<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_74.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><span>[75]</span><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_76.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 7e29bb4b779f4f35385e6f21994758845bf14d23
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 1 11:39:22 2009 -0400

    usb-serial: fix termios initialization logic
    
    This patch (as1288) fixes the initialization logic in
    serial_install().  A new tty always needs to have a termios
    initialized no matter what, not just in the case where the lower
    driver will override the termios settings.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/serial/usb-serial.c b/drivers/usb/serial/usb-serial.c
index 7d207d91a6a8..1bc0a24b896b 100644
--- a/drivers/usb/serial/usb-serial.c
+++ b/drivers/usb/serial/usb-serial.c
@@ -210,22 +210,21 @@ static int serial_install(struct tty_driver *driver, struct tty_struct *tty)
 	if (!try_module_get(serial-&gt;type-&gt;driver.owner))
 		goto error_module_get;
 
+	/* perform the standard setup */
+	retval = tty_init_termios(tty);
+	if (retval)
+		goto error_init_termios;
+
 	retval = usb_autopm_get_interface(serial-&gt;interface);
 	if (retval)
 		goto error_get_interface;
 
-	/* If the termios setup has yet to be done */
-	if (tty-&gt;driver-&gt;termios[idx] == NULL) {
-		/* perform the standard setup */
-		retval = tty_init_termios(tty);
-		if (retval)
-			goto error_init_termios;
-		/* allow the driver to update it */
-		if (serial-&gt;type-&gt;init_termios)
-			serial-&gt;type-&gt;init_termios(tty);
-	}
 	mutex_unlock(&amp;serial-&gt;disc_mutex);
 
+	/* allow the driver to update the settings */
+	if (serial-&gt;type-&gt;init_termios)
+		serial-&gt;type-&gt;init_termios(tty);
+
 	tty-&gt;driver_data = port;
 
 	/* Final install (we use the default method) */
@@ -234,9 +233,8 @@ static int serial_install(struct tty_driver *driver, struct tty_struct *tty)
 	driver-&gt;ttys[idx] = tty;
 	return retval;
 
- error_init_termios:
-	usb_autopm_put_interface(serial-&gt;interface);
  error_get_interface:
+ error_init_termios:
 	module_put(serial-&gt;type-&gt;driver.owner);
  error_module_get:
  error_no_port:</pre><hr><pre>commit cc56cd0157753c04a987888a2f793803df661a40
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 1 11:39:13 2009 -0400

    usb-serial: acquire references when a new tty is installed
    
    This patch (as1287) makes serial_install() be reponsible for acquiring
    references to the usb_serial structure and the driver module when a
    tty is first used.  This is more sensible than having serial_open() do
    it, because a tty can be opened many times whereas it is installed
    only once, when it is created.  (Not to mention that these actions are
    reversed when the tty is released, not when it is closed.)  Finally,
    it is at install time that the TTY core takes its own reference to the
    usb_serial module, so it is only fitting that we should act the same
    way in regard to the lower-level serial driver.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/serial/usb-serial.c b/drivers/usb/serial/usb-serial.c
index 87802ea8bbc8..7d207d91a6a8 100644
--- a/drivers/usb/serial/usb-serial.c
+++ b/drivers/usb/serial/usb-serial.c
@@ -187,100 +187,92 @@ void usb_serial_put(struct usb_serial *serial)
  * Create the termios objects for this tty.  We use the default
  * USB serial settings but permit them to be overridden by
  * serial-&gt;type-&gt;init_termios.
+ *
+ * This is the first place a new tty gets used.  Hence this is where we
+ * acquire references to the usb_serial structure and the driver module,
+ * where we store a pointer to the port, and where we do an autoresume.
+ * All these actions are reversed in serial_do_free().
  */
 static int serial_install(struct tty_driver *driver, struct tty_struct *tty)
 {
 	int idx = tty-&gt;index;
 	struct usb_serial *serial;
-	int retval;
+	struct usb_serial_port *port;
+	int retval = -ENODEV;
+
+	serial = usb_serial_get_by_index(idx);
+	if (!serial)
+		return retval;
+
+	port = serial-&gt;port[idx - serial-&gt;minor];
+	if (!port)
+		goto error_no_port;
+	if (!try_module_get(serial-&gt;type-&gt;driver.owner))
+		goto error_module_get;
+
+	retval = usb_autopm_get_interface(serial-&gt;interface);
+	if (retval)
+		goto error_get_interface;
 
 	/* If the termios setup has yet to be done */
 	if (tty-&gt;driver-&gt;termios[idx] == NULL) {
 		/* perform the standard setup */
 		retval = tty_init_termios(tty);
 		if (retval)
-			return retval;
+			goto error_init_termios;
 		/* allow the driver to update it */
-		serial = usb_serial_get_by_index(tty-&gt;index);
-		if (serial) {
-			if (serial-&gt;type-&gt;init_termios)
-				serial-&gt;type-&gt;init_termios(tty);
-			usb_serial_put(serial);
-			mutex_unlock(&amp;serial-&gt;disc_mutex);
-		}
+		if (serial-&gt;type-&gt;init_termios)
+			serial-&gt;type-&gt;init_termios(tty);
 	}
+	mutex_unlock(&amp;serial-&gt;disc_mutex);
+
+	tty-&gt;driver_data = port;
+
 	/* Final install (we use the default method) */
 	tty_driver_kref_get(driver);
 	tty-&gt;count++;
 	driver-&gt;ttys[idx] = tty;
-	return 0;
+	return retval;
+
+ error_init_termios:
+	usb_autopm_put_interface(serial-&gt;interface);
+ error_get_interface:
+	module_put(serial-&gt;type-&gt;driver.owner);
+ error_module_get:
+ error_no_port:
+	usb_serial_put(serial);
+	mutex_unlock(&amp;serial-&gt;disc_mutex);
+	return retval;
 }
 
 static int serial_open (struct tty_struct *tty, struct file *filp)
 {
 	struct usb_serial *serial;
 	struct usb_serial_port *port;
-	unsigned int portNumber;
 	int retval = 0;
 	int first = 0;
 
 	dbg("%s", __func__);
 
-	/* get the serial object associated with this tty pointer */
-	serial = usb_serial_get_by_index(tty-&gt;index);
-	if (!serial) {
-		tty-&gt;driver_data = NULL;
-		return -ENODEV;
-	}
-
-	portNumber = tty-&gt;index - serial-&gt;minor;
-	port = serial-&gt;port[portNumber];
-	if (!port || serial-&gt;disconnected)
-		retval = -ENODEV;
-	/*
-	 * Note: Our locking order requirement does not allow port-&gt;mutex
-	 * to be acquired while serial-&gt;disc_mutex is held.
-	 */
-	mutex_unlock(&amp;serial-&gt;disc_mutex);
-	if (retval)
-		goto bailout_serial_put;
+	port = tty-&gt;driver_data;
+	serial = port-&gt;serial;
 
-	if (mutex_lock_interruptible(&amp;port-&gt;mutex)) {
-		retval = -ERESTARTSYS;
-		goto bailout_serial_put;
-	}
+	if (mutex_lock_interruptible(&amp;port-&gt;mutex))
+		return -ERESTARTSYS;
 
 	++port-&gt;port.count;
-
-	/* set up our port structure making the tty driver
-	 * remember our port object, and us it */
-	tty-&gt;driver_data = port;
 	tty_port_tty_set(&amp;port-&gt;port, tty);
 
 	/* If the console is attached, the device is already open */
 	if (port-&gt;port.count == 1 &amp;&amp; !port-&gt;console) {
 		first = 1;
-		/* lock this module before we call it
-		 * this may fail, which means we must bail out,
-		 * safe because we are called with BKL held */
-		if (!try_module_get(serial-&gt;type-&gt;driver.owner)) {
-			retval = -ENODEV;
-			goto bailout_mutex_unlock;
-		}
-
 		mutex_lock(&amp;serial-&gt;disc_mutex);
-		if (serial-&gt;disconnected)
-			retval = -ENODEV;
-		else
-			retval = usb_autopm_get_interface(serial-&gt;interface);
-		if (retval)
-			goto bailout_module_put;
 
 		/* only call the device specific open if this
 		 * is the first time the port is opened */
 		retval = serial-&gt;type-&gt;open(tty, port);
 		if (retval)
-			goto bailout_interface_put;
+			goto bailout_module_put;
 		mutex_unlock(&amp;serial-&gt;disc_mutex);
 		set_bit(ASYNCB_INITIALIZED, &amp;port-&gt;port.flags);
 	}
@@ -297,18 +289,11 @@ static int serial_open (struct tty_struct *tty, struct file *filp)
 		goto bailout_mutex_unlock;
 	/* Undo the initial port actions */
 	mutex_lock(&amp;serial-&gt;disc_mutex);
-bailout_interface_put:
-	usb_autopm_put_interface(serial-&gt;interface);
 bailout_module_put:
 	mutex_unlock(&amp;serial-&gt;disc_mutex);
-	module_put(serial-&gt;type-&gt;driver.owner);
 bailout_mutex_unlock:
 	port-&gt;port.count = 0;
-	tty-&gt;driver_data = NULL;
-	tty_port_tty_set(&amp;port-&gt;port, NULL);
 	mutex_unlock(&amp;port-&gt;mutex);
-bailout_serial_put:
-	usb_serial_put(serial);
 	return retval;
 }
 
@@ -355,9 +340,6 @@ static void serial_close(struct tty_struct *tty, struct file *filp)
 {
 	struct usb_serial_port *port = tty-&gt;driver_data;
 
-	if (!port)
-		return;
-
 	dbg("%s - port %d", __func__, port-&gt;number);
 
 	if (tty_port_close_start(&amp;port-&gt;port, tty, filp) == 0)
@@ -365,7 +347,6 @@ static void serial_close(struct tty_struct *tty, struct file *filp)
 	serial_do_down(port);
 	tty_port_close_end(&amp;port-&gt;port, tty);
 	tty_port_tty_set(&amp;port-&gt;port, NULL);
-
 }
 
 /**
@@ -386,9 +367,11 @@ static void serial_do_free(struct tty_struct *tty)
 	/* The console is magical.  Do not hang up the console hardware
 	 * or there will be tears.
 	 */
-	if (port == NULL || port-&gt;console)
+	if (port-&gt;console)
 		return;
 
+	tty-&gt;driver_data = NULL;
+
 	serial = port-&gt;serial;
 	owner = serial-&gt;type-&gt;driver.owner;
 </pre><hr><pre>commit 8bc2c1b2daf95029658868cb1427baea2da87139
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 1 11:38:59 2009 -0400

    usb-serial: change logic of serial lookups
    
    This patch (as1286) changes usb_serial_get_by_index().  Now the
    routine will check whether the serial device has been disconnected; if
    it has then the return value will be NULL.  If the device hasn't been
    disconnected then the routine will return with serial-&gt;disc_mutex
    held, so that the caller can use the structure without fear of racing
    against driver unloads.
    
    This permits the scope of table_mutex in destroy_serial() to be
    reduced.  Instead of protecting the entire function, it suffices to
    protect the part that actually uses serial_table[], i.e., the call to
    return_serial().  There's no longer any danger of the refcount being
    incremented after it reaches 0 (which was the reason for having the
    large scope previously), because it can't reach 0 until the serial
    device has been disconnected.
    
    Also, the patch makes serial_install() check that serial is non-NULL
    before attempting to use it.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/serial/usb-serial.c b/drivers/usb/serial/usb-serial.c
index 266dc583867b..87802ea8bbc8 100644
--- a/drivers/usb/serial/usb-serial.c
+++ b/drivers/usb/serial/usb-serial.c
@@ -66,6 +66,11 @@ static struct usb_serial *serial_table[SERIAL_TTY_MINORS];
 static DEFINE_MUTEX(table_lock);
 static LIST_HEAD(usb_serial_driver_list);
 
+/*
+ * Look up the serial structure.  If it is found and it hasn't been
+ * disconnected, return with its disc_mutex held and its refcount
+ * incremented.  Otherwise return NULL.
+ */
 struct usb_serial *usb_serial_get_by_index(unsigned index)
 {
 	struct usb_serial *serial;
@@ -73,8 +78,15 @@ struct usb_serial *usb_serial_get_by_index(unsigned index)
 	mutex_lock(&amp;table_lock);
 	serial = serial_table[index];
 
-	if (serial)
-		kref_get(&amp;serial-&gt;kref);
+	if (serial) {
+		mutex_lock(&amp;serial-&gt;disc_mutex);
+		if (serial-&gt;disconnected) {
+			mutex_unlock(&amp;serial-&gt;disc_mutex);
+			serial = NULL;
+		} else {
+			kref_get(&amp;serial-&gt;kref);
+		}
+	}
 	mutex_unlock(&amp;table_lock);
 	return serial;
 }
@@ -123,8 +135,10 @@ static void return_serial(struct usb_serial *serial)
 
 	dbg("%s", __func__);
 
+	mutex_lock(&amp;table_lock);
 	for (i = 0; i &lt; serial-&gt;num_ports; ++i)
 		serial_table[serial-&gt;minor + i] = NULL;
+	mutex_unlock(&amp;table_lock);
 }
 
 static void destroy_serial(struct kref *kref)
@@ -158,9 +172,7 @@ static void destroy_serial(struct kref *kref)
 
 void usb_serial_put(struct usb_serial *serial)
 {
-	mutex_lock(&amp;table_lock);
 	kref_put(&amp;serial-&gt;kref, destroy_serial);
-	mutex_unlock(&amp;table_lock);
 }
 
 /*****************************************************************************
@@ -190,9 +202,12 @@ static int serial_install(struct tty_driver *driver, struct tty_struct *tty)
 			return retval;
 		/* allow the driver to update it */
 		serial = usb_serial_get_by_index(tty-&gt;index);
-		if (serial-&gt;type-&gt;init_termios)
-			serial-&gt;type-&gt;init_termios(tty);
-		usb_serial_put(serial);
+		if (serial) {
+			if (serial-&gt;type-&gt;init_termios)
+				serial-&gt;type-&gt;init_termios(tty);
+			usb_serial_put(serial);
+			mutex_unlock(&amp;serial-&gt;disc_mutex);
+		}
 	}
 	/* Final install (we use the default method) */
 	tty_driver_kref_get(driver);
@@ -218,7 +233,6 @@ static int serial_open (struct tty_struct *tty, struct file *filp)
 		return -ENODEV;
 	}
 
-	mutex_lock(&amp;serial-&gt;disc_mutex);
 	portNumber = tty-&gt;index - serial-&gt;minor;
 	port = serial-&gt;port[portNumber];
 	if (!port || serial-&gt;disconnected)
@@ -529,6 +543,7 @@ static int serial_proc_show(struct seq_file *m, void *v)
 
 		seq_putc(m, '\n');
 		usb_serial_put(serial);
+		mutex_unlock(&amp;serial-&gt;disc_mutex);
 	}
 	return 0;
 }</pre><hr><pre>commit f5b0953a89fa3407fb293cc54ead7d8feec489e4
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 1 11:38:44 2009 -0400

    usb-serial: put subroutines in logical order
    
    This patch (as1285) rearranges the subroutines in usb-serial.c
    concerned with tty lifetimes into a more logical order: install, open,
    hangup, close, release.  It also updates the formatting of the
    kerneldoc comments.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/serial/usb-serial.c b/drivers/usb/serial/usb-serial.c
index f1a1f0fb6d1b..266dc583867b 100644
--- a/drivers/usb/serial/usb-serial.c
+++ b/drivers/usb/serial/usb-serial.c
@@ -166,6 +166,41 @@ void usb_serial_put(struct usb_serial *serial)
 /*****************************************************************************
  * Driver tty interface functions
  *****************************************************************************/
+
+/**
+ * serial_install - install tty
+ * @driver: the driver (USB in our case)
+ * @tty: the tty being created
+ *
+ * Create the termios objects for this tty.  We use the default
+ * USB serial settings but permit them to be overridden by
+ * serial-&gt;type-&gt;init_termios.
+ */
+static int serial_install(struct tty_driver *driver, struct tty_struct *tty)
+{
+	int idx = tty-&gt;index;
+	struct usb_serial *serial;
+	int retval;
+
+	/* If the termios setup has yet to be done */
+	if (tty-&gt;driver-&gt;termios[idx] == NULL) {
+		/* perform the standard setup */
+		retval = tty_init_termios(tty);
+		if (retval)
+			return retval;
+		/* allow the driver to update it */
+		serial = usb_serial_get_by_index(tty-&gt;index);
+		if (serial-&gt;type-&gt;init_termios)
+			serial-&gt;type-&gt;init_termios(tty);
+		usb_serial_put(serial);
+	}
+	/* Final install (we use the default method) */
+	tty_driver_kref_get(driver);
+	tty-&gt;count++;
+	driver-&gt;ttys[idx] = tty;
+	return 0;
+}
+
 static int serial_open (struct tty_struct *tty, struct file *filp)
 {
 	struct usb_serial *serial;
@@ -264,13 +299,11 @@ static int serial_open (struct tty_struct *tty, struct file *filp)
 }
 
 /**
- *	serial_do_down		-	shut down hardware
- *	@port: port to shut down
+ * serial_do_down - shut down hardware
+ * @port: port to shut down
  *
- *	Shut down a USB port unless it is the console. We never shut down the
- *	console hardware as it will always be in use.
- *
- *	Don't free any resources at this point
+ * Shut down a USB serial port unless it is the console.  We never
+ * shut down the console hardware as it will always be in use.
  */
 static void serial_do_down(struct usb_serial_port *port)
 {
@@ -278,8 +311,10 @@ static void serial_do_down(struct usb_serial_port *port)
 	struct usb_serial *serial;
 	struct module *owner;
 
-	/* The console is magical, do not hang up the console hardware
-	   or there will be tears */
+	/*
+	 * The console is magical.  Do not hang up the console hardware
+	 * or there will be tears.
+	 */
 	if (port-&gt;console)
 		return;
 
@@ -293,24 +328,50 @@ static void serial_do_down(struct usb_serial_port *port)
 	mutex_unlock(&amp;port-&gt;mutex);
 }
 
+static void serial_hangup(struct tty_struct *tty)
+{
+	struct usb_serial_port *port = tty-&gt;driver_data;
+	serial_do_down(port);
+	tty_port_hangup(&amp;port-&gt;port);
+	/* We must not free port yet - the USB serial layer depends on it's
+	   continued existence */
+}
+
+static void serial_close(struct tty_struct *tty, struct file *filp)
+{
+	struct usb_serial_port *port = tty-&gt;driver_data;
+
+	if (!port)
+		return;
+
+	dbg("%s - port %d", __func__, port-&gt;number);
+
+	if (tty_port_close_start(&amp;port-&gt;port, tty, filp) == 0)
+		return;
+	serial_do_down(port);
+	tty_port_close_end(&amp;port-&gt;port, tty);
+	tty_port_tty_set(&amp;port-&gt;port, NULL);
+
+}
+
 /**
- *	serial_do_free		-	free resources post close/hangup
- *	@port: port to free up
+ * serial_do_free - free resources post close/hangup
+ * @port: port to free up
  *
- *	Do the resource freeing and refcount dropping for the port. We must
- *	be careful about ordering and we must avoid freeing up the console.
+ * Do the resource freeing and refcount dropping for the port.
+ * Avoid freeing the console.
  *
- *	Called when the last tty kref is dropped.
+ * Called when the last tty kref is dropped.
  */
-
 static void serial_do_free(struct tty_struct *tty)
 {
 	struct usb_serial_port *port = tty-&gt;driver_data;
 	struct usb_serial *serial;
 	struct module *owner;
 
-	/* The console is magical, do not hang up the console hardware
-	   or there will be tears */
+	/* The console is magical.  Do not hang up the console hardware
+	 * or there will be tears.
+	 */
 	if (port == NULL || port-&gt;console)
 		return;
 
@@ -326,32 +387,6 @@ static void serial_do_free(struct tty_struct *tty)
 	module_put(owner);
 }
 
-static void serial_close(struct tty_struct *tty, struct file *filp)
-{
-	struct usb_serial_port *port = tty-&gt;driver_data;
-
-	if (!port)
-		return;
-
-	dbg("%s - port %d", __func__, port-&gt;number);
-
-	if (tty_port_close_start(&amp;port-&gt;port, tty, filp) == 0)
-		return;
-	serial_do_down(port);		
-	tty_port_close_end(&amp;port-&gt;port, tty);
-	tty_port_tty_set(&amp;port-&gt;port, NULL);
-
-}
-
-static void serial_hangup(struct tty_struct *tty)
-{
-	struct usb_serial_port *port = tty-&gt;driver_data;
-	serial_do_down(port);
-	tty_port_hangup(&amp;port-&gt;port);
-	/* We must not free port yet - the USB serial layer depends on it's
-	   continued existence */
-}
-
 static int serial_write(struct tty_struct *tty, const unsigned char *buf,
 								int count)
 {
@@ -699,41 +734,6 @@ static const struct tty_port_operations serial_port_ops = {
 	.dtr_rts = serial_dtr_rts,
 };
 
-/**
- *	serial_install		-	install tty
- *	@driver: the driver (USB in our case)
- *	@tty: the tty being created
- *
- *	Create the termios objects for this tty. We use the default USB
- *	serial ones but permit them to be overriddenby serial-&gt;type-&gt;termios.
- *	This lets us remove all the ugly hackery
- */
-
-static int serial_install(struct tty_driver *driver, struct tty_struct *tty)
-{
-	int idx = tty-&gt;index;
-	struct usb_serial *serial;
-	int retval;
-
-	/* If the termios setup has yet to be done */
-	if (tty-&gt;driver-&gt;termios[idx] == NULL) {
-		/* perform the standard setup */
-		retval = tty_init_termios(tty);
-		if (retval)
-			return retval;
-		/* allow the driver to update it */
-		serial = usb_serial_get_by_index(tty-&gt;index);
-		if (serial-&gt;type-&gt;init_termios)
-			serial-&gt;type-&gt;init_termios(tty);
-		usb_serial_put(serial);
-	}
-	/* Final install (we use the default method) */
-	tty_driver_kref_get(driver);
-	tty-&gt;count++;
-	driver-&gt;ttys[idx] = tty;
-	return 0;
-}
-
 int usb_serial_probe(struct usb_interface *interface,
 			       const struct usb_device_id *id)
 {</pre><hr><pre>commit 41bd34ddd7aa46dbc03b5bb33896e0fa8100fe7b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 1 11:38:34 2009 -0400

    usb-serial: change referencing of port and serial structures
    
    This patch (as1284) changes the referencing of the usb_serial and
    usb_serial_port structures in usb-serial.c.  It's not feasible to make
    the port structures keep a reference to the serial structure, because
    the ports need to remain in existence when serial is released -- quite
    a few of the drivers expect this.  Consequently taking a reference
    to the port when the device file is open is insufficient; such a
    reference would not pin serial.
    
    To fix this, we now take a reference to serial when the device file is
    opened.  The final put_device() for the ports occurs in
    destroy_serial(), so that the ports will last as long as they are
    needed.
    
    The patch initializes all the port devices, including those in the
    unused "fake" ports.  This makes the code more uniform because they
    can all be released in the same way.  The error handling code in
    usb_serial_probe() is much simplified by this approach; instead of
    freeing everything by hand we can use a single usb_serial_put() call.
    
    Also simplified is the port-release mechanism.  Instead of being two
    separate routines, port_release() and port_free() can be combined into
    one.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/serial/usb-serial.c b/drivers/usb/serial/usb-serial.c
index 80c1f4d8e910..f1a1f0fb6d1b 100644
--- a/drivers/usb/serial/usb-serial.c
+++ b/drivers/usb/serial/usb-serial.c
@@ -43,8 +43,6 @@
 #define DRIVER_AUTHOR "Greg Kroah-Hartman, greg@kroah.com, http://www.kroah.com/linux/"
 #define DRIVER_DESC "USB Serial Driver core"
 
-static void port_free(struct usb_serial_port *port);
-
 /* Driver structure we register with the USB core */
 static struct usb_driver usb_serial_driver = {
 	.name =		"usbserial",
@@ -145,27 +143,16 @@ static void destroy_serial(struct kref *kref)
 
 	serial-&gt;type-&gt;release(serial);
 
-	for (i = 0; i &lt; serial-&gt;num_ports; ++i) {
+	/* Now that nothing is using the ports, they can be freed */
+	for (i = 0; i &lt; serial-&gt;num_port_pointers; ++i) {
 		port = serial-&gt;port[i];
-		if (port)
+		if (port) {
+			port-&gt;serial = NULL;
 			put_device(&amp;port-&gt;dev);
-	}
-
-	/* If this is a "fake" port, we have to clean it up here, as it will
-	 * not get cleaned up in port_release() as it was never registered with
-	 * the driver core */
-	if (serial-&gt;num_ports &lt; serial-&gt;num_port_pointers) {
-		for (i = serial-&gt;num_ports;
-					i &lt; serial-&gt;num_port_pointers; ++i) {
-			port = serial-&gt;port[i];
-			if (port)
-				port_free(port);
 		}
 	}
 
 	usb_put_dev(serial-&gt;dev);
-
-	/* free up any memory that we allocated */
 	kfree(serial);
 }
 
@@ -201,8 +188,6 @@ static int serial_open (struct tty_struct *tty, struct file *filp)
 	port = serial-&gt;port[portNumber];
 	if (!port || serial-&gt;disconnected)
 		retval = -ENODEV;
-	else
-		get_device(&amp;port-&gt;dev);
 	/*
 	 * Note: Our locking order requirement does not allow port-&gt;mutex
 	 * to be acquired while serial-&gt;disc_mutex is held.
@@ -213,7 +198,7 @@ static int serial_open (struct tty_struct *tty, struct file *filp)
 
 	if (mutex_lock_interruptible(&amp;port-&gt;mutex)) {
 		retval = -ERESTARTSYS;
-		goto bailout_port_put;
+		goto bailout_serial_put;
 	}
 
 	++port-&gt;port.count;
@@ -273,8 +258,6 @@ static int serial_open (struct tty_struct *tty, struct file *filp)
 	tty-&gt;driver_data = NULL;
 	tty_port_tty_set(&amp;port-&gt;port, NULL);
 	mutex_unlock(&amp;port-&gt;mutex);
-bailout_port_put:
-	put_device(&amp;port-&gt;dev);
 bailout_serial_put:
 	usb_serial_put(serial);
 	return retval;
@@ -333,14 +316,13 @@ static void serial_do_free(struct tty_struct *tty)
 
 	serial = port-&gt;serial;
 	owner = serial-&gt;type-&gt;driver.owner;
-	put_device(&amp;port-&gt;dev);
-	/* Mustn't dereference port any more */
+
 	mutex_lock(&amp;serial-&gt;disc_mutex);
 	if (!serial-&gt;disconnected)
 		usb_autopm_put_interface(serial-&gt;interface);
 	mutex_unlock(&amp;serial-&gt;disc_mutex);
+
 	usb_serial_put(serial);
-	/* Mustn't dereference serial any more */
 	module_put(owner);
 }
 
@@ -581,14 +563,6 @@ static void usb_serial_port_work(struct work_struct *work)
 	tty_kref_put(tty);
 }
 
-static void port_release(struct device *dev)
-{
-	struct usb_serial_port *port = to_usb_serial_port(dev);
-
-	dbg ("%s - %s", __func__, dev_name(dev));
-	port_free(port);
-}
-
 static void kill_traffic(struct usb_serial_port *port)
 {
 	usb_kill_urb(port-&gt;read_urb);
@@ -608,8 +582,12 @@ static void kill_traffic(struct usb_serial_port *port)
 	usb_kill_urb(port-&gt;interrupt_out_urb);
 }
 
-static void port_free(struct usb_serial_port *port)
+static void port_release(struct device *dev)
 {
+	struct usb_serial_port *port = to_usb_serial_port(dev);
+
+	dbg ("%s - %s", __func__, dev_name(dev));
+
 	/*
 	 * Stop all the traffic before cancelling the work, so that
 	 * nobody will restart it by calling usb_serial_port_softint.
@@ -955,6 +933,11 @@ int usb_serial_probe(struct usb_interface *interface,
 		mutex_init(&amp;port-&gt;mutex);
 		INIT_WORK(&amp;port-&gt;work, usb_serial_port_work);
 		serial-&gt;port[i] = port;
+		port-&gt;dev.parent = &amp;interface-&gt;dev;
+		port-&gt;dev.driver = NULL;
+		port-&gt;dev.bus = &amp;usb_serial_bus_type;
+		port-&gt;dev.release = &amp;port_release;
+		device_initialize(&amp;port-&gt;dev);
 	}
 
 	/* set up the endpoint information */
@@ -1097,15 +1080,10 @@ int usb_serial_probe(struct usb_interface *interface,
 	/* register all of the individual ports with the driver core */
 	for (i = 0; i &lt; num_ports; ++i) {
 		port = serial-&gt;port[i];
-		port-&gt;dev.parent = &amp;interface-&gt;dev;
-		port-&gt;dev.driver = NULL;
-		port-&gt;dev.bus = &amp;usb_serial_bus_type;
-		port-&gt;dev.release = &amp;port_release;
-
 		dev_set_name(&amp;port-&gt;dev, "ttyUSB%d", port-&gt;number);
 		dbg ("%s - registering %s", __func__, dev_name(&amp;port-&gt;dev));
 		port-&gt;dev_state = PORT_REGISTERING;
-		retval = device_register(&amp;port-&gt;dev);
+		retval = device_add(&amp;port-&gt;dev);
 		if (retval) {
 			dev_err(&amp;port-&gt;dev, "Error registering port device, "
 				"continuing\n");
@@ -1123,39 +1101,7 @@ int usb_serial_probe(struct usb_interface *interface,
 	return 0;
 
 probe_error:
-	for (i = 0; i &lt; num_bulk_in; ++i) {
-		port = serial-&gt;port[i];
-		if (!port)
-			continue;
-		usb_free_urb(port-&gt;read_urb);
-		kfree(port-&gt;bulk_in_buffer);
-	}
-	for (i = 0; i &lt; num_bulk_out; ++i) {
-		port = serial-&gt;port[i];
-		if (!port)
-			continue;
-		usb_free_urb(port-&gt;write_urb);
-		kfree(port-&gt;bulk_out_buffer);
-	}
-	for (i = 0; i &lt; num_interrupt_in; ++i) {
-		port = serial-&gt;port[i];
-		if (!port)
-			continue;
-		usb_free_urb(port-&gt;interrupt_in_urb);
-		kfree(port-&gt;interrupt_in_buffer);
-	}
-	for (i = 0; i &lt; num_interrupt_out; ++i) {
-		port = serial-&gt;port[i];
-		if (!port)
-			continue;
-		usb_free_urb(port-&gt;interrupt_out_urb);
-		kfree(port-&gt;interrupt_out_buffer);
-	}
-
-	/* free up any memory that we allocated */
-	for (i = 0; i &lt; serial-&gt;num_port_pointers; ++i)
-		kfree(serial-&gt;port[i]);
-	kfree(serial);
+	usb_serial_put(serial);
 	return -EIO;
 }
 EXPORT_SYMBOL_GPL(usb_serial_probe);
@@ -1206,8 +1152,7 @@ void usb_serial_disconnect(struct usb_interface *interface)
 	}
 	serial-&gt;type-&gt;disconnect(serial);
 
-	/* let the last holder of this object
-	 * cause it to be cleaned up */
+	/* let the last holder of this object cause it to be cleaned up */
 	usb_serial_put(serial);
 	dev_info(dev, "device disconnected\n");
 }</pre><hr><pre>commit 1f5c13fad4ec5617b610e12205902c06298c096a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Aug 20 15:23:47 2009 -0400

    TTY: fix typos
    
    This patch (as1282) fixes some obvious typos in the TTY core.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Alan Cox &lt;alan@lxorguk.ukuu.org.uk&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/char/tty_port.c b/drivers/char/tty_port.c
index c767e30a1425..a4bbb28f10be 100644
--- a/drivers/char/tty_port.c
+++ b/drivers/char/tty_port.c
@@ -100,7 +100,7 @@ EXPORT_SYMBOL(tty_port_tty_set);
 static void tty_port_shutdown(struct tty_port *port)
 {
 	if (port-&gt;ops-&gt;shutdown &amp;&amp;
-		test_and_clear_bit(ASYNC_INITIALIZED, &amp;port-&gt;flags))
+		test_and_clear_bit(ASYNCB_INITIALIZED, &amp;port-&gt;flags))
 			port-&gt;ops-&gt;shutdown(port);
 
 }
@@ -311,7 +311,7 @@ int tty_port_close_start(struct tty_port *port, struct tty_struct *tty, struct f
 			port-&gt;ops-&gt;drop(port);
 		return 0;
 	}
-	set_bit(ASYNC_CLOSING, &amp;port-&gt;flags);
+	set_bit(ASYNCB_CLOSING, &amp;port-&gt;flags);
 	tty-&gt;closing = 1;
 	spin_unlock_irqrestore(&amp;port-&gt;lock, flags);
 	/* Don't block on a stalled port, just pull the chain */</pre><hr><pre>commit 2023c610dc54a4f4130b0494309a9bd668ca3df8
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jul 30 15:27:18 2009 -0400

    Driver core: add new device to bus's list before probing
    
    This patch (as1271) affects when new devices get linked into their
    bus's list of devices.  Currently this happens after probing, and it
    doesn't happen at all if probing fails.  Clearly this is wrong,
    because at that point quite a few symbolic links have already been
    created in sysfs.  We are committed to adding the device, so it should
    be linked into the bus's list regardless.
    
    In addition, this needs to happen before the uevent announcing the new
    device gets issued.  Otherwise user programs might try to access the
    device before it has been added to the bus.
    
    To fix both these problems, the patch moves the call to
    klist_add_tail() forward from bus_attach_device() to bus_add_device().
    Since bus_attach_device() now does nothing but probe for drivers, it
    has been renamed to bus_probe_device().  And lastly, the kerneldoc is
    updated.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Kay Sievers &lt;kay.sievers@vrfy.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/base/base.h b/drivers/base/base.h
index b528145a078f..1e52c125f437 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -104,7 +104,7 @@ extern int system_bus_init(void);
 extern int cpu_dev_init(void);
 
 extern int bus_add_device(struct device *dev);
-extern void bus_attach_device(struct device *dev);
+extern void bus_probe_device(struct device *dev);
 extern void bus_remove_device(struct device *dev);
 
 extern int bus_add_driver(struct device_driver *drv);
diff --git a/drivers/base/bus.c b/drivers/base/bus.c
index 4b04a15146d7..973bf2ad4e0d 100644
--- a/drivers/base/bus.c
+++ b/drivers/base/bus.c
@@ -459,8 +459,9 @@ static inline void remove_deprecated_bus_links(struct device *dev) { }
  * bus_add_device - add device to bus
  * @dev: device being added
  *
+ * - Add device's bus attributes.
+ * - Create links to device's bus.
  * - Add the device to its bus's list of devices.
- * - Create link to device's bus.
  */
 int bus_add_device(struct device *dev)
 {
@@ -483,6 +484,7 @@ int bus_add_device(struct device *dev)
 		error = make_deprecated_bus_links(dev);
 		if (error)
 			goto out_deprecated;
+		klist_add_tail(&amp;dev-&gt;p-&gt;knode_bus, &amp;bus-&gt;p-&gt;klist_devices);
 	}
 	return 0;
 
@@ -498,24 +500,19 @@ int bus_add_device(struct device *dev)
 }
 
 /**
- * bus_attach_device - add device to bus
- * @dev: device tried to attach to a driver
+ * bus_probe_device - probe drivers for a new device
+ * @dev: device to probe
  *
- * - Add device to bus's list of devices.
- * - Try to attach to driver.
+ * - Automatically probe for a driver if the bus allows it.
  */
-void bus_attach_device(struct device *dev)
+void bus_probe_device(struct device *dev)
 {
 	struct bus_type *bus = dev-&gt;bus;
-	int ret = 0;
+	int ret;
 
-	if (bus) {
-		if (bus-&gt;p-&gt;drivers_autoprobe)
-			ret = device_attach(dev);
+	if (bus &amp;&amp; bus-&gt;p-&gt;drivers_autoprobe) {
+		ret = device_attach(dev);
 		WARN_ON(ret &lt; 0);
-		if (ret &gt;= 0)
-			klist_add_tail(&amp;dev-&gt;p-&gt;knode_bus,
-				       &amp;bus-&gt;p-&gt;klist_devices);
 	}
 }
 
diff --git a/drivers/base/core.c b/drivers/base/core.c
index 7ecb1938e590..c34774d0b9d3 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -945,7 +945,7 @@ int device_add(struct device *dev)
 					     BUS_NOTIFY_ADD_DEVICE, dev);
 
 	kobject_uevent(&amp;dev-&gt;kobj, KOBJ_ADD);
-	bus_attach_device(dev);
+	bus_probe_device(dev);
 	if (parent)
 		klist_add_tail(&amp;dev-&gt;p-&gt;knode_parent,
 			       &amp;parent-&gt;p-&gt;klist_children);</pre><hr><pre>commit ef4638f955f2c4a667c8af20769d03f5ed3781ca
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jul 31 10:41:40 2009 -0400

    USB: EHCI: fix counting of transaction error retries
    
    This patch (as1274) simplifies the counting of transaction-error
    retries.  Now we will count up from 0 to QH_XACTERR_MAX instead of
    down from QH_XACTERR_MAX to 0.
    
    The patch also fixes a small bug: qh-&gt;xacterr was not getting
    initialized for interrupt endpoints.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Matthijs Kooijman &lt;matthijs@stdin.nl&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index b27380505576..7673554fa64d 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -375,12 +375,11 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 				 */
 				if ((token &amp; QTD_STS_XACT) &amp;&amp;
 						QTD_CERR(token) == 0 &amp;&amp;
-						--qh-&gt;xacterrs &gt; 0 &amp;&amp;
+						++qh-&gt;xacterrs &lt; QH_XACTERR_MAX &amp;&amp;
 						!urb-&gt;unlinked) {
 					ehci_dbg(ehci,
 	"detected XactErr len %zu/%zu retry %d\n",
-	qtd-&gt;length - QTD_LENGTH(token), qtd-&gt;length,
-	QH_XACTERR_MAX - qh-&gt;xacterrs);
+	qtd-&gt;length - QTD_LENGTH(token), qtd-&gt;length, qh-&gt;xacterrs);
 
 					/* reset the token in the qtd and the
 					 * qh overlay (which still contains
@@ -494,7 +493,7 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 		last = qtd;
 
 		/* reinit the xacterr counter for the next qtd */
-		qh-&gt;xacterrs = QH_XACTERR_MAX;
+		qh-&gt;xacterrs = 0;
 	}
 
 	/* last urb's completion might still need calling */
@@ -941,7 +940,7 @@ static void qh_link_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	head-&gt;hw_next = dma;
 
 	qh_get(qh);
-	qh-&gt;xacterrs = QH_XACTERR_MAX;
+	qh-&gt;xacterrs = 0;
 	qh-&gt;qh_state = QH_STATE_LINKED;
 	/* qtd completions reported later by interrupt */
 }
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 74f7f83b29ad..edd61ee90323 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -542,6 +542,7 @@ static int qh_link_periodic (struct ehci_hcd *ehci, struct ehci_qh *qh)
 		}
 	}
 	qh-&gt;qh_state = QH_STATE_LINKED;
+	qh-&gt;xacterrs = 0;
 	qh_get (qh);
 
 	/* update per-qh bandwidth for usbfs */</pre><hr><pre>commit 7a0f0d951273eee889c2441846842348ebc00a2a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jul 31 10:40:22 2009 -0400

    USB: EHCI: fix two new bugs related to Clear-TT-Buffer
    
    This patch (as1273) fixes two(!) bugs introduced by the new
    Clear-TT-Buffer implementation in ehci-hcd.
    
            It is now possible for an idle QH to have some URBs on its
            queue -- this will happen if a Clear-TT-Buffer is pending for
            the QH's endpoint.  Consequently we should not issue a warning
            when someone tries to unlink an URB from an idle QH; instead
            we should process the request immediately.
    
            The refcounts for QHs could get messed up, because
            submit_async() would increment the refcount when calling
            qh_link_async() and qh_link_async() would then refuse to link
            the QH into the schedule if a Clear-TT-Buffer was pending.
            Instead we should increment the refcount only when the QH
            actually is added to the schedule.  The current code tries to
            be clever by leaving the refcount alone if an unlink is
            immediately followed by a relink; the patch changes this to an
            unconditional decrement and increment (although they occur in
            the opposite order).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    Tested-by: Manuel Lauss &lt;manuel.lauss@gmail.com&gt;
    Tested-by: Matthijs Kooijman &lt;matthijs@stdin.nl&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 7d03549c3339..11c627ce6022 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -903,7 +903,8 @@ static int ehci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 			/* already started */
 			break;
 		case QH_STATE_IDLE:
-			WARN_ON(1);
+			/* QH might be waiting for a Clear-TT-Buffer */
+			qh_completions(ehci, qh);
 			break;
 		}
 		break;
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 9a1384747f3b..b27380505576 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -940,6 +940,7 @@ static void qh_link_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	head-&gt;qh_next.qh = qh;
 	head-&gt;hw_next = dma;
 
+	qh_get(qh);
 	qh-&gt;xacterrs = QH_XACTERR_MAX;
 	qh-&gt;qh_state = QH_STATE_LINKED;
 	/* qtd completions reported later by interrupt */
@@ -1080,7 +1081,7 @@ submit_async (
 	 * the HC and TT handle it when the TT has a buffer ready.
 	 */
 	if (likely (qh-&gt;qh_state == QH_STATE_IDLE))
-		qh_link_async (ehci, qh_get (qh));
+		qh_link_async(ehci, qh);
  done:
 	spin_unlock_irqrestore (&amp;ehci-&gt;lock, flags);
 	if (unlikely (qh == NULL))
@@ -1115,8 +1116,6 @@ static void end_unlink_async (struct ehci_hcd *ehci)
 			&amp;&amp; HC_IS_RUNNING (ehci_to_hcd(ehci)-&gt;state))
 		qh_link_async (ehci, qh);
 	else {
-		qh_put (qh);		// refcount from async list
-
 		/* it's not free to turn the async schedule on/off; leave it
 		 * active but idle for a while once it empties.
 		 */
@@ -1124,6 +1123,7 @@ static void end_unlink_async (struct ehci_hcd *ehci)
 				&amp;&amp; ehci-&gt;async-&gt;qh_next.qh == NULL)
 			timer_action (ehci, TIMER_ASYNC_OFF);
 	}
+	qh_put(qh);			/* refcount from async list */
 
 	if (next) {
 		ehci-&gt;reclaim = NULL;</pre><hr><pre>commit 01105a246345f011fde64d24a601090b646e9e4c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jul 30 15:28:14 2009 -0400

    USB: usbfs: fix -ENOENT error code to be -ENODEV
    
    This patch (as1272) changes the error code returned when an open call
    for a USB device node fails to locate the corresponding device.  The
    appropriate error code is -ENODEV, not -ENOENT.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Kay Sievers &lt;kay.sievers@vrfy.org&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index e192fa05f8a1..4247eccf858c 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -595,7 +595,7 @@ static int usbdev_open(struct inode *inode, struct file *file)
 	if (!ps)
 		goto out;
 
-	ret = -ENOENT;
+	ret = -ENODEV;
 
 	/* usbdev device-node */
 	if (imajor(inode) == USB_DEVICE_MAJOR)</pre>
    <div class="pagination">
        <a href='2_74.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><span>[75]</span><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_76.html'>Next&gt;&gt;</a>
    <div>
</body>
