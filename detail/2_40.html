<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_39.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><span>[40]</span><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_41.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 6e0c3339a6f19d748f16091d0a05adeb1e1f822b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jan 25 16:54:22 2013 -0500

    USB: EHCI: unlink one async QH at a time
    
    This patch (as1648) fixes a regression affecting nVidia EHCI
    controllers.  Evidently they don't like to have more than one async QH
    unlinked at a time.  I can't imagine how they manage to mess it up,
    but at least one of them does.
    
    The patch changes the async unlink logic in two ways:
    
            Each time an IAA cycle is started, only the first QH on the
            async unlink list is handled (rather than all of them).
    
            Async QHs do not all get unlinked as soon as they have been
            empty for long enough.  Instead, only the last one (i.e., the
            one that has been on the schedule the longest) is unlinked,
            and then only if no other unlinks are in progress at the time.
    
    This means that when multiple QHs are empty, they won't be unlinked as
    quickly as before.  That's okay; it won't affect correct operation of
    the driver or add an excessive load.  Multiple unlinks tend to be
    relatively rare in any case.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Piergiorgio Sartor &lt;piergiorgio.sartor@nexgo.de&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt; # 3.6
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 3d989028c836..fd252f0cfb3a 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -1197,17 +1197,26 @@ static void start_iaa_cycle(struct ehci_hcd *ehci, bool nested)
 	if (ehci-&gt;async_iaa || ehci-&gt;async_unlinking)
 		return;
 
-	/* Do all the waiting QHs at once */
-	ehci-&gt;async_iaa = ehci-&gt;async_unlink;
-	ehci-&gt;async_unlink = NULL;
-
 	/* If the controller isn't running, we don't have to wait for it */
 	if (unlikely(ehci-&gt;rh_state &lt; EHCI_RH_RUNNING)) {
+
+		/* Do all the waiting QHs */
+		ehci-&gt;async_iaa = ehci-&gt;async_unlink;
+		ehci-&gt;async_unlink = NULL;
+
 		if (!nested)		/* Avoid recursion */
 			end_unlink_async(ehci);
 
 	/* Otherwise start a new IAA cycle */
 	} else if (likely(ehci-&gt;rh_state == EHCI_RH_RUNNING)) {
+		struct ehci_qh		*qh;
+
+		/* Do only the first waiting QH (nVidia bug?) */
+		qh = ehci-&gt;async_unlink;
+		ehci-&gt;async_iaa = qh;
+		ehci-&gt;async_unlink = qh-&gt;unlink_next;
+		qh-&gt;unlink_next = NULL;
+
 		/* Make sure the unlinks are all visible to the hardware */
 		wmb();
 
@@ -1255,34 +1264,35 @@ static void end_unlink_async(struct ehci_hcd *ehci)
 	}
 }
 
+static void start_unlink_async(struct ehci_hcd *ehci, struct ehci_qh *qh);
+
 static void unlink_empty_async(struct ehci_hcd *ehci)
 {
-	struct ehci_qh		*qh, *next;
-	bool			stopped = (ehci-&gt;rh_state &lt; EHCI_RH_RUNNING);
+	struct ehci_qh		*qh;
+	struct ehci_qh		*qh_to_unlink = NULL;
 	bool			check_unlinks_later = false;
+	int			count = 0;
 
-	/* Unlink all the async QHs that have been empty for a timer cycle */
-	next = ehci-&gt;async-&gt;qh_next.qh;
-	while (next) {
-		qh = next;
-		next = qh-&gt;qh_next.qh;
-
+	/* Find the last async QH which has been empty for a timer cycle */
+	for (qh = ehci-&gt;async-&gt;qh_next.qh; qh; qh = qh-&gt;qh_next.qh) {
 		if (list_empty(&amp;qh-&gt;qtd_list) &amp;&amp;
 				qh-&gt;qh_state == QH_STATE_LINKED) {
-			if (!stopped &amp;&amp; qh-&gt;unlink_cycle ==
-					ehci-&gt;async_unlink_cycle)
+			++count;
+			if (qh-&gt;unlink_cycle == ehci-&gt;async_unlink_cycle)
 				check_unlinks_later = true;
 			else
-				single_unlink_async(ehci, qh);
+				qh_to_unlink = qh;
 		}
 	}
 
-	/* Start a new IAA cycle if any QHs are waiting for it */
-	if (ehci-&gt;async_unlink)
-		start_iaa_cycle(ehci, false);
+	/* If nothing else is being unlinked, unlink the last empty QH */
+	if (!ehci-&gt;async_iaa &amp;&amp; !ehci-&gt;async_unlink &amp;&amp; qh_to_unlink) {
+		start_unlink_async(ehci, qh_to_unlink);
+		--count;
+	}
 
-	/* QHs that haven't been empty for long enough will be handled later */
-	if (check_unlinks_later) {
+	/* Other QHs will be handled later */
+	if (count &gt; 0) {
 		ehci_enable_event(ehci, EHCI_HRTIMER_ASYNC_UNLINKS, true);
 		++ehci-&gt;async_unlink_cycle;
 	}</pre><hr><pre>commit 55bcdce8a8228223ec4d17d8ded8134ed265d2c5
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jan 25 16:52:45 2013 -0500

    USB: EHCI: remove ASS/PSS polling timeout
    
    This patch (as1647) attempts to work around a problem that seems to
    affect some nVidia EHCI controllers.  They sometimes take a very long
    time to turn off their async or periodic schedules.  I don't know if
    this is a result of other problems, but in any case it seems wise not
    to depend on schedule enables or disables taking effect in any
    specific length of time.
    
    The patch removes the existing 20-ms timeout for enabling and
    disabling the schedules.  The driver will now continue to poll the
    schedule state at 1-ms intervals until the controller finally decides
    to obey the most recent command issued by the driver.  Just in case
    this hides a problem, a debugging message will be logged if the
    controller takes longer than 20 polls.
    
    I don't know if this will actually fix anything, but it can't hurt.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Piergiorgio Sartor &lt;piergiorgio.sartor@nexgo.de&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index 20dbdcbe9b0f..f904071d70df 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -113,14 +113,15 @@ static void ehci_poll_ASS(struct ehci_hcd *ehci)
 
 	if (want != actual) {
 
-		/* Poll again later, but give up after about 20 ms */
-		if (ehci-&gt;ASS_poll_count++ &lt; 20) {
-			ehci_enable_event(ehci, EHCI_HRTIMER_POLL_ASS, true);
-			return;
-		}
-		ehci_dbg(ehci, "Waited too long for the async schedule status (%x/%x), giving up\n",
-				want, actual);
+		/* Poll again later */
+		ehci_enable_event(ehci, EHCI_HRTIMER_POLL_ASS, true);
+		++ehci-&gt;ASS_poll_count;
+		return;
 	}
+
+	if (ehci-&gt;ASS_poll_count &gt; 20)
+		ehci_dbg(ehci, "ASS poll count reached %d\n",
+				ehci-&gt;ASS_poll_count);
 	ehci-&gt;ASS_poll_count = 0;
 
 	/* The status is up-to-date; restart or stop the schedule as needed */
@@ -159,14 +160,14 @@ static void ehci_poll_PSS(struct ehci_hcd *ehci)
 
 	if (want != actual) {
 
-		/* Poll again later, but give up after about 20 ms */
-		if (ehci-&gt;PSS_poll_count++ &lt; 20) {
-			ehci_enable_event(ehci, EHCI_HRTIMER_POLL_PSS, true);
-			return;
-		}
-		ehci_dbg(ehci, "Waited too long for the periodic schedule status (%x/%x), giving up\n",
-				want, actual);
+		/* Poll again later */
+		ehci_enable_event(ehci, EHCI_HRTIMER_POLL_PSS, true);
+		return;
 	}
+
+	if (ehci-&gt;PSS_poll_count &gt; 20)
+		ehci_dbg(ehci, "PSS poll count reached %d\n",
+				ehci-&gt;PSS_poll_count);
 	ehci-&gt;PSS_poll_count = 0;
 
 	/* The status is up-to-date; restart or stop the schedule as needed */</pre><hr><pre>commit bdb6bc06f7d694652c12fb8779bb031c2f220823
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jan 24 15:04:13 2013 -0500

    USB: fix sign-extension bug in the hub driver
    
    This patch (as1646) fixes a long-standing bug in the USB hub driver.
    Upon conversion from char to unsigned long, the bytes in the status
    buffer are subject to unwanted sign extension.  The bytes should be
    declared as u8 rather than char, to prevent this.
    
    This effects of this bug are minimal.  The hub driver may end up doing
    a little unnecessary extra work because it thinks events have occurred
    on some ports when they really haven't.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index d16a7c98aea9..c472058f8f27 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -31,7 +31,7 @@ struct usb_hub {
 	struct urb		*urb;		/* for interrupt polling pipe */
 
 	/* buffer for urb ... with extra space in case of babble */
-	char			(*buffer)[8];
+	u8			(*buffer)[8];
 	union {
 		struct usb_hub_status	hub;
 		struct usb_port_status	port;</pre><hr><pre>commit 48c3375c5f69b1c2ef3d1051a0009cb9bce0ce24
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jan 17 10:32:16 2013 -0500

    USB: XHCI: fix memory leak of URB-private data
    
    This patch (as1640) fixes a memory leak in xhci-hcd.  The urb_priv
    data structure isn't always deallocated in the handle_tx_event()
    routine for non-control transfers.  The patch adds a kfree() call so
    that all paths end up freeing the memory properly.
    
    This patch should be backported to kernels as old as 2.6.36, that
    contain the commit 8e51adccd4c4b9ffcd509d7f2afce0a906139f75 "USB: xHCI:
    Introduce urb_priv structure"
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Sarah Sharp &lt;sarah.a.sharp@linux.intel.com&gt;
    Reported-and-tested-by: Martin Mokrejs &lt;mmokrejs@fold.natur.cuni.cz&gt;
    CC: &lt;stable@vger.kernel.org&gt;

diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c
index 151204642a6e..7f76a49e90d3 100644
--- a/drivers/usb/host/xhci-ring.c
+++ b/drivers/usb/host/xhci-ring.c
@@ -2589,6 +2589,8 @@ static int handle_tx_event(struct xhci_hcd *xhci,
 				(trb_comp_code != COMP_STALL &amp;&amp;
 					trb_comp_code != COMP_BABBLE))
 				xhci_urb_free_priv(xhci, urb_priv);
+			else
+				kfree(urb_priv);
 
 			usb_hcd_unlink_urb_from_ep(bus_to_hcd(urb-&gt;dev-&gt;bus), urb);
 			if ((urb-&gt;actual_length != urb-&gt;transfer_buffer_length &amp;&amp;</pre><hr><pre>commit dba63b2f733ebfd89bbb15e8fe8ca10fd3871a7f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jan 23 13:26:15 2013 -0500

    USB: EHCI: fix build error in ehci-mxc
    
    This patch (as1643b) fixes a build error in ehci-hcd when compiling for
    ARM with allmodconfig:
    
    drivers/usb/host/ehci-hcd.c:1285:0: warning: "PLATFORM_DRIVER" redefined [enabled by default]
    drivers/usb/host/ehci-hcd.c:1255:0: note: this is the location of the previous definition
    drivers/usb/host/ehci-mxc.c:280:31: warning: 'ehci_mxc_driver' defined but not used [-Wunused-variable]
    drivers/usb/host/ehci-hcd.c:1285:0: warning: "PLATFORM_DRIVER" redefined [enabled by default]
    drivers/usb/host/ehci-hcd.c:1255:0: note: this is the location of the previous definition
    
    The fix is to convert ehci-mxc over to the new "ehci-hcd is a library"
    scheme so that it can coexist peacefully with the ehci-platform
    driver.  As part of the conversion the ehci_mxc_priv data structure,
    which was allocated dynamically, is now placed where it belongs: in
    the private area at the end of struct ehci_hcd.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Shawn Guo &lt;shawn.guo@linaro.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index d6bb128ce21e..3a21c5d683c0 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -148,7 +148,7 @@ config USB_EHCI_FSL
 	  Variation of ARC USB block used in some Freescale chips.
 
 config USB_EHCI_MXC
-	bool "Support for Freescale i.MX on-chip EHCI USB controller"
+	tristate "Support for Freescale i.MX on-chip EHCI USB controller"
 	depends on USB_EHCI_HCD &amp;&amp; ARCH_MXC
 	select USB_EHCI_ROOT_HUB_TT
 	---help---
diff --git a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
index 1eb4c3006e9e..001fbff2fdef 100644
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -26,6 +26,7 @@ obj-$(CONFIG_PCI)		+= pci-quirks.o
 obj-$(CONFIG_USB_EHCI_HCD)	+= ehci-hcd.o
 obj-$(CONFIG_USB_EHCI_PCI)	+= ehci-pci.o
 obj-$(CONFIG_USB_EHCI_HCD_PLATFORM)	+= ehci-platform.o
+obj-$(CONFIG_USB_EHCI_MXC)	+= ehci-mxc.o
 
 obj-$(CONFIG_USB_OXU210HP_HCD)	+= oxu210hp-hcd.o
 obj-$(CONFIG_USB_ISP116X_HCD)	+= isp116x-hcd.o
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index d09ff8f294fe..09537b2f1002 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1246,11 +1246,6 @@ MODULE_LICENSE ("GPL");
 #define	PLATFORM_DRIVER		ehci_fsl_driver
 #endif
 
-#ifdef CONFIG_USB_EHCI_MXC
-#include "ehci-mxc.c"
-#define PLATFORM_DRIVER		ehci_mxc_driver
-#endif
-
 #ifdef CONFIG_USB_EHCI_SH
 #include "ehci-sh.c"
 #define PLATFORM_DRIVER		ehci_hcd_sh_driver
@@ -1349,6 +1344,7 @@ MODULE_LICENSE ("GPL");
 #if !IS_ENABLED(CONFIG_USB_EHCI_PCI) &amp;&amp; \
 	!IS_ENABLED(CONFIG_USB_EHCI_HCD_PLATFORM) &amp;&amp; \
 	!IS_ENABLED(CONFIG_USB_CHIPIDEA_HOST) &amp;&amp; \
+	!IS_ENABLED(CONFIG_USB_EHCI_MXC) &amp;&amp; \
 	!defined(PLATFORM_DRIVER) &amp;&amp; \
 	!defined(PS3_SYSTEM_BUS_DRIVER) &amp;&amp; \
 	!defined(OF_PLATFORM_DRIVER) &amp;&amp; \
diff --git a/drivers/usb/host/ehci-mxc.c b/drivers/usb/host/ehci-mxc.c
index ec7f5d2c90de..dedb80bb8d40 100644
--- a/drivers/usb/host/ehci-mxc.c
+++ b/drivers/usb/host/ehci-mxc.c
@@ -17,75 +17,38 @@
  * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
+#include &lt;linux/kernel.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/io.h&gt;
 #include &lt;linux/platform_device.h&gt;
 #include &lt;linux/clk.h&gt;
 #include &lt;linux/delay.h&gt;
 #include &lt;linux/usb/otg.h&gt;
 #include &lt;linux/usb/ulpi.h&gt;
 #include &lt;linux/slab.h&gt;
+#include &lt;linux/usb.h&gt;
+#include &lt;linux/usb/hcd.h&gt;
 
 #include &lt;linux/platform_data/usb-ehci-mxc.h&gt;
 
 #include &lt;asm/mach-types.h&gt;
 
+#include "ehci.h"
+
+#define DRIVER_DESC "Freescale On-Chip EHCI Host driver"
+
+static const char hcd_name[] = "ehci-mxc";
+
 #define ULPI_VIEWPORT_OFFSET	0x170
 
 struct ehci_mxc_priv {
 	struct clk *usbclk, *ahbclk, *phyclk;
-	struct usb_hcd *hcd;
 };
 
-/* called during probe() after chip reset completes */
-static int ehci_mxc_setup(struct usb_hcd *hcd)
-{
-	hcd-&gt;has_tt = 1;
-
-	return ehci_setup(hcd);
-}
+static struct hc_driver __read_mostly ehci_mxc_hc_driver;
 
-static const struct hc_driver ehci_mxc_hc_driver = {
-	.description = hcd_name,
-	.product_desc = "Freescale On-Chip EHCI Host Controller",
-	.hcd_priv_size = sizeof(struct ehci_hcd),
-
-	/*
-	 * generic hardware linkage
-	 */
-	.irq = ehci_irq,
-	.flags = HCD_USB2 | HCD_MEMORY,
-
-	/*
-	 * basic lifecycle operations
-	 */
-	.reset = ehci_mxc_setup,
-	.start = ehci_run,
-	.stop = ehci_stop,
-	.shutdown = ehci_shutdown,
-
-	/*
-	 * managing i/o requests and associated device resources
-	 */
-	.urb_enqueue = ehci_urb_enqueue,
-	.urb_dequeue = ehci_urb_dequeue,
-	.endpoint_disable = ehci_endpoint_disable,
-	.endpoint_reset = ehci_endpoint_reset,
-
-	/*
-	 * scheduling support
-	 */
-	.get_frame_number = ehci_get_frame,
-
-	/*
-	 * root hub support
-	 */
-	.hub_status_data = ehci_hub_status_data,
-	.hub_control = ehci_hub_control,
-	.bus_suspend = ehci_bus_suspend,
-	.bus_resume = ehci_bus_resume,
-	.relinquish_port = ehci_relinquish_port,
-	.port_handed_over = ehci_port_handed_over,
-
-	.clear_tt_buffer_complete = ehci_clear_tt_buffer_complete,
+static const struct ehci_driver_overrides ehci_mxc_overrides __initdata = {
+	.extra_priv_size =	sizeof(struct ehci_mxc_priv),
 };
 
 static int ehci_mxc_drv_probe(struct platform_device *pdev)
@@ -112,12 +75,6 @@ static int ehci_mxc_drv_probe(struct platform_device *pdev)
 	if (!hcd)
 		return -ENOMEM;
 
-	priv = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(*priv), GFP_KERNEL);
-	if (!priv) {
-		ret = -ENOMEM;
-		goto err_alloc;
-	}
-
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res) {
 		dev_err(dev, "Found HC with no register addr. Check setup!\n");
@@ -135,6 +92,10 @@ static int ehci_mxc_drv_probe(struct platform_device *pdev)
 		goto err_alloc;
 	}
 
+	hcd-&gt;has_tt = 1;
+	ehci = hcd_to_ehci(hcd);
+	priv = (struct ehci_mxc_priv *) ehci-&gt;priv;
+
 	/* enable clocks */
 	priv-&gt;usbclk = devm_clk_get(&amp;pdev-&gt;dev, "ipg");
 	if (IS_ERR(priv-&gt;usbclk)) {
@@ -169,8 +130,6 @@ static int ehci_mxc_drv_probe(struct platform_device *pdev)
 		mdelay(10);
 	}
 
-	ehci = hcd_to_ehci(hcd);
-
 	/* EHCI registers start at offset 0x100 */
 	ehci-&gt;caps = hcd-&gt;regs + 0x100;
 	ehci-&gt;regs = hcd-&gt;regs + 0x100 +
@@ -198,8 +157,7 @@ static int ehci_mxc_drv_probe(struct platform_device *pdev)
 		}
 	}
 
-	priv-&gt;hcd = hcd;
-	platform_set_drvdata(pdev, priv);
+	platform_set_drvdata(pdev, hcd);
 
 	ret = usb_add_hcd(hcd, irq, IRQF_SHARED);
 	if (ret)
@@ -244,8 +202,11 @@ static int ehci_mxc_drv_probe(struct platform_device *pdev)
 static int __exit ehci_mxc_drv_remove(struct platform_device *pdev)
 {
 	struct mxc_usbh_platform_data *pdata = pdev-&gt;dev.platform_data;
-	struct ehci_mxc_priv *priv = platform_get_drvdata(pdev);
-	struct usb_hcd *hcd = priv-&gt;hcd;
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	struct ehci_mxc_priv *priv = (struct ehci_mxc_priv *) ehci-&gt;priv;
+
+	usb_remove_hcd(hcd);
 
 	if (pdata &amp;&amp; pdata-&gt;exit)
 		pdata-&gt;exit(pdev);
@@ -253,23 +214,20 @@ static int __exit ehci_mxc_drv_remove(struct platform_device *pdev)
 	if (pdata-&gt;otg)
 		usb_phy_shutdown(pdata-&gt;otg);
 
-	usb_remove_hcd(hcd);
-	usb_put_hcd(hcd);
-	platform_set_drvdata(pdev, NULL);
-
 	clk_disable_unprepare(priv-&gt;usbclk);
 	clk_disable_unprepare(priv-&gt;ahbclk);
 
 	if (priv-&gt;phyclk)
 		clk_disable_unprepare(priv-&gt;phyclk);
 
+	usb_put_hcd(hcd);
+	platform_set_drvdata(pdev, NULL);
 	return 0;
 }
 
 static void ehci_mxc_drv_shutdown(struct platform_device *pdev)
 {
-	struct ehci_mxc_priv *priv = platform_get_drvdata(pdev);
-	struct usb_hcd *hcd = priv-&gt;hcd;
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
 
 	if (hcd-&gt;driver-&gt;shutdown)
 		hcd-&gt;driver-&gt;shutdown(hcd);
@@ -279,9 +237,31 @@ MODULE_ALIAS("platform:mxc-ehci");
 
 static struct platform_driver ehci_mxc_driver = {
 	.probe = ehci_mxc_drv_probe,
-	.remove = __exit_p(ehci_mxc_drv_remove),
+	.remove = ehci_mxc_drv_remove,
 	.shutdown = ehci_mxc_drv_shutdown,
 	.driver = {
 		   .name = "mxc-ehci",
 	},
 };
+
+static int __init ehci_mxc_init(void)
+{
+	if (usb_disabled())
+		return -ENODEV;
+
+	pr_info("%s: " DRIVER_DESC "\n", hcd_name);
+
+	ehci_init_driver(&amp;ehci_mxc_hc_driver, &amp;ehci_mxc_overrides);
+	return platform_driver_register(&amp;ehci_mxc_driver);
+}
+module_init(ehci_mxc_init);
+
+static void __exit ehci_mxc_cleanup(void)
+{
+	platform_driver_unregister(&amp;ehci_mxc_driver);
+}
+module_exit(ehci_mxc_cleanup);
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_AUTHOR("Sascha Hauer");
+MODULE_LICENSE("GPL");</pre><hr><pre>commit 9debc1793b36124b9304255d2e8b5b6d8b491793
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jan 22 12:00:26 2013 -0500

    USB: EHCI: add a name for the platform-private field
    
    This patch (as1642) adds an ehci-&gt;priv field for private use by EHCI
    platform drivers.  The space was provided some time ago, but it didn't
    have a name.
    
    Until now none of the platform drivers has used this private space,
    but that's about to change in the next patch of this series.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 88f0142aea0c..36c3a8210595 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -225,6 +225,9 @@ struct ehci_hcd {			/* one per controller */
 #ifdef DEBUG
 	struct dentry		*debug_dir;
 #endif
+
+	/* platform-specific data -- must come last */
+	unsigned long		priv[0] __aligned(sizeof(s64));
 };
 
 /* convert between an HCD pointer and the corresponding EHCI_HCD */</pre><hr><pre>commit 9ce45ef86c4c861841ba68b24341dbd9d6834c98
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jan 22 12:00:12 2013 -0500

    USB: EHCI: fix incorrect configuration test
    
    This patch (as1641) fixes a minor bug in ehci-hcd left over from when
    the Chipidea driver was converted to the "ehci-hcd is a library"
    scheme.  The test for whether the Chipidea platform driver is active
    should be IS_ENABLED(), not defined().
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 104d6348377e..d09ff8f294fe 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1348,7 +1348,7 @@ MODULE_LICENSE ("GPL");
 
 #if !IS_ENABLED(CONFIG_USB_EHCI_PCI) &amp;&amp; \
 	!IS_ENABLED(CONFIG_USB_EHCI_HCD_PLATFORM) &amp;&amp; \
-	!defined(CONFIG_USB_CHIPIDEA_HOST) &amp;&amp; \
+	!IS_ENABLED(CONFIG_USB_CHIPIDEA_HOST) &amp;&amp; \
 	!defined(PLATFORM_DRIVER) &amp;&amp; \
 	!defined(PS3_SYSTEM_BUS_DRIVER) &amp;&amp; \
 	!defined(OF_PLATFORM_DRIVER) &amp;&amp; \</pre><hr><pre>commit 0f815a0a700bc10547449bde6c106051a035a1b9
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jan 22 11:37:35 2013 -0500

    USB: UHCI: fix IRQ race during initialization
    
    This patch (as1644) fixes a race that occurs during startup in
    uhci-hcd.  If the IRQ line is shared with other devices, it's possible
    for the handler routine to be called before the data structures are
    fully initialized.
    
    The problem is fixed by adding a check to the IRQ handler routine.  If
    the initialization hasn't finished yet, the routine will return
    immediately.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Don Zickus &lt;dzickus@redhat.com&gt;
    Tested-by: "Huang, Adrian (ISS Linux TW)" &lt;adrian.huang@hp.com&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 4b9e9aba2665..4f64d24eebc8 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -447,6 +447,10 @@ static irqreturn_t uhci_irq(struct usb_hcd *hcd)
 		return IRQ_NONE;
 	uhci_writew(uhci, status, USBSTS);		/* Clear it */
 
+	spin_lock(&amp;uhci-&gt;lock);
+	if (unlikely(!uhci-&gt;is_initialized))	/* not yet configured */
+		goto done;
+
 	if (status &amp; ~(USBSTS_USBINT | USBSTS_ERROR | USBSTS_RD)) {
 		if (status &amp; USBSTS_HSE)
 			dev_err(uhci_dev(uhci), "host system error, "
@@ -455,7 +459,6 @@ static irqreturn_t uhci_irq(struct usb_hcd *hcd)
 			dev_err(uhci_dev(uhci), "host controller process "
 					"error, something bad happened!\n");
 		if (status &amp; USBSTS_HCH) {
-			spin_lock(&amp;uhci-&gt;lock);
 			if (uhci-&gt;rh_state &gt;= UHCI_RH_RUNNING) {
 				dev_err(uhci_dev(uhci),
 					"host controller halted, "
@@ -473,15 +476,15 @@ static irqreturn_t uhci_irq(struct usb_hcd *hcd)
 				 * pending unlinks */
 				mod_timer(&amp;hcd-&gt;rh_timer, jiffies);
 			}
-			spin_unlock(&amp;uhci-&gt;lock);
 		}
 	}
 
-	if (status &amp; USBSTS_RD)
+	if (status &amp; USBSTS_RD) {
+		spin_unlock(&amp;uhci-&gt;lock);
 		usb_hcd_poll_rh_status(hcd);
-	else {
-		spin_lock(&amp;uhci-&gt;lock);
+	} else {
 		uhci_scan_schedule(uhci);
+ done:
 		spin_unlock(&amp;uhci-&gt;lock);
 	}
 
@@ -662,9 +665,9 @@ static int uhci_start(struct usb_hcd *hcd)
 	 */
 	mb();
 
+	spin_lock_irq(&amp;uhci-&gt;lock);
 	configure_hc(uhci);
 	uhci-&gt;is_initialized = 1;
-	spin_lock_irq(&amp;uhci-&gt;lock);
 	start_rh(uhci);
 	spin_unlock_irq(&amp;uhci-&gt;lock);
 	return 0;</pre><hr><pre>commit 2cb5000057fbd2237c19b8b8bd4f6948fd11f5f8
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jan 2 13:58:18 2013 -0500

    USB: usbtest: fix test number in log message
    
    This patch (as1639) fixes a minor bug in the usbtest driver.  Due to
    concurrent changes, a test originally written as number 17 got changed
    to number 24, but the corresponding change was not made in the log
    message.  This updates the log message.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 7667b12f2ff5..268148de9714 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -2179,7 +2179,7 @@ usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)
 		if (dev-&gt;out_pipe == 0 || !param-&gt;length || param-&gt;sglen &lt; 4)
 			break;
 		retval = 0;
-		dev_info(&amp;intf-&gt;dev, "TEST 17:  unlink from %d queues of "
+		dev_info(&amp;intf-&gt;dev, "TEST 24:  unlink from %d queues of "
 				"%d %d-byte writes\n",
 				param-&gt;iterations, param-&gt;sglen, param-&gt;length);
 		for (i = param-&gt;iterations; retval == 0 &amp;&amp; i &gt; 0; --i) {</pre><hr><pre>commit 50ce5c0683aa83eb161624ea89daa5a9eee0c2ce
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Nov 26 12:36:21 2012 -0500

    USB: OHCI: workaround for hardware bug: retired TDs not added to the Done Queue
    
    This patch (as1636) is a partial workaround for a hardware bug
    affecting OHCI controllers by NVIDIA at least, maybe others too.  When
    the controller retires a Transfer Descriptor, it is supposed to add
    the TD onto the Done Queue.  But sometimes this doesn't happen, with
    the result that ohci-hcd never realizes the corresponding transfer has
    finished.  Symptoms can vary; a typical result is that USB audio stops
    working after a while.
    
    The patch works around the problem by recognizing that TDs are always
    processed in order.  Therefore, if a later TD is found on the Done
    Queue than all the earlier TDs for the same endpoint must be finished
    as well.
    
    Unfortunately this won't solve the problem in cases where the missing
    TD is the last one in the endpoint's queue.  A complete fix would
    require a signficant amount of change to the driver.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Oliver Neukum &lt;oneukum@suse.de&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ohci-q.c b/drivers/usb/host/ohci-q.c
index 177a213790d4..7482cfbe8c5e 100644
--- a/drivers/usb/host/ohci-q.c
+++ b/drivers/usb/host/ohci-q.c
@@ -1128,6 +1128,25 @@ dl_done_list (struct ohci_hcd *ohci)
 
 	while (td) {
 		struct td	*td_next = td-&gt;next_dl_td;
+		struct ed	*ed = td-&gt;ed;
+
+		/*
+		 * Some OHCI controllers (NVIDIA for sure, maybe others)
+		 * occasionally forget to add TDs to the done queue.  Since
+		 * TDs for a given endpoint are always processed in order,
+		 * if we find a TD on the donelist then all of its
+		 * predecessors must be finished as well.
+		 */
+		for (;;) {
+			struct td	*td2;
+
+			td2 = list_first_entry(&amp;ed-&gt;td_list, struct td,
+					td_list);
+			if (td2 == td)
+				break;
+			takeback_td(ohci, td2);
+		}
+
 		takeback_td(ohci, td);
 		td = td_next;
 	}</pre>
    <div class="pagination">
        <a href='2_39.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><span>[40]</span><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_41.html'>Next&gt;&gt;</a>
    <div>
</body>
