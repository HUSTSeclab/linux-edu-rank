<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_3.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><span>[4]</span><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_5.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 7a09c1269702db8eccb6f718da2b00173e1e0034
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Nov 2 14:13:19 2022 -0400

    USB: core: Change configuration warnings to notices
    
    It has been pointed out that the kernel log messages warning about
    problems in USB configuration and related descriptors are vexing for
    users.  The warning log level has a fairly high priority, but the user
    can do nothing to fix the underlying errors in the device's firmware.
    
    To reduce the amount of useless information produced by tools that
    filter high-priority log messages, we can change these warnings to
    notices, i.e., change dev_warn() to dev_notice().  The same holds for
    a few messages that currently use dev_err(): Unless they indicate a
    failure that might make a device unusable (such as inability to
    transfer a config descriptor), change them to dev_notice() also.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=216630
    Suggested-by: Artem S. Tashkinov &lt;aros@gmx.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/Y2KzPx0h6z1jXCuN@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c
index 48bc8a4814ac..725b8dbcfe5f 100644
--- a/drivers/usb/core/config.c
+++ b/drivers/usb/core/config.c
@@ -61,7 +61,7 @@ static void usb_parse_ssp_isoc_endpoint_companion(struct device *ddev,
 	desc = (struct usb_ssp_isoc_ep_comp_descriptor *) buffer;
 	if (desc-&gt;bDescriptorType != USB_DT_SSP_ISOC_ENDPOINT_COMP ||
 	    size &lt; USB_DT_SSP_ISOC_EP_COMP_SIZE) {
-		dev_warn(ddev, "Invalid SuperSpeedPlus isoc endpoint companion"
+		dev_notice(ddev, "Invalid SuperSpeedPlus isoc endpoint companion"
 			 "for config %d interface %d altsetting %d ep %d.\n",
 			 cfgno, inum, asnum, ep-&gt;desc.bEndpointAddress);
 		return;
@@ -83,7 +83,7 @@ static void usb_parse_ss_endpoint_companion(struct device *ddev, int cfgno,
 
 	if (desc-&gt;bDescriptorType != USB_DT_SS_ENDPOINT_COMP ||
 			size &lt; USB_DT_SS_EP_COMP_SIZE) {
-		dev_warn(ddev, "No SuperSpeed endpoint companion for config %d "
+		dev_notice(ddev, "No SuperSpeed endpoint companion for config %d "
 				" interface %d altsetting %d ep %d: "
 				"using minimum values\n",
 				cfgno, inum, asnum, ep-&gt;desc.bEndpointAddress);
@@ -109,13 +109,13 @@ static void usb_parse_ss_endpoint_companion(struct device *ddev, int cfgno,
 
 	/* Check the various values */
 	if (usb_endpoint_xfer_control(&amp;ep-&gt;desc) &amp;&amp; desc-&gt;bMaxBurst != 0) {
-		dev_warn(ddev, "Control endpoint with bMaxBurst = %d in "
+		dev_notice(ddev, "Control endpoint with bMaxBurst = %d in "
 				"config %d interface %d altsetting %d ep %d: "
 				"setting to zero\n", desc-&gt;bMaxBurst,
 				cfgno, inum, asnum, ep-&gt;desc.bEndpointAddress);
 		ep-&gt;ss_ep_comp.bMaxBurst = 0;
 	} else if (desc-&gt;bMaxBurst &gt; 15) {
-		dev_warn(ddev, "Endpoint with bMaxBurst = %d in "
+		dev_notice(ddev, "Endpoint with bMaxBurst = %d in "
 				"config %d interface %d altsetting %d ep %d: "
 				"setting to 15\n", desc-&gt;bMaxBurst,
 				cfgno, inum, asnum, ep-&gt;desc.bEndpointAddress);
@@ -125,7 +125,7 @@ static void usb_parse_ss_endpoint_companion(struct device *ddev, int cfgno,
 	if ((usb_endpoint_xfer_control(&amp;ep-&gt;desc) ||
 			usb_endpoint_xfer_int(&amp;ep-&gt;desc)) &amp;&amp;
 				desc-&gt;bmAttributes != 0) {
-		dev_warn(ddev, "%s endpoint with bmAttributes = %d in "
+		dev_notice(ddev, "%s endpoint with bmAttributes = %d in "
 				"config %d interface %d altsetting %d ep %d: "
 				"setting to zero\n",
 				usb_endpoint_xfer_control(&amp;ep-&gt;desc) ? "Control" : "Bulk",
@@ -134,7 +134,7 @@ static void usb_parse_ss_endpoint_companion(struct device *ddev, int cfgno,
 		ep-&gt;ss_ep_comp.bmAttributes = 0;
 	} else if (usb_endpoint_xfer_bulk(&amp;ep-&gt;desc) &amp;&amp;
 			desc-&gt;bmAttributes &gt; 16) {
-		dev_warn(ddev, "Bulk endpoint with more than 65536 streams in "
+		dev_notice(ddev, "Bulk endpoint with more than 65536 streams in "
 				"config %d interface %d altsetting %d ep %d: "
 				"setting to max\n",
 				cfgno, inum, asnum, ep-&gt;desc.bEndpointAddress);
@@ -142,7 +142,7 @@ static void usb_parse_ss_endpoint_companion(struct device *ddev, int cfgno,
 	} else if (usb_endpoint_xfer_isoc(&amp;ep-&gt;desc) &amp;&amp;
 		   !USB_SS_SSP_ISOC_COMP(desc-&gt;bmAttributes) &amp;&amp;
 		   USB_SS_MULT(desc-&gt;bmAttributes) &gt; 3) {
-		dev_warn(ddev, "Isoc endpoint has Mult of %d in "
+		dev_notice(ddev, "Isoc endpoint has Mult of %d in "
 				"config %d interface %d altsetting %d ep %d: "
 				"setting to 3\n",
 				USB_SS_MULT(desc-&gt;bmAttributes),
@@ -160,7 +160,7 @@ static void usb_parse_ss_endpoint_companion(struct device *ddev, int cfgno,
 	else
 		max_tx = 999999;
 	if (le16_to_cpu(desc-&gt;wBytesPerInterval) &gt; max_tx) {
-		dev_warn(ddev, "%s endpoint with wBytesPerInterval of %d in "
+		dev_notice(ddev, "%s endpoint with wBytesPerInterval of %d in "
 				"config %d interface %d altsetting %d ep %d: "
 				"setting to %d\n",
 				usb_endpoint_xfer_isoc(&amp;ep-&gt;desc) ? "Isoc" : "Int",
@@ -273,7 +273,7 @@ static int usb_parse_endpoint(struct device *ddev, int cfgno,
 	else if (d-&gt;bLength &gt;= USB_DT_ENDPOINT_SIZE)
 		n = USB_DT_ENDPOINT_SIZE;
 	else {
-		dev_warn(ddev, "config %d interface %d altsetting %d has an "
+		dev_notice(ddev, "config %d interface %d altsetting %d has an "
 		    "invalid endpoint descriptor of length %d, skipping\n",
 		    cfgno, inum, asnum, d-&gt;bLength);
 		goto skip_to_next_endpoint_or_interface_descriptor;
@@ -281,7 +281,7 @@ static int usb_parse_endpoint(struct device *ddev, int cfgno,
 
 	i = d-&gt;bEndpointAddress &amp; ~USB_ENDPOINT_DIR_MASK;
 	if (i &gt;= 16 || i == 0) {
-		dev_warn(ddev, "config %d interface %d altsetting %d has an "
+		dev_notice(ddev, "config %d interface %d altsetting %d has an "
 		    "invalid endpoint with address 0x%X, skipping\n",
 		    cfgno, inum, asnum, d-&gt;bEndpointAddress);
 		goto skip_to_next_endpoint_or_interface_descriptor;
@@ -293,7 +293,7 @@ static int usb_parse_endpoint(struct device *ddev, int cfgno,
 
 	/* Check for duplicate endpoint addresses */
 	if (config_endpoint_is_duplicate(config, inum, asnum, d)) {
-		dev_warn(ddev, "config %d interface %d altsetting %d has a duplicate endpoint with address 0x%X, skipping\n",
+		dev_notice(ddev, "config %d interface %d altsetting %d has a duplicate endpoint with address 0x%X, skipping\n",
 				cfgno, inum, asnum, d-&gt;bEndpointAddress);
 		goto skip_to_next_endpoint_or_interface_descriptor;
 	}
@@ -301,7 +301,7 @@ static int usb_parse_endpoint(struct device *ddev, int cfgno,
 	/* Ignore some endpoints */
 	if (udev-&gt;quirks &amp; USB_QUIRK_ENDPOINT_IGNORE) {
 		if (usb_endpoint_is_ignored(udev, ifp, d)) {
-			dev_warn(ddev, "config %d interface %d altsetting %d has an ignored endpoint with address 0x%X, skipping\n",
+			dev_notice(ddev, "config %d interface %d altsetting %d has an ignored endpoint with address 0x%X, skipping\n",
 					cfgno, inum, asnum,
 					d-&gt;bEndpointAddress);
 			goto skip_to_next_endpoint_or_interface_descriptor;
@@ -378,7 +378,7 @@ static int usb_parse_endpoint(struct device *ddev, int cfgno,
 		}
 	}
 	if (d-&gt;bInterval &lt; i || d-&gt;bInterval &gt; j) {
-		dev_warn(ddev, "config %d interface %d altsetting %d "
+		dev_notice(ddev, "config %d interface %d altsetting %d "
 		    "endpoint 0x%X has an invalid bInterval %d, "
 		    "changing to %d\n",
 		    cfgno, inum, asnum,
@@ -391,7 +391,7 @@ static int usb_parse_endpoint(struct device *ddev, int cfgno,
 	 * them usable, we will try treating them as Interrupt endpoints.
 	 */
 	if (udev-&gt;speed == USB_SPEED_LOW &amp;&amp; usb_endpoint_xfer_bulk(d)) {
-		dev_warn(ddev, "config %d interface %d altsetting %d "
+		dev_notice(ddev, "config %d interface %d altsetting %d "
 		    "endpoint 0x%X is Bulk; changing to Interrupt\n",
 		    cfgno, inum, asnum, d-&gt;bEndpointAddress);
 		endpoint-&gt;desc.bmAttributes = USB_ENDPOINT_XFER_INT;
@@ -408,7 +408,7 @@ static int usb_parse_endpoint(struct device *ddev, int cfgno,
 	 */
 	maxp = le16_to_cpu(endpoint-&gt;desc.wMaxPacketSize);
 	if (maxp == 0 &amp;&amp; !(usb_endpoint_xfer_isoc(d) &amp;&amp; asnum == 0)) {
-		dev_warn(ddev, "config %d interface %d altsetting %d endpoint 0x%X has invalid wMaxPacketSize 0\n",
+		dev_notice(ddev, "config %d interface %d altsetting %d endpoint 0x%X has invalid wMaxPacketSize 0\n",
 		    cfgno, inum, asnum, d-&gt;bEndpointAddress);
 	}
 
@@ -439,7 +439,7 @@ static int usb_parse_endpoint(struct device *ddev, int cfgno,
 	j = maxpacket_maxes[usb_endpoint_type(&amp;endpoint-&gt;desc)];
 
 	if (maxp &gt; j) {
-		dev_warn(ddev, "config %d interface %d altsetting %d endpoint 0x%X has invalid maxpacket %d, setting to %d\n",
+		dev_notice(ddev, "config %d interface %d altsetting %d endpoint 0x%X has invalid maxpacket %d, setting to %d\n",
 		    cfgno, inum, asnum, d-&gt;bEndpointAddress, maxp, j);
 		maxp = j;
 		endpoint-&gt;desc.wMaxPacketSize = cpu_to_le16(i | maxp);
@@ -452,7 +452,7 @@ static int usb_parse_endpoint(struct device *ddev, int cfgno,
 	 */
 	if (udev-&gt;speed == USB_SPEED_HIGH &amp;&amp; usb_endpoint_xfer_bulk(d)) {
 		if (maxp != 512)
-			dev_warn(ddev, "config %d interface %d altsetting %d "
+			dev_notice(ddev, "config %d interface %d altsetting %d "
 				"bulk endpoint 0x%X has invalid maxpacket %d\n",
 				cfgno, inum, asnum, d-&gt;bEndpointAddress,
 				maxp);
@@ -533,7 +533,7 @@ static int usb_parse_interface(struct device *ddev, int cfgno,
 	      i &lt; intfc-&gt;num_altsetting;
 	     (++i, ++alt)) {
 		if (alt-&gt;desc.bAlternateSetting == asnum) {
-			dev_warn(ddev, "Duplicate descriptor for config %d "
+			dev_notice(ddev, "Duplicate descriptor for config %d "
 			    "interface %d altsetting %d, skipping\n",
 			    cfgno, inum, asnum);
 			goto skip_to_next_interface_descriptor;
@@ -559,7 +559,7 @@ static int usb_parse_interface(struct device *ddev, int cfgno,
 	num_ep = num_ep_orig = alt-&gt;desc.bNumEndpoints;
 	alt-&gt;desc.bNumEndpoints = 0;		/* Use as a counter */
 	if (num_ep &gt; USB_MAXENDPOINTS) {
-		dev_warn(ddev, "too many endpoints for config %d interface %d "
+		dev_notice(ddev, "too many endpoints for config %d interface %d "
 		    "altsetting %d: %d, using maximum allowed: %d\n",
 		    cfgno, inum, asnum, num_ep, USB_MAXENDPOINTS);
 		num_ep = USB_MAXENDPOINTS;
@@ -590,7 +590,7 @@ static int usb_parse_interface(struct device *ddev, int cfgno,
 	}
 
 	if (n != num_ep_orig)
-		dev_warn(ddev, "config %d interface %d altsetting %d has %d "
+		dev_notice(ddev, "config %d interface %d altsetting %d has %d "
 		    "endpoint descriptor%s, different from the interface "
 		    "descriptor's value: %d\n",
 		    cfgno, inum, asnum, n, plural(n), num_ep_orig);
@@ -625,7 +625,7 @@ static int usb_parse_configuration(struct usb_device *dev, int cfgidx,
 	if (config-&gt;desc.bDescriptorType != USB_DT_CONFIG ||
 	    config-&gt;desc.bLength &lt; USB_DT_CONFIG_SIZE ||
 	    config-&gt;desc.bLength &gt; size) {
-		dev_err(ddev, "invalid descriptor for config index %d: "
+		dev_notice(ddev, "invalid descriptor for config index %d: "
 		    "type = 0x%X, length = %d\n", cfgidx,
 		    config-&gt;desc.bDescriptorType, config-&gt;desc.bLength);
 		return -EINVAL;
@@ -636,7 +636,7 @@ static int usb_parse_configuration(struct usb_device *dev, int cfgidx,
 	size -= config-&gt;desc.bLength;
 
 	if (nintf &gt; USB_MAXINTERFACES) {
-		dev_warn(ddev, "config %d has too many interfaces: %d, "
+		dev_notice(ddev, "config %d has too many interfaces: %d, "
 		    "using maximum allowed: %d\n",
 		    cfgno, nintf, USB_MAXINTERFACES);
 		nintf = USB_MAXINTERFACES;
@@ -650,7 +650,7 @@ static int usb_parse_configuration(struct usb_device *dev, int cfgidx,
 	     (buffer2 += header-&gt;bLength, size2 -= header-&gt;bLength)) {
 
 		if (size2 &lt; sizeof(struct usb_descriptor_header)) {
-			dev_warn(ddev, "config %d descriptor has %d excess "
+			dev_notice(ddev, "config %d descriptor has %d excess "
 			    "byte%s, ignoring\n",
 			    cfgno, size2, plural(size2));
 			break;
@@ -658,7 +658,7 @@ static int usb_parse_configuration(struct usb_device *dev, int cfgidx,
 
 		header = (struct usb_descriptor_header *) buffer2;
 		if ((header-&gt;bLength &gt; size2) || (header-&gt;bLength &lt; 2)) {
-			dev_warn(ddev, "config %d has an invalid descriptor "
+			dev_notice(ddev, "config %d has an invalid descriptor "
 			    "of length %d, skipping remainder of the config\n",
 			    cfgno, header-&gt;bLength);
 			break;
@@ -670,7 +670,7 @@ static int usb_parse_configuration(struct usb_device *dev, int cfgidx,
 
 			d = (struct usb_interface_descriptor *) header;
 			if (d-&gt;bLength &lt; USB_DT_INTERFACE_SIZE) {
-				dev_warn(ddev, "config %d has an invalid "
+				dev_notice(ddev, "config %d has an invalid "
 				    "interface descriptor of length %d, "
 				    "skipping\n", cfgno, d-&gt;bLength);
 				continue;
@@ -680,7 +680,7 @@ static int usb_parse_configuration(struct usb_device *dev, int cfgidx,
 
 			if ((dev-&gt;quirks &amp; USB_QUIRK_HONOR_BNUMINTERFACES) &amp;&amp;
 			    n &gt;= nintf_orig) {
-				dev_warn(ddev, "config %d has more interface "
+				dev_notice(ddev, "config %d has more interface "
 				    "descriptors, than it declares in "
 				    "bNumInterfaces, ignoring interface "
 				    "number: %d\n", cfgno, inum);
@@ -688,7 +688,7 @@ static int usb_parse_configuration(struct usb_device *dev, int cfgidx,
 			}
 
 			if (inum &gt;= nintf_orig)
-				dev_warn(ddev, "config %d has an invalid "
+				dev_notice(ddev, "config %d has an invalid "
 				    "interface number: %d but max is %d\n",
 				    cfgno, inum, nintf_orig - 1);
 
@@ -713,14 +713,14 @@ static int usb_parse_configuration(struct usb_device *dev, int cfgidx,
 
 			d = (struct usb_interface_assoc_descriptor *)header;
 			if (d-&gt;bLength &lt; USB_DT_INTERFACE_ASSOCIATION_SIZE) {
-				dev_warn(ddev,
+				dev_notice(ddev,
 					 "config %d has an invalid interface association descriptor of length %d, skipping\n",
 					 cfgno, d-&gt;bLength);
 				continue;
 			}
 
 			if (iad_num == USB_MAXIADS) {
-				dev_warn(ddev, "found more Interface "
+				dev_notice(ddev, "found more Interface "
 					       "Association Descriptors "
 					       "than allocated for in "
 					       "configuration %d\n", cfgno);
@@ -731,7 +731,7 @@ static int usb_parse_configuration(struct usb_device *dev, int cfgidx,
 
 		} else if (header-&gt;bDescriptorType == USB_DT_DEVICE ||
 			    header-&gt;bDescriptorType == USB_DT_CONFIG)
-			dev_warn(ddev, "config %d contains an unexpected "
+			dev_notice(ddev, "config %d contains an unexpected "
 			    "descriptor of type 0x%X, skipping\n",
 			    cfgno, header-&gt;bDescriptorType);
 
@@ -740,11 +740,11 @@ static int usb_parse_configuration(struct usb_device *dev, int cfgidx,
 	config-&gt;desc.wTotalLength = cpu_to_le16(buffer2 - buffer0);
 
 	if (n != nintf)
-		dev_warn(ddev, "config %d has %d interface%s, different from "
+		dev_notice(ddev, "config %d has %d interface%s, different from "
 		    "the descriptor's value: %d\n",
 		    cfgno, n, plural(n), nintf_orig);
 	else if (n == 0)
-		dev_warn(ddev, "config %d has no interfaces?\n", cfgno);
+		dev_notice(ddev, "config %d has no interfaces?\n", cfgno);
 	config-&gt;desc.bNumInterfaces = nintf = n;
 
 	/* Check for missing interface numbers */
@@ -754,7 +754,7 @@ static int usb_parse_configuration(struct usb_device *dev, int cfgidx,
 				break;
 		}
 		if (j &gt;= nintf)
-			dev_warn(ddev, "config %d has no interface number "
+			dev_notice(ddev, "config %d has no interface number "
 			    "%d\n", cfgno, i);
 	}
 
@@ -762,7 +762,7 @@ static int usb_parse_configuration(struct usb_device *dev, int cfgidx,
 	for (i = 0; i &lt; nintf; ++i) {
 		j = nalts[i];
 		if (j &gt; USB_MAXALTSETTING) {
-			dev_warn(ddev, "too many alternate settings for "
+			dev_notice(ddev, "too many alternate settings for "
 			    "config %d interface %d: %d, "
 			    "using maximum allowed: %d\n",
 			    cfgno, inums[i], j, USB_MAXALTSETTING);
@@ -811,7 +811,7 @@ static int usb_parse_configuration(struct usb_device *dev, int cfgidx,
 					break;
 			}
 			if (n &gt;= intfc-&gt;num_altsetting)
-				dev_warn(ddev, "config %d interface %d has no "
+				dev_notice(ddev, "config %d interface %d has no "
 				    "altsetting %d\n", cfgno, inums[i], j);
 		}
 	}
@@ -868,7 +868,7 @@ int usb_get_configuration(struct usb_device *dev)
 	int result;
 
 	if (ncfg &gt; USB_MAXCONFIG) {
-		dev_warn(ddev, "too many configurations: %d, "
+		dev_notice(ddev, "too many configurations: %d, "
 		    "using maximum allowed: %d\n", ncfg, USB_MAXCONFIG);
 		dev-&gt;descriptor.bNumConfigurations = ncfg = USB_MAXCONFIG;
 	}
@@ -902,7 +902,7 @@ int usb_get_configuration(struct usb_device *dev)
 			    "descriptor/%s: %d\n", cfgno, "start", result);
 			if (result != -EPIPE)
 				goto err;
-			dev_err(ddev, "chopping to %d config(s)\n", cfgno);
+			dev_notice(ddev, "chopping to %d config(s)\n", cfgno);
 			dev-&gt;descriptor.bNumConfigurations = cfgno;
 			break;
 		} else if (result &lt; 4) {
@@ -934,7 +934,7 @@ int usb_get_configuration(struct usb_device *dev)
 			goto err;
 		}
 		if (result &lt; length) {
-			dev_warn(ddev, "config index %d descriptor too short "
+			dev_notice(ddev, "config index %d descriptor too short "
 			    "(expected %i, got %i)\n", cfgno, length, result);
 			length = result;
 		}
@@ -993,7 +993,7 @@ int usb_get_bos_descriptor(struct usb_device *dev)
 	/* Get BOS descriptor */
 	ret = usb_get_descriptor(dev, USB_DT_BOS, 0, bos, USB_DT_BOS_SIZE);
 	if (ret &lt; USB_DT_BOS_SIZE || bos-&gt;bLength &lt; USB_DT_BOS_SIZE) {
-		dev_err(ddev, "unable to get BOS descriptor or descriptor too short\n");
+		dev_notice(ddev, "unable to get BOS descriptor or descriptor too short\n");
 		if (ret &gt;= 0)
 			ret = -ENOMSG;
 		kfree(bos);
@@ -1021,7 +1021,7 @@ int usb_get_bos_descriptor(struct usb_device *dev)
 
 	ret = usb_get_descriptor(dev, USB_DT_BOS, 0, buffer, total_len);
 	if (ret &lt; total_len) {
-		dev_err(ddev, "unable to get BOS descriptor set\n");
+		dev_notice(ddev, "unable to get BOS descriptor set\n");
 		if (ret &gt;= 0)
 			ret = -ENOMSG;
 		goto err;
@@ -1046,7 +1046,7 @@ int usb_get_bos_descriptor(struct usb_device *dev)
 		}
 
 		if (cap-&gt;bDescriptorType != USB_DT_DEVICE_CAPABILITY) {
-			dev_warn(ddev, "descriptor type invalid, skip\n");
+			dev_notice(ddev, "descriptor type invalid, skip\n");
 			continue;
 		}
 </pre><hr><pre>commit 41fd1cb6151439b205ac7611883d85ae14250172
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 26 21:31:40 2022 +0200

    media: mceusb: Use new usb_control_msg_*() routines
    
    Automatic kernel fuzzing led to a WARN about invalid pipe direction in
    the mceusb driver:
    
    ------------[ cut here ]------------
    usb 6-1: BOGUS control dir, pipe 80000380 doesn't match bRequestType 40
    WARNING: CPU: 0 PID: 2465 at drivers/usb/core/urb.c:410
    usb_submit_urb+0x1326/0x1820 drivers/usb/core/urb.c:410
    Modules linked in:
    CPU: 0 PID: 2465 Comm: kworker/0:2 Not tainted 5.19.0-rc4-00208-g69cb6c6556ad #1
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS
    1.13.0-1ubuntu1.1 04/01/2014
    Workqueue: usb_hub_wq hub_event
    RIP: 0010:usb_submit_urb+0x1326/0x1820 drivers/usb/core/urb.c:410
    Code: 7c 24 40 e8 ac 23 91 fd 48 8b 7c 24 40 e8 b2 70 1b ff 45 89 e8
    44 89 f1 4c 89 e2 48 89 c6 48 c7 c7 a0 30 a9 86 e8 48 07 11 02 &lt;0f&gt; 0b
    e9 1c f0 ff ff e8 7e 23 91 fd 0f b6 1d 63 22 83 05 31 ff 41
    RSP: 0018:ffffc900032becf0 EFLAGS: 00010282
    RAX: 0000000000000000 RBX: ffff8881100f3058 RCX: 0000000000000000
    RDX: ffffc90004961000 RSI: ffff888114c6d580 RDI: fffff52000657d90
    RBP: ffff888105ad90f0 R08: ffffffff812c3638 R09: 0000000000000000
    R10: 0000000000000005 R11: ffffed1023504ef1 R12: ffff888105ad9000
    R13: 0000000000000040 R14: 0000000080000380 R15: ffff88810ba96500
    FS: 0000000000000000(0000) GS:ffff88811a800000(0000) knlGS:0000000000000000
    CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 00007ffe810bda58 CR3: 000000010b720000 CR4: 0000000000350ef0
    Call Trace:
    &lt;TASK&gt;
    usb_start_wait_urb+0x101/0x4c0 drivers/usb/core/message.c:58
    usb_internal_control_msg drivers/usb/core/message.c:102 [inline]
    usb_control_msg+0x31c/0x4a0 drivers/usb/core/message.c:153
    mceusb_gen1_init drivers/media/rc/mceusb.c:1431 [inline]
    mceusb_dev_probe+0x258e/0x33f0 drivers/media/rc/mceusb.c:1807
    
    The reason for the warning is clear enough; the driver sends an
    unusual read request on endpoint 0 but does not set the USB_DIR_IN bit
    in the bRequestType field.
    
    More importantly, the whole situation can be avoided and the driver
    simplified by converting it over to the relatively new
    usb_control_msg_recv() and usb_control_msg_send() routines.  That's
    what this fix does.
    
    Reported-and-tested-by: Rondreis &lt;linhaoguo86@gmail.com&gt;
    Link: https://lore.kernel.org/all/CAB7eexLLApHJwZfMQ=X-PtRhw0BgO+5KcSMS05FNUYejJXqtSA@mail.gmail.com/
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable@vger.kernel.org
    Signed-off-by: Sean Young &lt;sean@mess.org&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@kernel.org&gt;

diff --git a/drivers/media/rc/mceusb.c b/drivers/media/rc/mceusb.c
index 0834d5f866fd..39d2b03e2631 100644
--- a/drivers/media/rc/mceusb.c
+++ b/drivers/media/rc/mceusb.c
@@ -1416,42 +1416,37 @@ static void mceusb_gen1_init(struct mceusb_dev *ir)
 {
 	int ret;
 	struct device *dev = ir-&gt;dev;
-	char *data;
-
-	data = kzalloc(USB_CTRL_MSG_SZ, GFP_KERNEL);
-	if (!data) {
-		dev_err(dev, "%s: memory allocation failed!", __func__);
-		return;
-	}
+	char data[USB_CTRL_MSG_SZ];
 
 	/*
 	 * This is a strange one. Windows issues a set address to the device
 	 * on the receive control pipe and expect a certain value pair back
 	 */
-	ret = usb_control_msg(ir-&gt;usbdev, usb_rcvctrlpipe(ir-&gt;usbdev, 0),
-			      USB_REQ_SET_ADDRESS, USB_TYPE_VENDOR, 0, 0,
-			      data, USB_CTRL_MSG_SZ, 3000);
+	ret = usb_control_msg_recv(ir-&gt;usbdev, 0, USB_REQ_SET_ADDRESS,
+				   USB_DIR_IN | USB_TYPE_VENDOR,
+				   0, 0, data, USB_CTRL_MSG_SZ, 3000,
+				   GFP_KERNEL);
 	dev_dbg(dev, "set address - ret = %d", ret);
 	dev_dbg(dev, "set address - data[0] = %d, data[1] = %d",
 						data[0], data[1]);
 
 	/* set feature: bit rate 38400 bps */
-	ret = usb_control_msg(ir-&gt;usbdev, usb_sndctrlpipe(ir-&gt;usbdev, 0),
-			      USB_REQ_SET_FEATURE, USB_TYPE_VENDOR,
-			      0xc04e, 0x0000, NULL, 0, 3000);
+	ret = usb_control_msg_send(ir-&gt;usbdev, 0,
+				   USB_REQ_SET_FEATURE, USB_TYPE_VENDOR,
+				   0xc04e, 0x0000, NULL, 0, 3000, GFP_KERNEL);
 
 	dev_dbg(dev, "set feature - ret = %d", ret);
 
 	/* bRequest 4: set char length to 8 bits */
-	ret = usb_control_msg(ir-&gt;usbdev, usb_sndctrlpipe(ir-&gt;usbdev, 0),
-			      4, USB_TYPE_VENDOR,
-			      0x0808, 0x0000, NULL, 0, 3000);
+	ret = usb_control_msg_send(ir-&gt;usbdev, 0,
+				   4, USB_TYPE_VENDOR,
+				   0x0808, 0x0000, NULL, 0, 3000, GFP_KERNEL);
 	dev_dbg(dev, "set char length - retB = %d", ret);
 
 	/* bRequest 2: set handshaking to use DTR/DSR */
-	ret = usb_control_msg(ir-&gt;usbdev, usb_sndctrlpipe(ir-&gt;usbdev, 0),
-			      2, USB_TYPE_VENDOR,
-			      0x0000, 0x0100, NULL, 0, 3000);
+	ret = usb_control_msg_send(ir-&gt;usbdev, 0,
+				   2, USB_TYPE_VENDOR,
+				   0x0000, 0x0100, NULL, 0, 3000, GFP_KERNEL);
 	dev_dbg(dev, "set handshake  - retC = %d", ret);
 
 	/* device resume */
@@ -1459,8 +1454,6 @@ static void mceusb_gen1_init(struct mceusb_dev *ir)
 
 	/* get hw/sw revision? */
 	mce_command_out(ir, GET_REVISION, sizeof(GET_REVISION));
-
-	kfree(data);
 }
 
 static void mceusb_gen2_init(struct mceusb_dev *ir)</pre><hr><pre>commit 766a96dc558385be735a370db867e302c8f22153
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Sep 1 10:36:34 2022 -0400

    USB: core: Fix RST error in hub.c
    
    A recent commit added an invalid RST expression to a kerneldoc comment
    in hub.c.  The fix is trivial.
    
    Fixes: 9c6d778800b9 ("USB: core: Prevent nested device-reset calls")
    Cc: &lt;stable@vger.kernel.org&gt;
    Reported-by: Stephen Rothwell &lt;sfr@canb.auug.org.au&gt;
    Reviewed-by: Bagas Sanjaya &lt;bagasdotme@gmail.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/YxDDcsLtRZ7c20pq@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index d4b1e70d1498..bbab424b0d55 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -6039,7 +6039,7 @@ static int usb_reset_and_verify_device(struct usb_device *udev)
  *
  * Return: The same as for usb_reset_and_verify_device().
  * However, if a reset is already in progress (for instance, if a
- * driver doesn't have pre_ or post_reset() callbacks, and while
+ * driver doesn't have pre_reset() or post_reset() callbacks, and while
  * being unbound or re-bound during the ongoing reset its disconnect()
  * or probe() routine tries to perform a second, nested reset), the
  * routine returns -EINPROGRESS.</pre><hr><pre>commit 608e58a0f4617977178131f5f68a3fce1d3f5316
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 26 15:31:40 2022 -0400

    media: mceusb: Use new usb_control_msg_*() routines
    
    Automatic kernel fuzzing led to a WARN about invalid pipe direction in
    the mceusb driver:
    
    ------------[ cut here ]------------
    usb 6-1: BOGUS control dir, pipe 80000380 doesn't match bRequestType 40
    WARNING: CPU: 0 PID: 2465 at drivers/usb/core/urb.c:410
    usb_submit_urb+0x1326/0x1820 drivers/usb/core/urb.c:410
    Modules linked in:
    CPU: 0 PID: 2465 Comm: kworker/0:2 Not tainted 5.19.0-rc4-00208-g69cb6c6556ad #1
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS
    1.13.0-1ubuntu1.1 04/01/2014
    Workqueue: usb_hub_wq hub_event
    RIP: 0010:usb_submit_urb+0x1326/0x1820 drivers/usb/core/urb.c:410
    Code: 7c 24 40 e8 ac 23 91 fd 48 8b 7c 24 40 e8 b2 70 1b ff 45 89 e8
    44 89 f1 4c 89 e2 48 89 c6 48 c7 c7 a0 30 a9 86 e8 48 07 11 02 &lt;0f&gt; 0b
    e9 1c f0 ff ff e8 7e 23 91 fd 0f b6 1d 63 22 83 05 31 ff 41
    RSP: 0018:ffffc900032becf0 EFLAGS: 00010282
    RAX: 0000000000000000 RBX: ffff8881100f3058 RCX: 0000000000000000
    RDX: ffffc90004961000 RSI: ffff888114c6d580 RDI: fffff52000657d90
    RBP: ffff888105ad90f0 R08: ffffffff812c3638 R09: 0000000000000000
    R10: 0000000000000005 R11: ffffed1023504ef1 R12: ffff888105ad9000
    R13: 0000000000000040 R14: 0000000080000380 R15: ffff88810ba96500
    FS: 0000000000000000(0000) GS:ffff88811a800000(0000) knlGS:0000000000000000
    CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 00007ffe810bda58 CR3: 000000010b720000 CR4: 0000000000350ef0
    Call Trace:
    &lt;TASK&gt;
    usb_start_wait_urb+0x101/0x4c0 drivers/usb/core/message.c:58
    usb_internal_control_msg drivers/usb/core/message.c:102 [inline]
    usb_control_msg+0x31c/0x4a0 drivers/usb/core/message.c:153
    mceusb_gen1_init drivers/media/rc/mceusb.c:1431 [inline]
    mceusb_dev_probe+0x258e/0x33f0 drivers/media/rc/mceusb.c:1807
    
    The reason for the warning is clear enough; the driver sends an
    unusual read request on endpoint 0 but does not set the USB_DIR_IN bit
    in the bRequestType field.
    
    More importantly, the whole situation can be avoided and the driver
    simplified by converting it over to the relatively new
    usb_control_msg_recv() and usb_control_msg_send() routines.  That's
    what this fix does.
    
    Link: https://lore.kernel.org/all/CAB7eexLLApHJwZfMQ=X-PtRhw0BgO+5KcSMS05FNUYejJXqtSA@mail.gmail.com/
    Cc: Mauro Carvalho Chehab &lt;mchehab@kernel.org&gt;
    Cc: stable@vger.kernel.org
    Reported-and-tested-by: Rondreis &lt;linhaoguo86@gmail.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/YwkfnBFCSEVC6XZu@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/media/rc/mceusb.c b/drivers/media/rc/mceusb.c
index 0834d5f866fd..39d2b03e2631 100644
--- a/drivers/media/rc/mceusb.c
+++ b/drivers/media/rc/mceusb.c
@@ -1416,42 +1416,37 @@ static void mceusb_gen1_init(struct mceusb_dev *ir)
 {
 	int ret;
 	struct device *dev = ir-&gt;dev;
-	char *data;
-
-	data = kzalloc(USB_CTRL_MSG_SZ, GFP_KERNEL);
-	if (!data) {
-		dev_err(dev, "%s: memory allocation failed!", __func__);
-		return;
-	}
+	char data[USB_CTRL_MSG_SZ];
 
 	/*
 	 * This is a strange one. Windows issues a set address to the device
 	 * on the receive control pipe and expect a certain value pair back
 	 */
-	ret = usb_control_msg(ir-&gt;usbdev, usb_rcvctrlpipe(ir-&gt;usbdev, 0),
-			      USB_REQ_SET_ADDRESS, USB_TYPE_VENDOR, 0, 0,
-			      data, USB_CTRL_MSG_SZ, 3000);
+	ret = usb_control_msg_recv(ir-&gt;usbdev, 0, USB_REQ_SET_ADDRESS,
+				   USB_DIR_IN | USB_TYPE_VENDOR,
+				   0, 0, data, USB_CTRL_MSG_SZ, 3000,
+				   GFP_KERNEL);
 	dev_dbg(dev, "set address - ret = %d", ret);
 	dev_dbg(dev, "set address - data[0] = %d, data[1] = %d",
 						data[0], data[1]);
 
 	/* set feature: bit rate 38400 bps */
-	ret = usb_control_msg(ir-&gt;usbdev, usb_sndctrlpipe(ir-&gt;usbdev, 0),
-			      USB_REQ_SET_FEATURE, USB_TYPE_VENDOR,
-			      0xc04e, 0x0000, NULL, 0, 3000);
+	ret = usb_control_msg_send(ir-&gt;usbdev, 0,
+				   USB_REQ_SET_FEATURE, USB_TYPE_VENDOR,
+				   0xc04e, 0x0000, NULL, 0, 3000, GFP_KERNEL);
 
 	dev_dbg(dev, "set feature - ret = %d", ret);
 
 	/* bRequest 4: set char length to 8 bits */
-	ret = usb_control_msg(ir-&gt;usbdev, usb_sndctrlpipe(ir-&gt;usbdev, 0),
-			      4, USB_TYPE_VENDOR,
-			      0x0808, 0x0000, NULL, 0, 3000);
+	ret = usb_control_msg_send(ir-&gt;usbdev, 0,
+				   4, USB_TYPE_VENDOR,
+				   0x0808, 0x0000, NULL, 0, 3000, GFP_KERNEL);
 	dev_dbg(dev, "set char length - retB = %d", ret);
 
 	/* bRequest 2: set handshaking to use DTR/DSR */
-	ret = usb_control_msg(ir-&gt;usbdev, usb_sndctrlpipe(ir-&gt;usbdev, 0),
-			      2, USB_TYPE_VENDOR,
-			      0x0000, 0x0100, NULL, 0, 3000);
+	ret = usb_control_msg_send(ir-&gt;usbdev, 0,
+				   2, USB_TYPE_VENDOR,
+				   0x0000, 0x0100, NULL, 0, 3000, GFP_KERNEL);
 	dev_dbg(dev, "set handshake  - retC = %d", ret);
 
 	/* device resume */
@@ -1459,8 +1454,6 @@ static void mceusb_gen1_init(struct mceusb_dev *ir)
 
 	/* get hw/sw revision? */
 	mce_command_out(ir, GET_REVISION, sizeof(GET_REVISION));
-
-	kfree(data);
 }
 
 static void mceusb_gen2_init(struct mceusb_dev *ir)</pre><hr><pre>commit 9c6d778800b921bde3bff3cff5003d1650f942d1
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 26 15:31:32 2022 -0400

    USB: core: Prevent nested device-reset calls
    
    Automatic kernel fuzzing revealed a recursive locking violation in
    usb-storage:
    
    ============================================
    WARNING: possible recursive locking detected
    5.18.0 #3 Not tainted
    --------------------------------------------
    kworker/1:3/1205 is trying to acquire lock:
    ffff888018638db8 (&amp;us_interface_key[i]){+.+.}-{3:3}, at:
    usb_stor_pre_reset+0x35/0x40 drivers/usb/storage/usb.c:230
    
    but task is already holding lock:
    ffff888018638db8 (&amp;us_interface_key[i]){+.+.}-{3:3}, at:
    usb_stor_pre_reset+0x35/0x40 drivers/usb/storage/usb.c:230
    
    ...
    
    stack backtrace:
    CPU: 1 PID: 1205 Comm: kworker/1:3 Not tainted 5.18.0 #3
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS
    1.13.0-1ubuntu1.1 04/01/2014
    Workqueue: usb_hub_wq hub_event
    Call Trace:
    &lt;TASK&gt;
    __dump_stack lib/dump_stack.c:88 [inline]
    dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106
    print_deadlock_bug kernel/locking/lockdep.c:2988 [inline]
    check_deadlock kernel/locking/lockdep.c:3031 [inline]
    validate_chain kernel/locking/lockdep.c:3816 [inline]
    __lock_acquire.cold+0x152/0x3ca kernel/locking/lockdep.c:5053
    lock_acquire kernel/locking/lockdep.c:5665 [inline]
    lock_acquire+0x1ab/0x520 kernel/locking/lockdep.c:5630
    __mutex_lock_common kernel/locking/mutex.c:603 [inline]
    __mutex_lock+0x14f/0x1610 kernel/locking/mutex.c:747
    usb_stor_pre_reset+0x35/0x40 drivers/usb/storage/usb.c:230
    usb_reset_device+0x37d/0x9a0 drivers/usb/core/hub.c:6109
    r871xu_dev_remove+0x21a/0x270 drivers/staging/rtl8712/usb_intf.c:622
    usb_unbind_interface+0x1bd/0x890 drivers/usb/core/driver.c:458
    device_remove drivers/base/dd.c:545 [inline]
    device_remove+0x11f/0x170 drivers/base/dd.c:537
    __device_release_driver drivers/base/dd.c:1222 [inline]
    device_release_driver_internal+0x1a7/0x2f0 drivers/base/dd.c:1248
    usb_driver_release_interface+0x102/0x180 drivers/usb/core/driver.c:627
    usb_forced_unbind_intf+0x4d/0xa0 drivers/usb/core/driver.c:1118
    usb_reset_device+0x39b/0x9a0 drivers/usb/core/hub.c:6114
    
    This turned out not to be an error in usb-storage but rather a nested
    device reset attempt.  That is, as the rtl8712 driver was being
    unbound from a composite device in preparation for an unrelated USB
    reset (that driver does not have pre_reset or post_reset callbacks),
    its -&gt;remove routine called usb_reset_device() -- thus nesting one
    reset call within another.
    
    Performing a reset as part of disconnect processing is a questionable
    practice at best.  However, the bug report points out that the USB
    core does not have any protection against nested resets.  Adding a
    reset_in_progress flag and testing it will prevent such errors in the
    future.
    
    Link: https://lore.kernel.org/all/CAB7eexKUpvX-JNiLzhXBDWgfg2T9e9_0Tw4HQ6keN==voRbP0g@mail.gmail.com/
    Cc: stable@vger.kernel.org
    Reported-and-tested-by: Rondreis &lt;linhaoguo86@gmail.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/YwkflDxvg0KWqyZK@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 2633acde7ac1..d4b1e70d1498 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -6038,6 +6038,11 @@ static int usb_reset_and_verify_device(struct usb_device *udev)
  * the reset is over (using their post_reset method).
  *
  * Return: The same as for usb_reset_and_verify_device().
+ * However, if a reset is already in progress (for instance, if a
+ * driver doesn't have pre_ or post_reset() callbacks, and while
+ * being unbound or re-bound during the ongoing reset its disconnect()
+ * or probe() routine tries to perform a second, nested reset), the
+ * routine returns -EINPROGRESS.
  *
  * Note:
  * The caller must own the device lock.  For example, it's safe to use
@@ -6071,6 +6076,10 @@ int usb_reset_device(struct usb_device *udev)
 		return -EISDIR;
 	}
 
+	if (udev-&gt;reset_in_progress)
+		return -EINPROGRESS;
+	udev-&gt;reset_in_progress = 1;
+
 	port_dev = hub-&gt;ports[udev-&gt;portnum - 1];
 
 	/*
@@ -6135,6 +6144,7 @@ int usb_reset_device(struct usb_device *udev)
 
 	usb_autosuspend_device(udev);
 	memalloc_noio_restore(noio_flag);
+	udev-&gt;reset_in_progress = 0;
 	return ret;
 }
 EXPORT_SYMBOL_GPL(usb_reset_device);
diff --git a/include/linux/usb.h b/include/linux/usb.h
index f7a9914fc97f..9ff1ad4dfad1 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -575,6 +575,7 @@ struct usb3_lpm_parameters {
  * @devaddr: device address, XHCI: assigned by HW, others: same as devnum
  * @can_submit: URBs may be submitted
  * @persist_enabled:  USB_PERSIST enabled for this device
+ * @reset_in_progress: the device is being reset
  * @have_langid: whether string_langid is valid
  * @authorized: policy has said we can use it;
  *	(user space) policy determines if we authorize this device to be
@@ -662,6 +663,7 @@ struct usb_device {
 
 	unsigned can_submit:1;
 	unsigned persist_enabled:1;
+	unsigned reset_in_progress:1;
 	unsigned have_langid:1;
 	unsigned authorized:1;
 	unsigned authenticated:1;</pre><hr><pre>commit 1016fc0c096c92dd0e6e0541daac7a7868169903
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 26 15:31:17 2022 -0400

    USB: gadget: Fix obscure lockdep violation for udc_mutex
    
    A recent commit expanding the scope of the udc_lock mutex in the
    gadget core managed to cause an obscure and slightly bizarre lockdep
    violation.  In abbreviated form:
    
    ======================================================
    WARNING: possible circular locking dependency detected
    5.19.0-rc7+ #12510 Not tainted
    ------------------------------------------------------
    udevadm/312 is trying to acquire lock:
    ffff80000aae1058 (udc_lock){+.+.}-{3:3}, at: usb_udc_uevent+0x54/0xe0
    
    but task is already holding lock:
    ffff000002277548 (kn-&gt;active#4){++++}-{0:0}, at: kernfs_seq_start+0x34/0xe0
    
    which lock already depends on the new lock.
    
    the existing dependency chain (in reverse order) is:
    
    -&gt; #3 (kn-&gt;active#4){++++}-{0:0}:
            lock_acquire+0x68/0x84
            __kernfs_remove+0x268/0x380
            kernfs_remove_by_name_ns+0x58/0xac
            sysfs_remove_file_ns+0x18/0x24
            device_del+0x15c/0x440
    
    -&gt; #2 (device_links_lock){+.+.}-{3:3}:
            lock_acquire+0x68/0x84
            __mutex_lock+0x9c/0x430
            mutex_lock_nested+0x38/0x64
            device_link_remove+0x3c/0xa0
            _regulator_put.part.0+0x168/0x190
            regulator_put+0x3c/0x54
            devm_regulator_release+0x14/0x20
    
    -&gt; #1 (regulator_list_mutex){+.+.}-{3:3}:
            lock_acquire+0x68/0x84
            __mutex_lock+0x9c/0x430
            mutex_lock_nested+0x38/0x64
            regulator_lock_dependent+0x54/0x284
            regulator_enable+0x34/0x80
            phy_power_on+0x24/0x130
            __dwc2_lowlevel_hw_enable+0x100/0x130
            dwc2_lowlevel_hw_enable+0x18/0x40
            dwc2_hsotg_udc_start+0x6c/0x2f0
            gadget_bind_driver+0x124/0x1f4
    
    -&gt; #0 (udc_lock){+.+.}-{3:3}:
            __lock_acquire+0x1298/0x20cc
            lock_acquire.part.0+0xe0/0x230
            lock_acquire+0x68/0x84
            __mutex_lock+0x9c/0x430
            mutex_lock_nested+0x38/0x64
            usb_udc_uevent+0x54/0xe0
    
    Evidently this was caused by the scope of udc_mutex being too large.
    The mutex is only meant to protect udc-&gt;driver along with a few other
    things.  As far as I can tell, there's no reason for the mutex to be
    held while the gadget core calls a gadget driver's -&gt;bind or -&gt;unbind
    routine, or while a UDC is being started or stopped.  (This accounts
    for link #1 in the chain above, where the mutex is held while the
    dwc2_hsotg_udc is started as part of driver probing.)
    
    Gadget drivers' -&gt;disconnect callbacks are problematic.  Even though
    usb_gadget_disconnect() will now acquire the udc_mutex, there's a
    window in usb_gadget_bind_driver() between the times when the mutex is
    released and the -&gt;bind callback is invoked.  If a disconnect occurred
    during that window, we could call the driver's -&gt;disconnect routine
    before its -&gt;bind routine.  To prevent this from happening, it will be
    necessary to prevent a UDC from connecting while it has no gadget
    driver.  This should be done already but it doesn't seem to be;
    currently usb_gadget_connect() has no check for this.  Such a check
    will have to be added later.
    
    Some degree of mutual exclusion is required in soft_connect_store(),
    which can dereference udc-&gt;driver at arbitrary times since it is a
    sysfs callback.  The solution here is to acquire the gadget's device
    lock rather than the udc_mutex.  Since the driver core guarantees that
    the device lock is always held during driver binding and unbinding,
    this will make the accesses in soft_connect_store() mutually exclusive
    with any changes to udc-&gt;driver.
    
    Lastly, it turns out there is one place which should hold the
    udc_mutex but currently does not: The function_show() routine needs
    protection while it dereferences udc-&gt;driver.  The missing lock and
    unlock calls are added.
    
    Link: https://lore.kernel.org/all/b2ba4245-9917-e399-94c8-03a383e7070e@samsung.com/
    Fixes: 2191c00855b0 ("USB: gadget: Fix use-after-free Read in usb_udc_uevent()")
    Cc: Felipe Balbi &lt;balbi@kernel.org&gt;
    Cc: stable@vger.kernel.org
    Reported-by: Marek Szyprowski &lt;m.szyprowski@samsung.com&gt;
    Tested-by: Marek Szyprowski &lt;m.szyprowski@samsung.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/YwkfhdxA/I2nOcK7@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/gadget/udc/core.c b/drivers/usb/gadget/udc/core.c
index cafcf260394c..c63c0c2cf649 100644
--- a/drivers/usb/gadget/udc/core.c
+++ b/drivers/usb/gadget/udc/core.c
@@ -736,7 +736,10 @@ int usb_gadget_disconnect(struct usb_gadget *gadget)
 	ret = gadget-&gt;ops-&gt;pullup(gadget, 0);
 	if (!ret) {
 		gadget-&gt;connected = 0;
-		gadget-&gt;udc-&gt;driver-&gt;disconnect(gadget);
+		mutex_lock(&amp;udc_lock);
+		if (gadget-&gt;udc-&gt;driver)
+			gadget-&gt;udc-&gt;driver-&gt;disconnect(gadget);
+		mutex_unlock(&amp;udc_lock);
 	}
 
 out:
@@ -1489,7 +1492,6 @@ static int gadget_bind_driver(struct device *dev)
 
 	usb_gadget_udc_set_speed(udc, driver-&gt;max_speed);
 
-	mutex_lock(&amp;udc_lock);
 	ret = driver-&gt;bind(udc-&gt;gadget, driver);
 	if (ret)
 		goto err_bind;
@@ -1499,7 +1501,6 @@ static int gadget_bind_driver(struct device *dev)
 		goto err_start;
 	usb_gadget_enable_async_callbacks(udc);
 	usb_udc_connect_control(udc);
-	mutex_unlock(&amp;udc_lock);
 
 	kobject_uevent(&amp;udc-&gt;dev.kobj, KOBJ_CHANGE);
 	return 0;
@@ -1512,6 +1513,7 @@ static int gadget_bind_driver(struct device *dev)
 		dev_err(&amp;udc-&gt;dev, "failed to start %s: %d\n",
 			driver-&gt;function, ret);
 
+	mutex_lock(&amp;udc_lock);
 	udc-&gt;driver = NULL;
 	driver-&gt;is_bound = false;
 	mutex_unlock(&amp;udc_lock);
@@ -1529,7 +1531,6 @@ static void gadget_unbind_driver(struct device *dev)
 
 	kobject_uevent(&amp;udc-&gt;dev.kobj, KOBJ_CHANGE);
 
-	mutex_lock(&amp;udc_lock);
 	usb_gadget_disconnect(gadget);
 	usb_gadget_disable_async_callbacks(udc);
 	if (gadget-&gt;irq)
@@ -1537,6 +1538,7 @@ static void gadget_unbind_driver(struct device *dev)
 	udc-&gt;driver-&gt;unbind(gadget);
 	usb_gadget_udc_stop(udc);
 
+	mutex_lock(&amp;udc_lock);
 	driver-&gt;is_bound = false;
 	udc-&gt;driver = NULL;
 	mutex_unlock(&amp;udc_lock);
@@ -1612,7 +1614,7 @@ static ssize_t soft_connect_store(struct device *dev,
 	struct usb_udc		*udc = container_of(dev, struct usb_udc, dev);
 	ssize_t			ret;
 
-	mutex_lock(&amp;udc_lock);
+	device_lock(&amp;udc-&gt;gadget-&gt;dev);
 	if (!udc-&gt;driver) {
 		dev_err(dev, "soft-connect without a gadget driver\n");
 		ret = -EOPNOTSUPP;
@@ -1633,7 +1635,7 @@ static ssize_t soft_connect_store(struct device *dev,
 
 	ret = n;
 out:
-	mutex_unlock(&amp;udc_lock);
+	device_unlock(&amp;udc-&gt;gadget-&gt;dev);
 	return ret;
 }
 static DEVICE_ATTR_WO(soft_connect);
@@ -1652,11 +1654,15 @@ static ssize_t function_show(struct device *dev, struct device_attribute *attr,
 			     char *buf)
 {
 	struct usb_udc		*udc = container_of(dev, struct usb_udc, dev);
-	struct usb_gadget_driver *drv = udc-&gt;driver;
+	struct usb_gadget_driver *drv;
+	int			rc = 0;
 
-	if (!drv || !drv-&gt;function)
-		return 0;
-	return scnprintf(buf, PAGE_SIZE, "%s\n", drv-&gt;function);
+	mutex_lock(&amp;udc_lock);
+	drv = udc-&gt;driver;
+	if (drv &amp;&amp; drv-&gt;function)
+		rc = scnprintf(buf, PAGE_SIZE, "%s\n", drv-&gt;function);
+	mutex_unlock(&amp;udc_lock);
+	return rc;
 }
 static DEVICE_ATTR_RO(function);
 </pre><hr><pre>commit 2191c00855b03aa59c20e698be713d952d51fc18
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jul 21 11:07:10 2022 -0400

    USB: gadget: Fix use-after-free Read in usb_udc_uevent()
    
    The syzbot fuzzer found a race between uevent callbacks and gadget
    driver unregistration that can cause a use-after-free bug:
    
    ---------------------------------------------------------------
    BUG: KASAN: use-after-free in usb_udc_uevent+0x11f/0x130
    drivers/usb/gadget/udc/core.c:1732
    Read of size 8 at addr ffff888078ce2050 by task udevd/2968
    
    CPU: 1 PID: 2968 Comm: udevd Not tainted 5.19.0-rc4-next-20220628-syzkaller #0
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google
    06/29/2022
    Call Trace:
     &lt;TASK&gt;
     __dump_stack lib/dump_stack.c:88 [inline]
     dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106
     print_address_description mm/kasan/report.c:317 [inline]
     print_report.cold+0x2ba/0x719 mm/kasan/report.c:433
     kasan_report+0xbe/0x1f0 mm/kasan/report.c:495
     usb_udc_uevent+0x11f/0x130 drivers/usb/gadget/udc/core.c:1732
     dev_uevent+0x290/0x770 drivers/base/core.c:2424
    ---------------------------------------------------------------
    
    The bug occurs because usb_udc_uevent() dereferences udc-&gt;driver but
    does so without acquiring the udc_lock mutex, which protects this
    field.  If the gadget driver is unbound from the udc concurrently with
    uevent processing, the driver structure may be accessed after it has
    been deallocated.
    
    To prevent the race, we make sure that the routine holds the mutex
    around the racing accesses.
    
    Link: &lt;https://lore.kernel.org/all/0000000000004de90405a719c951@google.com&gt;
    CC: stable@vger.kernel.org # fc274c1e9973
    Reported-and-tested-by: syzbot+b0de012ceb1e2a97891b@syzkaller.appspotmail.com
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/YtlrnhHyrHsSky9m@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/gadget/udc/core.c b/drivers/usb/gadget/udc/core.c
index 7886497253cc..cafcf260394c 100644
--- a/drivers/usb/gadget/udc/core.c
+++ b/drivers/usb/gadget/udc/core.c
@@ -1728,13 +1728,14 @@ static int usb_udc_uevent(struct device *dev, struct kobj_uevent_env *env)
 		return ret;
 	}
 
-	if (udc-&gt;driver) {
+	mutex_lock(&amp;udc_lock);
+	if (udc-&gt;driver)
 		ret = add_uevent_var(env, "USB_UDC_DRIVER=%s",
 				udc-&gt;driver-&gt;function);
-		if (ret) {
-			dev_err(dev, "failed to add uevent USB_UDC_DRIVER\n");
-			return ret;
-		}
+	mutex_unlock(&amp;udc_lock);
+	if (ret) {
+		dev_err(dev, "failed to add uevent USB_UDC_DRIVER\n");
+		return ret;
 	}
 
 	return 0;</pre><hr><pre>commit 90bc2af24638659da56397ff835f3c95a948f991
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jun 22 10:46:31 2022 -0400

    USB: gadget: Fix double-free bug in raw_gadget driver
    
    Re-reading a recently merged fix to the raw_gadget driver showed that
    it inadvertently introduced a double-free bug in a failure pathway.
    If raw_ioctl_init() encounters an error after the driver ID number has
    been allocated, it deallocates the ID number before returning.  But
    when dev_free() runs later on, it will then try to deallocate the ID
    number a second time.
    
    Closely related to this issue is another error in the recent fix: The
    ID number is stored in the raw_dev structure before the code checks to
    see whether the structure has already been initialized, in which case
    the new ID number would overwrite the earlier value.
    
    The solution to both bugs is to keep the new ID number in a local
    variable, and store it in the raw_dev structure only after the check
    for prior initialization.  No errors can occur after that point, so
    the double-free will never happen.
    
    Fixes: f2d8c2606825 ("usb: gadget: Fix non-unique driver names in raw-gadget driver")
    CC: Andrey Konovalov &lt;andreyknvl@gmail.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/YrMrRw5AyIZghN0v@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/gadget/legacy/raw_gadget.c b/drivers/usb/gadget/legacy/raw_gadget.c
index 5c8481cef35f..2acece16b890 100644
--- a/drivers/usb/gadget/legacy/raw_gadget.c
+++ b/drivers/usb/gadget/legacy/raw_gadget.c
@@ -430,6 +430,7 @@ static int raw_release(struct inode *inode, struct file *fd)
 static int raw_ioctl_init(struct raw_dev *dev, unsigned long value)
 {
 	int ret = 0;
+	int driver_id_number;
 	struct usb_raw_init arg;
 	char *udc_driver_name;
 	char *udc_device_name;
@@ -452,10 +453,9 @@ static int raw_ioctl_init(struct raw_dev *dev, unsigned long value)
 		return -EINVAL;
 	}
 
-	ret = ida_alloc(&amp;driver_id_numbers, GFP_KERNEL);
-	if (ret &lt; 0)
-		return ret;
-	dev-&gt;driver_id_number = ret;
+	driver_id_number = ida_alloc(&amp;driver_id_numbers, GFP_KERNEL);
+	if (driver_id_number &lt; 0)
+		return driver_id_number;
 
 	driver_driver_name = kmalloc(DRIVER_DRIVER_NAME_LENGTH_MAX, GFP_KERNEL);
 	if (!driver_driver_name) {
@@ -463,7 +463,7 @@ static int raw_ioctl_init(struct raw_dev *dev, unsigned long value)
 		goto out_free_driver_id_number;
 	}
 	snprintf(driver_driver_name, DRIVER_DRIVER_NAME_LENGTH_MAX,
-				DRIVER_NAME ".%d", dev-&gt;driver_id_number);
+				DRIVER_NAME ".%d", driver_id_number);
 
 	udc_driver_name = kmalloc(UDC_NAME_LENGTH_MAX, GFP_KERNEL);
 	if (!udc_driver_name) {
@@ -507,6 +507,7 @@ static int raw_ioctl_init(struct raw_dev *dev, unsigned long value)
 	dev-&gt;driver.driver.name = driver_driver_name;
 	dev-&gt;driver.udc_name = udc_device_name;
 	dev-&gt;driver.match_existing_only = 1;
+	dev-&gt;driver_id_number = driver_id_number;
 
 	dev-&gt;state = STATE_DEV_INITIALIZED;
 	spin_unlock_irqrestore(&amp;dev-&gt;lock, flags);
@@ -521,7 +522,7 @@ static int raw_ioctl_init(struct raw_dev *dev, unsigned long value)
 out_free_driver_driver_name:
 	kfree(driver_driver_name);
 out_free_driver_id_number:
-	ida_free(&amp;driver_id_numbers, dev-&gt;driver_id_number);
+	ida_free(&amp;driver_id_numbers, driver_id_number);
 	return ret;
 }
 </pre><hr><pre>commit f2d8c2606825317b77db1f9ba0fc26ef26160b30
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jun 13 10:17:03 2022 -0400

    usb: gadget: Fix non-unique driver names in raw-gadget driver
    
    In a report for a separate bug (which has already been fixed by commit
    5f0b5f4d50fa "usb: gadget: fix race when gadget driver register via
    ioctl") in the raw-gadget driver, the syzbot console log included
    error messages caused by attempted registration of a new driver with
    the same name as an existing driver:
    
    &gt; kobject_add_internal failed for raw-gadget with -EEXIST, don't try to register things with the same name in the same directory.
    &gt; UDC core: USB Raw Gadget: driver registration failed: -17
    &gt; misc raw-gadget: fail, usb_gadget_register_driver returned -17
    
    These errors arise because raw_gadget.c registers a separate UDC
    driver for each of the UDC instances it creates, but these drivers all
    have the same name: "raw-gadget".  Until recently this wasn't a
    problem, but when the "gadget" bus was added and UDC drivers were
    registered on this bus, it became possible for name conflicts to cause
    the registrations to fail.  The reason is simply that the bus code in
    the driver core uses the driver name as a sysfs directory name (e.g.,
    /sys/bus/gadget/drivers/raw-gadget/), and you can't create two
    directories with the same pathname.
    
    To fix this problem, the driver names used by raw-gadget are made
    distinct by appending a unique ID number: "raw-gadget.N", with a
    different value of N for each driver instance.  And to avoid the
    proliferation of error handling code in the raw_ioctl_init() routine,
    the error return paths are refactored into the common pattern (goto
    statements leading to cleanup code at the end of the routine).
    
    Link: https://lore.kernel.org/all/0000000000008c664105dffae2eb@google.com/
    Fixes: fc274c1e9973 "USB: gadget: Add a new bus for gadgets"
    CC: Andrey Konovalov &lt;andreyknvl@gmail.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Reported-and-tested-by: syzbot+02b16343704b3af1667e@syzkaller.appspotmail.com
    Reviewed-by: Andrey Konovalov &lt;andreyknvl@gmail.com&gt;
    Acked-by: Hillf Danton &lt;hdanton@sina.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/YqdG32w+3h8c1s7z@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/gadget/legacy/raw_gadget.c b/drivers/usb/gadget/legacy/raw_gadget.c
index 241740024c50..5c8481cef35f 100644
--- a/drivers/usb/gadget/legacy/raw_gadget.c
+++ b/drivers/usb/gadget/legacy/raw_gadget.c
@@ -11,6 +11,7 @@
 #include &lt;linux/ctype.h&gt;
 #include &lt;linux/debugfs.h&gt;
 #include &lt;linux/delay.h&gt;
+#include &lt;linux/idr.h&gt;
 #include &lt;linux/kref.h&gt;
 #include &lt;linux/miscdevice.h&gt;
 #include &lt;linux/module.h&gt;
@@ -36,6 +37,9 @@ MODULE_LICENSE("GPL");
 
 /*----------------------------------------------------------------------*/
 
+static DEFINE_IDA(driver_id_numbers);
+#define DRIVER_DRIVER_NAME_LENGTH_MAX	32
+
 #define RAW_EVENT_QUEUE_SIZE	16
 
 struct raw_event_queue {
@@ -161,6 +165,9 @@ struct raw_dev {
 	/* Reference to misc device: */
 	struct device			*dev;
 
+	/* Make driver names unique */
+	int				driver_id_number;
+
 	/* Protected by lock: */
 	enum dev_state			state;
 	bool				gadget_registered;
@@ -189,6 +196,7 @@ static struct raw_dev *dev_new(void)
 	spin_lock_init(&amp;dev-&gt;lock);
 	init_completion(&amp;dev-&gt;ep0_done);
 	raw_event_queue_init(&amp;dev-&gt;queue);
+	dev-&gt;driver_id_number = -1;
 	return dev;
 }
 
@@ -199,6 +207,9 @@ static void dev_free(struct kref *kref)
 
 	kfree(dev-&gt;udc_name);
 	kfree(dev-&gt;driver.udc_name);
+	kfree(dev-&gt;driver.driver.name);
+	if (dev-&gt;driver_id_number &gt;= 0)
+		ida_free(&amp;driver_id_numbers, dev-&gt;driver_id_number);
 	if (dev-&gt;req) {
 		if (dev-&gt;ep0_urb_queued)
 			usb_ep_dequeue(dev-&gt;gadget-&gt;ep0, dev-&gt;req);
@@ -422,6 +433,7 @@ static int raw_ioctl_init(struct raw_dev *dev, unsigned long value)
 	struct usb_raw_init arg;
 	char *udc_driver_name;
 	char *udc_device_name;
+	char *driver_driver_name;
 	unsigned long flags;
 
 	if (copy_from_user(&amp;arg, (void __user *)value, sizeof(arg)))
@@ -440,36 +452,44 @@ static int raw_ioctl_init(struct raw_dev *dev, unsigned long value)
 		return -EINVAL;
 	}
 
+	ret = ida_alloc(&amp;driver_id_numbers, GFP_KERNEL);
+	if (ret &lt; 0)
+		return ret;
+	dev-&gt;driver_id_number = ret;
+
+	driver_driver_name = kmalloc(DRIVER_DRIVER_NAME_LENGTH_MAX, GFP_KERNEL);
+	if (!driver_driver_name) {
+		ret = -ENOMEM;
+		goto out_free_driver_id_number;
+	}
+	snprintf(driver_driver_name, DRIVER_DRIVER_NAME_LENGTH_MAX,
+				DRIVER_NAME ".%d", dev-&gt;driver_id_number);
+
 	udc_driver_name = kmalloc(UDC_NAME_LENGTH_MAX, GFP_KERNEL);
-	if (!udc_driver_name)
-		return -ENOMEM;
+	if (!udc_driver_name) {
+		ret = -ENOMEM;
+		goto out_free_driver_driver_name;
+	}
 	ret = strscpy(udc_driver_name, &amp;arg.driver_name[0],
 				UDC_NAME_LENGTH_MAX);
-	if (ret &lt; 0) {
-		kfree(udc_driver_name);
-		return ret;
-	}
+	if (ret &lt; 0)
+		goto out_free_udc_driver_name;
 	ret = 0;
 
 	udc_device_name = kmalloc(UDC_NAME_LENGTH_MAX, GFP_KERNEL);
 	if (!udc_device_name) {
-		kfree(udc_driver_name);
-		return -ENOMEM;
+		ret = -ENOMEM;
+		goto out_free_udc_driver_name;
 	}
 	ret = strscpy(udc_device_name, &amp;arg.device_name[0],
 				UDC_NAME_LENGTH_MAX);
-	if (ret &lt; 0) {
-		kfree(udc_driver_name);
-		kfree(udc_device_name);
-		return ret;
-	}
+	if (ret &lt; 0)
+		goto out_free_udc_device_name;
 	ret = 0;
 
 	spin_lock_irqsave(&amp;dev-&gt;lock, flags);
 	if (dev-&gt;state != STATE_DEV_OPENED) {
 		dev_dbg(dev-&gt;dev, "fail, device is not opened\n");
-		kfree(udc_driver_name);
-		kfree(udc_device_name);
 		ret = -EINVAL;
 		goto out_unlock;
 	}
@@ -484,14 +504,24 @@ static int raw_ioctl_init(struct raw_dev *dev, unsigned long value)
 	dev-&gt;driver.suspend = gadget_suspend;
 	dev-&gt;driver.resume = gadget_resume;
 	dev-&gt;driver.reset = gadget_reset;
-	dev-&gt;driver.driver.name = DRIVER_NAME;
+	dev-&gt;driver.driver.name = driver_driver_name;
 	dev-&gt;driver.udc_name = udc_device_name;
 	dev-&gt;driver.match_existing_only = 1;
 
 	dev-&gt;state = STATE_DEV_INITIALIZED;
+	spin_unlock_irqrestore(&amp;dev-&gt;lock, flags);
+	return ret;
 
 out_unlock:
 	spin_unlock_irqrestore(&amp;dev-&gt;lock, flags);
+out_free_udc_device_name:
+	kfree(udc_device_name);
+out_free_udc_driver_name:
+	kfree(udc_driver_name);
+out_free_driver_driver_name:
+	kfree(driver_driver_name);
+out_free_driver_id_number:
+	ida_free(&amp;driver_id_numbers, dev-&gt;driver_id_number);
 	return ret;
 }
 </pre><hr><pre>commit f9d76d15072caf1ec5558fa7cc6d93c7b9d33488
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 10 11:51:29 2022 -0400

    USB: gadget: Add ID numbers to gadget names
    
    Putting USB gadgets on a new bus of their own encounters a problem
    when multiple gadgets are present: They all have the same name!  The
    driver core fails with a "sys: cannot create duplicate filename" error
    when creating any of the /sys/bus/gadget/devices/&lt;gadget-name&gt;
    symbolic links after the first.
    
    This patch fixes the problem by adding a ".N" suffix to each gadget's
    name when the gadget is registered (where N is a unique ID number),
    thus making the names distinct.
    
    Reported-and-tested-by: Geert Uytterhoeven &lt;geert+renesas@glider.be&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reviewed-by: Geert Uytterhoeven &lt;geert+renesas@glider.be&gt;
    Fixes: fc274c1e9973 ("USB: gadget: Add a new bus for gadgets")
    Link: https://lore.kernel.org/r/YnqKAXKyp9Vq/pbn@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/gadget/udc/core.c b/drivers/usb/gadget/udc/core.c
index 3281d8a3dae7..7886497253cc 100644
--- a/drivers/usb/gadget/udc/core.c
+++ b/drivers/usb/gadget/udc/core.c
@@ -12,6 +12,7 @@
 #include &lt;linux/module.h&gt;
 #include &lt;linux/device.h&gt;
 #include &lt;linux/list.h&gt;
+#include &lt;linux/idr.h&gt;
 #include &lt;linux/err.h&gt;
 #include &lt;linux/dma-mapping.h&gt;
 #include &lt;linux/sched/task_stack.h&gt;
@@ -23,6 +24,8 @@
 
 #include "trace.h"
 
+static DEFINE_IDA(gadget_id_numbers);
+
 static struct bus_type gadget_bus_type;
 
 /**
@@ -1248,7 +1251,6 @@ static void usb_udc_nop_release(struct device *dev)
 void usb_initialize_gadget(struct device *parent, struct usb_gadget *gadget,
 		void (*release)(struct device *dev))
 {
-	dev_set_name(&amp;gadget-&gt;dev, "gadget");
 	INIT_WORK(&amp;gadget-&gt;work, usb_gadget_state_work);
 	gadget-&gt;dev.parent = parent;
 
@@ -1304,12 +1306,21 @@ int usb_add_gadget(struct usb_gadget *gadget)
 	usb_gadget_set_state(gadget, USB_STATE_NOTATTACHED);
 	udc-&gt;vbus = true;
 
+	ret = ida_alloc(&amp;gadget_id_numbers, GFP_KERNEL);
+	if (ret &lt; 0)
+		goto err_del_udc;
+	gadget-&gt;id_number = ret;
+	dev_set_name(&amp;gadget-&gt;dev, "gadget.%d", ret);
+
 	ret = device_add(&amp;gadget-&gt;dev);
 	if (ret)
-		goto err_del_udc;
+		goto err_free_id;
 
 	return 0;
 
+ err_free_id:
+	ida_free(&amp;gadget_id_numbers, gadget-&gt;id_number);
+
  err_del_udc:
 	flush_work(&amp;gadget-&gt;work);
 	device_del(&amp;udc-&gt;dev);
@@ -1417,6 +1428,7 @@ void usb_del_gadget(struct usb_gadget *gadget)
 	kobject_uevent(&amp;udc-&gt;dev.kobj, KOBJ_REMOVE);
 	flush_work(&amp;gadget-&gt;work);
 	device_del(&amp;gadget-&gt;dev);
+	ida_free(&amp;gadget_id_numbers, gadget-&gt;id_number);
 	device_unregister(&amp;udc-&gt;dev);
 }
 EXPORT_SYMBOL_GPL(usb_del_gadget);
diff --git a/include/linux/usb/gadget.h b/include/linux/usb/gadget.h
index cf7af8a0a6e9..3ad58b7a0824 100644
--- a/include/linux/usb/gadget.h
+++ b/include/linux/usb/gadget.h
@@ -386,6 +386,7 @@ struct usb_gadget_ops {
  * @lpm_capable: If the gadget max_speed is FULL or HIGH, this flag
  *	indicates that it supports LPM as per the LPM ECN &amp; errata.
  * @irq: the interrupt number for device controller.
+ * @id_number: a unique ID number for ensuring that gadget names are distinct
  *
  * Gadgets have a mostly-portable "gadget driver" implementing device
  * functions, handling all usb configurations and interfaces.  Gadget
@@ -446,6 +447,7 @@ struct usb_gadget {
 	unsigned			connected:1;
 	unsigned			lpm_capable:1;
 	int				irq;
+	int				id_number;
 };
 #define work_to_gadget(w)	(container_of((w), struct usb_gadget, work))
 </pre>
    <div class="pagination">
        <a href='2_3.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><span>[4]</span><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_5.html'>Next&gt;&gt;</a>
    <div>
</body>
