<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_37.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><span>[38]</span><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_39.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit d714aaf649460cbfd5e82e75520baa856b4fa0a0
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Mar 20 15:07:26 2013 -0400

    USB: EHCI: fix regression in QH unlinking
    
    This patch (as1670) fixes a regression caused by commit
    6402c796d3b4205d3d7296157956c5100a05d7d6 (USB: EHCI: work around
    silicon bug in Intel's EHCI controllers).  The workaround goes through
    two IAA cycles for each QH being unlinked.  During the first cycle,
    the QH is not added to the async_iaa list (because it isn't fully gone
    from the hardware yet), which means that list will be empty.
    
    Unfortunately, I forgot to update the IAA watchdog timer routine.  It
    thinks that an empty async_iaa list means the timer expiration was an
    error, which isn't true any more.  This problem didn't show up during
    initial testing because the controllers being tested all had working
    IAA interrupts.  But not all controllers do, and when the watchdog
    timer expires, the empty-list check prevents the second IAA cycle from
    starting.  As a result, URB unlinks never complete.  The check needs
    to be removed.
    
    Among the symptoms of the regression are processes stuck in D wait
    states and hangs during system shutdown.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Stephen Warren &lt;swarren@wwwdotorg.org&gt;
    Reported-and-tested-by: Sven Joachim &lt;svenjoac@gmx.de&gt;
    Reported-by: Andreas Bombe &lt;aeb@debian.org&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index 20dbdcbe9b0f..c3fa1305f830 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -304,7 +304,7 @@ static void ehci_iaa_watchdog(struct ehci_hcd *ehci)
 	 * (a) SMP races against real IAA firing and retriggering, and
 	 * (b) clean HC shutdown, when IAA watchdog was pending.
 	 */
-	if (ehci-&gt;async_iaa) {
+	if (1) {
 		u32 cmd, status;
 
 		/* If we get here, IAA is *REALLY* late.  It's barely</pre><hr><pre>commit 8119b55aed818e590c26cb97706c914e3d660fd8
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Mar 15 14:03:17 2013 -0400

    USB: gadget: net2280: remove leftover driver-&gt;unbind call in error pathway
    
    This patch (as1667) removes an incorrect driver-&gt;unbind() call from
    the net2280 driver.  If startup fails, the UDC core takes care of
    unbinding the gadget driver automatically; the controller driver
    shouldn't do it too.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Felipe Balbi &lt;balbi@ti.com&gt;

diff --git a/drivers/usb/gadget/net2280.c b/drivers/usb/gadget/net2280.c
index 3105a4d601c8..3bd0f992fb49 100644
--- a/drivers/usb/gadget/net2280.c
+++ b/drivers/usb/gadget/net2280.c
@@ -1924,7 +1924,6 @@ static int net2280_start(struct usb_gadget *_gadget,
 err_func:
 	device_remove_file (&amp;dev-&gt;pdev-&gt;dev, &amp;dev_attr_function);
 err_unbind:
-	driver-&gt;unbind (&amp;dev-&gt;gadget);
 	dev-&gt;gadget.dev.driver = NULL;
 	dev-&gt;driver = NULL;
 	return retval;</pre><hr><pre>commit 511f3c5326eabe1ece35202a404c24c0aeacc246
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Mar 15 14:02:14 2013 -0400

    usb: gadget: udc-core: fix a regression during gadget driver unbinding
    
    This patch (as1666) fixes a regression in the UDC core.  The core
    takes care of unbinding gadget drivers, and it does the unbinding
    before telling the UDC driver to turn off the controller hardware.
    When the call to the udc_stop callback is made, the gadget no longer
    has a driver.  The callback routine should not be invoked with a
    pointer to the old driver; doing so can cause problems (such as
    use-after-free accesses in net2280).
    
    This patch should be applied, with appropriate context changes, to all
    the stable kernels going back to 3.1.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Felipe Balbi &lt;balbi@ti.com&gt;

diff --git a/drivers/usb/gadget/udc-core.c b/drivers/usb/gadget/udc-core.c
index 2a9cd369f71c..f8f62c3ed65e 100644
--- a/drivers/usb/gadget/udc-core.c
+++ b/drivers/usb/gadget/udc-core.c
@@ -216,7 +216,7 @@ static void usb_gadget_remove_driver(struct usb_udc *udc)
 	usb_gadget_disconnect(udc-&gt;gadget);
 	udc-&gt;driver-&gt;disconnect(udc-&gt;gadget);
 	udc-&gt;driver-&gt;unbind(udc-&gt;gadget);
-	usb_gadget_udc_stop(udc-&gt;gadget, udc-&gt;driver);
+	usb_gadget_udc_stop(udc-&gt;gadget, NULL);
 
 	udc-&gt;driver = NULL;
 	udc-&gt;dev.driver = NULL;</pre><hr><pre>commit 24b90814fb133bb7971aef8ea5e642d9f9bc4b0b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Mar 18 12:05:42 2013 -0400

    USB: EHCI: don't turn on PORT_SUSPEND during port resume
    
    This patch (as1637) cleans up the way ehci-hcd handles end-of-resume
    port signalling.  When the PORT_RESUME bit in the port's status and
    control register is cleared, we shouldn't be setting the PORT_SUSPEND
    bit at the same time.  Not doing this doesn't seem to have hurt so
    far, but we might as well do the right thing.
    
    Also, the patch replaces an estimated value for what the port status
    should be following a resume with the actual register value.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 576b735f49b6..0df45d933a10 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -464,7 +464,7 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 	while (i--) {
 		temp = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;port_status [i]);
 		if (test_bit(i, &amp;resume_needed)) {
-			temp &amp;= ~(PORT_RWC_BITS | PORT_RESUME);
+			temp &amp;= ~(PORT_RWC_BITS | PORT_SUSPEND | PORT_RESUME);
 			ehci_writel(ehci, temp, &amp;ehci-&gt;regs-&gt;port_status [i]);
 			ehci_vdbg (ehci, "resumed port %d\n", i + 1);
 		}
@@ -871,10 +871,9 @@ static int ehci_hub_control (
 				usb_hcd_end_port_resume(&amp;hcd-&gt;self, wIndex);
 
 				/* stop resume signaling */
-				temp = ehci_readl(ehci, status_reg);
-				ehci_writel(ehci,
-					temp &amp; ~(PORT_RWC_BITS | PORT_RESUME),
-					status_reg);
+				temp &amp;= ~(PORT_RWC_BITS |
+						PORT_SUSPEND | PORT_RESUME);
+				ehci_writel(ehci, temp, status_reg);
 				clear_bit(wIndex, &amp;ehci-&gt;resuming_ports);
 				retval = handshake(ehci, status_reg,
 					   PORT_RESUME, 0, 2000 /* 2msec */);
@@ -884,7 +883,7 @@ static int ehci_hub_control (
 						wIndex + 1, retval);
 					goto error;
 				}
-				temp &amp;= ~(PORT_SUSPEND|PORT_RESUME|(3&lt;&lt;10));
+				temp = ehci_readl(ehci, status_reg);
 			}
 		}
 </pre><hr><pre>commit 60fd4aa742a0c4f01dafeb0d125fed54e91e3657
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Mar 18 12:05:19 2013 -0400

    USB: EHCI: reorganize ehci_iaa_watchdog()
    
    This patch (as1635) rearranges the control-flow logic in
    ehci_iaa_watchdog() slightly to agree better with the comments.  It
    also changes a verbose-debug message to a regular debug message.
    Expiration of the IAA watchdog is an unusual event and can lead to
    problems; we need to know about it if it happens during debugging.  It
    should not be necessary to set a "verbose" compilation option.
    
    No behavioral changes other than the debug message.  Lots of apparent
    changes to the source text, though, because the indentation level was
    decreased.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index cc9ad5892d19..97815d0fc97c 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -295,8 +295,7 @@ static void end_free_itds(struct ehci_hcd *ehci)
 /* Handle lost (or very late) IAA interrupts */
 static void ehci_iaa_watchdog(struct ehci_hcd *ehci)
 {
-	if (ehci-&gt;rh_state != EHCI_RH_RUNNING)
-		return;
+	u32 cmd, status;
 
 	/*
 	 * Lost IAA irqs wedge things badly; seen first with a vt8235.
@@ -304,34 +303,32 @@ static void ehci_iaa_watchdog(struct ehci_hcd *ehci)
 	 * (a) SMP races against real IAA firing and retriggering, and
 	 * (b) clean HC shutdown, when IAA watchdog was pending.
 	 */
-	if (ehci-&gt;async_iaa) {
-		u32 cmd, status;
-
-		/* If we get here, IAA is *REALLY* late.  It's barely
-		 * conceivable that the system is so busy that CMD_IAAD
-		 * is still legitimately set, so let's be sure it's
-		 * clear before we read STS_IAA.  (The HC should clear
-		 * CMD_IAAD when it sets STS_IAA.)
-		 */
-		cmd = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
-
-		/*
-		 * If IAA is set here it either legitimately triggered
-		 * after the watchdog timer expired (_way_ late, so we'll
-		 * still count it as lost) ... or a silicon erratum:
-		 * - VIA seems to set IAA without triggering the IRQ;
-		 * - IAAD potentially cleared without setting IAA.
-		 */
-		status = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;status);
-		if ((status &amp; STS_IAA) || !(cmd &amp; CMD_IAAD)) {
-			COUNT(ehci-&gt;stats.lost_iaa);
-			ehci_writel(ehci, STS_IAA, &amp;ehci-&gt;regs-&gt;status);
-		}
+	if (!ehci-&gt;async_iaa || ehci-&gt;rh_state != EHCI_RH_RUNNING)
+		return;
+
+	/* If we get here, IAA is *REALLY* late.  It's barely
+	 * conceivable that the system is so busy that CMD_IAAD
+	 * is still legitimately set, so let's be sure it's
+	 * clear before we read STS_IAA.  (The HC should clear
+	 * CMD_IAAD when it sets STS_IAA.)
+	 */
+	cmd = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
 
-		ehci_vdbg(ehci, "IAA watchdog: status %x cmd %x\n",
-				status, cmd);
-		end_unlink_async(ehci);
+	/*
+	 * If IAA is set here it either legitimately triggered
+	 * after the watchdog timer expired (_way_ late, so we'll
+	 * still count it as lost) ... or a silicon erratum:
+	 * - VIA seems to set IAA without triggering the IRQ;
+	 * - IAAD potentially cleared without setting IAA.
+	 */
+	status = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;status);
+	if ((status &amp; STS_IAA) || !(cmd &amp; CMD_IAAD)) {
+		COUNT(ehci-&gt;stats.lost_iaa);
+		ehci_writel(ehci, STS_IAA, &amp;ehci-&gt;regs-&gt;status);
 	}
+
+	ehci_dbg(ehci, "IAA watchdog: status %x cmd %x\n", status, cmd);
+	end_unlink_async(ehci);
 }
 
 </pre><hr><pre>commit 4dd405a4b0969bfec4dc9959050b46d818b6549b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Mar 18 12:05:08 2013 -0400

    USB: EHCI: improve use of per-port status-change bits
    
    This patch (as1634) simplifies some of the code associated with the
    per-port change bits added in EHCI-1.1, and in particular it fixes a
    bug in the logic of ehci_hub_status_data().  Even if the change bit
    doesn't indicate anything happened on a particular port, we still have
    to notify the core about changes to the suspend or reset status.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 303b0222cd6d..fcf8b940e867 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -758,7 +758,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 	/* remote wakeup [4.3.1] */
 	if (status &amp; STS_PCD) {
 		unsigned	i = HCS_N_PORTS (ehci-&gt;hcs_params);
-		u32		ppcd = 0;
+		u32		ppcd = ~0;
 
 		/* kick root hub later */
 		pcd_status = status;
@@ -775,7 +775,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 			int pstatus;
 
 			/* leverage per-port change bits feature */
-			if (ehci-&gt;has_ppcd &amp;&amp; !(ppcd &amp; (1 &lt;&lt; i)))
+			if (!(ppcd &amp; (1 &lt;&lt; i)))
 				continue;
 			pstatus = ehci_readl(ehci,
 					 &amp;ehci-&gt;regs-&gt;port_status[i]);
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 4d3b294f203e..576b735f49b6 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -590,7 +590,7 @@ ehci_hub_status_data (struct usb_hcd *hcd, char *buf)
 	u32		mask;
 	int		ports, i, retval = 1;
 	unsigned long	flags;
-	u32		ppcd = 0;
+	u32		ppcd = ~0;
 
 	/* init status to no-changes */
 	buf [0] = 0;
@@ -628,9 +628,10 @@ ehci_hub_status_data (struct usb_hcd *hcd, char *buf)
 
 	for (i = 0; i &lt; ports; i++) {
 		/* leverage per-port change bits feature */
-		if (ehci-&gt;has_ppcd &amp;&amp; !(ppcd &amp; (1 &lt;&lt; i)))
-			continue;
-		temp = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;port_status [i]);
+		if (ppcd &amp; (1 &lt;&lt; i))
+			temp = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;port_status[i]);
+		else
+			temp = 0;
 
 		/*
 		 * Return status information even for ports with OWNER set.</pre><hr><pre>commit 6d5df8976266d8e40603601f7695537f9f3dc9e2
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Mar 18 12:04:54 2013 -0400

    USB: EHCI: decrease schedule-status poll timeout
    
    This patch (as1657) decreases the timeout used by ehci-hcd for polling
    the async and periodic schedule statuses.  The timeout is currently
    set to 20 ms, which is much too high.  Controllers should always
    update the schedule status within one or two ms of being told to do
    so; if they don't then something is wrong.
    
    Furthermore, bug reports have shown that sometimes controllers
    (particularly those made by VIA) don't update the status bit at all,
    even when the schedule does change state.  When this happens, polling
    for 20 ms would cause an unnecessarily long delay.
    
    The delay is reduced to somewhere between 2 and 4 ms, depending on the
    slop allowed by the kernel's high-res timers.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index 20dbdcbe9b0f..cc9ad5892d19 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -113,8 +113,8 @@ static void ehci_poll_ASS(struct ehci_hcd *ehci)
 
 	if (want != actual) {
 
-		/* Poll again later, but give up after about 20 ms */
-		if (ehci-&gt;ASS_poll_count++ &lt; 20) {
+		/* Poll again later, but give up after about 2-4 ms */
+		if (ehci-&gt;ASS_poll_count++ &lt; 2) {
 			ehci_enable_event(ehci, EHCI_HRTIMER_POLL_ASS, true);
 			return;
 		}
@@ -159,8 +159,8 @@ static void ehci_poll_PSS(struct ehci_hcd *ehci)
 
 	if (want != actual) {
 
-		/* Poll again later, but give up after about 20 ms */
-		if (ehci-&gt;PSS_poll_count++ &lt; 20) {
+		/* Poll again later, but give up after about 2-4 ms */
+		if (ehci-&gt;PSS_poll_count++ &lt; 2) {
 			ehci_enable_event(ehci, EHCI_HRTIMER_POLL_PSS, true);
 			return;
 		}</pre><hr><pre>commit 2a40f324541ee61c22146214349c2ce9f5c30bcf
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Mar 15 14:40:26 2013 -0400

    USB: EHCI: fix regression during bus resume
    
    This patch (as1663) fixes a regression caused by commit
    6e0c3339a6f19d748f16091d0a05adeb1e1f822b (USB: EHCI: unlink one async
    QH at a time).  In order to avoid keeping multiple QHs in an unusable
    intermediate state, that commit changed unlink_empty_async() so that
    it unlinks only one empty QH at a time.
    
    However, when the EHCI root hub is suspended, _all_ async QHs need to
    be unlinked.  ehci_bus_suspend() used to do this by calling
    unlink_empty_async(), but now this only unlinks one of the QHs, not
    all of them.
    
    The symptom is that when the root hub is resumed, USB communications
    don't work for some period of time.  This is because ehci-hcd doesn't
    realize it needs to restart the async schedule; it assumes that
    because some QHs are already on the schedule, the schedule must be
    running.
    
    The easiest way to fix the problem is add a new function that unlinks
    all the async QHs when the root hub is suspended.
    
    This patch should be applied to all kernels that have the 6e0c3339a6f1
    commit.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Adrian Bassett &lt;adrian.bassett@hotmail.co.uk&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 5726cb144abf..416a6dce5e11 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -302,6 +302,7 @@ static void ehci_quiesce (struct ehci_hcd *ehci)
 
 static void end_unlink_async(struct ehci_hcd *ehci);
 static void unlink_empty_async(struct ehci_hcd *ehci);
+static void unlink_empty_async_suspended(struct ehci_hcd *ehci);
 static void ehci_work(struct ehci_hcd *ehci);
 static void start_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh);
 static void end_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh);
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 4d3b294f203e..7d06e77f6c4f 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -328,7 +328,7 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 	ehci-&gt;rh_state = EHCI_RH_SUSPENDED;
 
 	end_unlink_async(ehci);
-	unlink_empty_async(ehci);
+	unlink_empty_async_suspended(ehci);
 	ehci_handle_intr_unlinks(ehci);
 	end_free_itds(ehci);
 
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 5464665f0b6a..23d136904285 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -1316,6 +1316,19 @@ static void unlink_empty_async(struct ehci_hcd *ehci)
 	}
 }
 
+/* The root hub is suspended; unlink all the async QHs */
+static void unlink_empty_async_suspended(struct ehci_hcd *ehci)
+{
+	struct ehci_qh		*qh;
+
+	while (ehci-&gt;async-&gt;qh_next.qh) {
+		qh = ehci-&gt;async-&gt;qh_next.qh;
+		WARN_ON(!list_empty(&amp;qh-&gt;qtd_list));
+		single_unlink_async(ehci, qh);
+	}
+	start_iaa_cycle(ehci, false);
+}
+
 /* makes sure the async qh will become idle */
 /* caller must own ehci-&gt;lock */
 </pre><hr><pre>commit 54a419668b0f27b7982807fb2376d237e0a0ce05
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Mar 12 12:44:39 2013 +0200

    USB: EHCI: split ehci-omap out to a separate driver
    
    This patch (as1645) converts ehci-omap over to the new "ehci-hcd is a
    library" approach, so that it can coexist peacefully with other EHCI
    platform drivers and can make use of the private area allocated at
    the end of struct ehci_hcd.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index c59a1126926f..62f4e9a38557 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -155,7 +155,7 @@ config USB_EHCI_MXC
 	  Variation of ARC USB block used in some Freescale chips.
 
 config USB_EHCI_HCD_OMAP
-	bool "EHCI support for OMAP3 and later chips"
+	tristate "EHCI support for OMAP3 and later chips"
 	depends on USB_EHCI_HCD &amp;&amp; ARCH_OMAP
 	default y
 	---help---
diff --git a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
index 001fbff2fdef..56de4106c8b3 100644
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -27,6 +27,7 @@ obj-$(CONFIG_USB_EHCI_HCD)	+= ehci-hcd.o
 obj-$(CONFIG_USB_EHCI_PCI)	+= ehci-pci.o
 obj-$(CONFIG_USB_EHCI_HCD_PLATFORM)	+= ehci-platform.o
 obj-$(CONFIG_USB_EHCI_MXC)	+= ehci-mxc.o
+obj-$(CONFIG_USB_EHCI_HCD_OMAP)	+= ehci-omap.o
 
 obj-$(CONFIG_USB_OXU210HP_HCD)	+= oxu210hp-hcd.o
 obj-$(CONFIG_USB_ISP116X_HCD)	+= isp116x-hcd.o
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index b416a3fc9959..303b0222cd6d 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1252,11 +1252,6 @@ MODULE_LICENSE ("GPL");
 #define PLATFORM_DRIVER		ehci_hcd_sh_driver
 #endif
 
-#ifdef CONFIG_USB_EHCI_HCD_OMAP
-#include "ehci-omap.c"
-#define        PLATFORM_DRIVER         ehci_hcd_omap_driver
-#endif
-
 #ifdef CONFIG_PPC_PS3
 #include "ehci-ps3.c"
 #define	PS3_SYSTEM_BUS_DRIVER	ps3_ehci_driver
@@ -1346,6 +1341,7 @@ MODULE_LICENSE ("GPL");
 	!IS_ENABLED(CONFIG_USB_EHCI_HCD_PLATFORM) &amp;&amp; \
 	!IS_ENABLED(CONFIG_USB_CHIPIDEA_HOST) &amp;&amp; \
 	!IS_ENABLED(CONFIG_USB_EHCI_MXC) &amp;&amp; \
+	!IS_ENABLED(CONFIG_USB_EHCI_HCD_OMAP) &amp;&amp; \
 	!defined(PLATFORM_DRIVER) &amp;&amp; \
 	!defined(PS3_SYSTEM_BUS_DRIVER) &amp;&amp; \
 	!defined(OF_PLATFORM_DRIVER) &amp;&amp; \
diff --git a/drivers/usb/host/ehci-omap.c b/drivers/usb/host/ehci-omap.c
index 0555ee42d7cb..fa667577d9b9 100644
--- a/drivers/usb/host/ehci-omap.c
+++ b/drivers/usb/host/ehci-omap.c
@@ -36,6 +36,9 @@
  *	- convert to use hwmod and runtime PM
  */
 
+#include &lt;linux/kernel.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/io.h&gt;
 #include &lt;linux/platform_device.h&gt;
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/usb/ulpi.h&gt;
@@ -43,6 +46,10 @@
 #include &lt;linux/pm_runtime.h&gt;
 #include &lt;linux/gpio.h&gt;
 #include &lt;linux/clk.h&gt;
+#include &lt;linux/usb.h&gt;
+#include &lt;linux/usb/hcd.h&gt;
+
+#include "ehci.h"
 
 #include &lt;linux/platform_data/usb-omap.h&gt;
 
@@ -57,9 +64,11 @@
 #define	EHCI_INSNREG05_ULPI_EXTREGADD_SHIFT		8
 #define	EHCI_INSNREG05_ULPI_WRDATA_SHIFT		0
 
-/*-------------------------------------------------------------------------*/
+#define DRIVER_DESC "OMAP-EHCI Host Controller driver"
 
-static const struct hc_driver ehci_omap_hc_driver;
+static const char hcd_name[] = "ehci-omap";
+
+/*-------------------------------------------------------------------------*/
 
 
 static inline void ehci_write(void __iomem *base, u32 reg, u32 val)
@@ -166,6 +175,12 @@ static void disable_put_regulator(
 /* configure so an HC device and id are always provided */
 /* always called with process context; sleeping is OK */
 
+static struct hc_driver __read_mostly ehci_omap_hc_driver;
+
+static const struct ehci_driver_overrides ehci_omap_overrides __initdata = {
+	.reset =		omap_ehci_init,
+};
+
 /**
  * ehci_hcd_omap_probe - initialize TI-based HCDs
  *
@@ -315,56 +330,33 @@ static struct platform_driver ehci_hcd_omap_driver = {
 	/*.suspend		= ehci_hcd_omap_suspend, */
 	/*.resume		= ehci_hcd_omap_resume, */
 	.driver = {
-		.name		= "ehci-omap",
+		.name		= hcd_name,
 	}
 };
 
 /*-------------------------------------------------------------------------*/
 
-static const struct hc_driver ehci_omap_hc_driver = {
-	.description		= hcd_name,
-	.product_desc		= "OMAP-EHCI Host Controller",
-	.hcd_priv_size		= sizeof(struct ehci_hcd),
-
-	/*
-	 * generic hardware linkage
-	 */
-	.irq			= ehci_irq,
-	.flags			= HCD_MEMORY | HCD_USB2,
-
-	/*
-	 * basic lifecycle operations
-	 */
-	.reset			= omap_ehci_init,
-	.start			= ehci_run,
-	.stop			= ehci_stop,
-	.shutdown		= ehci_shutdown,
-
-	/*
-	 * managing i/o requests and associated device resources
-	 */
-	.urb_enqueue		= ehci_urb_enqueue,
-	.urb_dequeue		= ehci_urb_dequeue,
-	.endpoint_disable	= ehci_endpoint_disable,
-	.endpoint_reset		= ehci_endpoint_reset,
+static int __init ehci_omap_init(void)
+{
+	if (usb_disabled())
+		return -ENODEV;
 
-	/*
-	 * scheduling support
-	 */
-	.get_frame_number	= ehci_get_frame,
+	pr_info("%s: " DRIVER_DESC "\n", hcd_name);
 
-	/*
-	 * root hub support
-	 */
-	.hub_status_data	= ehci_hub_status_data,
-	.hub_control		= ehci_hub_control,
-	.bus_suspend		= ehci_bus_suspend,
-	.bus_resume		= ehci_bus_resume,
+	ehci_init_driver(&amp;ehci_omap_hc_driver, &amp;ehci_omap_overrides);
+	return platform_driver_register(&amp;ehci_hcd_omap_driver);
+}
+module_init(ehci_omap_init);
 
-	.clear_tt_buffer_complete = ehci_clear_tt_buffer_complete,
-};
+static void __exit ehci_omap_cleanup(void)
+{
+	platform_driver_unregister(&amp;ehci_hcd_omap_driver);
+}
+module_exit(ehci_omap_cleanup);
 
 MODULE_ALIAS("platform:ehci-omap");
 MODULE_AUTHOR("Texas Instruments, Inc.");
 MODULE_AUTHOR("Felipe Balbi &lt;felipe.balbi@nokia.com&gt;");
 
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");</pre><hr><pre>commit feca7746d5d9e84b105a613b7f3b6ad00d327372
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Mar 1 10:51:15 2013 -0500

    USB: EHCI: don't check DMA values in QH overlays
    
    This patch (as1661) fixes a rather obscure bug in ehci-hcd.  In a
    couple of places, the driver compares the DMA address stored in a QH's
    overlay region with the address of a particular qTD, in order to see
    whether that qTD is the one currently being processed by the hardware.
    (If it is then the status in the QH's overlay region is more
    up-to-date than the status in the qTD, and if it isn't then the
    overlay's value needs to be adjusted when the QH is added back to the
    active schedule.)
    
    However, DMA address in the overlay region isn't always valid.  It
    sometimes will contain a stale value, which may happen by coincidence
    to be equal to a qTD's DMA address.  Instead of checking the DMA
    address, we should check whether the overlay region is active and
    valid.  The patch tests the ACTIVE bit in the overlay, and clears this
    bit when the overlay becomes invalid (which happens when the
    currently-executing URB is unlinked).
    
    This is the second part of a fix for the regression reported at:
    
            https://bugs.launchpad.net/bugs/1088733
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Joseph Salisbury &lt;joseph.salisbury@canonical.com&gt;
    Reported-and-tested-by: Stephen Thirlwall &lt;sdt@dr.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 7bf2b4eeb9ce..5464665f0b6a 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -135,7 +135,7 @@ qh_refresh (struct ehci_hcd *ehci, struct ehci_qh *qh)
 		 * qtd is updated in qh_completions(). Update the QH
 		 * overlay here.
 		 */
-		if (cpu_to_hc32(ehci, qtd-&gt;qtd_dma) == qh-&gt;hw-&gt;hw_current) {
+		if (qh-&gt;hw-&gt;hw_token &amp; ACTIVE_BIT(ehci)) {
 			qh-&gt;hw-&gt;hw_qtd_next = qtd-&gt;hw_next;
 			qtd = NULL;
 		}
@@ -449,11 +449,19 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 			else if (last_status == -EINPROGRESS &amp;&amp; !urb-&gt;unlinked)
 				continue;
 
-			/* qh unlinked; token in overlay may be most current */
-			if (state == QH_STATE_IDLE
-					&amp;&amp; cpu_to_hc32(ehci, qtd-&gt;qtd_dma)
-						== hw-&gt;hw_current) {
+			/*
+			 * If this was the active qtd when the qh was unlinked
+			 * and the overlay's token is active, then the overlay
+			 * hasn't been written back to the qtd yet so use its
+			 * token instead of the qtd's.  After the qtd is
+			 * processed and removed, the overlay won't be valid
+			 * any more.
+			 */
+			if (state == QH_STATE_IDLE &amp;&amp;
+					qh-&gt;qtd_list.next == &amp;qtd-&gt;qtd_list &amp;&amp;
+					(hw-&gt;hw_token &amp; ACTIVE_BIT(ehci))) {
 				token = hc32_to_cpu(ehci, hw-&gt;hw_token);
+				hw-&gt;hw_token &amp;= ~ACTIVE_BIT(ehci);
 
 				/* An unlink may leave an incomplete
 				 * async transaction in the TT buffer.</pre>
    <div class="pagination">
        <a href='2_37.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><span>[38]</span><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_39.html'>Next&gt;&gt;</a>
    <div>
</body>
