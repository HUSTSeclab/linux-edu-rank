<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_114.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><span>[115]</span><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_116.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit a120586873d3d64de93bd6d593d237e131994e58
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Dec 6 20:32:37 2006 -0800

    [PATCH] Allow NULL pointers in percpu_free
    
    The patch (as824b) makes percpu_free() ignore NULL arguments, as one would
    expect for a deallocation routine.  (Note that free_percpu is #defined as
    percpu_free in include/linux/percpu.h.) A few callers are updated to remove
    now-unneeded tests for NULL.  A few other callers already seem to assume
    that passing a NULL pointer to percpu_free() is okay!
    
    The patch also removes an unnecessary NULL check in percpu_depopulate().
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/arch/i386/kernel/acpi/cstate.c b/arch/i386/kernel/acpi/cstate.c
index 4664b55f623e..12e937c1ce4b 100644
--- a/arch/i386/kernel/acpi/cstate.c
+++ b/arch/i386/kernel/acpi/cstate.c
@@ -156,10 +156,8 @@ static int __init ffh_cstate_init(void)
 
 static void __exit ffh_cstate_exit(void)
 {
-	if (cpu_cstate_entry) {
-		free_percpu(cpu_cstate_entry);
-		cpu_cstate_entry = NULL;
-	}
+	free_percpu(cpu_cstate_entry);
+	cpu_cstate_entry = NULL;
 }
 
 arch_initcall(ffh_cstate_init);
diff --git a/block/blktrace.c b/block/blktrace.c
index 74e02c04b2da..d3679dd1d220 100644
--- a/block/blktrace.c
+++ b/block/blktrace.c
@@ -394,8 +394,7 @@ static int blk_trace_setup(request_queue_t *q, struct block_device *bdev,
 	if (bt) {
 		if (bt-&gt;dropped_file)
 			debugfs_remove(bt-&gt;dropped_file);
-		if (bt-&gt;sequence)
-			free_percpu(bt-&gt;sequence);
+		free_percpu(bt-&gt;sequence);
 		if (bt-&gt;rchan)
 			relay_close(bt-&gt;rchan);
 		kfree(bt);
diff --git a/mm/allocpercpu.c b/mm/allocpercpu.c
index eaa9abeea536..b2486cf887a0 100644
--- a/mm/allocpercpu.c
+++ b/mm/allocpercpu.c
@@ -17,10 +17,9 @@
 void percpu_depopulate(void *__pdata, int cpu)
 {
 	struct percpu_data *pdata = __percpu_disguise(__pdata);
-	if (pdata-&gt;ptrs[cpu]) {
-		kfree(pdata-&gt;ptrs[cpu]);
-		pdata-&gt;ptrs[cpu] = NULL;
-	}
+
+	kfree(pdata-&gt;ptrs[cpu]);
+	pdata-&gt;ptrs[cpu] = NULL;
 }
 EXPORT_SYMBOL_GPL(percpu_depopulate);
 
@@ -123,6 +122,8 @@ EXPORT_SYMBOL_GPL(__percpu_alloc_mask);
  */
 void percpu_free(void *__pdata)
 {
+	if (unlikely(!__pdata))
+		return;
 	__percpu_depopulate_mask(__pdata, &amp;cpu_possible_map);
 	kfree(__percpu_disguise(__pdata));
 }
diff --git a/net/ipv6/af_inet6.c b/net/ipv6/af_inet6.c
index 87c8f54872b7..e5cd83b2205d 100644
--- a/net/ipv6/af_inet6.c
+++ b/net/ipv6/af_inet6.c
@@ -720,10 +720,8 @@ snmp6_mib_free(void *ptr[2])
 {
 	if (ptr == NULL)
 		return;
-	if (ptr[0])
-		free_percpu(ptr[0]);
-	if (ptr[1])
-		free_percpu(ptr[1]);
+	free_percpu(ptr[0]);
+	free_percpu(ptr[1]);
 	ptr[0] = ptr[1] = NULL;
 }
 </pre><hr><pre>commit 94fcda1f8ab5e0cacc381c5ca1cc9aa6ad523576
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Nov 20 11:38:46 2006 -0500

    usbcore: remove unused argument in autosuspend
    
    Thanks to several earlier patches, usb_autosuspend_device() and
    usb_autoresume_device() are never called with a second argument other
    than 1.  This patch (as819) removes the now-redundant argument.
    
    It also consolidates some common code between those two routines,
    putting it into a new subroutine called usb_autopm_do_device().  And
    it includes a sizable kerneldoc update for the affected functions.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index fed92be63b5e..3ed4cb2d56d9 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -561,7 +561,7 @@ static int usbdev_open(struct inode *inode, struct file *file)
 		dev = inode-&gt;i_private;
 	if (!dev)
 		goto out;
-	ret = usb_autoresume_device(dev, 1);
+	ret = usb_autoresume_device(dev);
 	if (ret)
 		goto out;
 
@@ -609,7 +609,7 @@ static int usbdev_release(struct inode *inode, struct file *file)
 			releaseintf(ps, ifnum);
 	}
 	destroy_all_async(ps);
-	usb_autosuspend_device(dev, 1);
+	usb_autosuspend_device(dev);
 	usb_unlock_device(dev);
 	usb_put_dev(dev);
 	put_pid(ps-&gt;disc_pid);
diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 0fa15bd62c48..d6eb5ce1dd1d 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -205,7 +205,7 @@ static int usb_probe_interface(struct device *dev)
 	if (id) {
 		dev_dbg(dev, "%s - got id\n", __FUNCTION__);
 
-		error = usb_autoresume_device(udev, 1);
+		error = usb_autoresume_device(udev);
 		if (error)
 			return error;
 
@@ -229,7 +229,7 @@ static int usb_probe_interface(struct device *dev)
 		} else
 			intf-&gt;condition = USB_INTERFACE_BOUND;
 
-		usb_autosuspend_device(udev, 1);
+		usb_autosuspend_device(udev);
 	}
 
 	return error;
@@ -247,7 +247,7 @@ static int usb_unbind_interface(struct device *dev)
 
 	/* Autoresume for set_interface call below */
 	udev = interface_to_usbdev(intf);
-	error = usb_autoresume_device(udev, 1);
+	error = usb_autoresume_device(udev);
 
 	/* release all urbs for this interface */
 	usb_disable_interface(interface_to_usbdev(intf), intf);
@@ -265,7 +265,7 @@ static int usb_unbind_interface(struct device *dev)
 	intf-&gt;needs_remote_wakeup = 0;
 
 	if (!error)
-		usb_autosuspend_device(udev, 1);
+		usb_autosuspend_device(udev);
 
 	return 0;
 }
@@ -940,6 +940,8 @@ static int usb_resume_interface(struct usb_interface *intf)
 	return status;
 }
 
+#ifdef	CONFIG_USB_SUSPEND
+
 /* Internal routine to check whether we may autosuspend a device. */
 static int autosuspend_check(struct usb_device *udev)
 {
@@ -970,6 +972,12 @@ static int autosuspend_check(struct usb_device *udev)
 	return 0;
 }
 
+#else
+
+#define autosuspend_check(udev)		0
+
+#endif
+
 /**
  * usb_suspend_both - suspend a USB device and its interfaces
  * @udev: the usb_device to suspend
@@ -1048,7 +1056,7 @@ int usb_suspend_both(struct usb_device *udev, pm_message_t msg)
 
 	/* If the suspend succeeded, propagate it up the tree */
 	} else if (parent)
-		usb_autosuspend_device(parent, 1);
+		usb_autosuspend_device(parent);
 
 	// dev_dbg(&amp;udev-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
 	return status;
@@ -1096,11 +1104,11 @@ int usb_resume_both(struct usb_device *udev)
 	/* Propagate the resume up the tree, if necessary */
 	if (udev-&gt;state == USB_STATE_SUSPENDED) {
 		if (parent) {
-			status = usb_autoresume_device(parent, 1);
+			status = usb_autoresume_device(parent);
 			if (status == 0) {
 				status = usb_resume_device(udev);
 				if (status) {
-					usb_autosuspend_device(parent, 1);
+					usb_autosuspend_device(parent);
 
 					/* It's possible usb_resume_device()
 					 * failed after the port was
@@ -1146,39 +1154,53 @@ int usb_resume_both(struct usb_device *udev)
 
 #ifdef CONFIG_USB_SUSPEND
 
+/* Internal routine to adjust a device's usage counter and change
+ * its autosuspend state.
+ */
+static int usb_autopm_do_device(struct usb_device *udev, int inc_usage_cnt)
+{
+	int	status = 0;
+
+	usb_pm_lock(udev);
+	udev-&gt;pm_usage_cnt += inc_usage_cnt;
+	WARN_ON(udev-&gt;pm_usage_cnt &lt; 0);
+	if (inc_usage_cnt &gt;= 0 &amp;&amp; udev-&gt;pm_usage_cnt &gt; 0) {
+		udev-&gt;auto_pm = 1;
+		status = usb_resume_both(udev);
+		if (status != 0)
+			udev-&gt;pm_usage_cnt -= inc_usage_cnt;
+	} else if (inc_usage_cnt &lt;= 0 &amp;&amp; autosuspend_check(udev) == 0)
+		queue_delayed_work(ksuspend_usb_wq, &amp;udev-&gt;autosuspend,
+				USB_AUTOSUSPEND_DELAY);
+	usb_pm_unlock(udev);
+	return status;
+}
+
 /**
  * usb_autosuspend_device - delayed autosuspend of a USB device and its interfaces
  * @udev: the usb_device to autosuspend
- * @dec_usage_cnt: flag to decrement @udev's PM-usage counter
  *
  * This routine should be called when a core subsystem is finished using
  * @udev and wants to allow it to autosuspend.  Examples would be when
  * @udev's device file in usbfs is closed or after a configuration change.
  *
- * @dec_usage_cnt should be 1 if the subsystem previously incremented
- * @udev's usage counter (such as by passing 1 to usb_autoresume_device);
- * otherwise it should be 0.
- *
- * If the usage counter for @udev or any of its active interfaces is greater
- * than 0, the autosuspend request will not be queued.  (If an interface
- * driver does not support autosuspend then its usage counter is permanently
- * positive.)  Likewise, if an interface driver requires remote-wakeup
- * capability during autosuspend but remote wakeup is disabled, the
- * autosuspend will fail.
+ * @udev's usage counter is decremented.  If it or any of the usage counters
+ * for an active interface is greater than 0, no autosuspend request will be
+ * queued.  (If an interface driver does not support autosuspend then its
+ * usage counter is permanently positive.)  Furthermore, if an interface
+ * driver requires remote-wakeup capability during autosuspend but remote
+ * wakeup is disabled, the autosuspend will fail.
  *
  * Often the caller will hold @udev's device lock, but this is not
  * necessary.
  *
  * This routine can run only in process context.
  */
-void usb_autosuspend_device(struct usb_device *udev, int dec_usage_cnt)
+void usb_autosuspend_device(struct usb_device *udev)
 {
-	usb_pm_lock(udev);
-	udev-&gt;pm_usage_cnt -= dec_usage_cnt;
-	if (autosuspend_check(udev) == 0)
-		queue_delayed_work(ksuspend_usb_wq, &amp;udev-&gt;autosuspend,
-				USB_AUTOSUSPEND_DELAY);
-	usb_pm_unlock(udev);
+	int	status;
+
+	status = usb_autopm_do_device(udev, -1);
 	// dev_dbg(&amp;udev-&gt;dev, "%s: cnt %d\n",
 	//		__FUNCTION__, udev-&gt;pm_usage_cnt);
 }
@@ -1186,39 +1208,27 @@ void usb_autosuspend_device(struct usb_device *udev, int dec_usage_cnt)
 /**
  * usb_autoresume_device - immediately autoresume a USB device and its interfaces
  * @udev: the usb_device to autoresume
- * @inc_usage_cnt: flag to increment @udev's PM-usage counter
  *
  * This routine should be called when a core subsystem wants to use @udev
- * and needs to guarantee that it is not suspended.  In addition, the
- * caller can prevent @udev from being autosuspended subsequently.  (Note
- * that this will not prevent suspend events originating in the PM core.)
- * Examples would be when @udev's device file in usbfs is opened (autosuspend
- * should be prevented until the file is closed) or when a remote-wakeup
- * request is received (later autosuspends should not be prevented).
+ * and needs to guarantee that it is not suspended.  No autosuspend will
+ * occur until usb_autosuspend_device is called.  (Note that this will not
+ * prevent suspend events originating in the PM core.)  Examples would be
+ * when @udev's device file in usbfs is opened or when a remote-wakeup
+ * request is received.
  *
- * @inc_usage_cnt should be 1 to increment @udev's usage counter and prevent
- * autosuspends.  This prevention will persist until the usage counter is
- * decremented again (such as by passing 1 to usb_autosuspend_device).
- * Otherwise @inc_usage_cnt should be 0 to leave the usage counter unchanged.
- * Regardless, if the autoresume fails then the usage counter is not
- * incremented.
+ * @udev's usage counter is incremented to prevent subsequent autosuspends.
+ * However if the autoresume fails then the usage counter is re-decremented.
  *
  * Often the caller will hold @udev's device lock, but this is not
  * necessary (and attempting it might cause deadlock).
  *
  * This routine can run only in process context.
  */
-int usb_autoresume_device(struct usb_device *udev, int inc_usage_cnt)
+int usb_autoresume_device(struct usb_device *udev)
 {
 	int	status;
 
-	usb_pm_lock(udev);
-	udev-&gt;pm_usage_cnt += inc_usage_cnt;
-	udev-&gt;auto_pm = 1;
-	status = usb_resume_both(udev);
-	if (status != 0)
-		udev-&gt;pm_usage_cnt -= inc_usage_cnt;
-	usb_pm_unlock(udev);
+	status = usb_autopm_do_device(udev, 1);
 	// dev_dbg(&amp;udev-&gt;dev, "%s: status %d cnt %d\n",
 	//		__FUNCTION__, status, udev-&gt;pm_usage_cnt);
 	return status;
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index e46d38b18249..0ce393eb3c4b 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1234,7 +1234,7 @@ void usb_disconnect(struct usb_device **pdev)
 	if (udev-&gt;parent) {
 		usb_pm_lock(udev);
 		if (!udev-&gt;discon_suspended)
-			usb_autosuspend_device(udev-&gt;parent, 1);
+			usb_autosuspend_device(udev-&gt;parent);
 		usb_pm_unlock(udev);
 	}
 
@@ -1368,7 +1368,7 @@ static int __usb_new_device(void *void_data)
 
 	/* Increment the parent's count of unsuspended children */
 	if (udev-&gt;parent)
-		usb_autoresume_device(udev-&gt;parent, 1);
+		usb_autoresume_device(udev-&gt;parent);
 
 exit:
 	module_put(THIS_MODULE);
@@ -1881,12 +1881,12 @@ static int remote_wakeup(struct usb_device *udev)
 	usb_lock_device(udev);
 	if (udev-&gt;state == USB_STATE_SUSPENDED) {
 		dev_dbg(&amp;udev-&gt;dev, "usb %sresume\n", "wakeup-");
-		status = usb_autoresume_device(udev, 1);
+		status = usb_autoresume_device(udev);
 
 		/* Give the interface drivers a chance to do something,
 		 * then autosuspend the device again. */
 		if (status == 0)
-			usb_autosuspend_device(udev, 1);
+			usb_autosuspend_device(udev);
 	}
 	usb_unlock_device(udev);
 	return status;
@@ -3099,7 +3099,7 @@ int usb_reset_composite_device(struct usb_device *udev,
 	}
 
 	/* Prevent autosuspend during the reset */
-	usb_autoresume_device(udev, 1);
+	usb_autoresume_device(udev);
 
 	if (iface &amp;&amp; iface-&gt;condition != USB_INTERFACE_BINDING)
 		iface = NULL;
@@ -3142,7 +3142,7 @@ int usb_reset_composite_device(struct usb_device *udev,
 		}
 	}
 
-	usb_autosuspend_device(udev, 1);
+	usb_autosuspend_device(udev);
 	return ret;
 }
 EXPORT_SYMBOL(usb_reset_composite_device);
diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 5684d8722922..29b0fa9ff9d0 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1398,7 +1398,7 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 	}
 
 	/* Wake up the device so we can send it the Set-Config request */
-	ret = usb_autoresume_device(dev, 1);
+	ret = usb_autoresume_device(dev);
 	if (ret)
 		goto free_interfaces;
 
@@ -1421,7 +1421,7 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 	dev-&gt;actconfig = cp;
 	if (!cp) {
 		usb_set_device_state(dev, USB_STATE_ADDRESS);
-		usb_autosuspend_device(dev, 1);
+		usb_autosuspend_device(dev);
 		goto free_interfaces;
 	}
 	usb_set_device_state(dev, USB_STATE_CONFIGURED);
@@ -1490,7 +1490,7 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 		usb_create_sysfs_intf_files (intf);
 	}
 
-	usb_autosuspend_device(dev, 1);
+	usb_autosuspend_device(dev);
 	return 0;
 }
 
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 13322e33f912..17830a81be14 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -64,14 +64,13 @@ static inline void usb_pm_unlock(struct usb_device *udev) {}
 
 #define USB_AUTOSUSPEND_DELAY	(HZ*2)
 
-extern void usb_autosuspend_device(struct usb_device *udev, int dec_busy_cnt);
-extern int usb_autoresume_device(struct usb_device *udev, int inc_busy_cnt);
+extern void usb_autosuspend_device(struct usb_device *udev);
+extern int usb_autoresume_device(struct usb_device *udev);
 
 #else
 
-#define usb_autosuspend_device(udev, dec_busy_cnt)	do {} while (0)
-static inline int usb_autoresume_device(struct usb_device *udev,
-		int inc_busy_cnt)
+#define usb_autosuspend_device(udev)	do {} while (0)
+static inline int usb_autoresume_device(struct usb_device *udev)
 {
 	return 0;
 }</pre><hr><pre>commit ee49fb5dc89d34f1794ac9362fa97c1a640f7ddd
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Nov 22 16:55:54 2006 -0500

    USB: keep count of unsuspended children
    
    This patch (as818b) simplifies autosuspend processing by keeping track
    of the number of unsuspended children of each USB hub.  This will
    permit us to avoid a good deal of unnecessary work all the time; we
    will no longer have to create a bunch of workqueue entries to carry
    out autosuspend requests, only to have them fail because one of the
    hub's children isn't suspended.
    
    The basic idea is simple.  There already is a usage counter in the
    usb_device structure for preventing autosuspends.  The patch just
    increments that counter for every unsuspended child.  There's only one
    tricky part: When a device disconnects we need to remember whether it
    was suspended at the time (leave the counter alone) or not (decrement
    the counter).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 40c1bf09b2b7..0fa15bd62c48 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -1048,7 +1048,7 @@ int usb_suspend_both(struct usb_device *udev, pm_message_t msg)
 
 	/* If the suspend succeeded, propagate it up the tree */
 	} else if (parent)
-		usb_autosuspend_device(parent, 0);
+		usb_autosuspend_device(parent, 1);
 
 	// dev_dbg(&amp;udev-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
 	return status;
@@ -1096,9 +1096,25 @@ int usb_resume_both(struct usb_device *udev)
 	/* Propagate the resume up the tree, if necessary */
 	if (udev-&gt;state == USB_STATE_SUSPENDED) {
 		if (parent) {
-			usb_pm_lock(parent);
-			parent-&gt;auto_pm = 1;
-			status = usb_resume_both(parent);
+			status = usb_autoresume_device(parent, 1);
+			if (status == 0) {
+				status = usb_resume_device(udev);
+				if (status) {
+					usb_autosuspend_device(parent, 1);
+
+					/* It's possible usb_resume_device()
+					 * failed after the port was
+					 * unsuspended, causing udev to be
+					 * logically disconnected.  We don't
+					 * want usb_disconnect() to autosuspend
+					 * the parent again, so tell it that
+					 * udev disconnected while still
+					 * suspended. */
+					if (udev-&gt;state ==
+							USB_STATE_NOTATTACHED)
+						udev-&gt;discon_suspended = 1;
+				}
+			}
 		} else {
 
 			/* We can't progagate beyond the USB subsystem,
@@ -1107,11 +1123,9 @@ int usb_resume_both(struct usb_device *udev)
 			if (udev-&gt;dev.parent-&gt;power.power_state.event !=
 					PM_EVENT_ON)
 				status = -EHOSTUNREACH;
-		}
-		if (status == 0)
-			status = usb_resume_device(udev);
-		if (parent)
-			usb_pm_unlock(parent);
+			else
+				status = usb_resume_device(udev);
+ 		}
 	} else {
 
 		/* Needed only for setting udev-&gt;dev.power.power_state.event
@@ -1119,8 +1133,6 @@ int usb_resume_both(struct usb_device *udev)
 		status = usb_resume_device(udev);
 	}
 
-	/* Now the parent won't suspend until we are finished */
-
 	if (status == 0 &amp;&amp; udev-&gt;actconfig) {
 		for (i = 0; i &lt; udev-&gt;actconfig-&gt;desc.bNumInterfaces; i++) {
 			intf = udev-&gt;actconfig-&gt;interface[i];
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 46df5e60764b..e46d38b18249 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1039,6 +1039,8 @@ static void recursively_mark_NOTATTACHED(struct usb_device *udev)
 		if (udev-&gt;children[i])
 			recursively_mark_NOTATTACHED(udev-&gt;children[i]);
 	}
+	if (udev-&gt;state == USB_STATE_SUSPENDED)
+		udev-&gt;discon_suspended = 1;
 	udev-&gt;state = USB_STATE_NOTATTACHED;
 }
 
@@ -1228,6 +1230,14 @@ void usb_disconnect(struct usb_device **pdev)
 	*pdev = NULL;
 	spin_unlock_irq(&amp;device_state_lock);
 
+	/* Decrement the parent's count of unsuspended children */
+	if (udev-&gt;parent) {
+		usb_pm_lock(udev);
+		if (!udev-&gt;discon_suspended)
+			usb_autosuspend_device(udev-&gt;parent, 1);
+		usb_pm_unlock(udev);
+	}
+
 	put_device(&amp;udev-&gt;dev);
 }
 
@@ -1356,6 +1366,10 @@ static int __usb_new_device(void *void_data)
 		goto fail;
 	}
 
+	/* Increment the parent's count of unsuspended children */
+	if (udev-&gt;parent)
+		usb_autoresume_device(udev-&gt;parent, 1);
+
 exit:
 	module_put(THIS_MODULE);
 	return err;
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 5634a2d91ec0..0cd73edeef13 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -362,6 +362,7 @@ struct usb_device {
 	u8 portnum;			/* Parent port number (origin 1) */
 	u8 level;			/* Number of USB hub ancestors */
 
+	unsigned discon_suspended:1;	/* Disconnected while suspended */
 	unsigned have_langid:1;		/* whether string_langid is valid */
 	int string_langid;		/* language ID for strings */
 </pre><hr><pre>commit d25450c68767481f7c9cc4823a6da8235db40be6
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Nov 20 11:14:30 2006 -0500

    USB hub: simplify remote-wakeup handling
    
    This patch (as817) simplifies the remote-wakeup processing in the hub
    driver.  Now instead of using a specialized code path, it relies on
    the standard USB resume routines.  The hub_port_resume() function does
    an initial get_port_status() to see whether the port has already
    resumed itself (as it does when a remote-wakeup request is sent).
    This will slow down handling of other resume events slightly, but not
    enough to matter.
    
    The patch also changes the hub_port_status() routine, making it return
    an error if a short reply is received.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 55812a5ac661..46df5e60764b 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1409,10 +1409,12 @@ static int hub_port_status(struct usb_hub *hub, int port1,
 	int ret;
 
 	ret = get_port_status(hub-&gt;hdev, port1, &amp;hub-&gt;status-&gt;port);
-	if (ret &lt; 0)
+	if (ret &lt; 4) {
 		dev_err (hub-&gt;intfdev,
 			"%s failed (err = %d)\n", __FUNCTION__, ret);
-	else {
+		if (ret &gt;= 0)
+			ret = -EIO;
+	} else {
 		*status = le16_to_cpu(hub-&gt;status-&gt;port.wPortStatus);
 		*change = le16_to_cpu(hub-&gt;status-&gt;port.wPortChange); 
 		ret = 0;
@@ -1760,6 +1762,12 @@ static int
 hub_port_resume(struct usb_hub *hub, int port1, struct usb_device *udev)
 {
 	int	status;
+	u16	portchange, portstatus;
+
+	/* Skip the initial Clear-Suspend step for a remote wakeup */
+	status = hub_port_status(hub, port1, &amp;portstatus, &amp;portchange);
+	if (status == 0 &amp;&amp; !(portstatus &amp; USB_PORT_STAT_SUSPEND))
+		goto SuspendCleared;
 
 	// dev_dbg(hub-&gt;intfdev, "resume port %d\n", port1);
 
@@ -1773,9 +1781,6 @@ hub_port_resume(struct usb_hub *hub, int port1, struct usb_device *udev)
 			"can't resume port %d, status %d\n",
 			port1, status);
 	} else {
-		u16		devstatus;
-		u16		portchange;
-
 		/* drive resume for at least 20 msec */
 		if (udev)
 			dev_dbg(&amp;udev-&gt;dev, "usb %sresume\n",
@@ -1790,16 +1795,15 @@ hub_port_resume(struct usb_hub *hub, int port1, struct usb_device *udev)
 		 * stop resume signaling.  Then finish the resume
 		 * sequence.
 		 */
-		devstatus = portchange = 0;
-		status = hub_port_status(hub, port1,
-				&amp;devstatus, &amp;portchange);
+		status = hub_port_status(hub, port1, &amp;portstatus, &amp;portchange);
+SuspendCleared:
 		if (status &lt; 0
-				|| (devstatus &amp; LIVE_FLAGS) != LIVE_FLAGS
-				|| (devstatus &amp; USB_PORT_STAT_SUSPEND) != 0
+				|| (portstatus &amp; LIVE_FLAGS) != LIVE_FLAGS
+				|| (portstatus &amp; USB_PORT_STAT_SUSPEND) != 0
 				) {
 			dev_dbg(hub-&gt;intfdev,
 				"port %d status %04x.%04x after resume, %d\n",
-				port1, portchange, devstatus, status);
+				port1, portchange, portstatus, status);
 			if (status &gt;= 0)
 				status = -ENODEV;
 		} else {
@@ -1860,23 +1864,16 @@ static int remote_wakeup(struct usb_device *udev)
 {
 	int	status = 0;
 
-	/* All this just to avoid sending a port-resume message
-	 * to the parent hub! */
-
 	usb_lock_device(udev);
-	usb_pm_lock(udev);
 	if (udev-&gt;state == USB_STATE_SUSPENDED) {
 		dev_dbg(&amp;udev-&gt;dev, "usb %sresume\n", "wakeup-");
-		/* TRSMRCY = 10 msec */
-		msleep(10);
-		status = finish_port_resume(udev);
+		status = usb_autoresume_device(udev, 1);
+
+		/* Give the interface drivers a chance to do something,
+		 * then autosuspend the device again. */
 		if (status == 0)
-			udev-&gt;dev.power.power_state.event = PM_EVENT_ON;
+			usb_autosuspend_device(udev, 1);
 	}
-	usb_pm_unlock(udev);
-
-	if (status == 0)
-		usb_autoresume_device(udev, 0);
 	usb_unlock_device(udev);
 	return status;
 }</pre><hr><pre>commit ce3615879ae85373c03744b45b7c2d7ae5e29b2a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Nov 20 11:12:22 2006 -0500

    USB: struct usb_device: change flag to bitflag
    
    This patch (as816) changes an existing flag in the usb_device
    structure to a bitflag, preparing the way for more bitflags to come
    in the future.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 7729c0744886..5684d8722922 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -764,7 +764,7 @@ int usb_string(struct usb_device *dev, int index, char *buf, size_t size)
 			err = -EINVAL;
 			goto errout;
 		} else {
-			dev-&gt;have_langid = -1;
+			dev-&gt;have_langid = 1;
 			dev-&gt;string_langid = tbuf[2] | (tbuf[3]&lt;&lt; 8);
 				/* always use the first langid listed */
 			dev_dbg (&amp;dev-&gt;dev, "default language 0x%04x\n",
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 864c6c21c21e..5634a2d91ec0 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -362,7 +362,7 @@ struct usb_device {
 	u8 portnum;			/* Parent port number (origin 1) */
 	u8 level;			/* Number of USB hub ancestors */
 
-	int have_langid;		/* whether string_langid is valid */
+	unsigned have_langid:1;		/* whether string_langid is valid */
 	int string_langid;		/* language ID for strings */
 
 	/* static strings from the device */</pre><hr><pre>commit 1f9fc882d92f3ff390455836f98d7ddc36d4e4c3
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Nov 20 11:06:59 2006 -0500

    OHCI: make autostop conditional on CONFIG_PM
    
    Unlike UHCI, OHCI does not exert any DMA load on the system when no
    devices are connected.  Consequently there is no advantage to doing
    an autostop other than the power savings, so we shouldn't compile the
    necessary code unless CONFIG_PM is enabled.
    
    This patch (as820) makes the root-hub suspend and resume routines
    conditional on CONFIG_PM.  It also prevents autostop from activating
    if the device_may_wakeup flag isn't set; some people use this flag to
    alert the driver about Resume-Detect bugs in the hardware.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ohci-hub.c b/drivers/usb/host/ohci-hub.c
index 4c9492779ede..2441642cb7b4 100644
--- a/drivers/usb/host/ohci-hub.c
+++ b/drivers/usb/host/ohci-hub.c
@@ -56,7 +56,6 @@ static void finish_unlinks (struct ohci_hcd *, u16);
 
 #ifdef	CONFIG_PM
 static int ohci_restart(struct ohci_hcd *ohci);
-#endif
 
 static int ohci_rh_suspend (struct ohci_hcd *ohci, int autostop)
 __releases(ohci-&gt;lock)
@@ -187,7 +186,6 @@ __acquires(ohci-&gt;lock)
 		ohci_dbg (ohci, "lost power\n");
 		status = -EBUSY;
 	}
-#ifdef	CONFIG_PM
 	if (status == -EBUSY) {
 		if (!autostopped) {
 			spin_unlock_irq (&amp;ohci-&gt;lock);
@@ -197,7 +195,6 @@ __acquires(ohci-&gt;lock)
 		}
 		return status;
 	}
-#endif
 	if (status != -EINPROGRESS)
 		return status;
 	if (autostopped)
@@ -291,8 +288,6 @@ __acquires(ohci-&gt;lock)
 	return 0;
 }
 
-#ifdef	CONFIG_PM
-
 static int ohci_bus_suspend (struct usb_hcd *hcd)
 {
 	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
@@ -330,6 +325,83 @@ static int ohci_bus_resume (struct usb_hcd *hcd)
 	return rc;
 }
 
+/* Carry out polling-, autostop-, and autoresume-related state changes */
+static int ohci_root_hub_state_changes(struct ohci_hcd *ohci, int changed,
+		int any_connected)
+{
+	int	poll_rh = 1;
+
+	switch (ohci-&gt;hc_control &amp; OHCI_CTRL_HCFS) {
+
+	case OHCI_USB_OPER:
+		/* keep on polling until we know a device is connected
+		 * and RHSC is enabled */
+		if (!ohci-&gt;autostop) {
+			if (any_connected ||
+					!device_may_wakeup(&amp;ohci_to_hcd(ohci)
+						-&gt;self.root_hub-&gt;dev)) {
+				if (ohci_readl(ohci, &amp;ohci-&gt;regs-&gt;intrenable) &amp;
+						OHCI_INTR_RHSC)
+					poll_rh = 0;
+			} else {
+				ohci-&gt;autostop = 1;
+				ohci-&gt;next_statechange = jiffies + HZ;
+			}
+
+		/* if no devices have been attached for one second, autostop */
+		} else {
+			if (changed || any_connected) {
+				ohci-&gt;autostop = 0;
+				ohci-&gt;next_statechange = jiffies +
+						STATECHANGE_DELAY;
+			} else if (time_after_eq(jiffies,
+						ohci-&gt;next_statechange)
+					&amp;&amp; !ohci-&gt;ed_rm_list
+					&amp;&amp; !(ohci-&gt;hc_control &amp;
+						OHCI_SCHED_ENABLES)) {
+				ohci_rh_suspend(ohci, 1);
+			}
+		}
+		break;
+
+	/* if there is a port change, autostart or ask to be resumed */
+	case OHCI_USB_SUSPEND:
+	case OHCI_USB_RESUME:
+		if (changed) {
+			if (ohci-&gt;autostop)
+				ohci_rh_resume(ohci);
+			else
+				usb_hcd_resume_root_hub(ohci_to_hcd(ohci));
+		} else {
+			/* everything is idle, no need for polling */
+			poll_rh = 0;
+		}
+		break;
+	}
+	return poll_rh;
+}
+
+#else	/* CONFIG_PM */
+
+static inline int ohci_rh_resume(struct ohci_hcd *ohci)
+{
+	return 0;
+}
+
+/* Carry out polling-related state changes.
+ * autostop isn't used when CONFIG_PM is turned off.
+ */
+static int ohci_root_hub_state_changes(struct ohci_hcd *ohci, int changed,
+		int any_connected)
+{
+	int	poll_rh = 1;
+
+	/* keep on polling until RHSC is enabled */
+	if (ohci_readl(ohci, &amp;ohci-&gt;regs-&gt;intrenable) &amp; OHCI_INTR_RHSC)
+		poll_rh = 0;
+	return poll_rh;
+}
+
 #endif	/* CONFIG_PM */
 
 /*-------------------------------------------------------------------------*/
@@ -382,55 +454,8 @@ ohci_hub_status_data (struct usb_hcd *hcd, char *buf)
 		}
 	}
 
-	hcd-&gt;poll_rh = 1;
-
-	/* carry out appropriate state changes */
-	switch (ohci-&gt;hc_control &amp; OHCI_CTRL_HCFS) {
-
-	case OHCI_USB_OPER:
-		/* keep on polling until we know a device is connected
-		 * and RHSC is enabled */
-		if (!ohci-&gt;autostop) {
-			if (any_connected) {
-				if (ohci_readl(ohci, &amp;ohci-&gt;regs-&gt;intrenable) &amp;
-						OHCI_INTR_RHSC)
-					hcd-&gt;poll_rh = 0;
-			} else {
-				ohci-&gt;autostop = 1;
-				ohci-&gt;next_statechange = jiffies + HZ;
-			}
-
-		/* if no devices have been attached for one second, autostop */
-		} else {
-			if (changed || any_connected) {
-				ohci-&gt;autostop = 0;
-				ohci-&gt;next_statechange = jiffies +
-						STATECHANGE_DELAY;
-			} else if (device_may_wakeup(&amp;hcd-&gt;self.root_hub-&gt;dev)
-					&amp;&amp; time_after_eq(jiffies,
-						ohci-&gt;next_statechange)
-					&amp;&amp; !ohci-&gt;ed_rm_list
-					&amp;&amp; !(ohci-&gt;hc_control &amp;
-						OHCI_SCHED_ENABLES)) {
-				ohci_rh_suspend (ohci, 1);
-			}
-		}
-		break;
-
-	/* if there is a port change, autostart or ask to be resumed */
-	case OHCI_USB_SUSPEND:
-	case OHCI_USB_RESUME:
-		if (changed) {
-			if (ohci-&gt;autostop)
-				ohci_rh_resume (ohci);
-			else
-				usb_hcd_resume_root_hub (hcd);
-		} else {
-			/* everything is idle, no need for polling */
-			hcd-&gt;poll_rh = 0;
-		}
-		break;
-	}
+	hcd-&gt;poll_rh = ohci_root_hub_state_changes(ohci, changed,
+			any_connected);
 
 done:
 	spin_unlock_irqrestore (&amp;ohci-&gt;lock, flags);</pre><hr><pre>commit 40f122f343797d02390c5a157372cac0c5b50bb7
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Nov 9 14:44:33 2006 -0500

    USB: Add autosuspend support to the hub driver
    
    This patch (as742b) adds autosuspend/autoresume support to the USB hub
    driver.  The largest aspect of the change is that we no longer need a
    special flag for root hubs that want to be resumed.  Now every hub is
    autoresumed whenever khubd needs to access it.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index f6e692180587..55812a5ac661 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -65,7 +65,6 @@ struct usb_hub {
 	unsigned		limited_power:1;
 	unsigned		quiescing:1;
 	unsigned		activating:1;
-	unsigned		resume_root_hub:1;
 
 	unsigned		has_indicators:1;
 	u8			indicator[USB_MAXCHILDREN];
@@ -328,6 +327,9 @@ static void kick_khubd(struct usb_hub *hub)
 {
 	unsigned long	flags;
 
+	/* Suppress autosuspend until khubd runs */
+	to_usb_interface(hub-&gt;intfdev)-&gt;pm_usage_cnt = 1;
+
 	spin_lock_irqsave(&amp;hub_event_lock, flags);
 	if (list_empty(&amp;hub-&gt;event_list)) {
 		list_add_tail(&amp;hub-&gt;event_list, &amp;hub_event_list);
@@ -509,7 +511,6 @@ static void hub_quiesce(struct usb_hub *hub)
 	/* (nonblocking) khubd and related activity won't re-trigger */
 	hub-&gt;quiescing = 1;
 	hub-&gt;activating = 0;
-	hub-&gt;resume_root_hub = 0;
 
 	/* (blocking) stop khubd and related activity */
 	usb_kill_urb(hub-&gt;urb);
@@ -525,7 +526,7 @@ static void hub_activate(struct usb_hub *hub)
 
 	hub-&gt;quiescing = 0;
 	hub-&gt;activating = 1;
-	hub-&gt;resume_root_hub = 0;
+
 	status = usb_submit_urb(hub-&gt;urb, GFP_NOIO);
 	if (status &lt; 0)
 		dev_err(hub-&gt;intfdev, "activate --&gt; %d\n", status);
@@ -940,6 +941,7 @@ static int hub_probe(struct usb_interface *intf, const struct usb_device_id *id)
 	INIT_WORK(&amp;hub-&gt;leds, led_work, hub);
 
 	usb_set_intfdata (intf, hub);
+	intf-&gt;needs_remote_wakeup = 1;
 
 	if (hdev-&gt;speed == USB_SPEED_HIGH)
 		highspeed_hubs++;
@@ -1938,6 +1940,8 @@ static int hub_suspend(struct usb_interface *intf, pm_message_t msg)
 		}
 	}
 
+	dev_dbg(&amp;intf-&gt;dev, "%s\n", __FUNCTION__);
+
 	/* "global suspend" of the downstream HC-to-USB interface */
 	if (!hdev-&gt;parent) {
 		struct usb_bus	*bus = hdev-&gt;bus;
@@ -1960,10 +1964,12 @@ static int hub_suspend(struct usb_interface *intf, pm_message_t msg)
 
 static int hub_resume(struct usb_interface *intf)
 {
-	struct usb_device	*hdev = interface_to_usbdev(intf);
 	struct usb_hub		*hub = usb_get_intfdata (intf);
+	struct usb_device	*hdev = hub-&gt;hdev;
 	int			status;
 
+	dev_dbg(&amp;intf-&gt;dev, "%s\n", __FUNCTION__);
+
 	/* "global resume" of the downstream HC-to-USB interface */
 	if (!hdev-&gt;parent) {
 		struct usb_bus	*bus = hdev-&gt;bus;
@@ -2002,7 +2008,6 @@ void usb_resume_root_hub(struct usb_device *hdev)
 {
 	struct usb_hub *hub = hdev_to_hub(hdev);
 
-	hub-&gt;resume_root_hub = 1;
 	kick_khubd(hub);
 }
 
@@ -2639,16 +2644,13 @@ static void hub_events(void)
 		intf = to_usb_interface(hub-&gt;intfdev);
 		hub_dev = &amp;intf-&gt;dev;
 
-		i = hub-&gt;resume_root_hub;
-
-		dev_dbg(hub_dev, "state %d ports %d chg %04x evt %04x%s\n",
+		dev_dbg(hub_dev, "state %d ports %d chg %04x evt %04x\n",
 				hdev-&gt;state, hub-&gt;descriptor
 					? hub-&gt;descriptor-&gt;bNbrPorts
 					: 0,
 				/* NOTE: expects max 15 ports... */
 				(u16) hub-&gt;change_bits[0],
-				(u16) hub-&gt;event_bits[0],
-				i ? ", resume root" : "");
+				(u16) hub-&gt;event_bits[0]);
 
 		usb_get_intf(intf);
 		spin_unlock_irq(&amp;hub_event_lock);
@@ -2669,16 +2671,16 @@ static void hub_events(void)
 			goto loop;
 		}
 
-		/* Is this is a root hub wanting to reactivate the downstream
-		 * ports?  If so, be sure the interface resumes even if its
-		 * stub "device" node was never suspended.
-		 */
-		if (i)
-			usb_autoresume_device(hdev, 0);
+		/* Autoresume */
+		ret = usb_autopm_get_interface(intf);
+		if (ret) {
+			dev_dbg(hub_dev, "Can't autoresume: %d\n", ret);
+			goto loop;
+		}
 
-		/* If this is an inactive or suspended hub, do nothing */
+		/* If this is an inactive hub, do nothing */
 		if (hub-&gt;quiescing)
-			goto loop;
+			goto loop_autopm;
 
 		if (hub-&gt;error) {
 			dev_dbg (hub_dev, "resetting for error %d\n",
@@ -2688,7 +2690,7 @@ static void hub_events(void)
 			if (ret) {
 				dev_dbg (hub_dev,
 					"error resetting hub: %d\n", ret);
-				goto loop;
+				goto loop_autopm;
 			}
 
 			hub-&gt;nerrors = 0;
@@ -2816,6 +2818,10 @@ static void hub_events(void)
 		if (!hdev-&gt;parent &amp;&amp; !hub-&gt;busy_bits[0])
 			usb_enable_root_hub_irq(hdev-&gt;bus);
 
+loop_autopm:
+		/* Allow autosuspend if we're not going to run again */
+		if (list_empty(&amp;hub-&gt;event_list))
+			usb_autopm_enable(intf);
 loop:
 		usb_unlock_device(hdev);
 		usb_put_intf(intf);
@@ -2857,6 +2863,7 @@ static struct usb_driver hub_driver = {
 	.post_reset =	hub_post_reset,
 	.ioctl =	hub_ioctl,
 	.id_table =	hub_id_table,
+	.supports_autosuspend =	1,
 };
 
 int usb_hub_init(void)</pre><hr><pre>commit 8c03356a559ced6fa78931f498193f776d67e445
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Nov 9 14:42:16 2006 -0500

    EHCI: Fix root-hub and port suspend/resume problems
    
    This patch (as738b) fixes numerous problems in the controller/root-hub
    suspend/resume/remote-wakeup support in ehci-hcd:
    
            The bus_resume() routine should wake up only the ports that
            were suspended by bus_suspend().  Ports that were already
            suspended should remain that way.
    
            The interrupt mask is used to detect loss of power in the
            bus_resume() routine (if the mask is 0 then power was lost).
            However bus_suspend() always sets the mask to 0.  Instead the
            mask should retain its normal value, with port-change-detect
            interrupts disabled if remote wakeup is turned off.
    
            The interrupt mask should be reset to its correct value at the
            end of bus_resume() regardless of whether power was lost.
    
            bus_resume() reinitializes the operational registers if power
            was lost.  However those registers are not in the aux power
            well, hence they can lose their values whenever the controller
            is put into D3.  They should always be reinitialized.
    
            When a port-change interrupt occurs and the root hub is
            suspended, the interrupt handler should request a root-hub
            resume instead of starting up the controller all by itself.
    
            There's no need for the interrupt handler to request a
            root-hub resume every time a suspended port sends a
            remote-wakeup request.
    
            The pci_resume() method doesn't need to check for connected
            ports when deciding whether or not to reset the controller.
            It can make that decision based on whether Vaux power was
            maintained.
    
            Even when the controller does not need to be reset,
            pci_resume() must undo the effect of pci_suspend() by
            re-enabling the interrupt mask.
    
            If power was lost, pci_resume() must not call ehci_run().
            At this point the root hub is still supposed to be suspended,
            not running.  It's enough to rewrite the command register and
            set the configured_flag.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index f2ceb5fdbeb7..025d33313681 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -619,9 +619,8 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 		unsigned	i = HCS_N_PORTS (ehci-&gt;hcs_params);
 
 		/* resume root hub? */
-		status = readl (&amp;ehci-&gt;regs-&gt;command);
-		if (!(status &amp; CMD_RUN))
-			writel (status | CMD_RUN, &amp;ehci-&gt;regs-&gt;command);
+		if (!(readl(&amp;ehci-&gt;regs-&gt;command) &amp; CMD_RUN))
+			usb_hcd_resume_root_hub(hcd);
 
 		while (i--) {
 			int pstatus = readl (&amp;ehci-&gt;regs-&gt;port_status [i]);
@@ -638,7 +637,6 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 			 */
 			ehci-&gt;reset_done [i] = jiffies + msecs_to_jiffies (20);
 			ehci_dbg (ehci, "port %d remote wakeup\n", i + 1);
-			usb_hcd_resume_root_hub(hcd);
 		}
 	}
 
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 0a56dfa2745d..bfe5f307cba6 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -34,6 +34,7 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
 	int			port;
+	int			mask;
 
 	if (time_before (jiffies, ehci-&gt;next_statechange))
 		msleep(5);
@@ -51,14 +52,25 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 		ehci-&gt;reclaim_ready = 1;
 	ehci_work(ehci);
 
-	/* suspend any active/unsuspended ports, maybe allow wakeup */
+	/* Unlike other USB host controller types, EHCI doesn't have
+	 * any notion of "global" or bus-wide suspend.  The driver has
+	 * to manually suspend all the active unsuspended ports, and
+	 * then manually resume them in the bus_resume() routine.
+	 */
+	ehci-&gt;bus_suspended = 0;
 	while (port--) {
 		u32 __iomem	*reg = &amp;ehci-&gt;regs-&gt;port_status [port];
 		u32		t1 = readl (reg) &amp; ~PORT_RWC_BITS;
 		u32		t2 = t1;
 
-		if ((t1 &amp; PORT_PE) &amp;&amp; !(t1 &amp; PORT_OWNER))
+		/* keep track of which ports we suspend */
+		if ((t1 &amp; PORT_PE) &amp;&amp; !(t1 &amp; PORT_OWNER) &amp;&amp;
+				!(t1 &amp; PORT_SUSPEND)) {
 			t2 |= PORT_SUSPEND;
+			set_bit(port, &amp;ehci-&gt;bus_suspended);
+		}
+
+		/* enable remote wakeup on all ports */
 		if (device_may_wakeup(&amp;hcd-&gt;self.root_hub-&gt;dev))
 			t2 |= PORT_WKOC_E|PORT_WKDISC_E|PORT_WKCONN_E;
 		else
@@ -76,6 +88,13 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 	ehci_halt (ehci);
 	hcd-&gt;state = HC_STATE_SUSPENDED;
 
+	/* allow remote wakeup */
+	mask = INTR_MASK;
+	if (!device_may_wakeup(&amp;hcd-&gt;self.root_hub-&gt;dev))
+		mask &amp;= ~STS_PCD;
+	writel(mask, &amp;ehci-&gt;regs-&gt;intr_enable);
+	readl(&amp;ehci-&gt;regs-&gt;intr_enable);
+
 	ehci-&gt;next_statechange = jiffies + msecs_to_jiffies(10);
 	spin_unlock_irq (&amp;ehci-&gt;lock);
 	return 0;
@@ -88,7 +107,6 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
 	u32			temp;
 	int			i;
-	int			intr_enable;
 
 	if (time_before (jiffies, ehci-&gt;next_statechange))
 		msleep(5);
@@ -100,31 +118,30 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 	 * the last user of the controller, not reset/pm hardware keeping
 	 * state we gave to it.
 	 */
+	temp = readl(&amp;ehci-&gt;regs-&gt;intr_enable);
+	ehci_dbg(ehci, "resume root hub%s\n", temp ? "" : " after power loss");
 
-	/* re-init operational registers in case we lost power */
-	if (readl (&amp;ehci-&gt;regs-&gt;intr_enable) == 0) {
-		/* at least some APM implementations will try to deliver
-		 * IRQs right away, so delay them until we're ready.
-		 */
-		intr_enable = 1;
-		writel (0, &amp;ehci-&gt;regs-&gt;segment);
-		writel (ehci-&gt;periodic_dma, &amp;ehci-&gt;regs-&gt;frame_list);
-		writel ((u32)ehci-&gt;async-&gt;qh_dma, &amp;ehci-&gt;regs-&gt;async_next);
-	} else
-		intr_enable = 0;
-	ehci_dbg(ehci, "resume root hub%s\n",
-			intr_enable ? " after power loss" : "");
+	/* at least some APM implementations will try to deliver
+	 * IRQs right away, so delay them until we're ready.
+	 */
+	writel(0, &amp;ehci-&gt;regs-&gt;intr_enable);
+
+	/* re-init operational registers */
+	writel(0, &amp;ehci-&gt;regs-&gt;segment);
+	writel(ehci-&gt;periodic_dma, &amp;ehci-&gt;regs-&gt;frame_list);
+	writel((u32) ehci-&gt;async-&gt;qh_dma, &amp;ehci-&gt;regs-&gt;async_next);
 
 	/* restore CMD_RUN, framelist size, and irq threshold */
 	writel (ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
 
-	/* take ports out of suspend */
+	/* manually resume the ports we suspended during bus_suspend() */
 	i = HCS_N_PORTS (ehci-&gt;hcs_params);
 	while (i--) {
 		temp = readl (&amp;ehci-&gt;regs-&gt;port_status [i]);
 		temp &amp;= ~(PORT_RWC_BITS
 			| PORT_WKOC_E | PORT_WKDISC_E | PORT_WKCONN_E);
-		if (temp &amp; PORT_SUSPEND) {
+		if (test_bit(i, &amp;ehci-&gt;bus_suspended) &amp;&amp;
+				(temp &amp; PORT_SUSPEND)) {
 			ehci-&gt;reset_done [i] = jiffies + msecs_to_jiffies (20);
 			temp |= PORT_RESUME;
 		}
@@ -134,11 +151,12 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 	mdelay (20);
 	while (i--) {
 		temp = readl (&amp;ehci-&gt;regs-&gt;port_status [i]);
-		if ((temp &amp; PORT_SUSPEND) == 0)
-			continue;
-		temp &amp;= ~(PORT_RWC_BITS | PORT_RESUME);
-		writel (temp, &amp;ehci-&gt;regs-&gt;port_status [i]);
-		ehci_vdbg (ehci, "resumed port %d\n", i + 1);
+		if (test_bit(i, &amp;ehci-&gt;bus_suspended) &amp;&amp;
+				(temp &amp; PORT_SUSPEND)) {
+			temp &amp;= ~(PORT_RWC_BITS | PORT_RESUME);
+			writel (temp, &amp;ehci-&gt;regs-&gt;port_status [i]);
+			ehci_vdbg (ehci, "resumed port %d\n", i + 1);
+		}
 	}
 	(void) readl (&amp;ehci-&gt;regs-&gt;command);
 
@@ -157,8 +175,7 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 	hcd-&gt;state = HC_STATE_RUNNING;
 
 	/* Now we can safely re-enable irqs */
-	if (intr_enable)
-		writel (INTR_MASK, &amp;ehci-&gt;regs-&gt;intr_enable);
+	writel(INTR_MASK, &amp;ehci-&gt;regs-&gt;intr_enable);
 
 	spin_unlock_irq (&amp;ehci-&gt;lock);
 	return 0;
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index e51c1ed81ac4..4bc7970ba3ef 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -257,9 +257,7 @@ static int ehci_pci_suspend(struct usb_hcd *hcd, pm_message_t message)
 static int ehci_pci_resume(struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
-	unsigned		port;
 	struct pci_dev		*pdev = to_pci_dev(hcd-&gt;self.controller);
-	int			retval = -EINVAL;
 
 	// maybe restore FLADJ
 
@@ -269,27 +267,19 @@ static int ehci_pci_resume(struct usb_hcd *hcd)
 	/* Mark hardware accessible again as we are out of D3 state by now */
 	set_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
 
-	/* If CF is clear, we lost PCI Vaux power and need to restart.  */
-	if (readl(&amp;ehci-&gt;regs-&gt;configured_flag) != FLAG_CF)
-		goto restart;
-
-	/* If any port is suspended (or owned by the companion),
-	 * we know we can/must resume the HC (and mustn't reset it).
-	 * We just defer that to the root hub code.
+	/* If CF is still set, we maintained PCI Vaux power.
+	 * Just undo the effect of ehci_pci_suspend().
 	 */
-	for (port = HCS_N_PORTS(ehci-&gt;hcs_params); port &gt; 0; ) {
-		u32	status;
-		port--;
-		status = readl(&amp;ehci-&gt;regs-&gt;port_status [port]);
-		if (!(status &amp; PORT_POWER))
-			continue;
-		if (status &amp; (PORT_SUSPEND | PORT_RESUME | PORT_OWNER)) {
-			usb_hcd_resume_root_hub(hcd);
-			return 0;
-		}
+	if (readl(&amp;ehci-&gt;regs-&gt;configured_flag) == FLAG_CF) {
+		int	mask = INTR_MASK;
+
+		if (!device_may_wakeup(&amp;hcd-&gt;self.root_hub-&gt;dev))
+			mask &amp;= ~STS_PCD;
+		writel(mask, &amp;ehci-&gt;regs-&gt;intr_enable);
+		readl(&amp;ehci-&gt;regs-&gt;intr_enable);
+		return 0;
 	}
 
-restart:
 	ehci_dbg(ehci, "lost power, restarting\n");
 	usb_root_hub_lost_power(hcd-&gt;self.root_hub);
 
@@ -307,13 +297,15 @@ static int ehci_pci_resume(struct usb_hcd *hcd)
 	ehci_work(ehci);
 	spin_unlock_irq(&amp;ehci-&gt;lock);
 
-	/* restart; khubd will disconnect devices */
-	retval = ehci_run(hcd);
-
 	/* here we "know" root ports should always stay powered */
 	ehci_port_power(ehci, 1);
 
-	return retval;
+	writel(ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
+	writel(FLAG_CF, &amp;ehci-&gt;regs-&gt;configured_flag);
+	readl(&amp;ehci-&gt;regs-&gt;command);	/* unblock posted writes */
+
+	hcd-&gt;state = HC_STATE_SUSPENDED;
+	return 0;
 }
 #endif
 
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index bbc3082a73d7..74dbc6c8228f 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -74,6 +74,7 @@ struct ehci_hcd {			/* one per controller */
 
 	/* per root hub port */
 	unsigned long		reset_done [EHCI_MAX_ROOT_PORTS];
+	unsigned long		bus_suspended;
 
 	/* per-HC memory pools (could be per-bus, but ...) */
 	struct dma_pool		*qh_pool;	/* qh per active urb */</pre><hr><pre>commit 1f26e28d3e32339ca683f087cd55a70e2befc333
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Nov 16 10:16:00 2006 -0500

    USB: net2280: don't send unwanted zero-length packets
    
    The net2280 driver is too eager to send zero-length packets when
    IN tokens are received on ep0.  No such packet should be sent (the
    driver should NAK) before the gadget driver has queued the proper
    response.  Otherwise deferred responses are impossible.
    
    This patch (as823) makes net2280 avoid sending ZLPs for IN transfers
    on ep0 until a response has been submitted, and avoids stalling when an
    OUT packet is received before a request has been submitted for an OUT
    transfer on ep0.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: David Brownell &lt;david-b@pacbell.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/net2280.c b/drivers/usb/gadget/net2280.c
index 3acc896a5d4c..0b590831582c 100644
--- a/drivers/usb/gadget/net2280.c
+++ b/drivers/usb/gadget/net2280.c
@@ -1040,6 +1040,7 @@ net2280_queue (struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)
 
 	} /* else the irq handler advances the queue. */
 
+	ep-&gt;responded = 1;
 	if (req)
 		list_add_tail (&amp;req-&gt;queue, &amp;ep-&gt;queue);
 done:
@@ -2188,7 +2189,8 @@ static void handle_ep_small (struct net2280_ep *ep)
 					ep-&gt;stopped = 1;
 					set_halt (ep);
 					mode = 2;
-				} else if (!req &amp;&amp; !ep-&gt;stopped)
+				} else if (ep-&gt;responded &amp;&amp;
+						!req &amp;&amp; !ep-&gt;stopped)
 					write_fifo (ep, NULL);
 			}
 		} else {
@@ -2203,7 +2205,7 @@ static void handle_ep_small (struct net2280_ep *ep)
 			} else if (((t &amp; (1 &lt;&lt; DATA_OUT_PING_TOKEN_INTERRUPT))
 					&amp;&amp; req
 					&amp;&amp; req-&gt;req.actual == req-&gt;req.length)
-					|| !req) {
+					|| (ep-&gt;responded &amp;&amp; !req)) {
 				ep-&gt;dev-&gt;protocol_stall = 1;
 				set_halt (ep);
 				ep-&gt;stopped = 1;
@@ -2469,6 +2471,7 @@ static void handle_stat0_irqs (struct net2280 *dev, u32 stat)
 		/* we made the hardware handle most lowlevel requests;
 		 * everything else goes uplevel to the gadget code.
 		 */
+		ep-&gt;responded = 1;
 		switch (u.r.bRequest) {
 		case USB_REQ_GET_STATUS: {
 			struct net2280_ep	*e;
@@ -2537,6 +2540,7 @@ static void handle_stat0_irqs (struct net2280 *dev, u32 stat)
 				u.r.bRequestType, u.r.bRequest,
 				w_value, w_index, w_length,
 				readl (&amp;ep-&gt;regs-&gt;ep_cfg));
+			ep-&gt;responded = 0;
 			spin_unlock (&amp;dev-&gt;lock);
 			tmp = dev-&gt;driver-&gt;setup (&amp;dev-&gt;gadget, &amp;u.r);
 			spin_lock (&amp;dev-&gt;lock);
diff --git a/drivers/usb/gadget/net2280.h b/drivers/usb/gadget/net2280.h
index 957d6df34015..44ca139983d8 100644
--- a/drivers/usb/gadget/net2280.h
+++ b/drivers/usb/gadget/net2280.h
@@ -110,7 +110,8 @@ struct net2280_ep {
 						out_overflow : 1,
 						stopped : 1,
 						is_in : 1,
-						is_iso : 1;
+						is_iso : 1,
+						responded : 1;
 };
 
 static inline void allow_status (struct net2280_ep *ep)</pre><hr><pre>commit db063507b40664de33a61161c90358fe6fc9565a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Nov 13 15:02:04 2006 -0500

    USB core: fix compiler warning about usb_autosuspend_work
    
    This patch (as821) fixes a compiler warning when CONFIG_PM isn't on
    ("usb_autosuspend_work" defined but not used).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index a83c2d5065c1..81cb52564e68 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -200,13 +200,6 @@ static void ksuspend_usb_cleanup(void)
 	destroy_workqueue(ksuspend_usb_wq);
 }
 
-#else
-
-#define ksuspend_usb_init()	0
-#define ksuspend_usb_cleanup()	do {} while (0)
-
-#endif
-
 #ifdef	CONFIG_USB_SUSPEND
 
 /* usb_autosuspend_work - callback routine to autosuspend a USB device */
@@ -225,7 +218,14 @@ static void usb_autosuspend_work(void *_udev)
 static void usb_autosuspend_work(void *_udev)
 {}
 
-#endif
+#endif	/* CONFIG_USB_SUSPEND */
+
+#else
+
+#define ksuspend_usb_init()	0
+#define ksuspend_usb_cleanup()	do {} while (0)
+
+#endif	/* CONFIG_PM */
 
 /**
  * usb_alloc_dev - usb device constructor (usbcore-internal)</pre>
    <div class="pagination">
        <a href='2_114.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><span>[115]</span><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_116.html'>Next&gt;&gt;</a>
    <div>
</body>
