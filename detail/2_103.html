<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_102.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><span>[103]</span><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_104.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit fea3409112a93581db18da4c4332c8bf8d68af6b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jul 30 17:06:16 2007 -0400

    USB: add direction bit to urb-&gt;transfer_flags
    
    This patch (as945) adds a bit to urb-&gt;transfer_flags for recording the
    direction of the URB.  The bit is set/cleared automatically in
    usb_submit_urb() so drivers don't have to worry about it (although as
    a result, it isn't valid until the URB has been submitted).  Inline
    routines are added for easily checking an URB's direction.  They
    replace calls to usb_pipein in the DMA-mapping parts of hcd.c.
    
    For non-control endpoints, the direction is determined directly from
    the endpoint descriptor.  However control endpoints are
    bi-directional; for them the direction is determined from the
    bRequestType byte and the wLength value in the setup packet.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index cc5b1d3c3680..bcbaedc897d5 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -928,7 +928,7 @@ static void urb_unlink(struct usb_hcd *hcd, struct urb *urb)
 			dma_unmap_single (hcd-&gt;self.controller,
 					urb-&gt;transfer_dma,
 					urb-&gt;transfer_buffer_length,
-					usb_pipein (urb-&gt;pipe)
+					usb_urb_dir_in(urb)
 					    ? DMA_FROM_DEVICE
 					    : DMA_TO_DEVICE);
 	}
@@ -1014,7 +1014,7 @@ int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
 					hcd-&gt;self.controller,
 					urb-&gt;transfer_buffer,
 					urb-&gt;transfer_buffer_length,
-					usb_pipein (urb-&gt;pipe)
+					usb_urb_dir_in(urb)
 					    ? DMA_FROM_DEVICE
 					    : DMA_TO_DEVICE);
 	}
diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index ff53acb4fab2..1a64a6a850f3 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -309,7 +309,21 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 	 * and don't need to duplicate tests
 	 */
 	xfertype = usb_endpoint_type(&amp;ep-&gt;desc);
-	is_out = usb_pipeout(urb-&gt;pipe);
+	if (xfertype == USB_ENDPOINT_XFER_CONTROL) {
+		struct usb_ctrlrequest *setup =
+				(struct usb_ctrlrequest *) urb-&gt;setup_packet;
+
+		if (!setup)
+			return -ENOEXEC;
+		is_out = !(setup-&gt;bRequestType &amp; USB_DIR_IN) ||
+				!setup-&gt;wLength;
+	} else {
+		is_out = usb_endpoint_dir_out(&amp;ep-&gt;desc);
+	}
+
+	/* Cache the direction for later use */
+	urb-&gt;transfer_flags = (urb-&gt;transfer_flags &amp; ~URB_DIR_MASK) |
+			(is_out ? URB_DIR_OUT : URB_DIR_IN);
 
 	if (xfertype != USB_ENDPOINT_XFER_CONTROL &amp;&amp;
 			dev-&gt;state &lt; USB_STATE_CONFIGURED)
@@ -363,7 +377,7 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 
 	/* enforce simple/standard policy */
 	allowed = (URB_NO_TRANSFER_DMA_MAP | URB_NO_SETUP_DMA_MAP |
-			URB_NO_INTERRUPT);
+			URB_NO_INTERRUPT | URB_DIR_MASK);
 	switch (xfertype) {
 	case USB_ENDPOINT_XFER_BULK:
 		if (is_out)
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 818a1b4f737a..9d08f5a5ba76 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1021,6 +1021,8 @@ extern int usb_disabled(void);
 
 /*
  * urb-&gt;transfer_flags:
+ *
+ * Note: URB_DIR_IN/OUT is automatically set in usb_submit_urb().
  */
 #define URB_SHORT_NOT_OK	0x0001	/* report short reads as errors */
 #define URB_ISO_ASAP		0x0002	/* iso-only, urb-&gt;start_frame
@@ -1033,6 +1035,10 @@ extern int usb_disabled(void);
 					 * needed */
 #define URB_FREE_BUFFER		0x0100	/* Free transfer buffer with the URB */
 
+#define URB_DIR_IN		0x0200	/* Transfer from device to host */
+#define URB_DIR_OUT		0
+#define URB_DIR_MASK		URB_DIR_IN
+
 struct usb_iso_packet_descriptor {
 	unsigned int offset;
 	unsigned int length;		/* expected length */
@@ -1380,6 +1386,30 @@ extern void usb_unanchor_urb(struct urb *urb);
 extern int usb_wait_anchor_empty_timeout(struct usb_anchor *anchor,
 					 unsigned int timeout);
 
+/**
+ * usb_urb_dir_in - check if an URB describes an IN transfer
+ * @urb: URB to be checked
+ *
+ * Returns 1 if @urb describes an IN transfer (device-to-host),
+ * otherwise 0.
+ */
+static inline int usb_urb_dir_in(struct urb *urb)
+{
+	return (urb-&gt;transfer_flags &amp; URB_DIR_MASK) != URB_DIR_OUT;
+}
+
+/**
+ * usb_urb_dir_out - check if an URB describes an OUT transfer
+ * @urb: URB to be checked
+ *
+ * Returns 1 if @urb describes an OUT transfer (host-to-device),
+ * otherwise 0.
+ */
+static inline int usb_urb_dir_out(struct urb *urb)
+{
+	return (urb-&gt;transfer_flags &amp; URB_DIR_MASK) == URB_DIR_OUT;
+}
+
 void *usb_buffer_alloc (struct usb_device *dev, size_t size,
 	gfp_t mem_flags, dma_addr_t *dma);
 void usb_buffer_free (struct usb_device *dev, size_t size,</pre><hr><pre>commit bdd016ba64d909329cb4bacacc8443901c00e112
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jul 30 17:05:22 2007 -0400

    USB: add ep-&gt;enable
    
    This patch (as944) adds an explicit "enabled" field to the
    usb_host_endpoint structure and uses it in place of the current
    mechanism.  This is merely a time-space tradeoff; it makes checking
    whether URBs may be submitted to an endpoint simpler.  The existing
    mechanism is efficient when converting urb-&gt;pipe to an endpoint
    pointer, but it's not so efficient when urb-&gt;ep is used instead.
    
    As a side effect, the procedure for enabling an endpoint is now a
    little more complicated.  The ad-hoc inline code in usb.c and hub.c
    for enabling ep0 is now replaced with calls to usb_enable_endpoint,
    which is no longer static.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index fb82c500caf4..cc5b1d3c3680 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -943,7 +943,6 @@ int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
 {
 	int			status;
 	struct usb_hcd		*hcd = bus_to_hcd(urb-&gt;dev-&gt;bus);
-	struct usb_host_endpoint *ep;
 	unsigned long		flags;
 
 	if (!hcd)
@@ -960,9 +959,7 @@ int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
 	// FIXME:  verify that quiescing hc works right (RH cleans up)
 
 	spin_lock_irqsave(&amp;hcd_urb_list_lock, flags);
-	ep = (usb_pipein(urb-&gt;pipe) ? urb-&gt;dev-&gt;ep_in : urb-&gt;dev-&gt;ep_out)
-			[usb_pipeendpoint(urb-&gt;pipe)];
-	if (unlikely(ep != urb-&gt;ep))
+	if (unlikely(!urb-&gt;ep-&gt;enabled))
 		status = -ENOENT;
 	else if (unlikely (urb-&gt;reject))
 		status = -EPERM;
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index f7b337feb3ea..c8a01f66df70 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1999,7 +1999,7 @@ static void ep0_reinit(struct usb_device *udev)
 {
 	usb_disable_endpoint(udev, 0 + USB_DIR_IN);
 	usb_disable_endpoint(udev, 0 + USB_DIR_OUT);
-	udev-&gt;ep_in[0] = udev-&gt;ep_out[0] = &amp;udev-&gt;ep0;
+	usb_enable_endpoint(udev, &amp;udev-&gt;ep0);
 }
 
 #define usb_sndaddr0pipe()	(PIPE_CONTROL &lt;&lt; 30)
diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index d8f7b089a8f0..0d618647758e 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1013,8 +1013,10 @@ void usb_disable_endpoint(struct usb_device *dev, unsigned int epaddr)
 		ep = dev-&gt;ep_in[epnum];
 		dev-&gt;ep_in[epnum] = NULL;
 	}
-	if (ep &amp;&amp; dev-&gt;bus)
+	if (ep) {
+		ep-&gt;enabled = 0;
 		usb_hcd_endpoint_disable(dev, ep);
+	}
 }
 
 /**
@@ -1096,23 +1098,21 @@ void usb_disable_device(struct usb_device *dev, int skip_ep0)
  * Resets the endpoint toggle, and sets dev-&gt;ep_{in,out} pointers.
  * For control endpoints, both the input and output sides are handled.
  */
-static void
-usb_enable_endpoint(struct usb_device *dev, struct usb_host_endpoint *ep)
+void usb_enable_endpoint(struct usb_device *dev, struct usb_host_endpoint *ep)
 {
-	unsigned int epaddr = ep-&gt;desc.bEndpointAddress;
-	unsigned int epnum = epaddr &amp; USB_ENDPOINT_NUMBER_MASK;
-	int is_control;
+	int epnum = usb_endpoint_num(&amp;ep-&gt;desc);
+	int is_out = usb_endpoint_dir_out(&amp;ep-&gt;desc);
+	int is_control = usb_endpoint_xfer_control(&amp;ep-&gt;desc);
 
-	is_control = ((ep-&gt;desc.bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK)
-			== USB_ENDPOINT_XFER_CONTROL);
-	if (usb_endpoint_out(epaddr) || is_control) {
+	if (is_out || is_control) {
 		usb_settoggle(dev, epnum, 1, 0);
 		dev-&gt;ep_out[epnum] = ep;
 	}
-	if (!usb_endpoint_out(epaddr) || is_control) {
+	if (!is_out || is_control) {
 		usb_settoggle(dev, epnum, 0, 0);
 		dev-&gt;ep_in[epnum] = ep;
 	}
+	ep-&gt;enabled = 1;
 }
 
 /*
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index 0fee5c66fd64..d3c68d8eafb2 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -260,7 +260,7 @@ usb_alloc_dev(struct usb_device *parent, struct usb_bus *bus, unsigned port1)
 	dev-&gt;ep0.desc.bLength = USB_DT_ENDPOINT_SIZE;
 	dev-&gt;ep0.desc.bDescriptorType = USB_DT_ENDPOINT;
 	/* ep0 maxpacket comes later, from device descriptor */
-	dev-&gt;ep_in[0] = dev-&gt;ep_out[0] = &amp;dev-&gt;ep0;
+	usb_enable_endpoint(dev, &amp;dev-&gt;ep0);
 
 	/* Save readable and stable topology id, distinguishing devices
 	 * by location for diagnostics, tools, driver model, etc.  The
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index ad5fa0338f49..cde6e52b84fe 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -8,6 +8,8 @@ extern int usb_create_ep_files(struct device *parent, struct usb_host_endpoint *
 				struct usb_device *udev);
 extern void usb_remove_ep_files(struct usb_host_endpoint *endpoint);
 
+extern void usb_enable_endpoint(struct usb_device *dev,
+		struct usb_host_endpoint *ep);
 extern void usb_disable_endpoint (struct usb_device *dev, unsigned int epaddr);
 extern void usb_disable_interface (struct usb_device *dev,
 		struct usb_interface *intf);
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 105e3e9362d0..818a1b4f737a 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -52,6 +52,7 @@ struct ep_device;
  * @ep_dev: ep_device for sysfs info
  * @extra: descriptors following this endpoint in the configuration
  * @extralen: how many bytes of "extra" are valid
+ * @enabled: URBs may be submitted to this endpoint
  *
  * USB requests are always queued to a given endpoint, identified by a
  * descriptor within an active interface in a given USB configuration.
@@ -64,6 +65,7 @@ struct usb_host_endpoint {
 
 	unsigned char *extra;   /* Extra descriptors */
 	int extralen;
+	int enabled;
 };
 
 /* host-side wrapper for one interface setting's parsed descriptors */</pre><hr><pre>commit 5b653c79c04c6b152b8dc7d18f8c8a7f77f4b235
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jul 30 17:04:37 2007 -0400

    USB: add urb-&gt;ep
    
    This patch (as943) prepares the way for eliminating urb-&gt;pipe by
    introducing an endpoint pointer into struct urb.  For now urb-&gt;ep
    is set by usb_submit_urb() from the pipe value; eventually drivers
    will set it themselves and we will remove urb-&gt;pipe completely.
    
    The patch also adds new inline routines to retrieve an endpoint
    descriptor's number and transfer type, essentially as replacements for
    usb_pipeendpoint and usb_pipetype.
    
    usb_submit_urb(), usb_hcd_submit_urb(), and usb_hcd_unlink_urb() are
    converted to use the new field and new routines.  Other parts of
    usbcore will be converted in later patches.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 42ef1d5f6c8a..fb82c500caf4 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -962,14 +962,14 @@ int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
 	spin_lock_irqsave(&amp;hcd_urb_list_lock, flags);
 	ep = (usb_pipein(urb-&gt;pipe) ? urb-&gt;dev-&gt;ep_in : urb-&gt;dev-&gt;ep_out)
 			[usb_pipeendpoint(urb-&gt;pipe)];
-	if (unlikely (!ep))
+	if (unlikely(ep != urb-&gt;ep))
 		status = -ENOENT;
 	else if (unlikely (urb-&gt;reject))
 		status = -EPERM;
 	else switch (hcd-&gt;state) {
 	case HC_STATE_RUNNING:
 	case HC_STATE_RESUMING:
-		list_add_tail (&amp;urb-&gt;urb_list, &amp;ep-&gt;urb_list);
+		list_add_tail (&amp;urb-&gt;urb_list, &amp;urb-&gt;ep-&gt;urb_list);
 		status = 0;
 		break;
 	default:
@@ -1022,7 +1022,7 @@ int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
 					    : DMA_TO_DEVICE);
 	}
 
-	status = hcd-&gt;driver-&gt;urb_enqueue (hcd, ep, urb, mem_flags);
+	status = hcd-&gt;driver-&gt;urb_enqueue (hcd, urb-&gt;ep, urb, mem_flags);
 done:
 	if (unlikely (status)) {
 		urb_unlink(hcd, urb);
@@ -1071,7 +1071,6 @@ unlink1 (struct usb_hcd *hcd, struct urb *urb)
  */
 int usb_hcd_unlink_urb (struct urb *urb, int status)
 {
-	struct usb_host_endpoint	*ep;
 	struct usb_hcd			*hcd = NULL;
 	struct device			*sys = NULL;
 	unsigned long			flags;
@@ -1082,10 +1081,6 @@ int usb_hcd_unlink_urb (struct urb *urb, int status)
 		return -EINVAL;
 	if (!urb-&gt;dev || !urb-&gt;dev-&gt;bus)
 		return -ENODEV;
-	ep = (usb_pipein(urb-&gt;pipe) ? urb-&gt;dev-&gt;ep_in : urb-&gt;dev-&gt;ep_out)
-			[usb_pipeendpoint(urb-&gt;pipe)];
-	if (!ep)
-		return -ENODEV;
 
 	/*
 	 * we contend for urb-&gt;status with the hcd core,
@@ -1109,7 +1104,7 @@ int usb_hcd_unlink_urb (struct urb *urb, int status)
 	}
 
 	/* insist the urb is still queued */
-	list_for_each(tmp, &amp;ep-&gt;urb_list) {
+	list_for_each(tmp, &amp;urb-&gt;ep-&gt;urb_list) {
 		if (tmp == &amp;urb-&gt;urb_list)
 			break;
 	}
diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index be630228461c..ff53acb4fab2 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -277,9 +277,10 @@ EXPORT_SYMBOL_GPL(usb_unanchor_urb);
  */
 int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 {
-	int			pipe, temp, max;
-	struct usb_device	*dev;
-	int			is_out;
+	int				xfertype, max;
+	struct usb_device		*dev;
+	struct usb_host_endpoint	*ep;
+	int				is_out;
 
 	if (!urb || urb-&gt;hcpriv || !urb-&gt;complete)
 		return -EINVAL;
@@ -291,30 +292,34 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 			|| dev-&gt;state == USB_STATE_SUSPENDED)
 		return -EHOSTUNREACH;
 
+	/* For now, get the endpoint from the pipe.  Eventually drivers
+	 * will be required to set urb-&gt;ep directly and we will eliminate
+	 * urb-&gt;pipe.
+	 */
+	ep = (usb_pipein(urb-&gt;pipe) ? dev-&gt;ep_in : dev-&gt;ep_out)
+			[usb_pipeendpoint(urb-&gt;pipe)];
+	if (!ep)
+		return -ENOENT;
+
+	urb-&gt;ep = ep;
 	urb-&gt;status = -EINPROGRESS;
 	urb-&gt;actual_length = 0;
 
 	/* Lots of sanity checks, so HCDs can rely on clean data
 	 * and don't need to duplicate tests
 	 */
-	pipe = urb-&gt;pipe;
-	temp = usb_pipetype(pipe);
-	is_out = usb_pipeout(pipe);
+	xfertype = usb_endpoint_type(&amp;ep-&gt;desc);
+	is_out = usb_pipeout(urb-&gt;pipe);
 
-	if (!usb_pipecontrol(pipe) &amp;&amp; dev-&gt;state &lt; USB_STATE_CONFIGURED)
+	if (xfertype != USB_ENDPOINT_XFER_CONTROL &amp;&amp;
+			dev-&gt;state &lt; USB_STATE_CONFIGURED)
 		return -ENODEV;
 
-	/* FIXME there should be a sharable lock protecting us against
-	 * config/altsetting changes and disconnects, kicking in here.
-	 * (here == before maxpacket, and eventually endpoint type,
-	 * checks get made.)
-	 */
-
-	max = usb_maxpacket(dev, pipe, is_out);
+	max = le16_to_cpu(ep-&gt;desc.wMaxPacketSize);
 	if (max &lt;= 0) {
 		dev_dbg(&amp;dev-&gt;dev,
 			"bogus endpoint ep%d%s in %s (bad maxpacket %d)\n",
-			usb_pipeendpoint(pipe), is_out ? "out" : "in",
+			usb_endpoint_num(&amp;ep-&gt;desc), is_out ? "out" : "in",
 			__FUNCTION__, max);
 		return -EMSGSIZE;
 	}
@@ -323,7 +328,7 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 	 * but drivers only control those sizes for ISO.
 	 * while we're checking, initialize return status.
 	 */
-	if (temp == PIPE_ISOCHRONOUS) {
+	if (xfertype == USB_ENDPOINT_XFER_ISOC) {
 		int	n, len;
 
 		/* "high bandwidth" mode, 1-3 packets/uframe? */
@@ -359,19 +364,19 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 	/* enforce simple/standard policy */
 	allowed = (URB_NO_TRANSFER_DMA_MAP | URB_NO_SETUP_DMA_MAP |
 			URB_NO_INTERRUPT);
-	switch (temp) {
-	case PIPE_BULK:
+	switch (xfertype) {
+	case USB_ENDPOINT_XFER_BULK:
 		if (is_out)
 			allowed |= URB_ZERO_PACKET;
 		/* FALLTHROUGH */
-	case PIPE_CONTROL:
+	case USB_ENDPOINT_XFER_CONTROL:
 		allowed |= URB_NO_FSBR;	/* only affects UHCI */
 		/* FALLTHROUGH */
 	default:			/* all non-iso endpoints */
 		if (!is_out)
 			allowed |= URB_SHORT_NOT_OK;
 		break;
-	case PIPE_ISOCHRONOUS:
+	case USB_ENDPOINT_XFER_ISOC:
 		allowed |= URB_ISO_ASAP;
 		break;
 	}
@@ -393,9 +398,9 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 	 * supports different values... this uses EHCI/UHCI defaults (and
 	 * EHCI can use smaller non-default values).
 	 */
-	switch (temp) {
-	case PIPE_ISOCHRONOUS:
-	case PIPE_INTERRUPT:
+	switch (xfertype) {
+	case USB_ENDPOINT_XFER_ISOC:
+	case USB_ENDPOINT_XFER_INT:
 		/* too small? */
 		if (urb-&gt;interval &lt;= 0)
 			return -EINVAL;
@@ -405,29 +410,29 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 			// NOTE usb handles 2^15
 			if (urb-&gt;interval &gt; (1024 * 8))
 				urb-&gt;interval = 1024 * 8;
-			temp = 1024 * 8;
+			max = 1024 * 8;
 			break;
 		case USB_SPEED_FULL:	/* units are frames/msec */
 		case USB_SPEED_LOW:
-			if (temp == PIPE_INTERRUPT) {
+			if (xfertype == USB_ENDPOINT_XFER_INT) {
 				if (urb-&gt;interval &gt; 255)
 					return -EINVAL;
 				// NOTE ohci only handles up to 32
-				temp = 128;
+				max = 128;
 			} else {
 				if (urb-&gt;interval &gt; 1024)
 					urb-&gt;interval = 1024;
 				// NOTE usb and ohci handle up to 2^15
-				temp = 1024;
+				max = 1024;
 			}
 			break;
 		default:
 			return -EINVAL;
 		}
 		/* power of two? */
-		while (temp &gt; urb-&gt;interval)
-			temp &gt;&gt;= 1;
-		urb-&gt;interval = temp;
+		while (max &gt; urb-&gt;interval)
+			max &gt;&gt;= 1;
+		urb-&gt;interval = max;
 	}
 
 	return usb_hcd_submit_urb(urb, mem_flags);
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 4f33a58fa9d1..105e3e9362d0 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -554,6 +554,29 @@ static inline int usb_make_path (struct usb_device *dev, char *buf,
 
 /*-------------------------------------------------------------------------*/
 
+/**
+ * usb_endpoint_num - get the endpoint's number
+ * @epd: endpoint to be checked
+ *
+ * Returns @epd's number: 0 to 15.
+ */
+static inline int usb_endpoint_num(const struct usb_endpoint_descriptor *epd)
+{
+	return epd-&gt;bEndpointAddress &amp; USB_ENDPOINT_NUMBER_MASK;
+}
+
+/**
+ * usb_endpoint_type - get the endpoint's transfer type
+ * @epd: endpoint to be checked
+ *
+ * Returns one of USB_ENDPOINT_XFER_{CONTROL, ISOC, BULK, INT} according
+ * to @epd's transfer type.
+ */
+static inline int usb_endpoint_type(const struct usb_endpoint_descriptor *epd)
+{
+	return epd-&gt;bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK;
+}
+
 /**
  * usb_endpoint_dir_in - check if the endpoint has IN direction
  * @epd: endpoint to be checked
@@ -1037,6 +1060,8 @@ typedef void (*usb_complete_t)(struct urb *);
  * @urb_list: For use by current owner of the URB.
  * @anchor_list: membership in the list of an anchor
  * @anchor: to anchor URBs to a common mooring
+ * @ep: Points to the endpoint's data structure.  Will eventually
+ *	replace @pipe.
  * @pipe: Holds endpoint number, direction, type, and more.
  *	Create these values with the eight macros available;
  *	usb_{snd,rcv}TYPEpipe(dev,endpoint), where the TYPE is "ctrl"
@@ -1212,6 +1237,7 @@ struct urb
 	struct list_head anchor_list;	/* the URB may be anchored by the driver */
 	struct usb_anchor *anchor;
 	struct usb_device *dev; 	/* (in) pointer to associated device */
+	struct usb_host_endpoint *ep;	/* (internal) pointer to endpoint struct */
 	unsigned int pipe;		/* (in) pipe information */
 	int status;			/* (return) non-ISO status */
 	unsigned int transfer_flags;	/* (in) URB_SHORT_NOT_OK | ...*/</pre><hr><pre>commit cd59abfcc441b2abb4cf2cd62c1eb0f02a60e8dd
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Sep 21 15:36:56 2007 -0400

    PM: merge device power-management source files
    
    This patch (as993) merges the suspend.c and resume.c files in
    drivers/base/power into main.c, making some public symbols private.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/base/power/Makefile b/drivers/base/power/Makefile
index 9caeaea753a3..a803733c839e 100644
--- a/drivers/base/power/Makefile
+++ b/drivers/base/power/Makefile
@@ -1,5 +1,5 @@
 obj-y			:= shutdown.o
-obj-$(CONFIG_PM_SLEEP)	+= main.o suspend.o resume.o sysfs.o
+obj-$(CONFIG_PM_SLEEP)	+= main.o sysfs.o
 obj-$(CONFIG_PM_TRACE)	+= trace.o
 
 ifeq ($(CONFIG_DEBUG_DRIVER),y)
diff --git a/drivers/base/power/main.c b/drivers/base/power/main.c
index eb9f38d0aa58..0ab4ab21f564 100644
--- a/drivers/base/power/main.c
+++ b/drivers/base/power/main.c
@@ -20,19 +20,24 @@
  */
 
 #include &lt;linux/device.h&gt;
+#include &lt;linux/kallsyms.h&gt;
 #include &lt;linux/mutex.h&gt;
+#include &lt;linux/pm.h&gt;
+#include &lt;linux/resume-trace.h&gt;
 
+#include "../base.h"
 #include "power.h"
 
 LIST_HEAD(dpm_active);
-LIST_HEAD(dpm_off);
-LIST_HEAD(dpm_off_irq);
+static LIST_HEAD(dpm_off);
+static LIST_HEAD(dpm_off_irq);
 
-DEFINE_MUTEX(dpm_mtx);
-DEFINE_MUTEX(dpm_list_mtx);
+static DEFINE_MUTEX(dpm_mtx);
+static DEFINE_MUTEX(dpm_list_mtx);
 
 int (*platform_enable_wakeup)(struct device *dev, int is_on);
 
+
 int device_pm_add(struct device *dev)
 {
 	int error;
@@ -61,3 +66,334 @@ void device_pm_remove(struct device *dev)
 }
 
 
+/*------------------------- Resume routines -------------------------*/
+
+/**
+ *	resume_device - Restore state for one device.
+ *	@dev:	Device.
+ *
+ */
+
+static int resume_device(struct device * dev)
+{
+	int error = 0;
+
+	TRACE_DEVICE(dev);
+	TRACE_RESUME(0);
+
+	down(&amp;dev-&gt;sem);
+
+	if (dev-&gt;bus &amp;&amp; dev-&gt;bus-&gt;resume) {
+		dev_dbg(dev,"resuming\n");
+		error = dev-&gt;bus-&gt;resume(dev);
+	}
+
+	if (!error &amp;&amp; dev-&gt;type &amp;&amp; dev-&gt;type-&gt;resume) {
+		dev_dbg(dev,"resuming\n");
+		error = dev-&gt;type-&gt;resume(dev);
+	}
+
+	if (!error &amp;&amp; dev-&gt;class &amp;&amp; dev-&gt;class-&gt;resume) {
+		dev_dbg(dev,"class resume\n");
+		error = dev-&gt;class-&gt;resume(dev);
+	}
+
+	up(&amp;dev-&gt;sem);
+
+	TRACE_RESUME(error);
+	return error;
+}
+
+
+static int resume_device_early(struct device * dev)
+{
+	int error = 0;
+
+	TRACE_DEVICE(dev);
+	TRACE_RESUME(0);
+	if (dev-&gt;bus &amp;&amp; dev-&gt;bus-&gt;resume_early) {
+		dev_dbg(dev,"EARLY resume\n");
+		error = dev-&gt;bus-&gt;resume_early(dev);
+	}
+	TRACE_RESUME(error);
+	return error;
+}
+
+/*
+ * Resume the devices that have either not gone through
+ * the late suspend, or that did go through it but also
+ * went through the early resume
+ */
+static void dpm_resume(void)
+{
+	mutex_lock(&amp;dpm_list_mtx);
+	while(!list_empty(&amp;dpm_off)) {
+		struct list_head * entry = dpm_off.next;
+		struct device * dev = to_device(entry);
+
+		get_device(dev);
+		list_move_tail(entry, &amp;dpm_active);
+
+		mutex_unlock(&amp;dpm_list_mtx);
+		resume_device(dev);
+		mutex_lock(&amp;dpm_list_mtx);
+		put_device(dev);
+	}
+	mutex_unlock(&amp;dpm_list_mtx);
+}
+
+
+/**
+ *	device_resume - Restore state of each device in system.
+ *
+ *	Walk the dpm_off list, remove each entry, resume the device,
+ *	then add it to the dpm_active list.
+ */
+
+void device_resume(void)
+{
+	might_sleep();
+	mutex_lock(&amp;dpm_mtx);
+	dpm_resume();
+	mutex_unlock(&amp;dpm_mtx);
+}
+
+EXPORT_SYMBOL_GPL(device_resume);
+
+
+/**
+ *	dpm_power_up - Power on some devices.
+ *
+ *	Walk the dpm_off_irq list and power each device up. This
+ *	is used for devices that required they be powered down with
+ *	interrupts disabled. As devices are powered on, they are moved
+ *	to the dpm_active list.
+ *
+ *	Interrupts must be disabled when calling this.
+ */
+
+static void dpm_power_up(void)
+{
+	while(!list_empty(&amp;dpm_off_irq)) {
+		struct list_head * entry = dpm_off_irq.next;
+		struct device * dev = to_device(entry);
+
+		list_move_tail(entry, &amp;dpm_off);
+		resume_device_early(dev);
+	}
+}
+
+
+/**
+ *	device_power_up - Turn on all devices that need special attention.
+ *
+ *	Power on system devices then devices that required we shut them down
+ *	with interrupts disabled.
+ *	Called with interrupts disabled.
+ */
+
+void device_power_up(void)
+{
+	sysdev_resume();
+	dpm_power_up();
+}
+
+EXPORT_SYMBOL_GPL(device_power_up);
+
+
+/*------------------------- Suspend routines -------------------------*/
+
+/*
+ * The entries in the dpm_active list are in a depth first order, simply
+ * because children are guaranteed to be discovered after parents, and
+ * are inserted at the back of the list on discovery.
+ *
+ * All list on the suspend path are done in reverse order, so we operate
+ * on the leaves of the device tree (or forests, depending on how you want
+ * to look at it ;) first. As nodes are removed from the back of the list,
+ * they are inserted into the front of their destintation lists.
+ *
+ * Things are the reverse on the resume path - iterations are done in
+ * forward order, and nodes are inserted at the back of their destination
+ * lists. This way, the ancestors will be accessed before their descendents.
+ */
+
+static inline char *suspend_verb(u32 event)
+{
+	switch (event) {
+	case PM_EVENT_SUSPEND:	return "suspend";
+	case PM_EVENT_FREEZE:	return "freeze";
+	case PM_EVENT_PRETHAW:	return "prethaw";
+	default:		return "(unknown suspend event)";
+	}
+}
+
+
+static void
+suspend_device_dbg(struct device *dev, pm_message_t state, char *info)
+{
+	dev_dbg(dev, "%s%s%s\n", info, suspend_verb(state.event),
+		((state.event == PM_EVENT_SUSPEND) &amp;&amp; device_may_wakeup(dev)) ?
+		", may wakeup" : "");
+}
+
+/**
+ *	suspend_device - Save state of one device.
+ *	@dev:	Device.
+ *	@state:	Power state device is entering.
+ */
+
+static int suspend_device(struct device * dev, pm_message_t state)
+{
+	int error = 0;
+
+	down(&amp;dev-&gt;sem);
+	if (dev-&gt;power.power_state.event) {
+		dev_dbg(dev, "PM: suspend %d--&gt;%d\n",
+			dev-&gt;power.power_state.event, state.event);
+	}
+
+	if (dev-&gt;class &amp;&amp; dev-&gt;class-&gt;suspend) {
+		suspend_device_dbg(dev, state, "class ");
+		error = dev-&gt;class-&gt;suspend(dev, state);
+		suspend_report_result(dev-&gt;class-&gt;suspend, error);
+	}
+
+	if (!error &amp;&amp; dev-&gt;type &amp;&amp; dev-&gt;type-&gt;suspend) {
+		suspend_device_dbg(dev, state, "type ");
+		error = dev-&gt;type-&gt;suspend(dev, state);
+		suspend_report_result(dev-&gt;type-&gt;suspend, error);
+	}
+
+	if (!error &amp;&amp; dev-&gt;bus &amp;&amp; dev-&gt;bus-&gt;suspend) {
+		suspend_device_dbg(dev, state, "");
+		error = dev-&gt;bus-&gt;suspend(dev, state);
+		suspend_report_result(dev-&gt;bus-&gt;suspend, error);
+	}
+	up(&amp;dev-&gt;sem);
+	return error;
+}
+
+
+/*
+ * This is called with interrupts off, only a single CPU
+ * running. We can't acquire a mutex or semaphore (and we don't
+ * need the protection)
+ */
+static int suspend_device_late(struct device *dev, pm_message_t state)
+{
+	int error = 0;
+
+	if (dev-&gt;bus &amp;&amp; dev-&gt;bus-&gt;suspend_late) {
+		suspend_device_dbg(dev, state, "LATE ");
+		error = dev-&gt;bus-&gt;suspend_late(dev, state);
+		suspend_report_result(dev-&gt;bus-&gt;suspend_late, error);
+	}
+	return error;
+}
+
+/**
+ *	device_suspend - Save state and stop all devices in system.
+ *	@state:		Power state to put each device in.
+ *
+ *	Walk the dpm_active list, call -&gt;suspend() for each device, and move
+ *	it to the dpm_off list.
+ *
+ *	(For historical reasons, if it returns -EAGAIN, that used to mean
+ *	that the device would be called again with interrupts disabled.
+ *	These days, we use the "suspend_late()" callback for that, so we
+ *	print a warning and consider it an error).
+ *
+ *	If we get a different error, try and back out.
+ *
+ *	If we hit a failure with any of the devices, call device_resume()
+ *	above to bring the suspended devices back to life.
+ *
+ */
+
+int device_suspend(pm_message_t state)
+{
+	int error = 0;
+
+	might_sleep();
+	mutex_lock(&amp;dpm_mtx);
+	mutex_lock(&amp;dpm_list_mtx);
+	while (!list_empty(&amp;dpm_active) &amp;&amp; error == 0) {
+		struct list_head * entry = dpm_active.prev;
+		struct device * dev = to_device(entry);
+
+		get_device(dev);
+		mutex_unlock(&amp;dpm_list_mtx);
+
+		error = suspend_device(dev, state);
+
+		mutex_lock(&amp;dpm_list_mtx);
+
+		/* Check if the device got removed */
+		if (!list_empty(&amp;dev-&gt;power.entry)) {
+			/* Move it to the dpm_off list */
+			if (!error)
+				list_move(&amp;dev-&gt;power.entry, &amp;dpm_off);
+		}
+		if (error)
+			printk(KERN_ERR "Could not suspend device %s: "
+				"error %d%s\n",
+				kobject_name(&amp;dev-&gt;kobj), error,
+				error == -EAGAIN ? " (please convert to suspend_late)" : "");
+		put_device(dev);
+	}
+	mutex_unlock(&amp;dpm_list_mtx);
+	if (error)
+		dpm_resume();
+
+	mutex_unlock(&amp;dpm_mtx);
+	return error;
+}
+
+EXPORT_SYMBOL_GPL(device_suspend);
+
+/**
+ *	device_power_down - Shut down special devices.
+ *	@state:		Power state to enter.
+ *
+ *	Walk the dpm_off_irq list, calling -&gt;power_down() for each device that
+ *	couldn't power down the device with interrupts enabled. When we're
+ *	done, power down system devices.
+ */
+
+int device_power_down(pm_message_t state)
+{
+	int error = 0;
+	struct device * dev;
+
+	while (!list_empty(&amp;dpm_off)) {
+		struct list_head * entry = dpm_off.prev;
+
+		dev = to_device(entry);
+		error = suspend_device_late(dev, state);
+		if (error)
+			goto Error;
+		list_move(&amp;dev-&gt;power.entry, &amp;dpm_off_irq);
+	}
+
+	error = sysdev_suspend(state);
+ Done:
+	return error;
+ Error:
+	printk(KERN_ERR "Could not power down device %s: "
+		"error %d\n", kobject_name(&amp;dev-&gt;kobj), error);
+	dpm_power_up();
+	goto Done;
+}
+
+EXPORT_SYMBOL_GPL(device_power_down);
+
+void __suspend_report_result(const char *function, void *fn, int ret)
+{
+	if (ret) {
+		printk(KERN_ERR "%s(): ", function);
+		print_fn_descriptor_symbol("%s() returns ", (unsigned long)fn);
+		printk("%d\n", ret);
+	}
+}
+EXPORT_SYMBOL_GPL(__suspend_report_result);
diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index 49e64dbcce96..5c4efd493fa5 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -11,32 +11,11 @@ extern void device_shutdown(void);
  * main.c
  */
 
-/*
- * Used to synchronize global power management operations.
- */
-extern struct mutex dpm_mtx;
-
-/*
- * Used to serialize changes to the dpm_* lists.
- */
-extern struct mutex dpm_list_mtx;
-
-/*
- * The PM lists.
- */
-extern struct list_head dpm_active;
-extern struct list_head dpm_off;
-extern struct list_head dpm_off_irq;
-
-
-static inline struct dev_pm_info * to_pm_info(struct list_head * entry)
-{
-	return container_of(entry, struct dev_pm_info, entry);
-}
+extern struct list_head dpm_active;	/* The active device list */
 
 static inline struct device * to_device(struct list_head * entry)
 {
-	return container_of(to_pm_info(entry), struct device, power);
+	return container_of(entry, struct device, power.entry);
 }
 
 extern int device_pm_add(struct device *);
@@ -49,13 +28,6 @@ extern void device_pm_remove(struct device *);
 extern int dpm_sysfs_add(struct device *);
 extern void dpm_sysfs_remove(struct device *);
 
-/*
- * resume.c
- */
-
-extern void dpm_resume(void);
-extern void dpm_power_up(void);
-
 #else /* CONFIG_PM_SLEEP */
 
 
diff --git a/drivers/base/power/resume.c b/drivers/base/power/resume.c
deleted file mode 100644
index 67948bac9938..000000000000
--- a/drivers/base/power/resume.c
+++ /dev/null
@@ -1,149 +0,0 @@
-/*
- * resume.c - Functions for waking devices up.
- *
- * Copyright (c) 2003 Patrick Mochel
- * Copyright (c) 2003 Open Source Development Labs
- *
- * This file is released under the GPLv2
- *
- */
-
-#include &lt;linux/device.h&gt;
-#include &lt;linux/resume-trace.h&gt;
-#include "../base.h"
-#include "power.h"
-
-
-/**
- *	resume_device - Restore state for one device.
- *	@dev:	Device.
- *
- */
-
-static int resume_device(struct device * dev)
-{
-	int error = 0;
-
-	TRACE_DEVICE(dev);
-	TRACE_RESUME(0);
-
-	down(&amp;dev-&gt;sem);
-
-	if (dev-&gt;bus &amp;&amp; dev-&gt;bus-&gt;resume) {
-		dev_dbg(dev,"resuming\n");
-		error = dev-&gt;bus-&gt;resume(dev);
-	}
-
-	if (!error &amp;&amp; dev-&gt;type &amp;&amp; dev-&gt;type-&gt;resume) {
-		dev_dbg(dev,"resuming\n");
-		error = dev-&gt;type-&gt;resume(dev);
-	}
-
-	if (!error &amp;&amp; dev-&gt;class &amp;&amp; dev-&gt;class-&gt;resume) {
-		dev_dbg(dev,"class resume\n");
-		error = dev-&gt;class-&gt;resume(dev);
-	}
-
-	up(&amp;dev-&gt;sem);
-
-	TRACE_RESUME(error);
-	return error;
-}
-
-
-static int resume_device_early(struct device * dev)
-{
-	int error = 0;
-
-	TRACE_DEVICE(dev);
-	TRACE_RESUME(0);
-	if (dev-&gt;bus &amp;&amp; dev-&gt;bus-&gt;resume_early) {
-		dev_dbg(dev,"EARLY resume\n");
-		error = dev-&gt;bus-&gt;resume_early(dev);
-	}
-	TRACE_RESUME(error);
-	return error;
-}
-
-/*
- * Resume the devices that have either not gone through
- * the late suspend, or that did go through it but also
- * went through the early resume
- */
-void dpm_resume(void)
-{
-	mutex_lock(&amp;dpm_list_mtx);
-	while(!list_empty(&amp;dpm_off)) {
-		struct list_head * entry = dpm_off.next;
-		struct device * dev = to_device(entry);
-
-		get_device(dev);
-		list_move_tail(entry, &amp;dpm_active);
-
-		mutex_unlock(&amp;dpm_list_mtx);
-		resume_device(dev);
-		mutex_lock(&amp;dpm_list_mtx);
-		put_device(dev);
-	}
-	mutex_unlock(&amp;dpm_list_mtx);
-}
-
-
-/**
- *	device_resume - Restore state of each device in system.
- *
- *	Walk the dpm_off list, remove each entry, resume the device,
- *	then add it to the dpm_active list.
- */
-
-void device_resume(void)
-{
-	might_sleep();
-	mutex_lock(&amp;dpm_mtx);
-	dpm_resume();
-	mutex_unlock(&amp;dpm_mtx);
-}
-
-EXPORT_SYMBOL_GPL(device_resume);
-
-
-/**
- *	dpm_power_up - Power on some devices.
- *
- *	Walk the dpm_off_irq list and power each device up. This
- *	is used for devices that required they be powered down with
- *	interrupts disabled. As devices are powered on, they are moved
- *	to the dpm_active list.
- *
- *	Interrupts must be disabled when calling this.
- */
-
-void dpm_power_up(void)
-{
-	while(!list_empty(&amp;dpm_off_irq)) {
-		struct list_head * entry = dpm_off_irq.next;
-		struct device * dev = to_device(entry);
-
-		list_move_tail(entry, &amp;dpm_off);
-		resume_device_early(dev);
-	}
-}
-
-
-/**
- *	device_power_up - Turn on all devices that need special attention.
- *
- *	Power on system devices then devices that required we shut them down
- *	with interrupts disabled.
- *	Called with interrupts disabled.
- */
-
-void device_power_up(void)
-{
-	sysdev_resume();
-	dpm_power_up();
-}
-
-EXPORT_SYMBOL_GPL(device_power_up);
-
-
diff --git a/drivers/base/power/suspend.c b/drivers/base/power/suspend.c
deleted file mode 100644
index 204517afb15e..000000000000
--- a/drivers/base/power/suspend.c
+++ /dev/null
@@ -1,210 +0,0 @@
-/*
- * suspend.c - Functions for putting devices to sleep.
- *
- * Copyright (c) 2003 Patrick Mochel
- * Copyright (c) 2003 Open Source Development Labs
- *
- * This file is released under the GPLv2
- *
- */
-
-#include &lt;linux/device.h&gt;
-#include &lt;linux/kallsyms.h&gt;
-#include &lt;linux/pm.h&gt;
-#include "../base.h"
-#include "power.h"
-
-/*
- * The entries in the dpm_active list are in a depth first order, simply
- * because children are guaranteed to be discovered after parents, and
- * are inserted at the back of the list on discovery.
- *
- * All list on the suspend path are done in reverse order, so we operate
- * on the leaves of the device tree (or forests, depending on how you want
- * to look at it ;) first. As nodes are removed from the back of the list,
- * they are inserted into the front of their destintation lists.
- *
- * Things are the reverse on the resume path - iterations are done in
- * forward order, and nodes are inserted at the back of their destination
- * lists. This way, the ancestors will be accessed before their descendents.
- */
-
-static inline char *suspend_verb(u32 event)
-{
-	switch (event) {
-	case PM_EVENT_SUSPEND:	return "suspend";
-	case PM_EVENT_FREEZE:	return "freeze";
-	case PM_EVENT_PRETHAW:	return "prethaw";
-	default:		return "(unknown suspend event)";
-	}
-}
-
-
-static void
-suspend_device_dbg(struct device *dev, pm_message_t state, char *info)
-{
-	dev_dbg(dev, "%s%s%s\n", info, suspend_verb(state.event),
-		((state.event == PM_EVENT_SUSPEND) &amp;&amp; device_may_wakeup(dev)) ?
-		", may wakeup" : "");
-}
-
-/**
- *	suspend_device - Save state of one device.
- *	@dev:	Device.
- *	@state:	Power state device is entering.
- */
-
-static int suspend_device(struct device * dev, pm_message_t state)
-{
-	int error = 0;
-
-	down(&amp;dev-&gt;sem);
-	if (dev-&gt;power.power_state.event) {
-		dev_dbg(dev, "PM: suspend %d--&gt;%d\n",
-			dev-&gt;power.power_state.event, state.event);
-	}
-
-	if (dev-&gt;class &amp;&amp; dev-&gt;class-&gt;suspend) {
-		suspend_device_dbg(dev, state, "class ");
-		error = dev-&gt;class-&gt;suspend(dev, state);
-		suspend_report_result(dev-&gt;class-&gt;suspend, error);
-	}
-
-	if (!error &amp;&amp; dev-&gt;type &amp;&amp; dev-&gt;type-&gt;suspend) {
-		suspend_device_dbg(dev, state, "type ");
-		error = dev-&gt;type-&gt;suspend(dev, state);
-		suspend_report_result(dev-&gt;type-&gt;suspend, error);
-	}
-
-	if (!error &amp;&amp; dev-&gt;bus &amp;&amp; dev-&gt;bus-&gt;suspend) {
-		suspend_device_dbg(dev, state, "");
-		error = dev-&gt;bus-&gt;suspend(dev, state);
-		suspend_report_result(dev-&gt;bus-&gt;suspend, error);
-	}
-	up(&amp;dev-&gt;sem);
-	return error;
-}
-
-
-/*
- * This is called with interrupts off, only a single CPU
- * running. We can't acquire a mutex or semaphore (and we don't
- * need the protection)
- */
-static int suspend_device_late(struct device *dev, pm_message_t state)
-{
-	int error = 0;
-
-	if (dev-&gt;bus &amp;&amp; dev-&gt;bus-&gt;suspend_late) {
-		suspend_device_dbg(dev, state, "LATE ");
-		error = dev-&gt;bus-&gt;suspend_late(dev, state);
-		suspend_report_result(dev-&gt;bus-&gt;suspend_late, error);
-	}
-	return error;
-}
-
-/**
- *	device_suspend - Save state and stop all devices in system.
- *	@state:		Power state to put each device in.
- *
- *	Walk the dpm_active list, call -&gt;suspend() for each device, and move
- *	it to the dpm_off list.
- *
- *	(For historical reasons, if it returns -EAGAIN, that used to mean
- *	that the device would be called again with interrupts disabled.
- *	These days, we use the "suspend_late()" callback for that, so we
- *	print a warning and consider it an error).
- *
- *	If we get a different error, try and back out.
- *
- *	If we hit a failure with any of the devices, call device_resume()
- *	above to bring the suspended devices back to life.
- *
- */
-
-int device_suspend(pm_message_t state)
-{
-	int error = 0;
-
-	might_sleep();
-	mutex_lock(&amp;dpm_mtx);
-	mutex_lock(&amp;dpm_list_mtx);
-	while (!list_empty(&amp;dpm_active) &amp;&amp; error == 0) {
-		struct list_head * entry = dpm_active.prev;
-		struct device * dev = to_device(entry);
-
-		get_device(dev);
-		mutex_unlock(&amp;dpm_list_mtx);
-
-		error = suspend_device(dev, state);
-
-		mutex_lock(&amp;dpm_list_mtx);
-
-		/* Check if the device got removed */
-		if (!list_empty(&amp;dev-&gt;power.entry)) {
-			/* Move it to the dpm_off list */
-			if (!error)
-				list_move(&amp;dev-&gt;power.entry, &amp;dpm_off);
-		}
-		if (error)
-			printk(KERN_ERR "Could not suspend device %s: "
-				"error %d%s\n",
-				kobject_name(&amp;dev-&gt;kobj), error,
-				error == -EAGAIN ? " (please convert to suspend_late)" : "");
-		put_device(dev);
-	}
-	mutex_unlock(&amp;dpm_list_mtx);
-	if (error)
-		dpm_resume();
-
-	mutex_unlock(&amp;dpm_mtx);
-	return error;
-}
-
-EXPORT_SYMBOL_GPL(device_suspend);
-
-/**
- *	device_power_down - Shut down special devices.
- *	@state:		Power state to enter.
- *
- *	Walk the dpm_off_irq list, calling -&gt;power_down() for each device that
- *	couldn't power down the device with interrupts enabled. When we're
- *	done, power down system devices.
- */
-
-int device_power_down(pm_message_t state)
-{
-	int error = 0;
-	struct device * dev;
-
-	while (!list_empty(&amp;dpm_off)) {
-		struct list_head * entry = dpm_off.prev;
-
-		dev = to_device(entry);
-		error = suspend_device_late(dev, state);
-		if (error)
-			goto Error;
-		list_move(&amp;dev-&gt;power.entry, &amp;dpm_off_irq);
-	}
-
-	error = sysdev_suspend(state);
- Done:
-	return error;
- Error:
-	printk(KERN_ERR "Could not power down device %s: "
-		"error %d\n", kobject_name(&amp;dev-&gt;kobj), error);
-	dpm_power_up();
-	goto Done;
-}
-
-EXPORT_SYMBOL_GPL(device_power_down);
-
-void __suspend_report_result(const char *function, void *fn, int ret)
-{
-	if (ret) {
-		printk(KERN_ERR "%s(): ", function);
-		print_fn_descriptor_symbol("%s() returns ", (unsigned long)fn);
-		printk("%d\n", ret);
-	}
-}
-EXPORT_SYMBOL_GPL(__suspend_report_result);</pre><hr><pre>commit 7d2c592609a7da950b458403f1936d382f38ff9c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Aug 20 10:48:05 2007 -0400

    USB: disable autosuspend by default for non-hubs
    
    This patch (as965) disables autosuspend by default for all USB devices
    other than hubs.  We are seeing too many devices that can't suspend or
    resume properly, the blacklist is growing unreasonably quickly, and
    this sort of thing should be handled in userspace.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c
index 7f17d0fd76c0..ebf3dc20110a 100644
--- a/drivers/usb/core/quirks.c
+++ b/drivers/usb/core/quirks.c
@@ -152,4 +152,10 @@ void usb_detect_quirks(struct usb_device *udev)
 	/* do any special quirk handling here if needed */
 	if (udev-&gt;quirks &amp; USB_QUIRK_NO_AUTOSUSPEND)
 		usb_autosuspend_quirk(udev);
+
+	/* By default, disable autosuspend for all non-hubs */
+#ifdef	CONFIG_USB_SUSPEND
+	if (udev-&gt;descriptor.bDeviceClass != USB_CLASS_HUB)
+		udev-&gt;autosuspend_delay = -1;
+#endif
 }</pre><hr><pre>commit c269b6abd65c24517b70ccc9430c4c50dbc0dc84
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 4 10:12:44 2007 -0400

    USB: prevent Genesys USB-IDE from autosuspending
    
    This patch (as986) prevents the troublesome Genesys USB-IDE adapter
    from autosuspending.  It may not be necessary for all such devices,
    but the one in Bugzilla #8892 sometimes fails to resume.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c
index af3b627a93cf..e388cbceaad9 100644
--- a/drivers/usb/core/quirks.c
+++ b/drivers/usb/core/quirks.c
@@ -70,6 +70,10 @@ static const struct usb_device_id usb_quirk_list[] = {
 	{ USB_DEVICE(0x05cc, 0x2267), .driver_info = USB_QUIRK_NO_AUTOSUSPEND },
 	/* Ultima Electronics Corp.*/
 	{ USB_DEVICE(0x05d8, 0x4005), .driver_info = USB_QUIRK_NO_AUTOSUSPEND },
+
+	/* Genesys USB-to-IDE */
+	{ USB_DEVICE(0x0503, 0x0702), .driver_info = USB_QUIRK_NO_AUTOSUSPEND },
+
 	/* Agfa Snapscan1212u */
 	{ USB_DEVICE(0x06bd, 0x2061), .driver_info = USB_QUIRK_NO_AUTOSUSPEND },
 	/* Seagate RSS LLC */</pre><hr><pre>commit d7790baf62a0e9f034e4668bb4b5fdaaa248412b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 4 10:11:56 2007 -0400

    USB: prevent Thomson card reader from autosuspending
    
    This patch (as985) prevents the SGS THomson Microelectronics 4in1 card
    reader from autosuspending.  This resolves Bugzilla #8885.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c
index a5cde8ba1655..af3b627a93cf 100644
--- a/drivers/usb/core/quirks.c
+++ b/drivers/usb/core/quirks.c
@@ -32,6 +32,10 @@ static const struct usb_device_id usb_quirk_list[] = {
 	{ USB_DEVICE(0x03f0, 0x0701), .driver_info = USB_QUIRK_STRING_FETCH_255 },
 	/* Hewlett-Packard PhotoSmart 720 / PhotoSmart 935 (storage) */
 	{ USB_DEVICE(0x03f0, 0x4002), .driver_info = USB_QUIRK_NO_AUTOSUSPEND },
+
+	/* SGS Thomson Microelectronics 4in1 card reader */
+	{ USB_DEVICE(0x0483, 0x0321), .driver_info = USB_QUIRK_NO_AUTOSUSPEND },
+
 	/* Acer Peripherals Inc. (now BenQ Corp.) Prisa 640BU */
 	{ USB_DEVICE(0x04a5, 0x207e), .driver_info = USB_QUIRK_NO_AUTOSUSPEND },
 	/* Benq S2W 3300U */</pre><hr><pre>commit 5f1835da79df8607ecbd69f648b5b140b7a0b8ba
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Aug 16 16:13:06 2007 -0400

    sysfs: don't warn on removal of a nonexistent binary file
    
    This patch (as960) removes the error message and stack dump logged by
    sysfs_remove_bin_file() when someone tries to remove a nonexistent
    file.  The warning doesn't seem to be needed, since none of the other
    file-, symlink-, or directory-removal routines in sysfs complain in a
    comparable way.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Tejun Heo &lt;htejun@gmail.com&gt;
    Acked-by: Cornelia Huck &lt;cornelia.huck@de.ibm.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/fs/sysfs/bin.c b/fs/sysfs/bin.c
index 135353f8a296..5afe2a26f5d8 100644
--- a/fs/sysfs/bin.c
+++ b/fs/sysfs/bin.c
@@ -248,12 +248,7 @@ int sysfs_create_bin_file(struct kobject * kobj, struct bin_attribute * attr)
 
 void sysfs_remove_bin_file(struct kobject * kobj, struct bin_attribute * attr)
 {
-	if (sysfs_hash_and_remove(kobj-&gt;sd, attr-&gt;attr.name) &lt; 0) {
-		printk(KERN_ERR "%s: "
-			"bad dentry or inode or no such file: \"%s\"\n",
-			__FUNCTION__, attr-&gt;attr.name);
-		dump_stack();
-	}
+	sysfs_hash_and_remove(kobj-&gt;sd, attr-&gt;attr.name);
 }
 
 EXPORT_SYMBOL_GPL(sysfs_create_bin_file);</pre><hr><pre>commit d1a94f080f5bdfe46c9fb4954ffe8ae9ec29e44a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 17 10:58:16 2007 -0400

    USB: g_file_storage: fix bug in DMA buffer handling
    
    This patch (as963) fixes a recently-introduced bug.  The gadget
    conversion removing DMA-mapped buffer allocation did not remove quite
    enough code from the g_file_storage driver; DMA pointers were being
    set to 0.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/file_storage.c b/drivers/usb/gadget/file_storage.c
index 01ddb6d3e51b..965ad7bec7b7 100644
--- a/drivers/usb/gadget/file_storage.c
+++ b/drivers/usb/gadget/file_storage.c
@@ -599,7 +599,6 @@ enum fsg_buffer_state {
 
 struct fsg_buffhd {
 	void				*buf;
-	dma_addr_t			dma;
 	enum fsg_buffer_state		state;
 	struct fsg_buffhd		*next;
 
@@ -2612,7 +2611,6 @@ static int send_status(struct fsg_dev *fsg)
 
 		fsg-&gt;intr_buffhd = bh;		// Point to the right buffhd
 		fsg-&gt;intreq-&gt;buf = bh-&gt;inreq-&gt;buf;
-		fsg-&gt;intreq-&gt;dma = bh-&gt;inreq-&gt;dma;
 		fsg-&gt;intreq-&gt;context = bh;
 		start_transfer(fsg, fsg-&gt;intr_in, fsg-&gt;intreq,
 				&amp;fsg-&gt;intreq_busy, &amp;bh-&gt;state);
@@ -3201,7 +3199,6 @@ static int do_set_interface(struct fsg_dev *fsg, int altsetting)
 		if ((rc = alloc_request(fsg, fsg-&gt;bulk_out, &amp;bh-&gt;outreq)) != 0)
 			goto reset;
 		bh-&gt;inreq-&gt;buf = bh-&gt;outreq-&gt;buf = bh-&gt;buf;
-		bh-&gt;inreq-&gt;dma = bh-&gt;outreq-&gt;dma = bh-&gt;dma;
 		bh-&gt;inreq-&gt;context = bh-&gt;outreq-&gt;context = bh;
 		bh-&gt;inreq-&gt;complete = bulk_in_complete;
 		bh-&gt;outreq-&gt;complete = bulk_out_complete;</pre><hr><pre>commit 013d27f265de6934ad7fb48fb29ab0172a20ab40
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Aug 20 12:18:39 2007 -0400

    USB: update last_busy field correctly
    
    This patch (as966) fixes a bug in the autosuspend code.  The last_busy
    field should be updated whenever any event occurs, not just events
    that cause an autosuspend or an autoresume.
    
    This partially fixes Bugzilla #8892.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 654857493a82..a1ad11d0c47c 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -1224,6 +1224,8 @@ static int usb_autopm_do_device(struct usb_device *udev, int inc_usage_cnt)
 	udev-&gt;auto_pm = 1;
 	udev-&gt;pm_usage_cnt += inc_usage_cnt;
 	WARN_ON(udev-&gt;pm_usage_cnt &lt; 0);
+	if (inc_usage_cnt)
+		udev-&gt;last_busy = jiffies;
 	if (inc_usage_cnt &gt;= 0 &amp;&amp; udev-&gt;pm_usage_cnt &gt; 0) {
 		if (udev-&gt;state == USB_STATE_SUSPENDED)
 			status = usb_resume_both(udev);
@@ -1232,8 +1234,6 @@ static int usb_autopm_do_device(struct usb_device *udev, int inc_usage_cnt)
 		else if (inc_usage_cnt)
 			udev-&gt;last_busy = jiffies;
 	} else if (inc_usage_cnt &lt;= 0 &amp;&amp; udev-&gt;pm_usage_cnt &lt;= 0) {
-		if (inc_usage_cnt)
-			udev-&gt;last_busy = jiffies;
 		status = usb_suspend_both(udev, PMSG_SUSPEND);
 	}
 	usb_pm_unlock(udev);
@@ -1342,16 +1342,15 @@ static int usb_autopm_do_interface(struct usb_interface *intf,
 	else {
 		udev-&gt;auto_pm = 1;
 		intf-&gt;pm_usage_cnt += inc_usage_cnt;
+		udev-&gt;last_busy = jiffies;
 		if (inc_usage_cnt &gt;= 0 &amp;&amp; intf-&gt;pm_usage_cnt &gt; 0) {
 			if (udev-&gt;state == USB_STATE_SUSPENDED)
 				status = usb_resume_both(udev);
 			if (status != 0)
 				intf-&gt;pm_usage_cnt -= inc_usage_cnt;
-			else if (inc_usage_cnt)
+			else
 				udev-&gt;last_busy = jiffies;
 		} else if (inc_usage_cnt &lt;= 0 &amp;&amp; intf-&gt;pm_usage_cnt &lt;= 0) {
-			if (inc_usage_cnt)
-				udev-&gt;last_busy = jiffies;
 			status = usb_suspend_both(udev, PMSG_SUSPEND);
 		}
 	}</pre>
    <div class="pagination">
        <a href='2_102.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><span>[103]</span><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_104.html'>Next&gt;&gt;</a>
    <div>
</body>
