<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_118.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><span>[119]</span><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_120.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit efd54a364121f61b2050b1df5ecb1b8329c4eaba
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Sep 25 11:55:56 2006 -0400

    USB: dummy-hcd: fix "warn-unused-result" messages
    
    This patch (as758) fixes the "warn-unused-result" messages in dummy-hcd.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index fdab97a27c08..4d2946e540cf 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -816,15 +816,14 @@ usb_gadget_register_driver (struct usb_gadget_driver *driver)
 	dum-&gt;gadget.dev.driver = &amp;driver-&gt;driver;
 	dev_dbg (udc_dev(dum), "binding gadget driver '%s'\n",
 			driver-&gt;driver.name);
-	if ((retval = driver-&gt;bind (&amp;dum-&gt;gadget)) != 0) {
-		dum-&gt;driver = NULL;
-		dum-&gt;gadget.dev.driver = NULL;
-		return retval;
-	}
+	if ((retval = driver-&gt;bind (&amp;dum-&gt;gadget)) != 0)
+		goto err_bind_gadget;
 
 	driver-&gt;driver.bus = dum-&gt;gadget.dev.parent-&gt;bus;
-	driver_register (&amp;driver-&gt;driver);
-	device_bind_driver (&amp;dum-&gt;gadget.dev);
+	if ((retval = driver_register (&amp;driver-&gt;driver)) != 0)
+		goto err_register;
+	if ((retval = device_bind_driver (&amp;dum-&gt;gadget.dev)) != 0)
+		goto err_bind_driver;
 
 	/* khubd will enumerate this in a while */
 	spin_lock_irq (&amp;dum-&gt;lock);
@@ -834,6 +833,19 @@ usb_gadget_register_driver (struct usb_gadget_driver *driver)
 
 	usb_hcd_poll_rh_status (dummy_to_hcd (dum));
 	return 0;
+
+err_bind_driver:
+	driver_unregister (&amp;driver-&gt;driver);
+err_register:
+	driver-&gt;unbind (&amp;dum-&gt;gadget);
+	spin_lock_irq (&amp;dum-&gt;lock);
+	dum-&gt;pullup = 0;
+	set_link_state (dum);
+	spin_unlock_irq (&amp;dum-&gt;lock);
+err_bind_gadget:
+	dum-&gt;driver = NULL;
+	dum-&gt;gadget.dev.driver = NULL;
+	return retval;
 }
 EXPORT_SYMBOL (usb_gadget_register_driver);
 
@@ -916,7 +928,9 @@ static int dummy_udc_probe (struct platform_device *pdev)
 	usb_get_hcd (dummy_to_hcd (dum));
 
 	platform_set_drvdata (pdev, dum);
-	device_create_file (&amp;dum-&gt;gadget.dev, &amp;dev_attr_function);
+	rc = device_create_file (&amp;dum-&gt;gadget.dev, &amp;dev_attr_function);
+	if (rc &lt; 0)
+		device_unregister (&amp;dum-&gt;gadget.dev);
 	return rc;
 }
 
@@ -1864,8 +1878,7 @@ static int dummy_start (struct usb_hcd *hcd)
 #endif
 
 	/* FIXME 'urbs' should be a per-device thing, maybe in usbcore */
-	device_create_file (dummy_dev(dum), &amp;dev_attr_urbs);
-	return 0;
+	return device_create_file (dummy_dev(dum), &amp;dev_attr_urbs);
 }
 
 static void dummy_stop (struct usb_hcd *hcd)</pre><hr><pre>commit bd859281c09b4318153dc7222b5e9052aad83b61
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 19 10:14:07 2006 -0400

    USB: create new workqueue thread for USB autosuspend
    
    This patch (as787) creates a new workqueue thread to handle delayed
    USB autosuspend requests.  Previously the code used keventd.  However
    it turns out that the hub driver's suspend routine calls
    flush_scheduled_work(), making it a poor candidate for running in
    keventd (the call immediately deadlocks).  The solution is to use a
    new thread instead of keventd.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index c2aad6a4d49f..ee18d187ca17 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -24,6 +24,7 @@
 
 #include &lt;linux/device.h&gt;
 #include &lt;linux/usb.h&gt;
+#include &lt;linux/workqueue.h&gt;
 #include "hcd.h"
 #include "usb.h"
 
@@ -1131,7 +1132,7 @@ void usb_autosuspend_device(struct usb_device *udev, int dec_usage_cnt)
 	mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
 	udev-&gt;pm_usage_cnt -= dec_usage_cnt;
 	if (udev-&gt;pm_usage_cnt &lt;= 0)
-		schedule_delayed_work(&amp;udev-&gt;autosuspend,
+		queue_delayed_work(ksuspend_usb_wq, &amp;udev-&gt;autosuspend,
 				USB_AUTOSUSPEND_DELAY);
 	mutex_unlock(&amp;udev-&gt;pm_mutex);
 	// dev_dbg(&amp;udev-&gt;dev, "%s: cnt %d\n",
@@ -1215,10 +1216,10 @@ void usb_autopm_put_interface(struct usb_interface *intf)
 	struct usb_device	*udev = interface_to_usbdev(intf);
 
 	mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
-	if (intf-&gt;condition != USB_INTERFACE_UNBOUND) {
-		if (--intf-&gt;pm_usage_cnt &lt;= 0)
-			schedule_delayed_work(&amp;udev-&gt;autosuspend,
-					USB_AUTOSUSPEND_DELAY);
+	if (intf-&gt;condition != USB_INTERFACE_UNBOUND &amp;&amp;
+			--intf-&gt;pm_usage_cnt &lt;= 0) {
+		queue_delayed_work(ksuspend_usb_wq, &amp;udev-&gt;autosuspend,
+				USB_AUTOSUSPEND_DELAY);
 	}
 	mutex_unlock(&amp;udev-&gt;pm_mutex);
 	// dev_dbg(&amp;intf-&gt;dev, "%s: cnt %d\n",
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index 60ef4ef0101a..239f8e5d247f 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -33,6 +33,7 @@
 #include &lt;linux/smp_lock.h&gt;
 #include &lt;linux/usb.h&gt;
 #include &lt;linux/mutex.h&gt;
+#include &lt;linux/workqueue.h&gt;
 
 #include &lt;asm/io.h&gt;
 #include &lt;asm/scatterlist.h&gt;
@@ -47,6 +48,8 @@ const char *usbcore_name = "usbcore";
 
 static int nousb;	/* Disable USB when built into kernel image */
 
+struct workqueue_struct *ksuspend_usb_wq;	/* For autosuspend */
+
 
 /**
  * usb_ifnum_to_if - get the interface object with a given interface number
@@ -170,9 +173,9 @@ static void usb_release_dev(struct device *dev)
 
 	udev = to_usb_device(dev);
 
-#ifdef	CONFIG_PM
+#ifdef	CONFIG_USB_SUSPEND
 	cancel_delayed_work(&amp;udev-&gt;autosuspend);
-	flush_scheduled_work();
+	flush_workqueue(ksuspend_usb_wq);
 #endif
 	usb_destroy_configuration(udev);
 	usb_put_hcd(bus_to_hcd(udev-&gt;bus));
@@ -184,6 +187,28 @@ static void usb_release_dev(struct device *dev)
 
 #ifdef	CONFIG_PM
 
+static int ksuspend_usb_init(void)
+{
+	ksuspend_usb_wq = create_singlethread_workqueue("ksuspend_usbd");
+	if (!ksuspend_usb_wq)
+		return -ENOMEM;
+	return 0;
+}
+
+static void ksuspend_usb_cleanup(void)
+{
+	destroy_workqueue(ksuspend_usb_wq);
+}
+
+#else
+
+#define ksuspend_usb_init()	0
+#define ksuspend_usb_cleanup()	do {} while (0)
+
+#endif
+
+#ifdef	CONFIG_USB_SUSPEND
+
 /* usb_autosuspend_work - callback routine to autosuspend a USB device */
 static void usb_autosuspend_work(void *_udev)
 {
@@ -195,6 +220,11 @@ static void usb_autosuspend_work(void *_udev)
 	mutex_unlock(&amp;udev-&gt;pm_mutex);
 }
 
+#else
+
+static void usb_autosuspend_work(void *_udev)
+{}
+
 #endif
 
 /**
@@ -976,9 +1006,12 @@ static int __init usb_init(void)
 		return 0;
 	}
 
+	retval = ksuspend_usb_init();
+	if (retval)
+		goto out;
 	retval = bus_register(&amp;usb_bus_type);
 	if (retval) 
-		goto out;
+		goto bus_register_failed;
 	retval = usb_host_init();
 	if (retval)
 		goto host_init_failed;
@@ -1014,6 +1047,8 @@ static int __init usb_init(void)
 	usb_host_cleanup();
 host_init_failed:
 	bus_unregister(&amp;usb_bus_type);
+bus_register_failed:
+	ksuspend_usb_cleanup();
 out:
 	return retval;
 }
@@ -1035,6 +1070,7 @@ static void __exit usb_exit(void)
 	usb_hub_cleanup();
 	usb_host_cleanup();
 	bus_unregister(&amp;usb_bus_type);
+	ksuspend_usb_cleanup();
 }
 
 subsys_initcall(usb_init);
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 0c09ecced6e1..fb6eb41c374f 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -62,6 +62,7 @@ extern int usb_autoresume_device(struct usb_device *udev, int inc_busy_cnt);
 
 #endif
 
+extern struct workqueue_struct *ksuspend_usb_wq;
 extern struct bus_type usb_bus_type;
 extern struct usb_device_driver usb_generic_driver;
 </pre><hr><pre>commit 7923811a46f7e29ae8052edf2461e6c6b8ec2415
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Sep 28 12:11:56 2006 -0400

    USB: unusual-devs entry for Nokia E60
    
    This patch (as794) adds an unusual_devs entry for the Nokia E60.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index 40bf159f7d54..16baa105ed0a 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -152,6 +152,13 @@ UNUSUAL_DEV(  0x0421, 0x042e, 0x0100, 0x0100,
 		US_SC_DEVICE, US_PR_DEVICE, NULL,
 		US_FL_IGNORE_RESIDUE | US_FL_FIX_CAPACITY ),
 
+/* Reported by Jon Hart &lt;Jon.Hart@web.de&gt; */
+UNUSUAL_DEV(  0x0421, 0x0434, 0x0100, 0x0100,
+		"Nokia",
+		"E60",
+		US_SC_DEVICE, US_PR_DEVICE, NULL,
+		US_FL_FIX_CAPACITY | US_FL_IGNORE_RESIDUE ),
+
 /* Reported by Sumedha Swamy &lt;sumedhaswamy@gmail.com&gt; and
  * Einar Th. Einarsson &lt;einarthered@gmail.com&gt; */
 UNUSUAL_DEV(  0x0421, 0x0444, 0x0100, 0x0100,</pre><hr><pre>commit 353a4098c61272b33a02ec5802fb3859fec91a0e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 19 10:07:58 2006 -0400

    USB: force root hub resume after power loss
    
    This patch(as785) forces the PM core to resume a root hub after a
    power loss during system sleep.  If the root hub had been suspended
    before the system sleep then normally the PM core would not resume it
    afterward.  Without this resume, various sorts of wakeup events (like
    port change events) can get lost.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index c74baad19b16..00441cde4588 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1053,6 +1053,12 @@ void usb_root_hub_lost_power(struct usb_device *rhdev)
 	unsigned long flags;
 
 	dev_warn(&amp;rhdev-&gt;dev, "root hub lost power or was reset\n");
+
+	/* Make sure no potential wakeup events get lost,
+	 * by forcing the root hub to be resumed.
+	 */
+	rhdev-&gt;dev.power.prev_state.event = PM_EVENT_ON;
+
 	spin_lock_irqsave(&amp;device_state_lock, flags);
 	hub = hdev_to_hub(rhdev);
 	for (port1 = 1; port1 &lt;= rhdev-&gt;maxchild; ++port1) {</pre><hr><pre>commit 592fbbe4bc339399d363dd55f0391e0623400706
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 19 10:08:43 2006 -0400

    USB: fix root-hub resume when CONFIG_USB_SUSPEND is not set
    
    This patch (as786) removes a redundant test and fixes a problem
    involving repeated system sleeps when CONFIG_USB_SUSPEND is not set.
    During the first wakeup, the root hub's dev.power.power_state.event
    field doesn't get updated, causing it not to be suspended during the
    second sleep transition.
    
    This takes care of the issue raised by Rafael J. Wysocki and Mattia
    Dongili.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 2b2000ac05ab..0d063c8ca4b4 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -1071,10 +1071,15 @@ int usb_resume_both(struct usb_device *udev)
 					PM_EVENT_ON)
 				status = -EHOSTUNREACH;
 		}
-		if (status == 0 &amp;&amp; udev-&gt;state == USB_STATE_SUSPENDED)
+		if (status == 0)
 			status = resume_device(udev);
 		if (parent)
 			mutex_unlock(&amp;parent-&gt;pm_mutex);
+	} else {
+
+		/* Needed only for setting udev-&gt;dev.power.power_state.event
+		 * and for possible debugging message. */
+		status = resume_device(udev);
 	}
 
 	/* Now the parent won't suspend until we are finished */</pre><hr><pre>commit 02c399ee45a54987c152fe5f627ed949bb55f187
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 30 15:47:11 2006 -0400

    usbcore: remove usb_suspend_root_hub
    
    This patch (as740) removes the existing support for autosuspend of
    root hubs.  That support fit in rather awkwardly with the rest of
    usbcore and it was used only by ohci-hcd.  It won't be needed any more
    since the hub driver will take care of autosuspending all hubs, root
    or external.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 9dfc812de034..e86f62957085 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1431,50 +1431,6 @@ int hcd_bus_resume (struct usb_bus *bus)
 	return status;
 }
 
-/*
- * usb_hcd_suspend_root_hub - HCD autosuspends downstream ports
- * @hcd: host controller for this root hub
- *
- * This call arranges that usb_hcd_resume_root_hub() is safe to call later;
- * that the HCD's root hub polling is deactivated; and that the root's hub
- * driver is suspended.  HCDs may call this to autosuspend when their root
- * hub's downstream ports are all inactive:  unpowered, disconnected,
- * disabled, or suspended.
- *
- * The HCD will autoresume on device connect change detection (using SRP
- * or a D+/D- pullup).  The HCD also autoresumes on remote wakeup signaling
- * from any ports that are suspended (if that is enabled).  In most cases,
- * overcurrent signaling (on powered ports) will also start autoresume.
- *
- * Always called with IRQs blocked.
- */
-void usb_hcd_suspend_root_hub (struct usb_hcd *hcd)
-{
-	struct urb	*urb;
-
-	spin_lock (&amp;hcd_root_hub_lock);
-	usb_suspend_root_hub (hcd-&gt;self.root_hub);
-
-	/* force status urb to complete/unlink while suspended */
-	if (hcd-&gt;status_urb) {
-		urb = hcd-&gt;status_urb;
-		urb-&gt;status = -ECONNRESET;
-		urb-&gt;hcpriv = NULL;
-		urb-&gt;actual_length = 0;
-
-		del_timer (&amp;hcd-&gt;rh_timer);
-		hcd-&gt;poll_pending = 0;
-		hcd-&gt;status_urb = NULL;
-	} else
-		urb = NULL;
-	spin_unlock (&amp;hcd_root_hub_lock);
-	hcd-&gt;state = HC_STATE_SUSPENDED;
-
-	if (urb)
-		usb_hcd_giveback_urb (hcd, urb, NULL);
-}
-EXPORT_SYMBOL_GPL(usb_hcd_suspend_root_hub);
-
 /**
  * usb_hcd_resume_root_hub - called by HCD to resume its root hub 
  * @hcd: host controller for this root hub
diff --git a/drivers/usb/core/hcd.h b/drivers/usb/core/hcd.h
index 7a2bcba2ae61..676877c15f81 100644
--- a/drivers/usb/core/hcd.h
+++ b/drivers/usb/core/hcd.h
@@ -368,17 +368,11 @@ extern int usb_find_interface_driver (struct usb_device *dev,
 #define usb_endpoint_out(ep_dir)	(!((ep_dir) &amp; USB_DIR_IN))
 
 #ifdef CONFIG_PM
-extern void usb_hcd_suspend_root_hub (struct usb_hcd *hcd);
 extern void usb_hcd_resume_root_hub (struct usb_hcd *hcd);
 extern void usb_root_hub_lost_power (struct usb_device *rhdev);
 extern int hcd_bus_suspend (struct usb_bus *bus);
 extern int hcd_bus_resume (struct usb_bus *bus);
 #else
-static inline void usb_hcd_suspend_root_hub(struct usb_hcd *hcd)
-{
-	return;
-}
-
 static inline void usb_hcd_resume_root_hub(struct usb_hcd *hcd)
 {
 	return;
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index dee812bc6c43..7479bd329abb 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -452,18 +452,14 @@ static void hub_power_on(struct usb_hub *hub)
 	msleep(max(pgood_delay, (unsigned) 100));
 }
 
-static inline void __hub_quiesce(struct usb_hub *hub)
+static void hub_quiesce(struct usb_hub *hub)
 {
 	/* (nonblocking) khubd and related activity won't re-trigger */
 	hub-&gt;quiescing = 1;
 	hub-&gt;activating = 0;
 	hub-&gt;resume_root_hub = 0;
-}
 
-static void hub_quiesce(struct usb_hub *hub)
-{
 	/* (blocking) stop khubd and related activity */
-	__hub_quiesce(hub);
 	usb_kill_urb(hub-&gt;urb);
 	if (hub-&gt;has_indicators)
 		cancel_delayed_work(&amp;hub-&gt;leds);
@@ -1914,18 +1910,6 @@ static inline int remote_wakeup(struct usb_device *udev)
 #define hub_resume NULL
 #endif
 
-void usb_suspend_root_hub(struct usb_device *hdev)
-{
-	struct usb_hub *hub = hdev_to_hub(hdev);
-
-	/* This also makes any led blinker stop retriggering.  We're called
-	 * from irq, so the blinker might still be scheduled.  Caller promises
-	 * that the root hub status URB will be canceled.
-	 */
-	__hub_quiesce(hub);
-	mark_quiesced(to_usb_interface(hub-&gt;intfdev));
-}
-
 void usb_resume_root_hub(struct usb_device *hdev)
 {
 	struct usb_hub *hub = hdev_to_hub(hdev);
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 10688ad73c6d..e8bc2e48913a 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -20,7 +20,6 @@ extern char *usb_cache_string(struct usb_device *udev, int index);
 extern int usb_set_configuration(struct usb_device *dev, int configuration);
 
 extern void usb_kick_khubd(struct usb_device *dev);
-extern void usb_suspend_root_hub(struct usb_device *hdev);
 extern void usb_resume_root_hub(struct usb_device *dev);
 
 extern int  usb_hub_init(void);
diff --git a/drivers/usb/host/ohci-hub.c b/drivers/usb/host/ohci-hub.c
index f1b1ed086bde..0b899339cac8 100644
--- a/drivers/usb/host/ohci-hub.c
+++ b/drivers/usb/host/ohci-hub.c
@@ -135,9 +135,6 @@ static int ohci_bus_suspend (struct usb_hcd *hcd)
 	hcd-&gt;poll_rh = 0;
 
 done:
-	/* external suspend vs self autosuspend ... same effect */
-	if (status == 0)
-		usb_hcd_suspend_root_hub(hcd);
 	spin_unlock_irqrestore (&amp;ohci-&gt;lock, flags);
 	return status;
 }</pre><hr><pre>commit 01d883d44a1ca8dc77486635d428cba63e7fdadf
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 30 15:47:18 2006 -0400

    usbcore: non-hub-specific uses of autosuspend
    
    This patch (as741) makes the non-hub parts of usbcore actually use the
    autosuspend facilities added by an earlier patch.
    
            Devices opened through usbfs are autoresumed and then
            autosuspended upon close.
    
            Likewise for usb-skeleton.
    
            Devices are autoresumed for usb_set_configuration.
    
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 43c08724a2d8..fd345ad810f8 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -558,10 +558,12 @@ static int usbdev_open(struct inode *inode, struct file *file)
 		dev = usbdev_lookup_minor(iminor(inode));
 	if (!dev)
 		dev = inode-&gt;i_private;
-	if (!dev) {
-		kfree(ps);
+	if (!dev)
 		goto out;
-	}
+	ret = usb_autoresume_device(dev, 1);
+	if (ret)
+		goto out;
+
 	usb_get_dev(dev);
 	ret = 0;
 	ps-&gt;dev = dev;
@@ -581,6 +583,8 @@ static int usbdev_open(struct inode *inode, struct file *file)
 	list_add_tail(&amp;ps-&gt;list, &amp;dev-&gt;filelist);
 	file-&gt;private_data = ps;
  out:
+	if (ret)
+		kfree(ps);
 	mutex_unlock(&amp;usbfs_mutex);
 	return ret;
 }
@@ -604,6 +608,7 @@ static int usbdev_release(struct inode *inode, struct file *file)
 			releaseintf(ps, ifnum);
 	}
 	destroy_all_async(ps);
+	usb_autosuspend_device(dev, 1);
 	usb_unlock_device(dev);
 	usb_put_dev(dev);
 	kfree(ps);
diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index 5358e656477c..16332cc57946 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -172,14 +172,10 @@ static void generic_disconnect(struct usb_device *udev)
 
 	/* if this is only an unbind, not a physical disconnect, then
 	 * unconfigure the device */
-	if (udev-&gt;state == USB_STATE_CONFIGURED)
+	if (udev-&gt;actconfig)
 		usb_set_configuration(udev, 0);
 
 	usb_remove_sysfs_dev_files(udev);
-
-	/* in case the call failed or the device was suspended */
-	if (udev-&gt;state &gt;= USB_STATE_CONFIGURED)
-		usb_disable_device(udev, 0);
 }
 
 #ifdef	CONFIG_PM
@@ -208,4 +204,5 @@ struct usb_device_driver usb_generic_driver = {
 	.suspend = generic_suspend,
 	.resume = generic_resume,
 #endif
+	.supports_autosuspend = 1,
 };
diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 1580c81a0db7..28c6cf225780 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1366,9 +1366,6 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 	if (cp &amp;&amp; configuration == 0)
 		dev_warn(&amp;dev-&gt;dev, "config 0 descriptor??\n");
 
-	if (dev-&gt;state == USB_STATE_SUSPENDED)
-		return -EHOSTUNREACH;
-
 	/* Allocate memory for new interfaces before doing anything else,
 	 * so that if we run out then nothing will have changed. */
 	n = nintf = 0;
@@ -1403,6 +1400,11 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 					configuration, -i);
 	}
 
+	/* Wake up the device so we can send it the Set-Config request */
+	ret = usb_autoresume_device(dev, 1);
+	if (ret)
+		goto free_interfaces;
+
 	/* if it's already configured, clear out old state first.
 	 * getting rid of old interfaces means unbinding their drivers.
 	 */
@@ -1422,6 +1424,7 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 	dev-&gt;actconfig = cp;
 	if (!cp) {
 		usb_set_device_state(dev, USB_STATE_ADDRESS);
+		usb_autosuspend_device(dev, 1);
 		goto free_interfaces;
 	}
 	usb_set_device_state(dev, USB_STATE_CONFIGURED);
@@ -1490,6 +1493,7 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 		usb_create_sysfs_intf_files (intf);
 	}
 
+	usb_autosuspend_device(dev, 1);
 	return 0;
 }
 
diff --git a/drivers/usb/usb-skeleton.c b/drivers/usb/usb-skeleton.c
index 9b542a6ba978..1b51d3187a95 100644
--- a/drivers/usb/usb-skeleton.c
+++ b/drivers/usb/usb-skeleton.c
@@ -90,6 +90,11 @@ static int skel_open(struct inode *inode, struct file *file)
 		goto exit;
 	}
 
+	/* prevent the device from being autosuspended */
+	retval = usb_autopm_get_interface(interface);
+	if (retval)
+		goto exit;
+
 	/* increment our usage count for the device */
 	kref_get(&amp;dev-&gt;kref);
 
@@ -108,6 +113,12 @@ static int skel_release(struct inode *inode, struct file *file)
 	if (dev == NULL)
 		return -ENODEV;
 
+	/* allow the device to be autosuspended */
+	mutex_lock(&amp;dev-&gt;io_mutex);
+	if (dev-&gt;interface)
+		usb_autopm_put_interface(dev-&gt;interface);
+	mutex_unlock(&amp;dev-&gt;io_mutex);
+
 	/* decrement the count on our device */
 	kref_put(&amp;dev-&gt;kref, skel_delete);
 	return 0;</pre><hr><pre>commit 645daaab0b6adc35c1838df2a82f9d729fdb1767
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 30 15:47:02 2006 -0400

    usbcore: add autosuspend/autoresume infrastructure
    
    This patch (as739) adds the basic infrastructure for USB autosuspend
    and autoresume.  The main features are:
    
            PM usage counters added to struct usb_device and struct
            usb_interface, indicating whether it's okay to autosuspend
            them or they are currently in use.
    
            Flag added to usb_device indicating whether the current
            suspend/resume operation originated from outside or as an
            autosuspend/autoresume.
    
            Flag added to usb_driver indicating whether the driver
            supports autosuspend.  If not, no device bound to the driver
            will be autosuspended.
    
            Mutex added to usb_device for protecting PM operations.
            Unlike the device semaphore, the locking rule for the pm_mutex
            is that you must acquire the locks going _up_ the device tree.
    
            New routines handling autosuspend/autoresume requests for
            interfaces and devices.
    
            Suspend and resume requests are propagated up the device tree
            (but not outside the USB subsystem).
    
            work_struct added to usb_device, for carrying out delayed
            autosuspend requests.
    
            Autoresume added (and autosuspend prevented) during probe and
            disconnect.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index a5d11461f5a9..2b2000ac05ab 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -157,12 +157,13 @@ static int usb_probe_device(struct device *dev)
 
 	udev = to_usb_device(dev);
 
-	/* FIXME: resume a suspended device */
-	if (udev-&gt;state == USB_STATE_SUSPENDED)
-		return -EHOSTUNREACH;
-
 	/* TODO: Add real matching code */
 
+	/* The device should always appear to be in use
+	 * unless the driver suports autosuspend.
+	 */
+	udev-&gt;pm_usage_cnt = !(udriver-&gt;supports_autosuspend);
+
 	error = udriver-&gt;probe(udev);
 	return error;
 }
@@ -182,6 +183,7 @@ static int usb_probe_interface(struct device *dev)
 {
 	struct usb_driver *driver = to_usb_driver(dev-&gt;driver);
 	struct usb_interface *intf;
+	struct usb_device *udev;
 	const struct usb_device_id *id;
 	int error = -ENODEV;
 
@@ -191,10 +193,7 @@ static int usb_probe_interface(struct device *dev)
 		return error;
 
 	intf = to_usb_interface(dev);
-
-	/* FIXME we'd much prefer to just resume it ... */
-	if (interface_to_usbdev(intf)-&gt;state == USB_STATE_SUSPENDED)
-		return -EHOSTUNREACH;
+	udev = interface_to_usbdev(intf);
 
 	id = usb_match_id(intf, driver-&gt;id_table);
 	if (!id)
@@ -202,18 +201,31 @@ static int usb_probe_interface(struct device *dev)
 	if (id) {
 		dev_dbg(dev, "%s - got id\n", __FUNCTION__);
 
+		error = usb_autoresume_device(udev, 1);
+		if (error)
+			return error;
+
 		/* Interface "power state" doesn't correspond to any hardware
 		 * state whatsoever.  We use it to record when it's bound to
 		 * a driver that may start I/0:  it's not frozen/quiesced.
 		 */
 		mark_active(intf);
 		intf-&gt;condition = USB_INTERFACE_BINDING;
+
+		/* The interface should always appear to be in use
+		 * unless the driver suports autosuspend.
+		 */
+		intf-&gt;pm_usage_cnt = !(driver-&gt;supports_autosuspend);
+
 		error = driver-&gt;probe(intf, id);
 		if (error) {
 			mark_quiesced(intf);
+			intf-&gt;needs_remote_wakeup = 0;
 			intf-&gt;condition = USB_INTERFACE_UNBOUND;
 		} else
 			intf-&gt;condition = USB_INTERFACE_BOUND;
+
+		usb_autosuspend_device(udev, 1);
 	}
 
 	return error;
@@ -224,9 +236,15 @@ static int usb_unbind_interface(struct device *dev)
 {
 	struct usb_driver *driver = to_usb_driver(dev-&gt;driver);
 	struct usb_interface *intf = to_usb_interface(dev);
+	struct usb_device *udev;
+	int error;
 
 	intf-&gt;condition = USB_INTERFACE_UNBINDING;
 
+	/* Autoresume for set_interface call below */
+	udev = interface_to_usbdev(intf);
+	error = usb_autoresume_device(udev, 1);
+
 	/* release all urbs for this interface */
 	usb_disable_interface(interface_to_usbdev(intf), intf);
 
@@ -237,8 +255,13 @@ static int usb_unbind_interface(struct device *dev)
 			intf-&gt;altsetting[0].desc.bInterfaceNumber,
 			0);
 	usb_set_intfdata(intf, NULL);
+
 	intf-&gt;condition = USB_INTERFACE_UNBOUND;
 	mark_quiesced(intf);
+	intf-&gt;needs_remote_wakeup = 0;
+
+	if (!error)
+		usb_autosuspend_device(udev, 1);
 
 	return 0;
 }
@@ -267,14 +290,19 @@ int usb_driver_claim_interface(struct usb_driver *driver,
 				struct usb_interface *iface, void* priv)
 {
 	struct device *dev = &amp;iface-&gt;dev;
+	struct usb_device *udev = interface_to_usbdev(iface);
 
 	if (dev-&gt;driver)
 		return -EBUSY;
 
 	dev-&gt;driver = &amp;driver-&gt;drvwrap.driver;
 	usb_set_intfdata(iface, priv);
+
+	mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
 	iface-&gt;condition = USB_INTERFACE_BOUND;
 	mark_active(iface);
+	iface-&gt;pm_usage_cnt = !(driver-&gt;supports_autosuspend);
+	mutex_unlock(&amp;udev-&gt;pm_mutex);
 
 	/* if interface was already added, bind now; else let
 	 * the future device_add() bind it, bypassing probe()
@@ -304,6 +332,7 @@ void usb_driver_release_interface(struct usb_driver *driver,
 					struct usb_interface *iface)
 {
 	struct device *dev = &amp;iface-&gt;dev;
+	struct usb_device *udev = interface_to_usbdev(iface);
 
 	/* this should never happen, don't release something that's not ours */
 	if (!dev-&gt;driver || dev-&gt;driver != &amp;driver-&gt;drvwrap.driver)
@@ -321,8 +350,12 @@ void usb_driver_release_interface(struct usb_driver *driver,
 
 	dev-&gt;driver = NULL;
 	usb_set_intfdata(iface, NULL);
+
+	mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
 	iface-&gt;condition = USB_INTERFACE_UNBOUND;
 	mark_quiesced(iface);
+	iface-&gt;needs_remote_wakeup = 0;
+	mutex_unlock(&amp;udev-&gt;pm_mutex);
 }
 EXPORT_SYMBOL(usb_driver_release_interface);
 
@@ -751,7 +784,7 @@ EXPORT_SYMBOL_GPL_FUTURE(usb_deregister);
 
 #ifdef CONFIG_PM
 
-/* Caller has locked udev */
+/* Caller has locked udev-&gt;pm_mutex */
 static int suspend_device(struct usb_device *udev, pm_message_t msg)
 {
 	struct usb_device_driver	*udriver;
@@ -763,6 +796,7 @@ static int suspend_device(struct usb_device *udev, pm_message_t msg)
 
 	/* For devices that don't have a driver, we do a standard suspend. */
 	if (udev-&gt;dev.driver == NULL) {
+		udev-&gt;do_remote_wakeup = 0;
 		status = usb_port_suspend(udev);
 		goto done;
 	}
@@ -771,12 +805,13 @@ static int suspend_device(struct usb_device *udev, pm_message_t msg)
 	status = udriver-&gt;suspend(udev, msg);
 
 done:
+	// dev_dbg(&amp;udev-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
 	if (status == 0)
 		udev-&gt;dev.power.power_state.event = msg.event;
 	return status;
 }
 
-/* Caller has locked udev */
+/* Caller has locked udev-&gt;pm_mutex */
 static int resume_device(struct usb_device *udev)
 {
 	struct usb_device_driver	*udriver;
@@ -796,12 +831,13 @@ static int resume_device(struct usb_device *udev)
 	status = udriver-&gt;resume(udev);
 
 done:
+	// dev_dbg(&amp;udev-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
 	if (status == 0)
 		udev-&gt;dev.power.power_state.event = PM_EVENT_ON;
 	return status;
 }
 
-/* Caller has locked intf's usb_device */
+/* Caller has locked intf's usb_device's pm_mutex */
 static int suspend_interface(struct usb_interface *intf, pm_message_t msg)
 {
 	struct usb_driver	*driver;
@@ -812,31 +848,33 @@ static int suspend_interface(struct usb_interface *intf, pm_message_t msg)
 			!is_active(intf))
 		goto done;
 
-	if (intf-&gt;dev.driver == NULL)		/* This can't happen */
+	if (intf-&gt;condition == USB_INTERFACE_UNBOUND)	/* This can't happen */
 		goto done;
 	driver = to_usb_driver(intf-&gt;dev.driver);
 
 	if (driver-&gt;suspend &amp;&amp; driver-&gt;resume) {
 		status = driver-&gt;suspend(intf, msg);
-		if (status)
+		if (status == 0)
+			mark_quiesced(intf);
+		else if (!interface_to_usbdev(intf)-&gt;auto_pm)
 			dev_err(&amp;intf-&gt;dev, "%s error %d\n",
 					"suspend", status);
-		else
-			mark_quiesced(intf);
 	} else {
 		// FIXME else if there's no suspend method, disconnect...
+		// Not possible if auto_pm is set...
 		dev_warn(&amp;intf-&gt;dev, "no suspend for driver %s?\n",
 				driver-&gt;name);
 		mark_quiesced(intf);
 	}
 
 done:
+	// dev_dbg(&amp;intf-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
 	if (status == 0)
 		intf-&gt;dev.power.power_state.event = msg.event;
 	return status;
 }
 
-/* Caller has locked intf's usb_device */
+/* Caller has locked intf's usb_device's pm_mutex */
 static int resume_interface(struct usb_interface *intf)
 {
 	struct usb_driver	*driver;
@@ -846,8 +884,12 @@ static int resume_interface(struct usb_interface *intf)
 			is_active(intf))
 		goto done;
 
+	/* Don't let autoresume interfere with unbinding */
+	if (intf-&gt;condition == USB_INTERFACE_UNBINDING)
+		goto done;
+
 	/* Can't resume it if it doesn't have a driver. */
-	if (intf-&gt;dev.driver == NULL) {
+	if (intf-&gt;condition == USB_INTERFACE_UNBOUND) {
 		status = -ENOTCONN;
 		goto done;
 	}
@@ -867,18 +909,88 @@ static int resume_interface(struct usb_interface *intf)
 	}
 
 done:
+	// dev_dbg(&amp;intf-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
 	if (status == 0)
 		intf-&gt;dev.power.power_state.event = PM_EVENT_ON;
 	return status;
 }
 
-/* Caller has locked udev */
+/**
+ * usb_suspend_both - suspend a USB device and its interfaces
+ * @udev: the usb_device to suspend
+ * @msg: Power Management message describing this state transition
+ *
+ * This is the central routine for suspending USB devices.  It calls the
+ * suspend methods for all the interface drivers in @udev and then calls
+ * the suspend method for @udev itself.  If an error occurs at any stage,
+ * all the interfaces which were suspended are resumed so that they remain
+ * in the same state as the device.
+ *
+ * If an autosuspend is in progress (@udev-&gt;auto_pm is set), the routine
+ * checks first to make sure that neither the device itself or any of its
+ * active interfaces is in use (pm_usage_cnt is greater than 0).  If they
+ * are, the autosuspend fails.
+ *
+ * If the suspend succeeds, the routine recursively queues an autosuspend
+ * request for @udev's parent device, thereby propagating the change up
+ * the device tree.  If all of the parent's children are now suspended,
+ * the parent will autosuspend in turn.
+ *
+ * The suspend method calls are subject to mutual exclusion under control
+ * of @udev's pm_mutex.  Many of these calls are also under the protection
+ * of @udev's device lock (including all requests originating outside the
+ * USB subsystem), but autosuspend requests generated by a child device or
+ * interface driver may not be.  Usbcore will insure that the method calls
+ * do not arrive during bind, unbind, or reset operations.  However, drivers
+ * must be prepared to handle suspend calls arriving at unpredictable times.
+ * The only way to block such calls is to do an autoresume (preventing
+ * autosuspends) while holding @udev's device lock (preventing outside
+ * suspends).
+ *
+ * The caller must hold @udev-&gt;pm_mutex.
+ *
+ * This routine can run only in process context.
+ */
 int usb_suspend_both(struct usb_device *udev, pm_message_t msg)
 {
 	int			status = 0;
 	int			i = 0;
 	struct usb_interface	*intf;
+	struct usb_device	*parent = udev-&gt;parent;
+
+	cancel_delayed_work(&amp;udev-&gt;autosuspend);
+	if (udev-&gt;state == USB_STATE_NOTATTACHED)
+		return 0;
+	if (udev-&gt;state == USB_STATE_SUSPENDED)
+		return 0;
 
+	udev-&gt;do_remote_wakeup = device_may_wakeup(&amp;udev-&gt;dev);
+
+	/* For autosuspend, fail fast if anything is in use.
+	 * Also fail if any interfaces require remote wakeup but it
+	 * isn't available. */
+	if (udev-&gt;auto_pm) {
+		if (udev-&gt;pm_usage_cnt &gt; 0)
+			return -EBUSY;
+		if (udev-&gt;actconfig) {
+			for (; i &lt; udev-&gt;actconfig-&gt;desc.bNumInterfaces; i++) {
+				intf = udev-&gt;actconfig-&gt;interface[i];
+				if (!is_active(intf))
+					continue;
+				if (intf-&gt;pm_usage_cnt &gt; 0)
+					return -EBUSY;
+				if (intf-&gt;needs_remote_wakeup &amp;&amp;
+						!udev-&gt;do_remote_wakeup) {
+					dev_dbg(&amp;udev-&gt;dev,
+	"remote wakeup needed for autosuspend\n");
+					return -EOPNOTSUPP;
+				}
+			}
+			i = 0;
+		}
+	}
+
+	/* Suspend all the interfaces and then udev itself */
 	if (udev-&gt;actconfig) {
 		for (; i &lt; udev-&gt;actconfig-&gt;desc.bNumInterfaces; i++) {
 			intf = udev-&gt;actconfig-&gt;interface[i];
@@ -896,40 +1008,282 @@ int usb_suspend_both(struct usb_device *udev, pm_message_t msg)
 			intf = udev-&gt;actconfig-&gt;interface[i];
 			resume_interface(intf);
 		}
-	}
+
+	/* If the suspend succeeded, propagate it up the tree */
+	} else if (parent)
+		usb_autosuspend_device(parent, 0);
+
+	// dev_dbg(&amp;udev-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
 	return status;
 }
 
-/* Caller has locked udev */
+/**
+ * usb_resume_both - resume a USB device and its interfaces
+ * @udev: the usb_device to resume
+ *
+ * This is the central routine for resuming USB devices.  It calls the
+ * the resume method for @udev and then calls the resume methods for all
+ * the interface drivers in @udev.
+ *
+ * Before starting the resume, the routine calls itself recursively for
+ * the parent device of @udev, thereby propagating the change up the device
+ * tree and assuring that @udev will be able to resume.  If the parent is
+ * unable to resume successfully, the routine fails.
+ *
+ * The resume method calls are subject to mutual exclusion under control
+ * of @udev's pm_mutex.  Many of these calls are also under the protection
+ * of @udev's device lock (including all requests originating outside the
+ * USB subsystem), but autoresume requests generated by a child device or
+ * interface driver may not be.  Usbcore will insure that the method calls
+ * do not arrive during bind, unbind, or reset operations.  However, drivers
+ * must be prepared to handle resume calls arriving at unpredictable times.
+ * The only way to block such calls is to do an autoresume (preventing
+ * other autoresumes) while holding @udev's device lock (preventing outside
+ * resumes).
+ *
+ * The caller must hold @udev-&gt;pm_mutex.
+ *
+ * This routine can run only in process context.
+ */
 int usb_resume_both(struct usb_device *udev)
 {
-	int			status;
+	int			status = 0;
 	int			i;
 	struct usb_interface	*intf;
+	struct usb_device	*parent = udev-&gt;parent;
+
+	cancel_delayed_work(&amp;udev-&gt;autosuspend);
+	if (udev-&gt;state == USB_STATE_NOTATTACHED)
+		return -ENODEV;
 
-	/* Can't resume if the parent is suspended */
-	if (udev-&gt;parent &amp;&amp; udev-&gt;parent-&gt;state == USB_STATE_SUSPENDED) {
-		dev_warn(&amp;udev-&gt;dev, "can't resume; parent is suspended\n");
-		return -EHOSTUNREACH;
+	/* Propagate the resume up the tree, if necessary */
+	if (udev-&gt;state == USB_STATE_SUSPENDED) {
+		if (parent) {
+			mutex_lock_nested(&amp;parent-&gt;pm_mutex, parent-&gt;level);
+			parent-&gt;auto_pm = 1;
+			status = usb_resume_both(parent);
+		} else {
+
+			/* We can't progagate beyond the USB subsystem,
+			 * so if a root hub's controller is suspended
+			 * then we're stuck. */
+			if (udev-&gt;dev.parent-&gt;power.power_state.event !=
+					PM_EVENT_ON)
+				status = -EHOSTUNREACH;
+		}
+		if (status == 0 &amp;&amp; udev-&gt;state == USB_STATE_SUSPENDED)
+			status = resume_device(udev);
+		if (parent)
+			mutex_unlock(&amp;parent-&gt;pm_mutex);
 	}
 
-	status = resume_device(udev);
+	/* Now the parent won't suspend until we are finished */
+
 	if (status == 0 &amp;&amp; udev-&gt;actconfig) {
 		for (i = 0; i &lt; udev-&gt;actconfig-&gt;desc.bNumInterfaces; i++) {
 			intf = udev-&gt;actconfig-&gt;interface[i];
 			resume_interface(intf);
 		}
 	}
+
+	// dev_dbg(&amp;udev-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
+	return status;
+}
+
+#ifdef CONFIG_USB_SUSPEND
+
+/**
+ * usb_autosuspend_device - delayed autosuspend of a USB device and its interfaces
+ * @udev - the usb_device to autosuspend
+ * @dec_usage_cnt - flag to decrement @udev's PM-usage counter
+ *
+ * This routine should be called when a core subsystem is finished using
+ * @udev and wants to allow it to autosuspend.  Examples would be when
+ * @udev's device file in usbfs is closed or after a configuration change.
+ *
+ * @dec_usage_cnt should be 1 if the subsystem previously incremented
+ * @udev's usage counter (such as by passing 1 to usb_autoresume_device);
+ * otherwise it should be 0.
+ *
+ * If the usage counter for @udev or any of its active interfaces is greater
+ * than 0, the autosuspend request will not be queued.  (If an interface
+ * driver does not support autosuspend then its usage counter is permanently
+ * positive.)  Likewise, if an interface driver requires remote-wakeup
+ * capability during autosuspend but remote wakeup is disabled, the
+ * autosuspend will fail.
+ *
+ * Often the caller will hold @udev's device lock, but this is not
+ * necessary.
+ *
+ * This routine can run only in process context.
+ */
+void usb_autosuspend_device(struct usb_device *udev, int dec_usage_cnt)
+{
+	mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
+	udev-&gt;pm_usage_cnt -= dec_usage_cnt;
+	if (udev-&gt;pm_usage_cnt &lt;= 0)
+		schedule_delayed_work(&amp;udev-&gt;autosuspend,
+				USB_AUTOSUSPEND_DELAY);
+	mutex_unlock(&amp;udev-&gt;pm_mutex);
+	// dev_dbg(&amp;udev-&gt;dev, "%s: cnt %d\n",
+	//		__FUNCTION__, udev-&gt;pm_usage_cnt);
+}
+
+/**
+ * usb_autoresume_device - immediately autoresume a USB device and its interfaces
+ * @udev - the usb_device to autoresume
+ * @inc_usage_cnt - flag to increment @udev's PM-usage counter
+ *
+ * This routine should be called when a core subsystem wants to use @udev
+ * and needs to guarantee that it is not suspended.  In addition, the
+ * caller can prevent @udev from being autosuspended subsequently.  (Note
+ * that this will not prevent suspend events originating in the PM core.)
+ * Examples would be when @udev's device file in usbfs is opened (autosuspend
+ * should be prevented until the file is closed) or when a remote-wakeup
+ * request is received (later autosuspends should not be prevented).
+ *
+ * @inc_usage_cnt should be 1 to increment @udev's usage counter and prevent
+ * autosuspends.  This prevention will persist until the usage counter is
+ * decremented again (such as by passing 1 to usb_autosuspend_device).
+ * Otherwise @inc_usage_cnt should be 0 to leave the usage counter unchanged.
+ * Regardless, if the autoresume fails then the usage counter is not
+ * incremented.
+ *
+ * Often the caller will hold @udev's device lock, but this is not
+ * necessary (and attempting it might cause deadlock).
+ *
+ * This routine can run only in process context.
+ */
+int usb_autoresume_device(struct usb_device *udev, int inc_usage_cnt)
+{
+	int	status;
+
+	mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
+	udev-&gt;pm_usage_cnt += inc_usage_cnt;
+	udev-&gt;auto_pm = 1;
+	status = usb_resume_both(udev);
+	if (status != 0)
+		udev-&gt;pm_usage_cnt -= inc_usage_cnt;
+	mutex_unlock(&amp;udev-&gt;pm_mutex);
+	// dev_dbg(&amp;udev-&gt;dev, "%s: status %d cnt %d\n",
+	//		__FUNCTION__, status, udev-&gt;pm_usage_cnt);
+	return status;
+}
+
+/**
+ * usb_autopm_put_interface - decrement a USB interface's PM-usage counter
+ * @intf - the usb_interface whose counter should be decremented
+ *
+ * This routine should be called by an interface driver when it is
+ * finished using @intf and wants to allow it to autosuspend.  A typical
+ * example would be a character-device driver when its device file is
+ * closed.
+ *
+ * The routine decrements @intf's usage counter.  When the counter reaches
+ * 0, a delayed autosuspend request for @intf's device is queued.  When
+ * the delay expires, if @intf-&gt;pm_usage_cnt is still &lt;= 0 along with all
+ * the other usage counters for the sibling interfaces and @intf's
+ * usb_device, the device and all its interfaces will be autosuspended.
+ *
+ * Note that @intf-&gt;pm_usage_cnt is owned by the interface driver.  The
+ * core will not change its value other than the increment and decrement
+ * in usb_autopm_get_interface and usb_autopm_put_interface.  The driver
+ * may use this simple counter-oriented discipline or may set the value
+ * any way it likes.
+ *
+ * If the driver has set @intf-&gt;needs_remote_wakeup then autosuspend will
+ * take place only if the device's remote-wakeup facility is enabled.
+ *
+ * Suspend method calls queued by this routine can arrive at any time
+ * while @intf is resumed and its usage counter is equal to 0.  They are
+ * not protected by the usb_device's lock but only by its pm_mutex.
+ * Drivers must provide their own synchronization.
+ *
+ * This routine can run only in process context.
+ */
+void usb_autopm_put_interface(struct usb_interface *intf)
+{
+	struct usb_device	*udev = interface_to_usbdev(intf);
+
+	mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
+	if (intf-&gt;condition != USB_INTERFACE_UNBOUND) {
+		if (--intf-&gt;pm_usage_cnt &lt;= 0)
+			schedule_delayed_work(&amp;udev-&gt;autosuspend,
+					USB_AUTOSUSPEND_DELAY);
+	}
+	mutex_unlock(&amp;udev-&gt;pm_mutex);
+	// dev_dbg(&amp;intf-&gt;dev, "%s: cnt %d\n",
+	//		__FUNCTION__, intf-&gt;pm_usage_cnt);
+}
+EXPORT_SYMBOL_GPL(usb_autopm_put_interface);
+
+/**
+ * usb_autopm_get_interface - increment a USB interface's PM-usage counter
+ * @intf - the usb_interface whose counter should be incremented
+ *
+ * This routine should be called by an interface driver when it wants to
+ * use @intf and needs to guarantee that it is not suspended.  In addition,
+ * the routine prevents @intf from being autosuspended subsequently.  (Note
+ * that this will not prevent suspend events originating in the PM core.)
+ * This prevention will persist until usb_autopm_put_interface() is called
+ * or @intf is unbound.  A typical example would be a character-device
+ * driver when its device file is opened.
+ *
+ * The routine increments @intf's usage counter.  So long as the counter
+ * is greater than 0, autosuspend will not be allowed for @intf or its
+ * usb_device.  When the driver is finished using @intf it should call
+ * usb_autopm_put_interface() to decrement the usage counter and queue
+ * a delayed autosuspend request (if the counter is &lt;= 0).
+ *
+ * Note that @intf-&gt;pm_usage_cnt is owned by the interface driver.  The
+ * core will not change its value other than the increment and decrement
+ * in usb_autopm_get_interface and usb_autopm_put_interface.  The driver
+ * may use this simple counter-oriented discipline or may set the value
+ * any way it likes.
+ *
+ * Resume method calls generated by this routine can arrive at any time
+ * while @intf is suspended.  They are not protected by the usb_device's
+ * lock but only by its pm_mutex.  Drivers must provide their own
+ * synchronization.
+ *
+ * This routine can run only in process context.
+ */
+int usb_autopm_get_interface(struct usb_interface *intf)
+{
+	struct usb_device	*udev = interface_to_usbdev(intf);
+	int			status;
+
+	mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
+	if (intf-&gt;condition == USB_INTERFACE_UNBOUND)
+		status = -ENODEV;
+	else {
+		++intf-&gt;pm_usage_cnt;
+		udev-&gt;auto_pm = 1;
+		status = usb_resume_both(udev);
+		if (status != 0)
+			--intf-&gt;pm_usage_cnt;
+	}
+	mutex_unlock(&amp;udev-&gt;pm_mutex);
+	// dev_dbg(&amp;intf-&gt;dev, "%s: status %d cnt %d\n",
+	//		__FUNCTION__, status, intf-&gt;pm_usage_cnt);
 	return status;
 }
+EXPORT_SYMBOL_GPL(usb_autopm_get_interface);
+
+#endif /* CONFIG_USB_SUSPEND */
 
 static int usb_suspend(struct device *dev, pm_message_t message)
 {
 	int	status;
 
-	if (is_usb_device(dev))
-		status = usb_suspend_both(to_usb_device(dev), message);
-	else
+	if (is_usb_device(dev)) {
+		struct usb_device *udev = to_usb_device(dev);
+
+		mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
+		udev-&gt;auto_pm = 0;
+		status = usb_suspend_both(udev, message);
+		mutex_unlock(&amp;udev-&gt;pm_mutex);
+	} else
 		status = 0;
 	return status;
 }
@@ -939,7 +1293,12 @@ static int usb_resume(struct device *dev)
 	int	status;
 
 	if (is_usb_device(dev)) {
-		status = usb_resume_both(to_usb_device(dev));
+		struct usb_device *udev = to_usb_device(dev);
+
+		mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
+		udev-&gt;auto_pm = 0;
+		status = usb_resume_both(udev);
+		mutex_unlock(&amp;udev-&gt;pm_mutex);
 
 		/* Rebind drivers that had no suspend method? */
 	} else
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 78e910b2046c..dee812bc6c43 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1017,19 +1017,22 @@ void usb_set_device_state(struct usb_device *udev,
 	if (udev-&gt;state == USB_STATE_NOTATTACHED)
 		;	/* do nothing */
 	else if (new_state != USB_STATE_NOTATTACHED) {
-		udev-&gt;state = new_state;
 
 		/* root hub wakeup capabilities are managed out-of-band
 		 * and may involve silicon errata ... ignore them here.
 		 */
 		if (udev-&gt;parent) {
-			if (new_state == USB_STATE_CONFIGURED)
+			if (udev-&gt;state == USB_STATE_SUSPENDED
+					|| new_state == USB_STATE_SUSPENDED)
+				;	/* No change to wakeup settings */
+			else if (new_state == USB_STATE_CONFIGURED)
 				device_init_wakeup(&amp;udev-&gt;dev,
 					(udev-&gt;actconfig-&gt;desc.bmAttributes
 					 &amp; USB_CONFIG_ATT_WAKEUP));
-			else if (new_state != USB_STATE_SUSPENDED)
+			else
 				device_init_wakeup(&amp;udev-&gt;dev, 0);
 		}
+		udev-&gt;state = new_state;
 	} else
 		recursively_mark_NOTATTACHED(udev);
 	spin_unlock_irqrestore(&amp;device_state_lock, flags);
@@ -1507,7 +1510,7 @@ static int hub_port_suspend(struct usb_hub *hub, int port1,
 	 * NOTE:  OTG devices may issue remote wakeup (or SRP) even when
 	 * we don't explicitly enable it here.
 	 */
-	if (device_may_wakeup(&amp;udev-&gt;dev)) {
+	if (udev-&gt;do_remote_wakeup) {
 		status = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
 				USB_REQ_SET_FEATURE, USB_RECIP_DEVICE,
 				USB_DEVICE_REMOTE_WAKEUP, 0,
@@ -1533,7 +1536,8 @@ static int hub_port_suspend(struct usb_hub *hub, int port1,
 				USB_CTRL_SET_TIMEOUT);
 	} else {
 		/* device has up to 10 msec to fully suspend */
-		dev_dbg(&amp;udev-&gt;dev, "usb suspend\n");
+		dev_dbg(&amp;udev-&gt;dev, "usb %ssuspend\n",
+				udev-&gt;auto_pm ? "auto-" : "");
 		usb_set_device_state(udev, USB_STATE_SUSPENDED);
 		msleep(10);
 	}
@@ -1573,7 +1577,8 @@ static int __usb_port_suspend (struct usb_device *udev, int port1)
 		status = hub_port_suspend(hdev_to_hub(udev-&gt;parent), port1,
 				udev);
 	else {
-		dev_dbg(&amp;udev-&gt;dev, "usb suspend\n");
+		dev_dbg(&amp;udev-&gt;dev, "usb %ssuspend\n",
+				udev-&gt;auto_pm ? "auto-" : "");
 		usb_set_device_state(udev, USB_STATE_SUSPENDED);
 	}
 	return status;
@@ -1687,7 +1692,8 @@ hub_port_resume(struct usb_hub *hub, int port1, struct usb_device *udev)
 
 		/* drive resume for at least 20 msec */
 		if (udev)
-			dev_dbg(&amp;udev-&gt;dev, "RESUME\n");
+			dev_dbg(&amp;udev-&gt;dev, "usb %sresume\n",
+					udev-&gt;auto_pm ? "auto-" : "");
 		msleep(25);
 
 #define LIVE_FLAGS	( USB_PORT_STAT_POWER \
@@ -1754,8 +1760,11 @@ int usb_port_resume(struct usb_device *udev)
 		// NOTE this fails if parent is also suspended...
 		status = hub_port_resume(hdev_to_hub(udev-&gt;parent),
 				udev-&gt;portnum, udev);
-	} else
+	} else {
+		dev_dbg(&amp;udev-&gt;dev, "usb %sresume\n",
+				udev-&gt;auto_pm ? "auto-" : "");
 		status = finish_port_resume(udev);
+	}
 	if (status &lt; 0)
 		dev_dbg(&amp;udev-&gt;dev, "can't resume, status %d\n", status);
 	return status;
@@ -1765,19 +1774,23 @@ static int remote_wakeup(struct usb_device *udev)
 {
 	int	status = 0;
 
-	/* don't repeat RESUME sequence if this device
-	 * was already woken up by some other task
-	 */
+	/* All this just to avoid sending a port-resume message
+	 * to the parent hub! */
+
 	usb_lock_device(udev);
+	mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
 	if (udev-&gt;state == USB_STATE_SUSPENDED) {
-		dev_dbg(&amp;udev-&gt;dev, "RESUME (wakeup)\n");
+		dev_dbg(&amp;udev-&gt;dev, "usb %sresume\n", "wakeup-");
 		/* TRSMRCY = 10 msec */
 		msleep(10);
 		status = finish_port_resume(udev);
+		if (status == 0)
+			udev-&gt;dev.power.power_state.event = PM_EVENT_ON;
 	}
+	mutex_unlock(&amp;udev-&gt;pm_mutex);
 
 	if (status == 0)
-		usb_resume_both(udev);
+		usb_autoresume_device(udev, 0);
 	usb_unlock_device(udev);
 	return status;
 }
@@ -1834,7 +1847,9 @@ static int hub_suspend(struct usb_interface *intf, pm_message_t msg)
 					== PM_EVENT_ON
 #endif
 				) {
-			dev_dbg(&amp;intf-&gt;dev, "port %d nyet suspended\n", port1);
+			if (!hdev-&gt;auto_pm)
+				dev_dbg(&amp;intf-&gt;dev, "port %d nyet suspended\n",
+						port1);
 			return -EBUSY;
 		}
 	}
@@ -2587,7 +2602,7 @@ static void hub_events(void)
 		 * stub "device" node was never suspended.
 		 */
 		if (i)
-			usb_resume_both(hdev);
+			usb_autoresume_device(hdev, 0);
 
 		/* If this is an inactive or suspended hub, do nothing */
 		if (hub-&gt;quiescing)
@@ -2993,6 +3008,9 @@ int usb_reset_composite_device(struct usb_device *udev,
 		return -EINVAL;
 	}
 
+	/* Prevent autosuspend during the reset */
+	usb_autoresume_device(udev, 1);
+
 	if (iface &amp;&amp; iface-&gt;condition != USB_INTERFACE_BINDING)
 		iface = NULL;
 
@@ -3034,6 +3052,7 @@ int usb_reset_composite_device(struct usb_device *udev,
 		}
 	}
 
+	usb_autosuspend_device(udev, 1);
 	return ret;
 }
 EXPORT_SYMBOL(usb_reset_composite_device);
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index b0c0a993338f..6b029cdb8671 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -168,6 +168,10 @@ static void usb_release_dev(struct device *dev)
 
 	udev = to_usb_device(dev);
 
+#ifdef	CONFIG_PM
+	cancel_delayed_work(&amp;udev-&gt;autosuspend);
+	flush_scheduled_work();
+#endif
 	usb_destroy_configuration(udev);
 	usb_put_hcd(bus_to_hcd(udev-&gt;bus));
 	kfree(udev-&gt;product);
@@ -176,6 +180,21 @@ static void usb_release_dev(struct device *dev)
 	kfree(udev);
 }
 
+#ifdef	CONFIG_PM
+
+/* usb_autosuspend_work - callback routine to autosuspend a USB device */
+static void usb_autosuspend_work(void *_udev)
+{
+	struct usb_device	*udev = _udev;
+
+	mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
+	udev-&gt;auto_pm = 1;
+	usb_suspend_both(udev, PMSG_SUSPEND);
+	mutex_unlock(&amp;udev-&gt;pm_mutex);
+}
+
+#endif
+
 /**
  * usb_alloc_dev - usb device constructor (usbcore-internal)
  * @parent: hub to which device is connected; null to allocate a root hub
@@ -251,6 +270,10 @@ usb_alloc_dev(struct usb_device *parent, struct usb_bus *bus, unsigned port1)
 	dev-&gt;parent = parent;
 	INIT_LIST_HEAD(&amp;dev-&gt;filelist);
 
+#ifdef	CONFIG_PM
+	mutex_init(&amp;dev-&gt;pm_mutex);
+	INIT_WORK(&amp;dev-&gt;autosuspend, usb_autosuspend_work, dev);
+#endif
 	return dev;
 }
 
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 5162cb370215..10688ad73c6d 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -49,6 +49,20 @@ static inline int usb_resume_both(struct usb_device *udev)
 
 #endif
 
+#ifdef CONFIG_USB_SUSPEND
+
+#define USB_AUTOSUSPEND_DELAY	(HZ*2)
+
+extern void usb_autosuspend_device(struct usb_device *udev, int dec_busy_cnt);
+extern int usb_autoresume_device(struct usb_device *udev, int inc_busy_cnt);
+
+#else
+
+#define usb_autosuspend_device(udev, dec_busy_cnt)	do {} while (0)
+#define usb_autoresume_device(udev, inc_busy_cnt)	0
+
+#endif
+
 extern struct bus_type usb_bus_type;
 extern struct usb_device_driver usb_generic_driver;
 
diff --git a/include/linux/usb.h b/include/linux/usb.h
index df5c93eb3ce9..0da15b0b02be 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -19,6 +19,7 @@
 #include &lt;linux/fs.h&gt;		/* for struct file_operations */
 #include &lt;linux/completion.h&gt;	/* for struct completion */
 #include &lt;linux/sched.h&gt;	/* for current &amp;&amp; schedule_timeout */
+#include &lt;linux/mutex.h&gt;	/* for struct mutex */
 
 struct usb_device;
 struct usb_driver;
@@ -103,8 +104,12 @@ enum usb_interface_condition {
  * @condition: binding state of the interface: not bound, binding
  *	(in probe()), bound to a driver, or unbinding (in disconnect())
  * @is_active: flag set when the interface is bound and not suspended.
+ * @needs_remote_wakeup: flag set when the driver requires remote-wakeup
+ *	capability during autosuspend.
  * @dev: driver model's view of this device
  * @class_dev: driver model's class view of this device.
+ * @pm_usage_cnt: PM usage counter for this interface; autosuspend is not
+ *	allowed unless the counter is 0.
  *
  * USB device drivers attach to interfaces on a physical device.  Each
  * interface encapsulates a single high level function, such as feeding
@@ -144,9 +149,11 @@ struct usb_interface {
 					 * bound to */
 	enum usb_interface_condition condition;		/* state of binding */
 	unsigned is_active:1;		/* the interface is not suspended */
+	unsigned needs_remote_wakeup:1;	/* driver requires remote wakeup */
 
 	struct device dev;		/* interface specific device info */
 	struct class_device *class_dev;
+	int pm_usage_cnt;		/* usage counter for autosuspend */
 };
 #define	to_usb_interface(d) container_of(d, struct usb_interface, dev)
 #define	interface_to_usbdev(intf) \
@@ -372,6 +379,15 @@ struct usb_device {
 
 	int maxchild;			/* Number of ports if hub */
 	struct usb_device *children[USB_MAXCHILDREN];
+
+#ifdef CONFIG_PM
+	struct work_struct autosuspend;	/* for delayed autosuspends */
+	struct mutex pm_mutex;		/* protects PM operations */
+	int pm_usage_cnt;		/* usage counter for autosuspend */
+
+	unsigned auto_pm:1;		/* autosuspend/resume in progress */
+	unsigned do_remote_wakeup:1;	/* remote wakeup should be enabled */
+#endif
 };
 #define	to_usb_device(d) container_of(d, struct usb_device, dev)
 
@@ -392,6 +408,17 @@ extern int usb_reset_composite_device(struct usb_device *dev,
 
 extern struct usb_device *usb_find_device(u16 vendor_id, u16 product_id);
 
+/* USB autosuspend and autoresume */
+#ifdef CONFIG_USB_SUSPEND
+extern int usb_autopm_get_interface(struct usb_interface *intf);
+extern void usb_autopm_put_interface(struct usb_interface *intf);
+
+#else
+#define usb_autopm_get_interface(intf)		0
+#define usb_autopm_put_interface(intf)		do {} while (0)
+#endif
+
+
 /*-------------------------------------------------------------------------*/
 
 /* for drivers using iso endpoints */
@@ -593,6 +620,8 @@ struct usbdrv_wrap {
  * @drvwrap: Driver-model core structure wrapper.
  * @no_dynamic_id: if set to 1, the USB core will not allow dynamic ids to be
  *	added to this driver by preventing the sysfs file from being created.
+ * @supports_autosuspend: if set to 0, the USB core will not allow autosuspend
+ *	for interfaces bound to this driver.
  *
  * USB interface drivers must provide a name, probe() and disconnect()
  * methods, and an id_table.  Other driver fields are optional.
@@ -631,6 +660,7 @@ struct usb_driver {
 	struct usb_dynids dynids;
 	struct usbdrv_wrap drvwrap;
 	unsigned int no_dynamic_id:1;
+	unsigned int supports_autosuspend:1;
 };
 #define	to_usb_driver(d) container_of(d, struct usb_driver, drvwrap.driver)
 
@@ -648,6 +678,8 @@ struct usb_driver {
  * @suspend: Called when the device is going to be suspended by the system.
  * @resume: Called when the device is being resumed by the system.
  * @drvwrap: Driver-model core structure wrapper.
+ * @supports_autosuspend: if set to 0, the USB core will not allow autosuspend
+ *	for devices bound to this driver.
  *
  * USB drivers must provide all the fields listed above except drvwrap.
  */
@@ -660,6 +692,7 @@ struct usb_device_driver {
 	int (*suspend) (struct usb_device *udev, pm_message_t message);
 	int (*resume) (struct usb_device *udev);
 	struct usbdrv_wrap drvwrap;
+	unsigned int supports_autosuspend:1;
 };
 #define	to_usb_device_driver(d) container_of(d, struct usb_device_driver, \
 		drvwrap.driver)</pre><hr><pre>commit b6956ffa595db97656d5901ca8fec77ef272d41a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 30 15:46:48 2006 -0400

    usbcore: store each usb_device's level in the tree
    
    This patch (as778) adds a field to struct usb_device to store the
    device's level in the USB tree.  In itself this number isn't really
    important.  But the overhead is very low, and in a later patch it will
    be used for preventing bogus warnings from the lockdep checker.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index f5adce049b35..78e910b2046c 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2414,6 +2414,7 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 		usb_set_device_state(udev, USB_STATE_POWERED);
 		udev-&gt;speed = USB_SPEED_UNKNOWN;
  		udev-&gt;bus_mA = hub-&gt;mA_per_port;
+		udev-&gt;level = hdev-&gt;level + 1;
 
 		/* set the address */
 		choose_address(udev);
diff --git a/include/linux/usb.h b/include/linux/usb.h
index c66303285a45..df5c93eb3ce9 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -348,6 +348,7 @@ struct usb_device {
 
 	unsigned short bus_mA;		/* Current available from the bus */
 	u8 portnum;			/* Parent port number (origin 1) */
+	u8 level;			/* Number of USB hub ancestors */
 
 	int have_langid;		/* whether string_langid is valid */
 	int string_langid;		/* language ID for strings */</pre><hr><pre>commit 4d6cd48380c4d361cc8ec34359df22377d85d202
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 30 11:35:21 2006 -0400

    usbmon: don't call mon_dmapeek if DMA isn't being used
    
    This patch (as755b) fixes a bug in usbmon.  Rather than assuming all
    USB host controllers use DMA, the code will check the usb_bus data
    structure.  If DMA isn't used, we don't want to try peeking into a
    non-existent DMA buffer!
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/mon/mon_main.c b/drivers/usb/mon/mon_main.c
index e0ed36cdfd8b..394bbf2f68d4 100644
--- a/drivers/usb/mon/mon_main.c
+++ b/drivers/usb/mon/mon_main.c
@@ -301,6 +301,7 @@ static void mon_bus_init(struct dentry *mondir, struct usb_bus *ubus)
 	 */
 	mbus-&gt;u_bus = ubus;
 	ubus-&gt;mon_bus = mbus;
+	mbus-&gt;uses_dma = ubus-&gt;uses_dma;
 
 	rc = snprintf(name, NAMESZ, "%dt", ubus-&gt;busnum);
 	if (rc &lt;= 0 || rc &gt;= NAMESZ)
diff --git a/drivers/usb/mon/mon_text.c b/drivers/usb/mon/mon_text.c
index 775e374a960c..7a2346c53284 100644
--- a/drivers/usb/mon/mon_text.c
+++ b/drivers/usb/mon/mon_text.c
@@ -75,13 +75,13 @@ static void mon_text_ctor(void *, kmem_cache_t *, unsigned long);
  */
 
 static inline char mon_text_get_setup(struct mon_event_text *ep,
-    struct urb *urb, char ev_type)
+    struct urb *urb, char ev_type, struct mon_bus *mbus)
 {
 
 	if (!usb_pipecontrol(urb-&gt;pipe) || ev_type != 'S')
 		return '-';
 
-	if (urb-&gt;transfer_flags &amp; URB_NO_SETUP_DMA_MAP)
+	if (mbus-&gt;uses_dma &amp;&amp; (urb-&gt;transfer_flags &amp; URB_NO_SETUP_DMA_MAP))
 		return mon_dmapeek(ep-&gt;setup, urb-&gt;setup_dma, SETUP_MAX);
 	if (urb-&gt;setup_packet == NULL)
 		return 'Z';	/* '0' would be not as pretty. */
@@ -91,7 +91,7 @@ static inline char mon_text_get_setup(struct mon_event_text *ep,
 }
 
 static inline char mon_text_get_data(struct mon_event_text *ep, struct urb *urb,
-    int len, char ev_type)
+    int len, char ev_type, struct mon_bus *mbus)
 {
 	int pipe = urb-&gt;pipe;
 
@@ -117,7 +117,7 @@ static inline char mon_text_get_data(struct mon_event_text *ep, struct urb *urb,
 	 * contain non-NULL garbage in case the upper level promised to
 	 * set DMA for the HCD.
 	 */
-	if (urb-&gt;transfer_flags &amp; URB_NO_TRANSFER_DMA_MAP)
+	if (mbus-&gt;uses_dma &amp;&amp; (urb-&gt;transfer_flags &amp; URB_NO_TRANSFER_DMA_MAP))
 		return mon_dmapeek(ep-&gt;data, urb-&gt;transfer_dma, len);
 
 	if (urb-&gt;transfer_buffer == NULL)
@@ -161,8 +161,9 @@ static void mon_text_event(struct mon_reader_text *rp, struct urb *urb,
 	/* Collecting status makes debugging sense for submits, too */
 	ep-&gt;status = urb-&gt;status;
 
-	ep-&gt;setup_flag = mon_text_get_setup(ep, urb, ev_type);
-	ep-&gt;data_flag = mon_text_get_data(ep, urb, ep-&gt;length, ev_type);
+	ep-&gt;setup_flag = mon_text_get_setup(ep, urb, ev_type, rp-&gt;r.m_bus);
+	ep-&gt;data_flag = mon_text_get_data(ep, urb, ep-&gt;length, ev_type,
+			rp-&gt;r.m_bus);
 
 	rp-&gt;nevents++;
 	list_add_tail(&amp;ep-&gt;e_link, &amp;rp-&gt;e_list);
diff --git a/drivers/usb/mon/usb_mon.h b/drivers/usb/mon/usb_mon.h
index 50efc8ee7c21..ab9d02d5df77 100644
--- a/drivers/usb/mon/usb_mon.h
+++ b/drivers/usb/mon/usb_mon.h
@@ -20,6 +20,7 @@ struct mon_bus {
 	struct dentry *dent_s;		/* Debugging file */
 	struct dentry *dent_t;		/* Text interface file */
 	struct usb_bus *u_bus;
+	int uses_dma;
 
 	/* Ref */
 	int nreaders;			/* Under mon_lock AND mbus-&gt;lock */</pre>
    <div class="pagination">
        <a href='2_118.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><span>[119]</span><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_120.html'>Next&gt;&gt;</a>
    <div>
</body>
