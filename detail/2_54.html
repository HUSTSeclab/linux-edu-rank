<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_53.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><span>[54]</span><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_55.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 86dc243cb2ddecb6984401463ebb0963ceff3cdc
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Nov 17 16:42:24 2011 -0500

    USB: remove homegrown UTF conversion routine for gadgets
    
    This patch (as1502) removes the UTF8-to-UTF16 conversion routine in
    the USB gadget library and replaces it with a call to the equivalent
    function in the NLS library.
    
    The only downside worth noting is that the NLS library routine
    requires the output buffer to be 16-bit aligned.  This is always true
    in the gadget code, because the output buffer is always a
    usb_request buffer being used to send a string descriptor.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/Kconfig b/drivers/usb/gadget/Kconfig
index b21cd376c11a..a11dbc85d08b 100644
--- a/drivers/usb/gadget/Kconfig
+++ b/drivers/usb/gadget/Kconfig
@@ -15,6 +15,7 @@
 
 menuconfig USB_GADGET
 	tristate "USB Gadget Support"
+	select NLS
 	help
 	   USB is a master/slave protocol, organized with one master
 	   host (such as a PC) controlling up to 127 peripheral devices.
diff --git a/drivers/usb/gadget/usbstring.c b/drivers/usb/gadget/usbstring.c
index 58c4d37d312a..4d25b9009edf 100644
--- a/drivers/usb/gadget/usbstring.c
+++ b/drivers/usb/gadget/usbstring.c
@@ -13,82 +13,17 @@
 #include &lt;linux/string.h&gt;
 #include &lt;linux/device.h&gt;
 #include &lt;linux/init.h&gt;
+#include &lt;linux/nls.h&gt;
 
 #include &lt;linux/usb/ch9.h&gt;
 #include &lt;linux/usb/gadget.h&gt;
 
-#include &lt;asm/unaligned.h&gt;
-
-
-static int utf8_to_utf16le(const char *s, __le16 *cp, unsigned len)
-{
-	int	count = 0;
-	u8	c;
-	u16	uchar;
-
-	/* this insists on correct encodings, though not minimal ones.
-	 * BUT it currently rejects legit 4-byte UTF-8 code points,
-	 * which need surrogate pairs.  (Unicode 3.1 can use them.)
-	 */
-	while (len != 0 &amp;&amp; (c = (u8) *s++) != 0) {
-		if (unlikely(c &amp; 0x80)) {
-			// 2-byte sequence:
-			// 00000yyyyyxxxxxx = 110yyyyy 10xxxxxx
-			if ((c &amp; 0xe0) == 0xc0) {
-				uchar = (c &amp; 0x1f) &lt;&lt; 6;
-
-				c = (u8) *s++;
-				if ((c &amp; 0xc0) != 0x80)
-					goto fail;
-				c &amp;= 0x3f;
-				uchar |= c;
-
-			// 3-byte sequence (most CJKV characters):
-			// zzzzyyyyyyxxxxxx = 1110zzzz 10yyyyyy 10xxxxxx
-			} else if ((c &amp; 0xf0) == 0xe0) {
-				uchar = (c &amp; 0x0f) &lt;&lt; 12;
-
-				c = (u8) *s++;
-				if ((c &amp; 0xc0) != 0x80)
-					goto fail;
-				c &amp;= 0x3f;
-				uchar |= c &lt;&lt; 6;
-
-				c = (u8) *s++;
-				if ((c &amp; 0xc0) != 0x80)
-					goto fail;
-				c &amp;= 0x3f;
-				uchar |= c;
-
-				/* no bogus surrogates */
-				if (0xd800 &lt;= uchar &amp;&amp; uchar &lt;= 0xdfff)
-					goto fail;
-
-			// 4-byte sequence (surrogate pairs, currently rare):
-			// 11101110wwwwzzzzyy + 110111yyyyxxxxxx
-			//     = 11110uuu 10uuzzzz 10yyyyyy 10xxxxxx
-			// (uuuuu = wwww + 1)
-			// FIXME accept the surrogate code points (only)
-
-			} else
-				goto fail;
-		} else
-			uchar = c;
-		put_unaligned_le16(uchar, cp++);
-		count++;
-		len--;
-	}
-	return count;
-fail:
-	return -1;
-}
-
 
 /**
  * usb_gadget_get_string - fill out a string descriptor 
  * @table: of c strings encoded using UTF-8
  * @id: string id, from low byte of wValue in get string descriptor
- * @buf: at least 256 bytes
+ * @buf: at least 256 bytes, must be 16-bit aligned
  *
  * Finds the UTF-8 string matching the ID, and converts it into a
  * string descriptor in utf16-le.
@@ -125,8 +60,8 @@ usb_gadget_get_string (struct usb_gadget_strings *table, int id, u8 *buf)
 
 	/* string descriptors have length, tag, then UTF16-LE text */
 	len = min ((size_t) 126, strlen (s-&gt;s));
-	memset (buf + 2, 0, 2 * len);	/* zero all the bytes */
-	len = utf8_to_utf16le(s-&gt;s, (__le16 *)&amp;buf[2], len);
+	len = utf8s_to_utf16s(s-&gt;s, len, UTF16_LITTLE_ENDIAN,
+			(wchar_t *) &amp;buf[2], 126);
 	if (len &lt; 0)
 		return -EINVAL;
 	buf [0] = (len + 1) * 2;</pre><hr><pre>commit 0720a06a7518c9d0c0125bd5d1f3b6264c55c3dd
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Nov 17 16:42:19 2011 -0500

    NLS: improve UTF8 -&gt; UTF16 string conversion routine
    
    The utf8s_to_utf16s conversion routine needs to be improved.  Unlike
    its utf16s_to_utf8s sibling, it doesn't accept arguments specifying
    the maximum length of the output buffer or the endianness of its
    16-bit output.
    
    This patch (as1501) adds the two missing arguments, and adjusts the
    only two places in the kernel where the function is called.  A
    follow-on patch will add a third caller that does utilize the new
    capabilities.
    
    The two conversion routines are still annoyingly inconsistent in the
    way they handle invalid byte combinations.  But that's a subject for a
    different patch.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Clemens Ladisch &lt;clemens@ladisch.de&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/hv/hv_kvp.c b/drivers/hv/hv_kvp.c
index 89f52440fcf4..0e8343f585bb 100644
--- a/drivers/hv/hv_kvp.c
+++ b/drivers/hv/hv_kvp.c
@@ -212,11 +212,13 @@ kvp_respond_to_host(char *key, char *value, int error)
 	 * The windows host expects the key/value pair to be encoded
 	 * in utf16.
 	 */
-	keylen = utf8s_to_utf16s(key_name, strlen(key_name),
-				(wchar_t *)kvp_data-&gt;data.key);
+	keylen = utf8s_to_utf16s(key_name, strlen(key_name), UTF16_HOST_ENDIAN,
+				(wchar_t *) kvp_data-&gt;data.key,
+				HV_KVP_EXCHANGE_MAX_KEY_SIZE / 2);
 	kvp_data-&gt;data.key_size = 2*(keylen + 1); /* utf16 encoding */
-	valuelen = utf8s_to_utf16s(value, strlen(value),
-				(wchar_t *)kvp_data-&gt;data.value);
+	valuelen = utf8s_to_utf16s(value, strlen(value), UTF16_HOST_ENDIAN,
+				(wchar_t *) kvp_data-&gt;data.value,
+				HV_KVP_EXCHANGE_MAX_VALUE_SIZE / 2);
 	kvp_data-&gt;data.value_size = 2*(valuelen + 1); /* utf16 encoding */
 
 	kvp_data-&gt;data.value_type = REG_SZ; /* all our values are strings */
diff --git a/fs/fat/namei_vfat.c b/fs/fat/namei_vfat.c
index a87a65663c25..c25cf151b84b 100644
--- a/fs/fat/namei_vfat.c
+++ b/fs/fat/namei_vfat.c
@@ -512,7 +512,8 @@ xlate_to_uni(const unsigned char *name, int len, unsigned char *outname,
 	int charlen;
 
 	if (utf8) {
-		*outlen = utf8s_to_utf16s(name, len, (wchar_t *)outname);
+		*outlen = utf8s_to_utf16s(name, len, UTF16_HOST_ENDIAN,
+				(wchar_t *) outname, FAT_LFN_LEN + 2);
 		if (*outlen &lt; 0)
 			return *outlen;
 		else if (*outlen &gt; FAT_LFN_LEN)
diff --git a/fs/nls/nls_base.c b/fs/nls/nls_base.c
index 44a88a9fa2c8..0eb059ec6f28 100644
--- a/fs/nls/nls_base.c
+++ b/fs/nls/nls_base.c
@@ -114,34 +114,57 @@ int utf32_to_utf8(unicode_t u, u8 *s, int maxlen)
 }
 EXPORT_SYMBOL(utf32_to_utf8);
 
-int utf8s_to_utf16s(const u8 *s, int len, wchar_t *pwcs)
+static inline void put_utf16(wchar_t *s, unsigned c, enum utf16_endian endian)
+{
+	switch (endian) {
+	default:
+		*s = (wchar_t) c;
+		break;
+	case UTF16_LITTLE_ENDIAN:
+		*s = __cpu_to_le16(c);
+		break;
+	case UTF16_BIG_ENDIAN:
+		*s = __cpu_to_be16(c);
+		break;
+	}
+}
+
+int utf8s_to_utf16s(const u8 *s, int len, enum utf16_endian endian,
+		wchar_t *pwcs, int maxlen)
 {
 	u16 *op;
 	int size;
 	unicode_t u;
 
 	op = pwcs;
-	while (*s &amp;&amp; len &gt; 0) {
+	while (len &gt; 0 &amp;&amp; maxlen &gt; 0 &amp;&amp; *s) {
 		if (*s &amp; 0x80) {
 			size = utf8_to_utf32(s, len, &amp;u);
 			if (size &lt; 0)
 				return -EINVAL;
+			s += size;
+			len -= size;
 
 			if (u &gt;= PLANE_SIZE) {
+				if (maxlen &lt; 2)
+					break;
 				u -= PLANE_SIZE;
-				*op++ = (wchar_t) (SURROGATE_PAIR |
-						((u &gt;&gt; 10) &amp; SURROGATE_BITS));
-				*op++ = (wchar_t) (SURROGATE_PAIR |
+				put_utf16(op++, SURROGATE_PAIR |
+						((u &gt;&gt; 10) &amp; SURROGATE_BITS),
+						endian);
+				put_utf16(op++, SURROGATE_PAIR |
 						SURROGATE_LOW |
-						(u &amp; SURROGATE_BITS));
+						(u &amp; SURROGATE_BITS),
+						endian);
+				maxlen -= 2;
 			} else {
-				*op++ = (wchar_t) u;
+				put_utf16(op++, u, endian);
+				maxlen--;
 			}
-			s += size;
-			len -= size;
 		} else {
-			*op++ = *s++;
+			put_utf16(op++, *s++, endian);
 			len--;
+			maxlen--;
 		}
 	}
 	return op - pwcs;
diff --git a/include/linux/nls.h b/include/linux/nls.h
index d47beef08dfd..5dc635f8d79e 100644
--- a/include/linux/nls.h
+++ b/include/linux/nls.h
@@ -43,7 +43,7 @@ enum utf16_endian {
 	UTF16_BIG_ENDIAN
 };
 
-/* nls.c */
+/* nls_base.c */
 extern int register_nls(struct nls_table *);
 extern int unregister_nls(struct nls_table *);
 extern struct nls_table *load_nls(char *);
@@ -52,7 +52,8 @@ extern struct nls_table *load_nls_default(void);
 
 extern int utf8_to_utf32(const u8 *s, int len, unicode_t *pu);
 extern int utf32_to_utf8(unicode_t u, u8 *s, int maxlen);
-extern int utf8s_to_utf16s(const u8 *s, int len, wchar_t *pwcs);
+extern int utf8s_to_utf16s(const u8 *s, int len,
+		enum utf16_endian endian, wchar_t *pwcs, int maxlen);
 extern int utf16s_to_utf8s(const wchar_t *pwcs, int len,
 		enum utf16_endian endian, u8 *s, int maxlen);
 </pre><hr><pre>commit b7463c71fbbff7111d0c879d2f64fe2b08f51848
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Nov 17 16:41:56 2011 -0500

    OHCI: remove uses of hcd-&gt;state
    
    This patch (as1500) removes all uses of the objectionable hcd-&gt;state
    variable from the ohci-hcd family of drivers.  It is replaced by a
    private ohci-&gt;rh_state field, just as in uhci-hcd and ehci-hcd.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ohci-au1xxx.c b/drivers/usb/host/ohci-au1xxx.c
index 9b66df8278f3..40d886adff53 100644
--- a/drivers/usb/host/ohci-au1xxx.c
+++ b/drivers/usb/host/ohci-au1xxx.c
@@ -173,12 +173,9 @@ static int ohci_hcd_au1xxx_drv_suspend(struct device *dev)
 	 * mark HW unaccessible, bail out if RH has been resumed. Use
 	 * the spinlock to properly synchronize with possible pending
 	 * RH suspend or resume activity.
-	 *
-	 * This is still racy as hcd-&gt;state is manipulated outside of
-	 * any locks =P But that will be a different fix.
 	 */
 	spin_lock_irqsave(&amp;ohci-&gt;lock, flags);
-	if (hcd-&gt;state != HC_STATE_SUSPENDED) {
+	if (ohci-&gt;rh_state != OHCI_RH_SUSPENDED) {
 		rc = -EINVAL;
 		goto bail;
 	}
diff --git a/drivers/usb/host/ohci-dbg.c b/drivers/usb/host/ohci-dbg.c
index d7d34492934a..5179fcd73d8a 100644
--- a/drivers/usb/host/ohci-dbg.c
+++ b/drivers/usb/host/ohci-dbg.c
@@ -127,6 +127,19 @@ static char *hcfs2string (int state)
 	return "?";
 }
 
+static const char *rh_state_string(struct ohci_hcd *ohci)
+{
+	switch (ohci-&gt;rh_state) {
+	case OHCI_RH_HALTED:
+		return "halted";
+	case OHCI_RH_SUSPENDED:
+		return "suspended";
+	case OHCI_RH_RUNNING:
+		return "running";
+	}
+	return "?";
+}
+
 // dump control and status registers
 static void
 ohci_dump_status (struct ohci_hcd *controller, char **next, unsigned *size)
@@ -136,9 +149,10 @@ ohci_dump_status (struct ohci_hcd *controller, char **next, unsigned *size)
 
 	temp = ohci_readl (controller, &amp;regs-&gt;revision) &amp; 0xff;
 	ohci_dbg_sw (controller, next, size,
-		"OHCI %d.%d, %s legacy support registers\n",
+		"OHCI %d.%d, %s legacy support registers, rh state %s\n",
 		0x03 &amp; (temp &gt;&gt; 4), (temp &amp; 0x0f),
-		(temp &amp; 0x0100) ? "with" : "NO");
+		(temp &amp; 0x0100) ? "with" : "NO",
+		rh_state_string(controller));
 
 	temp = ohci_readl (controller, &amp;regs-&gt;control);
 	ohci_dbg_sw (controller, next, size,
diff --git a/drivers/usb/host/ohci-ep93xx.c b/drivers/usb/host/ohci-ep93xx.c
index dc45d489d00e..3d63574d2c7e 100644
--- a/drivers/usb/host/ohci-ep93xx.c
+++ b/drivers/usb/host/ohci-ep93xx.c
@@ -179,8 +179,6 @@ static int ohci_hcd_ep93xx_drv_suspend(struct platform_device *pdev, pm_message_
 	ohci-&gt;next_statechange = jiffies;
 
 	ep93xx_stop_hc(&amp;pdev-&gt;dev);
-	hcd-&gt;state = HC_STATE_SUSPENDED;
-
 	return 0;
 }
 
diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index 34efd479e068..03c4631dc27a 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -209,7 +209,7 @@ static int ohci_urb_enqueue (
 		retval = -ENODEV;
 		goto fail;
 	}
-	if (!HC_IS_RUNNING(hcd-&gt;state)) {
+	if (ohci-&gt;rh_state != OHCI_RH_RUNNING) {
 		retval = -ENODEV;
 		goto fail;
 	}
@@ -274,7 +274,7 @@ static int ohci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 	rc = usb_hcd_check_unlink_urb(hcd, urb, status);
 	if (rc) {
 		;	/* Do nothing */
-	} else if (HC_IS_RUNNING(hcd-&gt;state)) {
+	} else if (ohci-&gt;rh_state == OHCI_RH_RUNNING) {
 		urb_priv_t  *urb_priv;
 
 		/* Unless an IRQ completed the unlink while it was being
@@ -321,7 +321,7 @@ ohci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 rescan:
 	spin_lock_irqsave (&amp;ohci-&gt;lock, flags);
 
-	if (!HC_IS_RUNNING (hcd-&gt;state)) {
+	if (ohci-&gt;rh_state != OHCI_RH_RUNNING) {
 sanitize:
 		ed-&gt;state = ED_IDLE;
 		if (quirk_zfmicro(ohci) &amp;&amp; ed-&gt;type == PIPE_INTERRUPT)
@@ -377,6 +377,7 @@ static void ohci_usb_reset (struct ohci_hcd *ohci)
 	ohci-&gt;hc_control = ohci_readl (ohci, &amp;ohci-&gt;regs-&gt;control);
 	ohci-&gt;hc_control &amp;= OHCI_CTRL_RWC;
 	ohci_writel (ohci, ohci-&gt;hc_control, &amp;ohci-&gt;regs-&gt;control);
+	ohci-&gt;rh_state = OHCI_RH_HALTED;
 }
 
 /* ohci_shutdown forcibly disables IRQs and DMA, helping kexec and
@@ -503,7 +504,7 @@ static int ohci_init (struct ohci_hcd *ohci)
 	if (distrust_firmware)
 		ohci-&gt;flags |= OHCI_QUIRK_HUB_POWER;
 
-	disable (ohci);
+	ohci-&gt;rh_state = OHCI_RH_HALTED;
 	ohci-&gt;regs = hcd-&gt;regs;
 
 	/* REVISIT this BIOS handshake is now moved into PCI "quirks", and
@@ -578,7 +579,7 @@ static int ohci_run (struct ohci_hcd *ohci)
 	int			first = ohci-&gt;fminterval == 0;
 	struct usb_hcd		*hcd = ohci_to_hcd(ohci);
 
-	disable (ohci);
+	ohci-&gt;rh_state = OHCI_RH_HALTED;
 
 	/* boot firmware should have set this up (5.1.1.3.1) */
 	if (first) {
@@ -691,7 +692,7 @@ static int ohci_run (struct ohci_hcd *ohci)
 	ohci-&gt;hc_control &amp;= OHCI_CTRL_RWC;
 	ohci-&gt;hc_control |= OHCI_CONTROL_INIT | OHCI_USB_OPER;
 	ohci_writel (ohci, ohci-&gt;hc_control, &amp;ohci-&gt;regs-&gt;control);
-	hcd-&gt;state = HC_STATE_RUNNING;
+	ohci-&gt;rh_state = OHCI_RH_RUNNING;
 
 	/* wake on ConnectStatusChange, matching external hubs */
 	ohci_writel (ohci, RH_HS_DRWE, &amp;ohci-&gt;regs-&gt;roothub.status);
@@ -728,7 +729,6 @@ static int ohci_run (struct ohci_hcd *ohci)
 
 	// POTPGT delay is bits 24-31, in 2 ms units.
 	mdelay ((val &gt;&gt; 23) &amp; 0x1fe);
-	hcd-&gt;state = HC_STATE_RUNNING;
 
 	if (quirk_zfmicro(ohci)) {
 		/* Create timer to watch for bad queue state on ZF Micro */
@@ -764,7 +764,7 @@ static irqreturn_t ohci_irq (struct usb_hcd *hcd)
 	 * of dead, unclocked, or unplugged (CardBus...) devices
 	 */
 	if (ints == ~(u32)0) {
-		disable (ohci);
+		ohci-&gt;rh_state = OHCI_RH_HALTED;
 		ohci_dbg (ohci, "device removed!\n");
 		usb_hc_died(hcd);
 		return IRQ_HANDLED;
@@ -774,7 +774,7 @@ static irqreturn_t ohci_irq (struct usb_hcd *hcd)
 	ints &amp;= ohci_readl(ohci, &amp;regs-&gt;intrenable);
 
 	/* interrupt for some other device? */
-	if (ints == 0 || unlikely(hcd-&gt;state == HC_STATE_HALT))
+	if (ints == 0 || unlikely(ohci-&gt;rh_state == OHCI_RH_HALTED))
 		return IRQ_NOTMINE;
 
 	if (ints &amp; OHCI_INTR_UE) {
@@ -789,8 +789,8 @@ static irqreturn_t ohci_irq (struct usb_hcd *hcd)
 
 			schedule_work (&amp;ohci-&gt;nec_work);
 		} else {
-			disable (ohci);
 			ohci_err (ohci, "OHCI Unrecoverable Error, disabled\n");
+			ohci-&gt;rh_state = OHCI_RH_HALTED;
 			usb_hc_died(hcd);
 		}
 
@@ -874,11 +874,11 @@ static irqreturn_t ohci_irq (struct usb_hcd *hcd)
 	if ((ints &amp; OHCI_INTR_SF) != 0
 			&amp;&amp; !ohci-&gt;ed_rm_list
 			&amp;&amp; !ohci-&gt;ed_to_check
-			&amp;&amp; HC_IS_RUNNING(hcd-&gt;state))
+			&amp;&amp; ohci-&gt;rh_state == OHCI_RH_RUNNING)
 		ohci_writel (ohci, OHCI_INTR_SF, &amp;regs-&gt;intrdisable);
 	spin_unlock (&amp;ohci-&gt;lock);
 
-	if (HC_IS_RUNNING(hcd-&gt;state)) {
+	if (ohci-&gt;rh_state == OHCI_RH_RUNNING) {
 		ohci_writel (ohci, ints, &amp;regs-&gt;intrstatus);
 		ohci_writel (ohci, OHCI_INTR_MIE, &amp;regs-&gt;intrenable);
 		// flush those writes
@@ -932,7 +932,7 @@ static int ohci_restart (struct ohci_hcd *ohci)
 	struct urb_priv *priv;
 
 	spin_lock_irq(&amp;ohci-&gt;lock);
-	disable (ohci);
+	ohci-&gt;rh_state = OHCI_RH_HALTED;
 
 	/* Recycle any "live" eds/tds (and urbs). */
 	if (!list_empty (&amp;ohci-&gt;pending))
diff --git a/drivers/usb/host/ohci-hub.c b/drivers/usb/host/ohci-hub.c
index 2f00040fc408..836772dfabd3 100644
--- a/drivers/usb/host/ohci-hub.c
+++ b/drivers/usb/host/ohci-hub.c
@@ -111,6 +111,7 @@ __acquires(ohci-&gt;lock)
 	if (!autostop) {
 		ohci-&gt;next_statechange = jiffies + msecs_to_jiffies (5);
 		ohci-&gt;autostop = 0;
+		ohci-&gt;rh_state = OHCI_RH_SUSPENDED;
 	}
 
 done:
@@ -140,7 +141,7 @@ __acquires(ohci-&gt;lock)
 
 	if (ohci-&gt;hc_control &amp; (OHCI_CTRL_IR | OHCI_SCHED_ENABLES)) {
 		/* this can happen after resuming a swsusp snapshot */
-		if (hcd-&gt;state == HC_STATE_RESUMING) {
+		if (ohci-&gt;rh_state != OHCI_RH_RUNNING) {
 			ohci_dbg (ohci, "BIOS/SMM active, control %03x\n",
 					ohci-&gt;hc_control);
 			status = -EBUSY;
@@ -274,6 +275,7 @@ __acquires(ohci-&gt;lock)
 		(void) ohci_readl (ohci, &amp;ohci-&gt;regs-&gt;control);
 	}
 
+	ohci-&gt;rh_state = OHCI_RH_RUNNING;
 	return 0;
 }
 
@@ -336,11 +338,8 @@ static void ohci_finish_controller_resume(struct usb_hcd *hcd)
 	/* If needed, reinitialize and suspend the root hub */
 	if (need_reinit) {
 		spin_lock_irq(&amp;ohci-&gt;lock);
-		hcd-&gt;state = HC_STATE_RESUMING;
 		ohci_rh_resume(ohci);
-		hcd-&gt;state = HC_STATE_QUIESCING;
 		ohci_rh_suspend(ohci, 0);
-		hcd-&gt;state = HC_STATE_SUSPENDED;
 		spin_unlock_irq(&amp;ohci-&gt;lock);
 	}
 
diff --git a/drivers/usb/host/ohci-omap.c b/drivers/usb/host/ohci-omap.c
index e4b8782cc6e2..db3968656d21 100644
--- a/drivers/usb/host/ohci-omap.c
+++ b/drivers/usb/host/ohci-omap.c
@@ -516,7 +516,6 @@ static int ohci_omap_suspend(struct platform_device *dev, pm_message_t message)
 	ohci-&gt;next_statechange = jiffies;
 
 	omap_ohci_clock_power(0);
-	ohci_to_hcd(ohci)-&gt;state = HC_STATE_SUSPENDED;
 	return 0;
 }
 
diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index ad8166c681e2..847187df50a1 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -334,12 +334,9 @@ static int ohci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)
 	 * mark HW unaccessible, bail out if RH has been resumed. Use
 	 * the spinlock to properly synchronize with possible pending
 	 * RH suspend or resume activity.
-	 *
-	 * This is still racy as hcd-&gt;state is manipulated outside of
-	 * any locks =P But that will be a different fix.
 	 */
 	spin_lock_irqsave (&amp;ohci-&gt;lock, flags);
-	if (hcd-&gt;state != HC_STATE_SUSPENDED) {
+	if (ohci-&gt;rh_state != OHCI_RH_SUSPENDED) {
 		rc = -EINVAL;
 		goto bail;
 	}
diff --git a/drivers/usb/host/ohci-pxa27x.c b/drivers/usb/host/ohci-pxa27x.c
index 29dfefe1c726..6313e4439f37 100644
--- a/drivers/usb/host/ohci-pxa27x.c
+++ b/drivers/usb/host/ohci-pxa27x.c
@@ -502,8 +502,6 @@ static int ohci_hcd_pxa27x_drv_suspend(struct device *dev)
 	ohci-&gt;ohci.next_statechange = jiffies;
 
 	pxa27x_stop_hc(ohci, dev);
-	hcd-&gt;state = HC_STATE_SUSPENDED;
-
 	return 0;
 }
 
diff --git a/drivers/usb/host/ohci-q.c b/drivers/usb/host/ohci-q.c
index 15dc51ded61a..c5a1ea9145fa 100644
--- a/drivers/usb/host/ohci-q.c
+++ b/drivers/usb/host/ohci-q.c
@@ -912,7 +912,7 @@ finish_unlinks (struct ohci_hcd *ohci, u16 tick)
 		/* only take off EDs that the HC isn't using, accounting for
 		 * frame counter wraps and EDs with partially retired TDs
 		 */
-		if (likely (HC_IS_RUNNING(ohci_to_hcd(ohci)-&gt;state))) {
+		if (likely(ohci-&gt;rh_state == OHCI_RH_RUNNING)) {
 			if (tick_before (tick, ed-&gt;tick)) {
 skip_ed:
 				last = &amp;ed-&gt;ed_next;
@@ -1012,7 +1012,7 @@ finish_unlinks (struct ohci_hcd *ohci, u16 tick)
 
 		/* but if there's work queued, reschedule */
 		if (!list_empty (&amp;ed-&gt;td_list)) {
-			if (HC_IS_RUNNING(ohci_to_hcd(ohci)-&gt;state))
+			if (ohci-&gt;rh_state == OHCI_RH_RUNNING)
 				ed_schedule (ohci, ed);
 		}
 
@@ -1021,9 +1021,7 @@ finish_unlinks (struct ohci_hcd *ohci, u16 tick)
 	}
 
 	/* maybe reenable control and bulk lists */
-	if (HC_IS_RUNNING(ohci_to_hcd(ohci)-&gt;state)
-			&amp;&amp; ohci_to_hcd(ohci)-&gt;state != HC_STATE_QUIESCING
-			&amp;&amp; !ohci-&gt;ed_rm_list) {
+	if (ohci-&gt;rh_state == OHCI_RH_RUNNING &amp;&amp; !ohci-&gt;ed_rm_list) {
 		u32	command = 0, control = 0;
 
 		if (ohci-&gt;ed_controltail) {
diff --git a/drivers/usb/host/ohci-sh.c b/drivers/usb/host/ohci-sh.c
index afc4eb6bb9d0..84686d90805b 100644
--- a/drivers/usb/host/ohci-sh.c
+++ b/drivers/usb/host/ohci-sh.c
@@ -29,7 +29,6 @@ static int ohci_sh_start(struct usb_hcd *hcd)
 	ohci_hcd_init(ohci);
 	ohci_init(ohci);
 	ohci_run(ohci);
-	hcd-&gt;state = HC_STATE_RUNNING;
 	return 0;
 }
 
diff --git a/drivers/usb/host/ohci-sm501.c b/drivers/usb/host/ohci-sm501.c
index 968cea2b6d4e..5596ac2ba1ca 100644
--- a/drivers/usb/host/ohci-sm501.c
+++ b/drivers/usb/host/ohci-sm501.c
@@ -224,7 +224,6 @@ static int ohci_sm501_suspend(struct platform_device *pdev, pm_message_t msg)
 	ohci-&gt;next_statechange = jiffies;
 
 	sm501_unit_power(dev-&gt;parent, SM501_GATE_USB_HOST, 0);
-	ohci_to_hcd(ohci)-&gt;state = HC_STATE_SUSPENDED;
 	return 0;
 }
 
diff --git a/drivers/usb/host/ohci-spear.c b/drivers/usb/host/ohci-spear.c
index 69874654f3b5..95c16489e883 100644
--- a/drivers/usb/host/ohci-spear.c
+++ b/drivers/usb/host/ohci-spear.c
@@ -203,7 +203,6 @@ static int spear_ohci_hcd_drv_suspend(struct platform_device *dev,
 	ohci-&gt;next_statechange = jiffies;
 
 	spear_stop_ohci(ohci_p);
-	ohci_to_hcd(ohci)-&gt;state = HC_STATE_SUSPENDED;
 	return 0;
 }
 
diff --git a/drivers/usb/host/ohci-tmio.c b/drivers/usb/host/ohci-tmio.c
index 06331d931171..120bfe6ede38 100644
--- a/drivers/usb/host/ohci-tmio.c
+++ b/drivers/usb/host/ohci-tmio.c
@@ -318,9 +318,6 @@ static int ohci_hcd_tmio_drv_suspend(struct platform_device *dev, pm_message_t s
 		if (ret)
 			return ret;
 	}
-
-	hcd-&gt;state = HC_STATE_SUSPENDED;
-
 	return 0;
 }
 
diff --git a/drivers/usb/host/ohci.h b/drivers/usb/host/ohci.h
index 35e5fd640ce7..3a978a2130cb 100644
--- a/drivers/usb/host/ohci.h
+++ b/drivers/usb/host/ohci.h
@@ -344,6 +344,12 @@ typedef struct urb_priv {
  * a subset of what the full implementation needs. (Linus)
  */
 
+enum ohci_rh_state {
+	OHCI_RH_HALTED,
+	OHCI_RH_SUSPENDED,
+	OHCI_RH_RUNNING
+};
+
 struct ohci_hcd {
 	spinlock_t		lock;
 
@@ -384,6 +390,7 @@ struct ohci_hcd {
 	/*
 	 * driver state
 	 */
+	enum ohci_rh_state	rh_state;
 	int			num_ports;
 	int			load [NUM_INTS];
 	u32			hc_control;	/* copy of hc control reg */
@@ -680,11 +687,6 @@ static inline u16 ohci_hwPSW(const struct ohci_hcd *ohci,
 
 /*-------------------------------------------------------------------------*/
 
-static inline void disable (struct ohci_hcd *ohci)
-{
-	ohci_to_hcd(ohci)-&gt;state = HC_STATE_HALT;
-}
-
 #define	FI			0x2edf		/* 12000 bits per frame (-1) */
 #define	FSMP(fi)		(0x7fff &amp; ((6 * ((fi) - 210)) / 7))
 #define	FIT			(1 &lt;&lt; 31)
@@ -708,7 +710,7 @@ static inline void periodic_reinit (struct ohci_hcd *ohci)
 #define read_roothub(hc, register, mask) ({ \
 	u32 temp = ohci_readl (hc, &amp;hc-&gt;regs-&gt;roothub.register); \
 	if (temp == -1) \
-		disable (hc); \
+		hc-&gt;rh_state = OHCI_RH_HALTED; \
 	else if (hc-&gt;flags &amp; OHCI_QUIRK_AMD756) \
 		while (temp &amp; mask) \
 			temp = ohci_readl (hc, &amp;hc-&gt;regs-&gt;roothub.register); \</pre><hr><pre>commit 2f640bf4c94324aeaa1b6385c10aab8c5ad1e1cf
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Oct 25 10:50:58 2011 -0400

    usb-storage: Accept 8020i-protocol commands longer than 12 bytes
    
    The 8020i protocol (also 8070i and QIC-157) uses 12-byte commands;
    shorter commands must be padded.  Simon Detheridge reports that his
    3-TB USB disk drive claims to use the 8020i protocol (which is
    normally meant for ATAPI devices like CD drives), and because of its
    large size, the disk drive requires the use of 16-byte commands.
    However the usb_stor_pad12_command() routine in usb-storage always
    sets the command length to 12, making the drive impossible to use.
    
    Since the SFF-8020i specification allows for 16-byte commands in
    future extensions, we may as well accept them.  This patch (as1490)
    changes usb_stor_pad12_command() to leave commands larger than 12
    bytes alone rather than truncating them.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Simon Detheridge &lt;simon@widgit.com&gt;
    CC: Matthew Dharm &lt;mdharm-usb@one-eyed-alien.net&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/protocol.c b/drivers/usb/storage/protocol.c
index 93c1a4d86f51..82dd834709c7 100644
--- a/drivers/usb/storage/protocol.c
+++ b/drivers/usb/storage/protocol.c
@@ -59,7 +59,9 @@
 
 void usb_stor_pad12_command(struct scsi_cmnd *srb, struct us_data *us)
 {
-	/* Pad the SCSI command with zeros out to 12 bytes
+	/*
+	 * Pad the SCSI command with zeros out to 12 bytes.  If the
+	 * command already is 12 bytes or longer, leave it alone.
 	 *
 	 * NOTE: This only works because a scsi_cmnd struct field contains
 	 * a unsigned char cmnd[16], so we know we have storage available
@@ -67,9 +69,6 @@ void usb_stor_pad12_command(struct scsi_cmnd *srb, struct us_data *us)
 	for (; srb-&gt;cmd_len&lt;12; srb-&gt;cmd_len++)
 		srb-&gt;cmnd[srb-&gt;cmd_len] = 0;
 
-	/* set command length to 12 bytes */
-	srb-&gt;cmd_len = 12;
-
 	/* send the command to the transport layer */
 	usb_stor_invoke_transport(srb, us);
 }</pre><hr><pre>commit 968b822c0023861ef6e4e15bb68582b36e89ad29
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Nov 3 12:03:38 2011 -0400

    USB: Remove the SAW_IRQ hcd flag
    
    The HCD_FLAG_SAW_IRQ flag was introduced in order to catch IRQ routing
    errors: If an URB was unlinked and the host controller hadn't gotten
    any IRQs, it seemed likely that the IRQs were directed to the wrong
    vector.
    
    This warning hasn't come up in many years, as far as I know; interrupt
    routing now seems to be well under control.  Therefore there's no
    reason to keep the flag around any more.  This patch (as1495) finally
    removes it.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/c67x00/c67x00-hcd.c b/drivers/usb/c67x00/c67x00-hcd.c
index d3e1356d091e..75e47b860a53 100644
--- a/drivers/usb/c67x00/c67x00-hcd.c
+++ b/drivers/usb/c67x00/c67x00-hcd.c
@@ -271,7 +271,6 @@ static void c67x00_hcd_irq(struct c67x00_sie *sie, u16 int_status, u16 msg)
 	if (int_status &amp; SOFEOP_FLG(sie-&gt;sie_num)) {
 		c67x00_ll_usb_clear_status(sie, SOF_EOP_IRQ_FLG);
 		c67x00_sched_kick(c67x00);
-		set_bit(HCD_FLAG_SAW_IRQ, &amp;hcd-&gt;flags);
 	}
 }
 
diff --git a/drivers/usb/core/hcd-pci.c b/drivers/usb/core/hcd-pci.c
index a004db35f6d0..d136b8f4c8a7 100644
--- a/drivers/usb/core/hcd-pci.c
+++ b/drivers/usb/core/hcd-pci.c
@@ -453,10 +453,6 @@ static int resume_common(struct device *dev, int event)
 
 	pci_set_master(pci_dev);
 
-	clear_bit(HCD_FLAG_SAW_IRQ, &amp;hcd-&gt;flags);
-	if (hcd-&gt;shared_hcd)
-		clear_bit(HCD_FLAG_SAW_IRQ, &amp;hcd-&gt;shared_hcd-&gt;flags);
-
 	if (hcd-&gt;driver-&gt;pci_resume &amp;&amp; !HCD_DEAD(hcd)) {
 		if (event != PM_EVENT_AUTO_RESUME)
 			wait_for_companions(pci_dev, hcd);
diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 13222d352a61..43a89e4ba928 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1168,20 +1168,6 @@ int usb_hcd_check_unlink_urb(struct usb_hcd *hcd, struct urb *urb,
 	if (urb-&gt;unlinked)
 		return -EBUSY;
 	urb-&gt;unlinked = status;
-
-	/* IRQ setup can easily be broken so that USB controllers
-	 * never get completion IRQs ... maybe even the ones we need to
-	 * finish unlinking the initial failed usb_set_address()
-	 * or device descriptor fetch.
-	 */
-	if (!HCD_SAW_IRQ(hcd) &amp;&amp; !is_root_hub(urb-&gt;dev)) {
-		dev_warn(hcd-&gt;self.controller, "Unlink after no-IRQ?  "
-			"Controller is probably using the wrong IRQ.\n");
-		set_bit(HCD_FLAG_SAW_IRQ, &amp;hcd-&gt;flags);
-		if (hcd-&gt;shared_hcd)
-			set_bit(HCD_FLAG_SAW_IRQ, &amp;hcd-&gt;shared_hcd-&gt;flags);
-	}
-
 	return 0;
 }
 EXPORT_SYMBOL_GPL(usb_hcd_check_unlink_urb);
@@ -2148,16 +2134,12 @@ irqreturn_t usb_hcd_irq (int irq, void *__hcd)
 	 */
 	local_irq_save(flags);
 
-	if (unlikely(HCD_DEAD(hcd) || !HCD_HW_ACCESSIBLE(hcd))) {
+	if (unlikely(HCD_DEAD(hcd) || !HCD_HW_ACCESSIBLE(hcd)))
 		rc = IRQ_NONE;
-	} else if (hcd-&gt;driver-&gt;irq(hcd) == IRQ_NONE) {
+	else if (hcd-&gt;driver-&gt;irq(hcd) == IRQ_NONE)
 		rc = IRQ_NONE;
-	} else {
-		set_bit(HCD_FLAG_SAW_IRQ, &amp;hcd-&gt;flags);
-		if (hcd-&gt;shared_hcd)
-			set_bit(HCD_FLAG_SAW_IRQ, &amp;hcd-&gt;shared_hcd-&gt;flags);
+	else
 		rc = IRQ_HANDLED;
-	}
 
 	local_irq_restore(flags);
 	return rc;
diff --git a/drivers/usb/host/hwa-hc.c b/drivers/usb/host/hwa-hc.c
index 9bfac657572e..565d79f06e6f 100644
--- a/drivers/usb/host/hwa-hc.c
+++ b/drivers/usb/host/hwa-hc.c
@@ -776,7 +776,6 @@ static int hwahc_probe(struct usb_interface *usb_iface,
 		goto error_alloc;
 	}
 	usb_hcd-&gt;wireless = 1;
-	set_bit(HCD_FLAG_SAW_IRQ, &amp;usb_hcd-&gt;flags);
 	wusbhc = usb_hcd_to_wusbhc(usb_hcd);
 	hwahc = container_of(wusbhc, struct hwahc, wusbhc);
 	hwahc_init(hwahc);
diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c
index 940321b3ec68..2f8c17381c6c 100644
--- a/drivers/usb/host/xhci-ring.c
+++ b/drivers/usb/host/xhci-ring.c
@@ -2389,17 +2389,7 @@ irqreturn_t xhci_irq(struct usb_hcd *hcd)
 
 irqreturn_t xhci_msi_irq(int irq, struct usb_hcd *hcd)
 {
-	irqreturn_t ret;
-	struct xhci_hcd *xhci;
-
-	xhci = hcd_to_xhci(hcd);
-	set_bit(HCD_FLAG_SAW_IRQ, &amp;hcd-&gt;flags);
-	if (xhci-&gt;shared_hcd)
-		set_bit(HCD_FLAG_SAW_IRQ, &amp;xhci-&gt;shared_hcd-&gt;flags);
-
-	ret = xhci_irq(hcd);
-
-	return ret;
+	return xhci_irq(hcd);
 }
 
 /****		Endpoint Ring Operations	****/
diff --git a/drivers/usb/musb/musb_core.c b/drivers/usb/musb/musb_core.c
index 20a28731c338..12044c473c38 100644
--- a/drivers/usb/musb/musb_core.c
+++ b/drivers/usb/musb/musb_core.c
@@ -661,7 +661,6 @@ static irqreturn_t musb_stage0_irq(struct musb *musb, u8 int_usb,
 
 		handled = IRQ_HANDLED;
 		musb-&gt;is_active = 1;
-		set_bit(HCD_FLAG_SAW_IRQ, &amp;hcd-&gt;flags);
 
 		musb-&gt;ep0_stage = MUSB_EP0_START;
 
diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 03354d557b79..b2f62f3a32af 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -99,7 +99,6 @@ struct usb_hcd {
 	 */
 	unsigned long		flags;
 #define HCD_FLAG_HW_ACCESSIBLE		0	/* at full power */
-#define HCD_FLAG_SAW_IRQ		1
 #define HCD_FLAG_POLL_RH		2	/* poll for rh status? */
 #define HCD_FLAG_POLL_PENDING		3	/* status has changed? */
 #define HCD_FLAG_WAKEUP_PENDING		4	/* root hub is resuming? */
@@ -110,7 +109,6 @@ struct usb_hcd {
 	 * be slightly faster than test_bit().
 	 */
 #define HCD_HW_ACCESSIBLE(hcd)	((hcd)-&gt;flags &amp; (1U &lt;&lt; HCD_FLAG_HW_ACCESSIBLE))
-#define HCD_SAW_IRQ(hcd)	((hcd)-&gt;flags &amp; (1U &lt;&lt; HCD_FLAG_SAW_IRQ))
 #define HCD_POLL_RH(hcd)	((hcd)-&gt;flags &amp; (1U &lt;&lt; HCD_FLAG_POLL_RH))
 #define HCD_POLL_PENDING(hcd)	((hcd)-&gt;flags &amp; (1U &lt;&lt; HCD_FLAG_POLL_PENDING))
 #define HCD_WAKEUP_PENDING(hcd)	((hcd)-&gt;flags &amp; (1U &lt;&lt; HCD_FLAG_WAKEUP_PENDING))</pre><hr><pre>commit f69e3120df82391a0ee8118e0a156239a06b2afb
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Nov 3 11:37:10 2011 -0400

    USB: XHCI: resume root hubs when the controller resumes
    
    This patch (as1494) fixes a problem in xhci-hcd's resume routine.
    When the controller is runtime-resumed, this can only mean that one of
    the two root hubs has made a wakeup request and therefore needs to be
    resumed as well.  Rather than try to determine which root hub requires
    attention (which might be difficult in the case where a new
    non-SuperSpeed device has been plugged in), the patch simply resumes
    both root hubs.
    
    Without this change, there is a race: The controller might be put back
    to sleep before it can activate its IRQ line, and the wakeup condition
    might never get handled.
    
    The patch also simplifies the logic in xhci_resume a little, combining
    some repeated flag settings into a single pair of statements.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Sarah Sharp &lt;sarah.a.sharp@linux.intel.com&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Tested-by: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c
index 747c5ead922b..aa94c0195791 100644
--- a/drivers/usb/host/xhci.c
+++ b/drivers/usb/host/xhci.c
@@ -799,7 +799,7 @@ int xhci_resume(struct xhci_hcd *xhci, bool hibernated)
 	u32			command, temp = 0;
 	struct usb_hcd		*hcd = xhci_to_hcd(xhci);
 	struct usb_hcd		*secondary_hcd;
-	int			retval;
+	int			retval = 0;
 
 	/* Wait a bit if either of the roothubs need to settle from the
 	 * transition into bus suspend.
@@ -809,6 +809,9 @@ int xhci_resume(struct xhci_hcd *xhci, bool hibernated)
 				xhci-&gt;bus_state[1].next_statechange))
 		msleep(100);
 
+	set_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
+	set_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;xhci-&gt;shared_hcd-&gt;flags);
+
 	spin_lock_irq(&amp;xhci-&gt;lock);
 	if (xhci-&gt;quirks &amp; XHCI_RESET_ON_RESUME)
 		hibernated = true;
@@ -878,20 +881,13 @@ int xhci_resume(struct xhci_hcd *xhci, bool hibernated)
 			return retval;
 		xhci_dbg(xhci, "Start the primary HCD\n");
 		retval = xhci_run(hcd-&gt;primary_hcd);
-		if (retval)
-			goto failed_restart;
-
-		xhci_dbg(xhci, "Start the secondary HCD\n");
-		retval = xhci_run(secondary_hcd);
 		if (!retval) {
-			set_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
-			set_bit(HCD_FLAG_HW_ACCESSIBLE,
-					&amp;xhci-&gt;shared_hcd-&gt;flags);
+			xhci_dbg(xhci, "Start the secondary HCD\n");
+			retval = xhci_run(secondary_hcd);
 		}
-failed_restart:
 		hcd-&gt;state = HC_STATE_SUSPENDED;
 		xhci-&gt;shared_hcd-&gt;state = HC_STATE_SUSPENDED;
-		return retval;
+		goto done;
 	}
 
 	/* step 4: set Run/Stop bit */
@@ -910,11 +906,14 @@ int xhci_resume(struct xhci_hcd *xhci, bool hibernated)
 	 * Running endpoints by ringing their doorbells
 	 */
 
-	set_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
-	set_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;xhci-&gt;shared_hcd-&gt;flags);
-
 	spin_unlock_irq(&amp;xhci-&gt;lock);
-	return 0;
+
+ done:
+	if (retval == 0) {
+		usb_hcd_resume_root_hub(hcd);
+		usb_hcd_resume_root_hub(xhci-&gt;shared_hcd);
+	}
+	return retval;
 }
 #endif	/* CONFIG_PM */
 </pre><hr><pre>commit 97ff22ee3b4cb3a334f7385e269773141aed702f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Oct 27 11:20:21 2011 -0400

    USB: workaround for bug in old version of GCC
    
    This patch (as1491) works around a bug in GCC-3.4.6, which is still
    supposed to be supported.  The number of microseconds in the udelay()
    call in quirk_usb_disable_ehci() is fixed at 100, but the compiler
    doesn't understand this and generates a link-time error.  So we
    replace the otherwise unused variable "delta" with a simple constant
    100.  This same pattern is already used in other delay loops in that
    source file.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Konrad Rzepecki &lt;krzepecki@dentonet.pl&gt;
    Tested-by: Konrad Rzepecki &lt;krzepecki@dentonet.pl&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/pci-quirks.c b/drivers/usb/host/pci-quirks.c
index 27a3dec32fa2..c7fd6ce11904 100644
--- a/drivers/usb/host/pci-quirks.c
+++ b/drivers/usb/host/pci-quirks.c
@@ -627,7 +627,7 @@ static void __devinit quirk_usb_disable_ehci(struct pci_dev *pdev)
 	void __iomem *base, *op_reg_base;
 	u32	hcc_params, cap, val;
 	u8	offset, cap_length;
-	int	wait_time, delta, count = 256/4;
+	int	wait_time, count = 256/4;
 
 	if (!mmio_resource_enabled(pdev, 0))
 		return;
@@ -673,11 +673,10 @@ static void __devinit quirk_usb_disable_ehci(struct pci_dev *pdev)
 		writel(val, op_reg_base + EHCI_USBCMD);
 
 		wait_time = 2000;
-		delta = 100;
 		do {
 			writel(0x3f, op_reg_base + EHCI_USBSTS);
-			udelay(delta);
-			wait_time -= delta;
+			udelay(100);
+			wait_time -= 100;
 			val = readl(op_reg_base + EHCI_USBSTS);
 			if ((val == ~(u32)0) || (val &amp; EHCI_USBSTS_HALTED)) {
 				break;</pre><hr><pre>commit b2c0a863e14676fa5760c6d828fd373288e2f64a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Nov 4 00:52:46 2011 +0100

    USB: Update last_busy time after autosuspend fails
    
    Originally, the runtime PM core would send an idle notification
    whenever a suspend attempt failed.  The idle callback routine could
    then schedule a delayed suspend for some time later.
    
    However this behavior was changed by commit
    f71648d73c1650b8b4aceb3856bebbde6daa3b86 (PM / Runtime: Remove idle
    notification after failing suspend).  No notifications were sent, and
    there was no clear mechanism to retry failed suspends.
    
    This caused problems for the usbhid driver, because it fails
    autosuspend attempts as long as a key is being held down.  A companion
    patch changes the PM core's behavior, but we also need to change the
    USB core.  In particular, this patch (as1493) updates the device's
    last_busy time when an autosuspend fails, so that the PM core will
    retry the autosuspend in the future when the delay time expires
    again.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Henrik Rydberg &lt;rydberg@euromail.se&gt;
    Cc: &lt;stable@kernel.org&gt;
    Acked-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;
    Signed-off-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 3b029a0a4787..c2c0ae57e7ff 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -1667,6 +1667,11 @@ int usb_runtime_suspend(struct device *dev)
 		return -EAGAIN;
 
 	status = usb_suspend_both(udev, PMSG_AUTO_SUSPEND);
+
+	/* Allow a retry if autosuspend failed temporarily */
+	if (status == -EAGAIN || status == -EBUSY)
+		usb_mark_last_busy(udev);
+
 	/* The PM core reacts badly unless the return code is 0,
 	 * -EAGAIN, or -EBUSY, so always return -EBUSY on an error.
 	 */</pre><hr><pre>commit 886486b792e4f6f96d4fbe8ec5bf20811cab7d6a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Nov 3 23:39:18 2011 +0100

    PM / Runtime: Automatically retry failed autosuspends
    
    Originally, the runtime PM core would send an idle notification
    whenever a suspend attempt failed.  The idle callback routine could
    then schedule a delayed suspend for some time later.
    
    However this behavior was changed by commit
    f71648d73c1650b8b4aceb3856bebbde6daa3b86 (PM / Runtime: Remove idle
    notification after failing suspend).  No notifications were sent, and
    there was no clear mechanism to retry failed suspends.
    
    This caused problems for the usbhid driver, because it fails
    autosuspend attempts as long as a key is being held down.  Therefore
    this patch (as1492) adds a mechanism for retrying failed
    autosuspends.  If the callback routine updates the last_busy field so
    that the next autosuspend expiration time is in the future, the
    autosuspend will automatically be rescheduled.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Henrik Rydberg &lt;rydberg@euromail.se&gt;
    Cc: &lt;stable@kernel.org&gt;
    Signed-off-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;

diff --git a/Documentation/power/runtime_pm.txt b/Documentation/power/runtime_pm.txt
index 0e856088db7c..5336149f831b 100644
--- a/Documentation/power/runtime_pm.txt
+++ b/Documentation/power/runtime_pm.txt
@@ -789,6 +789,16 @@ will behave normally, not taking the autosuspend delay into account.
 Similarly, if the power.use_autosuspend field isn't set then the autosuspend
 helper functions will behave just like the non-autosuspend counterparts.
 
+Under some circumstances a driver or subsystem may want to prevent a device
+from autosuspending immediately, even though the usage counter is zero and the
+autosuspend delay time has expired.  If the -&gt;runtime_suspend() callback
+returns -EAGAIN or -EBUSY, and if the next autosuspend delay expiration time is
+in the future (as it normally would be if the callback invoked
+pm_runtime_mark_last_busy()), the PM core will automatically reschedule the
+autosuspend.  The -&gt;runtime_suspend() callback can't do this rescheduling
+itself because no suspend requests of any kind are accepted while the device is
+suspending (i.e., while the callback is running).
+
 The implementation is well suited for asynchronous use in interrupt contexts.
 However such use inevitably involves races, because the PM core can't
 synchronize -&gt;runtime_suspend() callbacks with the arrival of I/O requests.
diff --git a/drivers/base/power/runtime.c b/drivers/base/power/runtime.c
index 18ef87e525fa..124dbf60c9bf 100644
--- a/drivers/base/power/runtime.c
+++ b/drivers/base/power/runtime.c
@@ -293,6 +293,9 @@ static int rpm_callback(int (*cb)(struct device *), struct device *dev)
  * the callback was running then carry it out, otherwise send an idle
  * notification for its parent (if the suspend succeeded and both
  * ignore_children of parent-&gt;power and irq_safe of dev-&gt;power are not set).
+ * If -&gt;runtime_suspend failed with -EAGAIN or -EBUSY, and if the RPM_AUTO
+ * flag is set and the next autosuspend-delay expiration time is in the
+ * future, schedule another autosuspend attempt.
  *
  * This function must be called under dev-&gt;power.lock with interrupts disabled.
  */
@@ -413,10 +416,21 @@ static int rpm_suspend(struct device *dev, int rpmflags)
 	if (retval) {
 		__update_runtime_status(dev, RPM_ACTIVE);
 		dev-&gt;power.deferred_resume = false;
-		if (retval == -EAGAIN || retval == -EBUSY)
+		if (retval == -EAGAIN || retval == -EBUSY) {
 			dev-&gt;power.runtime_error = 0;
-		else
+
+			/*
+			 * If the callback routine failed an autosuspend, and
+			 * if the last_busy time has been updated so that there
+			 * is a new autosuspend expiration time, automatically
+			 * reschedule another autosuspend.
+			 */
+			if ((rpmflags &amp; RPM_AUTO) &amp;&amp;
+			    pm_runtime_autosuspend_expiration(dev) != 0)
+				goto repeat;
+		} else {
 			pm_runtime_cancel_pending(dev);
+		}
 		wake_up_all(&amp;dev-&gt;power.wait_queue);
 		goto out;
 	}</pre><hr><pre>commit 68aa95d5d4de31c9348c1628ffa85c805305ebc5
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Oct 12 10:39:14 2011 -0400

    EHCI: workaround for MosChip controller bug
    
    This patch (as1489) works around a hardware bug in MosChip EHCI
    controllers.  Evidently when one of these controllers increments the
    frame-index register, it changes the three low-order bits (the
    microframe counter) before changing the higher order bits (the frame
    counter).  If the register is read at just the wrong time, the value
    obtained is too low by 8.
    
    When the appropriate quirk flag is set, we work around this problem by
    reading the frame-index register a second time if the first value's
    three low-order bits are all 0.  This gives the hardware a chance to
    finish updating the register, yielding the correct value.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Jason N Pitt &lt;jpitt@fhcrc.org&gt;
    CC: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-dbg.c b/drivers/usb/host/ehci-dbg.c
index 9952505d2357..d6d74d2e09f4 100644
--- a/drivers/usb/host/ehci-dbg.c
+++ b/drivers/usb/host/ehci-dbg.c
@@ -821,7 +821,7 @@ static ssize_t fill_registers_buffer(struct debug_buffer *buf)
 	next += temp;
 
 	temp = scnprintf (next, size, "uframe %04x\n",
-			ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;frame_index));
+			ehci_read_frame_index(ehci));
 	size -= temp;
 	next += temp;
 
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 05abbcd93cf4..59e81615e09c 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1195,8 +1195,7 @@ ehci_endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 static int ehci_get_frame (struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
-	return (ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;frame_index) &gt;&gt; 3) %
-		ehci-&gt;periodic_size;
+	return (ehci_read_frame_index(ehci) &gt;&gt; 3) % ehci-&gt;periodic_size;
 }
 
 /*-------------------------------------------------------------------------*/
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 8311de7c0a75..f4b627d343ac 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -224,6 +224,11 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 			pci_dev_put(p_smbus);
 		}
 		break;
+	case PCI_VENDOR_ID_NETMOS:
+		/* MosChip frame-index-register bug */
+		ehci_info(ehci, "applying MosChip frame-index workaround\n");
+		ehci-&gt;frame_index_bug = 1;
+		break;
 	}
 
 	/* optional debug port, normally in the first BAR */
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 488151bb45cb..2e829fae6482 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -36,6 +36,27 @@
 
 static int ehci_get_frame (struct usb_hcd *hcd);
 
+#ifdef CONFIG_PCI
+
+static unsigned ehci_read_frame_index(struct ehci_hcd *ehci)
+{
+	unsigned uf;
+
+	/*
+	 * The MosChip MCS9990 controller updates its microframe counter
+	 * a little before the frame counter, and occasionally we will read
+	 * the invalid intermediate value.  Avoid problems by checking the
+	 * microframe number (the low-order 3 bits); if they are 0 then
+	 * re-read the register to get the correct value.
+	 */
+	uf = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;frame_index);
+	if (unlikely(ehci-&gt;frame_index_bug &amp;&amp; ((uf &amp; 7) == 0)))
+		uf = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;frame_index);
+	return uf;
+}
+
+#endif
+
 /*-------------------------------------------------------------------------*/
 
 /*
@@ -481,7 +502,7 @@ static int enable_periodic (struct ehci_hcd *ehci)
 	/* posted write ... PSS happens later */
 
 	/* make sure ehci_work scans these */
-	ehci-&gt;next_uframe = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;frame_index)
+	ehci-&gt;next_uframe = ehci_read_frame_index(ehci)
 		% (ehci-&gt;periodic_size &lt;&lt; 3);
 	if (unlikely(ehci-&gt;broken_periodic))
 		ehci-&gt;last_periodic_enable = ktime_get_real();
@@ -1408,7 +1429,7 @@ iso_stream_schedule (
 		goto fail;
 	}
 
-	now = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;frame_index) &amp; (mod - 1);
+	now = ehci_read_frame_index(ehci) &amp; (mod - 1);
 
 	/* Typical case: reuse current schedule, stream is still active.
 	 * Hopefully there are no gaps from the host falling behind
@@ -2275,7 +2296,7 @@ scan_periodic (struct ehci_hcd *ehci)
 	 */
 	now_uframe = ehci-&gt;next_uframe;
 	if (ehci-&gt;rh_state == EHCI_RH_RUNNING) {
-		clock = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;frame_index);
+		clock = ehci_read_frame_index(ehci);
 		clock_frame = (clock &gt;&gt; 3) &amp; (ehci-&gt;periodic_size - 1);
 	} else  {
 		clock = now_uframe + mod - 1;
@@ -2454,8 +2475,7 @@ scan_periodic (struct ehci_hcd *ehci)
 					|| ehci-&gt;periodic_sched == 0)
 				break;
 			ehci-&gt;next_uframe = now_uframe;
-			now = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;frame_index) &amp;
-					(mod - 1);
+			now = ehci_read_frame_index(ehci) &amp; (mod - 1);
 			if (now_uframe == now)
 				break;
 
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index c161d97de7dd..0a5fda73b3f2 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -146,6 +146,7 @@ struct ehci_hcd {			/* one per controller */
 	unsigned		fs_i_thresh:1;	/* Intel iso scheduling */
 	unsigned		use_dummy_qh:1;	/* AMD Frame List table quirk*/
 	unsigned		has_synopsys_hc_bug:1; /* Synopsys HC */
+	unsigned		frame_index_bug:1; /* MosChip (AKA NetMos) */
 
 	/* required for usb32 quirk */
 	#define OHCI_CTRL_HCFS          (3 &lt;&lt; 6)
@@ -747,6 +748,22 @@ static inline u32 hc32_to_cpup (const struct ehci_hcd *ehci, const __hc32 *x)
 
 /*-------------------------------------------------------------------------*/
 
+#ifdef CONFIG_PCI
+
+/* For working around the MosChip frame-index-register bug */
+static unsigned ehci_read_frame_index(struct ehci_hcd *ehci);
+
+#else
+
+static inline unsigned ehci_read_frame_index(struct ehci_hcd *ehci)
+{
+	return ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;frame_index);
+}
+
+#endif
+
+/*-------------------------------------------------------------------------*/
+
 #ifndef DEBUG
 #define STUB_DEBUG_FILES
 #endif	/* DEBUG */</pre>
    <div class="pagination">
        <a href='2_53.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><span>[54]</span><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_55.html'>Next&gt;&gt;</a>
    <div>
</body>
