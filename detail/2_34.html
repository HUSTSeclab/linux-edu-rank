<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_33.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><span>[34]</span><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_35.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 9d8924297cd9c256c23c02abae40202563452453
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 30 10:46:00 2013 -0400

    USB: fix build error when CONFIG_PM_SLEEP isn't enabled
    
    This patch fixes a build error that occurs when CONFIG_PM is enabled
    and CONFIG_PM_SLEEP isn't:
    
    &gt;&gt; drivers/usb/host/ohci-pci.c:294:10: error: 'usb_hcd_pci_pm_ops' undeclared here (not in a function)
          .pm = &amp;usb_hcd_pci_pm_ops
    
    Since the usb_hcd_pci_pm_ops structure is defined and used when
    CONFIG_PM is enabled, its declaration should not be protected by
    CONFIG_PM_SLEEP.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: kbuild test robot &lt;fengguang.wu@intel.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index a9c7d44bd2ed..75efc45eaa2f 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -428,7 +428,7 @@ extern int usb_hcd_pci_probe(struct pci_dev *dev,
 extern void usb_hcd_pci_remove(struct pci_dev *dev);
 extern void usb_hcd_pci_shutdown(struct pci_dev *dev);
 
-#ifdef CONFIG_PM_SLEEP
+#ifdef CONFIG_PM
 extern const struct dev_pm_ops usb_hcd_pci_pm_ops;
 #endif
 #endif /* CONFIG_PCI */</pre><hr><pre>commit 69820e01aa756b8d228143d997f71523c1e97984
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Aug 26 15:01:40 2013 -0400

    USB: OHCI: Allow runtime PM without system sleep
    
    Since ohci-hcd supports runtime PM, the .pm field in its pci_driver
    structure should be protected by CONFIG_PM rather than
    CONFIG_PM_SLEEP.
    
    Without this change, OHCI controllers won't do runtime suspend if
    system suspend or hibernation isn't enabled.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    cc: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 08613e241894..767a5eeff848 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -289,7 +289,7 @@ static struct pci_driver ohci_pci_driver = {
 	.remove =	usb_hcd_pci_remove,
 	.shutdown =	usb_hcd_pci_shutdown,
 
-#ifdef CONFIG_PM_SLEEP
+#ifdef CONFIG_PM
 	.driver =	{
 		.pm =	&amp;usb_hcd_pci_pm_ops
 	},</pre><hr><pre>commit d3474049ab6cfcf14274f5ab9f20c8f50b083eab
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Aug 26 10:53:53 2013 -0400

    USB: OHCI: fix build error related to ohci_suspend/resume
    
    Commit 9a11899c5e69 (USB: OHCI: add missing PCI PM callbacks to
    ohci-pci.c) added missing ohci_suspend and ohci_resume callback
    pointers, but forgot that these callbacks are declared and defined
    only when CONFIG_PM is enabled.
    
    This patch adds a preprocessor conditional to avoid build errors when
    PM is disabled.
    
    Reported-by: Guenter Roeck &lt;linux@roeck-us.net&gt;
    Tested-by: Guenter Roeck &lt;linux@roeck-us.net&gt;
    Reported-by: Meelis Roos &lt;mroos@linux.ee&gt;,
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 0f1d193fef02..279b04910f00 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -305,9 +305,11 @@ static int __init ohci_pci_init(void)
 
 	ohci_init_driver(&amp;ohci_pci_hc_driver, &amp;pci_overrides);
 
+#ifdef	CONFIG_PM
 	/* Entries for the PCI suspend/resume callbacks are special */
 	ohci_pci_hc_driver.pci_suspend = ohci_suspend;
 	ohci_pci_hc_driver.pci_resume = ohci_resume;
+#endif
 
 	return pci_register_driver(&amp;ohci_pci_driver);
 }</pre><hr><pre>commit 9a11899c5e699a8d2551692dfcd4372e39dcbdf6
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 21 10:33:17 2013 -0400

    USB: OHCI: add missing PCI PM callbacks to ohci-pci.c
    
    Commit c1117afb8589 (USB: OHCI: make ohci-pci a separate driver)
    neglected to preserve the entries for the pci_suspend and pci_resume
    driver callbacks.  As a result, OHCI controllers don't work properly
    during suspend and after hibernation.
    
    This patch adds the missing callbacks to the driver.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Steve Cotton &lt;steve@s.cotton.clara.co.uk&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 08613e241894..0f1d193fef02 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -304,6 +304,11 @@ static int __init ohci_pci_init(void)
 	pr_info("%s: " DRIVER_DESC "\n", hcd_name);
 
 	ohci_init_driver(&amp;ohci_pci_hc_driver, &amp;pci_overrides);
+
+	/* Entries for the PCI suspend/resume callbacks are special */
+	ohci_pci_hc_driver.pci_suspend = ohci_suspend;
+	ohci_pci_hc_driver.pci_resume = ohci_resume;
+
 	return pci_register_driver(&amp;ohci_pci_driver);
 }
 module_init(ohci_pci_init);</pre><hr><pre>commit aa5ceae24bf8dff1d6fe87c6c4b08e69c6d33550
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jul 30 15:39:02 2013 -0400

    USB: handle LPM errors during device suspend correctly
    
    The hub driver's usb_port_suspend() routine doesn't handle errors
    related to Link Power Management properly.  It always returns failure,
    it doesn't try to clean up the wakeup setting, (in the case of system
    sleep) it doesn't try to go ahead with the port suspend regardless,
    and it doesn't try to apply the new power-off mechanism.
    
    This patch fixes these problems.
    
    Note: Sarah fixed this patch to apply against 3.11, since the original
    commit (4fae6f0fa86f92e6bc7429371b1e177ad0aaac66 "USB: handle LPM errors
    during device suspend correctly") called usb_disable_remote_wakeup,
    which won't be added until 3.12.
    
    This patch should be backported to kernels as old as 3.5, that
    contain the commit 8306095fd2c1100e8244c09bf560f97aca5a311d "USB:
    Disable USB 3.0 LPM in critical sections.".  There will be merge
    conflicts, since LTM wasn't added until 3.6.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Sarah Sharp &lt;sarah.a.sharp@linux.intel.com&gt;
    Cc: stable@vger.kernel.org

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 558313de4911..8287953e066c 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2918,7 +2918,6 @@ int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
 {
 	struct usb_hub	*hub = usb_hub_to_struct_hub(udev-&gt;parent);
 	struct usb_port *port_dev = hub-&gt;ports[udev-&gt;portnum - 1];
-	enum pm_qos_flags_status pm_qos_stat;
 	int		port1 = udev-&gt;portnum;
 	int		status;
 	bool		really_suspend = true;
@@ -2956,7 +2955,7 @@ int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
 					status);
 			/* bail if autosuspend is requested */
 			if (PMSG_IS_AUTO(msg))
-				return status;
+				goto err_wakeup;
 		}
 	}
 
@@ -2965,14 +2964,16 @@ int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
 		usb_set_usb2_hardware_lpm(udev, 0);
 
 	if (usb_disable_ltm(udev)) {
-		dev_err(&amp;udev-&gt;dev, "%s Failed to disable LTM before suspend\n.",
-				__func__);
-		return -ENOMEM;
+		dev_err(&amp;udev-&gt;dev, "Failed to disable LTM before suspend\n.");
+		status = -ENOMEM;
+		if (PMSG_IS_AUTO(msg))
+			goto err_ltm;
 	}
 	if (usb_unlocked_disable_lpm(udev)) {
-		dev_err(&amp;udev-&gt;dev, "%s Failed to disable LPM before suspend\n.",
-				__func__);
-		return -ENOMEM;
+		dev_err(&amp;udev-&gt;dev, "Failed to disable LPM before suspend\n.");
+		status = -ENOMEM;
+		if (PMSG_IS_AUTO(msg))
+			goto err_lpm3;
 	}
 
 	/* see 7.1.7.6 */
@@ -3000,28 +3001,31 @@ int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
 	if (status) {
 		dev_dbg(hub-&gt;intfdev, "can't suspend port %d, status %d\n",
 				port1, status);
-		/* paranoia:  "should not happen" */
-		if (udev-&gt;do_remote_wakeup) {
-			if (!hub_is_superspeed(hub-&gt;hdev)) {
-				(void) usb_control_msg(udev,
-						usb_sndctrlpipe(udev, 0),
-						USB_REQ_CLEAR_FEATURE,
-						USB_RECIP_DEVICE,
-						USB_DEVICE_REMOTE_WAKEUP, 0,
-						NULL, 0,
-						USB_CTRL_SET_TIMEOUT);
-			} else
-				(void) usb_disable_function_remotewakeup(udev);
-
-		}
 
+		/* Try to enable USB3 LPM and LTM again */
+		usb_unlocked_enable_lpm(udev);
+ err_lpm3:
+		usb_enable_ltm(udev);
+ err_ltm:
 		/* Try to enable USB2 hardware LPM again */
 		if (udev-&gt;usb2_hw_lpm_capable == 1)
 			usb_set_usb2_hardware_lpm(udev, 1);
 
-		/* Try to enable USB3 LTM and LPM again */
-		usb_enable_ltm(udev);
-		usb_unlocked_enable_lpm(udev);
+		if (udev-&gt;do_remote_wakeup) {
+			if (udev-&gt;speed &lt; USB_SPEED_SUPER)
+				usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
+						USB_REQ_CLEAR_FEATURE,
+						USB_RECIP_DEVICE,
+						USB_DEVICE_REMOTE_WAKEUP, 0,
+						NULL, 0, USB_CTRL_SET_TIMEOUT);
+			else
+				usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
+						USB_REQ_CLEAR_FEATURE,
+						USB_RECIP_INTERFACE,
+						USB_INTRF_FUNC_SUSPEND, 0,
+						NULL, 0, USB_CTRL_SET_TIMEOUT);
+		}
+ err_wakeup:
 
 		/* System sleep transitions should never fail */
 		if (!PMSG_IS_AUTO(msg))
@@ -3043,14 +3047,15 @@ int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
 	 * Check whether current status meets the requirement of
 	 * usb port power off mechanism
 	 */
-	pm_qos_stat = dev_pm_qos_flags(&amp;port_dev-&gt;dev,
-			PM_QOS_FLAG_NO_POWER_OFF);
-	if (!udev-&gt;do_remote_wakeup
-			&amp;&amp; pm_qos_stat != PM_QOS_FLAGS_ALL
-			&amp;&amp; udev-&gt;persist_enabled
-			&amp;&amp; !status) {
-		pm_runtime_put_sync(&amp;port_dev-&gt;dev);
-		port_dev-&gt;did_runtime_put = true;
+	if (status == 0 &amp;&amp; !udev-&gt;do_remote_wakeup &amp;&amp; udev-&gt;persist_enabled) {
+		enum pm_qos_flags_status pm_qos_stat;
+
+		pm_qos_stat = dev_pm_qos_flags(&amp;port_dev-&gt;dev,
+				PM_QOS_FLAG_NO_POWER_OFF);
+		if (pm_qos_stat != PM_QOS_FLAGS_ALL) {
+			pm_runtime_put_sync(&amp;port_dev-&gt;dev);
+			port_dev-&gt;did_runtime_put = true;
+		}
 	}
 
 	usb_mark_last_busy(hub-&gt;hdev);</pre><hr><pre>commit 24f531371de17010f2b1b57d90e42240032e7733
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 7 10:58:05 2013 -0400

    USB: EHCI: accept very late isochronous URBs
    
    Since commits 4005ad4390bf (EHCI: implement new semantics for
    URB_ISO_ASAP) and c75c5ab575af (ALSA: USB: adjust for changed 3.8 USB
    API) became widely distributed, people have been experiencing problems
    with audio transfers.  The slightest underrun causes complete failure,
    requiring the audio stream to be restarted.
    
    It turns out that the current isochronous API doesn't handle underruns
    in the best way.  The ALSA developers would much rather have transfers
    that are submitted too late be accepted and complete in the normal
    fashion, rather than being refused outright.
    
    This patch implements the requested approach.  When an isochronous URB
    submission is so late that all its scheduled slots have already
    expired, a debugging message will be printed in the log and the URB
    will be accepted as usual.  Assuming it was submitted by a completion
    handler (which is normally the case), it will complete shortly
    thereafter with all the usb_iso_packet_descriptor status fields marked
    -EXDEV.
    
    This fixes (for ehci-hcd)
    
            https://bugs.launchpad.net/ubuntu/+source/linux/+bug/1191603
    
    It should be applied to all kernels that include commit 4005ad4390bf.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Maksim Boyko &lt;maksboyko@yandex.ru&gt;
    CC: Clemens Ladisch &lt;clemens@ladisch.de&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index f80d0330d548..8e3c878f38cf 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -1391,21 +1391,20 @@ iso_stream_schedule (
 
 		/* Behind the scheduling threshold? */
 		if (unlikely(start &lt; next)) {
+			unsigned now2 = (now - base) &amp; (mod - 1);
 
 			/* USB_ISO_ASAP: Round up to the first available slot */
 			if (urb-&gt;transfer_flags &amp; URB_ISO_ASAP)
 				start += (next - start + period - 1) &amp; -period;
 
 			/*
-			 * Not ASAP: Use the next slot in the stream.  If
-			 * the entire URB falls before the threshold, fail.
+			 * Not ASAP: Use the next slot in the stream,
+			 * no matter what.
 			 */
-			else if (start + span - period &lt; next) {
-				ehci_dbg(ehci, "iso urb late %p (%u+%u &lt; %u)\n",
+			else if (start + span - period &lt; now2) {
+				ehci_dbg(ehci, "iso underrun %p (%u+%u &lt; %u)\n",
 						urb, start + base,
-						span - period, next + base);
-				status = -EXDEV;
-				goto fail;
+						span - period, now2 + base);
 			}
 		}
 </pre><hr><pre>commit 6753f4cf29046f4a2ae68c3a93bf6e6e6dce9fb7
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Aug 1 17:09:28 2013 -0400

    USB: EHCI: don't depend on hardware for tracking port resets and resumes
    
    In theory, an EHCI controller can turn off the PORT_RESUME or
    PORT_RESET bits in a port status register all by itself (and some
    controllers actually do this).  We shouldn't depend on these bits
    being set correctly.
    
    This patch rearranges the code in ehci-hcd that handles completion of
    port resets and resumes.  We guarantee that ehci-&gt;reset_done[portnum]
    is nonzero if a reset or resume is in progress, and that the portnum
    bit is set in ehci-&gt;resuming_ports if the operation is a resume.  (To
    help enforce this guarantee, the patch prevents suspended ports from
    being reset.)  Therefore it's not necessary to look at the port status
    bits to learn what's going on.
    
    The patch looks bigger than it really is, because it changes the
    indentation level of a sizeable region of code.  Most of what it
    actually does is interchange some tests.  The only functional changes
    are testing reset_done and resuming_ports rather than PORT_RESUME and
    PORT_RESET, removing a now-unnecessary check for spontaneous
    resets of the PORT_RESUME and PORT_RESET bits, and preventing a
    suspended or resuming port from being reset.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 6d0e59306ed9..6e69ee1a3371 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -867,11 +867,11 @@ static int ehci_hub_control (
 			}
 		}
 
-		/* whoever resumes must GetPortStatus to complete it!! */
-		if (temp &amp; PORT_RESUME) {
+		/* no reset or resume pending */
+		if (!ehci-&gt;reset_done[wIndex]) {
 
 			/* Remote Wakeup received? */
-			if (!ehci-&gt;reset_done[wIndex]) {
+			if (temp &amp; PORT_RESUME) {
 				/* resume signaling for 20 msec */
 				ehci-&gt;reset_done[wIndex] = jiffies
 						+ msecs_to_jiffies(20);
@@ -882,35 +882,32 @@ static int ehci_hub_control (
 						ehci-&gt;reset_done[wIndex]);
 			}
 
-			/* resume completed? */
-			else if (time_after_eq(jiffies,
-					ehci-&gt;reset_done[wIndex])) {
-				clear_bit(wIndex, &amp;ehci-&gt;suspended_ports);
-				set_bit(wIndex, &amp;ehci-&gt;port_c_suspend);
-				ehci-&gt;reset_done[wIndex] = 0;
-				usb_hcd_end_port_resume(&amp;hcd-&gt;self, wIndex);
-
-				/* stop resume signaling */
-				temp &amp;= ~(PORT_RWC_BITS |
-						PORT_SUSPEND | PORT_RESUME);
-				ehci_writel(ehci, temp, status_reg);
-				clear_bit(wIndex, &amp;ehci-&gt;resuming_ports);
-				retval = ehci_handshake(ehci, status_reg,
-					   PORT_RESUME, 0, 2000 /* 2msec */);
-				if (retval != 0) {
-					ehci_err(ehci,
-						"port %d resume error %d\n",
+		/* reset or resume not yet complete */
+		} else if (!time_after_eq(jiffies, ehci-&gt;reset_done[wIndex])) {
+			;	/* wait until it is complete */
+
+		/* resume completed */
+		} else if (test_bit(wIndex, &amp;ehci-&gt;resuming_ports)) {
+			clear_bit(wIndex, &amp;ehci-&gt;suspended_ports);
+			set_bit(wIndex, &amp;ehci-&gt;port_c_suspend);
+			ehci-&gt;reset_done[wIndex] = 0;
+			usb_hcd_end_port_resume(&amp;hcd-&gt;self, wIndex);
+
+			/* stop resume signaling */
+			temp &amp;= ~(PORT_RWC_BITS | PORT_SUSPEND | PORT_RESUME);
+			ehci_writel(ehci, temp, status_reg);
+			clear_bit(wIndex, &amp;ehci-&gt;resuming_ports);
+			retval = ehci_handshake(ehci, status_reg,
+					PORT_RESUME, 0, 2000 /* 2msec */);
+			if (retval != 0) {
+				ehci_err(ehci, "port %d resume error %d\n",
 						wIndex + 1, retval);
-					goto error;
-				}
-				temp = ehci_readl(ehci, status_reg);
+				goto error;
 			}
-		}
+			temp = ehci_readl(ehci, status_reg);
 
 		/* whoever resets must GetPortStatus to complete it!! */
-		if ((temp &amp; PORT_RESET)
-				&amp;&amp; time_after_eq(jiffies,
-					ehci-&gt;reset_done[wIndex])) {
+		} else {
 			status |= USB_PORT_STAT_C_RESET &lt;&lt; 16;
 			ehci-&gt;reset_done [wIndex] = 0;
 
@@ -933,11 +930,6 @@ static int ehci_hub_control (
 					ehci_readl(ehci, status_reg));
 		}
 
-		if (!(temp &amp; (PORT_RESUME|PORT_RESET))) {
-			ehci-&gt;reset_done[wIndex] = 0;
-			clear_bit(wIndex, &amp;ehci-&gt;resuming_ports);
-		}
-
 		/* transfer dedicated ports to the companion hc */
 		if ((temp &amp; PORT_CONNECT) &amp;&amp;
 				test_bit(wIndex, &amp;ehci-&gt;companion_ports)) {
@@ -1058,7 +1050,7 @@ static int ehci_hub_control (
 						status_reg);
 			break;
 		case USB_PORT_FEAT_RESET:
-			if (temp &amp; PORT_RESUME)
+			if (temp &amp; (PORT_SUSPEND|PORT_RESUME))
 				goto error;
 			/* line status bits may report this as low speed,
 			 * which can be fine if this root hub has a</pre><hr><pre>commit 3a20446f02bfb71d68ae9ec673268bb7823f878c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Aug 1 17:09:23 2013 -0400

    USB: EHCI: keep better track of resuming ports
    
    The ehci-hcd driver isn't as careful as it should be about the way it
    uses ehci-&gt;resuming_ports.  One of the omissions was fixed recently by
    commit 47a64a13d54 (USB: EHCI: Fix resume signalling on remote
    wakeup), but there are other places that need attention:
    
            When a port's suspend feature is explicitly cleared, the
            corresponding bit in resuming_ports should be set and the core
            should be notified about the port resume.
    
            We don't need to clear a resuming_ports bit when a reset
            completes.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 6dce37555c4f..6d0e59306ed9 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -801,6 +801,8 @@ static int ehci_hub_control (
 			ehci_writel(ehci, temp | PORT_RESUME, status_reg);
 			ehci-&gt;reset_done[wIndex] = jiffies
 					+ msecs_to_jiffies(20);
+			set_bit(wIndex, &amp;ehci-&gt;resuming_ports);
+			usb_hcd_start_port_resume(&amp;hcd-&gt;self, wIndex);
 			break;
 		case USB_PORT_FEAT_C_SUSPEND:
 			clear_bit(wIndex, &amp;ehci-&gt;port_c_suspend);
@@ -911,7 +913,6 @@ static int ehci_hub_control (
 					ehci-&gt;reset_done[wIndex])) {
 			status |= USB_PORT_STAT_C_RESET &lt;&lt; 16;
 			ehci-&gt;reset_done [wIndex] = 0;
-			clear_bit(wIndex, &amp;ehci-&gt;resuming_ports);
 
 			/* force reset to complete */
 			ehci_writel(ehci, temp &amp; ~(PORT_RWC_BITS | PORT_RESET),</pre><hr><pre>commit 4fae6f0fa86f92e6bc7429371b1e177ad0aaac66
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jul 30 15:39:02 2013 -0400

    USB: handle LPM errors during device suspend correctly
    
    The hub driver's usb_port_suspend() routine doesn't handle errors
    related to Link Power Management properly.  It always returns failure,
    it doesn't try to clean up the wakeup setting, (in the case of system
    sleep) it doesn't try to go ahead with the port suspend regardless,
    and it doesn't try to apply the new power-off mechanism.
    
    This patch fixes these problems.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Sarah Sharp &lt;sarah.a.sharp@linux.intel.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index c376c8bad40c..0416f835cfee 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2948,7 +2948,6 @@ int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
 {
 	struct usb_hub	*hub = usb_hub_to_struct_hub(udev-&gt;parent);
 	struct usb_port *port_dev = hub-&gt;ports[udev-&gt;portnum - 1];
-	enum pm_qos_flags_status pm_qos_stat;
 	int		port1 = udev-&gt;portnum;
 	int		status;
 	bool		really_suspend = true;
@@ -2966,7 +2965,7 @@ int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
 					status);
 			/* bail if autosuspend is requested */
 			if (PMSG_IS_AUTO(msg))
-				return status;
+				goto err_wakeup;
 		}
 	}
 
@@ -2975,14 +2974,16 @@ int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
 		usb_set_usb2_hardware_lpm(udev, 0);
 
 	if (usb_disable_ltm(udev)) {
-		dev_err(&amp;udev-&gt;dev, "%s Failed to disable LTM before suspend\n.",
-				__func__);
-		return -ENOMEM;
+		dev_err(&amp;udev-&gt;dev, "Failed to disable LTM before suspend\n.");
+		status = -ENOMEM;
+		if (PMSG_IS_AUTO(msg))
+			goto err_ltm;
 	}
 	if (usb_unlocked_disable_lpm(udev)) {
-		dev_err(&amp;udev-&gt;dev, "%s Failed to disable LPM before suspend\n.",
-				__func__);
-		return -ENOMEM;
+		dev_err(&amp;udev-&gt;dev, "Failed to disable LPM before suspend\n.");
+		status = -ENOMEM;
+		if (PMSG_IS_AUTO(msg))
+			goto err_lpm3;
 	}
 
 	/* see 7.1.7.6 */
@@ -3010,17 +3011,19 @@ int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
 	if (status) {
 		dev_dbg(hub-&gt;intfdev, "can't suspend port %d, status %d\n",
 				port1, status);
-		/* paranoia:  "should not happen" */
-		if (udev-&gt;do_remote_wakeup)
-			(void) usb_disable_remote_wakeup(udev);
 
+		/* Try to enable USB3 LPM and LTM again */
+		usb_unlocked_enable_lpm(udev);
+ err_lpm3:
+		usb_enable_ltm(udev);
+ err_ltm:
 		/* Try to enable USB2 hardware LPM again */
 		if (udev-&gt;usb2_hw_lpm_capable == 1)
 			usb_set_usb2_hardware_lpm(udev, 1);
 
-		/* Try to enable USB3 LTM and LPM again */
-		usb_enable_ltm(udev);
-		usb_unlocked_enable_lpm(udev);
+		if (udev-&gt;do_remote_wakeup)
+			(void) usb_disable_remote_wakeup(udev);
+ err_wakeup:
 
 		/* System sleep transitions should never fail */
 		if (!PMSG_IS_AUTO(msg))
@@ -3042,14 +3045,15 @@ int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
 	 * Check whether current status meets the requirement of
 	 * usb port power off mechanism
 	 */
-	pm_qos_stat = dev_pm_qos_flags(&amp;port_dev-&gt;dev,
-			PM_QOS_FLAG_NO_POWER_OFF);
-	if (!udev-&gt;do_remote_wakeup
-			&amp;&amp; pm_qos_stat != PM_QOS_FLAGS_ALL
-			&amp;&amp; udev-&gt;persist_enabled
-			&amp;&amp; !status) {
-		pm_runtime_put_sync(&amp;port_dev-&gt;dev);
-		port_dev-&gt;did_runtime_put = true;
+	if (status == 0 &amp;&amp; !udev-&gt;do_remote_wakeup &amp;&amp; udev-&gt;persist_enabled) {
+		enum pm_qos_flags_status pm_qos_stat;
+
+		pm_qos_stat = dev_pm_qos_flags(&amp;port_dev-&gt;dev,
+				PM_QOS_FLAG_NO_POWER_OFF);
+		if (pm_qos_stat != PM_QOS_FLAGS_ALL) {
+			pm_runtime_put_sync(&amp;port_dev-&gt;dev);
+			port_dev-&gt;did_runtime_put = true;
+		}
 	}
 
 	usb_mark_last_busy(hub-&gt;hdev);</pre><hr><pre>commit 28e861658e23ca94692f98e245d254c75c8088a7
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jul 30 15:37:33 2013 -0400

    USB: refactor code for enabling/disabling remote wakeup
    
    The hub driver is inconsistent in its organization of code for
    enabling and disabling remote wakeup.  There is a special routine to
    disable wakeup for SuperSpeed devices but not for slower devices, and
    there is no special routine to enable wakeup.
    
    This patch refactors the code.  It renames and changes the existing
    function to make it handle both SuperSpeed and non-SuperSpeed devices,
    and it adds a corresponding routine to enable remote wakeup.  It also
    changes the speed determination to look at the device's speed rather
    than the speed of the parent hub -- this shouldn't make any difference
    because a SuperSpeed device always has to be attached to a SuperSpeed
    hub and conversely.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 11a92198bfc7..c376c8bad40c 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2838,18 +2838,50 @@ void usb_enable_ltm(struct usb_device *udev)
 EXPORT_SYMBOL_GPL(usb_enable_ltm);
 
 /*
- * usb_disable_function_remotewakeup - disable usb3.0
- * device's function remote wakeup
+ * usb_enable_remote_wakeup - enable remote wakeup for a device
  * @udev: target device
  *
- * Assume there's only one function on the USB 3.0
- * device and disable remote wake for the first
- * interface. FIXME if the interface association
- * descriptor shows there's more than one function.
+ * For USB-2 devices: Set the device's remote wakeup feature.
+ *
+ * For USB-3 devices: Assume there's only one function on the device and
+ * enable remote wake for the first interface.  FIXME if the interface
+ * association descriptor shows there's more than one function.
  */
-static int usb_disable_function_remotewakeup(struct usb_device *udev)
+static int usb_enable_remote_wakeup(struct usb_device *udev)
 {
-	return usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
+	if (udev-&gt;speed &lt; USB_SPEED_SUPER)
+		return usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
+				USB_REQ_SET_FEATURE, USB_RECIP_DEVICE,
+				USB_DEVICE_REMOTE_WAKEUP, 0, NULL, 0,
+				USB_CTRL_SET_TIMEOUT);
+	else
+		return usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
+				USB_REQ_SET_FEATURE, USB_RECIP_INTERFACE,
+				USB_INTRF_FUNC_SUSPEND,
+				USB_INTRF_FUNC_SUSPEND_RW |
+					USB_INTRF_FUNC_SUSPEND_LP,
+				NULL, 0, USB_CTRL_SET_TIMEOUT);
+}
+
+/*
+ * usb_disable_remote_wakeup - disable remote wakeup for a device
+ * @udev: target device
+ *
+ * For USB-2 devices: Clear the device's remote wakeup feature.
+ *
+ * For USB-3 devices: Assume there's only one function on the device and
+ * disable remote wake for the first interface.  FIXME if the interface
+ * association descriptor shows there's more than one function.
+ */
+static int usb_disable_remote_wakeup(struct usb_device *udev)
+{
+	if (udev-&gt;speed &lt; USB_SPEED_SUPER)
+		return usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
+				USB_REQ_CLEAR_FEATURE, USB_RECIP_DEVICE,
+				USB_DEVICE_REMOTE_WAKEUP, 0, NULL, 0,
+				USB_CTRL_SET_TIMEOUT);
+	else
+		return usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
 				USB_REQ_CLEAR_FEATURE, USB_RECIP_INTERFACE,
 				USB_INTRF_FUNC_SUSPEND,	0, NULL, 0,
 				USB_CTRL_SET_TIMEOUT);
@@ -2928,27 +2960,7 @@ int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
 	 * we don't explicitly enable it here.
 	 */
 	if (udev-&gt;do_remote_wakeup) {
-		if (!hub_is_superspeed(hub-&gt;hdev)) {
-			status = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
-					USB_REQ_SET_FEATURE, USB_RECIP_DEVICE,
-					USB_DEVICE_REMOTE_WAKEUP, 0,
-					NULL, 0,
-					USB_CTRL_SET_TIMEOUT);
-		} else {
-			/* Assume there's only one function on the USB 3.0
-			 * device and enable remote wake for the first
-			 * interface. FIXME if the interface association
-			 * descriptor shows there's more than one function.
-			 */
-			status = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
-					USB_REQ_SET_FEATURE,
-					USB_RECIP_INTERFACE,
-					USB_INTRF_FUNC_SUSPEND,
-					USB_INTRF_FUNC_SUSPEND_RW |
-					USB_INTRF_FUNC_SUSPEND_LP,
-					NULL, 0,
-					USB_CTRL_SET_TIMEOUT);
-		}
+		status = usb_enable_remote_wakeup(udev);
 		if (status) {
 			dev_dbg(&amp;udev-&gt;dev, "won't remote wakeup, status %d\n",
 					status);
@@ -2999,19 +3011,8 @@ int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
 		dev_dbg(hub-&gt;intfdev, "can't suspend port %d, status %d\n",
 				port1, status);
 		/* paranoia:  "should not happen" */
-		if (udev-&gt;do_remote_wakeup) {
-			if (!hub_is_superspeed(hub-&gt;hdev)) {
-				(void) usb_control_msg(udev,
-						usb_sndctrlpipe(udev, 0),
-						USB_REQ_CLEAR_FEATURE,
-						USB_RECIP_DEVICE,
-						USB_DEVICE_REMOTE_WAKEUP, 0,
-						NULL, 0,
-						USB_CTRL_SET_TIMEOUT);
-			} else
-				(void) usb_disable_function_remotewakeup(udev);
-
-		}
+		if (udev-&gt;do_remote_wakeup)
+			(void) usb_disable_remote_wakeup(udev);
 
 		/* Try to enable USB2 hardware LPM again */
 		if (udev-&gt;usb2_hw_lpm_capable == 1)
@@ -3119,22 +3120,15 @@ static int finish_port_resume(struct usb_device *udev)
 	 * udev-&gt;reset_resume
 	 */
 	} else if (udev-&gt;actconfig &amp;&amp; !udev-&gt;reset_resume) {
-		if (!hub_is_superspeed(udev-&gt;parent)) {
+		if (udev-&gt;speed &lt; USB_SPEED_SUPER) {
 			if (devstatus &amp; (1 &lt;&lt; USB_DEVICE_REMOTE_WAKEUP))
-				status = usb_control_msg(udev,
-						usb_sndctrlpipe(udev, 0),
-						USB_REQ_CLEAR_FEATURE,
-						USB_RECIP_DEVICE,
-						USB_DEVICE_REMOTE_WAKEUP, 0,
-						NULL, 0,
-						USB_CTRL_SET_TIMEOUT);
+				status = usb_disable_remote_wakeup(udev);
 		} else {
 			status = usb_get_status(udev, USB_RECIP_INTERFACE, 0,
 					&amp;devstatus);
 			if (!status &amp;&amp; devstatus &amp; (USB_INTRF_STAT_FUNC_RW_CAP
 					| USB_INTRF_STAT_FUNC_RW))
-				status =
-					usb_disable_function_remotewakeup(udev);
+				status = usb_disable_remote_wakeup(udev);
 		}
 
 		if (status)</pre>
    <div class="pagination">
        <a href='2_33.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><span>[34]</span><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_35.html'>Next&gt;&gt;</a>
    <div>
</body>
