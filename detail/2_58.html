<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_57.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><span>[58]</span><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_59.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 6498d9db6d2dad4cf5deb2dd09e0816904f41ca5
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Apr 28 10:45:24 2011 -0400

    USB: documentation update for the pre_reset method
    
    This patch (as1459) updates the documentation for the pre_reset method
    in struct usb_driver.  When a driver is notified of an impending
    reset, it must cancel all outstanding I/O and not start any new I/O
    until it has been notified that the reset is complete.
    
    As far as I know, most existing drivers that implement pre_reset do
    this now.  The major exceptions appear to be the SpeedTouch and
    CDC-WDM drivers.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/Documentation/usb/callbacks.txt b/Documentation/usb/callbacks.txt
index bfb36b34b79e..9e85846bdb98 100644
--- a/Documentation/usb/callbacks.txt
+++ b/Documentation/usb/callbacks.txt
@@ -95,9 +95,11 @@ pre_reset
 
 int (*pre_reset)(struct usb_interface *intf);
 
-Another driver or user space is triggering a reset on the device which
-contains the interface passed as an argument. Cease IO and save any
-device state you need to restore.
+A driver or user space is triggering a reset on the device which
+contains the interface passed as an argument. Cease IO, wait for all
+outstanding URBs to complete, and save any device state you need to
+restore.  No more URBs may be submitted until the post_reset method
+is called.
 
 If you need to allocate memory here, use GFP_NOIO or GFP_ATOMIC, if you
 are in atomic context.
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 65f78ca5d88e..73c7df489607 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -806,8 +806,10 @@ struct usbdrv_wrap {
  * @resume: Called when the device is being resumed by the system.
  * @reset_resume: Called when the suspended device has been reset instead
  *	of being resumed.
- * @pre_reset: Called by usb_reset_device() when the device
- *	is about to be reset.
+ * @pre_reset: Called by usb_reset_device() when the device is about to be
+ *	reset.  This routine must not return until the driver has no active
+ *	URBs for the device, and no more URBs may be submitted until the
+ *	post_reset method is called.
  * @post_reset: Called by usb_reset_device() after the device
  *	has been reset
  * @id_table: USB drivers use ID table to support hotplugging.</pre><hr><pre>commit 99083f16f04e050eab0059167b4980cd67e7aa5a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Apr 5 13:35:53 2011 -0400

    USB: UHCI: don't try to revive a dead controller
    
    This patch (as1457) abandons the curious strategy of declaring a
    controller dead following hibernation merely in order to reset and
    then revive it.  The core no longer allow dead controllers to spring
    back to life when the system resumes, so there's no reason to declare
    a working controller temporarily dead.  Instead we do an explicit
    reset.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 73db5569f57b..83344d688ff0 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -140,8 +140,6 @@ static void finish_reset(struct uhci_hcd *uhci)
 	uhci-&gt;rh_state = UHCI_RH_RESET;
 	uhci-&gt;is_stopped = UHCI_IS_STOPPED;
 	clear_bit(HCD_FLAG_POLL_RH, &amp;uhci_to_hcd(uhci)-&gt;flags);
-
-	uhci-&gt;dead = 0;		/* Full reset resurrects the controller */
 }
 
 /*
@@ -837,16 +835,17 @@ static int uhci_pci_resume(struct usb_hcd *hcd, bool hibernated)
 	spin_lock_irq(&amp;uhci-&gt;lock);
 
 	/* Make sure resume from hibernation re-enumerates everything */
-	if (hibernated)
-		uhci_hc_died(uhci);
+	if (hibernated) {
+		uhci_reset_hc(to_pci_dev(uhci_dev(uhci)), uhci-&gt;io_addr);
+		finish_reset(uhci);
+	}
 
-	/* The firmware or a boot kernel may have changed the controller
-	 * settings during a system wakeup.  Check it and reconfigure
-	 * to avoid problems.
+	/* The firmware may have changed the controller settings during
+	 * a system wakeup.  Check it and reconfigure to avoid problems.
 	 */
-	check_and_reset_hc(uhci);
-
-	/* If the controller was dead before, it's back alive now */
+	else {
+		check_and_reset_hc(uhci);
+	}
 	configure_hc(uhci);
 
 	/* Tell the core if the controller had to be reset */</pre><hr><pre>commit 7d670a2ed770a3405a7edb1159e3fa9b3f43fe46
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Apr 5 13:36:04 2011 -0400

    USB: UHCI: remove uses of hcd-&gt;state
    
    This patch (as1456) removes all uses of hcd-&gt;state from the uhci-hcd
    driver, as part of the overall strategy to eliminate hcd-&gt;state
    completely.  Now when a controller dies we call usb_hc_died()
    directly, instead of relying on the core interrupt handler to see that
    hcd-&gt;state has changed to HC_STATE_HALT and make the call for us.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 4f65b14e5e08..73db5569f57b 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -139,7 +139,6 @@ static void finish_reset(struct uhci_hcd *uhci)
 	uhci-&gt;port_c_suspend = uhci-&gt;resuming_ports = 0;
 	uhci-&gt;rh_state = UHCI_RH_RESET;
 	uhci-&gt;is_stopped = UHCI_IS_STOPPED;
-	uhci_to_hcd(uhci)-&gt;state = HC_STATE_HALT;
 	clear_bit(HCD_FLAG_POLL_RH, &amp;uhci_to_hcd(uhci)-&gt;flags);
 
 	uhci-&gt;dead = 0;		/* Full reset resurrects the controller */
@@ -188,10 +187,6 @@ static void configure_hc(struct uhci_hcd *uhci)
 	outw(uhci-&gt;frame_number &amp; UHCI_MAX_SOF_NUMBER,
 			uhci-&gt;io_addr + USBFRNUM);
 
-	/* Mark controller as not halted before we enable interrupts */
-	uhci_to_hcd(uhci)-&gt;state = HC_STATE_SUSPENDED;
-	mb();
-
 	/* Enable PIRQ */
 	pci_write_config_word(pdev, USBLEGSUP, USBLEGSUP_DEFAULT);
 
@@ -360,7 +355,6 @@ __acquires(uhci-&gt;lock)
 
 static void start_rh(struct uhci_hcd *uhci)
 {
-	uhci_to_hcd(uhci)-&gt;state = HC_STATE_RUNNING;
 	uhci-&gt;is_stopped = 0;
 
 	/* Mark it configured and running with a 64-byte max packet.
@@ -449,6 +443,7 @@ static irqreturn_t uhci_irq(struct usb_hcd *hcd)
 					lprintk(errbuf);
 				}
 				uhci_hc_died(uhci);
+				usb_hc_died(hcd);
 
 				/* Force a callback in case there are
 				 * pending unlinks */</pre><hr><pre>commit ee81b3e086c907a3347b15ef219a24fc8bf900f6
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Mar 25 11:46:27 2011 -0400

    USB: g_file_storage: don't send padding when stall=n
    
    This patch (as1455) removes the extra padding sent by g_file_storage
    and g_mass_storage when the gadget wants to send less data than
    requested by the host and isn't allowed to halt the bulk-IN endpoint.
    
    Although the Bulk-Only Transport specification requires the padding to
    be present, it isn't truly needed since the transfer will be terminated
    by a short packet anyway.  Furthermore, many existing devices don't
    bother to send any padding.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-By: Michal Nazarewicz &lt;mina86@mina86.com&gt;
    CC: Roger Quadros &lt;roger.quadros@nokia.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/f_mass_storage.c b/drivers/usb/gadget/f_mass_storage.c
index 125587ac5d0b..98d6b39061d2 100644
--- a/drivers/usb/gadget/f_mass_storage.c
+++ b/drivers/usb/gadget/f_mass_storage.c
@@ -1569,37 +1569,6 @@ static int wedge_bulk_in_endpoint(struct fsg_dev *fsg)
 	return rc;
 }
 
-static int pad_with_zeros(struct fsg_dev *fsg)
-{
-	struct fsg_buffhd	*bh = fsg-&gt;common-&gt;next_buffhd_to_fill;
-	u32			nkeep = bh-&gt;inreq-&gt;length;
-	u32			nsend;
-	int			rc;
-
-	bh-&gt;state = BUF_STATE_EMPTY;		/* For the first iteration */
-	fsg-&gt;common-&gt;usb_amount_left = nkeep + fsg-&gt;common-&gt;residue;
-	while (fsg-&gt;common-&gt;usb_amount_left &gt; 0) {
-
-		/* Wait for the next buffer to be free */
-		while (bh-&gt;state != BUF_STATE_EMPTY) {
-			rc = sleep_thread(fsg-&gt;common);
-			if (rc)
-				return rc;
-		}
-
-		nsend = min(fsg-&gt;common-&gt;usb_amount_left, FSG_BUFLEN);
-		memset(bh-&gt;buf + nkeep, 0, nsend - nkeep);
-		bh-&gt;inreq-&gt;length = nsend;
-		bh-&gt;inreq-&gt;zero = 0;
-		start_transfer(fsg, fsg-&gt;bulk_in, bh-&gt;inreq,
-			       &amp;bh-&gt;inreq_busy, &amp;bh-&gt;state);
-		bh = fsg-&gt;common-&gt;next_buffhd_to_fill = bh-&gt;next;
-		fsg-&gt;common-&gt;usb_amount_left -= nsend;
-		nkeep = 0;
-	}
-	return 0;
-}
-
 static int throw_away_data(struct fsg_common *common)
 {
 	struct fsg_buffhd	*bh;
@@ -1686,6 +1655,10 @@ static int finish_reply(struct fsg_common *common)
 		if (common-&gt;data_size == 0) {
 			/* Nothing to send */
 
+		/* Don't know what to do if common-&gt;fsg is NULL */
+		} else if (!fsg_is_set(common)) {
+			rc = -EIO;
+
 		/* If there's no residue, simply send the last buffer */
 		} else if (common-&gt;residue == 0) {
 			bh-&gt;inreq-&gt;zero = 0;
@@ -1694,24 +1667,19 @@ static int finish_reply(struct fsg_common *common)
 			common-&gt;next_buffhd_to_fill = bh-&gt;next;
 
 		/*
-		 * For Bulk-only, if we're allowed to stall then send the
-		 * short packet and halt the bulk-in endpoint.  If we can't
-		 * stall, pad out the remaining data with 0's.
+		 * For Bulk-only, mark the end of the data with a short
+		 * packet.  If we are allowed to stall, halt the bulk-in
+		 * endpoint.  (Note: This violates the Bulk-Only Transport
+		 * specification, which requires us to pad the data if we
+		 * don't halt the endpoint.  Presumably nobody will mind.)
 		 */
-		} else if (common-&gt;can_stall) {
+		} else {
 			bh-&gt;inreq-&gt;zero = 1;
 			if (!start_in_transfer(common, bh))
-				/* Don't know what to do if
-				 * common-&gt;fsg is NULL */
 				rc = -EIO;
 			common-&gt;next_buffhd_to_fill = bh-&gt;next;
-			if (common-&gt;fsg)
+			if (common-&gt;can_stall)
 				rc = halt_bulk_in_endpoint(common-&gt;fsg);
-		} else if (fsg_is_set(common)) {
-			rc = pad_with_zeros(common-&gt;fsg);
-		} else {
-			/* Don't know what to do if common-&gt;fsg is NULL */
-			rc = -EIO;
 		}
 		break;
 
diff --git a/drivers/usb/gadget/file_storage.c b/drivers/usb/gadget/file_storage.c
index d04e0e6b019d..aebfb81f3ba4 100644
--- a/drivers/usb/gadget/file_storage.c
+++ b/drivers/usb/gadget/file_storage.c
@@ -1932,37 +1932,6 @@ static int wedge_bulk_in_endpoint(struct fsg_dev *fsg)
 	return rc;
 }
 
-static int pad_with_zeros(struct fsg_dev *fsg)
-{
-	struct fsg_buffhd	*bh = fsg-&gt;next_buffhd_to_fill;
-	u32			nkeep = bh-&gt;inreq-&gt;length;
-	u32			nsend;
-	int			rc;
-
-	bh-&gt;state = BUF_STATE_EMPTY;		// For the first iteration
-	fsg-&gt;usb_amount_left = nkeep + fsg-&gt;residue;
-	while (fsg-&gt;usb_amount_left &gt; 0) {
-
-		/* Wait for the next buffer to be free */
-		while (bh-&gt;state != BUF_STATE_EMPTY) {
-			rc = sleep_thread(fsg);
-			if (rc)
-				return rc;
-		}
-
-		nsend = min(fsg-&gt;usb_amount_left, (u32) mod_data.buflen);
-		memset(bh-&gt;buf + nkeep, 0, nsend - nkeep);
-		bh-&gt;inreq-&gt;length = nsend;
-		bh-&gt;inreq-&gt;zero = 0;
-		start_transfer(fsg, fsg-&gt;bulk_in, bh-&gt;inreq,
-				&amp;bh-&gt;inreq_busy, &amp;bh-&gt;state);
-		bh = fsg-&gt;next_buffhd_to_fill = bh-&gt;next;
-		fsg-&gt;usb_amount_left -= nsend;
-		nkeep = 0;
-	}
-	return 0;
-}
-
 static int throw_away_data(struct fsg_dev *fsg)
 {
 	struct fsg_buffhd	*bh;
@@ -2066,18 +2035,20 @@ static int finish_reply(struct fsg_dev *fsg)
 			}
 		}
 
-		/* For Bulk-only, if we're allowed to stall then send the
-		 * short packet and halt the bulk-in endpoint.  If we can't
-		 * stall, pad out the remaining data with 0's. */
+		/*
+		 * For Bulk-only, mark the end of the data with a short
+		 * packet.  If we are allowed to stall, halt the bulk-in
+		 * endpoint.  (Note: This violates the Bulk-Only Transport
+		 * specification, which requires us to pad the data if we
+		 * don't halt the endpoint.  Presumably nobody will mind.)
+		 */
 		else {
-			if (mod_data.can_stall) {
-				bh-&gt;inreq-&gt;zero = 1;
-				start_transfer(fsg, fsg-&gt;bulk_in, bh-&gt;inreq,
-						&amp;bh-&gt;inreq_busy, &amp;bh-&gt;state);
-				fsg-&gt;next_buffhd_to_fill = bh-&gt;next;
+			bh-&gt;inreq-&gt;zero = 1;
+			start_transfer(fsg, fsg-&gt;bulk_in, bh-&gt;inreq,
+					&amp;bh-&gt;inreq_busy, &amp;bh-&gt;state);
+			fsg-&gt;next_buffhd_to_fill = bh-&gt;next;
+			if (mod_data.can_stall)
 				rc = halt_bulk_in_endpoint(fsg);
-			} else
-				rc = pad_with_zeros(fsg);
 		}
 		break;
 </pre><hr><pre>commit 94ae4976e253757e9b03a44d27d41b20f1829d80
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Apr 5 13:36:15 2011 -0400

    USB: EHCI: unlink unused QHs when the controller is stopped
    
    This patch (as1458) fixes a problem affecting ultra-reliable systems:
    When hardware failover of an EHCI controller occurs, the data
    structures do not get released correctly.  This is because the routine
    responsible for removing unused QHs from the async schedule assumes
    the controller is running properly (the frame counter is used in
    determining how long the QH has been idle) -- but when a failover
    causes the controller to be electronically disconnected from the PCI
    bus, obviously it stops running.
    
    The solution is simple: Allow scan_async() to remove a QH from the
    async schedule if it has been idle for long enough _or_ if the
    controller is stopped.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-Tested-by: Dan Duval &lt;dan.duval@stratus.com&gt;
    CC: &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 98ded66e8d3f..42abd0f603bf 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -1247,24 +1247,27 @@ static void start_unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 
 static void scan_async (struct ehci_hcd *ehci)
 {
+	bool			stopped;
 	struct ehci_qh		*qh;
 	enum ehci_timer_action	action = TIMER_IO_WATCHDOG;
 
 	ehci-&gt;stamp = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;frame_index);
 	timer_action_done (ehci, TIMER_ASYNC_SHRINK);
 rescan:
+	stopped = !HC_IS_RUNNING(ehci_to_hcd(ehci)-&gt;state);
 	qh = ehci-&gt;async-&gt;qh_next.qh;
 	if (likely (qh != NULL)) {
 		do {
 			/* clean any finished work for this qh */
-			if (!list_empty (&amp;qh-&gt;qtd_list)
-					&amp;&amp; qh-&gt;stamp != ehci-&gt;stamp) {
+			if (!list_empty(&amp;qh-&gt;qtd_list) &amp;&amp; (stopped ||
+					qh-&gt;stamp != ehci-&gt;stamp)) {
 				int temp;
 
 				/* unlinks could happen here; completion
 				 * reporting drops the lock.  rescan using
 				 * the latest schedule, but don't rescan
-				 * qhs we already finished (no looping).
+				 * qhs we already finished (no looping)
+				 * unless the controller is stopped.
 				 */
 				qh = qh_get (qh);
 				qh-&gt;stamp = ehci-&gt;stamp;
@@ -1285,9 +1288,9 @@ static void scan_async (struct ehci_hcd *ehci)
 			 */
 			if (list_empty(&amp;qh-&gt;qtd_list)
 					&amp;&amp; qh-&gt;qh_state == QH_STATE_LINKED) {
-				if (!ehci-&gt;reclaim
-					&amp;&amp; ((ehci-&gt;stamp - qh-&gt;stamp) &amp; 0x1fff)
-						&gt;= (EHCI_SHRINK_FRAMES * 8))
+				if (!ehci-&gt;reclaim &amp;&amp; (stopped ||
+					((ehci-&gt;stamp - qh-&gt;stamp) &amp; 0x1fff)
+						&gt;= EHCI_SHRINK_FRAMES * 8))
 					start_unlink_async(ehci, qh);
 				else
 					action = TIMER_ASYNC_SHRINK;</pre><hr><pre>commit b5a3b3d985493c173925907adfebf3edab236fe7
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Mar 16 10:57:15 2011 -0400

    ehci-hcd: Bug fix: don't set a QH's Halt bit
    
    This patch (as1453) fixes a long-standing bug in the ehci-hcd driver.
    
    There is no need to set the Halt bit in the overlay region for an
    unlinked or blocked QH.  Contrary to what the comment says, setting
    the Halt bit does not cause the QH to be patched later; that decision
    (made in qh_refresh()) depends only on whether the QH is currently
    pointing to a valid qTD.  Likewise, setting the Halt bit does not
    prevent completions from activating the QH while it is "stopped"; they
    are prevented by the fact that qh_completions() temporarily changes
    qh-&gt;qh_state to QH_STATE_COMPLETING.
    
    On the other hand, there are circumstances in which the QH will be
    reactivated _without_ being patched; this happens after an URB beyond
    the head of the queue is unlinked.  Setting the Halt bit will then
    cause the hardware to see the QH with both the Active and Halt bits
    set, an invalid combination that will prevent the queue from
    advancing and may even crash some controllers.
    
    Apparently the only reason this hasn't been reported before is that
    unlinking URBs from the middle of a running queue is quite uncommon.
    However Test 17, recently added to the usbtest driver, does exactly
    this, and it confirms the presence of the bug.
    
    In short, there is no reason to set the Halt bit for an unlinked or
    blocked QH, and there is a very good reason not to set it.  Therefore
    the code that sets it is removed.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Andiry Xu &lt;andiry.xu@amd.com&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    CC: &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index fe99895fb098..98ded66e8d3f 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -315,7 +315,6 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	int			stopped;
 	unsigned		count = 0;
 	u8			state;
-	const __le32		halt = HALT_BIT(ehci);
 	struct ehci_qh_hw	*hw = qh-&gt;hw;
 
 	if (unlikely (list_empty (&amp;qh-&gt;qtd_list)))
@@ -422,7 +421,6 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 					&amp;&amp; !(qtd-&gt;hw_alt_next
 						&amp; EHCI_LIST_END(ehci))) {
 				stopped = 1;
-				goto halt;
 			}
 
 		/* stop scanning when we reach qtds the hc is using */
@@ -456,16 +454,6 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 				 */
 				ehci_clear_tt_buffer(ehci, qh, urb, token);
 			}
-
-			/* force halt for unlinked or blocked qh, so we'll
-			 * patch the qh later and so that completions can't
-			 * activate it while we "know" it's stopped.
-			 */
-			if ((halt &amp; hw-&gt;hw_token) == 0) {
-halt:
-				hw-&gt;hw_token |= halt;
-				wmb ();
-			}
 		}
 
 		/* unless we already know the urb's status, collect qtd status</pre><hr><pre>commit 9b37596a2e860404503a3f2a6513db60c296bfdc
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Mar 7 11:11:52 2011 -0500

    USB: move usbcore away from hcd-&gt;state
    
    The hcd-&gt;state variable is a disaster.  It's not clearly owned by
    either usbcore or the host controller drivers, and they both change it
    from time to time, potentially stepping on each other's toes.  It's
    not protected by any locks.  And there's no mechanism to prevent it
    from going through an invalid transition.
    
    This patch (as1451) takes a first step toward fixing these problems.
    As it turns out, usbcore uses hcd-&gt;state for essentially only two
    things: checking whether the controller's root hub is running and
    checking whether the controller has died.  Therefore the patch adds
    two new atomic bitflags to the hcd structure, to store these pieces of
    information.  The new flags are used only by usbcore, and a private
    spinlock prevents invalid combinations (a dead controller's root hub
    cannot be running).
    
    The patch does not change the places where usbcore sets hcd-&gt;state,
    since HCDs may depend on them.  Furthermore, there is one place in
    usb_hcd_irq() where usbcore still must use hcd-&gt;state: An HCD's
    interrupt handler can implicitly indicate that the controller died by
    setting hcd-&gt;state to HC_STATE_HALT.  Nevertheless, the new code is a
    big improvement over the current code.
    
    The patch makes one other change.  The hcd_bus_suspend() and
    hcd_bus_resume() routines now check first whether the host controller
    has died; if it has then they return immediately without calling the
    HCD's bus_suspend or bus_resume methods.
    
    This fixes the major problem reported in Bugzilla #29902: The system
    fails to suspend after a host controller dies during system resume.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Alex Terekhov &lt;a.terekhov@gmail.com&gt;
    CC: &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd-pci.c b/drivers/usb/core/hcd-pci.c
index f71e8e307e0f..d37088591d9a 100644
--- a/drivers/usb/core/hcd-pci.c
+++ b/drivers/usb/core/hcd-pci.c
@@ -363,8 +363,7 @@ static int check_root_hub_suspended(struct device *dev)
 	struct pci_dev		*pci_dev = to_pci_dev(dev);
 	struct usb_hcd		*hcd = pci_get_drvdata(pci_dev);
 
-	if (!(hcd-&gt;state == HC_STATE_SUSPENDED ||
-			hcd-&gt;state == HC_STATE_HALT)) {
+	if (HCD_RH_RUNNING(hcd)) {
 		dev_warn(dev, "Root hub is not suspended\n");
 		return -EBUSY;
 	}
@@ -386,7 +385,7 @@ static int suspend_common(struct device *dev, bool do_wakeup)
 	if (retval)
 		return retval;
 
-	if (hcd-&gt;driver-&gt;pci_suspend) {
+	if (hcd-&gt;driver-&gt;pci_suspend &amp;&amp; !HCD_DEAD(hcd)) {
 		/* Optimization: Don't suspend if a root-hub wakeup is
 		 * pending and it would cause the HCD to wake up anyway.
 		 */
@@ -427,7 +426,7 @@ static int resume_common(struct device *dev, int event)
 	struct usb_hcd		*hcd = pci_get_drvdata(pci_dev);
 	int			retval;
 
-	if (hcd-&gt;state != HC_STATE_SUSPENDED) {
+	if (HCD_RH_RUNNING(hcd)) {
 		dev_dbg(dev, "can't resume, not suspended!\n");
 		return 0;
 	}
@@ -442,7 +441,7 @@ static int resume_common(struct device *dev, int event)
 
 	clear_bit(HCD_FLAG_SAW_IRQ, &amp;hcd-&gt;flags);
 
-	if (hcd-&gt;driver-&gt;pci_resume) {
+	if (hcd-&gt;driver-&gt;pci_resume &amp;&amp; !HCD_DEAD(hcd)) {
 		if (event != PM_EVENT_AUTO_RESUME)
 			wait_for_companions(pci_dev, hcd);
 
@@ -475,10 +474,10 @@ static int hcd_pci_suspend_noirq(struct device *dev)
 
 	pci_save_state(pci_dev);
 
-	/* If the root hub is HALTed rather than SUSPENDed,
+	/* If the root hub is dead rather than suspended,
 	 * disallow remote wakeup.
 	 */
-	if (hcd-&gt;state == HC_STATE_HALT)
+	if (HCD_DEAD(hcd))
 		device_set_wakeup_enable(dev, 0);
 	dev_dbg(dev, "wakeup: %d\n", device_may_wakeup(dev));
 
diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 24765fd6cf12..e7d0c4571bbe 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -983,7 +983,7 @@ static int register_root_hub(struct usb_hcd *hcd)
 		spin_unlock_irq (&amp;hcd_root_hub_lock);
 
 		/* Did the HC die before the root hub was registered? */
-		if (hcd-&gt;state == HC_STATE_HALT)
+		if (HCD_DEAD(hcd) || hcd-&gt;state == HC_STATE_HALT)
 			usb_hc_died (hcd);	/* This time clean up */
 	}
 
@@ -1089,13 +1089,10 @@ int usb_hcd_link_urb_to_ep(struct usb_hcd *hcd, struct urb *urb)
 	 * Check the host controller's state and add the URB to the
 	 * endpoint's queue.
 	 */
-	switch (hcd-&gt;state) {
-	case HC_STATE_RUNNING:
-	case HC_STATE_RESUMING:
+	if (HCD_RH_RUNNING(hcd)) {
 		urb-&gt;unlinked = 0;
 		list_add_tail(&amp;urb-&gt;urb_list, &amp;urb-&gt;ep-&gt;urb_list);
-		break;
-	default:
+	} else {
 		rc = -ESHUTDOWN;
 		goto done;
 	}
@@ -1931,7 +1928,7 @@ int usb_hcd_get_frame_number (struct usb_device *udev)
 {
 	struct usb_hcd	*hcd = bus_to_hcd(udev-&gt;bus);
 
-	if (!HC_IS_RUNNING (hcd-&gt;state))
+	if (!HCD_RH_RUNNING(hcd))
 		return -ESHUTDOWN;
 	return hcd-&gt;driver-&gt;get_frame_number (hcd);
 }
@@ -1948,9 +1945,15 @@ int hcd_bus_suspend(struct usb_device *rhdev, pm_message_t msg)
 
 	dev_dbg(&amp;rhdev-&gt;dev, "bus %s%s\n",
 			(msg.event &amp; PM_EVENT_AUTO ? "auto-" : ""), "suspend");
+	if (HCD_DEAD(hcd)) {
+		dev_dbg(&amp;rhdev-&gt;dev, "skipped %s of dead bus\n", "suspend");
+		return 0;
+	}
+
 	if (!hcd-&gt;driver-&gt;bus_suspend) {
 		status = -ENOENT;
 	} else {
+		clear_bit(HCD_FLAG_RH_RUNNING, &amp;hcd-&gt;flags);
 		hcd-&gt;state = HC_STATE_QUIESCING;
 		status = hcd-&gt;driver-&gt;bus_suspend(hcd);
 	}
@@ -1958,7 +1961,12 @@ int hcd_bus_suspend(struct usb_device *rhdev, pm_message_t msg)
 		usb_set_device_state(rhdev, USB_STATE_SUSPENDED);
 		hcd-&gt;state = HC_STATE_SUSPENDED;
 	} else {
-		hcd-&gt;state = old_state;
+		spin_lock_irq(&amp;hcd_root_hub_lock);
+		if (!HCD_DEAD(hcd)) {
+			set_bit(HCD_FLAG_RH_RUNNING, &amp;hcd-&gt;flags);
+			hcd-&gt;state = old_state;
+		}
+		spin_unlock_irq(&amp;hcd_root_hub_lock);
 		dev_dbg(&amp;rhdev-&gt;dev, "bus %s fail, err %d\n",
 				"suspend", status);
 	}
@@ -1973,9 +1981,13 @@ int hcd_bus_resume(struct usb_device *rhdev, pm_message_t msg)
 
 	dev_dbg(&amp;rhdev-&gt;dev, "usb %s%s\n",
 			(msg.event &amp; PM_EVENT_AUTO ? "auto-" : ""), "resume");
+	if (HCD_DEAD(hcd)) {
+		dev_dbg(&amp;rhdev-&gt;dev, "skipped %s of dead bus\n", "resume");
+		return 0;
+	}
 	if (!hcd-&gt;driver-&gt;bus_resume)
 		return -ENOENT;
-	if (hcd-&gt;state == HC_STATE_RUNNING)
+	if (HCD_RH_RUNNING(hcd))
 		return 0;
 
 	hcd-&gt;state = HC_STATE_RESUMING;
@@ -1984,10 +1996,15 @@ int hcd_bus_resume(struct usb_device *rhdev, pm_message_t msg)
 	if (status == 0) {
 		/* TRSMRCY = 10 msec */
 		msleep(10);
-		usb_set_device_state(rhdev, rhdev-&gt;actconfig
-				? USB_STATE_CONFIGURED
-				: USB_STATE_ADDRESS);
-		hcd-&gt;state = HC_STATE_RUNNING;
+		spin_lock_irq(&amp;hcd_root_hub_lock);
+		if (!HCD_DEAD(hcd)) {
+			usb_set_device_state(rhdev, rhdev-&gt;actconfig
+					? USB_STATE_CONFIGURED
+					: USB_STATE_ADDRESS);
+			set_bit(HCD_FLAG_RH_RUNNING, &amp;hcd-&gt;flags);
+			hcd-&gt;state = HC_STATE_RUNNING;
+		}
+		spin_unlock_irq(&amp;hcd_root_hub_lock);
 	} else {
 		hcd-&gt;state = old_state;
 		dev_dbg(&amp;rhdev-&gt;dev, "bus %s fail, err %d\n",
@@ -2098,7 +2115,7 @@ irqreturn_t usb_hcd_irq (int irq, void *__hcd)
 	 */
 	local_irq_save(flags);
 
-	if (unlikely(hcd-&gt;state == HC_STATE_HALT || !HCD_HW_ACCESSIBLE(hcd))) {
+	if (unlikely(HCD_DEAD(hcd) || !HCD_HW_ACCESSIBLE(hcd))) {
 		rc = IRQ_NONE;
 	} else if (hcd-&gt;driver-&gt;irq(hcd) == IRQ_NONE) {
 		rc = IRQ_NONE;
@@ -2132,6 +2149,8 @@ void usb_hc_died (struct usb_hcd *hcd)
 	dev_err (hcd-&gt;self.controller, "HC died; cleaning up\n");
 
 	spin_lock_irqsave (&amp;hcd_root_hub_lock, flags);
+	clear_bit(HCD_FLAG_RH_RUNNING, &amp;hcd-&gt;flags);
+	set_bit(HCD_FLAG_DEAD, &amp;hcd-&gt;flags);
 	if (hcd-&gt;rh_registered) {
 		clear_bit(HCD_FLAG_POLL_RH, &amp;hcd-&gt;flags);
 
@@ -2274,6 +2293,12 @@ int usb_add_hcd(struct usb_hcd *hcd,
 	 */
 	device_init_wakeup(&amp;rhdev-&gt;dev, 1);
 
+	/* HCD_FLAG_RH_RUNNING doesn't matter until the root hub is
+	 * registered.  But since the controller can die at any time,
+	 * let's initialize the flag before touching the hardware.
+	 */
+	set_bit(HCD_FLAG_RH_RUNNING, &amp;hcd-&gt;flags);
+
 	/* "reset" is misnamed; its role is now one-time init. the controller
 	 * should already have been reset (and boot firmware kicked off etc).
 	 */
@@ -2341,6 +2366,7 @@ int usb_add_hcd(struct usb_hcd *hcd,
 	return retval;
 
 error_create_attr_group:
+	clear_bit(HCD_FLAG_RH_RUNNING, &amp;hcd-&gt;flags);
 	if (HC_IS_RUNNING(hcd-&gt;state))
 		hcd-&gt;state = HC_STATE_QUIESCING;
 	spin_lock_irq(&amp;hcd_root_hub_lock);
@@ -2393,6 +2419,7 @@ void usb_remove_hcd(struct usb_hcd *hcd)
 	usb_get_dev(rhdev);
 	sysfs_remove_group(&amp;rhdev-&gt;dev.kobj, &amp;usb_bus_attr_group);
 
+	clear_bit(HCD_FLAG_RH_RUNNING, &amp;hcd-&gt;flags);
 	if (HC_IS_RUNNING (hcd-&gt;state))
 		hcd-&gt;state = HC_STATE_QUIESCING;
 
diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 9cfba4f2457b..8b65068c6af9 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -99,6 +99,8 @@ struct usb_hcd {
 #define HCD_FLAG_POLL_RH		2	/* poll for rh status? */
 #define HCD_FLAG_POLL_PENDING		3	/* status has changed? */
 #define HCD_FLAG_WAKEUP_PENDING		4	/* root hub is resuming? */
+#define HCD_FLAG_RH_RUNNING		5	/* root hub is running? */
+#define HCD_FLAG_DEAD			6	/* controller has died? */
 
 	/* The flags can be tested using these macros; they are likely to
 	 * be slightly faster than test_bit().
@@ -108,6 +110,8 @@ struct usb_hcd {
 #define HCD_POLL_RH(hcd)	((hcd)-&gt;flags &amp; (1U &lt;&lt; HCD_FLAG_POLL_RH))
 #define HCD_POLL_PENDING(hcd)	((hcd)-&gt;flags &amp; (1U &lt;&lt; HCD_FLAG_POLL_PENDING))
 #define HCD_WAKEUP_PENDING(hcd)	((hcd)-&gt;flags &amp; (1U &lt;&lt; HCD_FLAG_WAKEUP_PENDING))
+#define HCD_RH_RUNNING(hcd)	((hcd)-&gt;flags &amp; (1U &lt;&lt; HCD_FLAG_RH_RUNNING))
+#define HCD_DEAD(hcd)		((hcd)-&gt;flags &amp; (1U &lt;&lt; HCD_FLAG_DEAD))
 
 	/* Flags that get set only during HCD registration or removal. */
 	unsigned		rh_registered:1;/* is root hub registered? */</pre><hr><pre>commit 969e3033ae7733a0af8f7742ca74cd16c0857e71
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Feb 23 15:28:18 2011 -0500

    USB: serial drivers need to use larger bulk-in buffers
    
    When a driver doesn't know how much data a device is going to send,
    the buffer size should be at least as big as the endpoint's maxpacket
    value.  The serial drivers don't follow this rule; many of them
    request only 256-byte bulk-in buffers.  As a result, they suffer
    overflow errors if a high-speed device wants to send a lot of data,
    because high-speed bulk endpoints are required to have a maxpacket
    size of 512.
    
    This patch (as1450) fixes the problem by using the driver's
    bulk_in_size value as a minimum, always allocating buffers no smaller
    than the endpoint's maxpacket size.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Flynn Marquardt &lt;flynn@flynnux.de&gt;
    CC: &lt;stable@kernel.org&gt; [after .39-rc1 is out]
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/serial/usb-serial.c b/drivers/usb/serial/usb-serial.c
index 546a52179bec..2ff90a9c8f47 100644
--- a/drivers/usb/serial/usb-serial.c
+++ b/drivers/usb/serial/usb-serial.c
@@ -911,9 +911,8 @@ int usb_serial_probe(struct usb_interface *interface,
 			dev_err(&amp;interface-&gt;dev, "No free urbs available\n");
 			goto probe_error;
 		}
-		buffer_size = serial-&gt;type-&gt;bulk_in_size;
-		if (!buffer_size)
-			buffer_size = le16_to_cpu(endpoint-&gt;wMaxPacketSize);
+		buffer_size = max_t(int, serial-&gt;type-&gt;bulk_in_size,
+				le16_to_cpu(endpoint-&gt;wMaxPacketSize));
 		port-&gt;bulk_in_size = buffer_size;
 		port-&gt;bulk_in_endpointAddress = endpoint-&gt;bEndpointAddress;
 		port-&gt;bulk_in_buffer = kmalloc(buffer_size, GFP_KERNEL);
diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index c9049139a7a5..45f3b9db4258 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -191,7 +191,8 @@ static inline void usb_set_serial_data(struct usb_serial *serial, void *data)
  * @id_table: pointer to a list of usb_device_id structures that define all
  *	of the devices this structure can support.
  * @num_ports: the number of different ports this device will have.
- * @bulk_in_size: bytes to allocate for bulk-in buffer (0 = end-point size)
+ * @bulk_in_size: minimum number of bytes to allocate for bulk-in buffer
+ *	(0 = end-point size)
  * @bulk_out_size: bytes to allocate for bulk-out buffer (0 = end-point size)
  * @calc_num_ports: pointer to a function to determine how many ports this
  *	device has dynamically.  It will be called after the probe()</pre><hr><pre>commit 3b29b68b1627781b5eecb581d3b9d5f0043a72f2
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Feb 22 09:53:41 2011 -0500

    USB: use "device number" instead of "address"
    
    The USB stack historically has conflated device numbers (i.e., the
    value of udev-&gt;devnum) with device addresses.  This is understandable,
    because until recently the two values were always the same.
    
    But with USB-3.0 they aren't the same, so we should start calling
    these things by their correct names.  This patch (as1449b) changes many
    of the references to "address" in the hub driver to "device number"
    or "devnum".
    
    The patch also removes some unnecessary or misleading comments.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Luben Tuikov &lt;ltuikov@yahoo.com&gt;
    Reviewed-by: Sarah Sharp &lt;sarah.a.sharp@linux.intel.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index d041c6826e43..c168121f9f97 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1499,6 +1499,13 @@ void usb_set_device_state(struct usb_device *udev,
 EXPORT_SYMBOL_GPL(usb_set_device_state);
 
 /*
+ * Choose a device number.
+ *
+ * Device numbers are used as filenames in usbfs.  On USB-1.1 and
+ * USB-2.0 buses they are also used as device addresses, however on
+ * USB-3.0 buses the address is assigned by the controller hardware
+ * and it usually is not the same as the device number.
+ *
  * WUSB devices are simple: they have no hubs behind, so the mapping
  * device &lt;-&gt; virtual port number becomes 1:1. Why? to simplify the
  * life of the device connection logic in
@@ -1520,7 +1527,7 @@ EXPORT_SYMBOL_GPL(usb_set_device_state);
  * the HCD must setup data structures before issuing a set address
  * command to the hardware.
  */
-static void choose_address(struct usb_device *udev)
+static void choose_devnum(struct usb_device *udev)
 {
 	int		devnum;
 	struct usb_bus	*bus = udev-&gt;bus;
@@ -1545,7 +1552,7 @@ static void choose_address(struct usb_device *udev)
 	}
 }
 
-static void release_address(struct usb_device *udev)
+static void release_devnum(struct usb_device *udev)
 {
 	if (udev-&gt;devnum &gt; 0) {
 		clear_bit(udev-&gt;devnum, udev-&gt;bus-&gt;devmap.devicemap);
@@ -1553,7 +1560,7 @@ static void release_address(struct usb_device *udev)
 	}
 }
 
-static void update_address(struct usb_device *udev, int devnum)
+static void update_devnum(struct usb_device *udev, int devnum)
 {
 	/* The address for a WUSB device is managed by wusbcore. */
 	if (!udev-&gt;wusb)
@@ -1600,7 +1607,8 @@ void usb_disconnect(struct usb_device **pdev)
 	 * this quiesces everyting except pending urbs.
 	 */
 	usb_set_device_state(udev, USB_STATE_NOTATTACHED);
-	dev_info (&amp;udev-&gt;dev, "USB disconnect, address %d\n", udev-&gt;devnum);
+	dev_info(&amp;udev-&gt;dev, "USB disconnect, device number %d\n",
+			udev-&gt;devnum);
 
 	usb_lock_device(udev);
 
@@ -1630,7 +1638,7 @@ void usb_disconnect(struct usb_device **pdev)
 	/* Free the device number and delete the parent's children[]
 	 * (or root_hub) pointer.
 	 */
-	release_address(udev);
+	release_devnum(udev);
 
 	/* Avoid races with recursively_mark_NOTATTACHED() */
 	spin_lock_irq(&amp;device_state_lock);
@@ -2071,7 +2079,7 @@ static int hub_port_reset(struct usb_hub *hub, int port1,
 		case 0:
 			/* TRSTRCY = 10 ms; plus some extra */
 			msleep(10 + 40);
-			update_address(udev, 0);
+			update_devnum(udev, 0);
 			if (hcd-&gt;driver-&gt;reset_device) {
 				status = hcd-&gt;driver-&gt;reset_device(hcd, udev);
 				if (status &lt; 0) {
@@ -2634,7 +2642,7 @@ static int hub_set_address(struct usb_device *udev, int devnum)
 				USB_REQ_SET_ADDRESS, 0, devnum, 0,
 				NULL, 0, USB_CTRL_SET_TIMEOUT);
 	if (retval == 0) {
-		update_address(udev, devnum);
+		update_devnum(udev, devnum);
 		/* Device now using proper address. */
 		usb_set_device_state(udev, USB_STATE_ADDRESS);
 		usb_ep0_reinit(udev);
@@ -2743,9 +2751,9 @@ hub_port_init (struct usb_hub *hub, struct usb_device *udev, int port1,
 	}
 	if (udev-&gt;speed != USB_SPEED_SUPER)
 		dev_info(&amp;udev-&gt;dev,
-				"%s %s speed %sUSB device using %s and address %d\n",
+				"%s %s speed %sUSB device number %d using %s\n",
 				(udev-&gt;config) ? "reset" : "new", speed, type,
-				udev-&gt;bus-&gt;controller-&gt;driver-&gt;name, devnum);
+				devnum, udev-&gt;bus-&gt;controller-&gt;driver-&gt;name);
 
 	/* Set up TT records, if needed  */
 	if (hdev-&gt;tt) {
@@ -2775,10 +2783,6 @@ hub_port_init (struct usb_hub *hub, struct usb_device *udev, int port1,
 	 * value.
 	 */
 	for (i = 0; i &lt; GET_DESCRIPTOR_TRIES; (++i, msleep(100))) {
-		/*
-		 * An xHCI controller cannot send any packets to a device until
-		 * a set address command successfully completes.
-		 */
 		if (USE_NEW_SCHEME(retry_counter) &amp;&amp; !(hcd-&gt;driver-&gt;flags &amp; HCD_USB3)) {
 			struct usb_device_descriptor *buf;
 			int r = 0;
@@ -2861,9 +2865,9 @@ hub_port_init (struct usb_hub *hub, struct usb_device *udev, int port1,
 			if (udev-&gt;speed == USB_SPEED_SUPER) {
 				devnum = udev-&gt;devnum;
 				dev_info(&amp;udev-&gt;dev,
-						"%s SuperSpeed USB device using %s and address %d\n",
+						"%s SuperSpeed USB device number %d using %s\n",
 						(udev-&gt;config) ? "reset" : "new",
-						udev-&gt;bus-&gt;controller-&gt;driver-&gt;name, devnum);
+						devnum, udev-&gt;bus-&gt;controller-&gt;driver-&gt;name);
 			}
 
 			/* cope with hardware quirkiness:
@@ -2926,7 +2930,7 @@ hub_port_init (struct usb_hub *hub, struct usb_device *udev, int port1,
 fail:
 	if (retval) {
 		hub_port_disable(hub, port1, 0);
-		update_address(udev, devnum);	/* for disconnect processing */
+		update_devnum(udev, devnum);	/* for disconnect processing */
 	}
 	mutex_unlock(&amp;usb_address0_mutex);
 	return retval;
@@ -3135,15 +3139,7 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 		else
 			udev-&gt;speed = USB_SPEED_UNKNOWN;
 
-		/*
-		 * Set the address.
-		 * Note xHCI needs to issue an address device command later
-		 * in the hub_port_init sequence for SS/HS/FS/LS devices,
-		 * and xHC will assign an address to the device. But use
-		 * kernel assigned address here, to avoid any address conflict
-		 * issue.
-		 */
-		choose_address(udev);
+		choose_devnum(udev);
 		if (udev-&gt;devnum &lt;= 0) {
 			status = -ENOTCONN;	/* Don't retry */
 			goto loop;
@@ -3235,7 +3231,7 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 		hub_port_disable(hub, port1, 1);
 loop:
 		usb_ep0_reinit(udev);
-		release_address(udev);
+		release_devnum(udev);
 		hub_free_dev(udev);
 		usb_put_dev(udev);
 		if ((status == -ENOTCONN) || (status == -ENOTSUPP))</pre><hr><pre>commit 3c18e30f87ac5466bddbb05cf955605efd7db025
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Feb 17 10:26:38 2011 -0500

    USB: add quirks entry for Keytouch QWERTY Panel
    
    This patch (as1448) adds a quirks entry for the Keytouch QWERTY Panel
    firmware, used in the IEC 60945 keyboard.  This device crashes during
    enumeration when the computer asks for its configuration string
    descriptor.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: kholis &lt;nur.kholis.majid@gmail.com&gt;
    CC: &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c
index 44c595432d6f..92ce90b83126 100644
--- a/drivers/usb/core/quirks.c
+++ b/drivers/usb/core/quirks.c
@@ -68,6 +68,10 @@ static const struct usb_device_id usb_quirk_list[] = {
 	/* M-Systems Flash Disk Pioneers */
 	{ USB_DEVICE(0x08ec, 0x1000), .driver_info = USB_QUIRK_RESET_RESUME },
 
+	/* Keytouch QWERTY Panel keyboard */
+	{ USB_DEVICE(0x0926, 0x3333), .driver_info =
+			USB_QUIRK_CONFIG_INTF_STRINGS },
+
 	/* X-Rite/Gretag-Macbeth Eye-One Pro display colorimeter */
 	{ USB_DEVICE(0x0971, 0x2000), .driver_info = USB_QUIRK_NO_SET_INTF },
 </pre>
    <div class="pagination">
        <a href='2_57.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><span>[58]</span><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_59.html'>Next&gt;&gt;</a>
    <div>
</body>
