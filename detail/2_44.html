<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_43.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><span>[44]</span><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_45.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 88d26136a256576e444db312179e17af6dd0ea87
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Sep 19 21:59:02 2012 +0200

    PM: Prevent runtime suspend during system resume
    
    This patch (as1591) moves the pm_runtime_get_noresume() and
    pm_runtime_put_sync() calls from __device_suspend() and
    device_resume() to device_prepare() and device_complete() in the PM
    core.
    
    The reason for doing this is to make sure that parent devices remain
    at full power (i.e., don't go into runtime suspend) while their
    children are being resumed from a system sleep.
    
    The PCI core already contained equivalent code to serve the same
    purpose.  The patch removes the duplicated code, since it is no longer
    needed.  One of the comments from the PCI core gets moved into the PM
    core, and a second comment is added to explain whe the _get_noresume
    and _put_sync calls are present.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;

diff --git a/drivers/base/power/main.c b/drivers/base/power/main.c
index 2700f2e4066f..077b9756fd8f 100644
--- a/drivers/base/power/main.c
+++ b/drivers/base/power/main.c
@@ -565,7 +565,6 @@ static int device_resume(struct device *dev, pm_message_t state, bool async)
 	pm_callback_t callback = NULL;
 	char *info = NULL;
 	int error = 0;
-	bool put = false;
 
 	TRACE_DEVICE(dev);
 	TRACE_RESUME(0);
@@ -583,7 +582,6 @@ static int device_resume(struct device *dev, pm_message_t state, bool async)
 		goto Unlock;
 
 	pm_runtime_enable(dev);
-	put = true;
 
 	if (dev-&gt;pm_domain) {
 		info = "power domain ";
@@ -636,9 +634,6 @@ static int device_resume(struct device *dev, pm_message_t state, bool async)
 
 	TRACE_RESUME(error);
 
-	if (put)
-		pm_runtime_put_sync(dev);
-
 	return error;
 }
 
@@ -749,6 +744,8 @@ static void device_complete(struct device *dev, pm_message_t state)
 	}
 
 	device_unlock(dev);
+
+	pm_runtime_put_sync(dev);
 }
 
 /**
@@ -1043,12 +1040,16 @@ static int __device_suspend(struct device *dev, pm_message_t state, bool async)
 	if (async_error)
 		goto Complete;
 
-	pm_runtime_get_noresume(dev);
+	/*
+	 * If a device configured to wake up the system from sleep states
+	 * has been suspended at run time and there's a resume request pending
+	 * for it, this is equivalent to the device signaling wakeup, so the
+	 * system suspend operation should be aborted.
+	 */
 	if (pm_runtime_barrier(dev) &amp;&amp; device_may_wakeup(dev))
 		pm_wakeup_event(dev, 0);
 
 	if (pm_wakeup_pending()) {
-		pm_runtime_put_sync(dev);
 		async_error = -EBUSY;
 		goto Complete;
 	}
@@ -1111,12 +1112,10 @@ static int __device_suspend(struct device *dev, pm_message_t state, bool async)
  Complete:
 	complete_all(&amp;dev-&gt;power.completion);
 
-	if (error) {
-		pm_runtime_put_sync(dev);
+	if (error)
 		async_error = error;
-	} else if (dev-&gt;power.is_suspended) {
+	else if (dev-&gt;power.is_suspended)
 		__pm_runtime_disable(dev, false);
-	}
 
 	return error;
 }
@@ -1209,6 +1208,14 @@ static int device_prepare(struct device *dev, pm_message_t state)
 	char *info = NULL;
 	int error = 0;
 
+	/*
+	 * If a device's parent goes into runtime suspend at the wrong time,
+	 * it won't be possible to resume the device.  To prevent this we
+	 * block runtime suspend here, during the prepare phase, and allow
+	 * it again during the complete phase.
+	 */
+	pm_runtime_get_noresume(dev);
+
 	device_lock(dev);
 
 	dev-&gt;power.wakeup_path = device_may_wakeup(dev);
diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 185be3703343..51cd90bcdd4c 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -623,21 +623,6 @@ static int pci_pm_prepare(struct device *dev)
 	struct device_driver *drv = dev-&gt;driver;
 	int error = 0;
 
-	/*
-	 * If a PCI device configured to wake up the system from sleep states
-	 * has been suspended at run time and there's a resume request pending
-	 * for it, this is equivalent to the device signaling wakeup, so the
-	 * system suspend operation should be aborted.
-	 */
-	pm_runtime_get_noresume(dev);
-	if (pm_runtime_barrier(dev) &amp;&amp; device_may_wakeup(dev))
-		pm_wakeup_event(dev, 0);
-
-	if (pm_wakeup_pending()) {
-		pm_runtime_put_sync(dev);
-		return -EBUSY;
-	}
-
 	/*
 	 * PCI devices suspended at run time need to be resumed at this
 	 * point, because in general it is necessary to reconfigure them for
@@ -661,8 +646,6 @@ static void pci_pm_complete(struct device *dev)
 
 	if (drv &amp;&amp; drv-&gt;pm &amp;&amp; drv-&gt;pm-&gt;complete)
 		drv-&gt;pm-&gt;complete(dev);
-
-	pm_runtime_put_sync(dev);
 }
 
 #else /* !CONFIG_PM_SLEEP */</pre><hr><pre>commit 92fc7a8b0f20bdb243c706daf42658e8e0cd2ef0
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 4 10:41:02 2012 -0400

    USB: add device quirk for Joss Optical touchboard
    
    This patch (as1604) adds a CONFIG_INTF_STRINGS quirk for the Joss
    infrared touchboard device.  The device doesn't like to be asked for
    its interface strings.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: adam ? &lt;adam3337@wp.pl&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c
index f15501f4c585..e77a8e8eaa23 100644
--- a/drivers/usb/core/quirks.c
+++ b/drivers/usb/core/quirks.c
@@ -71,6 +71,10 @@ static const struct usb_device_id usb_quirk_list[] = {
 	{ USB_DEVICE(0x04b4, 0x0526), .driver_info =
 			USB_QUIRK_CONFIG_INTF_STRINGS },
 
+	/* Microchip Joss Optical infrared touchboard device */
+	{ USB_DEVICE(0x04d8, 0x000c), .driver_info =
+			USB_QUIRK_CONFIG_INTF_STRINGS },
+
 	/* Samsung Android phone modem - ID conflict with SPH-I500 */
 	{ USB_DEVICE(0x04e8, 0x6601), .driver_info =
 			USB_QUIRK_CONFIG_INTF_STRINGS },</pre><hr><pre>commit d0d860758bd350206242962a223858bd01cd8a93
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Aug 20 16:12:47 2012 -0400

    usb: gadget: dummy-hcd: remember to update driver pointer
    
    This patch (as1599) fixes dummy-hcd to make it update the appropriate
    driver pointer when a new gadget driver is bound or unbound.  Without
    this change, the gadget driver's name doesn't appear in dev_printk
    output.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Felipe Balbi &lt;balbi@ti.com&gt;

diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index b799106027ad..91916f693ff7 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -909,6 +909,7 @@ static int dummy_udc_start(struct usb_gadget *g,
 	dum-&gt;devstatus = 0;
 
 	dum-&gt;driver = driver;
+	dum-&gt;gadget.dev.driver = &amp;driver-&gt;driver;
 	dev_dbg(udc_dev(dum), "binding gadget driver '%s'\n",
 			driver-&gt;driver.name);
 	return 0;
@@ -923,6 +924,7 @@ static int dummy_udc_stop(struct usb_gadget *g,
 	dev_dbg(udc_dev(dum), "unregister gadget driver '%s'\n",
 			driver-&gt;driver.name);
 
+	dum-&gt;gadget.dev.driver = NULL;
 	dum-&gt;driver = NULL;
 
 	return 0;</pre><hr><pre>commit 67ddbb3e6568fb1820b2cc45b00c50702b114801
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Aug 23 10:51:55 2012 -0400

    HID: add NOGET quirk for Eaton Ellipse MAX UPS
    
    This patch (as1603) adds a NOGET quirk for the Eaton Ellipse MAX UPS
    device.  (The USB IDs were already present in hid-ids.h, apparently
    under a different name.)
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Laurent Bigonville &lt;l.bigonville@edpnet.be&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/usbhid/hid-quirks.c b/drivers/hid/usbhid/hid-quirks.c
index 903eef3d3e10..991e85c7325c 100644
--- a/drivers/hid/usbhid/hid-quirks.c
+++ b/drivers/hid/usbhid/hid-quirks.c
@@ -70,6 +70,7 @@ static const struct hid_blacklist {
 	{ USB_VENDOR_ID_CH, USB_DEVICE_ID_CH_AXIS_295, HID_QUIRK_NOGET },
 	{ USB_VENDOR_ID_DMI, USB_DEVICE_ID_DMI_ENC, HID_QUIRK_NOGET },
 	{ USB_VENDOR_ID_ELO, USB_DEVICE_ID_ELO_TS2700, HID_QUIRK_NOGET },
+	{ USB_VENDOR_ID_MGE, USB_DEVICE_ID_MGE_UPS, HID_QUIRK_NOGET },
 	{ USB_VENDOR_ID_PIXART, USB_DEVICE_ID_PIXART_OPTICAL_TOUCH_SCREEN, HID_QUIRK_NO_INIT_REPORTS },
 	{ USB_VENDOR_ID_PIXART, USB_DEVICE_ID_PIXART_OPTICAL_TOUCH_SCREEN1, HID_QUIRK_NO_INIT_REPORTS },
 	{ USB_VENDOR_ID_PIXART, USB_DEVICE_ID_PIXART_OPTICAL_TOUCH_SCREEN2, HID_QUIRK_NO_INIT_REPORTS },</pre><hr><pre>commit eb055fd0560b9835e9e1a956aa6a83c51a735801
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jul 19 16:09:01 2012 -0400

    HID: usbhid: fix error paths in suspend
    
    This patch (as1597) fixes some of the error paths in usbhid's suspend
    routine.  The driver was not careful to restart everything that might
    have been stopped, in cases where a suspend failed.
    
    For example, once the HID_SUSPENDED flag is set, an output report
    submission would not restart the corresponding URB queue.  If a
    suspend fails, it's therefore necessary to check whether the queues
    need to be restarted.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Oliver Neukum &lt;oliver@neukum.org&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c
index 4309c03038f6..dedd8e4e5c6d 100644
--- a/drivers/hid/usbhid/hid-core.c
+++ b/drivers/hid/usbhid/hid-core.c
@@ -993,9 +993,10 @@ static int usbhid_output_raw_report(struct hid_device *hid, __u8 *buf, size_t co
 
 static void usbhid_restart_queues(struct usbhid_device *usbhid)
 {
-	if (usbhid-&gt;urbout)
+	if (usbhid-&gt;urbout &amp;&amp; !test_bit(HID_OUT_RUNNING, &amp;usbhid-&gt;iofl))
 		usbhid_restart_out_queue(usbhid);
-	usbhid_restart_ctrl_queue(usbhid);
+	if (!test_bit(HID_CTRL_RUNNING, &amp;usbhid-&gt;iofl))
+		usbhid_restart_ctrl_queue(usbhid);
 }
 
 static void hid_free_buffers(struct usb_device *dev, struct hid_device *hid)
@@ -1462,11 +1463,38 @@ void usbhid_put_power(struct hid_device *hid)
 
 
 #ifdef CONFIG_PM
+static int hid_resume_common(struct hid_device *hid, bool driver_suspended)
+{
+	struct usbhid_device *usbhid = hid-&gt;driver_data;
+	int status;
+
+	spin_lock_irq(&amp;usbhid-&gt;lock);
+	clear_bit(HID_SUSPENDED, &amp;usbhid-&gt;iofl);
+	usbhid_mark_busy(usbhid);
+
+	if (test_bit(HID_CLEAR_HALT, &amp;usbhid-&gt;iofl) ||
+			test_bit(HID_RESET_PENDING, &amp;usbhid-&gt;iofl))
+		schedule_work(&amp;usbhid-&gt;reset_work);
+	usbhid-&gt;retry_delay = 0;
+
+	usbhid_restart_queues(usbhid);
+	spin_unlock_irq(&amp;usbhid-&gt;lock);
+
+	status = hid_start_in(hid);
+	if (status &lt; 0)
+		hid_io_error(hid);
+
+	if (driver_suspended &amp;&amp; hid-&gt;driver &amp;&amp; hid-&gt;driver-&gt;resume)
+		status = hid-&gt;driver-&gt;resume(hid);
+	return status;
+}
+
 static int hid_suspend(struct usb_interface *intf, pm_message_t message)
 {
 	struct hid_device *hid = usb_get_intfdata(intf);
 	struct usbhid_device *usbhid = hid-&gt;driver_data;
 	int status;
+	bool driver_suspended = false;
 
 	if (PMSG_IS_AUTO(message)) {
 		spin_lock_irq(&amp;usbhid-&gt;lock);	/* Sync with error handler */
@@ -1482,8 +1510,9 @@ static int hid_suspend(struct usb_interface *intf, pm_message_t message)
 			if (hid-&gt;driver &amp;&amp; hid-&gt;driver-&gt;suspend) {
 				status = hid-&gt;driver-&gt;suspend(hid, message);
 				if (status &lt; 0)
-					return status;
+					goto failed;
 			}
+			driver_suspended = true;
 		} else {
 			usbhid_mark_busy(usbhid);
 			spin_unlock_irq(&amp;usbhid-&gt;lock);
@@ -1496,11 +1525,14 @@ static int hid_suspend(struct usb_interface *intf, pm_message_t message)
 			if (status &lt; 0)
 				return status;
 		}
+		driver_suspended = true;
 		spin_lock_irq(&amp;usbhid-&gt;lock);
 		set_bit(HID_SUSPENDED, &amp;usbhid-&gt;iofl);
 		spin_unlock_irq(&amp;usbhid-&gt;lock);
-		if (usbhid_wait_io(hid) &lt; 0)
-			return -EIO;
+		if (usbhid_wait_io(hid) &lt; 0) {
+			status = -EIO;
+			goto failed;
+		}
 	}
 
 	hid_cancel_delayed_stuff(usbhid);
@@ -1508,14 +1540,15 @@ static int hid_suspend(struct usb_interface *intf, pm_message_t message)
 
 	if (PMSG_IS_AUTO(message) &amp;&amp; test_bit(HID_KEYS_PRESSED, &amp;usbhid-&gt;iofl)) {
 		/* lost race against keypresses */
-		status = hid_start_in(hid);
-		if (status &lt; 0)
-			hid_io_error(hid);
-		usbhid_mark_busy(usbhid);
-		return -EBUSY;
+		status = -EBUSY;
+		goto failed;
 	}
 	dev_dbg(&amp;intf-&gt;dev, "suspend\n");
 	return 0;
+
+ failed:
+	hid_resume_common(hid, driver_suspended);
+	return status;
 }
 
 static int hid_resume(struct usb_interface *intf)
@@ -1527,23 +1560,7 @@ static int hid_resume(struct usb_interface *intf)
 	if (!test_bit(HID_STARTED, &amp;usbhid-&gt;iofl))
 		return 0;
 
-	clear_bit(HID_SUSPENDED, &amp;usbhid-&gt;iofl);
-	usbhid_mark_busy(usbhid);
-
-	if (test_bit(HID_CLEAR_HALT, &amp;usbhid-&gt;iofl) ||
-	    test_bit(HID_RESET_PENDING, &amp;usbhid-&gt;iofl))
-		schedule_work(&amp;usbhid-&gt;reset_work);
-	usbhid-&gt;retry_delay = 0;
-	status = hid_start_in(hid);
-	if (status &lt; 0)
-		hid_io_error(hid);
-	usbhid_restart_queues(usbhid);
-
-	if (status &gt;= 0 &amp;&amp; hid-&gt;driver &amp;&amp; hid-&gt;driver-&gt;resume) {
-		int ret = hid-&gt;driver-&gt;resume(hid);
-		if (ret &lt; 0)
-			status = ret;
-	}
+	status = hid_resume_common(hid, true);
 	dev_dbg(&amp;intf-&gt;dev, "resume status %d\n", status);
 	return 0;
 }</pre><hr><pre>commit d4150c8f3d80b4a9387083478a86da8b3390dd83
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jul 19 16:08:54 2012 -0400

    HID: usbhid: check for suspend or reset before restarting
    
    This patch (as1596) improves the queue-restart logic in usbhid by
    checking to see if the device is suspended or a reset is about to
    occur.  There's no point submitting an URB if either of those is
    true.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Oliver Neukum &lt;oliver@neukum.org&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c
index 271578b85d91..4309c03038f6 100644
--- a/drivers/hid/usbhid/hid-core.c
+++ b/drivers/hid/usbhid/hid-core.c
@@ -207,7 +207,8 @@ static int usbhid_restart_out_queue(struct usbhid_device *usbhid)
 	int kicked;
 	int r;
 
-	if (!hid)
+	if (!hid || test_bit(HID_RESET_PENDING, &amp;usbhid-&gt;iofl) ||
+			test_bit(HID_SUSPENDED, &amp;usbhid-&gt;iofl))
 		return 0;
 
 	if ((kicked = (usbhid-&gt;outhead != usbhid-&gt;outtail))) {
@@ -245,7 +246,8 @@ static int usbhid_restart_ctrl_queue(struct usbhid_device *usbhid)
 	int r;
 
 	WARN_ON(hid == NULL);
-	if (!hid)
+	if (!hid || test_bit(HID_RESET_PENDING, &amp;usbhid-&gt;iofl) ||
+			test_bit(HID_SUSPENDED, &amp;usbhid-&gt;iofl))
 		return 0;
 
 	if ((kicked = (usbhid-&gt;ctrlhead != usbhid-&gt;ctrltail))) {</pre><hr><pre>commit f2b5264d4f77328e45d73cd135772b6e88a4951a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jul 19 16:08:45 2012 -0400

    HID: usbhid: replace HID_REPORTED_IDLE with HID_SUSPENDED
    
    This patch (as1595) improves the usbhid driver by using the
    HID_SUSPENDED bitflag to indicate that the device is suspended rather
    than using HID_REPORTED_IDLE, which the patch removes.
    
    Since HID_SUSPENDED was not being used for anything, and since the
    name "HID_REPORTED_IDLE" doesn't convey much meaning, the end result
    is easier to read and understand.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Oliver Neukum &lt;oliver@neukum.org&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c
index 0fa07d95202d..271578b85d91 100644
--- a/drivers/hid/usbhid/hid-core.c
+++ b/drivers/hid/usbhid/hid-core.c
@@ -84,7 +84,7 @@ static int hid_start_in(struct hid_device *hid)
 	spin_lock_irqsave(&amp;usbhid-&gt;lock, flags);
 	if (hid-&gt;open &gt; 0 &amp;&amp;
 			!test_bit(HID_DISCONNECTED, &amp;usbhid-&gt;iofl) &amp;&amp;
-			!test_bit(HID_REPORTED_IDLE, &amp;usbhid-&gt;iofl) &amp;&amp;
+			!test_bit(HID_SUSPENDED, &amp;usbhid-&gt;iofl) &amp;&amp;
 			!test_and_set_bit(HID_IN_RUNNING, &amp;usbhid-&gt;iofl)) {
 		rc = usb_submit_urb(usbhid-&gt;urbin, GFP_ATOMIC);
 		if (rc != 0) {
@@ -222,7 +222,7 @@ static int usbhid_restart_out_queue(struct usbhid_device *usbhid)
 		 * If still suspended, don't submit.  Submission will
 		 * occur if/when resume drains the queue.
 		 */
-		if (test_bit(HID_REPORTED_IDLE, &amp;usbhid-&gt;iofl)) {
+		if (test_bit(HID_SUSPENDED, &amp;usbhid-&gt;iofl)) {
 			usb_autopm_put_interface_no_suspend(usbhid-&gt;intf);
 			return r;
 		}
@@ -260,7 +260,7 @@ static int usbhid_restart_ctrl_queue(struct usbhid_device *usbhid)
 		 * If still suspended, don't submit.  Submission will
 		 * occur if/when resume drains the queue.
 		 */
-		if (test_bit(HID_REPORTED_IDLE, &amp;usbhid-&gt;iofl)) {
+		if (test_bit(HID_SUSPENDED, &amp;usbhid-&gt;iofl)) {
 			usb_autopm_put_interface_no_suspend(usbhid-&gt;intf);
 			return r;
 		}
@@ -1475,7 +1475,7 @@ static int hid_suspend(struct usb_interface *intf, pm_message_t message)
 		    &amp;&amp; !test_bit(HID_KEYS_PRESSED, &amp;usbhid-&gt;iofl)
 		    &amp;&amp; (!usbhid-&gt;ledcount || ignoreled))
 		{
-			set_bit(HID_REPORTED_IDLE, &amp;usbhid-&gt;iofl);
+			set_bit(HID_SUSPENDED, &amp;usbhid-&gt;iofl);
 			spin_unlock_irq(&amp;usbhid-&gt;lock);
 			if (hid-&gt;driver &amp;&amp; hid-&gt;driver-&gt;suspend) {
 				status = hid-&gt;driver-&gt;suspend(hid, message);
@@ -1495,7 +1495,7 @@ static int hid_suspend(struct usb_interface *intf, pm_message_t message)
 				return status;
 		}
 		spin_lock_irq(&amp;usbhid-&gt;lock);
-		set_bit(HID_REPORTED_IDLE, &amp;usbhid-&gt;iofl);
+		set_bit(HID_SUSPENDED, &amp;usbhid-&gt;iofl);
 		spin_unlock_irq(&amp;usbhid-&gt;lock);
 		if (usbhid_wait_io(hid) &lt; 0)
 			return -EIO;
@@ -1525,7 +1525,7 @@ static int hid_resume(struct usb_interface *intf)
 	if (!test_bit(HID_STARTED, &amp;usbhid-&gt;iofl))
 		return 0;
 
-	clear_bit(HID_REPORTED_IDLE, &amp;usbhid-&gt;iofl);
+	clear_bit(HID_SUSPENDED, &amp;usbhid-&gt;iofl);
 	usbhid_mark_busy(usbhid);
 
 	if (test_bit(HID_CLEAR_HALT, &amp;usbhid-&gt;iofl) ||
@@ -1552,7 +1552,7 @@ static int hid_reset_resume(struct usb_interface *intf)
 	struct usbhid_device *usbhid = hid-&gt;driver_data;
 	int status;
 
-	clear_bit(HID_REPORTED_IDLE, &amp;usbhid-&gt;iofl);
+	clear_bit(HID_SUSPENDED, &amp;usbhid-&gt;iofl);
 	status = hid_post_reset(intf);
 	if (status &gt;= 0 &amp;&amp; hid-&gt;driver &amp;&amp; hid-&gt;driver-&gt;reset_resume) {
 		int ret = hid-&gt;driver-&gt;reset_resume(hid);
diff --git a/drivers/hid/usbhid/usbhid.h b/drivers/hid/usbhid/usbhid.h
index 1883d7b94870..bd87a61e5303 100644
--- a/drivers/hid/usbhid/usbhid.h
+++ b/drivers/hid/usbhid/usbhid.h
@@ -53,7 +53,6 @@ struct usb_interface *usbhid_find_interface(int minor);
 #define HID_CLEAR_HALT		6
 #define HID_DISCONNECTED	7
 #define HID_STARTED		8
-#define HID_REPORTED_IDLE	9
 #define HID_KEYS_PRESSED	10
 #define HID_NO_BANDWIDTH	11
 </pre><hr><pre>commit 93101af31bc5df4486103f6b3ef212aaa5341b09
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jul 19 16:08:39 2012 -0400

    HID: usbhid: inline some simple routines
    
    This patch (as1594) simplifies the usbhid driver by inlining a couple
    of routines.  As a result of an earlier patch, irq_out_pump_restart()
    and ctrl_pump_restart() are each used in only one place.  Since they
    don't really do what their names say, and since they each involve only
    about two lines of actual code, there's no reason to keep them as
    separate functions.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Oliver Neukum &lt;oliver@neukum.org&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c
index 213b3f39753c..0fa07d95202d 100644
--- a/drivers/hid/usbhid/hid-core.c
+++ b/drivers/hid/usbhid/hid-core.c
@@ -435,16 +435,6 @@ static int hid_submit_ctrl(struct hid_device *hid)
  * Output interrupt completion handler.
  */
 
-static int irq_out_pump_restart(struct hid_device *hid)
-{
-	struct usbhid_device *usbhid = hid-&gt;driver_data;
-
-	if (usbhid-&gt;outhead != usbhid-&gt;outtail)
-		return hid_submit_out(hid);
-	else
-		return -1;
-}
-
 static void hid_irq_out(struct urb *urb)
 {
 	struct hid_device *hid = urb-&gt;context;
@@ -469,15 +459,17 @@ static void hid_irq_out(struct urb *urb)
 
 	spin_lock_irqsave(&amp;usbhid-&gt;lock, flags);
 
-	if (unplug)
+	if (unplug) {
 		usbhid-&gt;outtail = usbhid-&gt;outhead;
-	else
+	} else {
 		usbhid-&gt;outtail = (usbhid-&gt;outtail + 1) &amp; (HID_OUTPUT_FIFO_SIZE - 1);
 
-	if (!irq_out_pump_restart(hid)) {
-		/* Successfully submitted next urb in queue */
-		spin_unlock_irqrestore(&amp;usbhid-&gt;lock, flags);
-		return;
+		if (usbhid-&gt;outhead != usbhid-&gt;outtail &amp;&amp;
+				hid_submit_out(hid) == 0) {
+			/* Successfully submitted next urb in queue */
+			spin_unlock_irqrestore(&amp;usbhid-&gt;lock, flags);
+			return;
+		}
 	}
 
 	clear_bit(HID_OUT_RUNNING, &amp;usbhid-&gt;iofl);
@@ -489,15 +481,6 @@ static void hid_irq_out(struct urb *urb)
 /*
  * Control pipe completion handler.
  */
-static int ctrl_pump_restart(struct hid_device *hid)
-{
-	struct usbhid_device *usbhid = hid-&gt;driver_data;
-
-	if (usbhid-&gt;ctrlhead != usbhid-&gt;ctrltail)
-		return hid_submit_ctrl(hid);
-	else
-		return -1;
-}
 
 static void hid_ctrl(struct urb *urb)
 {
@@ -526,15 +509,17 @@ static void hid_ctrl(struct urb *urb)
 		hid_warn(urb-&gt;dev, "ctrl urb status %d received\n", status);
 	}
 
-	if (unplug)
+	if (unplug) {
 		usbhid-&gt;ctrltail = usbhid-&gt;ctrlhead;
-	else
+	} else {
 		usbhid-&gt;ctrltail = (usbhid-&gt;ctrltail + 1) &amp; (HID_CONTROL_FIFO_SIZE - 1);
 
-	if (!ctrl_pump_restart(hid)) {
-		/* Successfully submitted next urb in queue */
-		spin_unlock(&amp;usbhid-&gt;lock);
-		return;
+		if (usbhid-&gt;ctrlhead != usbhid-&gt;ctrltail &amp;&amp;
+				hid_submit_ctrl(hid) == 0) {
+			/* Successfully submitted next urb in queue */
+			spin_unlock(&amp;usbhid-&gt;lock);
+			return;
+		}
 	}
 
 	clear_bit(HID_CTRL_RUNNING, &amp;usbhid-&gt;iofl);</pre><hr><pre>commit 01a7c984e86fd45b760bb0da8b635059dff602e1
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jul 19 16:08:31 2012 -0400

    HID: usbhid: fix autosuspend calls
    
    This patch (as1593) fixes some logic errors in the usbhid driver
    relating to runtime PM.  The driver does not balance its calls to
    usb_autopm_get_interface_async() and usb_autopm_put_interface_async().
    
    For example, when the control queue is restarted the driver does a
    _get.  But the resume won't happen immediately, so the driver leaves
    the queue stopped.  When the resume does occur, the queue is restarted
    and a second _get occurs, with no balancing _put.
    
    The patch fixes the problem by rearranging the logic for restarting
    the queues.  All the _get/_put calls and bitflag settings in
    __usbhid_submit_report() are moved into the queue-restart routines.  A
    balancing _put call is added for the case where the queue is still
    suspended.  A call to irq_out_pump_restart(), which doesn't take all
    the right actions for restarting the irq-OUT queue, is replaced by a
    call to usbhid_restart_out_queue(), which does.  Similarly for
    ctrl_pump_restart().
    
    Finally, new code is added to prevent an autosuspend from happening
    every time an URB is cancelled, and the comments explaining what
    happens when an URB needs to be cancelled are expanded and clarified.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Oliver Neukum &lt;oliver@neukum.org&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c
index 6b9bad540702..213b3f39753c 100644
--- a/drivers/hid/usbhid/hid-core.c
+++ b/drivers/hid/usbhid/hid-core.c
@@ -213,9 +213,20 @@ static int usbhid_restart_out_queue(struct usbhid_device *usbhid)
 	if ((kicked = (usbhid-&gt;outhead != usbhid-&gt;outtail))) {
 		hid_dbg(hid, "Kicking head %d tail %d", usbhid-&gt;outhead, usbhid-&gt;outtail);
 
+		/* Try to wake up from autosuspend... */
 		r = usb_autopm_get_interface_async(usbhid-&gt;intf);
 		if (r &lt; 0)
 			return r;
+
+		/*
+		 * If still suspended, don't submit.  Submission will
+		 * occur if/when resume drains the queue.
+		 */
+		if (test_bit(HID_REPORTED_IDLE, &amp;usbhid-&gt;iofl)) {
+			usb_autopm_put_interface_no_suspend(usbhid-&gt;intf);
+			return r;
+		}
+
 		/* Asynchronously flush queue. */
 		set_bit(HID_OUT_RUNNING, &amp;usbhid-&gt;iofl);
 		if (hid_submit_out(hid)) {
@@ -240,9 +251,20 @@ static int usbhid_restart_ctrl_queue(struct usbhid_device *usbhid)
 	if ((kicked = (usbhid-&gt;ctrlhead != usbhid-&gt;ctrltail))) {
 		hid_dbg(hid, "Kicking head %d tail %d", usbhid-&gt;ctrlhead, usbhid-&gt;ctrltail);
 
+		/* Try to wake up from autosuspend... */
 		r = usb_autopm_get_interface_async(usbhid-&gt;intf);
 		if (r &lt; 0)
 			return r;
+
+		/*
+		 * If still suspended, don't submit.  Submission will
+		 * occur if/when resume drains the queue.
+		 */
+		if (test_bit(HID_REPORTED_IDLE, &amp;usbhid-&gt;iofl)) {
+			usb_autopm_put_interface_no_suspend(usbhid-&gt;intf);
+			return r;
+		}
+
 		/* Asynchronously flush queue. */
 		set_bit(HID_CTRL_RUNNING, &amp;usbhid-&gt;iofl);
 		if (hid_submit_ctrl(hid)) {
@@ -546,49 +568,36 @@ static void __usbhid_submit_report(struct hid_device *hid, struct hid_report *re
 		usbhid-&gt;out[usbhid-&gt;outhead].report = report;
 		usbhid-&gt;outhead = head;
 
-		/* Try to awake from autosuspend... */
-		if (usb_autopm_get_interface_async(usbhid-&gt;intf) &lt; 0)
-			return;
+		/* If the queue isn't running, restart it */
+		if (!test_bit(HID_OUT_RUNNING, &amp;usbhid-&gt;iofl)) {
+			usbhid_restart_out_queue(usbhid);
 
-		/*
-		 * But if still suspended, leave urb enqueued, don't submit.
-		 * Submission will occur if/when resume() drains the queue.
-		 */
-		if (test_bit(HID_REPORTED_IDLE, &amp;usbhid-&gt;iofl))
-			return;
+		/* Otherwise see if an earlier request has timed out */
+		} else if (time_after(jiffies, usbhid-&gt;last_out + HZ * 5)) {
+
+			/* Prevent autosuspend following the unlink */
+			usb_autopm_get_interface_no_resume(usbhid-&gt;intf);
 
-		if (!test_and_set_bit(HID_OUT_RUNNING, &amp;usbhid-&gt;iofl)) {
-			if (hid_submit_out(hid)) {
-				clear_bit(HID_OUT_RUNNING, &amp;usbhid-&gt;iofl);
-				usb_autopm_put_interface_async(usbhid-&gt;intf);
-			}
-			wake_up(&amp;usbhid-&gt;wait);
-		} else {
 			/*
-			 * the queue is known to run
-			 * but an earlier request may be stuck
-			 * we may need to time out
-			 * no race because the URB is blocked under
-			 * spinlock
+			 * Prevent resubmission in case the URB completes
+			 * before we can unlink it.  We don't want to cancel
+			 * the wrong transfer!
 			 */
-			if (time_after(jiffies, usbhid-&gt;last_out + HZ * 5)) {
-				usb_block_urb(usbhid-&gt;urbout);
-				/* drop lock to not deadlock if the callback is called */
-				spin_unlock(&amp;usbhid-&gt;lock);
-				usb_unlink_urb(usbhid-&gt;urbout);
-				spin_lock(&amp;usbhid-&gt;lock);
-				usb_unblock_urb(usbhid-&gt;urbout);
-				/*
-				 * if the unlinking has already completed
-				 * the pump will have been stopped
-				 * it must be restarted now
-				 */
-				if (!test_bit(HID_OUT_RUNNING, &amp;usbhid-&gt;iofl))
-					if (!irq_out_pump_restart(hid))
-						set_bit(HID_OUT_RUNNING, &amp;usbhid-&gt;iofl);
+			usb_block_urb(usbhid-&gt;urbout);
 
+			/* Drop lock to avoid deadlock if the callback runs */
+			spin_unlock(&amp;usbhid-&gt;lock);
 
-			}
+			usb_unlink_urb(usbhid-&gt;urbout);
+			spin_lock(&amp;usbhid-&gt;lock);
+			usb_unblock_urb(usbhid-&gt;urbout);
+
+			/* Unlink might have stopped the queue */
+			if (!test_bit(HID_OUT_RUNNING, &amp;usbhid-&gt;iofl))
+				usbhid_restart_out_queue(usbhid);
+
+			/* Now we can allow autosuspend again */
+			usb_autopm_put_interface_async(usbhid-&gt;intf);
 		}
 		return;
 	}
@@ -610,47 +619,36 @@ static void __usbhid_submit_report(struct hid_device *hid, struct hid_report *re
 	usbhid-&gt;ctrl[usbhid-&gt;ctrlhead].dir = dir;
 	usbhid-&gt;ctrlhead = head;
 
-	/* Try to awake from autosuspend... */
-	if (usb_autopm_get_interface_async(usbhid-&gt;intf) &lt; 0)
-		return;
+	/* If the queue isn't running, restart it */
+	if (!test_bit(HID_CTRL_RUNNING, &amp;usbhid-&gt;iofl)) {
+		usbhid_restart_ctrl_queue(usbhid);
 
-	/*
-	 * If already suspended, leave urb enqueued, but don't submit.
-	 * Submission will occur if/when resume() drains the queue.
-	 */
-	if (test_bit(HID_REPORTED_IDLE, &amp;usbhid-&gt;iofl))
-		return;
+	/* Otherwise see if an earlier request has timed out */
+	} else if (time_after(jiffies, usbhid-&gt;last_ctrl + HZ * 5)) {
+
+		/* Prevent autosuspend following the unlink */
+		usb_autopm_get_interface_no_resume(usbhid-&gt;intf);
 
-	if (!test_and_set_bit(HID_CTRL_RUNNING, &amp;usbhid-&gt;iofl)) {
-		if (hid_submit_ctrl(hid)) {
-			clear_bit(HID_CTRL_RUNNING, &amp;usbhid-&gt;iofl);
-			usb_autopm_put_interface_async(usbhid-&gt;intf);
-		}
-		wake_up(&amp;usbhid-&gt;wait);
-	} else {
 		/*
-		 * the queue is known to run
-		 * but an earlier request may be stuck
-		 * we may need to time out
-		 * no race because the URB is blocked under
-		 * spinlock
+		 * Prevent resubmission in case the URB completes
+		 * before we can unlink it.  We don't want to cancel
+		 * the wrong transfer!
 		 */
-		if (time_after(jiffies, usbhid-&gt;last_ctrl + HZ * 5)) {
-			usb_block_urb(usbhid-&gt;urbctrl);
-			/* drop lock to not deadlock if the callback is called */
-			spin_unlock(&amp;usbhid-&gt;lock);
-			usb_unlink_urb(usbhid-&gt;urbctrl);
-			spin_lock(&amp;usbhid-&gt;lock);
-			usb_unblock_urb(usbhid-&gt;urbctrl);
-			/*
-			 * if the unlinking has already completed
-			 * the pump will have been stopped
-			 * it must be restarted now
-			 */
-			if (!test_bit(HID_CTRL_RUNNING, &amp;usbhid-&gt;iofl))
-				if (!ctrl_pump_restart(hid))
-					set_bit(HID_CTRL_RUNNING, &amp;usbhid-&gt;iofl);
-		}
+		usb_block_urb(usbhid-&gt;urbctrl);
+
+		/* Drop lock to avoid deadlock if the callback runs */
+		spin_unlock(&amp;usbhid-&gt;lock);
+
+		usb_unlink_urb(usbhid-&gt;urbctrl);
+		spin_lock(&amp;usbhid-&gt;lock);
+		usb_unblock_urb(usbhid-&gt;urbctrl);
+
+		/* Unlink might have stopped the queue */
+		if (!test_bit(HID_CTRL_RUNNING, &amp;usbhid-&gt;iofl))
+			usbhid_restart_ctrl_queue(usbhid);
+
+		/* Now we can allow autosuspend again */
+		usb_autopm_put_interface_async(usbhid-&gt;intf);
 	}
 }
 </pre><hr><pre>commit 668160e5a80536251b4931a332dfe34d6ec2aeb7
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jul 19 16:08:21 2012 -0400

    HID: usbhid: fix use-after-free bug
    
    This patch (as1592) fixes an obscure problem in the usbhid driver.
    Under some circumstances, a control or interrupt-OUT URB can be
    submitted twice.  This will happen if the first submission fails; the
    queue pointers aren't updated, so the next time the queue is restarted
    the same URB will be submitted again.
    
    The problem is that raw_report gets deallocated during the first
    submission.  The second submission will then dereference and try to
    free an already-freed region of memory.  The patch fixes the problem
    by setting raw_report to NULL when it is deallocated and checking for
    NULL before dereferencing it.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Oliver Neukum &lt;oliver@neukum.org&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c
index 482f936fc29b..6b9bad540702 100644
--- a/drivers/hid/usbhid/hid-core.c
+++ b/drivers/hid/usbhid/hid-core.c
@@ -331,9 +331,12 @@ static int hid_submit_out(struct hid_device *hid)
 	usbhid-&gt;urbout-&gt;transfer_buffer_length = ((report-&gt;size - 1) &gt;&gt; 3) +
 						 1 + (report-&gt;id &gt; 0);
 	usbhid-&gt;urbout-&gt;dev = hid_to_usb_dev(hid);
-	memcpy(usbhid-&gt;outbuf, raw_report,
-	       usbhid-&gt;urbout-&gt;transfer_buffer_length);
-	kfree(raw_report);
+	if (raw_report) {
+		memcpy(usbhid-&gt;outbuf, raw_report,
+				usbhid-&gt;urbout-&gt;transfer_buffer_length);
+		kfree(raw_report);
+		usbhid-&gt;out[usbhid-&gt;outtail].raw_report = NULL;
+	}
 
 	dbg_hid("submitting out urb\n");
 
@@ -362,8 +365,11 @@ static int hid_submit_ctrl(struct hid_device *hid)
 	if (dir == USB_DIR_OUT) {
 		usbhid-&gt;urbctrl-&gt;pipe = usb_sndctrlpipe(hid_to_usb_dev(hid), 0);
 		usbhid-&gt;urbctrl-&gt;transfer_buffer_length = len;
-		memcpy(usbhid-&gt;ctrlbuf, raw_report, len);
-		kfree(raw_report);
+		if (raw_report) {
+			memcpy(usbhid-&gt;ctrlbuf, raw_report, len);
+			kfree(raw_report);
+			usbhid-&gt;ctrl[usbhid-&gt;ctrltail].raw_report = NULL;
+		}
 	} else {
 		int maxpacket, padlen;
 </pre>
    <div class="pagination">
        <a href='2_43.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><span>[44]</span><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_45.html'>Next&gt;&gt;</a>
    <div>
</body>
