<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_99.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><span>[100]</span><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_101.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 5ad4f71e2f19a06f738463da1f09ea7fda3a3db2
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Sep 10 11:31:43 2007 -0400

    USB: move decision to ignore FREEZE events
    
    This patch (as987) changes the way FREEZE and PRETHAW suspend events
    are handled in usbcore.  The decision about whether or not to ignore
    them for non-root devices is pushed down into the USB-device driver,
    instead of being made in the core code.
    
    This is appropriate, since devices exported to a virtualized guest or
    over a network may indeed need to handle these types of suspend, even
    though normal devices don't.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 8da4801bb922..ca43a6f824ab 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -1088,15 +1088,8 @@ static int usb_suspend_both(struct usb_device *udev, pm_message_t msg)
 				break;
 		}
 	}
-	if (status == 0) {
-
-		/* Non-root devices don't need to do anything for FREEZE
-		 * or PRETHAW. */
-		if (udev-&gt;parent &amp;&amp; (msg.event == PM_EVENT_FREEZE ||
-				msg.event == PM_EVENT_PRETHAW))
-			goto done;
+	if (status == 0)
 		status = usb_suspend_device(udev, msg);
-	}
 
 	/* If the suspend failed, resume interfaces that did get suspended */
 	if (status != 0) {
diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index 9148b69785c5..c1cb94e9f242 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -206,8 +206,13 @@ static int generic_suspend(struct usb_device *udev, pm_message_t msg)
 	 */
 	if (!udev-&gt;parent)
 		rc = hcd_bus_suspend(udev);
+
+	/* Non-root devices don't need to do anything for FREEZE or PRETHAW */
+	else if (msg.event == PM_EVENT_FREEZE || msg.event == PM_EVENT_PRETHAW)
+		rc = 0;
 	else
 		rc = usb_port_suspend(udev);
+
 	return rc;
 }
 </pre><hr><pre>commit 7477120e34eef65a530cfb3fea5fe612c89669e5
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Sep 10 11:35:14 2007 -0400

    USB: Get rid of annoying endpoint-release message
    
    This patch (as990) removes an annoying debugging message.  Nobody
    really cares when endpoint pseudo-devices are released.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/endpoint.c b/drivers/usb/core/endpoint.c
index e0ec7045e865..7dc123d6b2d0 100644
--- a/drivers/usb/core/endpoint.c
+++ b/drivers/usb/core/endpoint.c
@@ -267,7 +267,6 @@ static void ep_device_release(struct device *dev)
 {
 	struct ep_device *ep_dev = to_ep_device(dev);
 
-	dev_dbg(dev, "%s called for %s\n", __FUNCTION__, dev-&gt;bus_id);
 	endpoint_free_minor(ep_dev);
 	kfree(ep_dev);
 }</pre><hr><pre>commit 63f991b2871bdb1431e8ff62cae2b7b94b4e5b0c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 4 09:53:24 2007 -0400

    USB: fix location of statement label in dummy-hcd
    
    This patch (as984) fixes a rather elementary mistake in dummy_hcd.
    The new statement label should come before the spin_unlock_irqrestore,
    not after it.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index 58e4d7208805..6479a36d6f0e 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -1001,8 +1001,8 @@ static int dummy_urb_enqueue (
 	if (!timer_pending (&amp;dum-&gt;timer))
 		mod_timer (&amp;dum-&gt;timer, jiffies + 1);
 
-	spin_unlock_irqrestore (&amp;dum-&gt;lock, flags);
  done:
+	spin_unlock_irqrestore(&amp;dum-&gt;lock, flags);
 	return rc;
 }
 </pre><hr><pre>commit e015268d2fcfcaef70a1ec535e6381f75aafbf81
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 24 15:42:52 2007 -0400

    USB: remove traces of urb-&gt;status from usbcore
    
    This patch (as981) removes the remaining nontrivial usages of
    urb-&gt;status from usbcore.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index b9f1edd6af53..e5ad76b4a738 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -71,6 +71,7 @@ struct async {
 	void __user *userbuffer;
 	void __user *userurb;
 	struct urb *urb;
+	int status;
 	u32 secid;
 };
 
@@ -310,9 +311,10 @@ static void async_completed(struct urb *urb)
         spin_lock(&amp;ps-&gt;lock);
         list_move_tail(&amp;as-&gt;asynclist, &amp;ps-&gt;async_completed);
         spin_unlock(&amp;ps-&gt;lock);
+	as-&gt;status = urb-&gt;status;
 	if (as-&gt;signr) {
 		sinfo.si_signo = as-&gt;signr;
-		sinfo.si_errno = as-&gt;urb-&gt;status;
+		sinfo.si_errno = as-&gt;status;
 		sinfo.si_code = SI_ASYNCIO;
 		sinfo.si_addr = as-&gt;userurb;
 		kill_pid_info_as_uid(as-&gt;signr, &amp;sinfo, as-&gt;pid, as-&gt;uid,
@@ -1132,7 +1134,7 @@ static int processcompl(struct async *as, void __user * __user *arg)
 	if (as-&gt;userbuffer)
 		if (copy_to_user(as-&gt;userbuffer, urb-&gt;transfer_buffer, urb-&gt;transfer_buffer_length))
 			return -EFAULT;
-	if (put_user(urb-&gt;status, &amp;userurb-&gt;status))
+	if (put_user(as-&gt;status, &amp;userurb-&gt;status))
 		return -EFAULT;
 	if (put_user(urb-&gt;actual_length, &amp;userurb-&gt;actual_length))
 		return -EFAULT;
@@ -1246,7 +1248,7 @@ static int processcompl_compat(struct async *as, void __user * __user *arg)
 	if (as-&gt;userbuffer)
 		if (copy_to_user(as-&gt;userbuffer, urb-&gt;transfer_buffer, urb-&gt;transfer_buffer_length))
 			return -EFAULT;
-	if (put_user(urb-&gt;status, &amp;userurb-&gt;status))
+	if (put_user(as-&gt;status, &amp;userurb-&gt;status))
 		return -EFAULT;
 	if (put_user(urb-&gt;actual_length, &amp;userurb-&gt;actual_length))
 		return -EFAULT;
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 4c495c4d5053..bd08d51d7f41 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -347,11 +347,11 @@ void usb_kick_khubd(struct usb_device *hdev)
 static void hub_irq(struct urb *urb)
 {
 	struct usb_hub *hub = urb-&gt;context;
-	int status;
+	int status = urb-&gt;status;
 	int i;
 	unsigned long bits;
 
-	switch (urb-&gt;status) {
+	switch (status) {
 	case -ENOENT:		/* synchronous unlink */
 	case -ECONNRESET:	/* async unlink */
 	case -ESHUTDOWN:	/* hardware going away */
@@ -359,10 +359,10 @@ static void hub_irq(struct urb *urb)
 
 	default:		/* presumably an error */
 		/* Cause a hub reset after 10 consecutive errors */
-		dev_dbg (hub-&gt;intfdev, "transfer --&gt; %d\n", urb-&gt;status);
+		dev_dbg (hub-&gt;intfdev, "transfer --&gt; %d\n", status);
 		if ((++hub-&gt;nerrors &lt; 10) || hub-&gt;error)
 			goto resubmit;
-		hub-&gt;error = urb-&gt;status;
+		hub-&gt;error = status;
 		/* FALL THROUGH */
 
 	/* let khubd handle things */</pre><hr><pre>commit 1431d2a44ccf68a547094976f363f94177ab00c6
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 24 15:42:39 2007 -0400

    USB: get rid of urb-&gt;lock
    
    Now that urb-&gt;status isn't used, urb-&gt;lock doesn't protect anything.
    This patch (as980) removes it and replaces it with a private mutex in
    the one remaining place it was still used: usb_kill_urb.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 19f5f66c2733..76db76fdb4ec 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -39,7 +39,6 @@ void usb_init_urb(struct urb *urb)
 	if (urb) {
 		memset(urb, 0, sizeof(*urb));
 		kref_init(&amp;urb-&gt;kref);
-		spin_lock_init(&amp;urb-&gt;lock);
 		INIT_LIST_HEAD(&amp;urb-&gt;anchor_list);
 	}
 }
@@ -541,19 +540,21 @@ int usb_unlink_urb(struct urb *urb)
  */
 void usb_kill_urb(struct urb *urb)
 {
+	static DEFINE_MUTEX(reject_mutex);
+
 	might_sleep();
 	if (!(urb &amp;&amp; urb-&gt;dev &amp;&amp; urb-&gt;ep))
 		return;
-	spin_lock_irq(&amp;urb-&gt;lock);
+	mutex_lock(&amp;reject_mutex);
 	++urb-&gt;reject;
-	spin_unlock_irq(&amp;urb-&gt;lock);
+	mutex_unlock(&amp;reject_mutex);
 
 	usb_hcd_unlink_urb(urb, -ENOENT);
 	wait_event(usb_kill_urb_queue, atomic_read(&amp;urb-&gt;use_count) == 0);
 
-	spin_lock_irq(&amp;urb-&gt;lock);
+	mutex_lock(&amp;reject_mutex);
 	--urb-&gt;reject;
-	spin_unlock_irq(&amp;urb-&gt;lock);
+	mutex_unlock(&amp;reject_mutex);
 }
 
 /**
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 5c7b79088add..5b14b4c81fd6 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1241,7 +1241,6 @@ struct urb
 {
 	/* private: usb core and host controller only fields in the urb */
 	struct kref kref;		/* reference count of the URB */
-	spinlock_t lock;		/* lock for the URB */
 	void *hcpriv;			/* private data for host controller */
 	atomic_t use_count;		/* concurrent submissions counter */
 	u8 reject;			/* submissions will fail */
@@ -1299,7 +1298,6 @@ static inline void usb_fill_control_urb (struct urb *urb,
 					 usb_complete_t complete_fn,
 					 void *context)
 {
-	spin_lock_init(&amp;urb-&gt;lock);
 	urb-&gt;dev = dev;
 	urb-&gt;pipe = pipe;
 	urb-&gt;setup_packet = setup_packet;
@@ -1330,7 +1328,6 @@ static inline void usb_fill_bulk_urb (struct urb *urb,
 				      usb_complete_t complete_fn,
 				      void *context)
 {
-	spin_lock_init(&amp;urb-&gt;lock);
 	urb-&gt;dev = dev;
 	urb-&gt;pipe = pipe;
 	urb-&gt;transfer_buffer = transfer_buffer;
@@ -1366,7 +1363,6 @@ static inline void usb_fill_int_urb (struct urb *urb,
 				     void *context,
 				     int interval)
 {
-	spin_lock_init(&amp;urb-&gt;lock);
 	urb-&gt;dev = dev;
 	urb-&gt;pipe = pipe;
 	urb-&gt;transfer_buffer = transfer_buffer;</pre><hr><pre>commit 4a00027dcb088bf90fa8fb14a7e8ba3506d78f22
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 24 15:42:24 2007 -0400

    USB: Eliminate urb-&gt;status usage!
    
    This patch (as979) removes the last vestiges of urb-&gt;status from the
    host controller drivers and the root-hub emulator.  Now the field
    doesn't get set until just before the URB's completion routine is
    called.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    CC: Olav Kongas &lt;ok@artecdesign.ee&gt;
    CC: Yoshihiro Shimoda &lt;shimoda.yoshihiro@renesas.com&gt;
    CC: Tony Olech &lt;tony.olech@elandigitalsystems.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 4ac021e42cd8..1c5e5d35e08d 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -532,7 +532,6 @@ static int rh_call_control (struct usb_hcd *hcd, struct urb *urb)
 
 	/* any errors get returned through the urb completion */
 	spin_lock_irq(&amp;hcd_root_hub_lock);
-	urb-&gt;status = status;
 	usb_hcd_unlink_urb_from_ep(hcd, urb);
 
 	/* This peculiar use of spinlocks echoes what real HC drivers do.
@@ -540,7 +539,7 @@ static int rh_call_control (struct usb_hcd *hcd, struct urb *urb)
 	 * RT-friendly.
 	 */
 	spin_unlock(&amp;hcd_root_hub_lock);
-	usb_hcd_giveback_urb(hcd, urb);
+	usb_hcd_giveback_urb(hcd, urb, status);
 	spin_lock(&amp;hcd_root_hub_lock);
 
 	spin_unlock_irq(&amp;hcd_root_hub_lock);
@@ -578,13 +577,12 @@ void usb_hcd_poll_rh_status(struct usb_hcd *hcd)
 		if (urb) {
 			hcd-&gt;poll_pending = 0;
 			hcd-&gt;status_urb = NULL;
-			urb-&gt;status = 0;
 			urb-&gt;actual_length = length;
 			memcpy(urb-&gt;transfer_buffer, buffer, length);
 
 			usb_hcd_unlink_urb_from_ep(hcd, urb);
 			spin_unlock(&amp;hcd_root_hub_lock);
-			usb_hcd_giveback_urb(hcd, urb);
+			usb_hcd_giveback_urb(hcd, urb, 0);
 			spin_lock(&amp;hcd_root_hub_lock);
 		} else {
 			length = 0;
@@ -677,7 +675,7 @@ static int usb_rh_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 			usb_hcd_unlink_urb_from_ep(hcd, urb);
 
 			spin_unlock(&amp;hcd_root_hub_lock);
-			usb_hcd_giveback_urb(hcd, urb);
+			usb_hcd_giveback_urb(hcd, urb, status);
 			spin_lock(&amp;hcd_root_hub_lock);
 		}
 	}
@@ -1252,6 +1250,7 @@ int usb_hcd_unlink_urb (struct urb *urb, int status)
  * usb_hcd_giveback_urb - return URB from HCD to device driver
  * @hcd: host controller returning the URB
  * @urb: urb being returned to the USB device driver.
+ * @status: completion status code for the URB.
  * Context: in_interrupt()
  *
  * This hands the URB from HCD to its USB device driver, using its
@@ -1260,25 +1259,26 @@ int usb_hcd_unlink_urb (struct urb *urb, int status)
  * the device driver won't cause problems if it frees, modifies,
  * or resubmits this URB.
  *
- * If @urb was unlinked, the value of @urb-&gt;status will be overridden by
+ * If @urb was unlinked, the value of @status will be overridden by
  * @urb-&gt;unlinked.  Erroneous short transfers are detected in case
  * the HCD hasn't checked for them.
  */
-void usb_hcd_giveback_urb (struct usb_hcd *hcd, struct urb *urb)
+void usb_hcd_giveback_urb(struct usb_hcd *hcd, struct urb *urb, int status)
 {
 	urb-&gt;hcpriv = NULL;
 	if (unlikely(urb-&gt;unlinked))
-		urb-&gt;status = urb-&gt;unlinked;
+		status = urb-&gt;unlinked;
 	else if (unlikely((urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK) &amp;&amp;
 			urb-&gt;actual_length &lt; urb-&gt;transfer_buffer_length &amp;&amp;
-			!urb-&gt;status))
-		urb-&gt;status = -EREMOTEIO;
+			!status))
+		status = -EREMOTEIO;
 
 	unmap_urb_for_dma(hcd, urb);
-	usbmon_urb_complete(&amp;hcd-&gt;self, urb, urb-&gt;status);
+	usbmon_urb_complete(&amp;hcd-&gt;self, urb, status);
 	usb_unanchor_urb(urb);
 
 	/* pass ownership to the completion handler */
+	urb-&gt;status = status;
 	urb-&gt;complete (urb);
 	atomic_dec (&amp;urb-&gt;use_count);
 	if (unlikely (urb-&gt;reject))
diff --git a/drivers/usb/core/hcd.h b/drivers/usb/core/hcd.h
index 729b7a03acd8..0fc7b95259f5 100644
--- a/drivers/usb/core/hcd.h
+++ b/drivers/usb/core/hcd.h
@@ -217,7 +217,8 @@ extern void usb_hcd_unlink_urb_from_ep(struct usb_hcd *hcd, struct urb *urb);
 
 extern int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags);
 extern int usb_hcd_unlink_urb (struct urb *urb, int status);
-extern void usb_hcd_giveback_urb (struct usb_hcd *hcd, struct urb *urb);
+extern void usb_hcd_giveback_urb(struct usb_hcd *hcd, struct urb *urb,
+		int status);
 extern void usb_hcd_endpoint_disable (struct usb_device *udev,
 		struct usb_host_endpoint *ep);
 extern int usb_hcd_get_frame_number (struct usb_device *udev);
diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index c1af7bab26f0..58e4d7208805 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -1511,8 +1511,7 @@ static void dummy_timer (unsigned long _dum)
 
 		usb_hcd_unlink_urb_from_ep(dummy_to_hcd(dum), urb);
 		spin_unlock (&amp;dum-&gt;lock);
-		urb-&gt;status = status;
-		usb_hcd_giveback_urb (dummy_to_hcd(dum), urb);
+		usb_hcd_giveback_urb(dummy_to_hcd(dum), urb, status);
 		spin_lock (&amp;dum-&gt;lock);
 
 		goto restart;
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 794d27e07807..b10f39c047e9 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -256,8 +256,7 @@ __acquires(ehci-&gt;lock)
 	/* complete() can reenter this HCD */
 	usb_hcd_unlink_urb_from_ep(ehci_to_hcd(ehci), urb);
 	spin_unlock (&amp;ehci-&gt;lock);
-	urb-&gt;status = status;
-	usb_hcd_giveback_urb (ehci_to_hcd(ehci), urb);
+	usb_hcd_giveback_urb(ehci_to_hcd(ehci), urb, status);
 	spin_lock (&amp;ehci-&gt;lock);
 }
 
diff --git a/drivers/usb/host/isp116x-hcd.c b/drivers/usb/host/isp116x-hcd.c
index 35b3507ff401..c27417f5b9d8 100644
--- a/drivers/usb/host/isp116x-hcd.c
+++ b/drivers/usb/host/isp116x-hcd.c
@@ -277,7 +277,7 @@ static void preproc_atl_queue(struct isp116x *isp116x)
   processed urbs.
 */
 static void finish_request(struct isp116x *isp116x, struct isp116x_ep *ep,
-			   struct urb *urb)
+			   struct urb *urb, int status)
 __releases(isp116x-&gt;lock) __acquires(isp116x-&gt;lock)
 {
 	unsigned i;
@@ -291,7 +291,7 @@ __releases(isp116x-&gt;lock) __acquires(isp116x-&gt;lock)
 
 	usb_hcd_unlink_urb_from_ep(isp116x_to_hcd(isp116x), urb);
 	spin_unlock(&amp;isp116x-&gt;lock);
-	usb_hcd_giveback_urb(isp116x_to_hcd(isp116x), urb);
+	usb_hcd_giveback_urb(isp116x_to_hcd(isp116x), urb, status);
 	spin_lock(&amp;isp116x-&gt;lock);
 
 	/* take idle endpoints out of the schedule */
@@ -453,13 +453,8 @@ static void postproc_atl_queue(struct isp116x *isp116x)
 		}
 
  done:
-		if (status != -EINPROGRESS) {
-			spin_lock(&amp;urb-&gt;lock);
-			urb-&gt;status = status;
-			spin_unlock(&amp;urb-&gt;lock);
-		}
-		if (urb-&gt;status != -EINPROGRESS || urb-&gt;unlinked)
-			finish_request(isp116x, ep, urb);
+		if (status != -EINPROGRESS || urb-&gt;unlinked)
+			finish_request(isp116x, ep, urb, status);
 	}
 }
 
@@ -853,7 +848,7 @@ static int isp116x_urb_dequeue(struct usb_hcd *hcd, struct urb *urb,
 			}
 
 	if (urb)
-		finish_request(isp116x, ep, urb);
+		finish_request(isp116x, ep, urb, status);
  done:
 	spin_unlock_irqrestore(&amp;isp116x-&gt;lock, flags);
 	return rc;
diff --git a/drivers/usb/host/ohci-q.c b/drivers/usb/host/ohci-q.c
index 13d31edd1a86..51817322232b 100644
--- a/drivers/usb/host/ohci-q.c
+++ b/drivers/usb/host/ohci-q.c
@@ -62,8 +62,7 @@ __acquires(ohci-&gt;lock)
 	/* urb-&gt;complete() can reenter this HCD */
 	usb_hcd_unlink_urb_from_ep(ohci_to_hcd(ohci), urb);
 	spin_unlock (&amp;ohci-&gt;lock);
-	urb-&gt;status = status;
-	usb_hcd_giveback_urb (ohci_to_hcd(ohci), urb);
+	usb_hcd_giveback_urb(ohci_to_hcd(ohci), urb, status);
 	spin_lock (&amp;ohci-&gt;lock);
 
 	/* stop periodic dma if it's not needed */
diff --git a/drivers/usb/host/r8a66597-hcd.c b/drivers/usb/host/r8a66597-hcd.c
index fea6036771f6..fd00f1e33fb5 100644
--- a/drivers/usb/host/r8a66597-hcd.c
+++ b/drivers/usb/host/r8a66597-hcd.c
@@ -782,12 +782,12 @@ static void force_dequeue(struct r8a66597 *r8a66597, u16 pipenum, u16 address)
 		kfree(td);
 
 		if (urb) {
-			urb-&gt;status = -ENODEV;
 			usb_hcd_unlink_urb_from_ep(r8a66597_to_hcd(r8a66597),
 					urb);
 
 			spin_unlock(&amp;r8a66597-&gt;lock);
-			usb_hcd_giveback_urb(r8a66597_to_hcd(r8a66597), urb);
+			usb_hcd_giveback_urb(r8a66597_to_hcd(r8a66597), urb,
+					-ENODEV);
 			spin_lock(&amp;r8a66597-&gt;lock);
 		}
 		break;
@@ -1134,10 +1134,8 @@ __releases(r8a66597-&gt;lock) __acquires(r8a66597-&gt;lock)
 			urb-&gt;start_frame = r8a66597_get_frame(hcd);
 
 		usb_hcd_unlink_urb_from_ep(r8a66597_to_hcd(r8a66597), urb);
-
-		urb-&gt;status = status;
 		spin_unlock(&amp;r8a66597-&gt;lock);
-		usb_hcd_giveback_urb(hcd, urb);
+		usb_hcd_giveback_urb(hcd, urb, status);
 		spin_lock(&amp;r8a66597-&gt;lock);
 	}
 
diff --git a/drivers/usb/host/sl811-hcd.c b/drivers/usb/host/sl811-hcd.c
index 515152809d37..94d859aa73f8 100644
--- a/drivers/usb/host/sl811-hcd.c
+++ b/drivers/usb/host/sl811-hcd.c
@@ -436,9 +436,8 @@ static void finish_request(
 		ep-&gt;nextpid = USB_PID_SETUP;
 
 	usb_hcd_unlink_urb_from_ep(sl811_to_hcd(sl811), urb);
-	urb-&gt;status = status;
 	spin_unlock(&amp;sl811-&gt;lock);
-	usb_hcd_giveback_urb(sl811_to_hcd(sl811), urb);
+	usb_hcd_giveback_urb(sl811_to_hcd(sl811), urb, status);
 	spin_lock(&amp;sl811-&gt;lock);
 
 	/* leave active endpoints in the schedule */
diff --git a/drivers/usb/host/u132-hcd.c b/drivers/usb/host/u132-hcd.c
index db800a434b83..2b379a78d0d5 100644
--- a/drivers/usb/host/u132-hcd.c
+++ b/drivers/usb/host/u132-hcd.c
@@ -518,7 +518,6 @@ static void u132_hcd_giveback_urb(struct u132 *u132, struct u132_endp *endp,
         unsigned long irqs;
         struct usb_hcd *hcd = u132_to_hcd(u132);
         urb-&gt;error_count = 0;
-        urb-&gt;status = status;
         spin_lock_irqsave(&amp;endp-&gt;queue_lock.slock, irqs);
 	usb_hcd_unlink_urb_from_ep(hcd, urb);
         endp-&gt;queue_next += 1;
@@ -542,7 +541,7 @@ static void u132_hcd_giveback_urb(struct u132 *u132, struct u132_endp *endp,
         u132_ring_queue_work(u132, ring, 0);
         up(&amp;u132-&gt;scheduler_lock);
         u132_endp_put_kref(u132, endp);
-        usb_hcd_giveback_urb(hcd, urb);
+	usb_hcd_giveback_urb(hcd, urb, status);
         return;
 }
 
@@ -558,7 +557,6 @@ static void u132_hcd_abandon_urb(struct u132 *u132, struct u132_endp *endp,
         unsigned long irqs;
         struct usb_hcd *hcd = u132_to_hcd(u132);
         urb-&gt;error_count = 0;
-        urb-&gt;status = status;
         spin_lock_irqsave(&amp;endp-&gt;queue_lock.slock, irqs);
 	usb_hcd_unlink_urb_from_ep(hcd, urb);
         endp-&gt;queue_next += 1;
@@ -575,7 +573,7 @@ static void u132_hcd_abandon_urb(struct u132 *u132, struct u132_endp *endp,
                 endp-&gt;active = 0;
                 spin_unlock_irqrestore(&amp;endp-&gt;queue_lock.slock, irqs);
                 kfree(urbq);
-        } usb_hcd_giveback_urb(hcd, urb);
+	} usb_hcd_giveback_urb(hcd, urb, status);
         return;
 }
 
@@ -719,7 +717,7 @@ static void u132_hcd_interrupt_recv(void *data, struct urb *urb, u8 *buf,
 		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
 				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
+		u132_hcd_giveback_urb(u132, endp, urb, 0);
                 return;
         }
 }
@@ -771,7 +769,7 @@ static void u132_hcd_bulk_output_sent(void *data, struct urb *urb, u8 *buf,
 		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
 				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
+		u132_hcd_giveback_urb(u132, endp, urb, 0);
                 return;
         }
 }
@@ -874,7 +872,7 @@ static void u132_hcd_bulk_input_recv(void *data, struct urb *urb, u8 *buf,
 		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
 				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
+		u132_hcd_giveback_urb(u132, endp, urb, 0);
                 return;
         }
 }
@@ -911,7 +909,7 @@ static void u132_hcd_configure_empty_sent(void *data, struct urb *urb, u8 *buf,
 		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
 				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
+		u132_hcd_giveback_urb(u132, endp, urb, 0);
                 return;
         }
 }
@@ -983,7 +981,7 @@ static void u132_hcd_configure_input_recv(void *data, struct urb *urb, u8 *buf,
 		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
 				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
+		u132_hcd_giveback_urb(u132, endp, urb, 0);
                 return;
         }
 }
@@ -1020,7 +1018,7 @@ static void u132_hcd_configure_empty_recv(void *data, struct urb *urb, u8 *buf,
 		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
 				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
+		u132_hcd_giveback_urb(u132, endp, urb, 0);
                 return;
         }
 }
@@ -1080,7 +1078,7 @@ static void u132_hcd_configure_setup_sent(void *data, struct urb *urb, u8 *buf,
 		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
 				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
+		u132_hcd_giveback_urb(u132, endp, urb, 0);
                 return;
         }
 }
@@ -1121,7 +1119,7 @@ static void u132_hcd_enumeration_empty_recv(void *data, struct urb *urb,
 		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
 				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
+		u132_hcd_giveback_urb(u132, endp, urb, 0);
                 return;
         }
 }
@@ -1165,7 +1163,7 @@ static void u132_hcd_enumeration_address_sent(void *data, struct urb *urb,
 		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
 				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
+		u132_hcd_giveback_urb(u132, endp, urb, 0);
                 return;
         }
 }
@@ -1202,7 +1200,7 @@ static void u132_hcd_initial_empty_sent(void *data, struct urb *urb, u8 *buf,
 		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
 				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
+		u132_hcd_giveback_urb(u132, endp, urb, 0);
                 return;
         }
 }
@@ -1254,7 +1252,7 @@ static void u132_hcd_initial_input_recv(void *data, struct urb *urb, u8 *buf,
 		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
 				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
+		u132_hcd_giveback_urb(u132, endp, urb, 0);
                 return;
         }
 }
@@ -1299,7 +1297,7 @@ static void u132_hcd_initial_setup_sent(void *data, struct urb *urb, u8 *buf,
 		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
 				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
+		u132_hcd_giveback_urb(u132, endp, urb, 0);
                 return;
         }
 }
@@ -2428,7 +2426,7 @@ static int dequeue_from_overflow_chain(struct u132 *u132,
                         list_del(scan);
                         endp-&gt;queue_size -= 1;
                         urb-&gt;error_count = 0;
-                        usb_hcd_giveback_urb(hcd, urb);
+			usb_hcd_giveback_urb(hcd, urb, 0);
                         return 0;
                 } else
                         continue;
@@ -2472,7 +2470,7 @@ static int u132_endp_urb_dequeue(struct u132 *u132, struct u132_endp *endp,
                         return 0;
                 } else {
                         spin_unlock_irqrestore(&amp;endp-&gt;queue_lock.slock, irqs);
-                        u132_hcd_abandon_urb(u132, endp, urb, urb-&gt;status);
+			u132_hcd_abandon_urb(u132, endp, urb, status);
                         return 0;
                 }
         } else {
@@ -2513,7 +2511,7 @@ static int u132_endp_urb_dequeue(struct u132 *u132, struct u132_endp *endp,
                                         irqs);
                                 kfree(urbq);
                         } urb-&gt;error_count = 0;
-                        usb_hcd_giveback_urb(hcd, urb);
+			usb_hcd_giveback_urb(hcd, urb, status);
                         return 0;
                 } else if (list_empty(&amp;endp-&gt;urb_more)) {
                         dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "urb=%p not found in "
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index e46d2b0203cb..340d6ed3e6e9 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -456,21 +456,6 @@ struct urb_priv {
 };
 
 
-/*
- * Locking in uhci.c
- *
- * Almost everything relating to the hardware schedule and processing
- * of URBs is protected by uhci-&gt;lock.  urb-&gt;status is protected by
- * urb-&gt;lock; that's the one exception.
- *
- * To prevent deadlocks, never lock uhci-&gt;lock while holding urb-&gt;lock.
- * The safe order of locking is:
- *
- * #1 uhci-&gt;lock
- * #2 urb-&gt;lock
- */
-
-
 /* Some special IDs */
 
 #define PCI_VENDOR_ID_GENESYS		0x17a0
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index bab567266559..e5d60d5b105a 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -1480,7 +1480,7 @@ static int uhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
  * Finish unlinking an URB and give it back
  */
 static void uhci_giveback_urb(struct uhci_hcd *uhci, struct uhci_qh *qh,
-		struct urb *urb)
+		struct urb *urb, int status)
 __releases(uhci-&gt;lock)
 __acquires(uhci-&gt;lock)
 {
@@ -1520,7 +1520,7 @@ __acquires(uhci-&gt;lock)
 	usb_hcd_unlink_urb_from_ep(uhci_to_hcd(uhci), urb);
 
 	spin_unlock(&amp;uhci-&gt;lock);
-	usb_hcd_giveback_urb(uhci_to_hcd(uhci), urb);
+	usb_hcd_giveback_urb(uhci_to_hcd(uhci), urb, status);
 	spin_lock(&amp;uhci-&gt;lock);
 
 	/* If the queue is now empty, we can unlink the QH and give up its
@@ -1556,10 +1556,6 @@ static void uhci_scan_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
 		if (status == -EINPROGRESS)
 			break;
 
-		spin_lock(&amp;urb-&gt;lock);
-		urb-&gt;status = status;
-		spin_unlock(&amp;urb-&gt;lock);
-
 		/* Dequeued but completed URBs can't be given back unless
 		 * the QH is stopped or has finished unlinking. */
 		if (urb-&gt;unlinked) {
@@ -1569,7 +1565,7 @@ static void uhci_scan_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
 				return;
 		}
 
-		uhci_giveback_urb(uhci, qh, urb);
+		uhci_giveback_urb(uhci, qh, urb, status);
 		if (status &lt; 0)
 			break;
 	}
@@ -1594,7 +1590,7 @@ static void uhci_scan_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
 				qh-&gt;is_stopped = 0;
 				return;
 			}
-			uhci_giveback_urb(uhci, qh, urb);
+			uhci_giveback_urb(uhci, qh, urb, 0);
 			goto restart;
 		}
 	}</pre><hr><pre>commit 9347d51c52afcf1a77d2104f162cf8a085624c83
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 24 15:41:41 2007 -0400

    USB: reorganize urb-&gt;status use in usbmon
    
    This patch (as978) reorganizes the way usbmon uses urb-&gt;status.  It
    now accepts the status value as an argument.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Pete Zaitcev &lt;zaitcev@redhat.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 8b17babf5c55..4ac021e42cd8 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1275,7 +1275,7 @@ void usb_hcd_giveback_urb (struct usb_hcd *hcd, struct urb *urb)
 		urb-&gt;status = -EREMOTEIO;
 
 	unmap_urb_for_dma(hcd, urb);
-	usbmon_urb_complete(&amp;hcd-&gt;self, urb);
+	usbmon_urb_complete(&amp;hcd-&gt;self, urb, urb-&gt;status);
 	usb_unanchor_urb(urb);
 
 	/* pass ownership to the completion handler */
diff --git a/drivers/usb/core/hcd.h b/drivers/usb/core/hcd.h
index 745be2566f62..729b7a03acd8 100644
--- a/drivers/usb/core/hcd.h
+++ b/drivers/usb/core/hcd.h
@@ -413,7 +413,7 @@ static inline void usbfs_cleanup(void) { }
 struct usb_mon_operations {
 	void (*urb_submit)(struct usb_bus *bus, struct urb *urb);
 	void (*urb_submit_error)(struct usb_bus *bus, struct urb *urb, int err);
-	void (*urb_complete)(struct usb_bus *bus, struct urb *urb);
+	void (*urb_complete)(struct usb_bus *bus, struct urb *urb, int status);
 	/* void (*urb_unlink)(struct usb_bus *bus, struct urb *urb); */
 };
 
@@ -432,10 +432,11 @@ static inline void usbmon_urb_submit_error(struct usb_bus *bus, struct urb *urb,
 		(*mon_ops-&gt;urb_submit_error)(bus, urb, error);
 }
 
-static inline void usbmon_urb_complete(struct usb_bus *bus, struct urb *urb)
+static inline void usbmon_urb_complete(struct usb_bus *bus, struct urb *urb,
+		int status)
 {
 	if (bus-&gt;monitored)
-		(*mon_ops-&gt;urb_complete)(bus, urb);
+		(*mon_ops-&gt;urb_complete)(bus, urb, status);
 }
 
 int usb_mon_register(struct usb_mon_operations *ops);
@@ -446,7 +447,8 @@ void usb_mon_deregister(void);
 static inline void usbmon_urb_submit(struct usb_bus *bus, struct urb *urb) {}
 static inline void usbmon_urb_submit_error(struct usb_bus *bus, struct urb *urb,
     int error) {}
-static inline void usbmon_urb_complete(struct usb_bus *bus, struct urb *urb) {}
+static inline void usbmon_urb_complete(struct usb_bus *bus, struct urb *urb,
+		int status) {}
 
 #endif /* CONFIG_USB_MON */
 
diff --git a/drivers/usb/mon/mon_bin.c b/drivers/usb/mon/mon_bin.c
index 3d6f03819ffd..f06e4e2b49d3 100644
--- a/drivers/usb/mon/mon_bin.c
+++ b/drivers/usb/mon/mon_bin.c
@@ -386,7 +386,7 @@ static char mon_bin_get_data(const struct mon_reader_bin *rp,
 }
 
 static void mon_bin_event(struct mon_reader_bin *rp, struct urb *urb,
-    char ev_type)
+    char ev_type, int status)
 {
 	const struct usb_endpoint_descriptor *epd = &amp;urb-&gt;ep-&gt;desc;
 	unsigned long flags;
@@ -452,7 +452,7 @@ static void mon_bin_event(struct mon_reader_bin *rp, struct urb *urb,
 	ep-&gt;id = (unsigned long) urb;
 	ep-&gt;ts_sec = ts.tv_sec;
 	ep-&gt;ts_usec = ts.tv_usec;
-	ep-&gt;status = urb-&gt;status;
+	ep-&gt;status = status;
 	ep-&gt;len_urb = urb_length;
 	ep-&gt;len_cap = length;
 
@@ -475,13 +475,13 @@ static void mon_bin_event(struct mon_reader_bin *rp, struct urb *urb,
 static void mon_bin_submit(void *data, struct urb *urb)
 {
 	struct mon_reader_bin *rp = data;
-	mon_bin_event(rp, urb, 'S');
+	mon_bin_event(rp, urb, 'S', -EINPROGRESS);
 }
 
-static void mon_bin_complete(void *data, struct urb *urb)
+static void mon_bin_complete(void *data, struct urb *urb, int status)
 {
 	struct mon_reader_bin *rp = data;
-	mon_bin_event(rp, urb, 'C');
+	mon_bin_event(rp, urb, 'C', status);
 }
 
 static void mon_bin_error(void *data, struct urb *urb, int error)
diff --git a/drivers/usb/mon/mon_main.c b/drivers/usb/mon/mon_main.c
index 2e317bd79e92..b371ffd39d36 100644
--- a/drivers/usb/mon/mon_main.c
+++ b/drivers/usb/mon/mon_main.c
@@ -129,7 +129,8 @@ static void mon_submit_error(struct usb_bus *ubus, struct urb *urb, int error)
 
 /*
  */
-static void mon_bus_complete(struct mon_bus *mbus, struct urb *urb)
+static void mon_bus_complete(struct mon_bus *mbus, struct urb *urb,
+		int status)
 {
 	unsigned long flags;
 	struct list_head *pos;
@@ -139,18 +140,18 @@ static void mon_bus_complete(struct mon_bus *mbus, struct urb *urb)
 	mbus-&gt;cnt_events++;
 	list_for_each (pos, &amp;mbus-&gt;r_list) {
 		r = list_entry(pos, struct mon_reader, r_link);
-		r-&gt;rnf_complete(r-&gt;r_data, urb);
+		r-&gt;rnf_complete(r-&gt;r_data, urb, status);
 	}
 	spin_unlock_irqrestore(&amp;mbus-&gt;lock, flags);
 }
 
-static void mon_complete(struct usb_bus *ubus, struct urb *urb)
+static void mon_complete(struct usb_bus *ubus, struct urb *urb, int status)
 {
 	struct mon_bus *mbus;
 
 	if ((mbus = ubus-&gt;mon_bus) != NULL)
-		mon_bus_complete(mbus, urb);
-	mon_bus_complete(&amp;mon_bus0, urb);
+		mon_bus_complete(mbus, urb, status);
+	mon_bus_complete(&amp;mon_bus0, urb, status);
 }
 
 /* int (*unlink_urb) (struct urb *urb, int status); */
diff --git a/drivers/usb/mon/mon_text.c b/drivers/usb/mon/mon_text.c
index 663a702a17dd..ebb04ac4857b 100644
--- a/drivers/usb/mon/mon_text.c
+++ b/drivers/usb/mon/mon_text.c
@@ -183,7 +183,7 @@ static inline unsigned int mon_get_timestamp(void)
 }
 
 static void mon_text_event(struct mon_reader_text *rp, struct urb *urb,
-    char ev_type)
+    char ev_type, int status)
 {
 	struct mon_event_text *ep;
 	unsigned int stamp;
@@ -210,7 +210,7 @@ static void mon_text_event(struct mon_reader_text *rp, struct urb *urb,
 	ep-&gt;length = (ev_type == 'S') ?
 	    urb-&gt;transfer_buffer_length : urb-&gt;actual_length;
 	/* Collecting status makes debugging sense for submits, too */
-	ep-&gt;status = urb-&gt;status;
+	ep-&gt;status = status;
 
 	if (ep-&gt;xfertype == USB_ENDPOINT_XFER_INT) {
 		ep-&gt;interval = urb-&gt;interval;
@@ -248,13 +248,13 @@ static void mon_text_event(struct mon_reader_text *rp, struct urb *urb,
 static void mon_text_submit(void *data, struct urb *urb)
 {
 	struct mon_reader_text *rp = data;
-	mon_text_event(rp, urb, 'S');
+	mon_text_event(rp, urb, 'S', -EINPROGRESS);
 }
 
-static void mon_text_complete(void *data, struct urb *urb)
+static void mon_text_complete(void *data, struct urb *urb, int status)
 {
 	struct mon_reader_text *rp = data;
-	mon_text_event(rp, urb, 'C');
+	mon_text_event(rp, urb, 'C', status);
 }
 
 static void mon_text_error(void *data, struct urb *urb, int error)
diff --git a/drivers/usb/mon/usb_mon.h b/drivers/usb/mon/usb_mon.h
index f68ad6d99ad7..f5d84ff8c101 100644
--- a/drivers/usb/mon/usb_mon.h
+++ b/drivers/usb/mon/usb_mon.h
@@ -46,7 +46,7 @@ struct mon_reader {
 
 	void (*rnf_submit)(void *data, struct urb *urb);
 	void (*rnf_error)(void *data, struct urb *urb, int error);
-	void (*rnf_complete)(void *data, struct urb *urb);
+	void (*rnf_complete)(void *data, struct urb *urb, int status);
 };
 
 void mon_reader_add(struct mon_bus *mbus, struct mon_reader *r);</pre><hr><pre>commit 888fda47051716765175d0008450126c837adb32
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 24 15:41:18 2007 -0400

    USB: reorganize urb-&gt;status use in r8a66597-hcd
    
    This patch (as977) reorganizes the way r8a66597-hcd sets urb-&gt;status.  It
    now keeps the information in a local variable until the last moment.
    
    Parts of this patch were written by Yoshihiro Shimoda.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Yoshihiro Shimoda &lt;shimoda.yoshihiro@renesas.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/r8a66597-hcd.c b/drivers/usb/host/r8a66597-hcd.c
index 98b9e0547544..fea6036771f6 100644
--- a/drivers/usb/host/r8a66597-hcd.c
+++ b/drivers/usb/host/r8a66597-hcd.c
@@ -1109,7 +1109,7 @@ static void set_td_timer(struct r8a66597 *r8a66597, struct r8a66597_td *td)
 
 /* this function must be called with interrupt disabled */
 static void finish_request(struct r8a66597 *r8a66597, struct r8a66597_td *td,
-		u16 pipenum, struct urb *urb)
+		u16 pipenum, struct urb *urb, int status)
 __releases(r8a66597-&gt;lock) __acquires(r8a66597-&gt;lock)
 {
 	int restart = 0;
@@ -1118,7 +1118,7 @@ __releases(r8a66597-&gt;lock) __acquires(r8a66597-&gt;lock)
 	r8a66597-&gt;timeout_map &amp;= ~(1 &lt;&lt; pipenum);
 
 	if (likely(td)) {
-		if (td-&gt;set_address &amp;&amp; (urb-&gt;status != 0 || urb-&gt;unlinked))
+		if (td-&gt;set_address &amp;&amp; (status != 0 || urb-&gt;unlinked))
 			r8a66597-&gt;address_map &amp;= ~(1 &lt;&lt; urb-&gt;setup_packet[2]);
 
 		pipe_toggle_save(r8a66597, td-&gt;pipe, urb);
@@ -1135,6 +1135,7 @@ __releases(r8a66597-&gt;lock) __acquires(r8a66597-&gt;lock)
 
 		usb_hcd_unlink_urb_from_ep(r8a66597_to_hcd(r8a66597), urb);
 
+		urb-&gt;status = status;
 		spin_unlock(&amp;r8a66597-&gt;lock);
 		usb_hcd_giveback_urb(hcd, urb);
 		spin_lock(&amp;r8a66597-&gt;lock);
@@ -1167,11 +1168,10 @@ static void packet_read(struct r8a66597 *r8a66597, u16 pipenum)
 	fifo_change_from_pipe(r8a66597, td-&gt;pipe);
 	tmp = r8a66597_read(r8a66597, td-&gt;pipe-&gt;fifoctr);
 	if (unlikely((tmp &amp; FRDY) == 0)) {
-		urb-&gt;status = -EPIPE;
 		pipe_stop(r8a66597, td-&gt;pipe);
 		pipe_irq_disable(r8a66597, pipenum);
 		err("in fifo not ready (%d)", pipenum);
-		finish_request(r8a66597, td, pipenum, td-&gt;urb);
+		finish_request(r8a66597, td, pipenum, td-&gt;urb, -EPIPE);
 		return;
 	}
 
@@ -1224,10 +1224,8 @@ static void packet_read(struct r8a66597 *r8a66597, u16 pipenum)
 					   buf, size);
 	}
 
-	if (finish &amp;&amp; pipenum != 0) {
-		td-&gt;urb-&gt;status = status;
-		finish_request(r8a66597, td, pipenum, urb);
-	}
+	if (finish &amp;&amp; pipenum != 0)
+		finish_request(r8a66597, td, pipenum, urb, status);
 }
 
 static void packet_write(struct r8a66597 *r8a66597, u16 pipenum)
@@ -1245,11 +1243,10 @@ static void packet_write(struct r8a66597 *r8a66597, u16 pipenum)
 	fifo_change_from_pipe(r8a66597, td-&gt;pipe);
 	tmp = r8a66597_read(r8a66597, td-&gt;pipe-&gt;fifoctr);
 	if (unlikely((tmp &amp; FRDY) == 0)) {
-		urb-&gt;status = -EPIPE;
 		pipe_stop(r8a66597, td-&gt;pipe);
 		pipe_irq_disable(r8a66597, pipenum);
 		err("out write fifo not ready. (%d)", pipenum);
-		finish_request(r8a66597, td, pipenum, td-&gt;urb);
+		finish_request(r8a66597, td, pipenum, urb, -EPIPE);
 		return;
 	}
 
@@ -1294,7 +1291,7 @@ static void packet_write(struct r8a66597 *r8a66597, u16 pipenum)
 }
 
 
-static void check_next_phase(struct r8a66597 *r8a66597)
+static void check_next_phase(struct r8a66597 *r8a66597, int status)
 {
 	struct r8a66597_td *td = r8a66597_get_td(r8a66597, 0);
 	struct urb *urb;
@@ -1320,28 +1317,28 @@ static void check_next_phase(struct r8a66597 *r8a66597)
 		break;
 	case USB_PID_ACK:
 		finish = 1;
-		urb-&gt;status = 0;
 		break;
 	}
 
-	if (finish || urb-&gt;unlinked)
-		finish_request(r8a66597, td, 0, urb);
+	if (finish || status != 0 || urb-&gt;unlinked)
+		finish_request(r8a66597, td, 0, urb, status);
 	else
 		start_transfer(r8a66597, td);
 }
 
-static void set_urb_error(struct r8a66597 *r8a66597, u16 pipenum)
+static int get_urb_error(struct r8a66597 *r8a66597, u16 pipenum)
 {
 	struct r8a66597_td *td = r8a66597_get_td(r8a66597, pipenum);
 
-	if (td &amp;&amp; td-&gt;urb) {
+	if (td) {
 		u16 pid = r8a66597_read(r8a66597, td-&gt;pipe-&gt;pipectr) &amp; PID;
 
 		if (pid == PID_NAK)
-			td-&gt;urb-&gt;status = -ECONNRESET;
+			return -ECONNRESET;
 		else
-			td-&gt;urb-&gt;status = -EPIPE;
+			return -EPIPE;
 	}
+	return 0;
 }
 
 static void irq_pipe_ready(struct r8a66597 *r8a66597)
@@ -1360,7 +1357,7 @@ static void irq_pipe_ready(struct r8a66597 *r8a66597)
 			packet_read(r8a66597, 0);
 		else
 			pipe_irq_disable(r8a66597, 0);
-		check_next_phase(r8a66597);
+		check_next_phase(r8a66597, 0);
 	}
 
 	for (pipenum = 1; pipenum &lt; R8A66597_MAX_NUM_PIPE; pipenum++) {
@@ -1394,7 +1391,7 @@ static void irq_pipe_empty(struct r8a66597 *r8a66597)
 		td = r8a66597_get_td(r8a66597, 0);
 		if (td &amp;&amp; td-&gt;type != USB_PID_OUT)
 			disable_irq_empty(r8a66597, 0);
-		check_next_phase(r8a66597);
+		check_next_phase(r8a66597, 0);
 	}
 
 	for (pipenum = 1; pipenum &lt; R8A66597_MAX_NUM_PIPE; pipenum++) {
@@ -1409,8 +1406,8 @@ static void irq_pipe_empty(struct r8a66597 *r8a66597)
 			if ((tmp &amp; INBUFM) == 0) {
 				disable_irq_empty(r8a66597, pipenum);
 				pipe_irq_disable(r8a66597, pipenum);
-				td-&gt;urb-&gt;status = 0;
-				finish_request(r8a66597, td, pipenum, td-&gt;urb);
+				finish_request(r8a66597, td, pipenum, td-&gt;urb,
+						0);
 			}
 		}
 	}
@@ -1421,15 +1418,16 @@ static void irq_pipe_nrdy(struct r8a66597 *r8a66597)
 	u16 check;
 	u16 pipenum;
 	u16 mask;
+	int status;
 
 	mask = r8a66597_read(r8a66597, NRDYSTS)
 	       &amp; r8a66597_read(r8a66597, NRDYENB);
 	r8a66597_write(r8a66597, ~mask, NRDYSTS);
 	if (mask &amp; NRDY0) {
 		cfifo_change(r8a66597, 0);
-		set_urb_error(r8a66597, 0);
+		status = get_urb_error(r8a66597, 0);
 		pipe_irq_disable(r8a66597, 0);
-		check_next_phase(r8a66597);
+		check_next_phase(r8a66597, status);
 	}
 
 	for (pipenum = 1; pipenum &lt; R8A66597_MAX_NUM_PIPE; pipenum++) {
@@ -1440,10 +1438,10 @@ static void irq_pipe_nrdy(struct r8a66597 *r8a66597)
 			if (unlikely(!td))
 				continue;
 
-			set_urb_error(r8a66597, pipenum);
+			status = get_urb_error(r8a66597, pipenum);
 			pipe_irq_disable(r8a66597, pipenum);
 			pipe_stop(r8a66597, td-&gt;pipe);
-			finish_request(r8a66597, td, pipenum, td-&gt;urb);
+			finish_request(r8a66597, td, pipenum, td-&gt;urb, status);
 		}
 	}
 }
@@ -1463,6 +1461,7 @@ static irqreturn_t r8a66597_irq(struct usb_hcd *hcd)
 	u16 intsts0, intsts1, intsts2;
 	u16 intenb0, intenb1, intenb2;
 	u16 mask0, mask1, mask2;
+	int status;
 
 	spin_lock(&amp;r8a66597-&gt;lock);
 
@@ -1506,12 +1505,12 @@ static irqreturn_t r8a66597_irq(struct usb_hcd *hcd)
 		}
 		if (mask1 &amp; SIGN) {
 			r8a66597_write(r8a66597, ~SIGN, INTSTS1);
-			set_urb_error(r8a66597, 0);
-			check_next_phase(r8a66597);
+			status = get_urb_error(r8a66597, 0);
+			check_next_phase(r8a66597, status);
 		}
 		if (mask1 &amp; SACK) {
 			r8a66597_write(r8a66597, ~SACK, INTSTS1);
-			check_next_phase(r8a66597);
+			check_next_phase(r8a66597, 0);
 		}
 	}
 	if (mask0) {
@@ -1790,7 +1789,7 @@ static int r8a66597_urb_dequeue(struct usb_hcd *hcd, struct urb *urb,
 		pipe_stop(r8a66597, td-&gt;pipe);
 		pipe_irq_disable(r8a66597, td-&gt;pipenum);
 		disable_irq_empty(r8a66597, td-&gt;pipenum);
-		finish_request(r8a66597, td, td-&gt;pipenum, urb);
+		finish_request(r8a66597, td, td-&gt;pipenum, urb, status);
 	}
  done:
 	spin_unlock_irqrestore(&amp;r8a66597-&gt;lock, flags);
@@ -1824,7 +1823,7 @@ static void r8a66597_endpoint_disable(struct usb_hcd *hcd,
 	td = r8a66597_get_td(r8a66597, pipenum);
 	if (td)
 		urb = td-&gt;urb;
-	finish_request(r8a66597, td, pipenum, urb);
+	finish_request(r8a66597, td, pipenum, urb, -ESHUTDOWN);
 	kfree(hep-&gt;hcpriv);
 	hep-&gt;hcpriv = NULL;
 	spin_unlock_irqrestore(&amp;r8a66597-&gt;lock, flags);</pre><hr><pre>commit 65e51098d9094c7e840b6d6291867b95538d9442
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 24 15:40:47 2007 -0400

    USB: reorganize urb-&gt;status use in sl811-hcd
    
    This patch (as976) reorganizes the way sl811-hcd sets urb-&gt;status.  It
    now keeps the information in a local variable until the last moment.
    
    The patch also improves the handling of faults during the status stage
    of a control transfer, since it no longer needs to retain the error
    information from the earlier stages.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/sl811-hcd.c b/drivers/usb/host/sl811-hcd.c
index f0fa94148d9d..515152809d37 100644
--- a/drivers/usb/host/sl811-hcd.c
+++ b/drivers/usb/host/sl811-hcd.c
@@ -435,11 +435,8 @@ static void finish_request(
 	if (usb_pipecontrol(urb-&gt;pipe))
 		ep-&gt;nextpid = USB_PID_SETUP;
 
-	spin_lock(&amp;urb-&gt;lock);
-	urb-&gt;status = status;
-	spin_unlock(&amp;urb-&gt;lock);
-
 	usb_hcd_unlink_urb_from_ep(sl811_to_hcd(sl811), urb);
+	urb-&gt;status = status;
 	spin_unlock(&amp;sl811-&gt;lock);
 	usb_hcd_giveback_urb(sl811_to_hcd(sl811), urb);
 	spin_lock(&amp;sl811-&gt;lock);
@@ -537,27 +534,20 @@ done(struct sl811 *sl811, struct sl811h_ep *ep, u8 bank)
 						bank + SL11H_XFERCNTREG);
 			if (len &gt; ep-&gt;length) {
 				len = ep-&gt;length;
-				urb-&gt;status = -EOVERFLOW;
+				urbstat = -EOVERFLOW;
 			}
 			urb-&gt;actual_length += len;
 			sl811_read_buf(sl811, SL811HS_PACKET_BUF(bank == 0),
 					buf, len);
 			usb_dotoggle(udev, ep-&gt;epnum, 0);
-			if (urb-&gt;actual_length == urb-&gt;transfer_buffer_length
-					|| len &lt; ep-&gt;maxpacket)
-				urbstat = 0;
-			if (usb_pipecontrol(urb-&gt;pipe) &amp;&amp; urbstat == 0) {
-
-				/* NOTE if the status stage STALLs (why?),
-				 * this reports the wrong urb status.
-				 */
-				spin_lock(&amp;urb-&gt;lock);
-				if (urb-&gt;status == -EINPROGRESS)
-					urb-&gt;status = urbstat;
-				spin_unlock(&amp;urb-&gt;lock);
-
-				urb = NULL;
-				ep-&gt;nextpid = USB_PID_ACK;
+			if (urbstat == -EINPROGRESS &amp;&amp;
+					(len &lt; ep-&gt;maxpacket ||
+						urb-&gt;actual_length ==
+						urb-&gt;transfer_buffer_length)) {
+				if (usb_pipecontrol(urb-&gt;pipe))
+					ep-&gt;nextpid = USB_PID_ACK;
+				else
+					urbstat = 0;
 			}
 			break;
 		case USB_PID_SETUP:
@@ -597,7 +587,7 @@ done(struct sl811 *sl811, struct sl811h_ep *ep, u8 bank)
 				bank, status, ep, urbstat);
 	}
 
-	if (urb &amp;&amp; (urbstat != -EINPROGRESS || urb-&gt;unlinked))
+	if (urbstat != -EINPROGRESS || urb-&gt;unlinked)
 		finish_request(sl811, ep, urb, urbstat);
 }
 </pre><hr><pre>commit 55d8496837cf124f68656e4242a5e20eb592fd54
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 24 15:40:34 2007 -0400

    USB: reorganize urb-&gt;status use in ohci-hcd
    
    This patch (as975) reorganizes the way ohci-hcd sets urb-&gt;status.  It
    now keeps the information in a local variable until the last moment.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ohci-dbg.c b/drivers/usb/host/ohci-dbg.c
index f61c6cdd06f2..ebab5ce8f5ce 100644
--- a/drivers/usb/host/ohci-dbg.c
+++ b/drivers/usb/host/ohci-dbg.c
@@ -24,7 +24,7 @@
  * small: 0) header + data packets 1) just header
  */
 static void __maybe_unused
-urb_print (struct urb * urb, char * str, int small)
+urb_print(struct urb * urb, char * str, int small, int status)
 {
 	unsigned int pipe= urb-&gt;pipe;
 
@@ -34,7 +34,7 @@ urb_print (struct urb * urb, char * str, int small)
 	}
 
 #ifndef	OHCI_VERBOSE_DEBUG
-	if (urb-&gt;status != 0)
+	if (status != 0)
 #endif
 	dbg("%s %p dev=%d ep=%d%s-%s flags=%x len=%d/%d stat=%d",
 		    str,
@@ -46,7 +46,7 @@ urb_print (struct urb * urb, char * str, int small)
 		    urb-&gt;transfer_flags,
 		    urb-&gt;actual_length,
 		    urb-&gt;transfer_buffer_length,
-		    urb-&gt;status);
+		    status);
 
 #ifdef	OHCI_VERBOSE_DEBUG
 	if (!small) {
@@ -66,7 +66,7 @@ urb_print (struct urb * urb, char * str, int small)
 						urb-&gt;transfer_buffer_length: urb-&gt;actual_length;
 			for (i = 0; i &lt; 16 &amp;&amp; i &lt; len; i++)
 				printk (" %02x", ((__u8 *) urb-&gt;transfer_buffer) [i]);
-			printk ("%s stat:%d\n", i &lt; len? "...": "", urb-&gt;status);
+			printk ("%s stat:%d\n", i &lt; len? "...": "", status);
 		}
 	}
 #endif
diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index 6b06ab69938f..f7c6ced2bc03 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -129,7 +129,7 @@ static int ohci_urb_enqueue (
 	int		retval = 0;
 
 #ifdef OHCI_VERBOSE_DEBUG
-	urb_print (urb, "SUB", usb_pipein (pipe));
+	urb_print(urb, "SUB", usb_pipein(pipe), -EINPROGRESS);
 #endif
 
 	/* every endpoint has a ed, locate and maybe (re)initialize it */
@@ -240,8 +240,8 @@ static int ohci_urb_enqueue (
 }
 
 /*
- * decouple the URB from the HC queues (TDs, urb_priv); it's
- * already marked using urb-&gt;status.  reporting is always done
+ * decouple the URB from the HC queues (TDs, urb_priv).
+ * reporting is always done
  * asynchronously, and we might be dealing with an urb that's
  * partially transferred, or an ED with other urbs being unlinked.
  */
@@ -252,7 +252,7 @@ static int ohci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 	int			rc;
 
 #ifdef OHCI_VERBOSE_DEBUG
-	urb_print (urb, "UNLINK", 1);
+	urb_print(urb, "UNLINK", 1, status);
 #endif
 
 	spin_lock_irqsave (&amp;ohci-&gt;lock, flags);
@@ -277,7 +277,7 @@ static int ohci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 		 * any more ... just clean up every urb's memory.
 		 */
 		if (urb-&gt;hcpriv)
-			finish_urb (ohci, urb);
+			finish_urb(ohci, urb, status);
 	}
 	spin_unlock_irqrestore (&amp;ohci-&gt;lock, flags);
 	return rc;
@@ -927,9 +927,8 @@ static int ohci_restart (struct ohci_hcd *ohci)
 					ed, ed-&gt;state);
 		}
 
-		spin_lock (&amp;urb-&gt;lock);
-		urb-&gt;status = -ESHUTDOWN;
-		spin_unlock (&amp;urb-&gt;lock);
+		if (!urb-&gt;unlinked)
+			urb-&gt;unlinked = -ESHUTDOWN;
 	}
 	finish_unlinks (ohci, 0);
 	spin_unlock_irq(&amp;ohci-&gt;lock);
diff --git a/drivers/usb/host/ohci-q.c b/drivers/usb/host/ohci-q.c
index 860e55ff67a1..13d31edd1a86 100644
--- a/drivers/usb/host/ohci-q.c
+++ b/drivers/usb/host/ohci-q.c
@@ -36,18 +36,15 @@ static void urb_free_priv (struct ohci_hcd *hc, urb_priv_t *urb_priv)
  * PRECONDITION:  ohci lock held, irqs blocked.
  */
 static void
-finish_urb (struct ohci_hcd *ohci, struct urb *urb)
+finish_urb(struct ohci_hcd *ohci, struct urb *urb, int status)
 __releases(ohci-&gt;lock)
 __acquires(ohci-&gt;lock)
 {
 	// ASSERT (urb-&gt;hcpriv != 0);
 
 	urb_free_priv (ohci, urb-&gt;hcpriv);
-
-	spin_lock (&amp;urb-&gt;lock);
-	if (likely (urb-&gt;status == -EINPROGRESS))
-		urb-&gt;status = 0;
-	spin_unlock (&amp;urb-&gt;lock);
+	if (likely(status == -EINPROGRESS))
+		status = 0;
 
 	switch (usb_pipetype (urb-&gt;pipe)) {
 	case PIPE_ISOCHRONOUS:
@@ -59,12 +56,13 @@ __acquires(ohci-&gt;lock)
 	}
 
 #ifdef OHCI_VERBOSE_DEBUG
-	urb_print (urb, "RET", usb_pipeout (urb-&gt;pipe));
+	urb_print(urb, "RET", usb_pipeout (urb-&gt;pipe), status);
 #endif
 
 	/* urb-&gt;complete() can reenter this HCD */
 	usb_hcd_unlink_urb_from_ep(ohci_to_hcd(ohci), urb);
 	spin_unlock (&amp;ohci-&gt;lock);
+	urb-&gt;status = status;
 	usb_hcd_giveback_urb (ohci_to_hcd(ohci), urb);
 	spin_lock (&amp;ohci-&gt;lock);
 
@@ -702,19 +700,18 @@ static void td_submit_urb (
  * Done List handling functions
  *-------------------------------------------------------------------------*/
 
-/* calculate transfer length/status and update the urb
- * PRECONDITION:  irqsafe (only for urb-&gt;status locking)
- */
-static void td_done (struct ohci_hcd *ohci, struct urb *urb, struct td *td)
+/* calculate transfer length/status and update the urb */
+static int td_done(struct ohci_hcd *ohci, struct urb *urb, struct td *td)
 {
 	u32	tdINFO = hc32_to_cpup (ohci, &amp;td-&gt;hwINFO);
 	int	cc = 0;
+	int	status = -EINPROGRESS;
 
 	list_del (&amp;td-&gt;td_list);
 
 	/* ISO ... drivers see per-TD length/status */
 	if (tdINFO &amp; TD_ISO) {
-		u16	tdPSW = ohci_hwPSW (ohci, td, 0);
+		u16	tdPSW = ohci_hwPSW(ohci, td, 0);
 		int	dlen = 0;
 
 		/* NOTE:  assumes FC in tdINFO == 0, and that
@@ -723,7 +720,7 @@ static void td_done (struct ohci_hcd *ohci, struct urb *urb, struct td *td)
 
 		cc = (tdPSW &gt;&gt; 12) &amp; 0xF;
 		if (tdINFO &amp; TD_CC)	/* hc didn't touch? */
-			return;
+			return status;
 
 		if (usb_pipeout (urb-&gt;pipe))
 			dlen = urb-&gt;iso_frame_desc [td-&gt;index].length;
@@ -756,11 +753,8 @@ static void td_done (struct ohci_hcd *ohci, struct urb *urb, struct td *td)
 		if (cc == TD_DATAUNDERRUN
 				&amp;&amp; !(urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK))
 			cc = TD_CC_NOERROR;
-		if (cc != TD_CC_NOERROR &amp;&amp; cc &lt; 0x0E) {
-			spin_lock (&amp;urb-&gt;lock);
-			urb-&gt;status = cc_to_error[cc];
-			spin_unlock (&amp;urb-&gt;lock);
-		}
+		if (cc != TD_CC_NOERROR &amp;&amp; cc &lt; 0x0E)
+			status = cc_to_error[cc];
 
 		/* count all non-empty packets except control SETUP packet */
 		if ((type != PIPE_CONTROL || td-&gt;index != 0) &amp;&amp; tdBE != 0) {
@@ -779,6 +773,7 @@ static void td_done (struct ohci_hcd *ohci, struct urb *urb, struct td *td)
 				urb-&gt;actual_length,
 				urb-&gt;transfer_buffer_length);
 	}
+	return status;
 }
 
 /*-------------------------------------------------------------------------*/
@@ -979,7 +974,7 @@ finish_unlinks (struct ohci_hcd *ohci, u16 tick)
 			/* if URB is done, clean up */
 			if (urb_priv-&gt;td_cnt == urb_priv-&gt;length) {
 				modified = completed = 1;
-				finish_urb (ohci, urb);
+				finish_urb(ohci, urb, 0);
 			}
 		}
 		if (completed &amp;&amp; !list_empty (&amp;ed-&gt;td_list))
@@ -1062,14 +1057,15 @@ static void takeback_td(struct ohci_hcd *ohci, struct td *td)
 	struct urb	*urb = td-&gt;urb;
 	urb_priv_t	*urb_priv = urb-&gt;hcpriv;
 	struct ed	*ed = td-&gt;ed;
+	int		status;
 
 	/* update URB's length and status from TD */
-	td_done(ohci, urb, td);
+	status = td_done(ohci, urb, td);
 	urb_priv-&gt;td_cnt++;
 
 	/* If all this urb's TDs are done, call complete() */
 	if (urb_priv-&gt;td_cnt == urb_priv-&gt;length)
-		finish_urb(ohci, urb);
+		finish_urb(ohci, urb, status);
 
 	/* clean schedule:  unlink EDs that are no longer busy */
 	if (list_empty(&amp;ed-&gt;td_list)) {</pre>
    <div class="pagination">
        <a href='2_99.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><span>[100]</span><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_101.html'>Next&gt;&gt;</a>
    <div>
</body>
