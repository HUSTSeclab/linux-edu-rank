<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_2.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><span>[3]</span><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_4.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit df05a9b05e466a46725564528b277d0c570d0104
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Apr 10 15:38:22 2023 -0400

    USB: sisusbvga: Add endpoint checks
    
    The syzbot fuzzer was able to provoke a WARNING from the sisusbvga driver:
    
    ------------[ cut here ]------------
    usb 1-1: BOGUS urb xfer, pipe 3 != type 1
    WARNING: CPU: 1 PID: 26 at drivers/usb/core/urb.c:504 usb_submit_urb+0xed6/0x1880 drivers/usb/core/urb.c:504
    Modules linked in:
    CPU: 1 PID: 26 Comm: kworker/1:1 Not tainted 6.2.0-rc5-syzkaller-00199-g5af6ce704936 #0
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/12/2023
    Workqueue: usb_hub_wq hub_event
    RIP: 0010:usb_submit_urb+0xed6/0x1880 drivers/usb/core/urb.c:504
    Code: 7c 24 18 e8 6c 50 80 fb 48 8b 7c 24 18 e8 62 1a 01 ff 41 89 d8 44 89 e1 4c 89 ea 48 89 c6 48 c7 c7 60 b1 fa 8a e8 84 b0 be 03 &lt;0f&gt; 0b e9 58 f8 ff ff e8 3e 50 80 fb 48 81 c5 c0 05 00 00 e9 84 f7
    RSP: 0018:ffffc90000a1ed18 EFLAGS: 00010282
    RAX: 0000000000000000 RBX: 0000000000000001 RCX: 0000000000000000
    RDX: ffff888012783a80 RSI: ffffffff816680ec RDI: fffff52000143d95
    RBP: ffff888079020000 R08: 0000000000000005 R09: 0000000000000000
    R10: 0000000080000000 R11: 0000000000000000 R12: 0000000000000003
    R13: ffff888017d33370 R14: 0000000000000003 R15: ffff888021213600
    FS:  0000000000000000(0000) GS:ffff8880b9900000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 00005592753a60b0 CR3: 0000000022899000 CR4: 00000000003506e0
    DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
    Call Trace:
     &lt;TASK&gt;
     sisusb_bulkout_msg drivers/usb/misc/sisusbvga/sisusbvga.c:224 [inline]
     sisusb_send_bulk_msg.constprop.0+0x904/0x1230 drivers/usb/misc/sisusbvga/sisusbvga.c:379
     sisusb_send_bridge_packet drivers/usb/misc/sisusbvga/sisusbvga.c:567 [inline]
     sisusb_do_init_gfxdevice drivers/usb/misc/sisusbvga/sisusbvga.c:2077 [inline]
     sisusb_init_gfxdevice+0x87b/0x4000 drivers/usb/misc/sisusbvga/sisusbvga.c:2177
     sisusb_probe+0x9cd/0xbe2 drivers/usb/misc/sisusbvga/sisusbvga.c:2869
    ...
    
    The problem was caused by the fact that the driver does not check
    whether the endpoints it uses are actually present and have the
    appropriate types.  This can be fixed by adding a simple check of
    the endpoints.
    
    Link: https://syzkaller.appspot.com/bug?extid=23be03b56c5259385d79
    Reported-and-tested-by: syzbot+23be03b56c5259385d79@syzkaller.appspotmail.com
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/48ef98f7-51ae-4f63-b8d3-0ef2004bb60a@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/misc/sisusbvga/sisusbvga.c b/drivers/usb/misc/sisusbvga/sisusbvga.c
index 654a79fd3231..febf34f9f049 100644
--- a/drivers/usb/misc/sisusbvga/sisusbvga.c
+++ b/drivers/usb/misc/sisusbvga/sisusbvga.c
@@ -2778,6 +2778,20 @@ static int sisusb_probe(struct usb_interface *intf,
 	struct usb_device *dev = interface_to_usbdev(intf);
 	struct sisusb_usb_data *sisusb;
 	int retval = 0, i;
+	static const u8 ep_addresses[] = {
+		SISUSB_EP_GFX_IN | USB_DIR_IN,
+		SISUSB_EP_GFX_OUT | USB_DIR_OUT,
+		SISUSB_EP_GFX_BULK_OUT | USB_DIR_OUT,
+		SISUSB_EP_GFX_LBULK_OUT | USB_DIR_OUT,
+		SISUSB_EP_BRIDGE_IN | USB_DIR_IN,
+		SISUSB_EP_BRIDGE_OUT | USB_DIR_OUT,
+		0};
+
+	/* Are the expected endpoints present? */
+	if (!usb_check_bulk_endpoints(intf, ep_addresses)) {
+		dev_err(&amp;intf-&gt;dev, "Invalid USB2VGA device\n");
+		return -EINVAL;
+	}
 
 	dev_info(&amp;dev-&gt;dev, "USB2VGA dongle found at address %d\n",
 			dev-&gt;devnum);</pre><hr><pre>commit 13890626501ffda22b18213ddaf7930473da5792
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Apr 10 15:37:07 2023 -0400

    USB: core: Add routines for endpoint checks in old drivers
    
    Many of the older USB drivers in the Linux USB stack were written
    based simply on a vendor's device specification.  They use the
    endpoint information in the spec and assume these endpoints will
    always be present, with the properties listed, in any device matching
    the given vendor and product IDs.
    
    While that may have been true back then, with spoofing and fuzzing it
    is not true any more.  More and more we are finding that those old
    drivers need to perform at least a minimum of checking before they try
    to use any endpoint other than ep0.
    
    To make this checking as simple as possible, we now add a couple of
    utility routines to the USB core.  usb_check_bulk_endpoints() and
    usb_check_int_endpoints() take an interface pointer together with a
    list of endpoint addresses (numbers and directions).  They check that
    the interface's current alternate setting includes endpoints with
    those addresses and that each of these endpoints has the right type:
    bulk or interrupt, respectively.
    
    Although we already have usb_find_common_endpoints() and related
    routines meant for a similar purpose, they are not well suited for
    this kind of checking.  Those routines find endpoints of various
    kinds, but only one (either the first or the last) of each kind, and
    they don't verify that the endpoints' addresses agree with what the
    caller expects.
    
    In theory the new routines could be more general: They could take a
    particular altsetting as their argument instead of always using the
    interface's current altsetting.  In practice I think this won't matter
    too much; multiple altsettings tend to be used for transferring media
    (audio or visual) over isochronous endpoints, not bulk or interrupt.
    Drivers for such devices will generally require more sophisticated
    checking than these simplistic routines provide.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/dd2c8e8c-2c87-44ea-ba17-c64b97e201c9@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index 34742fbbd84d..901ec732321c 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -206,6 +206,82 @@ int usb_find_common_endpoints_reverse(struct usb_host_interface *alt,
 }
 EXPORT_SYMBOL_GPL(usb_find_common_endpoints_reverse);
 
+/**
+ * usb_find_endpoint() - Given an endpoint address, search for the endpoint's
+ * usb_host_endpoint structure in an interface's current altsetting.
+ * @intf: the interface whose current altsetting should be searched
+ * @ep_addr: the endpoint address (number and direction) to find
+ *
+ * Search the altsetting's list of endpoints for one with the specified address.
+ *
+ * Return: Pointer to the usb_host_endpoint if found, %NULL otherwise.
+ */
+static const struct usb_host_endpoint *usb_find_endpoint(
+		const struct usb_interface *intf, unsigned int ep_addr)
+{
+	int n;
+	const struct usb_host_endpoint *ep;
+
+	n = intf-&gt;cur_altsetting-&gt;desc.bNumEndpoints;
+	ep = intf-&gt;cur_altsetting-&gt;endpoint;
+	for (; n &gt; 0; (--n, ++ep)) {
+		if (ep-&gt;desc.bEndpointAddress == ep_addr)
+			return ep;
+	}
+	return NULL;
+}
+
+/**
+ * usb_check_bulk_endpoints - Check whether an interface's current altsetting
+ * contains a set of bulk endpoints with the given addresses.
+ * @intf: the interface whose current altsetting should be searched
+ * @ep_addrs: 0-terminated array of the endpoint addresses (number and
+ * direction) to look for
+ *
+ * Search for endpoints with the specified addresses and check their types.
+ *
+ * Return: %true if all the endpoints are found and are bulk, %false otherwise.
+ */
+bool usb_check_bulk_endpoints(
+		const struct usb_interface *intf, const u8 *ep_addrs)
+{
+	const struct usb_host_endpoint *ep;
+
+	for (; *ep_addrs; ++ep_addrs) {
+		ep = usb_find_endpoint(intf, *ep_addrs);
+		if (!ep || !usb_endpoint_xfer_bulk(&amp;ep-&gt;desc))
+			return false;
+	}
+	return true;
+}
+EXPORT_SYMBOL_GPL(usb_check_bulk_endpoints);
+
+/**
+ * usb_check_int_endpoints - Check whether an interface's current altsetting
+ * contains a set of interrupt endpoints with the given addresses.
+ * @intf: the interface whose current altsetting should be searched
+ * @ep_addrs: 0-terminated array of the endpoint addresses (number and
+ * direction) to look for
+ *
+ * Search for endpoints with the specified addresses and check their types.
+ *
+ * Return: %true if all the endpoints are found and are interrupt,
+ * %false otherwise.
+ */
+bool usb_check_int_endpoints(
+		const struct usb_interface *intf, const u8 *ep_addrs)
+{
+	const struct usb_host_endpoint *ep;
+
+	for (; *ep_addrs; ++ep_addrs) {
+		ep = usb_find_endpoint(intf, *ep_addrs);
+		if (!ep || !usb_endpoint_xfer_int(&amp;ep-&gt;desc))
+			return false;
+	}
+	return true;
+}
+EXPORT_SYMBOL_GPL(usb_check_int_endpoints);
+
 /**
  * usb_find_alt_setting() - Given a configuration, find the alternate setting
  * for the given interface.
diff --git a/include/linux/usb.h b/include/linux/usb.h
index d510fabcafa2..4ae0466c846c 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -291,6 +291,11 @@ void usb_put_intf(struct usb_interface *intf);
 #define USB_MAXINTERFACES	32
 #define USB_MAXIADS		(USB_MAXINTERFACES/2)
 
+bool usb_check_bulk_endpoints(
+		const struct usb_interface *intf, const u8 *ep_addrs);
+bool usb_check_int_endpoints(
+		const struct usb_interface *intf, const u8 *ep_addrs);
+
 /*
  * USB Resume Timer: Every Host controller driver should drive the resume
  * signalling on the bus for the amount of time defined by this macro.</pre><hr><pre>commit de0418053215482cc61843244fc7c1385ddf63a7
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Feb 24 10:30:48 2023 -0500

    tools/memory-model: Add documentation about SRCU read-side critical sections
    
    Expand the discussion of SRCU and its read-side critical sections in
    the Linux Kernel Memory Model documentation file explanation.txt.  The
    new material discusses recent changes to the memory model made in
    commit 6cd244c87428 ("tools/memory-model: Provide exact SRCU
    semantics").
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Co-developed-by: Joel Fernandes (Google) &lt;joel@joelfernandes.org&gt;
    Signed-off-by: Joel Fernandes (Google) &lt;joel@joelfernandes.org&gt;
    Reviewed-by: Akira Yokosawa &lt;akiyks@gmail.com&gt;
    Cc: Andrea Parri &lt;parri.andrea@gmail.com&gt;
    Cc: Boqun Feng &lt;boqun.feng@gmail.com&gt;
    Cc: Jade Alglave &lt;j.alglave@ucl.ac.uk&gt;
    Cc: Jonas Oberhauser &lt;jonas.oberhauser@huawei.com&gt;
    Cc: Luc Maranget &lt;luc.maranget@inria.fr&gt;
    Cc: "Paul E. McKenney" &lt;paulmck@linux.ibm.com&gt;
    Cc: Peter Zijlstra &lt;peterz@infradead.org&gt;
    CC: Will Deacon &lt;will@kernel.org&gt;
    Signed-off-by: Paul E. McKenney &lt;paulmck@kernel.org&gt;

diff --git a/tools/memory-model/Documentation/explanation.txt b/tools/memory-model/Documentation/explanation.txt
index 8e7085238470..6dc8b3642458 100644
--- a/tools/memory-model/Documentation/explanation.txt
+++ b/tools/memory-model/Documentation/explanation.txt
@@ -28,9 +28,10 @@ Explanation of the Linux-Kernel Memory Consistency Model
   20. THE HAPPENS-BEFORE RELATION: hb
   21. THE PROPAGATES-BEFORE RELATION: pb
   22. RCU RELATIONS: rcu-link, rcu-gp, rcu-rscsi, rcu-order, rcu-fence, and rb
-  23. LOCKING
-  24. PLAIN ACCESSES AND DATA RACES
-  25. ODDS AND ENDS
+  23. SRCU READ-SIDE CRITICAL SECTIONS
+  24. LOCKING
+  25. PLAIN ACCESSES AND DATA RACES
+  26. ODDS AND ENDS
 
 
 
@@ -1848,14 +1849,169 @@ section in P0 both starts before P1's grace period does and ends
 before it does, and the critical section in P2 both starts after P1's
 grace period does and ends after it does.
 
-Addendum: The LKMM now supports SRCU (Sleepable Read-Copy-Update) in
-addition to normal RCU.  The ideas involved are much the same as
-above, with new relations srcu-gp and srcu-rscsi added to represent
-SRCU grace periods and read-side critical sections.  There is a
-restriction on the srcu-gp and srcu-rscsi links that can appear in an
-rcu-order sequence (the srcu-rscsi links must be paired with srcu-gp
-links having the same SRCU domain with proper nesting); the details
-are relatively unimportant.
+The LKMM supports SRCU (Sleepable Read-Copy-Update) in addition to
+normal RCU.  The ideas involved are much the same as above, with new
+relations srcu-gp and srcu-rscsi added to represent SRCU grace periods
+and read-side critical sections.  However, there are some significant
+differences between RCU read-side critical sections and their SRCU
+counterparts, as described in the next section.
+
+
+SRCU READ-SIDE CRITICAL SECTIONS
+--------------------------------
+
+The LKMM uses the srcu-rscsi relation to model SRCU read-side critical
+sections.  They differ from RCU read-side critical sections in the
+following respects:
+
+1.	Unlike the analogous RCU primitives, synchronize_srcu(),
+	srcu_read_lock(), and srcu_read_unlock() take a pointer to a
+	struct srcu_struct as an argument.  This structure is called
+	an SRCU domain, and calls linked by srcu-rscsi must have the
+	same domain.  Read-side critical sections and grace periods
+	associated with different domains are independent of one
+	another; the SRCU version of the RCU Guarantee applies only
+	to pairs of critical sections and grace periods having the
+	same domain.
+
+2.	srcu_read_lock() returns a value, called the index, which must
+	be passed to the matching srcu_read_unlock() call.  Unlike
+	rcu_read_lock() and rcu_read_unlock(), an srcu_read_lock()
+	call does not always have to match the next unpaired
+	srcu_read_unlock().  In fact, it is possible for two SRCU
+	read-side critical sections to overlap partially, as in the
+	following example (where s is an srcu_struct and idx1 and idx2
+	are integer variables):
+
+		idx1 = srcu_read_lock(&amp;s);	// Start of first RSCS
+		idx2 = srcu_read_lock(&amp;s);	// Start of second RSCS
+		srcu_read_unlock(&amp;s, idx1);	// End of first RSCS
+		srcu_read_unlock(&amp;s, idx2);	// End of second RSCS
+
+	The matching is determined entirely by the domain pointer and
+	index value.  By contrast, if the calls had been
+	rcu_read_lock() and rcu_read_unlock() then they would have
+	created two nested (fully overlapping) read-side critical
+	sections: an inner one and an outer one.
+
+3.	The srcu_down_read() and srcu_up_read() primitives work
+	exactly like srcu_read_lock() and srcu_read_unlock(), except
+	that matching calls don't have to execute on the same CPU.
+	(The names are meant to be suggestive of operations on
+	semaphores.)  Since the matching is determined by the domain
+	pointer and index value, these primitives make it possible for
+	an SRCU read-side critical section to start on one CPU and end
+	on another, so to speak.
+
+In order to account for these properties of SRCU, the LKMM models
+srcu_read_lock() as a special type of load event (which is
+appropriate, since it takes a memory location as argument and returns
+a value, just as a load does) and srcu_read_unlock() as a special type
+of store event (again appropriate, since it takes as arguments a
+memory location and a value).  These loads and stores are annotated as
+belonging to the "srcu-lock" and "srcu-unlock" event classes
+respectively.
+
+This approach allows the LKMM to tell whether two events are
+associated with the same SRCU domain, simply by checking whether they
+access the same memory location (i.e., they are linked by the loc
+relation).  It also gives a way to tell which unlock matches a
+particular lock, by checking for the presence of a data dependency
+from the load (srcu-lock) to the store (srcu-unlock).  For example,
+given the situation outlined earlier (with statement labels added):
+
+	A: idx1 = srcu_read_lock(&amp;s);
+	B: idx2 = srcu_read_lock(&amp;s);
+	C: srcu_read_unlock(&amp;s, idx1);
+	D: srcu_read_unlock(&amp;s, idx2);
+
+the LKMM will treat A and B as loads from s yielding values saved in
+idx1 and idx2 respectively.  Similarly, it will treat C and D as
+though they stored the values from idx1 and idx2 in s.  The end result
+is much as if we had written:
+
+	A: idx1 = READ_ONCE(s);
+	B: idx2 = READ_ONCE(s);
+	C: WRITE_ONCE(s, idx1);
+	D: WRITE_ONCE(s, idx2);
+
+except for the presence of the special srcu-lock and srcu-unlock
+annotations.  You can see at once that we have A -&gt;data C and
+B -&gt;data D.  These dependencies tell the LKMM that C is the
+srcu-unlock event matching srcu-lock event A, and D is the
+srcu-unlock event matching srcu-lock event B.
+
+This approach is admittedly a hack, and it has the potential to lead
+to problems.  For example, in:
+
+	idx1 = srcu_read_lock(&amp;s);
+	srcu_read_unlock(&amp;s, idx1);
+	idx2 = srcu_read_lock(&amp;s);
+	srcu_read_unlock(&amp;s, idx2);
+
+the LKMM will believe that idx2 must have the same value as idx1,
+since it reads from the immediately preceding store of idx1 in s.
+Fortunately this won't matter, assuming that litmus tests never do
+anything with SRCU index values other than pass them to
+srcu_read_unlock() or srcu_up_read() calls.
+
+However, sometimes it is necessary to store an index value in a
+shared variable temporarily.  In fact, this is the only way for
+srcu_down_read() to pass the index it gets to an srcu_up_read() call
+on a different CPU.  In more detail, we might have soething like:
+
+	struct srcu_struct s;
+	int x;
+
+	P0()
+	{
+		int r0;
+
+		A: r0 = srcu_down_read(&amp;s);
+		B: WRITE_ONCE(x, r0);
+	}
+
+	P1()
+	{
+		int r1;
+
+		C: r1 = READ_ONCE(x);
+		D: srcu_up_read(&amp;s, r1);
+	}
+
+Assuming that P1 executes after P0 and does read the index value
+stored in x, we can write this (using brackets to represent event
+annotations) as:
+
+	A[srcu-lock] -&gt;data B[once] -&gt;rf C[once] -&gt;data D[srcu-unlock].
+
+The LKMM defines a carry-srcu-data relation to express this pattern;
+it permits an arbitrarily long sequence of
+
+	data ; rf
+
+pairs (that is, a data link followed by an rf link) to occur between
+an srcu-lock event and the final data dependency leading to the
+matching srcu-unlock event.  carry-srcu-data is complicated by the
+need to ensure that none of the intermediate store events in this
+sequence are instances of srcu-unlock.  This is necessary because in a
+pattern like the one above:
+
+	A: idx1 = srcu_read_lock(&amp;s);
+	B: srcu_read_unlock(&amp;s, idx1);
+	C: idx2 = srcu_read_lock(&amp;s);
+	D: srcu_read_unlock(&amp;s, idx2);
+
+the LKMM treats B as a store to the variable s and C as a load from
+that variable, creating an undesirable rf link from B to C:
+
+	A -&gt;data B -&gt;rf C -&gt;data D.
+
+This would cause carry-srcu-data to mistakenly extend a data
+dependency from A to D, giving the impression that D was the
+srcu-unlock event matching A's srcu-lock.  To avoid such problems,
+carry-srcu-data does not accept sequences in which the ends of any of
+the intermediate -&gt;data links (B above) is an srcu-unlock event.
 
 
 LOCKING</pre><hr><pre>commit 614e40faf5ae30113f94b00106ce690602f10fc2
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jan 25 15:21:42 2023 -0500

    tools/memory-model: Provide exact SRCU semantics
    
    LKMM has long provided only approximate handling of SRCU read-side
    critical sections.  This has not been a pressing problem because LKMM's
    traditional handling is correct for the common cases of non-overlapping
    and properly nested critical sections.  However, LKMM's traditional
    handling of partially overlapping critical sections incorrectly fuses
    them into one large critical section.
    
    For example, consider the following litmus test:
    
    ------------------------------------------------------------------------
    
    C C-srcu-nest-5
    
    (*
     * Result: Sometimes
     *
     * This demonstrates non-nested overlapping of SRCU read-side critical
     * sections.  Unlike RCU, SRCU critical sections do not unconditionally
     * nest.
     *)
    
    {}
    
    P0(int *x, int *y, struct srcu_struct *s1)
    {
            int r1;
            int r2;
            int r3;
            int r4;
    
            r3 = srcu_read_lock(s1);
            r2 = READ_ONCE(*y);
            r4 = srcu_read_lock(s1);
            srcu_read_unlock(s1, r3);
            r1 = READ_ONCE(*x);
            srcu_read_unlock(s1, r4);
    }
    
    P1(int *x, int *y, struct srcu_struct *s1)
    {
            WRITE_ONCE(*y, 1);
            synchronize_srcu(s1);
            WRITE_ONCE(*x, 1);
    }
    
    locations [0:r1]
    exists (0:r1=1 /\ 0:r2=0)
    
    ------------------------------------------------------------------------
    
    Current mainline incorrectly flattens the two critical sections into
    one larger critical section, giving "Never" instead of the correct
    "Sometimes":
    
    ------------------------------------------------------------------------
    
    $ herd7 -conf linux-kernel.cfg C-srcu-nest-5.litmus
    Test C-srcu-nest-5 Allowed
    States 3
    0:r1=0; 0:r2=0;
    0:r1=0; 0:r2=1;
    0:r1=1; 0:r2=1;
    No
    Witnesses
    Positive: 0 Negative: 3
    Flag srcu-bad-nesting
    Condition exists (0:r1=1 /\ 0:r2=0)
    Observation C-srcu-nest-5 Never 0 3
    Time C-srcu-nest-5 0.01
    Hash=e692c106cf3e84e20f12991dc438ff1b
    
    ------------------------------------------------------------------------
    
    To its credit, it does complain about bad nesting.  But with this
    commit we get the following result, which has the virtue of being
    correct:
    
    ------------------------------------------------------------------------
    
    $ herd7 -conf linux-kernel.cfg C-srcu-nest-5.litmus
    Test C-srcu-nest-5 Allowed
    States 4
    0:r1=0; 0:r2=0;
    0:r1=0; 0:r2=1;
    0:r1=1; 0:r2=0;
    0:r1=1; 0:r2=1;
    Ok
    Witnesses
    Positive: 1 Negative: 3
    Condition exists (0:r1=1 /\ 0:r2=0)
    Observation C-srcu-nest-5 Sometimes 1 3
    Time C-srcu-nest-5 0.05
    Hash=e692c106cf3e84e20f12991dc438ff1b
    
    ------------------------------------------------------------------------
    
    In addition, there are new srcu_down_read() and srcu_up_read()
    functions on their way to mainline.  Roughly speaking, these are to
    srcu_read_lock() and srcu_read_unlock() as down() and up() are to
    mutex_lock() and mutex_unlock().  The key point is that
    srcu_down_read() can execute in one process and the matching
    srcu_up_read() in another, as shown in this litmus test:
    
    ------------------------------------------------------------------------
    
    C C-srcu-nest-6
    
    (*
     * Result: Never
     *
     * This would be valid for srcu_down_read() and srcu_up_read().
     *)
    
    {}
    
    P0(int *x, int *y, struct srcu_struct *s1, int *idx, int *f)
    {
            int r2;
            int r3;
    
            r3 = srcu_down_read(s1);
            WRITE_ONCE(*idx, r3);
            r2 = READ_ONCE(*y);
            smp_store_release(f, 1);
    }
    
    P1(int *x, int *y, struct srcu_struct *s1, int *idx, int *f)
    {
            int r1;
            int r3;
            int r4;
    
            r4 = smp_load_acquire(f);
            r1 = READ_ONCE(*x);
            r3 = READ_ONCE(*idx);
            srcu_up_read(s1, r3);
    }
    
    P2(int *x, int *y, struct srcu_struct *s1)
    {
            WRITE_ONCE(*y, 1);
            synchronize_srcu(s1);
            WRITE_ONCE(*x, 1);
    }
    
    locations [0:r1]
    filter (1:r4=1)
    exists (1:r1=1 /\ 0:r2=0)
    
    ------------------------------------------------------------------------
    
    When run on current mainline, this litmus test gets a complaint about
    an unknown macro srcu_down_read().  With this commit:
    
    ------------------------------------------------------------------------
    
    herd7 -conf linux-kernel.cfg C-srcu-nest-6.litmus
    Test C-srcu-nest-6 Allowed
    States 3
    0:r1=0; 0:r2=0; 1:r1=0;
    0:r1=0; 0:r2=1; 1:r1=0;
    0:r1=0; 0:r2=1; 1:r1=1;
    No
    Witnesses
    Positive: 0 Negative: 3
    Condition exists (1:r1=1 /\ 0:r2=0)
    Observation C-srcu-nest-6 Never 0 3
    Time C-srcu-nest-6 0.02
    Hash=c1f20257d052ca5e899be508bedcb2a1
    
    ------------------------------------------------------------------------
    
    Note that the user must supply the flag "f" and the "filter" clause,
    similar to what must be done to emulate call_rcu().
    
    The commit works by treating srcu_read_lock()/srcu_down_read() as
    loads and srcu_read_unlock()/srcu_up_read() as stores.  This allows us
    to determine which unlock matches which lock by looking for a data
    dependency between them.  In order for this to work properly, the data
    dependencies have to be tracked through stores to intermediate
    variables such as "idx" in the litmus test above; this is handled by
    the new carry-srcu-data relation.  But it's important here (and in the
    existing carry-dep relation) to avoid tracking the dependencies
    through SRCU unlock stores.  Otherwise, in situations resembling:
    
            A: r1 = srcu_read_lock(s);
            B: srcu_read_unlock(s, r1);
            C: r2 = srcu_read_lock(s);
            D: srcu_read_unlock(s, r2);
    
    it would look as if D was dependent on both A and C, because "s" would
    appear to be an intermediate variable written by B and read by C.
    This explains the complications in the definitions of carry-srcu-dep
    and carry-dep.
    
    As a debugging aid, the commit adds a check for errors in which the
    value returned by one call to srcu_read_lock()/srcu_down_read() is
    passed to more than one instance of srcu_read_unlock()/srcu_up_read().
    
    Finally, since these SRCU-related primitives are now treated as
    ordinary reads and writes, we have to add them into the lists of
    marked accesses (i.e., not subject to data races) and lock-related
    accesses (i.e., one shouldn't try to access an srcu_struct with a
    non-lock-related primitive such as READ_ONCE() or a plain write).
    
    Portions of this approach were suggested by Boqun Feng and Jonas
    Oberhauser.
    
    [ paulmck: Fix space-before-tab whitespace nit. ]
    
    Reported-by: Paul E. McKenney &lt;paulmck@kernel.org&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reviewed-by: Jonas Oberhauser &lt;jonas.oberhauser@huaweicloud.com&gt;
    Signed-off-by: Paul E. McKenney &lt;paulmck@kernel.org&gt;

diff --git a/tools/memory-model/linux-kernel.bell b/tools/memory-model/linux-kernel.bell
index b92fdf7f6eeb..ce068700939c 100644
--- a/tools/memory-model/linux-kernel.bell
+++ b/tools/memory-model/linux-kernel.bell
@@ -58,20 +58,13 @@ flag ~empty Rcu-lock \ domain(rcu-rscs) as unmatched-rcu-lock
 flag ~empty Rcu-unlock \ range(rcu-rscs) as unmatched-rcu-unlock
 
 (* Compute matching pairs of nested Srcu-lock and Srcu-unlock *)
-let srcu-rscs = let rec
-	    unmatched-locks = Srcu-lock \ domain(matched)
-	and unmatched-unlocks = Srcu-unlock \ range(matched)
-	and unmatched = unmatched-locks | unmatched-unlocks
-	and unmatched-po = ([unmatched] ; po ; [unmatched]) &amp; loc
-	and unmatched-locks-to-unlocks =
-		([unmatched-locks] ; po ; [unmatched-unlocks]) &amp; loc
-	and matched = matched | (unmatched-locks-to-unlocks \
-		(unmatched-po ; unmatched-po))
-	in matched
+let carry-srcu-data = (data ; [~ Srcu-unlock] ; rf)*
+let srcu-rscs = ([Srcu-lock] ; carry-srcu-data ; data ; [Srcu-unlock]) &amp; loc
 
 (* Validate nesting *)
 flag ~empty Srcu-lock \ domain(srcu-rscs) as unmatched-srcu-lock
 flag ~empty Srcu-unlock \ range(srcu-rscs) as unmatched-srcu-unlock
+flag ~empty (srcu-rscs^-1 ; srcu-rscs) \ id as multiple-srcu-matches
 
 (* Check for use of synchronize_srcu() inside an RCU critical section *)
 flag ~empty rcu-rscs &amp; (po ; [Sync-srcu] ; po) as invalid-sleep
@@ -81,11 +74,11 @@ flag ~empty different-values(srcu-rscs) as srcu-bad-value-match
 
 (* Compute marked and plain memory accesses *)
 let Marked = (~M) | IW | Once | Release | Acquire | domain(rmw) | range(rmw) |
-		LKR | LKW | UL | LF | RL | RU
+		LKR | LKW | UL | LF | RL | RU | Srcu-lock | Srcu-unlock
 let Plain = M \ Marked
 
 (* Redefine dependencies to include those carried through plain accesses *)
-let carry-dep = (data ; rfi)*
+let carry-dep = (data ; [~ Srcu-unlock] ; rfi)*
 let addr = carry-dep ; addr
 let ctrl = carry-dep ; ctrl
 let data = carry-dep ; data
diff --git a/tools/memory-model/linux-kernel.def b/tools/memory-model/linux-kernel.def
index a6b6fbc9d0b2..88a39601f525 100644
--- a/tools/memory-model/linux-kernel.def
+++ b/tools/memory-model/linux-kernel.def
@@ -50,8 +50,10 @@ synchronize_rcu() { __fence{sync-rcu}; }
 synchronize_rcu_expedited() { __fence{sync-rcu}; }
 
 // SRCU
-srcu_read_lock(X)  __srcu{srcu-lock}(X)
-srcu_read_unlock(X,Y) { __srcu{srcu-unlock}(X,Y); }
+srcu_read_lock(X) __load{srcu-lock}(*X)
+srcu_read_unlock(X,Y) { __store{srcu-unlock}(*X,Y); }
+srcu_down_read(X) __load{srcu-lock}(*X)
+srcu_up_read(X,Y) { __store{srcu-unlock}(*X,Y); }
 synchronize_srcu(X)  { __srcu{sync-srcu}(X); }
 synchronize_srcu_expedited(X)  { __srcu{sync-srcu}(X); }
 
diff --git a/tools/memory-model/lock.cat b/tools/memory-model/lock.cat
index 6b52f365d73a..53b5a492739d 100644
--- a/tools/memory-model/lock.cat
+++ b/tools/memory-model/lock.cat
@@ -36,9 +36,9 @@ let RU = try RU with emptyset
 (* Treat RL as a kind of LF: a read with no ordering properties *)
 let LF = LF | RL
 
-(* There should be no ordinary R or W accesses to spinlocks *)
-let ALL-LOCKS = LKR | LKW | UL | LF | RU
-flag ~empty [M \ IW] ; loc ; [ALL-LOCKS] as mixed-lock-accesses
+(* There should be no ordinary R or W accesses to spinlocks or SRCU structs *)
+let ALL-LOCKS = LKR | LKW | UL | LF | RU | Srcu-lock | Srcu-unlock | Sync-srcu
+flag ~empty [M \ IW \ ALL-LOCKS] ; loc ; [ALL-LOCKS] as mixed-lock-accesses
 
 (* Link Lock-Reads to their RMW-partner Lock-Writes *)
 let lk-rmw = ([LKR] ; po-loc ; [LKW]) \ (po ; po)</pre><hr><pre>commit 627c9ad04f01221b4396f3df839c5dd994f327b4
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jan 25 15:20:51 2023 -0500

    tools/memory-model: Update some warning labels
    
    Some of the warning labels used in the LKMM are unfortunately
    ambiguous.  In particular, the same warning is used for both an
    unmatched rcu_read_lock() call and for an unmatched rcu_read_unlock()
    call.  Likewise for the srcu_* equivalents.  Also, the warning about
    passing a wrong value to srcu_read_unlock() -- i.e., a value different
    from the one returned by the matching srcu_read_lock() -- talks about
    bad nesting rather than non-matching values.
    
    Let's update the warning labels to make their meanings more clear.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reviewed-by: Jonas Oberhauser &lt;jonas.oberhauser@huaweicloud.com&gt;
    Acked-by: Andrea Parri &lt;parri.andrea@gmail.com&gt;
    Signed-off-by: Paul E. McKenney &lt;paulmck@kernel.org&gt;

diff --git a/tools/memory-model/linux-kernel.bell b/tools/memory-model/linux-kernel.bell
index 70a9073dec3e..dc464854d28a 100644
--- a/tools/memory-model/linux-kernel.bell
+++ b/tools/memory-model/linux-kernel.bell
@@ -53,8 +53,8 @@ let rcu-rscs = let rec
 	in matched
 
 (* Validate nesting *)
-flag ~empty Rcu-lock \ domain(rcu-rscs) as unbalanced-rcu-locking
-flag ~empty Rcu-unlock \ range(rcu-rscs) as unbalanced-rcu-locking
+flag ~empty Rcu-lock \ domain(rcu-rscs) as unmatched-rcu-lock
+flag ~empty Rcu-unlock \ range(rcu-rscs) as unmatched-rcu-unlock
 
 (* Compute matching pairs of nested Srcu-lock and Srcu-unlock *)
 let srcu-rscs = let rec
@@ -69,14 +69,14 @@ let srcu-rscs = let rec
 	in matched
 
 (* Validate nesting *)
-flag ~empty Srcu-lock \ domain(srcu-rscs) as unbalanced-srcu-locking
-flag ~empty Srcu-unlock \ range(srcu-rscs) as unbalanced-srcu-locking
+flag ~empty Srcu-lock \ domain(srcu-rscs) as unmatched-srcu-lock
+flag ~empty Srcu-unlock \ range(srcu-rscs) as unmatched-srcu-unlock
 
 (* Check for use of synchronize_srcu() inside an RCU critical section *)
 flag ~empty rcu-rscs &amp; (po ; [Sync-srcu] ; po) as invalid-sleep
 
 (* Validate SRCU dynamic match *)
-flag ~empty different-values(srcu-rscs) as srcu-bad-nesting
+flag ~empty different-values(srcu-rscs) as srcu-bad-value-match
 
 (* Compute marked and plain memory accesses *)
 let Marked = (~M) | IW | Once | Release | Acquire | domain(rmw) | range(rmw) |</pre><hr><pre>commit 93fd565919cf897adf7e1da81cace1a46e4db7f4
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Feb 3 14:32:09 2023 -0500

    net: USB: Fix wrong-direction WARNING in plusb.c
    
    The syzbot fuzzer detected a bug in the plusb network driver: A
    zero-length control-OUT transfer was treated as a read instead of a
    write.  In modern kernels this error provokes a WARNING:
    
    usb 1-1: BOGUS control dir, pipe 80000280 doesn't match bRequestType c0
    WARNING: CPU: 0 PID: 4645 at drivers/usb/core/urb.c:411
    usb_submit_urb+0x14a7/0x1880 drivers/usb/core/urb.c:411
    Modules linked in:
    CPU: 1 PID: 4645 Comm: dhcpcd Not tainted
    6.2.0-rc6-syzkaller-00050-g9f266ccaa2f5 #0
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google
    01/12/2023
    RIP: 0010:usb_submit_urb+0x14a7/0x1880 drivers/usb/core/urb.c:411
    ...
    Call Trace:
     &lt;TASK&gt;
     usb_start_wait_urb+0x101/0x4b0 drivers/usb/core/message.c:58
     usb_internal_control_msg drivers/usb/core/message.c:102 [inline]
     usb_control_msg+0x320/0x4a0 drivers/usb/core/message.c:153
     __usbnet_read_cmd+0xb9/0x390 drivers/net/usb/usbnet.c:2010
     usbnet_read_cmd+0x96/0xf0 drivers/net/usb/usbnet.c:2068
     pl_vendor_req drivers/net/usb/plusb.c:60 [inline]
     pl_set_QuickLink_features drivers/net/usb/plusb.c:75 [inline]
     pl_reset+0x2f/0xf0 drivers/net/usb/plusb.c:85
     usbnet_open+0xcc/0x5d0 drivers/net/usb/usbnet.c:889
     __dev_open+0x297/0x4d0 net/core/dev.c:1417
     __dev_change_flags+0x587/0x750 net/core/dev.c:8530
     dev_change_flags+0x97/0x170 net/core/dev.c:8602
     devinet_ioctl+0x15a2/0x1d70 net/ipv4/devinet.c:1147
     inet_ioctl+0x33f/0x380 net/ipv4/af_inet.c:979
     sock_do_ioctl+0xcc/0x230 net/socket.c:1169
     sock_ioctl+0x1f8/0x680 net/socket.c:1286
     vfs_ioctl fs/ioctl.c:51 [inline]
     __do_sys_ioctl fs/ioctl.c:870 [inline]
     __se_sys_ioctl fs/ioctl.c:856 [inline]
     __x64_sys_ioctl+0x197/0x210 fs/ioctl.c:856
     do_syscall_x64 arch/x86/entry/common.c:50 [inline]
     do_syscall_64+0x39/0xb0 arch/x86/entry/common.c:80
     entry_SYSCALL_64_after_hwframe+0x63/0xcd
    
    The fix is to call usbnet_write_cmd() instead of usbnet_read_cmd() and
    remove the USB_DIR_IN flag.
    
    Reported-and-tested-by: syzbot+2a0e7abd24f1eb90ce25@syzkaller.appspotmail.com
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Fixes: 090ffa9d0e90 ("[PATCH] USB: usbnet (9/9) module for pl2301/2302 cables")
    CC: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/00000000000052099f05f3b3e298@google.com/
    Link: https://lore.kernel.org/r/Y91hOew3nW56Ki4O@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/net/usb/plusb.c b/drivers/net/usb/plusb.c
index 2c82fbcaab22..7a2b0094de51 100644
--- a/drivers/net/usb/plusb.c
+++ b/drivers/net/usb/plusb.c
@@ -57,9 +57,7 @@
 static inline int
 pl_vendor_req(struct usbnet *dev, u8 req, u8 val, u8 index)
 {
-	return usbnet_read_cmd(dev, req,
-				USB_DIR_IN | USB_TYPE_VENDOR |
-				USB_RECIP_DEVICE,
+	return usbnet_write_cmd(dev, req, USB_TYPE_VENDOR | USB_RECIP_DEVICE,
 				val, index, NULL, 0);
 }
 </pre><hr><pre>commit 811d581194f7412eda97acc03d17fc77824b561f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Feb 3 14:32:09 2023 -0500

    net: USB: Fix wrong-direction WARNING in plusb.c
    
    The syzbot fuzzer detected a bug in the plusb network driver: A
    zero-length control-OUT transfer was treated as a read instead of a
    write.  In modern kernels this error provokes a WARNING:
    
    usb 1-1: BOGUS control dir, pipe 80000280 doesn't match bRequestType c0
    WARNING: CPU: 0 PID: 4645 at drivers/usb/core/urb.c:411
    usb_submit_urb+0x14a7/0x1880 drivers/usb/core/urb.c:411
    Modules linked in:
    CPU: 1 PID: 4645 Comm: dhcpcd Not tainted
    6.2.0-rc6-syzkaller-00050-g9f266ccaa2f5 #0
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google
    01/12/2023
    RIP: 0010:usb_submit_urb+0x14a7/0x1880 drivers/usb/core/urb.c:411
    ...
    Call Trace:
     &lt;TASK&gt;
     usb_start_wait_urb+0x101/0x4b0 drivers/usb/core/message.c:58
     usb_internal_control_msg drivers/usb/core/message.c:102 [inline]
     usb_control_msg+0x320/0x4a0 drivers/usb/core/message.c:153
     __usbnet_read_cmd+0xb9/0x390 drivers/net/usb/usbnet.c:2010
     usbnet_read_cmd+0x96/0xf0 drivers/net/usb/usbnet.c:2068
     pl_vendor_req drivers/net/usb/plusb.c:60 [inline]
     pl_set_QuickLink_features drivers/net/usb/plusb.c:75 [inline]
     pl_reset+0x2f/0xf0 drivers/net/usb/plusb.c:85
     usbnet_open+0xcc/0x5d0 drivers/net/usb/usbnet.c:889
     __dev_open+0x297/0x4d0 net/core/dev.c:1417
     __dev_change_flags+0x587/0x750 net/core/dev.c:8530
     dev_change_flags+0x97/0x170 net/core/dev.c:8602
     devinet_ioctl+0x15a2/0x1d70 net/ipv4/devinet.c:1147
     inet_ioctl+0x33f/0x380 net/ipv4/af_inet.c:979
     sock_do_ioctl+0xcc/0x230 net/socket.c:1169
     sock_ioctl+0x1f8/0x680 net/socket.c:1286
     vfs_ioctl fs/ioctl.c:51 [inline]
     __do_sys_ioctl fs/ioctl.c:870 [inline]
     __se_sys_ioctl fs/ioctl.c:856 [inline]
     __x64_sys_ioctl+0x197/0x210 fs/ioctl.c:856
     do_syscall_x64 arch/x86/entry/common.c:50 [inline]
     do_syscall_64+0x39/0xb0 arch/x86/entry/common.c:80
     entry_SYSCALL_64_after_hwframe+0x63/0xcd
    
    The fix is to call usbnet_write_cmd() instead of usbnet_read_cmd() and
    remove the USB_DIR_IN flag.
    
    Reported-and-tested-by: syzbot+2a0e7abd24f1eb90ce25@syzkaller.appspotmail.com
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Fixes: 090ffa9d0e90 ("[PATCH] USB: usbnet (9/9) module for pl2301/2302 cables")
    CC: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/00000000000052099f05f3b3e298@google.com/
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/drivers/net/usb/plusb.c b/drivers/net/usb/plusb.c
index 2c82fbcaab22..7a2b0094de51 100644
--- a/drivers/net/usb/plusb.c
+++ b/drivers/net/usb/plusb.c
@@ -57,9 +57,7 @@
 static inline int
 pl_vendor_req(struct usbnet *dev, u8 req, u8 val, u8 index)
 {
-	return usbnet_read_cmd(dev, req,
-				USB_DIR_IN | USB_TYPE_VENDOR |
-				USB_RECIP_DEVICE,
+	return usbnet_write_cmd(dev, req, USB_TYPE_VENDOR | USB_RECIP_DEVICE,
 				val, index, NULL, 0);
 }
 </pre><hr><pre>commit 45bf39f8df7f05efb83b302c65ae3b9bc92b7065
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jan 31 15:49:04 2023 -0500

    USB: core: Don't hold device lock while reading the "descriptors" sysfs file
    
    Ever since commit 83e83ecb79a8 ("usb: core: get config and string
    descriptors for unauthorized devices") was merged in 2013, there has
    been no mechanism for reallocating the rawdescriptors buffers in
    struct usb_device after the initial enumeration.  Before that commit,
    the buffers would be deallocated when a device was deauthorized and
    reallocated when it was authorized and enumerated.
    
    This means that the locking in the read_descriptors() routine is not
    needed, since the buffers it reads will never be reallocated while the
    routine is running.  This locking can interfere with user programs
    trying to read a hub's descriptors via sysfs while new child devices
    of the hub are being initialized, since the hub is locked during this
    procedure.
    
    Since the locking in read_descriptors() hasn't been needed for over
    nine years, we can remove it.
    
    Reported-and-tested-by: Troels Liebe Bentsen &lt;troels@connectedcars.dk&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/Y9l+wDTRbuZABzsE@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 9eca403af2a8..97a0f8faea6e 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2389,9 +2389,8 @@ static int usb_enumerate_device_otg(struct usb_device *udev)
  * usb_enumerate_device - Read device configs/intfs/otg (usbcore-internal)
  * @udev: newly addressed device (in ADDRESS state)
  *
- * This is only called by usb_new_device() and usb_authorize_device()
- * and FIXME -- all comments that apply to them apply here wrt to
- * environment.
+ * This is only called by usb_new_device() -- all comments that apply there
+ * apply here wrt to environment.
  *
  * If the device is WUSB and not authorized, we don't attempt to read
  * the string descriptors, as they will be errored out by the device
diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c
index 8217032dfb85..b63f78e48c74 100644
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -869,11 +869,7 @@ read_descriptors(struct file *filp, struct kobject *kobj,
 	size_t srclen, n;
 	int cfgno;
 	void *src;
-	int retval;
 
-	retval = usb_lock_device_interruptible(udev);
-	if (retval &lt; 0)
-		return -EINTR;
 	/* The binary attribute begins with the device descriptor.
 	 * Following that are the raw descriptor entries for all the
 	 * configurations (config plus subsidiary descriptors).
@@ -898,7 +894,6 @@ read_descriptors(struct file *filp, struct kobject *kobj,
 			off -= srclen;
 		}
 	}
-	usb_unlock_device(udev);
 	return count - nleft;
 }
 </pre><hr><pre>commit d18dcfe9860e842f394e37ba01ca9440ab2178f4
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Dec 23 09:59:09 2022 -0500

    USB: gadgetfs: Fix race between mounting and unmounting
    
    The syzbot fuzzer and Gerald Lee have identified a use-after-free bug
    in the gadgetfs driver, involving processes concurrently mounting and
    unmounting the gadgetfs filesystem.  In particular, gadgetfs_fill_super()
    can race with gadgetfs_kill_sb(), causing the latter to deallocate
    the_device while the former is using it.  The output from KASAN says,
    in part:
    
    BUG: KASAN: use-after-free in instrument_atomic_read_write include/linux/instrumented.h:102 [inline]
    BUG: KASAN: use-after-free in atomic_fetch_sub_release include/linux/atomic/atomic-instrumented.h:176 [inline]
    BUG: KASAN: use-after-free in __refcount_sub_and_test include/linux/refcount.h:272 [inline]
    BUG: KASAN: use-after-free in __refcount_dec_and_test include/linux/refcount.h:315 [inline]
    BUG: KASAN: use-after-free in refcount_dec_and_test include/linux/refcount.h:333 [inline]
    BUG: KASAN: use-after-free in put_dev drivers/usb/gadget/legacy/inode.c:159 [inline]
    BUG: KASAN: use-after-free in gadgetfs_kill_sb+0x33/0x100 drivers/usb/gadget/legacy/inode.c:2086
    Write of size 4 at addr ffff8880276d7840 by task syz-executor126/18689
    
    CPU: 0 PID: 18689 Comm: syz-executor126 Not tainted 6.1.0-syzkaller #0
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 10/26/2022
    Call Trace:
     &lt;TASK&gt;
    ...
     atomic_fetch_sub_release include/linux/atomic/atomic-instrumented.h:176 [inline]
     __refcount_sub_and_test include/linux/refcount.h:272 [inline]
     __refcount_dec_and_test include/linux/refcount.h:315 [inline]
     refcount_dec_and_test include/linux/refcount.h:333 [inline]
     put_dev drivers/usb/gadget/legacy/inode.c:159 [inline]
     gadgetfs_kill_sb+0x33/0x100 drivers/usb/gadget/legacy/inode.c:2086
     deactivate_locked_super+0xa7/0xf0 fs/super.c:332
     vfs_get_super fs/super.c:1190 [inline]
     get_tree_single+0xd0/0x160 fs/super.c:1207
     vfs_get_tree+0x88/0x270 fs/super.c:1531
     vfs_fsconfig_locked fs/fsopen.c:232 [inline]
    
    The simplest solution is to ensure that gadgetfs_fill_super() and
    gadgetfs_kill_sb() are serialized by making them both acquire a new
    mutex.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: syzbot+33d7ad66d65044b93f16@syzkaller.appspotmail.com
    Reported-and-tested-by: Gerald Lee &lt;sundaywind2004@gmail.com&gt;
    Link: https://lore.kernel.org/linux-usb/CAO3qeMVzXDP-JU6v1u5Ags6Q-bb35kg3=C6d04DjzA9ffa5x1g@mail.gmail.com/
    Fixes: e5d82a7360d1 ("vfs: Convert gadgetfs to use the new mount API")
    CC: &lt;stable@vger.kernel.org&gt;
    Link: https://lore.kernel.org/r/Y6XCPXBpn3tmjdCC@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/gadget/legacy/inode.c b/drivers/usb/gadget/legacy/inode.c
index 01c3ead7d1b4..d605bc2e7e8f 100644
--- a/drivers/usb/gadget/legacy/inode.c
+++ b/drivers/usb/gadget/legacy/inode.c
@@ -229,6 +229,7 @@ static void put_ep (struct ep_data *data)
  */
 
 static const char *CHIP;
+static DEFINE_MUTEX(sb_mutex);		/* Serialize superblock operations */
 
 /*----------------------------------------------------------------------*/
 
@@ -2010,13 +2011,20 @@ gadgetfs_fill_super (struct super_block *sb, struct fs_context *fc)
 {
 	struct inode	*inode;
 	struct dev_data	*dev;
+	int		rc;
 
-	if (the_device)
-		return -ESRCH;
+	mutex_lock(&amp;sb_mutex);
+
+	if (the_device) {
+		rc = -ESRCH;
+		goto Done;
+	}
 
 	CHIP = usb_get_gadget_udc_name();
-	if (!CHIP)
-		return -ENODEV;
+	if (!CHIP) {
+		rc = -ENODEV;
+		goto Done;
+	}
 
 	/* superblock */
 	sb-&gt;s_blocksize = PAGE_SIZE;
@@ -2053,13 +2061,17 @@ gadgetfs_fill_super (struct super_block *sb, struct fs_context *fc)
 	 * from binding to a controller.
 	 */
 	the_device = dev;
-	return 0;
+	rc = 0;
+	goto Done;
 
-Enomem:
+ Enomem:
 	kfree(CHIP);
 	CHIP = NULL;
+	rc = -ENOMEM;
 
-	return -ENOMEM;
+ Done:
+	mutex_unlock(&amp;sb_mutex);
+	return rc;
 }
 
 /* "mount -t gadgetfs path /dev/gadget" ends up here */
@@ -2081,6 +2093,7 @@ static int gadgetfs_init_fs_context(struct fs_context *fc)
 static void
 gadgetfs_kill_sb (struct super_block *sb)
 {
+	mutex_lock(&amp;sb_mutex);
 	kill_litter_super (sb);
 	if (the_device) {
 		put_dev (the_device);
@@ -2088,6 +2101,7 @@ gadgetfs_kill_sb (struct super_block *sb)
 	}
 	kfree(CHIP);
 	CHIP = NULL;
+	mutex_unlock(&amp;sb_mutex);
 }
 
 /*----------------------------------------------------------------------*/</pre><hr><pre>commit ebd50e2947de9d2675b800a6a29748d0ed7d7fd4
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Nov 16 15:48:01 2022 -0500

    tools: memory-model: Add rmw-sequences to the LKMM
    
    Viktor (as relayed by Jonas) has pointed out a weakness in the Linux
    Kernel Memory Model.  Namely, the memory ordering properties of atomic
    operations are not monotonic: An atomic op with full-barrier semantics
    does not always provide ordering as strong as one with release-barrier
    semantics.
    
    The following litmus test illustrates the problem:
    
    --------------------------------------------------
    C atomics-not-monotonic
    
    {}
    
    P0(int *x, atomic_t *y)
    {
            WRITE_ONCE(*x, 1);
            smp_wmb();
            atomic_set(y, 1);
    }
    
    P1(atomic_t *y)
    {
            int r1;
    
            r1 = atomic_inc_return(y);
    }
    
    P2(int *x, atomic_t *y)
    {
            int r2;
            int r3;
    
            r2 = atomic_read(y);
            smp_rmb();
            r3 = READ_ONCE(*x);
    }
    
    exists (2:r2=2 /\ 2:r3=0)
    --------------------------------------------------
    
    The litmus test is allowed as shown with atomic_inc_return(), which
    has full-barrier semantics.  But if the operation is changed to
    atomic_inc_return_release(), which only has release-barrier semantics,
    the litmus test is forbidden.  Clearly this violates monotonicity.
    
    The reason is because the LKMM treats full-barrier atomic ops as if
    they were written:
    
            mb();
            load();
            store();
            mb();
    
    (where the load() and store() are the two parts of an atomic RMW op),
    whereas it treats release-barrier atomic ops as if they were written:
    
            load();
            release_barrier();
            store();
    
    The difference is that here the release barrier orders the load part
    of the atomic op before the store part with A-cumulativity, whereas
    the mb()'s above do not.  This means that release-barrier atomics can
    effectively extend the cumul-fence relation but full-barrier atomics
    cannot.
    
    To resolve this problem we introduce the rmw-sequence relation,
    representing an arbitrarily long sequence of atomic RMW operations in
    which each operation reads from the previous one, and explicitly allow
    it to extend cumul-fence.  This modification of the memory model is
    sound; it holds for PPC because of B-cumulativity, it holds for TSO
    and ARM64 because of other-multicopy atomicity, and we can assume that
    atomic ops on all other architectures will be implemented so as to
    make it hold for them.
    
    For similar reasons we also allow rmw-sequence to extend the
    w-post-bounded relation, which is analogous to cumul-fence in some
    ways.
    
    Reported-by: Viktor Vafeiadis &lt;viktor@mpi-sws.org&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reviewed-by: Jonas Oberhauser &lt;jonas.oberhauser@huawei.com&gt;
    Signed-off-by: Paul E. McKenney &lt;paulmck@kernel.org&gt;

diff --git a/tools/memory-model/Documentation/explanation.txt b/tools/memory-model/Documentation/explanation.txt
index 11a1d2d4f681..e901b47236c3 100644
--- a/tools/memory-model/Documentation/explanation.txt
+++ b/tools/memory-model/Documentation/explanation.txt
@@ -1007,6 +1007,36 @@ order.  Equivalently,
 where the rmw relation links the read and write events making up each
 atomic update.  This is what the LKMM's "atomic" axiom says.
 
+Atomic rmw updates play one more role in the LKMM: They can form "rmw
+sequences".  An rmw sequence is simply a bunch of atomic updates where
+each update reads from the previous one.  Written using events, it
+looks like this:
+
+	Z0 -&gt;rf Y1 -&gt;rmw Z1 -&gt;rf ... -&gt;rf Yn -&gt;rmw Zn,
+
+where Z0 is some store event and n can be any number (even 0, in the
+degenerate case).  We write this relation as: Z0 -&gt;rmw-sequence Zn.
+Note that this implies Z0 and Zn are stores to the same variable.
+
+Rmw sequences have a special property in the LKMM: They can extend the
+cumul-fence relation.  That is, if we have:
+
+	U -&gt;cumul-fence X -&gt; rmw-sequence Y
+
+then also U -&gt;cumul-fence Y.  Thinking about this in terms of the
+operational model, U -&gt;cumul-fence X says that the store U propagates
+to each CPU before the store X does.  Then the fact that X and Y are
+linked by an rmw sequence means that U also propagates to each CPU
+before Y does.  In an analogous way, rmw sequences can also extend
+the w-post-bounded relation defined below in the PLAIN ACCESSES AND
+DATA RACES section.
+
+(The notion of rmw sequences in the LKMM is similar to, but not quite
+the same as, that of release sequences in the C11 memory model.  They
+were added to the LKMM to fix an obscure bug; without them, atomic
+updates with full-barrier semantics did not always guarantee ordering
+at least as strong as atomic updates with release-barrier semantics.)
+
 
 THE PRESERVED PROGRAM ORDER RELATION: ppo
 -----------------------------------------
diff --git a/tools/memory-model/linux-kernel.cat b/tools/memory-model/linux-kernel.cat
index d70315fddef6..07f884f9b2bf 100644
--- a/tools/memory-model/linux-kernel.cat
+++ b/tools/memory-model/linux-kernel.cat
@@ -74,8 +74,9 @@ let ppo = to-r | to-w | fence | (po-unlock-lock-po &amp; int)
 
 (* Propagation: Ordering from release operations and strong fences. *)
 let A-cumul(r) = (rfe ; [Marked])? ; r
+let rmw-sequence = (rf ; rmw)*
 let cumul-fence = [Marked] ; (A-cumul(strong-fence | po-rel) | wmb |
-	po-unlock-lock-po) ; [Marked]
+	po-unlock-lock-po) ; [Marked] ; rmw-sequence
 let prop = [Marked] ; (overwrite &amp; ext)? ; cumul-fence* ;
 	[Marked] ; rfe? ; [Marked]
 
@@ -174,7 +175,7 @@ let vis = cumul-fence* ; rfe? ; [Marked] ;
 let w-pre-bounded = [Marked] ; (addr | fence)?
 let r-pre-bounded = [Marked] ; (addr | nonrw-fence |
 	([R4rmb] ; fencerel(Rmb) ; [~Noreturn]))?
-let w-post-bounded = fence? ; [Marked]
+let w-post-bounded = fence? ; [Marked] ; rmw-sequence
 let r-post-bounded = (nonrw-fence | ([~Noreturn] ; fencerel(Rmb) ; [R4rmb]))? ;
 	[Marked]
 </pre>
    <div class="pagination">
        <a href='2_2.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><span>[3]</span><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_4.html'>Next&gt;&gt;</a>
    <div>
</body>
