<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_90.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><span>[91]</span><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_92.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 4330354f7660828d97834598633054b413f6264d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Apr 28 11:07:31 2008 -0400

    USB: combine hub_quiesce and hub_stop
    
    This patch (as1083) combines hub_quiesce() and hub_stop() into a
    single routine.  There's no point keeping them separate since they are
    usually called together.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 4c629a036aed..e678ed8bd8c2 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -538,19 +538,6 @@ static void hub_power_on(struct usb_hub *hub)
 	msleep(max(pgood_delay, (unsigned) 100));
 }
 
-static void hub_quiesce(struct usb_hub *hub)
-{
-	/* (nonblocking) khubd and related activity won't re-trigger */
-	hub-&gt;quiescing = 1;
-
-	/* (blocking) stop khubd and related activity */
-	usb_kill_urb(hub-&gt;urb);
-	if (hub-&gt;has_indicators)
-		cancel_delayed_work_sync(&amp;hub-&gt;leds);
-	if (hub-&gt;tt.hub)
-		cancel_work_sync(&amp;hub-&gt;tt.kevent);
-}
-
 static int hub_hub_status(struct usb_hub *hub,
 		u16 *status, u16 *change)
 {
@@ -609,20 +596,6 @@ static void hub_port_logical_disconnect(struct usb_hub *hub, int port1)
  	kick_khubd(hub);
 }
 
-/* caller has locked the hub device */
-static void hub_stop(struct usb_hub *hub)
-{
-	struct usb_device *hdev = hub-&gt;hdev;
-	int i;
-
-	/* Disconnect all the children */
-	for (i = 0; i &lt; hdev-&gt;maxchild; ++i) {
-		if (hdev-&gt;children[i])
-			usb_disconnect(&amp;hdev-&gt;children[i]);
-	}
-	hub_quiesce(hub);
-}
-
 enum hub_activation_type {
 	HUB_INIT, HUB_POST_RESET, HUB_RESUME, HUB_RESET_RESUME
 };
@@ -732,12 +705,40 @@ static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)
 	kick_khubd(hub);
 }
 
+enum hub_quiescing_type {
+	HUB_DISCONNECT, HUB_PRE_RESET, HUB_SUSPEND
+};
+
+static void hub_quiesce(struct usb_hub *hub, enum hub_quiescing_type type)
+{
+	struct usb_device *hdev = hub-&gt;hdev;
+	int i;
+
+	/* khubd and related activity won't re-trigger */
+	hub-&gt;quiescing = 1;
+
+	if (type != HUB_SUSPEND) {
+		/* Disconnect all the children */
+		for (i = 0; i &lt; hdev-&gt;maxchild; ++i) {
+			if (hdev-&gt;children[i])
+				usb_disconnect(&amp;hdev-&gt;children[i]);
+		}
+	}
+
+	/* Stop khubd and related activity */
+	usb_kill_urb(hub-&gt;urb);
+	if (hub-&gt;has_indicators)
+		cancel_delayed_work_sync(&amp;hub-&gt;leds);
+	if (hub-&gt;tt.hub)
+		cancel_work_sync(&amp;hub-&gt;tt.kevent);
+}
+
 /* caller has locked the hub device */
 static int hub_pre_reset(struct usb_interface *intf)
 {
 	struct usb_hub *hub = usb_get_intfdata(intf);
 
-	hub_stop(hub);
+	hub_quiesce(hub, HUB_PRE_RESET);
 	return 0;
 }
 
@@ -1024,7 +1025,7 @@ static void hub_disconnect(struct usb_interface *intf)
 
 	/* Disconnect all children and quiesce the hub */
 	hub-&gt;error = 0;
-	hub_stop(hub);
+	hub_quiesce(hub, HUB_DISCONNECT);
 
 	usb_set_intfdata (intf, NULL);
 
@@ -2167,7 +2168,7 @@ static int hub_suspend(struct usb_interface *intf, pm_message_t msg)
 	dev_dbg(&amp;intf-&gt;dev, "%s\n", __func__);
 
 	/* stop khubd and related activity */
-	hub_quiesce(hub);
+	hub_quiesce(hub, HUB_SUSPEND);
 	return 0;
 }
 
@@ -2914,7 +2915,7 @@ static void hub_events(void)
 		/* If the hub has died, clean up after it */
 		if (hdev-&gt;state == USB_STATE_NOTATTACHED) {
 			hub-&gt;error = -ENODEV;
-			hub_stop(hub);
+			hub_quiesce(hub, HUB_DISCONNECT);
 			goto loop;
 		}
 </pre><hr><pre>commit f2835219ed5e29ec959a0e635af4339d6174b2a7
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Apr 28 11:07:17 2008 -0400

    USB: combine hub_activate and hub_restart
    
    This patch (as1071) combines hub_activate() and hub_restart() into a
    single routine.  There's no point keeping them separate, since they
    are always called together.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index bc80168957b8..4c629a036aed 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -551,22 +551,6 @@ static void hub_quiesce(struct usb_hub *hub)
 		cancel_work_sync(&amp;hub-&gt;tt.kevent);
 }
 
-static void hub_activate(struct usb_hub *hub)
-{
-	int	status;
-
-	hub-&gt;quiescing = 0;
-
-	status = usb_submit_urb(hub-&gt;urb, GFP_NOIO);
-	if (status &lt; 0)
-		dev_err(hub-&gt;intfdev, "activate --&gt; %d\n", status);
-	if (hub-&gt;has_indicators &amp;&amp; blinkenlights)
-		schedule_delayed_work(&amp;hub-&gt;leds, LED_CYCLE_PERIOD);
-
-	/* scan all ports ASAP */
-	kick_khubd(hub);
-}
-
 static int hub_hub_status(struct usb_hub *hub,
 		u16 *status, u16 *change)
 {
@@ -643,18 +627,24 @@ enum hub_activation_type {
 	HUB_INIT, HUB_POST_RESET, HUB_RESUME, HUB_RESET_RESUME
 };
 
-static void hub_restart(struct usb_hub *hub, enum hub_activation_type type)
+static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)
 {
 	struct usb_device *hdev = hub-&gt;hdev;
 	int port1;
+	int status;
 	bool need_debounce_delay = false;
 
+	/* After a resume, port power should still be on.
+	 * For any other type of activation, turn it on.
+	 */
+	if (type != HUB_RESUME)
+		hub_power_on(hub);
+
 	/* Check each port and set hub-&gt;change_bits to let khubd know
 	 * which ports need attention.
 	 */
 	for (port1 = 1; port1 &lt;= hdev-&gt;maxchild; ++port1) {
 		struct usb_device *udev = hdev-&gt;children[port1-1];
-		int status;
 		u16 portstatus, portchange;
 
 		portstatus = portchange = 0;
@@ -729,7 +719,17 @@ static void hub_restart(struct usb_hub *hub, enum hub_activation_type type)
 	 */
 	if (need_debounce_delay)
 		msleep(HUB_DEBOUNCE_STABLE);
-	hub_activate(hub);
+
+	hub-&gt;quiescing = 0;
+
+	status = usb_submit_urb(hub-&gt;urb, GFP_NOIO);
+	if (status &lt; 0)
+		dev_err(hub-&gt;intfdev, "activate --&gt; %d\n", status);
+	if (hub-&gt;has_indicators &amp;&amp; blinkenlights)
+		schedule_delayed_work(&amp;hub-&gt;leds, LED_CYCLE_PERIOD);
+
+	/* Scan all ports that need attention */
+	kick_khubd(hub);
 }
 
 /* caller has locked the hub device */
@@ -746,8 +746,7 @@ static int hub_post_reset(struct usb_interface *intf)
 {
 	struct usb_hub *hub = usb_get_intfdata(intf);
 
-	hub_power_on(hub);
-	hub_restart(hub, HUB_POST_RESET);
+	hub_activate(hub, HUB_POST_RESET);
 	return 0;
 }
 
@@ -993,8 +992,7 @@ static int hub_configure(struct usb_hub *hub,
 	if (hub-&gt;has_indicators &amp;&amp; blinkenlights)
 		hub-&gt;indicator [0] = INDICATOR_CYCLE;
 
-	hub_power_on(hub);
-	hub_activate(hub);
+	hub_activate(hub, HUB_INIT);
 	return 0;
 
 fail:
@@ -2178,7 +2176,7 @@ static int hub_resume(struct usb_interface *intf)
 	struct usb_hub *hub = usb_get_intfdata(intf);
 
 	dev_dbg(&amp;intf-&gt;dev, "%s\n", __func__);
-	hub_restart(hub, HUB_RESUME);
+	hub_activate(hub, HUB_RESUME);
 	return 0;
 }
 
@@ -2187,8 +2185,7 @@ static int hub_reset_resume(struct usb_interface *intf)
 	struct usb_hub *hub = usb_get_intfdata(intf);
 
 	dev_dbg(&amp;intf-&gt;dev, "%s\n", __func__);
-	hub_power_on(hub);
-	hub_restart(hub, HUB_RESET_RESUME);
+	hub_activate(hub, HUB_RESET_RESUME);
 	return 0;
 }
 </pre><hr><pre>commit 948fea37dcebfef8f0f2faf00930e7ec7e756e07
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Apr 28 11:07:07 2008 -0400

    USB: optimize port debouncing during hub activation
    
    This patch (as1082) makes a small optimization to the way the hub
    driver carries out port debouncing immediately after a hub is
    activated (i.e., initialized, reset, or resumed).  If any port-change
    statuses are observed, the code will delay for a minimal debounce
    period -- thereby making a good start at debouncing all the ports at
    once.
    
    If this wasn't sufficient then khubd will debounce any port that still
    requires attention.  But in most cases it should suffice; it's rare
    for a device to need more than a minimal debounce delay.  (In the
    cases of hub initialization or reset even that is most likely not
    needed, since any devices plugged in at such times have probably been
    attached for a while.)
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 8ea095e59099..bc80168957b8 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -130,6 +130,10 @@ MODULE_PARM_DESC(use_both_schemes,
 DECLARE_RWSEM(ehci_cf_port_reset_rwsem);
 EXPORT_SYMBOL_GPL(ehci_cf_port_reset_rwsem);
 
+#define HUB_DEBOUNCE_TIMEOUT	1500
+#define HUB_DEBOUNCE_STEP	  25
+#define HUB_DEBOUNCE_STABLE	 100
+
 
 static inline char *portspeed(int portstatus)
 {
@@ -643,6 +647,7 @@ static void hub_restart(struct usb_hub *hub, enum hub_activation_type type)
 {
 	struct usb_device *hdev = hub-&gt;hdev;
 	int port1;
+	bool need_debounce_delay = false;
 
 	/* Check each port and set hub-&gt;change_bits to let khubd know
 	 * which ports need attention.
@@ -673,6 +678,18 @@ static void hub_restart(struct usb_hub *hub, enum hub_activation_type type)
 			portstatus &amp;= ~USB_PORT_STAT_ENABLE;
 		}
 
+		/* Clear status-change flags; we'll debounce later */
+		if (portchange &amp; USB_PORT_STAT_C_CONNECTION) {
+			need_debounce_delay = true;
+			clear_port_feature(hub-&gt;hdev, port1,
+					USB_PORT_FEAT_C_CONNECTION);
+		}
+		if (portchange &amp; USB_PORT_STAT_C_ENABLE) {
+			need_debounce_delay = true;
+			clear_port_feature(hub-&gt;hdev, port1,
+					USB_PORT_FEAT_C_ENABLE);
+		}
+
 		if (!udev || udev-&gt;state == USB_STATE_NOTATTACHED) {
 			/* Tell khubd to disconnect the device or
 			 * check for a new connection
@@ -702,6 +719,16 @@ static void hub_restart(struct usb_hub *hub, enum hub_activation_type type)
 		}
 	}
 
+	/* If no port-status-change flags were set, we don't need any
+	 * debouncing.  If flags were set we can try to debounce the
+	 * ports all at once right now, instead of letting khubd do them
+	 * one at a time later on.
+	 *
+	 * If any port-status changes do occur during this delay, khubd
+	 * will see them later and handle them normally.
+	 */
+	if (need_debounce_delay)
+		msleep(HUB_DEBOUNCE_STABLE);
 	hub_activate(hub);
 }
 
@@ -2211,11 +2238,6 @@ static inline int remote_wakeup(struct usb_device *udev)
  * every 25ms for transient disconnects.  When the port status has been
  * unchanged for 100ms it returns the port status.
  */
-
-#define HUB_DEBOUNCE_TIMEOUT	1500
-#define HUB_DEBOUNCE_STEP	  25
-#define HUB_DEBOUNCE_STABLE	 100
-
 static int hub_port_debounce(struct usb_hub *hub, int port1)
 {
 	int ret;</pre><hr><pre>commit 8808f00c7adfc8dc0b797c34ec03490b237fce4e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Apr 28 11:06:55 2008 -0400

    USB: try to salvage lost power sessions
    
    This patch (as1073) adds to khubd a way to recover from power-session
    interruption caused by transient connect-change or enable-change
    events.  After the debouncing period, khubd attempts to do a
    USB-Persist-style reset or reset-resume.  If it works, the connection
    will remain unscathed.
    
    The upshot is that we will be more immune to noise caused by EMI.  The
    grace period is on the order of 100 ms, so this won't permit recovery
    from the "accidentally knocked the USB cable out of its socket" type
    of event, but it's a start.
    
    As an added bonus, if a device was suspended when the system goes to
    sleep then we no longer need to check for power-session interruptions
    when the system wakes up.  Khubd will naturally see the status change
    while processing the device's parent hub and will do the right thing.
    
    The remote_wakeup() routine is changed; now it expects the caller to
    acquire the device lock rather than acquiring the lock itself.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index bf1585b203ca..0a0e8cea0afc 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -1537,14 +1537,11 @@ static int usb_resume(struct device *dev)
 	udev = to_usb_device(dev);
 
 	/* If udev-&gt;skip_sys_resume is set then udev was already suspended
-	 * when the system suspend started, so we don't want to resume
-	 * udev during this system wakeup.  However a reset-resume counts
-	 * as a wakeup event, so allow a reset-resume to occur if remote
-	 * wakeup is enabled. */
-	if (udev-&gt;skip_sys_resume) {
-		if (!(udev-&gt;reset_resume &amp;&amp; udev-&gt;do_remote_wakeup))
-			return -EHOSTUNREACH;
-	}
+	 * when the system sleep started, so we don't want to resume it
+	 * during this system wakeup.
+	 */
+	if (udev-&gt;skip_sys_resume)
+		return 0;
 	return usb_external_resume_device(udev);
 }
 
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 054a76dc5d5b..8ea095e59099 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -690,18 +690,11 @@ static void hub_restart(struct usb_hub *hub, enum hub_activation_type type)
 				set_bit(port1, hub-&gt;change_bits);
 
 		} else if (udev-&gt;persist_enabled) {
-			/* Turn off the status changes to prevent khubd
-			 * from disconnecting the device.
-			 */
-			if (portchange &amp; USB_PORT_STAT_C_ENABLE)
-				clear_port_feature(hub-&gt;hdev, port1,
-						USB_PORT_FEAT_C_ENABLE);
-			if (portchange &amp; USB_PORT_STAT_C_CONNECTION)
-				clear_port_feature(hub-&gt;hdev, port1,
-						USB_PORT_FEAT_C_CONNECTION);
 #ifdef CONFIG_PM
 			udev-&gt;reset_resume = 1;
 #endif
+			set_bit(port1, hub-&gt;change_bits);
+
 		} else {
 			/* The power session is gone; tell khubd */
 			usb_set_device_state(udev, USB_STATE_NOTATTACHED);
@@ -2075,17 +2068,16 @@ int usb_port_resume(struct usb_device *udev)
 	return status;
 }
 
+/* caller has locked udev */
 static int remote_wakeup(struct usb_device *udev)
 {
 	int	status = 0;
 
-	usb_lock_device(udev);
 	if (udev-&gt;state == USB_STATE_SUSPENDED) {
 		dev_dbg(&amp;udev-&gt;dev, "usb %sresume\n", "wakeup-");
 		usb_mark_last_busy(udev);
 		status = usb_external_resume_device(udev);
 	}
-	usb_unlock_device(udev);
 	return status;
 }
 
@@ -2632,6 +2624,7 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 	struct usb_hcd *hcd = bus_to_hcd(hdev-&gt;bus);
 	unsigned wHubCharacteristics =
 			le16_to_cpu(hub-&gt;descriptor-&gt;wHubCharacteristics);
+	struct usb_device *udev;
 	int status, i;
 
 	dev_dbg (hub_dev,
@@ -2666,8 +2659,45 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 		}
 	}
 
+	/* Try to resuscitate an existing device */
+	udev = hdev-&gt;children[port1-1];
+	if ((portstatus &amp; USB_PORT_STAT_CONNECTION) &amp;&amp; udev &amp;&amp;
+			udev-&gt;state != USB_STATE_NOTATTACHED) {
+
+		usb_lock_device(udev);
+		if (portstatus &amp; USB_PORT_STAT_ENABLE) {
+			status = 0;		/* Nothing to do */
+		} else if (!udev-&gt;persist_enabled) {
+			status = -ENODEV;	/* Mustn't resuscitate */
+
+#ifdef CONFIG_USB_SUSPEND
+		} else if (udev-&gt;state == USB_STATE_SUSPENDED) {
+			/* For a suspended device, treat this as a
+			 * remote wakeup event.
+			 */
+			if (udev-&gt;do_remote_wakeup)
+				status = remote_wakeup(udev);
+
+			/* Otherwise leave it be; devices can't tell the
+			 * difference between suspended and disabled.
+			 */
+			else
+				status = 0;
+#endif
+
+		} else {
+			status = usb_reset_composite_device(udev, NULL);
+		}
+		usb_unlock_device(udev);
+
+		if (status == 0) {
+			clear_bit(port1, hub-&gt;change_bits);
+			return;
+		}
+	}
+
 	/* Disconnect any existing devices under this port */
-	if (hdev-&gt;children[port1-1])
+	if (udev)
 		usb_disconnect(&amp;hdev-&gt;children[port1-1]);
 	clear_bit(port1, hub-&gt;change_bits);
 
@@ -2685,7 +2715,6 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 	}
 
 	for (i = 0; i &lt; SET_CONFIG_TRIES; i++) {
-		struct usb_device *udev;
 
 		/* reallocate for each attempt, since references
 		 * to the previous one can escape in various ways
@@ -2944,11 +2973,16 @@ static void hub_events(void)
 			}
 
 			if (portchange &amp; USB_PORT_STAT_C_SUSPEND) {
+				struct usb_device *udev;
+
 				clear_port_feature(hdev, i,
 					USB_PORT_FEAT_C_SUSPEND);
-				if (hdev-&gt;children[i-1]) {
+				udev = hdev-&gt;children[i-1];
+				if (udev) {
+					usb_lock_device(udev);
 					ret = remote_wakeup(hdev-&gt;
 							children[i-1]);
+					usb_unlock_device(udev);
 					if (ret &lt; 0)
 						connect_change = 1;
 				} else {</pre><hr><pre>commit 6ee0b270c733027b2b716b1c80b9aced41e08d20
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Apr 28 11:06:42 2008 -0400

    USB: simplify hub_restart() logic
    
    This patch (as1081) straightens out the logic of the hub_restart()
    routine.  Each port of the hub is scanned and the driver makes sure
    that ports which are supposed to be disabled really _are_ disabled.
    Any ports with a significant change in status are flagged in
    hub-&gt;change_bits, so that khubd can focus on them without the need to
    scan all the ports a second time -- which means the hub-&gt;activating
    flag is no longer needed.
    
    Also, it is now recognized explicitly that the only reason for
    resuming a port which was not suspended is to carry out a reset-resume
    operation, which happens only in a non-CONFIG_USB_SUSPEND setting.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index d0b37d776afe..bf1585b203ca 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -805,8 +805,6 @@ static int usb_resume_device(struct usb_device *udev)
 
 	if (udev-&gt;state == USB_STATE_NOTATTACHED)
 		goto done;
-	if (udev-&gt;state != USB_STATE_SUSPENDED &amp;&amp; !udev-&gt;reset_resume)
-		goto done;
 
 	/* Can't resume it if it doesn't have a driver. */
 	if (udev-&gt;dev.driver == NULL) {
@@ -1173,11 +1171,8 @@ static int usb_resume_both(struct usb_device *udev)
 			 * then we're stuck. */
 			status = usb_resume_device(udev);
 		}
-	} else {
-
-		/* Needed for reset-resume */
+	} else if (udev-&gt;reset_resume)
 		status = usb_resume_device(udev);
-	}
 
 	if (status == 0 &amp;&amp; udev-&gt;actconfig) {
 		for (i = 0; i &lt; udev-&gt;actconfig-&gt;desc.bNumInterfaces; i++) {
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 976da1c4919b..054a76dc5d5b 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -72,7 +72,6 @@ struct usb_hub {
 
 	unsigned		limited_power:1;
 	unsigned		quiescing:1;
-	unsigned		activating:1;
 	unsigned		disconnected:1;
 
 	unsigned		has_indicators:1;
@@ -539,7 +538,6 @@ static void hub_quiesce(struct usb_hub *hub)
 {
 	/* (nonblocking) khubd and related activity won't re-trigger */
 	hub-&gt;quiescing = 1;
-	hub-&gt;activating = 0;
 
 	/* (blocking) stop khubd and related activity */
 	usb_kill_urb(hub-&gt;urb);
@@ -554,7 +552,6 @@ static void hub_activate(struct usb_hub *hub)
 	int	status;
 
 	hub-&gt;quiescing = 0;
-	hub-&gt;activating = 1;
 
 	status = usb_submit_urb(hub-&gt;urb, GFP_NOIO);
 	if (status &lt; 0)
@@ -638,81 +635,83 @@ static void hub_stop(struct usb_hub *hub)
 	hub_quiesce(hub);
 }
 
-#define HUB_RESET		1
-#define HUB_RESUME		2
-#define HUB_RESET_RESUME	3
-
-#ifdef CONFIG_PM
+enum hub_activation_type {
+	HUB_INIT, HUB_POST_RESET, HUB_RESUME, HUB_RESET_RESUME
+};
 
-static void hub_restart(struct usb_hub *hub, int type)
+static void hub_restart(struct usb_hub *hub, enum hub_activation_type type)
 {
 	struct usb_device *hdev = hub-&gt;hdev;
 	int port1;
 
-	/* Check each of the children to see if they require
-	 * USB-PERSIST handling or disconnection.  Also check
-	 * each unoccupied port to make sure it is still disabled.
+	/* Check each port and set hub-&gt;change_bits to let khubd know
+	 * which ports need attention.
 	 */
 	for (port1 = 1; port1 &lt;= hdev-&gt;maxchild; ++port1) {
 		struct usb_device *udev = hdev-&gt;children[port1-1];
-		int status = 0;
+		int status;
 		u16 portstatus, portchange;
 
-		if (!udev || udev-&gt;state == USB_STATE_NOTATTACHED) {
-			if (type != HUB_RESET) {
-				status = hub_port_status(hub, port1,
-						&amp;portstatus, &amp;portchange);
-				if (status == 0 &amp;&amp; (portstatus &amp;
-						USB_PORT_STAT_ENABLE))
-					clear_port_feature(hdev, port1,
-							USB_PORT_FEAT_ENABLE);
-			}
-			continue;
+		portstatus = portchange = 0;
+		status = hub_port_status(hub, port1, &amp;portstatus, &amp;portchange);
+		if (udev || (portstatus &amp; USB_PORT_STAT_CONNECTION))
+			dev_dbg(hub-&gt;intfdev,
+					"port %d: status %04x change %04x\n",
+					port1, portstatus, portchange);
+
+		/* After anything other than HUB_RESUME (i.e., initialization
+		 * or any sort of reset), every port should be disabled.
+		 * Unconnected ports should likewise be disabled (paranoia),
+		 * and so should ports for which we have no usb_device.
+		 */
+		if ((portstatus &amp; USB_PORT_STAT_ENABLE) &amp;&amp; (
+				type != HUB_RESUME ||
+				!(portstatus &amp; USB_PORT_STAT_CONNECTION) ||
+				!udev ||
+				udev-&gt;state == USB_STATE_NOTATTACHED)) {
+			clear_port_feature(hdev, port1, USB_PORT_FEAT_ENABLE);
+			portstatus &amp;= ~USB_PORT_STAT_ENABLE;
 		}
 
-		/* Was the power session lost while we were suspended? */
-		switch (type) {
-		case HUB_RESET_RESUME:
-			portstatus = 0;
-			portchange = USB_PORT_STAT_C_CONNECTION;
-			break;
-
-		case HUB_RESET:
-		case HUB_RESUME:
-			status = hub_port_status(hub, port1,
-					&amp;portstatus, &amp;portchange);
-			break;
-		}
+		if (!udev || udev-&gt;state == USB_STATE_NOTATTACHED) {
+			/* Tell khubd to disconnect the device or
+			 * check for a new connection
+			 */
+			if (udev || (portstatus &amp; USB_PORT_STAT_CONNECTION))
+				set_bit(port1, hub-&gt;change_bits);
+
+		} else if (portstatus &amp; USB_PORT_STAT_ENABLE) {
+			/* The power session apparently survived the resume.
+			 * If there was an overcurrent or suspend change
+			 * (i.e., remote wakeup request), have khubd
+			 * take care of it.
+			 */
+			if (portchange)
+				set_bit(port1, hub-&gt;change_bits);
 
-		/* For "USB_PERSIST"-enabled children we must
-		 * mark the child device for reset-resume and
-		 * turn off the various status changes to prevent
-		 * khubd from disconnecting it later.
-		 */
-		if (udev-&gt;persist_enabled &amp;&amp; status == 0 &amp;&amp;
-				!(portstatus &amp; USB_PORT_STAT_ENABLE)) {
+		} else if (udev-&gt;persist_enabled) {
+			/* Turn off the status changes to prevent khubd
+			 * from disconnecting the device.
+			 */
 			if (portchange &amp; USB_PORT_STAT_C_ENABLE)
 				clear_port_feature(hub-&gt;hdev, port1,
 						USB_PORT_FEAT_C_ENABLE);
 			if (portchange &amp; USB_PORT_STAT_C_CONNECTION)
 				clear_port_feature(hub-&gt;hdev, port1,
 						USB_PORT_FEAT_C_CONNECTION);
+#ifdef CONFIG_PM
 			udev-&gt;reset_resume = 1;
+#endif
+		} else {
+			/* The power session is gone; tell khubd */
+			usb_set_device_state(udev, USB_STATE_NOTATTACHED);
+			set_bit(port1, hub-&gt;change_bits);
 		}
-
-		/* Otherwise for a reset_resume we must disconnect the child,
-		 * but as we may not lock the child device here
-		 * we have to do a "logical" disconnect.
-		 */
-		else if (type == HUB_RESET_RESUME)
-			hub_port_logical_disconnect(hub, port1);
 	}
 
 	hub_activate(hub);
 }
 
-#endif	/* CONFIG_PM */
-
 /* caller has locked the hub device */
 static int hub_pre_reset(struct usb_interface *intf)
 {
@@ -728,7 +727,7 @@ static int hub_post_reset(struct usb_interface *intf)
 	struct usb_hub *hub = usb_get_intfdata(intf);
 
 	hub_power_on(hub);
-	hub_activate(hub);
+	hub_restart(hub, HUB_POST_RESET);
 	return 0;
 }
 
@@ -2903,7 +2902,7 @@ static void hub_events(void)
 				continue;
 			connect_change = test_bit(i, hub-&gt;change_bits);
 			if (!test_and_clear_bit(i, hub-&gt;event_bits) &amp;&amp;
-					!connect_change &amp;&amp; !hub-&gt;activating)
+					!connect_change)
 				continue;
 
 			ret = hub_port_status(hub, i,
@@ -2911,11 +2910,6 @@ static void hub_events(void)
 			if (ret &lt; 0)
 				continue;
 
-			if (hub-&gt;activating &amp;&amp; !hdev-&gt;children[i-1] &amp;&amp;
-					(portstatus &amp;
-						USB_PORT_STAT_CONNECTION))
-				connect_change = 1;
-
 			if (portchange &amp; USB_PORT_STAT_C_CONNECTION) {
 				clear_port_feature(hdev, i,
 					USB_PORT_FEAT_C_CONNECTION);
@@ -3011,8 +3005,6 @@ static void hub_events(void)
 			}
 		}
 
-		hub-&gt;activating = 0;
-
 		/* If this is a root hub, tell the HCD it's okay to
 		 * re-enable port-change interrupts now. */
 		if (!hdev-&gt;parent &amp;&amp; !hub-&gt;busy_bits[0])</pre><hr><pre>commit 24618b0cd42f936cda461bdf6144670a5c925178
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Apr 28 11:06:28 2008 -0400

    USB: debounce before unregistering
    
    This patch (as1080) makes a significant change to the way khubd
    handles port connect-change and enable-change events.  Both types of
    event are now debounced, and the debouncing is carried out _before_ an
    existing usb_device is unregistered, instead of afterward.
    
    This means that drivers will have to deal with longer runs of errors
    when a device is unplugged, but they are supposed to be prepared for
    that in any case.
    
    The advantage is that when an enable-change occurs (caused for example
    by electromagnetic interference), the debouncing period will provide
    time for the cause of the problem to die away.  A simple port reset
    (added in a forthcoming patch) will then allow us to recover from the
    fault.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index d14da2123eb5..d741b9457427 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2673,9 +2673,10 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 	struct usb_device *hdev = hub-&gt;hdev;
 	struct device *hub_dev = hub-&gt;intfdev;
 	struct usb_hcd *hcd = bus_to_hcd(hdev-&gt;bus);
-	u16 wHubCharacteristics = le16_to_cpu(hub-&gt;descriptor-&gt;wHubCharacteristics);
+	unsigned wHubCharacteristics =
+			le16_to_cpu(hub-&gt;descriptor-&gt;wHubCharacteristics);
 	int status, i;
- 
+
 	dev_dbg (hub_dev,
 		"port %d, status %04x, change %04x, %s\n",
 		port1, portstatus, portchange, portspeed (portstatus));
@@ -2684,30 +2685,36 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 		set_port_led(hub, port1, HUB_LED_AUTO);
 		hub-&gt;indicator[port1-1] = INDICATOR_AUTO;
 	}
- 
-	/* Disconnect any existing devices under this port */
-	if (hdev-&gt;children[port1-1])
-		usb_disconnect(&amp;hdev-&gt;children[port1-1]);
-	clear_bit(port1, hub-&gt;change_bits);
 
 #ifdef	CONFIG_USB_OTG
 	/* during HNP, don't repeat the debounce */
 	if (hdev-&gt;bus-&gt;is_b_host)
-		portchange &amp;= ~USB_PORT_STAT_C_CONNECTION;
+		portchange &amp;= ~(USB_PORT_STAT_C_CONNECTION |
+				USB_PORT_STAT_C_ENABLE);
 #endif
 
-	if (portchange &amp; USB_PORT_STAT_C_CONNECTION) {
+	/* Try to use the debounce delay for protection against
+	 * port-enable changes caused, for example, by EMI.
+	 */
+	if (portchange &amp; (USB_PORT_STAT_C_CONNECTION |
+				USB_PORT_STAT_C_ENABLE)) {
 		status = hub_port_debounce(hub, port1);
 		if (status &lt; 0) {
 			if (printk_ratelimit())
 				dev_err (hub_dev, "connect-debounce failed, "
 						"port %d disabled\n", port1);
-			goto done;
+			portstatus &amp;= ~USB_PORT_STAT_CONNECTION;
+		} else {
+			portstatus = status;
 		}
-		portstatus = status;
 	}
 
-	/* Return now if nothing is connected */
+	/* Disconnect any existing devices under this port */
+	if (hdev-&gt;children[port1-1])
+		usb_disconnect(&amp;hdev-&gt;children[port1-1]);
+	clear_bit(port1, hub-&gt;change_bits);
+
+	/* Return now if debouncing failed or nothing is connected */
 	if (!(portstatus &amp; USB_PORT_STAT_CONNECTION)) {
 
 		/* maybe switch power back on (e.g. root hub was reset) */</pre><hr><pre>commit b01b03f3ad82b4293f6ca4da9b2692b6a377c609
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Apr 28 11:06:11 2008 -0400

    USB: add new routine for checking port-resume type
    
    This patch (as1070) creates a new subroutine to check whether a device
    can be resumed.  This code is needed even when CONFIG_USB_SUSPEND
    isn't set, because devices do suspend themselves when the root hub
    (and hence the entire bus) is suspended, and power sessions can get
    lost during a system sleep even without individual port suspends.
    
    The patch also fixes a loose end in USB-Persist reset-resume handling.
    When a low- or full-speed device is attached to an EHCI's companion
    controller, the port handoff during resume will cause the companion
    port's connect-status-change feature to be set.  If that flag isn't
    cleared, the port-reset code will think it indicates that the device
    has been unplugged and the reset-resume will fail.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 2a5c2833de38..d14da2123eb5 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1821,6 +1821,45 @@ static int hub_port_reset(struct usb_hub *hub, int port1,
 
 #ifdef	CONFIG_PM
 
+#define MASK_BITS	(USB_PORT_STAT_POWER | USB_PORT_STAT_CONNECTION | \
+				USB_PORT_STAT_SUSPEND)
+#define WANT_BITS	(USB_PORT_STAT_POWER | USB_PORT_STAT_CONNECTION)
+
+/* Determine whether the device on a port is ready for a normal resume,
+ * is ready for a reset-resume, or should be disconnected.
+ */
+static int check_port_resume_type(struct usb_device *udev,
+		struct usb_hub *hub, int port1,
+		int status, unsigned portchange, unsigned portstatus)
+{
+	/* Is the device still present? */
+	if (status || (portstatus &amp; MASK_BITS) != WANT_BITS) {
+		if (status &gt;= 0)
+			status = -ENODEV;
+	}
+
+	/* Can't do a normal resume if the port isn't enabled */
+	else if (!(portstatus &amp; USB_PORT_STAT_ENABLE) &amp;&amp; !udev-&gt;reset_resume)
+		status = -ENODEV;
+
+	if (status) {
+		dev_dbg(hub-&gt;intfdev,
+				"port %d status %04x.%04x after resume, %d\n",
+				port1, portchange, portstatus, status);
+	} else if (udev-&gt;reset_resume) {
+
+		/* Late port handoff can set status-change bits */
+		if (portchange &amp; USB_PORT_STAT_C_CONNECTION)
+			clear_port_feature(hub-&gt;hdev, port1,
+					USB_PORT_FEAT_C_CONNECTION);
+		if (portchange &amp; USB_PORT_STAT_C_ENABLE)
+			clear_port_feature(hub-&gt;hdev, port1,
+					USB_PORT_FEAT_C_ENABLE);
+	}
+
+	return status;
+}
+
 #ifdef	CONFIG_USB_SUSPEND
 
 /*
@@ -2025,7 +2064,6 @@ int usb_port_resume(struct usb_device *udev)
 	int		port1 = udev-&gt;portnum;
 	int		status;
 	u16		portchange, portstatus;
-	unsigned	mask_flags, want_flags;
 
 	/* Skip the initial Clear-Suspend step for a remote wakeup */
 	status = hub_port_status(hub, port1, &amp;portstatus, &amp;portchange);
@@ -2054,35 +2092,23 @@ int usb_port_resume(struct usb_device *udev)
 		 */
 		status = hub_port_status(hub, port1, &amp;portstatus, &amp;portchange);
 
- SuspendCleared:
-		if (udev-&gt;reset_resume)
-			want_flags = USB_PORT_STAT_POWER
-					| USB_PORT_STAT_CONNECTION;
-		else
-			want_flags = USB_PORT_STAT_POWER
-					| USB_PORT_STAT_CONNECTION
-					| USB_PORT_STAT_ENABLE;
-		mask_flags = want_flags | USB_PORT_STAT_SUSPEND;
+		/* TRSMRCY = 10 msec */
+		msleep(10);
+	}
 
-		if (status &lt; 0 || (portstatus &amp; mask_flags) != want_flags) {
-			dev_dbg(hub-&gt;intfdev,
-				"port %d status %04x.%04x after resume, %d\n",
-				port1, portchange, portstatus, status);
-			if (status &gt;= 0)
-				status = -ENODEV;
-		} else {
-			if (portchange &amp; USB_PORT_STAT_C_SUSPEND)
-				clear_port_feature(hub-&gt;hdev, port1,
-						USB_PORT_FEAT_C_SUSPEND);
-			/* TRSMRCY = 10 msec */
-			msleep(10);
-		}
+ SuspendCleared:
+	if (status == 0) {
+		if (portchange &amp; USB_PORT_STAT_C_SUSPEND)
+			clear_port_feature(hub-&gt;hdev, port1,
+					USB_PORT_FEAT_C_SUSPEND);
 	}
 
 	clear_bit(port1, hub-&gt;busy_bits);
 	if (!hub-&gt;hdev-&gt;parent &amp;&amp; !hub-&gt;busy_bits[0])
 		usb_enable_root_hub_irq(hub-&gt;hdev-&gt;bus);
 
+	status = check_port_resume_type(udev,
+			hub, port1, status, portchange, portstatus);
 	if (status == 0)
 		status = finish_port_resume(udev);
 	if (status &lt; 0) {
@@ -2115,12 +2141,23 @@ int usb_port_suspend(struct usb_device *udev)
 	return 0;
 }
 
+/* However we may need to do a reset-resume */
+
 int usb_port_resume(struct usb_device *udev)
 {
-	int status = 0;
+	struct usb_hub	*hub = hdev_to_hub(udev-&gt;parent);
+	int		port1 = udev-&gt;portnum;
+	int		status;
+	u16		portchange, portstatus;
 
-	/* However we may need to do a reset-resume */
-	if (udev-&gt;reset_resume) {
+	status = hub_port_status(hub, port1, &amp;portstatus, &amp;portchange);
+	status = check_port_resume_type(udev,
+			hub, port1, status, portchange, portstatus);
+
+	if (status) {
+		dev_dbg(&amp;udev-&gt;dev, "can't resume, status %d\n", status);
+		hub_port_logical_disconnect(hub, port1);
+	} else if (udev-&gt;reset_resume) {
 		dev_dbg(&amp;udev-&gt;dev, "reset-resume\n");
 		status = usb_reset_device(udev);
 	}</pre><hr><pre>commit bdb2b8cab4392ce41ddfbd6773a3da3334daf836
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jun 24 14:03:14 2008 -0400

    [SCSI] erase invalid data returned by device
    
    This patch (as1108) fixes a problem that can occur with certain USB
    mass-storage devices: They return invalid data together with a residue
    indicating that the data should be ignored.  Rather than leave the
    invalid data in a transfer buffer, where it can get misinterpreted,
    the patch clears the invalid portion of the buffer.
    
    This solves a problem (wrong write-protect setting detected) reported
    by Maciej Rutecki and Peter Teoh.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Peter Teoh &lt;htmldeveloper@gmail.com&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
index a82d2fe80fb5..cbf55d59a54c 100644
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@ -207,6 +207,15 @@ int scsi_execute(struct scsi_device *sdev, const unsigned char *cmd,
 	 */
 	blk_execute_rq(req-&gt;q, NULL, req, 1);
 
+	/*
+	 * Some devices (USB mass-storage in particular) may transfer
+	 * garbage data together with a residue indicating that the data
+	 * is invalid.  Prevent the garbage from being misinterpreted
+	 * and prevent security leaks by zeroing out the excess data.
+	 */
+	if (unlikely(req-&gt;data_len &gt; 0 &amp;&amp; req-&gt;data_len &lt;= bufflen))
+		memset(buffer + (bufflen - req-&gt;data_len), 0, req-&gt;data_len);
+
 	ret = req-&gt;errors;
  out:
 	blk_put_request(req);</pre><hr><pre>commit 1236edf1c70107a0d31b3fba0b2a8783615d0d24
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jul 1 10:45:51 2008 -0400

    USB: don't lose disconnections during suspend
    
    This patch (as1111) fixes a bug in the hub driver.  When a hub
    resumes, disconnections that occurred while the hub was suspended are
    lost.
    
    A completely different fix for this problem has already been accepted
    for 2.6.27; however the problem still needs to be handled in 2.6.26.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Lukas Hejtmanek &lt;xhejtman@ics.muni.cz&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 94789be54ca3..512d2d57d41e 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -713,18 +713,11 @@ static void hub_restart(struct usb_hub *hub, int type)
 		}
 
 		/* Was the power session lost while we were suspended? */
-		switch (type) {
-		case HUB_RESET_RESUME:
-			portstatus = 0;
-			portchange = USB_PORT_STAT_C_CONNECTION;
-			break;
+		status = hub_port_status(hub, port1, &amp;portstatus, &amp;portchange);
 
-		case HUB_RESET:
-		case HUB_RESUME:
-			status = hub_port_status(hub, port1,
-					&amp;portstatus, &amp;portchange);
-			break;
-		}
+		/* If the device is gone, khubd will handle it later */
+		if (status == 0 &amp;&amp; !(portstatus &amp; USB_PORT_STAT_CONNECTION))
+			continue;
 
 		/* For "USB_PERSIST"-enabled children we must
 		 * mark the child device for reset-resume and</pre><hr><pre>commit 19c4158bcdf42ee3b2394342caf14f8471d2c78e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Mar 7 11:20:25 2008 -0500

    [SCSI] SCSI: remove dev-&gt;power.power_state from mesh driver
    
    power.power_state is scheduled for removal.  This patch (as1055)
    removes all uses of that field from the SCSI mesh driver.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Paul Mackerras &lt;paulus@au.ibm.com&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/scsi/mesh.c b/drivers/scsi/mesh.c
index fd63b06d9ef1..11aa917629ac 100644
--- a/drivers/scsi/mesh.c
+++ b/drivers/scsi/mesh.c
@@ -1765,7 +1765,7 @@ static int mesh_suspend(struct macio_dev *mdev, pm_message_t mesg)
 	default:
 		return 0;
 	}
-	if (mesg.event == mdev-&gt;ofdev.dev.power.power_state.event)
+	if (ms-&gt;phase == sleeping)
 		return 0;
 
 	scsi_block_requests(ms-&gt;host);
@@ -1780,8 +1780,6 @@ static int mesh_suspend(struct macio_dev *mdev, pm_message_t mesg)
 	disable_irq(ms-&gt;meshintr);
 	set_mesh_power(ms, 0);
 
-	mdev-&gt;ofdev.dev.power.power_state = mesg;
-
 	return 0;
 }
 
@@ -1790,7 +1788,7 @@ static int mesh_resume(struct macio_dev *mdev)
 	struct mesh_state *ms = (struct mesh_state *)macio_get_drvdata(mdev);
 	unsigned long flags;
 
-	if (mdev-&gt;ofdev.dev.power.power_state.event == PM_EVENT_ON)
+	if (ms-&gt;phase != sleeping)
 		return 0;
 
 	set_mesh_power(ms, 1);
@@ -1801,8 +1799,6 @@ static int mesh_resume(struct macio_dev *mdev)
 	enable_irq(ms-&gt;meshintr);
 	scsi_unblock_requests(ms-&gt;host);
 
-	mdev-&gt;ofdev.dev.power.power_state.event = PM_EVENT_ON;
-
 	return 0;
 }
 </pre>
    <div class="pagination">
        <a href='2_90.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><span>[91]</span><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_92.html'>Next&gt;&gt;</a>
    <div>
</body>
