<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_11.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><span>[12]</span><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_13.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit d9d4b1e46d9543a82c23f6df03f4ad697dab361b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Oct 3 14:53:59 2019 -0400

    HID: Fix assumption that devices have inputs
    
    The syzbot fuzzer found a slab-out-of-bounds write bug in the hid-gaff
    driver.  The problem is caused by the driver's assumption that the
    device must have an input report.  While this will be true for all
    normal HID input devices, a suitably malicious device can violate the
    assumption.
    
    The same assumption is present in over a dozen other HID drivers.
    This patch fixes them by checking that the list of hid_inputs for the
    hid_device is nonempty before allowing it to be used.
    
    Reported-and-tested-by: syzbot+403741a091bf41d4ae79@syzkaller.appspotmail.com
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Benjamin Tissoires &lt;benjamin.tissoires@redhat.com&gt;

diff --git a/drivers/hid/hid-axff.c b/drivers/hid/hid-axff.c
index 6654c1550e2e..fbe4e16ab029 100644
--- a/drivers/hid/hid-axff.c
+++ b/drivers/hid/hid-axff.c
@@ -63,13 +63,20 @@ static int axff_init(struct hid_device *hid)
 {
 	struct axff_device *axff;
 	struct hid_report *report;
-	struct hid_input *hidinput = list_first_entry(&amp;hid-&gt;inputs, struct hid_input, list);
+	struct hid_input *hidinput;
 	struct list_head *report_list =&amp;hid-&gt;report_enum[HID_OUTPUT_REPORT].report_list;
-	struct input_dev *dev = hidinput-&gt;input;
+	struct input_dev *dev;
 	int field_count = 0;
 	int i, j;
 	int error;
 
+	if (list_empty(&amp;hid-&gt;inputs)) {
+		hid_err(hid, "no inputs found\n");
+		return -ENODEV;
+	}
+	hidinput = list_first_entry(&amp;hid-&gt;inputs, struct hid_input, list);
+	dev = hidinput-&gt;input;
+
 	if (list_empty(report_list)) {
 		hid_err(hid, "no output reports found\n");
 		return -ENODEV;
diff --git a/drivers/hid/hid-dr.c b/drivers/hid/hid-dr.c
index 17e17f9a597b..947f19f8685f 100644
--- a/drivers/hid/hid-dr.c
+++ b/drivers/hid/hid-dr.c
@@ -75,13 +75,19 @@ static int drff_init(struct hid_device *hid)
 {
 	struct drff_device *drff;
 	struct hid_report *report;
-	struct hid_input *hidinput = list_first_entry(&amp;hid-&gt;inputs,
-						struct hid_input, list);
+	struct hid_input *hidinput;
 	struct list_head *report_list =
 			&amp;hid-&gt;report_enum[HID_OUTPUT_REPORT].report_list;
-	struct input_dev *dev = hidinput-&gt;input;
+	struct input_dev *dev;
 	int error;
 
+	if (list_empty(&amp;hid-&gt;inputs)) {
+		hid_err(hid, "no inputs found\n");
+		return -ENODEV;
+	}
+	hidinput = list_first_entry(&amp;hid-&gt;inputs, struct hid_input, list);
+	dev = hidinput-&gt;input;
+
 	if (list_empty(report_list)) {
 		hid_err(hid, "no output reports found\n");
 		return -ENODEV;
diff --git a/drivers/hid/hid-emsff.c b/drivers/hid/hid-emsff.c
index 7cd5651872d3..c34f2e5a049f 100644
--- a/drivers/hid/hid-emsff.c
+++ b/drivers/hid/hid-emsff.c
@@ -47,13 +47,19 @@ static int emsff_init(struct hid_device *hid)
 {
 	struct emsff_device *emsff;
 	struct hid_report *report;
-	struct hid_input *hidinput = list_first_entry(&amp;hid-&gt;inputs,
-						struct hid_input, list);
+	struct hid_input *hidinput;
 	struct list_head *report_list =
 			&amp;hid-&gt;report_enum[HID_OUTPUT_REPORT].report_list;
-	struct input_dev *dev = hidinput-&gt;input;
+	struct input_dev *dev;
 	int error;
 
+	if (list_empty(&amp;hid-&gt;inputs)) {
+		hid_err(hid, "no inputs found\n");
+		return -ENODEV;
+	}
+	hidinput = list_first_entry(&amp;hid-&gt;inputs, struct hid_input, list);
+	dev = hidinput-&gt;input;
+
 	if (list_empty(report_list)) {
 		hid_err(hid, "no output reports found\n");
 		return -ENODEV;
diff --git a/drivers/hid/hid-gaff.c b/drivers/hid/hid-gaff.c
index 0f95c96b70f8..ecbd3995a4eb 100644
--- a/drivers/hid/hid-gaff.c
+++ b/drivers/hid/hid-gaff.c
@@ -64,14 +64,20 @@ static int gaff_init(struct hid_device *hid)
 {
 	struct gaff_device *gaff;
 	struct hid_report *report;
-	struct hid_input *hidinput = list_entry(hid-&gt;inputs.next,
-						struct hid_input, list);
+	struct hid_input *hidinput;
 	struct list_head *report_list =
 			&amp;hid-&gt;report_enum[HID_OUTPUT_REPORT].report_list;
 	struct list_head *report_ptr = report_list;
-	struct input_dev *dev = hidinput-&gt;input;
+	struct input_dev *dev;
 	int error;
 
+	if (list_empty(&amp;hid-&gt;inputs)) {
+		hid_err(hid, "no inputs found\n");
+		return -ENODEV;
+	}
+	hidinput = list_entry(hid-&gt;inputs.next, struct hid_input, list);
+	dev = hidinput-&gt;input;
+
 	if (list_empty(report_list)) {
 		hid_err(hid, "no output reports found\n");
 		return -ENODEV;
diff --git a/drivers/hid/hid-holtekff.c b/drivers/hid/hid-holtekff.c
index 10a720558830..8619b80c834c 100644
--- a/drivers/hid/hid-holtekff.c
+++ b/drivers/hid/hid-holtekff.c
@@ -124,13 +124,19 @@ static int holtekff_init(struct hid_device *hid)
 {
 	struct holtekff_device *holtekff;
 	struct hid_report *report;
-	struct hid_input *hidinput = list_entry(hid-&gt;inputs.next,
-						struct hid_input, list);
+	struct hid_input *hidinput;
 	struct list_head *report_list =
 			&amp;hid-&gt;report_enum[HID_OUTPUT_REPORT].report_list;
-	struct input_dev *dev = hidinput-&gt;input;
+	struct input_dev *dev;
 	int error;
 
+	if (list_empty(&amp;hid-&gt;inputs)) {
+		hid_err(hid, "no inputs found\n");
+		return -ENODEV;
+	}
+	hidinput = list_entry(hid-&gt;inputs.next, struct hid_input, list);
+	dev = hidinput-&gt;input;
+
 	if (list_empty(report_list)) {
 		hid_err(hid, "no output report found\n");
 		return -ENODEV;
diff --git a/drivers/hid/hid-lg2ff.c b/drivers/hid/hid-lg2ff.c
index dd1a6c3a7de6..73d07e35f12a 100644
--- a/drivers/hid/hid-lg2ff.c
+++ b/drivers/hid/hid-lg2ff.c
@@ -50,11 +50,17 @@ int lg2ff_init(struct hid_device *hid)
 {
 	struct lg2ff_device *lg2ff;
 	struct hid_report *report;
-	struct hid_input *hidinput = list_entry(hid-&gt;inputs.next,
-						struct hid_input, list);
-	struct input_dev *dev = hidinput-&gt;input;
+	struct hid_input *hidinput;
+	struct input_dev *dev;
 	int error;
 
+	if (list_empty(&amp;hid-&gt;inputs)) {
+		hid_err(hid, "no inputs found\n");
+		return -ENODEV;
+	}
+	hidinput = list_entry(hid-&gt;inputs.next, struct hid_input, list);
+	dev = hidinput-&gt;input;
+
 	/* Check that the report looks ok */
 	report = hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 7);
 	if (!report)
diff --git a/drivers/hid/hid-lg3ff.c b/drivers/hid/hid-lg3ff.c
index 9ecb6fd06203..b7e1949f3cf7 100644
--- a/drivers/hid/hid-lg3ff.c
+++ b/drivers/hid/hid-lg3ff.c
@@ -117,12 +117,19 @@ static const signed short ff3_joystick_ac[] = {
 
 int lg3ff_init(struct hid_device *hid)
 {
-	struct hid_input *hidinput = list_entry(hid-&gt;inputs.next, struct hid_input, list);
-	struct input_dev *dev = hidinput-&gt;input;
+	struct hid_input *hidinput;
+	struct input_dev *dev;
 	const signed short *ff_bits = ff3_joystick_ac;
 	int error;
 	int i;
 
+	if (list_empty(&amp;hid-&gt;inputs)) {
+		hid_err(hid, "no inputs found\n");
+		return -ENODEV;
+	}
+	hidinput = list_entry(hid-&gt;inputs.next, struct hid_input, list);
+	dev = hidinput-&gt;input;
+
 	/* Check that the report looks ok */
 	if (!hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 35))
 		return -ENODEV;
diff --git a/drivers/hid/hid-lg4ff.c b/drivers/hid/hid-lg4ff.c
index 03f0220062ca..5e6a0cef2a06 100644
--- a/drivers/hid/hid-lg4ff.c
+++ b/drivers/hid/hid-lg4ff.c
@@ -1253,8 +1253,8 @@ static int lg4ff_handle_multimode_wheel(struct hid_device *hid, u16 *real_produc
 
 int lg4ff_init(struct hid_device *hid)
 {
-	struct hid_input *hidinput = list_entry(hid-&gt;inputs.next, struct hid_input, list);
-	struct input_dev *dev = hidinput-&gt;input;
+	struct hid_input *hidinput;
+	struct input_dev *dev;
 	struct list_head *report_list = &amp;hid-&gt;report_enum[HID_OUTPUT_REPORT].report_list;
 	struct hid_report *report = list_entry(report_list-&gt;next, struct hid_report, list);
 	const struct usb_device_descriptor *udesc = &amp;(hid_to_usb_dev(hid)-&gt;descriptor);
@@ -1266,6 +1266,13 @@ int lg4ff_init(struct hid_device *hid)
 	int mmode_ret, mmode_idx = -1;
 	u16 real_product_id;
 
+	if (list_empty(&amp;hid-&gt;inputs)) {
+		hid_err(hid, "no inputs found\n");
+		return -ENODEV;
+	}
+	hidinput = list_entry(hid-&gt;inputs.next, struct hid_input, list);
+	dev = hidinput-&gt;input;
+
 	/* Check that the report looks ok */
 	if (!hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 7))
 		return -1;
diff --git a/drivers/hid/hid-lgff.c b/drivers/hid/hid-lgff.c
index c79a6ec43745..aed4ddc397a9 100644
--- a/drivers/hid/hid-lgff.c
+++ b/drivers/hid/hid-lgff.c
@@ -115,12 +115,19 @@ static void hid_lgff_set_autocenter(struct input_dev *dev, u16 magnitude)
 
 int lgff_init(struct hid_device* hid)
 {
-	struct hid_input *hidinput = list_entry(hid-&gt;inputs.next, struct hid_input, list);
-	struct input_dev *dev = hidinput-&gt;input;
+	struct hid_input *hidinput;
+	struct input_dev *dev;
 	const signed short *ff_bits = ff_joystick;
 	int error;
 	int i;
 
+	if (list_empty(&amp;hid-&gt;inputs)) {
+		hid_err(hid, "no inputs found\n");
+		return -ENODEV;
+	}
+	hidinput = list_entry(hid-&gt;inputs.next, struct hid_input, list);
+	dev = hidinput-&gt;input;
+
 	/* Check that the report looks ok */
 	if (!hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 7))
 		return -ENODEV;
diff --git a/drivers/hid/hid-logitech-hidpp.c b/drivers/hid/hid-logitech-hidpp.c
index 0179f7ed77e5..1ac1ecc1e67c 100644
--- a/drivers/hid/hid-logitech-hidpp.c
+++ b/drivers/hid/hid-logitech-hidpp.c
@@ -2084,8 +2084,8 @@ static void hidpp_ff_destroy(struct ff_device *ff)
 static int hidpp_ff_init(struct hidpp_device *hidpp, u8 feature_index)
 {
 	struct hid_device *hid = hidpp-&gt;hid_dev;
-	struct hid_input *hidinput = list_entry(hid-&gt;inputs.next, struct hid_input, list);
-	struct input_dev *dev = hidinput-&gt;input;
+	struct hid_input *hidinput;
+	struct input_dev *dev;
 	const struct usb_device_descriptor *udesc = &amp;(hid_to_usb_dev(hid)-&gt;descriptor);
 	const u16 bcdDevice = le16_to_cpu(udesc-&gt;bcdDevice);
 	struct ff_device *ff;
@@ -2094,6 +2094,13 @@ static int hidpp_ff_init(struct hidpp_device *hidpp, u8 feature_index)
 	int error, j, num_slots;
 	u8 version;
 
+	if (list_empty(&amp;hid-&gt;inputs)) {
+		hid_err(hid, "no inputs found\n");
+		return -ENODEV;
+	}
+	hidinput = list_entry(hid-&gt;inputs.next, struct hid_input, list);
+	dev = hidinput-&gt;input;
+
 	if (!dev) {
 		hid_err(hid, "Struct input_dev not set!\n");
 		return -EINVAL;
diff --git a/drivers/hid/hid-microsoft.c b/drivers/hid/hid-microsoft.c
index 2cf83856f2e4..2d8b589201a4 100644
--- a/drivers/hid/hid-microsoft.c
+++ b/drivers/hid/hid-microsoft.c
@@ -328,11 +328,17 @@ static int ms_play_effect(struct input_dev *dev, void *data,
 
 static int ms_init_ff(struct hid_device *hdev)
 {
-	struct hid_input *hidinput = list_entry(hdev-&gt;inputs.next,
-						struct hid_input, list);
-	struct input_dev *input_dev = hidinput-&gt;input;
+	struct hid_input *hidinput;
+	struct input_dev *input_dev;
 	struct ms_data *ms = hid_get_drvdata(hdev);
 
+	if (list_empty(&amp;hdev-&gt;inputs)) {
+		hid_err(hdev, "no inputs found\n");
+		return -ENODEV;
+	}
+	hidinput = list_entry(hdev-&gt;inputs.next, struct hid_input, list);
+	input_dev = hidinput-&gt;input;
+
 	if (!(ms-&gt;quirks &amp; MS_QUIRK_FF))
 		return 0;
 
diff --git a/drivers/hid/hid-sony.c b/drivers/hid/hid-sony.c
index 73c0f7a95e2d..4c6ed6ef31f1 100644
--- a/drivers/hid/hid-sony.c
+++ b/drivers/hid/hid-sony.c
@@ -2254,9 +2254,15 @@ static int sony_play_effect(struct input_dev *dev, void *data,
 
 static int sony_init_ff(struct sony_sc *sc)
 {
-	struct hid_input *hidinput = list_entry(sc-&gt;hdev-&gt;inputs.next,
-						struct hid_input, list);
-	struct input_dev *input_dev = hidinput-&gt;input;
+	struct hid_input *hidinput;
+	struct input_dev *input_dev;
+
+	if (list_empty(&amp;sc-&gt;hdev-&gt;inputs)) {
+		hid_err(sc-&gt;hdev, "no inputs found\n");
+		return -ENODEV;
+	}
+	hidinput = list_entry(sc-&gt;hdev-&gt;inputs.next, struct hid_input, list);
+	input_dev = hidinput-&gt;input;
 
 	input_set_capability(input_dev, EV_FF, FF_RUMBLE);
 	return input_ff_create_memless(input_dev, NULL, sony_play_effect);
diff --git a/drivers/hid/hid-tmff.c b/drivers/hid/hid-tmff.c
index bdfc5ff3b2c5..90acef304536 100644
--- a/drivers/hid/hid-tmff.c
+++ b/drivers/hid/hid-tmff.c
@@ -124,12 +124,18 @@ static int tmff_init(struct hid_device *hid, const signed short *ff_bits)
 	struct tmff_device *tmff;
 	struct hid_report *report;
 	struct list_head *report_list;
-	struct hid_input *hidinput = list_entry(hid-&gt;inputs.next,
-							struct hid_input, list);
-	struct input_dev *input_dev = hidinput-&gt;input;
+	struct hid_input *hidinput;
+	struct input_dev *input_dev;
 	int error;
 	int i;
 
+	if (list_empty(&amp;hid-&gt;inputs)) {
+		hid_err(hid, "no inputs found\n");
+		return -ENODEV;
+	}
+	hidinput = list_entry(hid-&gt;inputs.next, struct hid_input, list);
+	input_dev = hidinput-&gt;input;
+
 	tmff = kzalloc(sizeof(struct tmff_device), GFP_KERNEL);
 	if (!tmff)
 		return -ENOMEM;
diff --git a/drivers/hid/hid-zpff.c b/drivers/hid/hid-zpff.c
index f90959e94028..3abaca045869 100644
--- a/drivers/hid/hid-zpff.c
+++ b/drivers/hid/hid-zpff.c
@@ -54,11 +54,17 @@ static int zpff_init(struct hid_device *hid)
 {
 	struct zpff_device *zpff;
 	struct hid_report *report;
-	struct hid_input *hidinput = list_entry(hid-&gt;inputs.next,
-						struct hid_input, list);
-	struct input_dev *dev = hidinput-&gt;input;
+	struct hid_input *hidinput;
+	struct input_dev *dev;
 	int i, error;
 
+	if (list_empty(&amp;hid-&gt;inputs)) {
+		hid_err(hid, "no inputs found\n");
+		return -ENODEV;
+	}
+	hidinput = list_entry(hid-&gt;inputs.next, struct hid_input, list);
+	dev = hidinput-&gt;input;
+
 	for (i = 0; i &lt; 4; i++) {
 		report = hid_validate_values(hid, HID_OUTPUT_REPORT, 0, i, 1);
 		if (!report)</pre><hr><pre>commit 98375b86c79137416e9fd354177b85e768c16e56
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Sep 4 11:54:20 2019 -0400

    HID: prodikeys: Fix general protection fault during probe
    
    The syzbot fuzzer provoked a general protection fault in the
    hid-prodikeys driver:
    
    kasan: CONFIG_KASAN_INLINE enabled
    kasan: GPF could be caused by NULL-ptr deref or user memory access
    general protection fault: 0000 [#1] SMP KASAN
    CPU: 0 PID: 12 Comm: kworker/0:1 Not tainted 5.3.0-rc5+ #28
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS
    Google 01/01/2011
    Workqueue: usb_hub_wq hub_event
    RIP: 0010:pcmidi_submit_output_report drivers/hid/hid-prodikeys.c:300  [inline]
    RIP: 0010:pcmidi_set_operational drivers/hid/hid-prodikeys.c:558 [inline]
    RIP: 0010:pcmidi_snd_initialise drivers/hid/hid-prodikeys.c:686 [inline]
    RIP: 0010:pk_probe+0xb51/0xfd0 drivers/hid/hid-prodikeys.c:836
    Code: 0f 85 50 04 00 00 48 8b 04 24 4c 89 7d 10 48 8b 58 08 e8 b2 53 e4 fc
    48 8b 54 24 20 48 b8 00 00 00 00 00 fc ff df 48 c1 ea 03 &lt;80&gt; 3c 02 00 0f
    85 13 04 00 00 48 ba 00 00 00 00 00 fc ff df 49 8b
    
    The problem is caused by the fact that pcmidi_get_output_report() will
    return an error if the HID device doesn't provide the right sort of
    output report, but pcmidi_set_operational() doesn't bother to check
    the return code and assumes the function call always succeeds.
    
    This patch adds the missing check and aborts the probe operation if
    necessary.
    
    Reported-and-tested-by: syzbot+1088533649dafa1c9004@syzkaller.appspotmail.com
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/hid-prodikeys.c b/drivers/hid/hid-prodikeys.c
index 21544ebff855..5a3b3d974d84 100644
--- a/drivers/hid/hid-prodikeys.c
+++ b/drivers/hid/hid-prodikeys.c
@@ -551,10 +551,14 @@ static void pcmidi_setup_extra_keys(
 
 static int pcmidi_set_operational(struct pcmidi_snd *pm)
 {
+	int rc;
+
 	if (pm-&gt;ifnum != 1)
 		return 0; /* only set up ONCE for interace 1 */
 
-	pcmidi_get_output_report(pm);
+	rc = pcmidi_get_output_report(pm);
+	if (rc &lt; 0)
+		return rc;
 	pcmidi_submit_output_report(pm, 0xc1);
 	return 0;
 }
@@ -683,7 +687,11 @@ static int pcmidi_snd_initialise(struct pcmidi_snd *pm)
 	spin_lock_init(&amp;pm-&gt;rawmidi_in_lock);
 
 	init_sustain_timers(pm);
-	pcmidi_set_operational(pm);
+	err = pcmidi_set_operational(pm);
+	if (err &lt; 0) {
+		pk_error("failed to find output report\n");
+		goto fail_register;
+	}
 
 	/* register it */
 	err = snd_card_register(card);</pre><hr><pre>commit 3dd550a2d36596a1b0ee7955da3b611c031d3873
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Sep 4 11:56:27 2019 -0400

    USB: usbcore: Fix slab-out-of-bounds bug during device reset
    
    The syzbot fuzzer provoked a slab-out-of-bounds error in the USB core:
    
    BUG: KASAN: slab-out-of-bounds in memcmp+0xa6/0xb0 lib/string.c:904
    Read of size 1 at addr ffff8881d175bed6 by task kworker/0:3/2746
    
    CPU: 0 PID: 2746 Comm: kworker/0:3 Not tainted 5.3.0-rc5+ #28
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS
    Google 01/01/2011
    Workqueue: usb_hub_wq hub_event
    Call Trace:
      __dump_stack lib/dump_stack.c:77 [inline]
      dump_stack+0xca/0x13e lib/dump_stack.c:113
      print_address_description+0x6a/0x32c mm/kasan/report.c:351
      __kasan_report.cold+0x1a/0x33 mm/kasan/report.c:482
      kasan_report+0xe/0x12 mm/kasan/common.c:612
      memcmp+0xa6/0xb0 lib/string.c:904
      memcmp include/linux/string.h:400 [inline]
      descriptors_changed drivers/usb/core/hub.c:5579 [inline]
      usb_reset_and_verify_device+0x564/0x1300 drivers/usb/core/hub.c:5729
      usb_reset_device+0x4c1/0x920 drivers/usb/core/hub.c:5898
      rt2x00usb_probe+0x53/0x7af
    drivers/net/wireless/ralink/rt2x00/rt2x00usb.c:806
    
    The error occurs when the descriptors_changed() routine (called during
    a device reset) attempts to compare the old and new BOS and capability
    descriptors.  The length it uses for the comparison is the
    wTotalLength value stored in BOS descriptor, but this value is not
    necessarily the same as the length actually allocated for the
    descriptors.  If it is larger the routine will call memcmp() with a
    length that is too big, thus reading beyond the end of the allocated
    region and leading to this fault.
    
    The kernel reads the BOS descriptor twice: first to get the total
    length of all the capability descriptors, and second to read it along
    with all those other descriptors.  A malicious (or very faulty) device
    may send different values for the BOS descriptor fields each time.
    The memory area will be allocated using the wTotalLength value read
    the first time, but stored within it will be the value read the second
    time.
    
    To prevent this possibility from causing any errors, this patch
    modifies the BOS descriptor after it has been read the second time:
    It sets the wTotalLength field to the actual length of the descriptors
    that were read in and validated.  Then the memcpy() call, or any other
    code using these descriptors, will be able to rely on wTotalLength
    being valid.
    
    Reported-and-tested-by: syzbot+35f4d916c623118d576e@syzkaller.appspotmail.com
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Link: https://lore.kernel.org/r/Pine.LNX.4.44L0.1909041154260.1722-100000@iolanthe.rowland.org
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c
index 9d6cb709ca7b..151a74a54386 100644
--- a/drivers/usb/core/config.c
+++ b/drivers/usb/core/config.c
@@ -921,7 +921,7 @@ int usb_get_bos_descriptor(struct usb_device *dev)
 	struct usb_bos_descriptor *bos;
 	struct usb_dev_cap_header *cap;
 	struct usb_ssp_cap_descriptor *ssp_cap;
-	unsigned char *buffer;
+	unsigned char *buffer, *buffer0;
 	int length, total_len, num, i, ssac;
 	__u8 cap_type;
 	int ret;
@@ -966,10 +966,12 @@ int usb_get_bos_descriptor(struct usb_device *dev)
 			ret = -ENOMSG;
 		goto err;
 	}
+
+	buffer0 = buffer;
 	total_len -= length;
+	buffer += length;
 
 	for (i = 0; i &lt; num; i++) {
-		buffer += length;
 		cap = (struct usb_dev_cap_header *)buffer;
 
 		if (total_len &lt; sizeof(*cap) || total_len &lt; cap-&gt;bLength) {
@@ -983,8 +985,6 @@ int usb_get_bos_descriptor(struct usb_device *dev)
 			break;
 		}
 
-		total_len -= length;
-
 		if (cap-&gt;bDescriptorType != USB_DT_DEVICE_CAPABILITY) {
 			dev_warn(ddev, "descriptor type invalid, skip\n");
 			continue;
@@ -1019,7 +1019,11 @@ int usb_get_bos_descriptor(struct usb_device *dev)
 		default:
 			break;
 		}
+
+		total_len -= length;
+		buffer += length;
 	}
+	dev-&gt;bos-&gt;desc-&gt;wTotalLength = cpu_to_le16(buffer - buffer0);
 
 	return 0;
 </pre><hr><pre>commit 9472aff16ca0fd9351eea7773facef364743088f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Aug 8 13:34:08 2019 -0400

    USB: rio500: Fix lockdep violation
    
    The syzbot fuzzer found a lockdep violation in the rio500 driver:
    
            ======================================================
            WARNING: possible circular locking dependency detected
            5.3.0-rc2+ #23 Not tainted
            ------------------------------------------------------
            syz-executor.2/20386 is trying to acquire lock:
            00000000772249c6 (rio500_mutex){+.+.}, at: open_rio+0x16/0xc0
            drivers/usb/misc/rio500.c:64
    
            but task is already holding lock:
            00000000d3e8f4b9 (minor_rwsem){++++}, at: usb_open+0x23/0x270
            drivers/usb/core/file.c:39
    
            which lock already depends on the new lock.
    
    The problem is that the driver's open_rio() routine is called while
    the usbcore's minor_rwsem is locked for reading, and it acquires the
    rio500_mutex; whereas conversely, probe_rio() and disconnect_rio()
    first acquire the rio500_mutex and then call usb_register_dev() or
    usb_deregister_dev(), which lock minor_rwsem for writing.
    
    The correct ordering of acquisition should be: minor_rwsem first, then
    rio500_mutex (since the locking in open_rio() cannot be changed).
    Thus, the probe and disconnect routines should avoid holding
    rio500_mutex while doing their registration and deregistration.
    
    This patch adjusts the code in those two routines to do just that.  It
    also relies on the fact that the probe and disconnect routines are
    protected by the device mutex, so the initial test of rio-&gt;present
    needs no extra locking.
    
    Reported-by: syzbot+7bbcbe9c9ff0cd49592a@syzkaller.appspotmail.com
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Fixes: d710734b0677 ("USB: rio500: simplify locking")
    Acked-by: Oliver Neukum &lt;oneukum@suse.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    
    Link: https://lore.kernel.org/r/Pine.LNX.4.44L0.1908081329240.1319-100000@iolanthe.rowland.org
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/misc/rio500.c b/drivers/usb/misc/rio500.c
index 27e9c78a791e..30cae5e1954d 100644
--- a/drivers/usb/misc/rio500.c
+++ b/drivers/usb/misc/rio500.c
@@ -454,51 +454,55 @@ static int probe_rio(struct usb_interface *intf,
 {
 	struct usb_device *dev = interface_to_usbdev(intf);
 	struct rio_usb_data *rio = &amp;rio_instance;
-	int retval = 0;
+	int retval = -ENOMEM;
+	char *ibuf, *obuf;
 
-	mutex_lock(&amp;rio500_mutex);
 	if (rio-&gt;present) {
 		dev_info(&amp;intf-&gt;dev, "Second USB Rio at address %d refused\n", dev-&gt;devnum);
-		retval = -EBUSY;
-		goto bail_out;
-	} else {
-		dev_info(&amp;intf-&gt;dev, "USB Rio found at address %d\n", dev-&gt;devnum);
-	}
-
-	retval = usb_register_dev(intf, &amp;usb_rio_class);
-	if (retval) {
-		dev_err(&amp;dev-&gt;dev,
-			"Not able to get a minor for this device.\n");
-		retval = -ENOMEM;
-		goto bail_out;
+		return -EBUSY;
 	}
+	dev_info(&amp;intf-&gt;dev, "USB Rio found at address %d\n", dev-&gt;devnum);
 
-	rio-&gt;rio_dev = dev;
-
-	if (!(rio-&gt;obuf = kmalloc(OBUF_SIZE, GFP_KERNEL))) {
+	obuf = kmalloc(OBUF_SIZE, GFP_KERNEL);
+	if (!obuf) {
 		dev_err(&amp;dev-&gt;dev,
 			"probe_rio: Not enough memory for the output buffer\n");
-		usb_deregister_dev(intf, &amp;usb_rio_class);
-		retval = -ENOMEM;
-		goto bail_out;
+		goto err_obuf;
 	}
-	dev_dbg(&amp;intf-&gt;dev, "obuf address:%p\n", rio-&gt;obuf);
+	dev_dbg(&amp;intf-&gt;dev, "obuf address: %p\n", obuf);
 
-	if (!(rio-&gt;ibuf = kmalloc(IBUF_SIZE, GFP_KERNEL))) {
+	ibuf = kmalloc(IBUF_SIZE, GFP_KERNEL);
+	if (!ibuf) {
 		dev_err(&amp;dev-&gt;dev,
 			"probe_rio: Not enough memory for the input buffer\n");
-		usb_deregister_dev(intf, &amp;usb_rio_class);
-		kfree(rio-&gt;obuf);
-		retval = -ENOMEM;
-		goto bail_out;
+		goto err_ibuf;
 	}
-	dev_dbg(&amp;intf-&gt;dev, "ibuf address:%p\n", rio-&gt;ibuf);
+	dev_dbg(&amp;intf-&gt;dev, "ibuf address: %p\n", ibuf);
 
-	usb_set_intfdata (intf, rio);
+	mutex_lock(&amp;rio500_mutex);
+	rio-&gt;rio_dev = dev;
+	rio-&gt;ibuf = ibuf;
+	rio-&gt;obuf = obuf;
 	rio-&gt;present = 1;
-bail_out:
 	mutex_unlock(&amp;rio500_mutex);
 
+	retval = usb_register_dev(intf, &amp;usb_rio_class);
+	if (retval) {
+		dev_err(&amp;dev-&gt;dev,
+			"Not able to get a minor for this device.\n");
+		goto err_register;
+	}
+
+	usb_set_intfdata(intf, rio);
+	return retval;
+
+ err_register:
+	mutex_lock(&amp;rio500_mutex);
+	rio-&gt;present = 0;
+	mutex_unlock(&amp;rio500_mutex);
+ err_ibuf:
+	kfree(obuf);
+ err_obuf:
 	return retval;
 }
 
@@ -507,10 +511,10 @@ static void disconnect_rio(struct usb_interface *intf)
 	struct rio_usb_data *rio = usb_get_intfdata (intf);
 
 	usb_set_intfdata (intf, NULL);
-	mutex_lock(&amp;rio500_mutex);
 	if (rio) {
 		usb_deregister_dev(intf, &amp;usb_rio_class);
 
+		mutex_lock(&amp;rio500_mutex);
 		if (rio-&gt;isopen) {
 			rio-&gt;isopen = 0;
 			/* better let it finish - the release will do whats needed */
@@ -524,8 +528,8 @@ static void disconnect_rio(struct usb_interface *intf)
 		dev_info(&amp;intf-&gt;dev, "USB Rio disconnected.\n");
 
 		rio-&gt;present = 0;
+		mutex_unlock(&amp;rio500_mutex);
 	}
-	mutex_unlock(&amp;rio500_mutex);
 }
 
 static const struct usb_device_id rio_table[] = {</pre><hr><pre>commit 5f9242775bb61f390f0885f23fc16397262c7538
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Aug 20 16:00:21 2019 -0400

    HID: logitech: Fix general protection fault caused by Logitech driver
    
    The syzbot fuzzer found a general protection fault in the HID subsystem:
    
    kasan: CONFIG_KASAN_INLINE enabled
    kasan: GPF could be caused by NULL-ptr deref or user memory access
    general protection fault: 0000 [#1] SMP KASAN
    CPU: 0 PID: 3715 Comm: syz-executor.3 Not tainted 5.2.0-rc6+ #15
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS
    Google 01/01/2011
    RIP: 0010:__pm_runtime_resume+0x49/0x180 drivers/base/power/runtime.c:1069
    Code: ed 74 d5 fe 45 85 ed 0f 85 9a 00 00 00 e8 6f 73 d5 fe 48 8d bd c1 02
    00 00 48 b8 00 00 00 00 00 fc ff df 48 89 fa 48 c1 ea 03 &lt;0f&gt; b6 04 02 48
    89 fa 83 e2 07 38 d0 7f 08 84 c0 0f 85 fe 00 00 00
    RSP: 0018:ffff8881d99d78e0 EFLAGS: 00010202
    RAX: dffffc0000000000 RBX: 0000000000000020 RCX: ffffc90003f3f000
    RDX: 0000000416d8686d RSI: ffffffff82676841 RDI: 00000020b6c3436a
    RBP: 00000020b6c340a9 R08: ffff8881c6d64800 R09: fffffbfff0e84c25
    R10: ffff8881d99d7940 R11: ffffffff87426127 R12: 0000000000000004
    R13: 0000000000000000 R14: ffff8881d9b94000 R15: ffffffff897f9048
    FS:  00007f047f542700(0000) GS:ffff8881db200000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 0000001b30f21000 CR3: 00000001ca032000 CR4: 00000000001406f0
    DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
    Call Trace:
      pm_runtime_get_sync include/linux/pm_runtime.h:226 [inline]
      usb_autopm_get_interface+0x1b/0x50 drivers/usb/core/driver.c:1707
      usbhid_power+0x7c/0xe0 drivers/hid/usbhid/hid-core.c:1234
      hid_hw_power include/linux/hid.h:1038 [inline]
      hidraw_open+0x20d/0x740 drivers/hid/hidraw.c:282
      chrdev_open+0x219/0x5c0 fs/char_dev.c:413
      do_dentry_open+0x497/0x1040 fs/open.c:778
      do_last fs/namei.c:3416 [inline]
      path_openat+0x1430/0x3ff0 fs/namei.c:3533
      do_filp_open+0x1a1/0x280 fs/namei.c:3563
      do_sys_open+0x3c0/0x580 fs/open.c:1070
      do_syscall_64+0xb7/0x560 arch/x86/entry/common.c:301
      entry_SYSCALL_64_after_hwframe+0x49/0xbe
    
    It turns out the fault was caused by a bug in the HID Logitech driver,
    which violates the requirement that every pathway calling
    hid_hw_start() must also call hid_hw_stop().  This patch fixes the bug
    by making sure the requirement is met.
    
    Reported-and-tested-by: syzbot+3cbe5cd105d2ad56a1df@syzkaller.appspotmail.com
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/hid-lg.c b/drivers/hid/hid-lg.c
index 5008a3dc28f4..0dc7cdfc56f7 100644
--- a/drivers/hid/hid-lg.c
+++ b/drivers/hid/hid-lg.c
@@ -818,7 +818,7 @@ static int lg_probe(struct hid_device *hdev, const struct hid_device_id *id)
 
 		if (!buf) {
 			ret = -ENOMEM;
-			goto err_free;
+			goto err_stop;
 		}
 
 		ret = hid_hw_raw_request(hdev, buf[0], buf, sizeof(cbuf),
@@ -850,9 +850,12 @@ static int lg_probe(struct hid_device *hdev, const struct hid_device_id *id)
 		ret = lg4ff_init(hdev);
 
 	if (ret)
-		goto err_free;
+		goto err_stop;
 
 	return 0;
+
+err_stop:
+	hid_hw_stop(hdev);
 err_free:
 	kfree(drv_data);
 	return ret;
@@ -863,8 +866,7 @@ static void lg_remove(struct hid_device *hdev)
 	struct lg_drv_data *drv_data = hid_get_drvdata(hdev);
 	if (drv_data-&gt;quirks &amp; LG_FF4)
 		lg4ff_deinit(hdev);
-	else
-		hid_hw_stop(hdev);
+	hid_hw_stop(hdev);
 	kfree(drv_data);
 }
 
diff --git a/drivers/hid/hid-lg4ff.c b/drivers/hid/hid-lg4ff.c
index cefba038520c..03f0220062ca 100644
--- a/drivers/hid/hid-lg4ff.c
+++ b/drivers/hid/hid-lg4ff.c
@@ -1477,7 +1477,6 @@ int lg4ff_deinit(struct hid_device *hid)
 		}
 	}
 #endif
-	hid_hw_stop(hid);
 	drv_data-&gt;device_props = NULL;
 
 	kfree(entry);</pre><hr><pre>commit 416dacb819f59180e4d86a5550052033ebb6d72c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 21 13:27:12 2019 -0400

    HID: hidraw: Fix invalid read in hidraw_ioctl
    
    The syzbot fuzzer has reported a pair of problems in the
    hidraw_ioctl() function: slab-out-of-bounds read and use-after-free
    read.  An example of the first:
    
    BUG: KASAN: slab-out-of-bounds in strlen+0x79/0x90 lib/string.c:525
    Read of size 1 at addr ffff8881c8035f38 by task syz-executor.4/2833
    
    CPU: 1 PID: 2833 Comm: syz-executor.4 Not tainted 5.3.0-rc2+ #1
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS
    Google 01/01/2011
    Call Trace:
      __dump_stack lib/dump_stack.c:77 [inline]
      dump_stack+0xca/0x13e lib/dump_stack.c:113
      print_address_description+0x6a/0x32c mm/kasan/report.c:351
      __kasan_report.cold+0x1a/0x33 mm/kasan/report.c:482
      kasan_report+0xe/0x12 mm/kasan/common.c:612
      strlen+0x79/0x90 lib/string.c:525
      strlen include/linux/string.h:281 [inline]
      hidraw_ioctl+0x245/0xae0 drivers/hid/hidraw.c:446
      vfs_ioctl fs/ioctl.c:46 [inline]
      file_ioctl fs/ioctl.c:509 [inline]
      do_vfs_ioctl+0xd2d/0x1330 fs/ioctl.c:696
      ksys_ioctl+0x9b/0xc0 fs/ioctl.c:713
      __do_sys_ioctl fs/ioctl.c:720 [inline]
      __se_sys_ioctl fs/ioctl.c:718 [inline]
      __x64_sys_ioctl+0x6f/0xb0 fs/ioctl.c:718
      do_syscall_64+0xb7/0x580 arch/x86/entry/common.c:296
      entry_SYSCALL_64_after_hwframe+0x49/0xbe
    RIP: 0033:0x459829
    Code: fd b7 fb ff c3 66 2e 0f 1f 84 00 00 00 00 00 66 90 48 89 f8 48 89 f7
    48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 &lt;48&gt; 3d 01 f0 ff
    ff 0f 83 cb b7 fb ff c3 66 2e 0f 1f 84 00 00 00 00
    RSP: 002b:00007f7a68f6dc78 EFLAGS: 00000246 ORIG_RAX: 0000000000000010
    RAX: ffffffffffffffda RBX: 0000000000000003 RCX: 0000000000459829
    RDX: 0000000000000000 RSI: 0000000080404805 RDI: 0000000000000004
    RBP: 000000000075bf20 R08: 0000000000000000 R09: 0000000000000000
    R10: 0000000000000000 R11: 0000000000000246 R12: 00007f7a68f6e6d4
    R13: 00000000004c21de R14: 00000000004d5620 R15: 00000000ffffffff
    
    The two problems have the same cause: hidraw_ioctl() fails to test
    whether the device has been removed.  This patch adds the missing test.
    
    Reported-and-tested-by: syzbot+5a6c4ec678a0c6ee84ba@syzkaller.appspotmail.com
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/hidraw.c b/drivers/hid/hidraw.c
index 006bd6f4f653..62ef47a730b0 100644
--- a/drivers/hid/hidraw.c
+++ b/drivers/hid/hidraw.c
@@ -370,7 +370,7 @@ static long hidraw_ioctl(struct file *file, unsigned int cmd,
 
 	mutex_lock(&amp;minors_lock);
 	dev = hidraw_table[minor];
-	if (!dev) {
+	if (!dev || !dev-&gt;exist) {
 		ret = -ENODEV;
 		goto out;
 	}</pre><hr><pre>commit 4ed3350539aa931f58c939fcd803c7510584e143
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Aug 13 16:15:38 2019 -0400

    USB: usbfs: Add a capability flag for runtime suspend
    
    The recent commit 7794f486ed0b ("usbfs: Add ioctls for runtime power
    management") neglected to add a corresponding capability flag.  This
    patch rectifies the omission.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Mayuresh Kulkarni &lt;mkulkarni@opensource.cirrus.com&gt;
    
    Link: https://lore.kernel.org/r/Pine.LNX.4.44L0.1908131613490.1941-100000@iolanthe.rowland.org
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 5db7b6dbcb44..24d4a801ca64 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -44,6 +44,12 @@
 
 #include "usb.h"
 
+#ifdef CONFIG_PM
+#define MAYBE_CAP_SUSPEND	USBDEVFS_CAP_SUSPEND
+#else
+#define MAYBE_CAP_SUSPEND	0
+#endif
+
 #define USB_MAXBUS			64
 #define USB_DEVICE_MAX			(USB_MAXBUS * 128)
 #define USB_SG_SIZE			16384 /* split-size for large txs */
@@ -2310,7 +2316,8 @@ static int proc_get_capabilities(struct usb_dev_state *ps, void __user *arg)
 
 	caps = USBDEVFS_CAP_ZERO_PACKET | USBDEVFS_CAP_NO_PACKET_SIZE_LIM |
 			USBDEVFS_CAP_REAP_AFTER_DISCONNECT | USBDEVFS_CAP_MMAP |
-			USBDEVFS_CAP_DROP_PRIVILEGES | USBDEVFS_CAP_CONNINFO_EX;
+			USBDEVFS_CAP_DROP_PRIVILEGES |
+			USBDEVFS_CAP_CONNINFO_EX | MAYBE_CAP_SUSPEND;
 	if (!ps-&gt;dev-&gt;bus-&gt;no_stop_on_short)
 		caps |= USBDEVFS_CAP_BULK_CONTINUATION;
 	if (ps-&gt;dev-&gt;bus-&gt;sg_tablesize)
diff --git a/include/uapi/linux/usbdevice_fs.h b/include/uapi/linux/usbdevice_fs.h
index d24bbb6d3ca1..cf525cddeb94 100644
--- a/include/uapi/linux/usbdevice_fs.h
+++ b/include/uapi/linux/usbdevice_fs.h
@@ -158,6 +158,7 @@ struct usbdevfs_hub_portinfo {
 #define USBDEVFS_CAP_MMAP			0x20
 #define USBDEVFS_CAP_DROP_PRIVILEGES		0x40
 #define USBDEVFS_CAP_CONNINFO_EX		0x80
+#define USBDEVFS_CAP_SUSPEND			0x100
 
 /* USBDEVFS_DISCONNECT_CLAIM flags &amp; struct */
 </pre><hr><pre>commit 303911cfc5b95d33687d9046133ff184cf5043ff
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Aug 12 16:11:07 2019 -0400

    USB: core: Fix races in character device registration and deregistraion
    
    The syzbot fuzzer has found two (!) races in the USB character device
    registration and deregistration routines.  This patch fixes the races.
    
    The first race results from the fact that usb_deregister_dev() sets
    usb_minors[intf-&gt;minor] to NULL before calling device_destroy() on the
    class device.  This leaves a window during which another thread can
    allocate the same minor number but will encounter a duplicate name
    error when it tries to register its own class device.  A typical error
    message in the system log would look like:
    
        sysfs: cannot create duplicate filename '/class/usbmisc/ldusb0'
    
    The patch fixes this race by destroying the class device first.
    
    The second race is in usb_register_dev().  When that routine runs, it
    first allocates a minor number, then drops minor_rwsem, and then
    creates the class device.  If the device creation fails, the minor
    number is deallocated and the whole routine returns an error.  But
    during the time while minor_rwsem was dropped, there is a window in
    which the minor number is allocated and so another thread can
    successfully open the device file.  Typically this results in
    use-after-free errors or invalid accesses when the other thread closes
    its open file reference, because the kernel then tries to release
    resources that were already deallocated when usb_register_dev()
    failed.  The patch fixes this race by keeping minor_rwsem locked
    throughout the entire routine.
    
    Reported-and-tested-by: syzbot+30cf45ebfe0b0c4847a1@syzkaller.appspotmail.com
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Link: https://lore.kernel.org/r/Pine.LNX.4.44L0.1908121607590.1659-100000@iolanthe.rowland.org
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/file.c b/drivers/usb/core/file.c
index 65de6f73b672..558890ada0e5 100644
--- a/drivers/usb/core/file.c
+++ b/drivers/usb/core/file.c
@@ -193,9 +193,10 @@ int usb_register_dev(struct usb_interface *intf,
 		intf-&gt;minor = minor;
 		break;
 	}
-	up_write(&amp;minor_rwsem);
-	if (intf-&gt;minor &lt; 0)
+	if (intf-&gt;minor &lt; 0) {
+		up_write(&amp;minor_rwsem);
 		return -EXFULL;
+	}
 
 	/* create a usb class device for this usb interface */
 	snprintf(name, sizeof(name), class_driver-&gt;name, minor - minor_base);
@@ -203,12 +204,11 @@ int usb_register_dev(struct usb_interface *intf,
 				      MKDEV(USB_MAJOR, minor), class_driver,
 				      "%s", kbasename(name));
 	if (IS_ERR(intf-&gt;usb_dev)) {
-		down_write(&amp;minor_rwsem);
 		usb_minors[minor] = NULL;
 		intf-&gt;minor = -1;
-		up_write(&amp;minor_rwsem);
 		retval = PTR_ERR(intf-&gt;usb_dev);
 	}
+	up_write(&amp;minor_rwsem);
 	return retval;
 }
 EXPORT_SYMBOL_GPL(usb_register_dev);
@@ -234,12 +234,12 @@ void usb_deregister_dev(struct usb_interface *intf,
 		return;
 
 	dev_dbg(&amp;intf-&gt;dev, "removing %d minor\n", intf-&gt;minor);
+	device_destroy(usb_class-&gt;class, MKDEV(USB_MAJOR, intf-&gt;minor));
 
 	down_write(&amp;minor_rwsem);
 	usb_minors[intf-&gt;minor] = NULL;
 	up_write(&amp;minor_rwsem);
 
-	device_destroy(usb_class-&gt;class, MKDEV(USB_MAJOR, intf-&gt;minor));
 	intf-&gt;usb_dev = NULL;
 	intf-&gt;minor = -1;
 	destroy_usb_class();</pre><hr><pre>commit 7794f486ed0b1fa8022dd0a27b9babf86a46d1cf
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 7 10:29:50 2019 -0400

    usbfs: Add ioctls for runtime power management
    
    It has been requested that usbfs should implement runtime power
    management, instead of forcing the device to remain at full power as
    long as the device file is open.  This patch introduces that new
    feature.
    
    It does so by adding three new usbfs ioctls:
    
            USBDEVFS_FORBID_SUSPEND: Prevents the device from going into
            runtime suspend (and causes a resume if the device is already
            suspended).
    
            USBDEVFS_ALLOW_SUSPEND: Allows the device to go into runtime
            suspend.  Some time may elapse before the device actually is
            suspended, depending on things like the autosuspend delay.
    
            USBDEVFS_WAIT_FOR_RESUME: Blocks until the call is interrupted
            by a signal or at least one runtime resume has occurred since
            the most recent ALLOW_SUSPEND ioctl call (which may mean
            immediately, even if the device is currently suspended).  In
            the latter case, the device is prevented from suspending again
            just as if FORBID_SUSPEND was called before the ioctl returns.
    
    For backward compatibility, when the device file is first opened
    runtime suspends are forbidden.  The userspace program can then allow
    suspends whenever it wants, and either resume the device directly (by
    forbidding suspends again) or wait for a resume from some other source
    (such as a remote wakeup).  URBs submitted to a suspended device will
    fail or will complete with an appropriate error code.
    
    This combination of ioctls is sufficient for user programs to have
    nearly the same degree of control over a device's runtime power
    behavior as kernel drivers do.
    
    Still lacking is documentation for the new ioctls.  I intend to add it
    later, after the existing documentation for the usbfs userspace API is
    straightened out into a reasonable form.
    
    Suggested-by: Mayuresh Kulkarni &lt;mkulkarni@opensource.cirrus.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    
    Link: https://lore.kernel.org/r/Pine.LNX.4.44L0.1908071013220.1514-100000@iolanthe.rowland.org
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index b265ab5405f9..cdd34dcb2395 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -48,6 +48,9 @@
 #define USB_DEVICE_MAX			(USB_MAXBUS * 128)
 #define USB_SG_SIZE			16384 /* split-size for large txs */
 
+/* Mutual exclusion for ps-&gt;list in resume vs. release and remove */
+static DEFINE_MUTEX(usbfs_mutex);
+
 struct usb_dev_state {
 	struct list_head list;      /* state list */
 	struct usb_device *dev;
@@ -57,14 +60,17 @@ struct usb_dev_state {
 	struct list_head async_completed;
 	struct list_head memory_list;
 	wait_queue_head_t wait;     /* wake up if a request completed */
+	wait_queue_head_t wait_for_resume;   /* wake up upon runtime resume */
 	unsigned int discsignr;
 	struct pid *disc_pid;
 	const struct cred *cred;
 	sigval_t disccontext;
 	unsigned long ifclaimed;
 	u32 disabled_bulk_eps;
-	bool privileges_dropped;
 	unsigned long interface_allowed_mask;
+	int not_yet_resumed;
+	bool suspend_allowed;
+	bool privileges_dropped;
 };
 
 struct usb_memory {
@@ -694,9 +700,7 @@ static void driver_disconnect(struct usb_interface *intf)
 	destroy_async_on_interface(ps, ifnum);
 }
 
-/* The following routines are merely placeholders.  There is no way
- * to inform a user task about suspend or resumes.
- */
+/* We don't care about suspend/resume of claimed interfaces */
 static int driver_suspend(struct usb_interface *intf, pm_message_t msg)
 {
 	return 0;
@@ -707,12 +711,32 @@ static int driver_resume(struct usb_interface *intf)
 	return 0;
 }
 
+/* The following routines apply to the entire device, not interfaces */
+void usbfs_notify_suspend(struct usb_device *udev)
+{
+	/* We don't need to handle this */
+}
+
+void usbfs_notify_resume(struct usb_device *udev)
+{
+	struct usb_dev_state *ps;
+
+	/* Protect against simultaneous remove or release */
+	mutex_lock(&amp;usbfs_mutex);
+	list_for_each_entry(ps, &amp;udev-&gt;filelist, list) {
+		WRITE_ONCE(ps-&gt;not_yet_resumed, 0);
+		wake_up_all(&amp;ps-&gt;wait_for_resume);
+	}
+	mutex_unlock(&amp;usbfs_mutex);
+}
+
 struct usb_driver usbfs_driver = {
 	.name =		"usbfs",
 	.probe =	driver_probe,
 	.disconnect =	driver_disconnect,
 	.suspend =	driver_suspend,
 	.resume =	driver_resume,
+	.supports_autosuspend = 1,
 };
 
 static int claimintf(struct usb_dev_state *ps, unsigned int ifnum)
@@ -997,9 +1021,12 @@ static int usbdev_open(struct inode *inode, struct file *file)
 	INIT_LIST_HEAD(&amp;ps-&gt;async_completed);
 	INIT_LIST_HEAD(&amp;ps-&gt;memory_list);
 	init_waitqueue_head(&amp;ps-&gt;wait);
+	init_waitqueue_head(&amp;ps-&gt;wait_for_resume);
 	ps-&gt;disc_pid = get_pid(task_pid(current));
 	ps-&gt;cred = get_current_cred();
 	smp_wmb();
+
+	/* Can't race with resume; the device is already active */
 	list_add_tail(&amp;ps-&gt;list, &amp;dev-&gt;filelist);
 	file-&gt;private_data = ps;
 	usb_unlock_device(dev);
@@ -1025,7 +1052,10 @@ static int usbdev_release(struct inode *inode, struct file *file)
 	usb_lock_device(dev);
 	usb_hub_release_all_ports(dev, ps);
 
+	/* Protect against simultaneous resume */
+	mutex_lock(&amp;usbfs_mutex);
 	list_del_init(&amp;ps-&gt;list);
+	mutex_unlock(&amp;usbfs_mutex);
 
 	for (ifnum = 0; ps-&gt;ifclaimed &amp;&amp; ifnum &lt; 8*sizeof(ps-&gt;ifclaimed);
 			ifnum++) {
@@ -1033,7 +1063,8 @@ static int usbdev_release(struct inode *inode, struct file *file)
 			releaseintf(ps, ifnum);
 	}
 	destroy_all_async(ps);
-	usb_autosuspend_device(dev);
+	if (!ps-&gt;suspend_allowed)
+		usb_autosuspend_device(dev);
 	usb_unlock_device(dev);
 	usb_put_dev(dev);
 	put_pid(ps-&gt;disc_pid);
@@ -2384,6 +2415,47 @@ static int proc_drop_privileges(struct usb_dev_state *ps, void __user *arg)
 	return 0;
 }
 
+static int proc_forbid_suspend(struct usb_dev_state *ps)
+{
+	int ret = 0;
+
+	if (ps-&gt;suspend_allowed) {
+		ret = usb_autoresume_device(ps-&gt;dev);
+		if (ret == 0)
+			ps-&gt;suspend_allowed = false;
+		else if (ret != -ENODEV)
+			ret = -EIO;
+	}
+	return ret;
+}
+
+static int proc_allow_suspend(struct usb_dev_state *ps)
+{
+	if (!connected(ps))
+		return -ENODEV;
+
+	WRITE_ONCE(ps-&gt;not_yet_resumed, 1);
+	if (!ps-&gt;suspend_allowed) {
+		usb_autosuspend_device(ps-&gt;dev);
+		ps-&gt;suspend_allowed = true;
+	}
+	return 0;
+}
+
+static int proc_wait_for_resume(struct usb_dev_state *ps)
+{
+	int ret;
+
+	usb_unlock_device(ps-&gt;dev);
+	ret = wait_event_interruptible(ps-&gt;wait_for_resume,
+			READ_ONCE(ps-&gt;not_yet_resumed) == 0);
+	usb_lock_device(ps-&gt;dev);
+
+	if (ret != 0)
+		return -EINTR;
+	return proc_forbid_suspend(ps);
+}
+
 /*
  * NOTE:  All requests here that have interface numbers as parameters
  * are assuming that somehow the configuration has been prevented from
@@ -2578,6 +2650,15 @@ static long usbdev_do_ioctl(struct file *file, unsigned int cmd,
 	case USBDEVFS_GET_SPEED:
 		ret = ps-&gt;dev-&gt;speed;
 		break;
+	case USBDEVFS_FORBID_SUSPEND:
+		ret = proc_forbid_suspend(ps);
+		break;
+	case USBDEVFS_ALLOW_SUSPEND:
+		ret = proc_allow_suspend(ps);
+		break;
+	case USBDEVFS_WAIT_FOR_RESUME:
+		ret = proc_wait_for_resume(ps);
+		break;
 	}
 
 	/* Handle variable-length commands */
@@ -2651,15 +2732,20 @@ static void usbdev_remove(struct usb_device *udev)
 {
 	struct usb_dev_state *ps;
 
+	/* Protect against simultaneous resume */
+	mutex_lock(&amp;usbfs_mutex);
 	while (!list_empty(&amp;udev-&gt;filelist)) {
 		ps = list_entry(udev-&gt;filelist.next, struct usb_dev_state, list);
 		destroy_all_async(ps);
 		wake_up_all(&amp;ps-&gt;wait);
+		WRITE_ONCE(ps-&gt;not_yet_resumed, 0);
+		wake_up_all(&amp;ps-&gt;wait_for_resume);
 		list_del_init(&amp;ps-&gt;list);
 		if (ps-&gt;discsignr)
 			kill_pid_usb_asyncio(ps-&gt;discsignr, EPIPE, ps-&gt;disccontext,
 					     ps-&gt;disc_pid, ps-&gt;cred);
 	}
+	mutex_unlock(&amp;usbfs_mutex);
 }
 
 static int usbdev_notify(struct notifier_block *self,
diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index 1ac9c1e5f773..38f8b3e31762 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -257,6 +257,8 @@ static int generic_suspend(struct usb_device *udev, pm_message_t msg)
 	else
 		rc = usb_port_suspend(udev, msg);
 
+	if (rc == 0)
+		usbfs_notify_suspend(udev);
 	return rc;
 }
 
@@ -273,6 +275,9 @@ static int generic_resume(struct usb_device *udev, pm_message_t msg)
 		rc = hcd_bus_resume(udev, msg);
 	else
 		rc = usb_port_resume(udev, msg);
+
+	if (rc == 0)
+		usbfs_notify_resume(udev);
 	return rc;
 }
 
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index bd8d01f85a13..2932d1ec5def 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -95,6 +95,9 @@ extern int usb_runtime_idle(struct device *dev);
 extern int usb_enable_usb2_hardware_lpm(struct usb_device *udev);
 extern int usb_disable_usb2_hardware_lpm(struct usb_device *udev);
 
+extern void usbfs_notify_suspend(struct usb_device *udev);
+extern void usbfs_notify_resume(struct usb_device *udev);
+
 #else
 
 static inline int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
diff --git a/include/uapi/linux/usbdevice_fs.h b/include/uapi/linux/usbdevice_fs.h
index 78efe870c2b7..d24bbb6d3ca1 100644
--- a/include/uapi/linux/usbdevice_fs.h
+++ b/include/uapi/linux/usbdevice_fs.h
@@ -223,5 +223,8 @@ struct usbdevfs_streams {
  * extending size of the data returned.
  */
 #define USBDEVFS_CONNINFO_EX(len)  _IOC(_IOC_READ, 'U', 32, len)
+#define USBDEVFS_FORBID_SUSPEND    _IO('U', 33)
+#define USBDEVFS_ALLOW_SUSPEND     _IO('U', 34)
+#define USBDEVFS_WAIT_FOR_RESUME   _IO('U', 35)
 
 #endif /* _UAPI_LINUX_USBDEVICE_FS_H */</pre><hr><pre>commit 257adc0fbe9f0a26695f4d68bdbf2886f5a3ecd0
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jun 25 16:00:26 2019 -0400

    USB: core: Fix compiler warnings in devio.c
    
    In the current kernel, devio.c generates a number of compiler warnings
    about taking the address of a member of a packed structure.  The
    warnings all look like this one:
    
            drivers/usb/core/devio.c: In function ‘proc_do_submiturb’:
            drivers/usb/core/devio.c:1489:43: warning: taking address of packed member of ‘struct usb_ctrlrequest’ may result in an unaligned pointer value [-Waddress-of-packed-member]
             1489 |   if (uurb-&gt;buffer_length &lt; (le16_to_cpup(&amp;dr-&gt;wLength) + 8)) {
                  |                                           ^~~~~~~~~~~~
    
    These warnings can easily be eliminated by changing various
    le16_to_cpup() calls to use le16_to_cpu() instead.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 0100a54165cd..a951ce69f10e 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -1510,15 +1510,15 @@ static int proc_do_submiturb(struct usb_dev_state *ps, struct usbdevfs_urb *uurb
 			ret = -EFAULT;
 			goto error;
 		}
-		if (uurb-&gt;buffer_length &lt; (le16_to_cpup(&amp;dr-&gt;wLength) + 8)) {
+		if (uurb-&gt;buffer_length &lt; (le16_to_cpu(dr-&gt;wLength) + 8)) {
 			ret = -EINVAL;
 			goto error;
 		}
 		ret = check_ctrlrecip(ps, dr-&gt;bRequestType, dr-&gt;bRequest,
-				      le16_to_cpup(&amp;dr-&gt;wIndex));
+				      le16_to_cpu(dr-&gt;wIndex));
 		if (ret)
 			goto error;
-		uurb-&gt;buffer_length = le16_to_cpup(&amp;dr-&gt;wLength);
+		uurb-&gt;buffer_length = le16_to_cpu(dr-&gt;wLength);
 		uurb-&gt;buffer += 8;
 		if ((dr-&gt;bRequestType &amp; USB_DIR_IN) &amp;&amp; uurb-&gt;buffer_length) {
 			is_in = 1;
@@ -1533,9 +1533,9 @@ static int proc_do_submiturb(struct usb_dev_state *ps, struct usbdevfs_urb *uurb
 			"bRequest=%02x wValue=%04x "
 			"wIndex=%04x wLength=%04x\n",
 			dr-&gt;bRequestType, dr-&gt;bRequest,
-			__le16_to_cpup(&amp;dr-&gt;wValue),
-			__le16_to_cpup(&amp;dr-&gt;wIndex),
-			__le16_to_cpup(&amp;dr-&gt;wLength));
+			__le16_to_cpu(dr-&gt;wValue),
+			__le16_to_cpu(dr-&gt;wIndex),
+			__le16_to_cpu(dr-&gt;wLength));
 		u = sizeof(struct usb_ctrlrequest);
 		break;
 </pre>
    <div class="pagination">
        <a href='2_11.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><span>[12]</span><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_13.html'>Next&gt;&gt;</a>
    <div>
</body>
