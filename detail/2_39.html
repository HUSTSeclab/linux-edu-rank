<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_38.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><span>[39]</span><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_40.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 6402c796d3b4205d3d7296157956c5100a05d7d6
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Mar 1 10:50:08 2013 -0500

    USB: EHCI: work around silicon bug in Intel's EHCI controllers
    
    This patch (as1660) works around a hardware problem present in some
    (if not all) Intel EHCI controllers.  After a QH has been unlinked
    from the async schedule and the corresponding IAA interrupt has
    occurred, the controller is not supposed access the QH and its qTDs.
    There certainly shouldn't be any more DMA writes to those structures.
    Nevertheless, Intel's controllers have been observed to perform a
    final writeback to the QH's overlay region and to the most recent qTD.
    For more information and a test program to determine whether this
    problem is present in a particular controller, see
    
            http://marc.info/?l=linux-usb&amp;m=135492071812265&amp;w=2
            http://marc.info/?l=linux-usb&amp;m=136182570800963&amp;w=2
    
    This patch works around the problem by always waiting for two IAA
    cycles when unlinking an async QH.  The extra IAA delay gives the
    controller time to perform its final writeback.
    
    Surprisingly enough, the effects of this silicon bug have gone
    undetected until quite recently.  More through luck than anything
    else, it hasn't caused any apparent problems.  However, it does
    interact badly with the path that follows this one, so it needs to be
    addressed.
    
    This is the first part of a fix for the regression reported at:
    
            https://bugs.launchpad.net/bugs/1088733
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Stephen Thirlwall &lt;sdt@dr.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index b416a3fc9959..5726cb144abf 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -748,11 +748,9 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 		/* guard against (alleged) silicon errata */
 		if (cmd &amp; CMD_IAAD)
 			ehci_dbg(ehci, "IAA with IAAD still set?\n");
-		if (ehci-&gt;async_iaa) {
+		if (ehci-&gt;async_iaa)
 			COUNT(ehci-&gt;stats.iaa);
-			end_unlink_async(ehci);
-		} else
-			ehci_dbg(ehci, "IAA with nothing unlinked?\n");
+		end_unlink_async(ehci);
 	}
 
 	/* remote wakeup [4.3.1] */
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index fd252f0cfb3a..7bf2b4eeb9ce 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -1170,7 +1170,7 @@ static void single_unlink_async(struct ehci_hcd *ehci, struct ehci_qh *qh)
 	struct ehci_qh		*prev;
 
 	/* Add to the end of the list of QHs waiting for the next IAAD */
-	qh-&gt;qh_state = QH_STATE_UNLINK;
+	qh-&gt;qh_state = QH_STATE_UNLINK_WAIT;
 	if (ehci-&gt;async_unlink)
 		ehci-&gt;async_unlink_last-&gt;unlink_next = qh;
 	else
@@ -1213,9 +1213,19 @@ static void start_iaa_cycle(struct ehci_hcd *ehci, bool nested)
 
 		/* Do only the first waiting QH (nVidia bug?) */
 		qh = ehci-&gt;async_unlink;
-		ehci-&gt;async_iaa = qh;
-		ehci-&gt;async_unlink = qh-&gt;unlink_next;
-		qh-&gt;unlink_next = NULL;
+
+		/*
+		 * Intel (?) bug: The HC can write back the overlay region
+		 * even after the IAA interrupt occurs.  In self-defense,
+		 * always go through two IAA cycles for each QH.
+		 */
+		if (qh-&gt;qh_state == QH_STATE_UNLINK_WAIT) {
+			qh-&gt;qh_state = QH_STATE_UNLINK;
+		} else {
+			ehci-&gt;async_iaa = qh;
+			ehci-&gt;async_unlink = qh-&gt;unlink_next;
+			qh-&gt;unlink_next = NULL;
+		}
 
 		/* Make sure the unlinks are all visible to the hardware */
 		wmb();</pre><hr><pre>commit 221f8dfca89276d8aec54c6d07fbe20c281668f0
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Feb 26 13:43:41 2013 -0500

    USB: EHCI: revert "remove ASS/PSS polling timeout"
    
    This patch (as1649) reverts commit
    55bcdce8a8228223ec4d17d8ded8134ed265d2c5 (USB: EHCI: remove ASS/PSS
    polling timeout).  That commit was written under the assumption that
    some controllers may take a very long time to turn off their async and
    periodic schedules.  It now appears that in fact the schedules do get
    turned off reasonably quickly, but some controllers occasionally leave
    the schedules' status bits turned on and consequently ehci-hcd can't
    tell that the schedules are off.
    
    VIA controllers in particular have this problem.  ehci-hcd tells the
    hardware to turn off the async schedule, the schedule does get turned
    off, but the status bit remains on.  Since the EHCI spec requires that
    the schedules not be re-enabled until the previous disable has taken
    effect, with an unlimited timeout the async schedule never gets turned
    back on.  The resulting symptom is that the system is unable to
    communicate with USB devices.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Ronald &lt;ronald645@gmail.com&gt;
    Reported-and-tested-by: Paul Hartman &lt;paul.hartman@gmail.com&gt;
    Reported-and-tested-by: Dieter NÃ¼tzel &lt;dieter@nuetzel-hh.de&gt;
    Reported-and-tested-by: Jean Delvare &lt;khali@linux-fr.org&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index f904071d70df..20dbdcbe9b0f 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -113,15 +113,14 @@ static void ehci_poll_ASS(struct ehci_hcd *ehci)
 
 	if (want != actual) {
 
-		/* Poll again later */
-		ehci_enable_event(ehci, EHCI_HRTIMER_POLL_ASS, true);
-		++ehci-&gt;ASS_poll_count;
-		return;
+		/* Poll again later, but give up after about 20 ms */
+		if (ehci-&gt;ASS_poll_count++ &lt; 20) {
+			ehci_enable_event(ehci, EHCI_HRTIMER_POLL_ASS, true);
+			return;
+		}
+		ehci_dbg(ehci, "Waited too long for the async schedule status (%x/%x), giving up\n",
+				want, actual);
 	}
-
-	if (ehci-&gt;ASS_poll_count &gt; 20)
-		ehci_dbg(ehci, "ASS poll count reached %d\n",
-				ehci-&gt;ASS_poll_count);
 	ehci-&gt;ASS_poll_count = 0;
 
 	/* The status is up-to-date; restart or stop the schedule as needed */
@@ -160,14 +159,14 @@ static void ehci_poll_PSS(struct ehci_hcd *ehci)
 
 	if (want != actual) {
 
-		/* Poll again later */
-		ehci_enable_event(ehci, EHCI_HRTIMER_POLL_PSS, true);
-		return;
+		/* Poll again later, but give up after about 20 ms */
+		if (ehci-&gt;PSS_poll_count++ &lt; 20) {
+			ehci_enable_event(ehci, EHCI_HRTIMER_POLL_PSS, true);
+			return;
+		}
+		ehci_dbg(ehci, "Waited too long for the periodic schedule status (%x/%x), giving up\n",
+				want, actual);
 	}
-
-	if (ehci-&gt;PSS_poll_count &gt; 20)
-		ehci_dbg(ehci, "PSS poll count reached %d\n",
-				ehci-&gt;PSS_poll_count);
 	ehci-&gt;PSS_poll_count = 0;
 
 	/* The status is up-to-date; restart or stop the schedule as needed */</pre><hr><pre>commit 3e619d04159be54b3daa0b7036b0ce9e067f4b5d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jan 30 16:36:40 2013 -0500

    USB: EHCI: fix bug in scheduling periodic split transfers
    
    This patch (as1654) fixes a very old bug in ehci-hcd, connected with
    scheduling of periodic split transfers.  The calculations for
    full/low-speed bus usage are all carried out after the correction for
    bit-stuffing has been applied, but the values in the max_tt_usecs
    array assume it hasn't been.  The array should allow for allocation of
    up to 90% of the bus capacity, which is 900 us, not 780 us.
    
    The symptom caused by this bug is that any isochronous transfer to a
    full-speed device with a maxpacket size larger than about 980 bytes is
    always rejected with a -ENOSPC error.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 2b6917dc3996..b476daf49f6f 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -213,7 +213,7 @@ static inline unsigned char tt_start_uframe(struct ehci_hcd *ehci, __hc32 mask)
 }
 
 static const unsigned char
-max_tt_usecs[] = { 125, 125, 125, 125, 125, 125, 30, 0 };
+max_tt_usecs[] = { 125, 125, 125, 125, 125, 125, 125, 25 };
 
 /* carryover low/fullspeed bandwidth that crosses uframe boundries */
 static inline void carryover_tt_bandwidth(unsigned short tt_usecs[8])</pre><hr><pre>commit b09a61cc0bc2a7151f4ab652489e85253d5d0175
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jan 30 16:35:02 2013 -0500

    USB: EHCI: fix for leaking isochronous data
    
    This patch (as1653) fixes a bug in ehci-hcd.  Unlike iTD entries, an
    siTD entry in the periodic schedule may not complete until the frame
    after the one it belongs to.  Consequently, when scanning the periodic
    schedule it is necessary to start with the frame _preceding_ the one
    where the previous scan ended.
    
    Not doing this properly can result in memory leaks and failures to
    complete isochronous URBs.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Andy Leiserson &lt;andy@leiserson.org&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 69ebee73c0c1..2b6917dc3996 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -2212,11 +2212,11 @@ static void scan_isoc(struct ehci_hcd *ehci)
 	}
 	ehci-&gt;now_frame = now_frame;
 
+	frame = ehci-&gt;last_iso_frame;
 	for (;;) {
 		union ehci_shadow	q, *q_p;
 		__hc32			type, *hw_p;
 
-		frame = ehci-&gt;last_iso_frame;
 restart:
 		/* scan each element in frame's queue for completions */
 		q_p = &amp;ehci-&gt;pshadow [frame];
@@ -2321,6 +2321,9 @@ static void scan_isoc(struct ehci_hcd *ehci)
 		/* Stop when we have reached the current frame */
 		if (frame == now_frame)
 			break;
-		ehci-&gt;last_iso_frame = (frame + 1) &amp; fmask;
+
+		/* The last frame may still have active siTDs */
+		ehci-&gt;last_iso_frame = frame;
+		frame = (frame + 1) &amp; fmask;
 	}
 }</pre><hr><pre>commit 2f0760774711c957c395b31131b848043af98edf
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jan 30 16:40:14 2013 -0500

    USB: GADGET: optionally force full-speed for net2280 UDC
    
    This patch (as1656) adds a module parameter to the net2280 UDC driver
    to force full-speed operation.  It is intended for testing purposes,
    where one wants to check how well a full-speed device performs when
    attached to a high-speed bus.  Without this parameter it would be
    necessary to interpose a full-speed hub; otherwise the net2280 would
    connect at high speed.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Felipe Balbi &lt;balbi@ti.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/gadget/net2280.c b/drivers/usb/gadget/net2280.c
index 708c0b55dcc8..a1b650e11339 100644
--- a/drivers/usb/gadget/net2280.c
+++ b/drivers/usb/gadget/net2280.c
@@ -116,6 +116,10 @@ static bool enable_suspend = 0;
 /* "modprobe net2280 enable_suspend=1" etc */
 module_param (enable_suspend, bool, S_IRUGO);
 
+/* force full-speed operation */
+static bool full_speed;
+module_param(full_speed, bool, 0444);
+MODULE_PARM_DESC(full_speed, "force full-speed mode -- for testing only!");
 
 #define	DIR_STRING(bAddress) (((bAddress) &amp; USB_DIR_IN) ? "in" : "out")
 
@@ -1899,6 +1903,10 @@ static int net2280_start(struct usb_gadget *_gadget,
 	retval = device_create_file (&amp;dev-&gt;pdev-&gt;dev, &amp;dev_attr_queues);
 	if (retval) goto err_func;
 
+	/* Enable force-full-speed testing mode, if desired */
+	if (full_speed)
+		writel(1 &lt;&lt; FORCE_FULL_SPEED_MODE, &amp;dev-&gt;usb-&gt;xcvrdiag);
+
 	/* ... then enable host detection and ep0; and we're ready
 	 * for set_configuration as well as eventual disconnect.
 	 */
@@ -1957,6 +1965,10 @@ static int net2280_stop(struct usb_gadget *_gadget,
 	dev-&gt;driver = NULL;
 
 	net2280_led_active (dev, 0);
+
+	/* Disable full-speed test mode */
+	writel(0, &amp;dev-&gt;usb-&gt;xcvrdiag);
+
 	device_remove_file (&amp;dev-&gt;pdev-&gt;dev, &amp;dev_attr_function);
 	device_remove_file (&amp;dev-&gt;pdev-&gt;dev, &amp;dev_attr_queues);
 
@@ -2841,6 +2853,9 @@ static void net2280_shutdown (struct pci_dev *pdev)
 
 	/* disable the pullup so the host will think we're gone */
 	writel (0, &amp;dev-&gt;usb-&gt;usbctl);
+
+	/* Disable full-speed test mode */
+	writel(0, &amp;dev-&gt;usb-&gt;xcvrdiag);
 }
 
 </pre><hr><pre>commit d0b4652f80c3276a57ede3b6b6d8159fa26c091f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jan 30 16:38:11 2013 -0500

    USB: altsetting overrides for usbtest
    
    The usbtest driver includes some rather simple-minded logic for
    selecting an altsetting to test.  It doesn't work well for the g_zero
    gadget, because it selects altsetting 0 (which doesn't have
    isochronous endpoints) rather than altsetting 1 (which does have them,
    if the gadget's hardware supports them).  This prevents usbtest's
    isochronous tests (15, 16, 22, and 23) from working with g_zero.
    
    Since g_zero is one of the most common gadget drivers used for USB
    testing, usbtest should do a better job of supporting it.  But since
    some programs may rely on the current scheme for selecting
    altsettings, I didn't want to change it.
    
    Instead, this patch (as1655) adds a module parameter to usbtest, which
    can be used to override the default altsetting.  Since usbtest is
    never used by normal users (most distributions probably don't even
    build it), the new module parameter won't inconvenience anybody.  In
    any case, it is entirely optional -- leaving it unset preserves the
    existing behavior.
    
    The patch also fixes a related bug in usbtest: After selecting an
    altsetting, the driver neglects to store its selection.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 268148de9714..8b4ca1cb450a 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -11,6 +11,12 @@
 #include &lt;linux/usb.h&gt;
 
 
+/*-------------------------------------------------------------------------*/
+
+static int override_alt = -1;
+module_param_named(alt, override_alt, int, 0644);
+MODULE_PARM_DESC(alt, "&gt;= 0 to override altsetting selection");
+
 /*-------------------------------------------------------------------------*/
 
 /* FIXME make these public somewhere; usbdevfs.h? */
@@ -103,6 +109,10 @@ get_endpoints(struct usbtest_dev *dev, struct usb_interface *intf)
 		iso_in = iso_out = NULL;
 		alt = intf-&gt;altsetting + tmp;
 
+		if (override_alt &gt;= 0 &amp;&amp;
+				override_alt != alt-&gt;desc.bAlternateSetting)
+			continue;
+
 		/* take the first altsetting with in-bulk + out-bulk;
 		 * ignore other endpoints and altsettings.
 		 */
@@ -144,6 +154,7 @@ get_endpoints(struct usbtest_dev *dev, struct usb_interface *intf)
 
 found:
 	udev = testdev_to_usbdev(dev);
+	dev-&gt;info-&gt;alt = alt-&gt;desc.bAlternateSetting;
 	if (alt-&gt;desc.bAlternateSetting != 0) {
 		tmp = usb_set_interface(udev,
 				alt-&gt;desc.bInterfaceNumber,
@@ -2280,7 +2291,7 @@ usbtest_probe(struct usb_interface *intf, const struct usb_device_id *id)
 			wtest = " intr-out";
 		}
 	} else {
-		if (info-&gt;autoconf) {
+		if (override_alt &gt;= 0 || info-&gt;autoconf) {
 			int status;
 
 			status = get_endpoints(dev, intf);</pre><hr><pre>commit ee74290b7853db9d5fd64db70e5c175241c59fba
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jan 25 17:17:43 2013 -0500

    USB: EHCI: fix timer bug affecting port resume
    
    This patch (as1652) fixes a long-standing bug in ehci-hcd.  The driver
    relies on status polls to know when to stop port-resume signalling.
    It uses the root-hub status timer to schedule these status polls.  But
    when the driver for the root hub is resumed, the timer is rescheduled
    to go off immediately -- before the port is ready.  When this happens
    the timer does not get re-enabled, which prevents the port resume from
    finishing until some other event occurs.
    
    The symptom is that when a new device is plugged in, it doesn't get
    recognized or enumerated until lsusb is run or something else happens.
    
    The solution is to re-enable the root-hub status timer after every
    status poll while a port resume is in progress.
    
    This bug hasn't surfaced before now because we never used to try to
    suspend the root hub in the middle of a port resume (except by
    coincidence).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Norbert Preining &lt;preining@logic.at&gt;
    Tested-by: Ming Lei &lt;ming.lei@canonical.com&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index f88be801d60c..4d3b294f203e 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -649,7 +649,11 @@ ehci_hub_status_data (struct usb_hcd *hcd, char *buf)
 			status = STS_PCD;
 		}
 	}
-	/* FIXME autosuspend idle root hubs */
+
+	/* If a resume is in progress, make sure it can finish */
+	if (ehci-&gt;resuming_ports)
+		mod_timer(&amp;hcd-&gt;rh_timer, jiffies + msecs_to_jiffies(25));
+
 	spin_unlock_irqrestore (&amp;ehci-&gt;lock, flags);
 	return status ? retval : 0;
 }</pre><hr><pre>commit 840008bb5162f029d5bc05959c7f51a3e8f9e0ff
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jan 25 17:09:55 2013 -0500

    USB: UHCI: notify usbcore about port resumes
    
    This patch (as1651) adds calls to the new
    usb_hcd_{start,end}_port_resume() functions to uhci-hcd.  Now UHCI
    root hubs won't be runtime suspended while they are sending a resume
    signal to one of their ports.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/uhci-hub.c b/drivers/usb/host/uhci-hub.c
index 768d54295a20..15d13229ddbb 100644
--- a/drivers/usb/host/uhci-hub.c
+++ b/drivers/usb/host/uhci-hub.c
@@ -116,6 +116,7 @@ static void uhci_finish_suspend(struct uhci_hcd *uhci, int port,
 		}
 	}
 	clear_bit(port, &amp;uhci-&gt;resuming_ports);
+	usb_hcd_end_port_resume(&amp;uhci_to_hcd(uhci)-&gt;self, port);
 }
 
 /* Wait for the UHCI controller in HP's iLO2 server management chip.
@@ -167,6 +168,8 @@ static void uhci_check_ports(struct uhci_hcd *uhci)
 				set_bit(port, &amp;uhci-&gt;resuming_ports);
 				uhci-&gt;ports_timeout = jiffies +
 						msecs_to_jiffies(25);
+				usb_hcd_start_port_resume(
+						&amp;uhci_to_hcd(uhci)-&gt;self, port);
 
 				/* Make sure we see the port again
 				 * after the resuming period is over. */</pre><hr><pre>commit f292e7f9fb0e4bec68bbd83443407d6bb7922d36
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jan 25 17:09:49 2013 -0500

    USB: EHCI: notify usbcore about port resumes
    
    This patch (as1650) adds calls to the new
    usb_hcd_{start,end}_port_resume() functions to ehci-hcd.  Now EHCI
    root hubs won't be runtime suspended while they are sending a resume
    signal to one of their ports.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Ming Lei &lt;ming.lei@canonical.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 09537b2f1002..b416a3fc9959 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -797,6 +797,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 			ehci-&gt;reset_done[i] = jiffies + msecs_to_jiffies(25);
 			set_bit(i, &amp;ehci-&gt;resuming_ports);
 			ehci_dbg (ehci, "port %d remote wakeup\n", i + 1);
+			usb_hcd_start_port_resume(&amp;hcd-&gt;self, i);
 			mod_timer(&amp;hcd-&gt;rh_timer, ehci-&gt;reset_done[i]);
 		}
 	}
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 4ccb97c0678f..f88be801d60c 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -851,6 +851,7 @@ static int ehci_hub_control (
 				/* resume signaling for 20 msec */
 				ehci-&gt;reset_done[wIndex] = jiffies
 						+ msecs_to_jiffies(20);
+				usb_hcd_start_port_resume(&amp;hcd-&gt;self, wIndex);
 				/* check the port again */
 				mod_timer(&amp;ehci_to_hcd(ehci)-&gt;rh_timer,
 						ehci-&gt;reset_done[wIndex]);
@@ -862,6 +863,7 @@ static int ehci_hub_control (
 				clear_bit(wIndex, &amp;ehci-&gt;suspended_ports);
 				set_bit(wIndex, &amp;ehci-&gt;port_c_suspend);
 				ehci-&gt;reset_done[wIndex] = 0;
+				usb_hcd_end_port_resume(&amp;hcd-&gt;self, wIndex);
 
 				/* stop resume signaling */
 				temp = ehci_readl(ehci, status_reg);
@@ -950,6 +952,7 @@ static int ehci_hub_control (
 			ehci-&gt;reset_done[wIndex] = 0;
 			if (temp &amp; PORT_PE)
 				set_bit(wIndex, &amp;ehci-&gt;port_c_suspend);
+			usb_hcd_end_port_resume(&amp;hcd-&gt;self, wIndex);
 		}
 
 		if (temp &amp; PORT_OC)</pre><hr><pre>commit da0aa7169b97d90f4af39a9dc84d58bbe19d7e78
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jan 25 17:09:42 2013 -0500

    USB: add usb_hcd_{start,end}_port_resume
    
    This patch (as1649) adds a mechanism for host controller drivers to
    inform usbcore when they have begun or ended resume signalling on a
    particular root-hub port.  The core will then make sure that the root
    hub does not get runtime-suspended while the port resume is going on.
    
    Since commit 596d789a211d134dc5f94d1e5957248c204ef850 (USB: set hub's
    default autosuspend delay as 0), the system tries to suspend hubs
    whenever they aren't in use.  While a root-hub port is being resumed,
    the root hub does not appear to be in use.  Attempted runtime suspends
    fail because of the ongoing port resume, but the PM core just keeps on
    trying over and over again.  We want to prevent this wasteful effort.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Ming Lei &lt;ming.lei@canonical.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 4225d5e72131..8e64adf8e4d5 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -39,6 +39,7 @@
 #include &lt;asm/unaligned.h&gt;
 #include &lt;linux/platform_device.h&gt;
 #include &lt;linux/workqueue.h&gt;
+#include &lt;linux/pm_runtime.h&gt;
 
 #include &lt;linux/usb.h&gt;
 #include &lt;linux/usb/hcd.h&gt;
@@ -1025,6 +1026,49 @@ static int register_root_hub(struct usb_hcd *hcd)
 	return retval;
 }
 
+/*
+ * usb_hcd_start_port_resume - a root-hub port is sending a resume signal
+ * @bus: the bus which the root hub belongs to
+ * @portnum: the port which is being resumed
+ *
+ * HCDs should call this function when they know that a resume signal is
+ * being sent to a root-hub port.  The root hub will be prevented from
+ * going into autosuspend until usb_hcd_end_port_resume() is called.
+ *
+ * The bus's private lock must be held by the caller.
+ */
+void usb_hcd_start_port_resume(struct usb_bus *bus, int portnum)
+{
+	unsigned bit = 1 &lt;&lt; portnum;
+
+	if (!(bus-&gt;resuming_ports &amp; bit)) {
+		bus-&gt;resuming_ports |= bit;
+		pm_runtime_get_noresume(&amp;bus-&gt;root_hub-&gt;dev);
+	}
+}
+EXPORT_SYMBOL_GPL(usb_hcd_start_port_resume);
+
+/*
+ * usb_hcd_end_port_resume - a root-hub port has stopped sending a resume signal
+ * @bus: the bus which the root hub belongs to
+ * @portnum: the port which is being resumed
+ *
+ * HCDs should call this function when they know that a resume signal has
+ * stopped being sent to a root-hub port.  The root hub will be allowed to
+ * autosuspend again.
+ *
+ * The bus's private lock must be held by the caller.
+ */
+void usb_hcd_end_port_resume(struct usb_bus *bus, int portnum)
+{
+	unsigned bit = 1 &lt;&lt; portnum;
+
+	if (bus-&gt;resuming_ports &amp; bit) {
+		bus-&gt;resuming_ports &amp;= ~bit;
+		pm_runtime_put_noidle(&amp;bus-&gt;root_hub-&gt;dev);
+	}
+}
+EXPORT_SYMBOL_GPL(usb_hcd_end_port_resume);
 
 /*-------------------------------------------------------------------------*/
 
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 689b14b26c8d..4d22d0f6167a 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -357,6 +357,8 @@ struct usb_bus {
 	int bandwidth_int_reqs;		/* number of Interrupt requests */
 	int bandwidth_isoc_reqs;	/* number of Isoc. requests */
 
+	unsigned resuming_ports;	/* bit array: resuming root-hub ports */
+
 #if defined(CONFIG_USB_MON) || defined(CONFIG_USB_MON_MODULE)
 	struct mon_bus *mon_bus;	/* non-null when associated */
 	int monitored;			/* non-zero when monitored */
diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 608050b2545f..0a78df5f6cfd 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -430,6 +430,9 @@ extern void usb_hcd_poll_rh_status(struct usb_hcd *hcd);
 extern void usb_wakeup_notification(struct usb_device *hdev,
 		unsigned int portnum);
 
+extern void usb_hcd_start_port_resume(struct usb_bus *bus, int portnum);
+extern void usb_hcd_end_port_resume(struct usb_bus *bus, int portnum);
+
 /* The D0/D1 toggle bits ... USE WITH CAUTION (they're almost hcd-internal) */
 #define usb_gettoggle(dev, ep, out) (((dev)-&gt;toggle[out] &gt;&gt; (ep)) &amp; 1)
 #define	usb_dotoggle(dev, ep, out)  ((dev)-&gt;toggle[out] ^= (1 &lt;&lt; (ep)))</pre>
    <div class="pagination">
        <a href='2_38.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><span>[39]</span><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_40.html'>Next&gt;&gt;</a>
    <div>
</body>
