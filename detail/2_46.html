<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_45.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><span>[46]</span><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_47.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 55934eb3b9fa52eb53b9d7342267fc73c38206aa
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 11 11:22:35 2012 -0400

    USB: EHCI: use hrtimer for (s)iTD deallocation
    
    This patch (as1579) adds an hrtimer event to handle deallocation of
    iTDs and siTDs in ehci-hcd.
    
    Because of the frame-oriented approach used by the EHCI periodic
    schedule, the hardware can continue to access the Transfer Descriptor
    for isochronous (or split-isochronous) transactions for up to a
    millisecond after the transaction completes.  The iTD (or siTD) must
    not be reused before then.
    
    The strategy currently used involves putting completed iTDs on a list
    of cached entries and every so often returning them to the endpoint's
    free list.  The new strategy reduces overhead by putting completed
    iTDs back on the free list immediately, although they are not reused
    until it is safe to do so.
    
    When the isochronous endpoint stops (its queue becomes empty), the
    iTDs on its free list get moved to a global list, from which they will
    be deallocated after a minimum of 2 ms.  This delay is what the new
    hrtimer event is for.
    
    Overall this may not be a tremendous improvement over the current
    code, but to me it seems a lot more clear and logical.  In addition,
    it removes the need for each iTD to keep a reference to the
    ehci_iso_stream it belongs to, since the iTD never needs to be moved
    back to the stream's free list from the global list.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 1676c66b8530..98b945840c9e 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -509,6 +509,7 @@ static void ehci_stop (struct usb_hcd *hcd)
 	spin_lock_irq (&amp;ehci-&gt;lock);
 	if (ehci-&gt;async)
 		ehci_work (ehci);
+	end_free_itds(ehci);
 	spin_unlock_irq (&amp;ehci-&gt;lock);
 	ehci_mem_cleanup (ehci);
 
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 8aa740dc510d..6ad806bbe468 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -303,6 +303,7 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 	if (ehci-&gt;async_unlink)
 		end_unlink_async(ehci);
 	ehci_handle_intr_unlinks(ehci);
+	end_free_itds(ehci);
 
 	/* allow remote wakeup */
 	mask = INTR_MASK;
diff --git a/drivers/usb/host/ehci-mem.c b/drivers/usb/host/ehci-mem.c
index 93132d8ad360..ef2c3a1eca4b 100644
--- a/drivers/usb/host/ehci-mem.c
+++ b/drivers/usb/host/ehci-mem.c
@@ -118,7 +118,6 @@ static struct ehci_qh *ehci_qh_alloc (struct ehci_hcd *ehci, gfp_t flags)
 
 static void ehci_mem_cleanup (struct ehci_hcd *ehci)
 {
-	free_cached_lists(ehci);
 	if (ehci-&gt;async)
 		qh_destroy(ehci, ehci-&gt;async);
 	ehci-&gt;async = NULL;
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index eec8446f8ded..1e4f13c11b6a 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -1045,31 +1045,6 @@ iso_stream_put(struct ehci_hcd *ehci, struct ehci_iso_stream *stream)
 	if (stream-&gt;refcount == 1) {
 		// BUG_ON (!list_empty(&amp;stream-&gt;td_list));
 
-		while (!list_empty (&amp;stream-&gt;free_list)) {
-			struct list_head	*entry;
-
-			entry = stream-&gt;free_list.next;
-			list_del (entry);
-
-			/* knows about ITD vs SITD */
-			if (stream-&gt;highspeed) {
-				struct ehci_itd		*itd;
-
-				itd = list_entry (entry, struct ehci_itd,
-						itd_list);
-				dma_pool_free (ehci-&gt;itd_pool, itd,
-						itd-&gt;itd_dma);
-			} else {
-				struct ehci_sitd	*sitd;
-
-				sitd = list_entry (entry, struct ehci_sitd,
-						sitd_list);
-				dma_pool_free (ehci-&gt;sitd_pool, sitd,
-						sitd-&gt;sitd_dma);
-			}
-		}
-
-		stream-&gt;bEndpointAddress &amp;= 0x0f;
 		if (stream-&gt;ep)
 			stream-&gt;ep-&gt;hcpriv = NULL;
 
@@ -1230,17 +1205,19 @@ itd_urb_transaction (
 	spin_lock_irqsave (&amp;ehci-&gt;lock, flags);
 	for (i = 0; i &lt; num_itds; i++) {
 
-		/* free_list.next might be cache-hot ... but maybe
-		 * the HC caches it too. avoid that issue for now.
+		/*
+		 * Use iTDs from the free list, but not iTDs that may
+		 * still be in use by the hardware.
 		 */
-
-		/* prefer previously-allocated itds */
-		if (likely (!list_empty(&amp;stream-&gt;free_list))) {
-			itd = list_entry (stream-&gt;free_list.prev,
+		if (likely(!list_empty(&amp;stream-&gt;free_list))) {
+			itd = list_first_entry(&amp;stream-&gt;free_list,
 					struct ehci_itd, itd_list);
+			if (itd-&gt;frame == ehci-&gt;clock_frame)
+				goto alloc_itd;
 			list_del (&amp;itd-&gt;itd_list);
 			itd_dma = itd-&gt;itd_dma;
 		} else {
+ alloc_itd:
 			spin_unlock_irqrestore (&amp;ehci-&gt;lock, flags);
 			itd = dma_pool_alloc (ehci-&gt;itd_pool, mem_flags,
 					&amp;itd_dma);
@@ -1762,24 +1739,18 @@ itd_complete (
 
 done:
 	itd-&gt;urb = NULL;
-	if (ehci-&gt;clock_frame != itd-&gt;frame || itd-&gt;index[7] != -1) {
-		/* OK to recycle this ITD now. */
-		itd-&gt;stream = NULL;
-		list_move(&amp;itd-&gt;itd_list, &amp;stream-&gt;free_list);
-		iso_stream_put(ehci, stream);
-	} else {
-		/* HW might remember this ITD, so we can't recycle it yet.
-		 * Move it to a safe place until a new frame starts.
-		 */
-		list_move(&amp;itd-&gt;itd_list, &amp;ehci-&gt;cached_itd_list);
-		if (stream-&gt;refcount == 2) {
-			/* If iso_stream_put() were called here, stream
-			 * would be freed.  Instead, just prevent reuse.
-			 */
-			stream-&gt;ep-&gt;hcpriv = NULL;
-			stream-&gt;ep = NULL;
-		}
+
+	/* Add to the end of the free list for later reuse */
+	list_move_tail(&amp;itd-&gt;itd_list, &amp;stream-&gt;free_list);
+
+	/* Recycle the iTDs when the pipeline is empty (ep no longer in use) */
+	if (list_empty(&amp;stream-&gt;td_list)) {
+		list_splice_tail_init(&amp;stream-&gt;free_list,
+				&amp;ehci-&gt;cached_itd_list);
+		start_free_itds(ehci);
 	}
+
+	iso_stream_put(ehci, stream);
 	return retval;
 }
 
@@ -1930,17 +1901,19 @@ sitd_urb_transaction (
 		 * means we never need two sitds for full speed packets.
 		 */
 
-		/* free_list.next might be cache-hot ... but maybe
-		 * the HC caches it too. avoid that issue for now.
+		/*
+		 * Use siTDs from the free list, but not siTDs that may
+		 * still be in use by the hardware.
 		 */
-
-		/* prefer previously-allocated sitds */
-		if (!list_empty(&amp;stream-&gt;free_list)) {
-			sitd = list_entry (stream-&gt;free_list.prev,
+		if (likely(!list_empty(&amp;stream-&gt;free_list))) {
+			sitd = list_first_entry(&amp;stream-&gt;free_list,
 					 struct ehci_sitd, sitd_list);
+			if (sitd-&gt;frame == ehci-&gt;clock_frame)
+				goto alloc_sitd;
 			list_del (&amp;sitd-&gt;sitd_list);
 			sitd_dma = sitd-&gt;sitd_dma;
 		} else {
+ alloc_sitd:
 			spin_unlock_irqrestore (&amp;ehci-&gt;lock, flags);
 			sitd = dma_pool_alloc (ehci-&gt;sitd_pool, mem_flags,
 					&amp;sitd_dma);
@@ -2157,24 +2130,18 @@ sitd_complete (
 
 done:
 	sitd-&gt;urb = NULL;
-	if (ehci-&gt;clock_frame != sitd-&gt;frame) {
-		/* OK to recycle this SITD now. */
-		sitd-&gt;stream = NULL;
-		list_move(&amp;sitd-&gt;sitd_list, &amp;stream-&gt;free_list);
-		iso_stream_put(ehci, stream);
-	} else {
-		/* HW might remember this SITD, so we can't recycle it yet.
-		 * Move it to a safe place until a new frame starts.
-		 */
-		list_move(&amp;sitd-&gt;sitd_list, &amp;ehci-&gt;cached_sitd_list);
-		if (stream-&gt;refcount == 2) {
-			/* If iso_stream_put() were called here, stream
-			 * would be freed.  Instead, just prevent reuse.
-			 */
-			stream-&gt;ep-&gt;hcpriv = NULL;
-			stream-&gt;ep = NULL;
-		}
+
+	/* Add to the end of the free list for later reuse */
+	list_move_tail(&amp;sitd-&gt;sitd_list, &amp;stream-&gt;free_list);
+
+	/* Recycle the siTDs when the pipeline is empty (ep no longer in use) */
+	if (list_empty(&amp;stream-&gt;td_list)) {
+		list_splice_tail_init(&amp;stream-&gt;free_list,
+				&amp;ehci-&gt;cached_sitd_list);
+		start_free_itds(ehci);
 	}
+
+	iso_stream_put(ehci, stream);
 	return retval;
 }
 
@@ -2239,28 +2206,6 @@ static int sitd_submit (struct ehci_hcd *ehci, struct urb *urb,
 
 /*-------------------------------------------------------------------------*/
 
-static void free_cached_lists(struct ehci_hcd *ehci)
-{
-	struct ehci_itd *itd, *n;
-	struct ehci_sitd *sitd, *sn;
-
-	list_for_each_entry_safe(itd, n, &amp;ehci-&gt;cached_itd_list, itd_list) {
-		struct ehci_iso_stream	*stream = itd-&gt;stream;
-		itd-&gt;stream = NULL;
-		list_move(&amp;itd-&gt;itd_list, &amp;stream-&gt;free_list);
-		iso_stream_put(ehci, stream);
-	}
-
-	list_for_each_entry_safe(sitd, sn, &amp;ehci-&gt;cached_sitd_list, sitd_list) {
-		struct ehci_iso_stream	*stream = sitd-&gt;stream;
-		sitd-&gt;stream = NULL;
-		list_move(&amp;sitd-&gt;sitd_list, &amp;stream-&gt;free_list);
-		iso_stream_put(ehci, stream);
-	}
-}
-
-/*-------------------------------------------------------------------------*/
-
 static void
 scan_periodic (struct ehci_hcd *ehci)
 {
@@ -2282,10 +2227,7 @@ scan_periodic (struct ehci_hcd *ehci)
 		clock = now_uframe + mod - 1;
 		clock_frame = -1;
 	}
-	if (ehci-&gt;clock_frame != clock_frame) {
-		free_cached_lists(ehci);
-		ehci-&gt;clock_frame = clock_frame;
-	}
+	ehci-&gt;clock_frame = clock_frame;
 	clock &amp;= mod - 1;
 	clock_frame = clock &gt;&gt; 3;
 	++ehci-&gt;periodic_stamp;
@@ -2463,7 +2405,6 @@ scan_periodic (struct ehci_hcd *ehci)
 			clock = now;
 			clock_frame = clock &gt;&gt; 3;
 			if (ehci-&gt;clock_frame != clock_frame) {
-				free_cached_lists(ehci);
 				ehci-&gt;clock_frame = clock_frame;
 				++ehci-&gt;periodic_stamp;
 			}
diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index 0c5326a8883c..8feb60ff4228 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -71,6 +71,7 @@ static unsigned event_delays_ns[] = {
 	1 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_POLL_PSS */
 	1 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_POLL_DEAD */
 	1125 * NSEC_PER_USEC,	/* EHCI_HRTIMER_UNLINK_INTR */
+	2 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_FREE_ITDS */
 	10 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_DISABLE_PERIODIC */
 	15 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_DISABLE_ASYNC */
 };
@@ -165,7 +166,6 @@ static void ehci_poll_PSS(struct ehci_hcd *ehci)
 
 	/* The status is up-to-date; restart or stop the schedule as needed */
 	if (want == 0) {	/* Stopped */
-		free_cached_lists(ehci);
 		if (ehci-&gt;periodic_count &gt; 0) {
 
 			/* make sure ehci_work scans these */
@@ -188,9 +188,6 @@ static void ehci_poll_PSS(struct ehci_hcd *ehci)
 static void ehci_disable_PSE(struct ehci_hcd *ehci)
 {
 	ehci_clear_command_bit(ehci, CMD_PSE);
-
-	/* Poll to see when it actually stops */
-	ehci_enable_event(ehci, EHCI_HRTIMER_POLL_PSS, true);
 }
 
 
@@ -250,6 +247,50 @@ static void ehci_handle_intr_unlinks(struct ehci_hcd *ehci)
 }
 
 
+/* Start another free-iTDs/siTDs cycle */
+static void start_free_itds(struct ehci_hcd *ehci)
+{
+	if (!(ehci-&gt;enabled_hrtimer_events &amp; BIT(EHCI_HRTIMER_FREE_ITDS))) {
+		ehci-&gt;last_itd_to_free = list_entry(
+				ehci-&gt;cached_itd_list.prev,
+				struct ehci_itd, itd_list);
+		ehci-&gt;last_sitd_to_free = list_entry(
+				ehci-&gt;cached_sitd_list.prev,
+				struct ehci_sitd, sitd_list);
+		ehci_enable_event(ehci, EHCI_HRTIMER_FREE_ITDS, true);
+	}
+}
+
+/* Wait for controller to stop using old iTDs and siTDs */
+static void end_free_itds(struct ehci_hcd *ehci)
+{
+	struct ehci_itd		*itd, *n;
+	struct ehci_sitd	*sitd, *sn;
+
+	if (ehci-&gt;rh_state &lt; EHCI_RH_RUNNING) {
+		ehci-&gt;last_itd_to_free = NULL;
+		ehci-&gt;last_sitd_to_free = NULL;
+	}
+
+	list_for_each_entry_safe(itd, n, &amp;ehci-&gt;cached_itd_list, itd_list) {
+		list_del(&amp;itd-&gt;itd_list);
+		dma_pool_free(ehci-&gt;itd_pool, itd, itd-&gt;itd_dma);
+		if (itd == ehci-&gt;last_itd_to_free)
+			break;
+	}
+	list_for_each_entry_safe(sitd, sn, &amp;ehci-&gt;cached_sitd_list, sitd_list) {
+		list_del(&amp;sitd-&gt;sitd_list);
+		dma_pool_free(ehci-&gt;sitd_pool, sitd, sitd-&gt;sitd_dma);
+		if (sitd == ehci-&gt;last_sitd_to_free)
+			break;
+	}
+
+	if (!list_empty(&amp;ehci-&gt;cached_itd_list) ||
+			!list_empty(&amp;ehci-&gt;cached_sitd_list))
+		start_free_itds(ehci);
+}
+
+
 /*
  * Handler functions for the hrtimer event types.
  * Keep this array in the same order as the event types indexed by
@@ -260,6 +301,7 @@ static void (*event_handlers[])(struct ehci_hcd *) = {
 	ehci_poll_PSS,			/* EHCI_HRTIMER_POLL_PSS */
 	ehci_handle_controller_death,	/* EHCI_HRTIMER_POLL_DEAD */
 	ehci_handle_intr_unlinks,	/* EHCI_HRTIMER_UNLINK_INTR */
+	end_free_itds,			/* EHCI_HRTIMER_FREE_ITDS */
 	ehci_disable_PSE,		/* EHCI_HRTIMER_DISABLE_PERIODIC */
 	ehci_disable_ASE,		/* EHCI_HRTIMER_DISABLE_ASYNC */
 };
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 6874d89b0b64..bcfbb175e2b4 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -83,6 +83,7 @@ enum ehci_hrtimer_event {
 	EHCI_HRTIMER_POLL_PSS,		/* Poll for periodic schedule off */
 	EHCI_HRTIMER_POLL_DEAD,		/* Wait for dead controller to stop */
 	EHCI_HRTIMER_UNLINK_INTR,	/* Wait for interrupt QH unlink */
+	EHCI_HRTIMER_FREE_ITDS,		/* Wait for unused iTDs and siTDs */
 	EHCI_HRTIMER_DISABLE_PERIODIC,	/* Wait to disable periodic sched */
 	EHCI_HRTIMER_DISABLE_ASYNC,	/* Wait to disable async sched */
 	EHCI_HRTIMER_NUM_EVENTS		/* Must come last */
@@ -139,7 +140,9 @@ struct ehci_hcd {			/* one per controller */
 
 	/* list of itds &amp; sitds completed while clock_frame was still active */
 	struct list_head	cached_itd_list;
+	struct ehci_itd		*last_itd_to_free;
 	struct list_head	cached_sitd_list;
+	struct ehci_sitd	*last_sitd_to_free;
 	unsigned		clock_frame;
 
 	/* per root hub port */
@@ -250,8 +253,6 @@ timer_action_done (struct ehci_hcd *ehci, enum ehci_timer_action action)
 	clear_bit (action, &amp;ehci-&gt;actions);
 }
 
-static void free_cached_lists(struct ehci_hcd *ehci);
-
 /*-------------------------------------------------------------------------*/
 
 #include &lt;linux/usb/ehci_def.h&gt;</pre><hr><pre>commit bf6387bcd16975ba8952b094f262a359d74e1c8a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 11 11:22:31 2012 -0400

    USB: EHCI: use hrtimer for controller death
    
    This patch (as1578) adds an hrtimer event to handle the death of an
    EHCI controller.  When a controller dies, it doesn't necessarily stop
    running right away.  The new event polls at 1-ms intervals to see when
    all activity has safely stopped.  This replaces a busy-wait polling
    loop in the current code.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index edcfd2c4295e..1676c66b8530 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -888,20 +888,20 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 	/* PCI errors [4.15.2.4] */
 	if (unlikely ((status &amp; STS_FATAL) != 0)) {
 		ehci_err(ehci, "fatal error\n");
-		ehci-&gt;rh_state = EHCI_RH_STOPPING;
 		dbg_cmd(ehci, "fatal", cmd);
 		dbg_status(ehci, "fatal", status);
-		ehci_halt(ehci);
 dead:
-		ehci-&gt;enabled_hrtimer_events = 0;
-		hrtimer_try_to_cancel(&amp;ehci-&gt;hrtimer);
-		ehci_reset(ehci);
-		ehci_writel(ehci, 0, &amp;ehci-&gt;regs-&gt;configured_flag);
 		usb_hc_died(hcd);
-		/* generic layer kills/unlinks all urbs, then
-		 * uses ehci_stop to clean up the rest
-		 */
-		bh = 1;
+
+		/* Don't let the controller do anything more */
+		ehci-&gt;rh_state = EHCI_RH_STOPPING;
+		ehci-&gt;command &amp;= ~(CMD_RUN | CMD_ASE | CMD_PSE);
+		ehci_writel(ehci, ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
+		ehci_writel(ehci, 0, &amp;ehci-&gt;regs-&gt;intr_enable);
+		ehci_handle_controller_death(ehci);
+
+		/* Handle completions when the controller stops */
+		bh = 0;
 	}
 
 	if (bh)
diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index bd8b591771b0..0c5326a8883c 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -69,6 +69,7 @@ static void ehci_clear_command_bit(struct ehci_hcd *ehci, u32 bit)
 static unsigned event_delays_ns[] = {
 	1 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_POLL_ASS */
 	1 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_POLL_PSS */
+	1 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_POLL_DEAD */
 	1125 * NSEC_PER_USEC,	/* EHCI_HRTIMER_UNLINK_INTR */
 	10 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_DISABLE_PERIODIC */
 	15 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_DISABLE_ASYNC */
@@ -193,6 +194,30 @@ static void ehci_disable_PSE(struct ehci_hcd *ehci)
 }
 
 
+/* Poll the STS_HALT status bit; see when a dead controller stops */
+static void ehci_handle_controller_death(struct ehci_hcd *ehci)
+{
+	if (!(ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;status) &amp; STS_HALT)) {
+
+		/* Give up after a few milliseconds */
+		if (ehci-&gt;died_poll_count++ &lt; 5) {
+			/* Try again later */
+			ehci_enable_event(ehci, EHCI_HRTIMER_POLL_DEAD, true);
+			return;
+		}
+		ehci_warn(ehci, "Waited too long for the controller to stop, giving up\n");
+	}
+
+	/* Clean up the mess */
+	ehci-&gt;rh_state = EHCI_RH_HALTED;
+	ehci_writel(ehci, 0, &amp;ehci-&gt;regs-&gt;configured_flag);
+	ehci_writel(ehci, 0, &amp;ehci-&gt;regs-&gt;intr_enable);
+	ehci_work(ehci);
+
+	/* Not in process context, so don't try to reset the controller */
+}
+
+
 /* Handle unlinked interrupt QHs once they are gone from the hardware */
 static void ehci_handle_intr_unlinks(struct ehci_hcd *ehci)
 {
@@ -233,6 +258,7 @@ static void ehci_handle_intr_unlinks(struct ehci_hcd *ehci)
 static void (*event_handlers[])(struct ehci_hcd *) = {
 	ehci_poll_ASS,			/* EHCI_HRTIMER_POLL_ASS */
 	ehci_poll_PSS,			/* EHCI_HRTIMER_POLL_PSS */
+	ehci_handle_controller_death,	/* EHCI_HRTIMER_POLL_DEAD */
 	ehci_handle_intr_unlinks,	/* EHCI_HRTIMER_UNLINK_INTR */
 	ehci_disable_PSE,		/* EHCI_HRTIMER_DISABLE_PERIODIC */
 	ehci_disable_ASE,		/* EHCI_HRTIMER_DISABLE_ASYNC */
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index f36f1f85d7fd..6874d89b0b64 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -81,6 +81,7 @@ enum ehci_rh_state {
 enum ehci_hrtimer_event {
 	EHCI_HRTIMER_POLL_ASS,		/* Poll for async schedule off */
 	EHCI_HRTIMER_POLL_PSS,		/* Poll for periodic schedule off */
+	EHCI_HRTIMER_POLL_DEAD,		/* Wait for dead controller to stop */
 	EHCI_HRTIMER_UNLINK_INTR,	/* Wait for interrupt QH unlink */
 	EHCI_HRTIMER_DISABLE_PERIODIC,	/* Wait to disable periodic sched */
 	EHCI_HRTIMER_DISABLE_ASYNC,	/* Wait to disable async sched */
@@ -97,6 +98,7 @@ struct ehci_hcd {			/* one per controller */
 
 	int			PSS_poll_count;
 	int			ASS_poll_count;
+	int			died_poll_count;
 
 	/* glue to PCI and HCD framework */
 	struct ehci_caps __iomem *caps;</pre><hr><pre>commit df2022553dd8d34d49e16c19d851ea619438f0ef
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 11 11:22:26 2012 -0400

    USB: EHCI: use hrtimer for interrupt QH unlink
    
    This patch (as1577) adds hrtimer support for unlinking interrupt QHs
    in ehci-hcd.  The current code relies on a fixed delay of either 2 or
    55 us, which is not always adequate and in any case is totally bogus.
    Thanks to internal caching, the EHCI hardware may continue to access
    an interrupt QH for more than a millisecond after it has been unlinked.
    
    In fact, the EHCI spec doesn't say how long to wait before using an
    unlinked interrupt QH.  The patch sets the delay to 9 microframes
    minimum, which ought to be adequate.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 21d6fbc0a327..edcfd2c4295e 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -309,6 +309,8 @@ static void ehci_quiesce (struct ehci_hcd *ehci)
 
 static void end_unlink_async(struct ehci_hcd *ehci);
 static void ehci_work(struct ehci_hcd *ehci);
+static void start_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh);
+static void end_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh);
 
 #include "ehci-timer.c"
 #include "ehci-hub.c"
@@ -1034,7 +1036,7 @@ static int ehci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 		switch (qh-&gt;qh_state) {
 		case QH_STATE_LINKED:
 		case QH_STATE_COMPLETING:
-			intr_deschedule (ehci, qh);
+			start_unlink_intr(ehci, qh);
 			break;
 		case QH_STATE_IDLE:
 			qh_completions (ehci, qh);
@@ -1164,7 +1166,7 @@ ehci_endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 			if (eptype == USB_ENDPOINT_XFER_BULK)
 				unlink_async(ehci, qh);
 			else
-				intr_deschedule(ehci, qh);
+				start_unlink_intr(ehci, qh);
 		}
 	}
 	spin_unlock_irqrestore(&amp;ehci-&gt;lock, flags);
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 25329e4b844f..8aa740dc510d 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -302,6 +302,7 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 
 	if (ehci-&gt;async_unlink)
 		end_unlink_async(ehci);
+	ehci_handle_intr_unlinks(ehci);
 
 	/* allow remote wakeup */
 	mask = INTR_MASK;
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 69b1861e4325..eec8446f8ded 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -578,12 +578,20 @@ static void qh_unlink_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)
 	unsigned	i;
 	unsigned	period;
 
-	// FIXME:
-	// IF this isn't high speed
-	//   and this qh is active in the current uframe
-	//   (and overlay token SplitXstate is false?)
-	// THEN
-	//   qh-&gt;hw_info1 |= cpu_to_hc32(1 &lt;&lt; 7 /* "ignore" */);
+	/*
+	 * If qh is for a low/full-speed device, simply unlinking it
+	 * could interfere with an ongoing split transaction.  To unlink
+	 * it safely would require setting the QH_INACTIVATE bit and
+	 * waiting at least one frame, as described in EHCI 4.12.2.5.
+	 *
+	 * We won't bother with any of this.  Instead, we assume that the
+	 * only reason for unlinking an interrupt QH while the current URB
+	 * is still active is to dequeue all the URBs (flush the whole
+	 * endpoint queue).
+	 *
+	 * If rebalancing the periodic schedule is ever implemented, this
+	 * approach will no longer be valid.
+	 */
 
 	/* high bandwidth, or otherwise part of every microframe */
 	if ((period = qh-&gt;period) == 0)
@@ -608,12 +616,8 @@ static void qh_unlink_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)
 	qh-&gt;qh_next.ptr = NULL;
 }
 
-static void intr_deschedule (struct ehci_hcd *ehci, struct ehci_qh *qh)
+static void start_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
-	unsigned		wait;
-	struct ehci_qh_hw	*hw = qh-&gt;hw;
-	int			rc;
-
 	/* If the QH isn't linked then there's nothing we can do
 	 * unless we were called during a giveback, in which case
 	 * qh_completions() has to deal with it.
@@ -626,28 +630,45 @@ static void intr_deschedule (struct ehci_hcd *ehci, struct ehci_qh *qh)
 
 	qh_unlink_periodic (ehci, qh);
 
-	/* simple/paranoid:  always delay, expecting the HC needs to read
-	 * qh-&gt;hw_next or finish a writeback after SPLIT/CSPLIT ... and
-	 * expect khubd to clean up after any CSPLITs we won't issue.
-	 * active high speed queues may need bigger delays...
+	/* Make sure the unlinks are visible before starting the timer */
+	wmb();
+
+	/*
+	 * The EHCI spec doesn't say how long it takes the controller to
+	 * stop accessing an unlinked interrupt QH.  The timer delay is
+	 * 9 uframes; presumably that will be long enough.
 	 */
-	if (list_empty (&amp;qh-&gt;qtd_list)
-			|| (cpu_to_hc32(ehci, QH_CMASK)
-					&amp; hw-&gt;hw_info2) != 0)
-		wait = 2;
+	qh-&gt;unlink_cycle = ehci-&gt;intr_unlink_cycle;
+
+	/* New entries go at the end of the intr_unlink list */
+	if (ehci-&gt;intr_unlink)
+		ehci-&gt;intr_unlink_last-&gt;unlink_next = qh;
 	else
-		wait = 55;	/* worst case: 3 * 1024 */
+		ehci-&gt;intr_unlink = qh;
+	ehci-&gt;intr_unlink_last = qh;
+
+	if (ehci-&gt;intr_unlinking)
+		;	/* Avoid recursive calls */
+	else if (ehci-&gt;rh_state &lt; EHCI_RH_RUNNING)
+		ehci_handle_intr_unlinks(ehci);
+	else if (ehci-&gt;intr_unlink == qh) {
+		ehci_enable_event(ehci, EHCI_HRTIMER_UNLINK_INTR, true);
+		++ehci-&gt;intr_unlink_cycle;
+	}
+}
+
+static void end_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh)
+{
+	struct ehci_qh_hw	*hw = qh-&gt;hw;
+	int			rc;
 
-	udelay (wait);
 	qh-&gt;qh_state = QH_STATE_IDLE;
 	hw-&gt;hw_next = EHCI_LIST_END(ehci);
-	wmb ();
 
 	qh_completions(ehci, qh);
 
 	/* reschedule QH iff another request is queued */
-	if (!list_empty(&amp;qh-&gt;qtd_list) &amp;&amp;
-			ehci-&gt;rh_state == EHCI_RH_RUNNING) {
+	if (!list_empty(&amp;qh-&gt;qtd_list) &amp;&amp; ehci-&gt;rh_state == EHCI_RH_RUNNING) {
 		rc = qh_schedule(ehci, qh);
 
 		/* An error here likely indicates handshake failure
@@ -2302,7 +2323,7 @@ scan_periodic (struct ehci_hcd *ehci)
 						temp.qh-&gt;stamp = ehci-&gt;periodic_stamp;
 					if (unlikely(list_empty(&amp;temp.qh-&gt;qtd_list) ||
 							temp.qh-&gt;needs_rescan))
-						intr_deschedule(ehci, temp.qh);
+						start_unlink_intr(ehci, temp.qh);
 				}
 				break;
 			case Q_TYPE_FSTN:
diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index 1e907dd3bb1b..bd8b591771b0 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -69,6 +69,7 @@ static void ehci_clear_command_bit(struct ehci_hcd *ehci, u32 bit)
 static unsigned event_delays_ns[] = {
 	1 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_POLL_ASS */
 	1 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_POLL_PSS */
+	1125 * NSEC_PER_USEC,	/* EHCI_HRTIMER_UNLINK_INTR */
 	10 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_DISABLE_PERIODIC */
 	15 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_DISABLE_ASYNC */
 };
@@ -192,6 +193,38 @@ static void ehci_disable_PSE(struct ehci_hcd *ehci)
 }
 
 
+/* Handle unlinked interrupt QHs once they are gone from the hardware */
+static void ehci_handle_intr_unlinks(struct ehci_hcd *ehci)
+{
+	bool		stopped = (ehci-&gt;rh_state &lt; EHCI_RH_RUNNING);
+
+	/*
+	 * Process all the QHs on the intr_unlink list that were added
+	 * before the current unlink cycle began.  The list is in
+	 * temporal order, so stop when we reach the first entry in the
+	 * current cycle.  But if the root hub isn't running then
+	 * process all the QHs on the list.
+	 */
+	ehci-&gt;intr_unlinking = true;
+	while (ehci-&gt;intr_unlink) {
+		struct ehci_qh	*qh = ehci-&gt;intr_unlink;
+
+		if (!stopped &amp;&amp; qh-&gt;unlink_cycle == ehci-&gt;intr_unlink_cycle)
+			break;
+		ehci-&gt;intr_unlink = qh-&gt;unlink_next;
+		qh-&gt;unlink_next = NULL;
+		end_unlink_intr(ehci, qh);
+	}
+
+	/* Handle remaining entries later */
+	if (ehci-&gt;intr_unlink) {
+		ehci_enable_event(ehci, EHCI_HRTIMER_UNLINK_INTR, true);
+		++ehci-&gt;intr_unlink_cycle;
+	}
+	ehci-&gt;intr_unlinking = false;
+}
+
+
 /*
  * Handler functions for the hrtimer event types.
  * Keep this array in the same order as the event types indexed by
@@ -200,6 +233,7 @@ static void ehci_disable_PSE(struct ehci_hcd *ehci)
 static void (*event_handlers[])(struct ehci_hcd *) = {
 	ehci_poll_ASS,			/* EHCI_HRTIMER_POLL_ASS */
 	ehci_poll_PSS,			/* EHCI_HRTIMER_POLL_PSS */
+	ehci_handle_intr_unlinks,	/* EHCI_HRTIMER_UNLINK_INTR */
 	ehci_disable_PSE,		/* EHCI_HRTIMER_DISABLE_PERIODIC */
 	ehci_disable_ASE,		/* EHCI_HRTIMER_DISABLE_ASYNC */
 };
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index bf06bbb77ba4..f36f1f85d7fd 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -81,6 +81,7 @@ enum ehci_rh_state {
 enum ehci_hrtimer_event {
 	EHCI_HRTIMER_POLL_ASS,		/* Poll for async schedule off */
 	EHCI_HRTIMER_POLL_PSS,		/* Poll for periodic schedule off */
+	EHCI_HRTIMER_UNLINK_INTR,	/* Wait for interrupt QH unlink */
 	EHCI_HRTIMER_DISABLE_PERIODIC,	/* Wait to disable periodic sched */
 	EHCI_HRTIMER_DISABLE_ASYNC,	/* Wait to disable async sched */
 	EHCI_HRTIMER_NUM_EVENTS		/* Must come last */
@@ -106,13 +107,16 @@ struct ehci_hcd {			/* one per controller */
 	spinlock_t		lock;
 	enum ehci_rh_state	rh_state;
 
+	/* general schedule support */
+	unsigned		scanning:1;
+	bool			intr_unlinking:1;
+
 	/* async schedule support */
 	struct ehci_qh		*async;
 	struct ehci_qh		*dummy;		/* For AMD quirk use */
 	struct ehci_qh		*async_unlink;
 	struct ehci_qh		*async_unlink_last;
 	struct ehci_qh		*qh_scan_next;
-	unsigned		scanning : 1;
 	unsigned		async_count;	/* async activity count */
 
 	/* periodic schedule support */
@@ -123,6 +127,9 @@ struct ehci_hcd {			/* one per controller */
 	unsigned		i_thresh;	/* uframes HC might cache */
 
 	union ehci_shadow	*pshadow;	/* mirror hw periodic table */
+	struct ehci_qh		*intr_unlink;
+	struct ehci_qh		*intr_unlink_last;
+	unsigned		intr_unlink_cycle;
 	int			next_uframe;	/* scan periodic, start here */
 	unsigned		periodic_count;	/* periodic activity count */
 	unsigned		uframe_periodic_max; /* max periodic time per uframe */
@@ -385,6 +392,7 @@ struct ehci_qh {
 	struct ehci_qh		*unlink_next;	/* next on unlink list */
 
 	unsigned long		unlink_time;
+	unsigned		unlink_cycle;
 	unsigned		stamp;
 
 	u8			needs_rescan;	/* Dequeue during giveback */</pre><hr><pre>commit 314466101c6ae14f6f5db8a86eda1509ba2c02a8
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 11 11:22:21 2012 -0400

    USB: EHCI: use hrtimer for async schedule
    
    This patch (as1576) adds hrtimer support for managing ehci-hcd's
    async schedule.  Just as with the earlier change to the periodic
    schedule management, two new hrtimer events take care of everything.
    
    One event polls at 1-ms intervals to see when the Asynchronous
    Schedule Status (ASS) flag matches the Asynchronous Schedule Enable
    (ASE) value; the schedule's state must not be changed until it does.
    The other event delays for 15 ms after the async schedule becomes
    empty before turning it off.
    
    The new events replace a busy-wait poll and a kernel timer usage.
    They also replace the rather illogical method currently used for
    indicating the async schedule should be turned off: attempting to
    unlink the dedicated QH at the head of the async list.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index fd7ae16f77be..21d6fbc0a327 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -95,7 +95,6 @@ static const char	hcd_name [] = "ehci_hcd";
 
 #define EHCI_IAA_MSECS		10		/* arbitrary */
 #define EHCI_IO_JIFFIES		(HZ/10)		/* io watchdog &gt; irq_thresh */
-#define EHCI_ASYNC_JIFFIES	(HZ/20)		/* async idle timeout */
 #define EHCI_SHRINK_JIFFIES	(DIV_ROUND_UP(HZ, 200) + 1)
 						/* 5-ms async qh unlink delay */
 
@@ -137,7 +136,7 @@ timer_action(struct ehci_hcd *ehci, enum ehci_timer_action action)
 	 * SHRINK were pending, OFF would never be requested.
 	 */
 	if (timer_pending(&amp;ehci-&gt;watchdog)
-			&amp;&amp; ((BIT(TIMER_ASYNC_SHRINK) | BIT(TIMER_ASYNC_OFF))
+			&amp;&amp; (BIT(TIMER_ASYNC_SHRINK)
 				&amp; ehci-&gt;actions))
 		return;
 
@@ -150,9 +149,6 @@ timer_action(struct ehci_hcd *ehci, enum ehci_timer_action action)
 				return;
 			t = EHCI_IO_JIFFIES;
 			break;
-		case TIMER_ASYNC_OFF:
-			t = EHCI_ASYNC_JIFFIES;
-			break;
 		/* case TIMER_ASYNC_SHRINK: */
 		default:
 			t = EHCI_SHRINK_JIFFIES;
@@ -376,10 +372,6 @@ static void ehci_watchdog(unsigned long param)
 
 	spin_lock_irqsave(&amp;ehci-&gt;lock, flags);
 
-	/* stop async processing after it's idled a bit */
-	if (test_bit (TIMER_ASYNC_OFF, &amp;ehci-&gt;actions))
-		start_unlink_async (ehci, ehci-&gt;async);
-
 	/* ehci could run by timer, without IRQs ... */
 	ehci_work (ehci);
 
@@ -470,7 +462,8 @@ static void ehci_work (struct ehci_hcd *ehci)
 	if (ehci-&gt;scanning)
 		return;
 	ehci-&gt;scanning = 1;
-	scan_async (ehci);
+	if (ehci-&gt;async_count)
+		scan_async(ehci);
 	if (ehci-&gt;next_uframe != -1)
 		scan_periodic (ehci);
 	ehci-&gt;scanning = 0;
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 285d5a0f3f70..d68764ef4476 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -964,6 +964,30 @@ qh_make (
 
 /*-------------------------------------------------------------------------*/
 
+static void enable_async(struct ehci_hcd *ehci)
+{
+	if (ehci-&gt;async_count++)
+		return;
+
+	/* Stop waiting to turn off the async schedule */
+	ehci-&gt;enabled_hrtimer_events &amp;= ~BIT(EHCI_HRTIMER_DISABLE_ASYNC);
+
+	/* Don't start the schedule until ASS is 0 */
+	ehci_poll_ASS(ehci);
+}
+
+static void disable_async(struct ehci_hcd *ehci)
+{
+	if (--ehci-&gt;async_count)
+		return;
+
+	/* The async schedule and async_unlink list are supposed to be empty */
+	WARN_ON(ehci-&gt;async-&gt;qh_next.qh || ehci-&gt;async_unlink);
+
+	/* Don't turn off the schedule until ASS is 1 */
+	ehci_poll_ASS(ehci);
+}
+
 /* move qh (and its qtds) onto async queue; maybe enable queue.  */
 
 static void qh_link_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
@@ -977,24 +1001,11 @@ static void qh_link_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 
 	WARN_ON(qh-&gt;qh_state != QH_STATE_IDLE);
 
-	/* (re)start the async schedule? */
-	head = ehci-&gt;async;
-	timer_action_done (ehci, TIMER_ASYNC_OFF);
-	if (!head-&gt;qh_next.qh) {
-		if (!(ehci-&gt;command &amp; CMD_ASE)) {
-			/* in case a clear of CMD_ASE didn't take yet */
-			(void)handshake(ehci, &amp;ehci-&gt;regs-&gt;status,
-					STS_ASS, 0, 150);
-			ehci-&gt;command |= CMD_ASE;
-			ehci_writel(ehci, ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
-			/* posted write need not be known to HC yet ... */
-		}
-	}
-
 	/* clear halt and/or toggle; and maybe recover from silicon quirk */
 	qh_refresh(ehci, qh);
 
 	/* splice right after start */
+	head = ehci-&gt;async;
 	qh-&gt;qh_next = head-&gt;qh_next;
 	qh-&gt;hw-&gt;hw_next = head-&gt;hw-&gt;hw_next;
 	wmb ();
@@ -1005,6 +1016,8 @@ static void qh_link_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	qh-&gt;xacterrs = 0;
 	qh-&gt;qh_state = QH_STATE_LINKED;
 	/* qtd completions reported later by interrupt */
+
+	enable_async(ehci);
 }
 
 /*-------------------------------------------------------------------------*/
@@ -1173,16 +1186,10 @@ static void end_unlink_async (struct ehci_hcd *ehci)
 
 	qh_completions (ehci, qh);
 
-	if (!list_empty(&amp;qh-&gt;qtd_list) &amp;&amp; ehci-&gt;rh_state == EHCI_RH_RUNNING) {
+	if (!list_empty(&amp;qh-&gt;qtd_list) &amp;&amp; ehci-&gt;rh_state == EHCI_RH_RUNNING)
 		qh_link_async (ehci, qh);
-	} else {
-		/* it's not free to turn the async schedule on/off; leave it
-		 * active but idle for a while once it empties.
-		 */
-		if (ehci-&gt;rh_state == EHCI_RH_RUNNING
-				&amp;&amp; ehci-&gt;async-&gt;qh_next.qh == NULL)
-			timer_action (ehci, TIMER_ASYNC_OFF);
-	}
+
+	disable_async(ehci);
 
 	if (next) {
 		ehci-&gt;async_unlink = NULL;
@@ -1210,21 +1217,6 @@ static void start_unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 		BUG ();
 #endif
 
-	/* stop async schedule right now? */
-	if (unlikely (qh == ehci-&gt;async)) {
-		/* can't get here without STS_ASS set */
-		if (ehci-&gt;rh_state != EHCI_RH_HALTED
-				&amp;&amp; !ehci-&gt;async_unlink) {
-			/* ... and CMD_IAAD clear */
-			ehci-&gt;command &amp;= ~CMD_ASE;
-			ehci_writel(ehci, ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
-			wmb ();
-			// handshake later, if we need to
-			timer_action_done (ehci, TIMER_ASYNC_OFF);
-		}
-		return;
-	}
-
 	qh-&gt;qh_state = QH_STATE_UNLINK;
 	ehci-&gt;async_unlink = qh;
 	if (!qh-&gt;unlink_next)
diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index ecd3296157c6..1e907dd3bb1b 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -67,8 +67,10 @@ static void ehci_clear_command_bit(struct ehci_hcd *ehci, u32 bit)
  * the event types indexed by enum ehci_hrtimer_event in ehci.h.
  */
 static unsigned event_delays_ns[] = {
+	1 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_POLL_ASS */
 	1 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_POLL_PSS */
 	10 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_DISABLE_PERIODIC */
+	15 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_DISABLE_ASYNC */
 };
 
 /* Enable a pending hrtimer event */
@@ -91,6 +93,51 @@ static void ehci_enable_event(struct ehci_hcd *ehci, unsigned event,
 }
 
 
+/* Poll the STS_ASS status bit; see when it agrees with CMD_ASE */
+static void ehci_poll_ASS(struct ehci_hcd *ehci)
+{
+	unsigned	actual, want;
+
+	/* Don't enable anything if the controller isn't running (e.g., died) */
+	if (ehci-&gt;rh_state != EHCI_RH_RUNNING)
+		return;
+
+	want = (ehci-&gt;command &amp; CMD_ASE) ? STS_ASS : 0;
+	actual = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;status) &amp; STS_ASS;
+
+	if (want != actual) {
+
+		/* Poll again later, but give up after about 20 ms */
+		if (ehci-&gt;ASS_poll_count++ &lt; 20) {
+			ehci_enable_event(ehci, EHCI_HRTIMER_POLL_ASS, true);
+			return;
+		}
+		ehci_warn(ehci, "Waited too long for the async schedule status, giving up\n");
+	}
+	ehci-&gt;ASS_poll_count = 0;
+
+	/* The status is up-to-date; restart or stop the schedule as needed */
+	if (want == 0) {	/* Stopped */
+		if (ehci-&gt;async_count &gt; 0)
+			ehci_set_command_bit(ehci, CMD_ASE);
+
+	} else {		/* Running */
+		if (ehci-&gt;async_count == 0) {
+
+			/* Turn off the schedule after a while */
+			ehci_enable_event(ehci, EHCI_HRTIMER_DISABLE_ASYNC,
+					true);
+		}
+	}
+}
+
+/* Turn off the async schedule after a brief delay */
+static void ehci_disable_ASE(struct ehci_hcd *ehci)
+{
+	ehci_clear_command_bit(ehci, CMD_ASE);
+}
+
+
 /* Poll the STS_PSS status bit; see when it agrees with CMD_PSE */
 static void ehci_poll_PSS(struct ehci_hcd *ehci)
 {
@@ -151,8 +198,10 @@ static void ehci_disable_PSE(struct ehci_hcd *ehci)
  * enum ehci_hrtimer_event in ehci.h.
  */
 static void (*event_handlers[])(struct ehci_hcd *) = {
+	ehci_poll_ASS,			/* EHCI_HRTIMER_POLL_ASS */
 	ehci_poll_PSS,			/* EHCI_HRTIMER_POLL_PSS */
 	ehci_disable_PSE,		/* EHCI_HRTIMER_DISABLE_PERIODIC */
+	ehci_disable_ASE,		/* EHCI_HRTIMER_DISABLE_ASYNC */
 };
 
 static enum hrtimer_restart ehci_hrtimer_func(struct hrtimer *t)
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index da2e0ab23850..bf06bbb77ba4 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -79,8 +79,10 @@ enum ehci_rh_state {
  * ehci-timer.c) in parallel with this list.
  */
 enum ehci_hrtimer_event {
+	EHCI_HRTIMER_POLL_ASS,		/* Poll for async schedule off */
 	EHCI_HRTIMER_POLL_PSS,		/* Poll for periodic schedule off */
 	EHCI_HRTIMER_DISABLE_PERIODIC,	/* Wait to disable periodic sched */
+	EHCI_HRTIMER_DISABLE_ASYNC,	/* Wait to disable async sched */
 	EHCI_HRTIMER_NUM_EVENTS		/* Must come last */
 };
 #define EHCI_HRTIMER_NO_EVENT	99
@@ -93,6 +95,7 @@ struct ehci_hcd {			/* one per controller */
 	struct hrtimer		hrtimer;
 
 	int			PSS_poll_count;
+	int			ASS_poll_count;
 
 	/* glue to PCI and HCD framework */
 	struct ehci_caps __iomem *caps;
@@ -110,6 +113,7 @@ struct ehci_hcd {			/* one per controller */
 	struct ehci_qh		*async_unlink_last;
 	struct ehci_qh		*qh_scan_next;
 	unsigned		scanning : 1;
+	unsigned		async_count;	/* async activity count */
 
 	/* periodic schedule support */
 #define	DEFAULT_I_TDPS		1024		/* some HCs can do less */
@@ -229,7 +233,6 @@ static inline void iaa_watchdog_done(struct ehci_hcd *ehci)
 enum ehci_timer_action {
 	TIMER_IO_WATCHDOG,
 	TIMER_ASYNC_SHRINK,
-	TIMER_ASYNC_OFF,
 };
 
 static inline void</pre><hr><pre>commit 9671cd7a91059bcd27665a884ee6568d31ef6857
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 11 11:22:16 2012 -0400

    USB: EHCI: remove PS3 status polling
    
    This patch (as1575) removes special code added for status polling of
    the EHCI controller in PS3 systems.  While the controller is running,
    the polling is now carried out by an hrtimer handler.  When the
    controller is suspending or stopping, we use the same polling routine
    as the old code -- but in neither case do we need to conclude that the
    controller has died if the polling goes on for too long.
    
    As a result the entire handshake_on_error_set_halt() routine is now
    unused, so it is removed from the driver.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 7e00ca095cea..fd7ae16f77be 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -235,68 +235,6 @@ static int ehci_halt (struct ehci_hcd *ehci)
 			  STS_HALT, STS_HALT, 16 * 125);
 }
 
-#if defined(CONFIG_USB_SUSPEND) &amp;&amp; defined(CONFIG_PPC_PS3)
-
-/*
- * The EHCI controller of the Cell Super Companion Chip used in the
- * PS3 will stop the root hub after all root hub ports are suspended.
- * When in this condition handshake will return -ETIMEDOUT.  The
- * STS_HLT bit will not be set, so inspection of the frame index is
- * used here to test for the condition.  If the condition is found
- * return success to allow the USB suspend to complete.
- */
-
-static int handshake_for_broken_root_hub(struct ehci_hcd *ehci,
-					 void __iomem *ptr, u32 mask, u32 done,
-					 int usec)
-{
-	unsigned int old_index;
-	int error;
-
-	if (!firmware_has_feature(FW_FEATURE_PS3_LV1))
-		return -ETIMEDOUT;
-
-	old_index = ehci_read_frame_index(ehci);
-
-	error = handshake(ehci, ptr, mask, done, usec);
-
-	if (error == -ETIMEDOUT &amp;&amp; ehci_read_frame_index(ehci) == old_index)
-		return 0;
-
-	return error;
-}
-
-#else
-
-static int handshake_for_broken_root_hub(struct ehci_hcd *ehci,
-					 void __iomem *ptr, u32 mask, u32 done,
-					 int usec)
-{
-	return -ETIMEDOUT;
-}
-
-#endif
-
-static int handshake_on_error_set_halt(struct ehci_hcd *ehci, void __iomem *ptr,
-				       u32 mask, u32 done, int usec)
-{
-	int error;
-
-	error = handshake(ehci, ptr, mask, done, usec);
-	if (error == -ETIMEDOUT)
-		error = handshake_for_broken_root_hub(ehci, ptr, mask, done,
-						      usec);
-
-	if (error) {
-		ehci_halt(ehci);
-		ehci-&gt;rh_state = EHCI_RH_HALTED;
-		ehci_err(ehci, "force halt; handshake %p %08x %08x -&gt; %d\n",
-			ptr, mask, done, error);
-	}
-
-	return error;
-}
-
 /* put TDI/ARC silicon into EHCI mode */
 static void tdi_reset (struct ehci_hcd *ehci)
 {
@@ -361,17 +299,14 @@ static void ehci_quiesce (struct ehci_hcd *ehci)
 
 	/* wait for any schedule enables/disables to take effect */
 	temp = (ehci-&gt;command &lt;&lt; 10) &amp; (STS_ASS | STS_PSS);
-	if (handshake_on_error_set_halt(ehci, &amp;ehci-&gt;regs-&gt;status,
-					STS_ASS | STS_PSS, temp, 16 * 125))
-		return;
+	handshake(ehci, &amp;ehci-&gt;regs-&gt;status, STS_ASS | STS_PSS, temp, 16 * 125);
 
 	/* then disable anything that's still active */
 	ehci-&gt;command &amp;= ~(CMD_ASE | CMD_PSE);
 	ehci_writel(ehci, ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
 
 	/* hardware can take 16 microframes to turn off ... */
-	handshake_on_error_set_halt(ehci, &amp;ehci-&gt;regs-&gt;status,
-				    STS_ASS | STS_PSS, 0, 16 * 125);
+	handshake(ehci, &amp;ehci-&gt;regs-&gt;status, STS_ASS | STS_PSS, 0, 16 * 125);
 }
 
 /*-------------------------------------------------------------------------*/</pre><hr><pre>commit b015cb79ce84944076a8a849055f898f2a4d6be8
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 11 11:22:10 2012 -0400

    USB: EHCI: return void instead of 0
    
    This patch (as1574) changes the return type of multiple functions in
    ehci-sched.c from int to void.  The values they return are now always
    0, so there's no reason for them to return any value at all.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index f5c15880c65a..69b1861e4325 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -479,29 +479,27 @@ static int tt_no_collision (
 
 /*-------------------------------------------------------------------------*/
 
-static int enable_periodic (struct ehci_hcd *ehci)
+static void enable_periodic(struct ehci_hcd *ehci)
 {
 	if (ehci-&gt;periodic_count++)
-		return 0;
+		return;
 
 	/* Stop waiting to turn off the periodic schedule */
 	ehci-&gt;enabled_hrtimer_events &amp;= ~BIT(EHCI_HRTIMER_DISABLE_PERIODIC);
 
 	/* Don't start the schedule until PSS is 0 */
 	ehci_poll_PSS(ehci);
-	return 0;
 }
 
-static int disable_periodic (struct ehci_hcd *ehci)
+static void disable_periodic(struct ehci_hcd *ehci)
 {
 	if (--ehci-&gt;periodic_count)
-		return 0;
+		return;
 
 	ehci-&gt;next_uframe = -1;		/* the periodic schedule is empty */
 
 	/* Don't turn off the schedule until PSS is 1 */
 	ehci_poll_PSS(ehci);
-	return 0;
 }
 
 /*-------------------------------------------------------------------------*/
@@ -512,7 +510,7 @@ static int disable_periodic (struct ehci_hcd *ehci)
  * this just links in a qh; caller guarantees uframe masks are set right.
  * no FSTN support (yet; ehci 0.96+)
  */
-static int qh_link_periodic (struct ehci_hcd *ehci, struct ehci_qh *qh)
+static void qh_link_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
 	unsigned	i;
 	unsigned	period = qh-&gt;period;
@@ -572,10 +570,10 @@ static int qh_link_periodic (struct ehci_hcd *ehci, struct ehci_qh *qh)
 		: (qh-&gt;usecs * 8);
 
 	/* maybe enable periodic schedule processing */
-	return enable_periodic(ehci);
+	enable_periodic(ehci);
 }
 
-static int qh_unlink_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)
+static void qh_unlink_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
 	unsigned	i;
 	unsigned	period;
@@ -608,8 +606,6 @@ static int qh_unlink_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)
 	/* qh-&gt;qh_next still "live" to HC */
 	qh-&gt;qh_state = QH_STATE_UNLINK;
 	qh-&gt;qh_next.ptr = NULL;
-
-	return 0;
 }
 
 static void intr_deschedule (struct ehci_hcd *ehci, struct ehci_qh *qh)
@@ -843,7 +839,7 @@ static int qh_schedule(struct ehci_hcd *ehci, struct ehci_qh *qh)
 		ehci_dbg (ehci, "reused qh %p schedule\n", qh);
 
 	/* stuff into the periodic schedule */
-	status = qh_link_periodic (ehci, qh);
+	qh_link_periodic(ehci, qh);
 done:
 	return status;
 }
@@ -1574,8 +1570,7 @@ itd_link (struct ehci_hcd *ehci, unsigned frame, struct ehci_itd *itd)
 }
 
 /* fit urb's itds into the selected schedule slot; activate as needed */
-static int
-itd_link_urb (
+static void itd_link_urb(
 	struct ehci_hcd		*ehci,
 	struct urb		*urb,
 	unsigned		mod,
@@ -1646,7 +1641,7 @@ itd_link_urb (
 	urb-&gt;hcpriv = NULL;
 
 	timer_action (ehci, TIMER_IO_WATCHDOG);
-	return enable_periodic(ehci);
+	enable_periodic(ehci);
 }
 
 #define	ISO_ERRS (EHCI_ISOC_BUF_ERR | EHCI_ISOC_BABBLE | EHCI_ISOC_XACTERR)
@@ -1726,7 +1721,7 @@ itd_complete (
 	ehci_urb_done(ehci, urb, 0);
 	retval = true;
 	urb = NULL;
-	(void) disable_periodic(ehci);
+	disable_periodic(ehci);
 	ehci_to_hcd(ehci)-&gt;self.bandwidth_isoc_reqs--;
 
 	if (ehci_to_hcd(ehci)-&gt;self.bandwidth_isoc_reqs == 0) {
@@ -1993,8 +1988,7 @@ sitd_link (struct ehci_hcd *ehci, unsigned frame, struct ehci_sitd *sitd)
 }
 
 /* fit urb's sitds into the selected schedule slot; activate as needed */
-static int
-sitd_link_urb (
+static void sitd_link_urb(
 	struct ehci_hcd		*ehci,
 	struct urb		*urb,
 	unsigned		mod,
@@ -2056,7 +2050,7 @@ sitd_link_urb (
 	urb-&gt;hcpriv = NULL;
 
 	timer_action (ehci, TIMER_IO_WATCHDOG);
-	return enable_periodic(ehci);
+	enable_periodic(ehci);
 }
 
 /*-------------------------------------------------------------------------*/
@@ -2122,7 +2116,7 @@ sitd_complete (
 	ehci_urb_done(ehci, urb, 0);
 	retval = true;
 	urb = NULL;
-	(void) disable_periodic(ehci);
+	disable_periodic(ehci);
 	ehci_to_hcd(ehci)-&gt;self.bandwidth_isoc_reqs--;
 
 	if (ehci_to_hcd(ehci)-&gt;self.bandwidth_isoc_reqs == 0) {</pre><hr><pre>commit 3ca9aebac2ebb8f56d2d097636b8c568320a9f87
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 11 11:22:05 2012 -0400

    USB: EHCI: use hrtimer for the periodic schedule
    
    This patch (as1573) adds hrtimer support for managing ehci-hcd's
    periodic schedule.  There are two issues to deal with.
    
    First, the schedule's state (on or off) must not be changed until the
    hardware status has caught up with the current command.  This is
    handled by an hrtimer event that polls at 1-ms intervals to see when
    the Periodic Schedule Status (PSS) flag matches the Periodic Schedule
    Enable (PSE) value.
    
    Second, the schedule should not be turned off as soon as it becomes
    empty.  Turning the schedule on and off takes time, so we want to wait
    until the schedule has been empty for a suitable period before turning
    it off.  This is handled by an hrtimer event that gets set to expire
    10 ms after the periodic schedule becomes empty.
    
    The existing code polls (for up to 1125 us and with interrupts
    disabled!) to check the status, and doesn't implement a delay before
    turning off the schedule.  Furthermore, if the polling fails then the
    driver decides that the controller has died.  This has caused problems
    for several people; some controllers can take 10 ms or more to turn
    off their periodic schedules.
    
    This patch fixes these issues.  It also makes the "broken_periodic"
    workaround unnecessary; there is no longer any danger of turning off
    the periodic schedule after it has been on for less than 1 ms.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index f8fed163a23a..7e00ca095cea 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -546,7 +546,7 @@ static void ehci_work (struct ehci_hcd *ehci)
 	 */
 	if (ehci-&gt;rh_state == EHCI_RH_RUNNING &amp;&amp;
 			(ehci-&gt;async-&gt;qh_next.ptr != NULL ||
-			 ehci-&gt;periodic_sched != 0))
+			 ehci-&gt;periodic_count != 0))
 		timer_action (ehci, TIMER_IO_WATCHDOG);
 }
 
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 21e5f963f331..2cb7d370c4ef 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -104,10 +104,6 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		break;
 	case PCI_VENDOR_ID_INTEL:
 		ehci-&gt;fs_i_thresh = 1;
-		if (pdev-&gt;device == 0x27cc) {
-			ehci-&gt;broken_periodic = 1;
-			ehci_info(ehci, "using broken periodic workaround\n");
-		}
 		if (pdev-&gt;device == PCI_DEVICE_ID_INTEL_CE4100_USB)
 			hcd-&gt;has_tt = 1;
 		break;
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 3429b8a33c58..f5c15880c65a 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -481,67 +481,26 @@ static int tt_no_collision (
 
 static int enable_periodic (struct ehci_hcd *ehci)
 {
-	int	status;
-
-	if (ehci-&gt;periodic_sched++)
+	if (ehci-&gt;periodic_count++)
 		return 0;
 
-	/* did clearing PSE did take effect yet?
-	 * takes effect only at frame boundaries...
-	 */
-	status = handshake_on_error_set_halt(ehci, &amp;ehci-&gt;regs-&gt;status,
-					     STS_PSS, 0, 9 * 125);
-	if (status) {
-		usb_hc_died(ehci_to_hcd(ehci));
-		return status;
-	}
-
-	ehci-&gt;command |= CMD_PSE;
-	ehci_writel(ehci, ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
-	/* posted write ... PSS happens later */
+	/* Stop waiting to turn off the periodic schedule */
+	ehci-&gt;enabled_hrtimer_events &amp;= ~BIT(EHCI_HRTIMER_DISABLE_PERIODIC);
 
-	/* make sure ehci_work scans these */
-	ehci-&gt;next_uframe = ehci_read_frame_index(ehci)
-		% (ehci-&gt;periodic_size &lt;&lt; 3);
-	if (unlikely(ehci-&gt;broken_periodic))
-		ehci-&gt;last_periodic_enable = ktime_get_real();
+	/* Don't start the schedule until PSS is 0 */
+	ehci_poll_PSS(ehci);
 	return 0;
 }
 
 static int disable_periodic (struct ehci_hcd *ehci)
 {
-	int	status;
-
-	if (--ehci-&gt;periodic_sched)
+	if (--ehci-&gt;periodic_count)
 		return 0;
 
-	if (unlikely(ehci-&gt;broken_periodic)) {
-		/* delay experimentally determined */
-		ktime_t safe = ktime_add_us(ehci-&gt;last_periodic_enable, 1000);
-		ktime_t now = ktime_get_real();
-		s64 delay = ktime_us_delta(safe, now);
-
-		if (unlikely(delay &gt; 0))
-			udelay(delay);
-	}
-
-	/* did setting PSE not take effect yet?
-	 * takes effect only at frame boundaries...
-	 */
-	status = handshake_on_error_set_halt(ehci, &amp;ehci-&gt;regs-&gt;status,
-					     STS_PSS, STS_PSS, 9 * 125);
-	if (status) {
-		usb_hc_died(ehci_to_hcd(ehci));
-		return status;
-	}
-
-	ehci-&gt;command &amp;= ~CMD_PSE;
-	ehci_writel(ehci, ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
-	/* posted write ... */
-
-	free_cached_lists(ehci);
+	ehci-&gt;next_uframe = -1;		/* the periodic schedule is empty */
 
-	ehci-&gt;next_uframe = -1;
+	/* Don't turn off the schedule until PSS is 1 */
+	ehci_poll_PSS(ehci);
 	return 0;
 }
 
@@ -650,8 +609,7 @@ static int qh_unlink_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)
 	qh-&gt;qh_state = QH_STATE_UNLINK;
 	qh-&gt;qh_next.ptr = NULL;
 
-	/* maybe turn off periodic schedule */
-	return disable_periodic(ehci);
+	return 0;
 }
 
 static void intr_deschedule (struct ehci_hcd *ehci, struct ehci_qh *qh)
@@ -706,6 +664,9 @@ static void intr_deschedule (struct ehci_hcd *ehci, struct ehci_qh *qh)
 			ehci_err(ehci, "can't reschedule qh %p, err %d\n",
 					qh, rc);
 	}
+
+	/* maybe turn off periodic schedule */
+	disable_periodic(ehci);
 }
 
 /*-------------------------------------------------------------------------*/
@@ -2447,7 +2408,7 @@ scan_periodic (struct ehci_hcd *ehci)
 
 			/* assume completion callbacks modify the queue */
 			if (unlikely (modified)) {
-				if (likely(ehci-&gt;periodic_sched &gt; 0))
+				if (likely(ehci-&gt;periodic_count &gt; 0))
 					goto restart;
 				/* short-circuit this scan */
 				now_uframe = clock;
@@ -2476,7 +2437,7 @@ scan_periodic (struct ehci_hcd *ehci)
 			unsigned	now;
 
 			if (ehci-&gt;rh_state &lt; EHCI_RH_RUNNING
-					|| ehci-&gt;periodic_sched == 0)
+					|| ehci-&gt;periodic_count == 0)
 				break;
 			ehci-&gt;next_uframe = now_uframe;
 			now = ehci_read_frame_index(ehci) &amp; (mod - 1);
diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index f6279e2883a8..ecd3296157c6 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -16,6 +16,28 @@
 
 /*-------------------------------------------------------------------------*/
 
+/* Set a bit in the USBCMD register */
+static void ehci_set_command_bit(struct ehci_hcd *ehci, u32 bit)
+{
+	ehci-&gt;command |= bit;
+	ehci_writel(ehci, ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
+
+	/* unblock posted write */
+	ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
+}
+
+/* Clear a bit in the USBCMD register */
+static void ehci_clear_command_bit(struct ehci_hcd *ehci, u32 bit)
+{
+	ehci-&gt;command &amp;= ~bit;
+	ehci_writel(ehci, ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
+
+	/* unblock posted write */
+	ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
+}
+
+/*-------------------------------------------------------------------------*/
+
 /*
  * EHCI timer support...  Now using hrtimers.
  *
@@ -45,6 +67,8 @@
  * the event types indexed by enum ehci_hrtimer_event in ehci.h.
  */
 static unsigned event_delays_ns[] = {
+	1 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_POLL_PSS */
+	10 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_DISABLE_PERIODIC */
 };
 
 /* Enable a pending hrtimer event */
@@ -67,12 +91,68 @@ static void ehci_enable_event(struct ehci_hcd *ehci, unsigned event,
 }
 
 
+/* Poll the STS_PSS status bit; see when it agrees with CMD_PSE */
+static void ehci_poll_PSS(struct ehci_hcd *ehci)
+{
+	unsigned	actual, want;
+
+	/* Don't do anything if the controller isn't running (e.g., died) */
+	if (ehci-&gt;rh_state != EHCI_RH_RUNNING)
+		return;
+
+	want = (ehci-&gt;command &amp; CMD_PSE) ? STS_PSS : 0;
+	actual = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;status) &amp; STS_PSS;
+
+	if (want != actual) {
+
+		/* Poll again later, but give up after about 20 ms */
+		if (ehci-&gt;PSS_poll_count++ &lt; 20) {
+			ehci_enable_event(ehci, EHCI_HRTIMER_POLL_PSS, true);
+			return;
+		}
+		ehci_warn(ehci, "Waited too long for the periodic schedule status, giving up\n");
+	}
+	ehci-&gt;PSS_poll_count = 0;
+
+	/* The status is up-to-date; restart or stop the schedule as needed */
+	if (want == 0) {	/* Stopped */
+		free_cached_lists(ehci);
+		if (ehci-&gt;periodic_count &gt; 0) {
+
+			/* make sure ehci_work scans these */
+			ehci-&gt;next_uframe = ehci_read_frame_index(ehci)
+					&amp; ((ehci-&gt;periodic_size &lt;&lt; 3) - 1);
+			ehci_set_command_bit(ehci, CMD_PSE);
+		}
+
+	} else {		/* Running */
+		if (ehci-&gt;periodic_count == 0) {
+
+			/* Turn off the schedule after a while */
+			ehci_enable_event(ehci, EHCI_HRTIMER_DISABLE_PERIODIC,
+					true);
+		}
+	}
+}
+
+/* Turn off the periodic schedule after a brief delay */
+static void ehci_disable_PSE(struct ehci_hcd *ehci)
+{
+	ehci_clear_command_bit(ehci, CMD_PSE);
+
+	/* Poll to see when it actually stops */
+	ehci_enable_event(ehci, EHCI_HRTIMER_POLL_PSS, true);
+}
+
+
 /*
  * Handler functions for the hrtimer event types.
  * Keep this array in the same order as the event types indexed by
  * enum ehci_hrtimer_event in ehci.h.
  */
 static void (*event_handlers[])(struct ehci_hcd *) = {
+	ehci_poll_PSS,			/* EHCI_HRTIMER_POLL_PSS */
+	ehci_disable_PSE,		/* EHCI_HRTIMER_DISABLE_PERIODIC */
 };
 
 static enum hrtimer_restart ehci_hrtimer_func(struct hrtimer *t)
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 070be83028d5..da2e0ab23850 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -79,6 +79,8 @@ enum ehci_rh_state {
  * ehci-timer.c) in parallel with this list.
  */
 enum ehci_hrtimer_event {
+	EHCI_HRTIMER_POLL_PSS,		/* Poll for periodic schedule off */
+	EHCI_HRTIMER_DISABLE_PERIODIC,	/* Wait to disable periodic sched */
 	EHCI_HRTIMER_NUM_EVENTS		/* Must come last */
 };
 #define EHCI_HRTIMER_NO_EVENT	99
@@ -90,6 +92,8 @@ struct ehci_hcd {			/* one per controller */
 	ktime_t			hr_timeouts[EHCI_HRTIMER_NUM_EVENTS];
 	struct hrtimer		hrtimer;
 
+	int			PSS_poll_count;
+
 	/* glue to PCI and HCD framework */
 	struct ehci_caps __iomem *caps;
 	struct ehci_regs __iomem *regs;
@@ -116,7 +120,7 @@ struct ehci_hcd {			/* one per controller */
 
 	union ehci_shadow	*pshadow;	/* mirror hw periodic table */
 	int			next_uframe;	/* scan periodic, start here */
-	unsigned		periodic_sched;	/* periodic activity count */
+	unsigned		periodic_count;	/* periodic activity count */
 	unsigned		uframe_periodic_max; /* max periodic time per uframe */
 
 
@@ -165,7 +169,6 @@ struct ehci_hcd {			/* one per controller */
 	unsigned		big_endian_capbase:1;
 	unsigned		has_amcc_usb23:1;
 	unsigned		need_io_watchdog:1;
-	unsigned		broken_periodic:1;
 	unsigned		amd_pll_fix:1;
 	unsigned		fs_i_thresh:1;	/* Intel iso scheduling */
 	unsigned		use_dummy_qh:1;	/* AMD Frame List table quirk*/</pre><hr><pre>commit d58b4bcc6df8046cf9c3c59f9ff84d2cd86b93eb
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 11 11:21:54 2012 -0400

    USB: EHCI: introduce high-res timer
    
    This patch (as1572) begins the conversion of ehci-hcd over to using
    high-resolution timers rather than old-fashioned low-resolution kernel
    timers.  This reduces overhead caused by timer roundoff on systems
    where HZ is smaller than 1000.  Also, the new timer framework
    introduced here is much more logical and easily extended than the
    ad-hoc approach ehci-hcd currently uses for timers.
    
    An hrtimer structure is added to ehci_hcd, along with a bitflag array
    and an array of ktime_t values, to keep track of which timing events
    are pending and what their expiration times are.
    
    Only the infrastructure for the timing operations is added in this
    patch.  Later patches will add routines for handling each of the
    various timing events the driver needs.  In some cases the new hrtimer
    handlers will replace the existing handlers for ehci-hcd's kernel
    timers; as this happens the old timers will be removed.  In other
    cases the new timing events will replace busy-wait loops.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index bc94822f4c5d..f8fed163a23a 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -30,8 +30,7 @@
 #include &lt;linux/vmalloc.h&gt;
 #include &lt;linux/errno.h&gt;
 #include &lt;linux/init.h&gt;
-#include &lt;linux/timer.h&gt;
-#include &lt;linux/ktime.h&gt;
+#include &lt;linux/hrtimer.h&gt;
 #include &lt;linux/list.h&gt;
 #include &lt;linux/interrupt.h&gt;
 #include &lt;linux/usb.h&gt;
@@ -380,6 +379,7 @@ static void ehci_quiesce (struct ehci_hcd *ehci)
 static void end_unlink_async(struct ehci_hcd *ehci);
 static void ehci_work(struct ehci_hcd *ehci);
 
+#include "ehci-timer.c"
 #include "ehci-hub.c"
 #include "ehci-lpm.c"
 #include "ehci-mem.c"
@@ -494,7 +494,10 @@ static void ehci_shutdown(struct usb_hcd *hcd)
 	spin_lock_irq(&amp;ehci-&gt;lock);
 	ehci-&gt;rh_state = EHCI_RH_STOPPING;
 	ehci_silence_controller(ehci);
+	ehci-&gt;enabled_hrtimer_events = 0;
 	spin_unlock_irq(&amp;ehci-&gt;lock);
+
+	hrtimer_cancel(&amp;ehci-&gt;hrtimer);
 }
 
 static void ehci_port_power (struct ehci_hcd *ehci, int is_on)
@@ -561,12 +564,14 @@ static void ehci_stop (struct usb_hcd *hcd)
 	del_timer_sync(&amp;ehci-&gt;iaa_watchdog);
 
 	spin_lock_irq(&amp;ehci-&gt;lock);
+	ehci-&gt;enabled_hrtimer_events = 0;
 	ehci_quiesce(ehci);
 
 	ehci_silence_controller(ehci);
 	ehci_reset (ehci);
 	spin_unlock_irq(&amp;ehci-&gt;lock);
 
+	hrtimer_cancel(&amp;ehci-&gt;hrtimer);
 	remove_sysfs_files(ehci);
 	remove_debug_files (ehci);
 
@@ -615,6 +620,10 @@ static int ehci_init(struct usb_hcd *hcd)
 	ehci-&gt;iaa_watchdog.function = ehci_iaa_watchdog;
 	ehci-&gt;iaa_watchdog.data = (unsigned long) ehci;
 
+	hrtimer_init(&amp;ehci-&gt;hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);
+	ehci-&gt;hrtimer.function = ehci_hrtimer_func;
+	ehci-&gt;next_hrtimer_event = EHCI_HRTIMER_NO_EVENT;
+
 	hcc_params = ehci_readl(ehci, &amp;ehci-&gt;caps-&gt;hcc_params);
 
 	/*
@@ -954,6 +963,8 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 		dbg_status(ehci, "fatal", status);
 		ehci_halt(ehci);
 dead:
+		ehci-&gt;enabled_hrtimer_events = 0;
+		hrtimer_try_to_cancel(&amp;ehci-&gt;hrtimer);
 		ehci_reset(ehci);
 		ehci_writel(ehci, 0, &amp;ehci-&gt;regs-&gt;configured_flag);
 		usb_hc_died(hcd);
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index fb1b99e74937..25329e4b844f 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -311,12 +311,15 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 	ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;intr_enable);
 
 	ehci-&gt;next_statechange = jiffies + msecs_to_jiffies(10);
+	ehci-&gt;enabled_hrtimer_events = 0;
+	ehci-&gt;next_hrtimer_event = EHCI_HRTIMER_NO_EVENT;
 	spin_unlock_irq (&amp;ehci-&gt;lock);
 
 	/* ehci_work() may have re-enabled the watchdog timer, which we do not
 	 * want, and so we must delete any pending watchdog timer events.
 	 */
 	del_timer_sync(&amp;ehci-&gt;watchdog);
+	hrtimer_cancel(&amp;ehci-&gt;hrtimer);
 	return 0;
 }
 
diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
new file mode 100644
index 000000000000..f6279e2883a8
--- /dev/null
+++ b/drivers/usb/host/ehci-timer.c
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2012 by Alan Stern
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ */
+
+/* This file is part of ehci-hcd.c */
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * EHCI timer support...  Now using hrtimers.
+ *
+ * Lots of different events are triggered from ehci-&gt;hrtimer.  Whenever
+ * the timer routine runs, it checks each possible event; events that are
+ * currently enabled and whose expiration time has passed get handled.
+ * The set of enabled events is stored as a collection of bitflags in
+ * ehci-&gt;enabled_hrtimer_events, and they are numbered in order of
+ * increasing delay values (ranging between 1 ms and 100 ms).
+ *
+ * Rather than implementing a sorted list or tree of all pending events,
+ * we keep track only of the lowest-numbered pending event, in
+ * ehci-&gt;next_hrtimer_event.  Whenever ehci-&gt;hrtimer gets restarted, its
+ * expiration time is set to the timeout value for this event.
+ *
+ * As a result, events might not get handled right away; the actual delay
+ * could be anywhere up to twice the requested delay.  This doesn't
+ * matter, because none of the events are especially time-critical.  The
+ * ones that matter most all have a delay of 1 ms, so they will be
+ * handled after 2 ms at most, which is okay.  In addition to this, we
+ * allow for an expiration range of 1 ms.
+ */
+
+/*
+ * Delay lengths for the hrtimer event types.
+ * Keep this list sorted by delay length, in the same order as
+ * the event types indexed by enum ehci_hrtimer_event in ehci.h.
+ */
+static unsigned event_delays_ns[] = {
+};
+
+/* Enable a pending hrtimer event */
+static void ehci_enable_event(struct ehci_hcd *ehci, unsigned event,
+		bool resched)
+{
+	ktime_t		*timeout = &amp;ehci-&gt;hr_timeouts[event];
+
+	if (resched)
+		*timeout = ktime_add(ktime_get(),
+				ktime_set(0, event_delays_ns[event]));
+	ehci-&gt;enabled_hrtimer_events |= (1 &lt;&lt; event);
+
+	/* Track only the lowest-numbered pending event */
+	if (event &lt; ehci-&gt;next_hrtimer_event) {
+		ehci-&gt;next_hrtimer_event = event;
+		hrtimer_start_range_ns(&amp;ehci-&gt;hrtimer, *timeout,
+				NSEC_PER_MSEC, HRTIMER_MODE_ABS);
+	}
+}
+
+
+/*
+ * Handler functions for the hrtimer event types.
+ * Keep this array in the same order as the event types indexed by
+ * enum ehci_hrtimer_event in ehci.h.
+ */
+static void (*event_handlers[])(struct ehci_hcd *) = {
+};
+
+static enum hrtimer_restart ehci_hrtimer_func(struct hrtimer *t)
+{
+	struct ehci_hcd	*ehci = container_of(t, struct ehci_hcd, hrtimer);
+	ktime_t		now;
+	unsigned long	events;
+	unsigned long	flags;
+	unsigned	e;
+
+	spin_lock_irqsave(&amp;ehci-&gt;lock, flags);
+
+	events = ehci-&gt;enabled_hrtimer_events;
+	ehci-&gt;enabled_hrtimer_events = 0;
+	ehci-&gt;next_hrtimer_event = EHCI_HRTIMER_NO_EVENT;
+
+	/*
+	 * Check each pending event.  If its time has expired, handle
+	 * the event; otherwise re-enable it.
+	 */
+	now = ktime_get();
+	for_each_set_bit(e, &amp;events, EHCI_HRTIMER_NUM_EVENTS) {
+		if (now.tv64 &gt;= ehci-&gt;hr_timeouts[e].tv64)
+			event_handlers[e](ehci);
+		else
+			ehci_enable_event(ehci, e, false);
+	}
+
+	spin_unlock_irqrestore(&amp;ehci-&gt;lock, flags);
+	return HRTIMER_NORESTART;
+}
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 9e8e82ecce58..070be83028d5 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -73,7 +73,23 @@ enum ehci_rh_state {
 	EHCI_RH_STOPPING
 };
 
+/*
+ * Timer events, ordered by increasing delay length.
+ * Always update event_delays_ns[] and event_handlers[] (defined in
+ * ehci-timer.c) in parallel with this list.
+ */
+enum ehci_hrtimer_event {
+	EHCI_HRTIMER_NUM_EVENTS		/* Must come last */
+};
+#define EHCI_HRTIMER_NO_EVENT	99
+
 struct ehci_hcd {			/* one per controller */
+	/* timing support */
+	enum ehci_hrtimer_event	next_hrtimer_event;
+	unsigned		enabled_hrtimer_events;
+	ktime_t			hr_timeouts[EHCI_HRTIMER_NUM_EVENTS];
+	struct hrtimer		hrtimer;
+
 	/* glue to PCI and HCD framework */
 	struct ehci_caps __iomem *caps;
 	struct ehci_regs __iomem *regs;</pre><hr><pre>commit c0c53dbc32ea05a1e1dd9dba4772327da9a11750
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 11 11:21:48 2012 -0400

    USB: EHCI: add new root-hub state: STOPPING
    
    This patch (as1571) adds a new state for ehci-hcd's root hubs:
    EHCI_RH_STOPPING.  This value is used at times when the root hub is
    being stopped and we don't know whether or not the hardware has
    finished all its DMA yet.
    
    Although the purpose may not be apparent, this distinction will come
    in useful later on.  Future patches will avoid actions that depend on
    the root hub being operational (like turning on the async or periodic
    schedules) when they see the state is EHCI_RH_STOPPING.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-dbg.c b/drivers/usb/host/ehci-dbg.c
index 76120957d60a..f0c00de035ef 100644
--- a/drivers/usb/host/ehci-dbg.c
+++ b/drivers/usb/host/ehci-dbg.c
@@ -706,6 +706,8 @@ static const char *rh_state_string(struct ehci_hcd *ehci)
 		return "suspended";
 	case EHCI_RH_RUNNING:
 		return "running";
+	case EHCI_RH_STOPPING:
+		return "stopping";
 	}
 	return "?";
 }
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 8b75e4279a47..bc94822f4c5d 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -357,10 +357,8 @@ static void ehci_quiesce (struct ehci_hcd *ehci)
 {
 	u32	temp;
 
-#ifdef DEBUG
 	if (ehci-&gt;rh_state != EHCI_RH_RUNNING)
-		BUG ();
-#endif
+		return;
 
 	/* wait for any schedule enables/disables to take effect */
 	temp = (ehci-&gt;command &lt;&lt; 10) &amp; (STS_ASS | STS_PSS);
@@ -494,6 +492,7 @@ static void ehci_shutdown(struct usb_hcd *hcd)
 	del_timer_sync(&amp;ehci-&gt;iaa_watchdog);
 
 	spin_lock_irq(&amp;ehci-&gt;lock);
+	ehci-&gt;rh_state = EHCI_RH_STOPPING;
 	ehci_silence_controller(ehci);
 	spin_unlock_irq(&amp;ehci-&gt;lock);
 }
@@ -562,8 +561,7 @@ static void ehci_stop (struct usb_hcd *hcd)
 	del_timer_sync(&amp;ehci-&gt;iaa_watchdog);
 
 	spin_lock_irq(&amp;ehci-&gt;lock);
-	if (ehci-&gt;rh_state == EHCI_RH_RUNNING)
-		ehci_quiesce (ehci);
+	ehci_quiesce(ehci);
 
 	ehci_silence_controller(ehci);
 	ehci_reset (ehci);
@@ -951,6 +949,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 	/* PCI errors [4.15.2.4] */
 	if (unlikely ((status &amp; STS_FATAL) != 0)) {
 		ehci_err(ehci, "fatal error\n");
+		ehci-&gt;rh_state = EHCI_RH_STOPPING;
 		dbg_cmd(ehci, "fatal", cmd);
 		dbg_status(ehci, "fatal", status);
 		ehci_halt(ehci);
@@ -1026,7 +1025,7 @@ static int ehci_urb_enqueue (
 static void unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
 	/* failfast */
-	if (ehci-&gt;rh_state != EHCI_RH_RUNNING &amp;&amp; ehci-&gt;async_unlink)
+	if (ehci-&gt;rh_state &lt; EHCI_RH_RUNNING &amp;&amp; ehci-&gt;async_unlink)
 		end_unlink_async(ehci);
 
 	/* If the QH isn't linked then there's nothing we can do
@@ -1148,7 +1147,7 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 		goto idle_timeout;
 	}
 
-	if (ehci-&gt;rh_state != EHCI_RH_RUNNING)
+	if (ehci-&gt;rh_state &lt; EHCI_RH_RUNNING)
 		qh-&gt;qh_state = QH_STATE_IDLE;
 	switch (qh-&gt;qh_state) {
 	case QH_STATE_LINKED:
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 77d3324b4b28..fb1b99e74937 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -227,8 +227,7 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 	}
 
 	/* stop schedules, clean any completed work */
-	if (ehci-&gt;rh_state == EHCI_RH_RUNNING)
-		ehci_quiesce (ehci);
+	ehci_quiesce(ehci);
 	ehci_work(ehci);
 
 	/* Unlike other USB host controller types, EHCI doesn't have
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 5193612c96ea..285d5a0f3f70 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -433,7 +433,7 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 
 		/* stop scanning when we reach qtds the hc is using */
 		} else if (likely (!stopped
-				&amp;&amp; ehci-&gt;rh_state == EHCI_RH_RUNNING)) {
+				&amp;&amp; ehci-&gt;rh_state &gt;= EHCI_RH_RUNNING)) {
 			break;
 
 		/* scan the whole queue for unlinks whenever it stops */
@@ -441,7 +441,7 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 			stopped = 1;
 
 			/* cancel everything if we halt, suspend, etc */
-			if (ehci-&gt;rh_state != EHCI_RH_RUNNING)
+			if (ehci-&gt;rh_state &lt; EHCI_RH_RUNNING)
 				last_status = -ESHUTDOWN;
 
 			/* this qtd is active; skip it unless a previous qtd
@@ -1241,7 +1241,7 @@ static void start_unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	wmb ();
 
 	/* If the controller isn't running, we don't have to wait for it */
-	if (unlikely(ehci-&gt;rh_state != EHCI_RH_RUNNING)) {
+	if (unlikely(ehci-&gt;rh_state &lt; EHCI_RH_RUNNING)) {
 		/* if (unlikely (qh-&gt;unlink_next != 0))
 		 *	this will recurse, probably not much
 		 */
@@ -1263,7 +1263,7 @@ static void scan_async (struct ehci_hcd *ehci)
 	enum ehci_timer_action	action = TIMER_IO_WATCHDOG;
 
 	timer_action_done (ehci, TIMER_ASYNC_SHRINK);
-	stopped = (ehci-&gt;rh_state != EHCI_RH_RUNNING);
+	stopped = (ehci-&gt;rh_state &lt; EHCI_RH_RUNNING);
 
 	ehci-&gt;qh_scan_next = ehci-&gt;async-&gt;qh_next.qh;
 	while (ehci-&gt;qh_scan_next) {
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 027df3de2dc9..3429b8a33c58 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -2299,7 +2299,7 @@ scan_periodic (struct ehci_hcd *ehci)
 	 * Touches as few pages as possible:  cache-friendly.
 	 */
 	now_uframe = ehci-&gt;next_uframe;
-	if (ehci-&gt;rh_state == EHCI_RH_RUNNING) {
+	if (ehci-&gt;rh_state &gt;= EHCI_RH_RUNNING) {
 		clock = ehci_read_frame_index(ehci);
 		clock_frame = (clock &gt;&gt; 3) &amp; (ehci-&gt;periodic_size - 1);
 	} else  {
@@ -2334,7 +2334,7 @@ scan_periodic (struct ehci_hcd *ehci)
 			union ehci_shadow	temp;
 			int			live;
 
-			live = (ehci-&gt;rh_state == EHCI_RH_RUNNING);
+			live = (ehci-&gt;rh_state &gt;= EHCI_RH_RUNNING);
 			switch (hc32_to_cpu(ehci, type)) {
 			case Q_TYPE_QH:
 				/* handle any completions */
@@ -2459,7 +2459,7 @@ scan_periodic (struct ehci_hcd *ehci)
 		 * We can't advance our scan without collecting the ISO
 		 * transfers that are still pending in this frame.
 		 */
-		if (incomplete &amp;&amp; ehci-&gt;rh_state == EHCI_RH_RUNNING) {
+		if (incomplete &amp;&amp; ehci-&gt;rh_state &gt;= EHCI_RH_RUNNING) {
 			ehci-&gt;next_uframe = now_uframe;
 			break;
 		}
@@ -2475,7 +2475,7 @@ scan_periodic (struct ehci_hcd *ehci)
 		if (now_uframe == clock) {
 			unsigned	now;
 
-			if (ehci-&gt;rh_state != EHCI_RH_RUNNING
+			if (ehci-&gt;rh_state &lt; EHCI_RH_RUNNING
 					|| ehci-&gt;periodic_sched == 0)
 				break;
 			ehci-&gt;next_uframe = now_uframe;
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 475f23e10bbf..9e8e82ecce58 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -62,10 +62,15 @@ struct ehci_stats {
 
 #define	EHCI_MAX_ROOT_PORTS	15		/* see HCS_N_PORTS */
 
+/*
+ * ehci_rh_state values of EHCI_RH_RUNNING or above mean that the
+ * controller may be doing DMA.  Lower values mean there's no DMA.
+ */
 enum ehci_rh_state {
 	EHCI_RH_HALTED,
 	EHCI_RH_SUSPENDED,
-	EHCI_RH_RUNNING
+	EHCI_RH_RUNNING,
+	EHCI_RH_STOPPING
 };
 
 struct ehci_hcd {			/* one per controller */</pre><hr><pre>commit 2f5bb665ba7a14c5842fa2e1cde2be039843a2a2
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 11 11:21:43 2012 -0400

    USB: EHCI: add pointer to end of async-unlink list
    
    This patch (as1570) adds a pointer for the end of ehci-hcd's
    async-unlink list.  The list (which is actually a queue) is singly
    linked, so having a pointer to its end makes adding new entries easier
    -- there's no longer any need to scan through the whole list.
    
    In principle it could be changed to a standard doubly-linked list.  It
    turns out that doing so actually makes the code less clear, so I'm
    leaving it as is.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index efee426a2465..8b75e4279a47 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1041,14 +1041,9 @@ static void unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 
 	/* defer till later if busy */
 	if (ehci-&gt;async_unlink) {
-		struct ehci_qh		*last;
-
-		for (last = ehci-&gt;async_unlink;
-				last-&gt;unlink_next;
-				last = last-&gt;unlink_next)
-			continue;
 		qh-&gt;qh_state = QH_STATE_UNLINK_WAIT;
-		last-&gt;unlink_next = qh;
+		ehci-&gt;async_unlink_last-&gt;unlink_next = qh;
+		ehci-&gt;async_unlink_last = qh;
 
 	/* start IAA cycle */
 	} else
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 8e80cde8c35e..5193612c96ea 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -1227,6 +1227,8 @@ static void start_unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 
 	qh-&gt;qh_state = QH_STATE_UNLINK;
 	ehci-&gt;async_unlink = qh;
+	if (!qh-&gt;unlink_next)
+		ehci-&gt;async_unlink_last = qh;
 
 	prev = ehci-&gt;async;
 	while (prev-&gt;qh_next.qh != qh)
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 3c6c07c0956a..475f23e10bbf 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -82,6 +82,7 @@ struct ehci_hcd {			/* one per controller */
 	struct ehci_qh		*async;
 	struct ehci_qh		*dummy;		/* For AMD quirk use */
 	struct ehci_qh		*async_unlink;
+	struct ehci_qh		*async_unlink_last;
 	struct ehci_qh		*qh_scan_next;
 	unsigned		scanning : 1;
 </pre>
    <div class="pagination">
        <a href='2_45.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><span>[46]</span><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_47.html'>Next&gt;&gt;</a>
    <div>
</body>
