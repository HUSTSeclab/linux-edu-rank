<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_50.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><span>[51]</span><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_52.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 69276a33bd1d272dc9c3bd577038954811bd1831
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Feb 23 14:57:37 2012 -0500

    usb-serial: use new registration API in staging drivers
    
    This patch (as1530) modifies the following usb-serial drivers from
    drivers/staging to utilize the new usb_serial_{de}register_drivers()
    routines:
    
            quatech_usb2 and serqt_usb2.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/quatech_usb2/quatech_usb2.c b/drivers/staging/quatech_usb2/quatech_usb2.c
index 897a3a99c794..b8a078abd6c7 100644
--- a/drivers/staging/quatech_usb2/quatech_usb2.c
+++ b/drivers/staging/quatech_usb2/quatech_usb2.c
@@ -135,7 +135,6 @@ static struct usb_driver quausb2_usb_driver = {
 	.probe = usb_serial_probe,
 	.disconnect = usb_serial_disconnect,
 	.id_table = quausb2_id_table,
-	.no_dynamic_id = 1,
 };
 
 /**
@@ -1942,7 +1941,6 @@ static struct usb_serial_driver quatech2_device = {
 		.name = "quatech_usb2",
 	},
 	.description = DRIVER_DESC,
-	.usb_driver = &amp;quausb2_usb_driver,
 	.id_table = quausb2_id_table,
 	.num_ports = 8,
 	.open = qt2_open,
@@ -1964,37 +1962,27 @@ static struct usb_serial_driver quatech2_device = {
 	.write_bulk_callback = qt2_write_bulk_callback,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;quatech2_device, NULL
+};
+
 static int __init quausb2_usb_init(void)
 {
 	int retval;
 
 	dbg("%s\n", __func__);
 
-	/* register with usb-serial */
-	retval = usb_serial_register(&amp;quatech2_device);
-
-	if (retval)
-		goto failed_usb_serial_register;
-
-	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
-			DRIVER_DESC "\n");
-
-	/* register with usb */
-
-	retval = usb_register(&amp;quausb2_usb_driver);
+	retval = usb_serial_register_drivers(&amp;quausb2_usb_driver,
+			serial_drivers);
 	if (retval == 0)
-		return 0;
-
-	/* if we're here, usb_register() failed */
-	usb_serial_deregister(&amp;quatech2_device);
-failed_usb_serial_register:
-		return retval;
+		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+				DRIVER_DESC "\n");
+	return retval;
 }
 
 static void __exit quausb2_usb_exit(void)
 {
-	usb_deregister(&amp;quausb2_usb_driver);
-	usb_serial_deregister(&amp;quatech2_device);
+	usb_serial_deregister_drivers(&amp;quausb2_usb_driver, serial_drivers);
 }
 
 module_init(quausb2_usb_init);
diff --git a/drivers/staging/serqt_usb2/serqt_usb2.c b/drivers/staging/serqt_usb2/serqt_usb2.c
index 1c5780f1571b..04b6be86df1a 100644
--- a/drivers/staging/serqt_usb2/serqt_usb2.c
+++ b/drivers/staging/serqt_usb2/serqt_usb2.c
@@ -200,7 +200,6 @@ static struct usb_driver serqt_usb_driver = {
 	.probe = usb_serial_probe,
 	.disconnect = usb_serial_disconnect,
 	.id_table = serqt_id_table,
-	.no_dynamic_id = 1,
 };
 
 static int port_paranoia_check(struct usb_serial_port *port,
@@ -1590,7 +1589,6 @@ static struct usb_serial_driver quatech_device = {
 		   .name = "serqt",
 		   },
 	.description = DRIVER_DESC,
-	.usb_driver = &amp;serqt_usb_driver,
 	.id_table = serqt_id_table,
 	.num_ports = 8,
 	.open = qt_open,
@@ -1610,37 +1608,27 @@ static struct usb_serial_driver quatech_device = {
 	.release = qt_release,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;quatech_device, NULL
+};
+
 static int __init serqt_usb_init(void)
 {
 	int retval;
 
 	dbg("%s\n", __func__);
 
-	/* register with usb-serial */
-	retval = usb_serial_register(&amp;quatech_device);
-
-	if (retval)
-		goto failed_usb_serial_register;
-
-	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
-	       DRIVER_DESC "\n");
-
-	/* register with usb */
-
-	retval = usb_register(&amp;serqt_usb_driver);
+	retval = usb_serial_register_drivers(&amp;serqt_usb_driver,
+			serial_drivers);
 	if (retval == 0)
-		return 0;
-
-	/* if we're here, usb_register() failed */
-	usb_serial_deregister(&amp;quatech_device);
-failed_usb_serial_register:
+		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+				DRIVER_DESC "\n");
 	return retval;
 }
 
 static void __exit serqt_usb_exit(void)
 {
-	usb_deregister(&amp;serqt_usb_driver);
-	usb_serial_deregister(&amp;quatech_device);
+	usb_serial_deregister_drivers(&amp;serqt_usb_driver, serial_drivers);
 }
 
 module_init(serqt_usb_init);</pre><hr><pre>commit 29618e9fb5507b9fcf07f739a8506a3640495945
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Feb 23 14:57:32 2012 -0500

    usb-serial: use new registration API in [t-z]* drivers
    
    This patch (as1529) modifies the following usb-serial drivers to
    utilize the new usb_serial_{de}register_drivers() routines:
    
            ti_usb_3410_5052, usb_debug, visor, vivopay-serial,
            whiteheat, and zio.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/serial/ti_usb_3410_5052.c b/drivers/usb/serial/ti_usb_3410_5052.c
index 74f2c7746cc4..ab74123d658e 100644
--- a/drivers/usb/serial/ti_usb_3410_5052.c
+++ b/drivers/usb/serial/ti_usb_3410_5052.c
@@ -216,7 +216,6 @@ static struct usb_driver ti_usb_driver = {
 	.probe			= usb_serial_probe,
 	.disconnect		= usb_serial_disconnect,
 	.id_table		= ti_id_table_combined,
-	.no_dynamic_id = 	1,
 };
 
 static struct usb_serial_driver ti_1port_device = {
@@ -225,7 +224,6 @@ static struct usb_serial_driver ti_1port_device = {
 		.name		= "ti_usb_3410_5052_1",
 	},
 	.description		= "TI USB 3410 1 port adapter",
-	.usb_driver		= &amp;ti_usb_driver,
 	.id_table		= ti_id_table_3410,
 	.num_ports		= 1,
 	.attach			= ti_startup,
@@ -254,7 +252,6 @@ static struct usb_serial_driver ti_2port_device = {
 		.name		= "ti_usb_3410_5052_2",
 	},
 	.description		= "TI USB 5052 2 port adapter",
-	.usb_driver		= &amp;ti_usb_driver,
 	.id_table		= ti_id_table_5052,
 	.num_ports		= 2,
 	.attach			= ti_startup,
@@ -277,6 +274,9 @@ static struct usb_serial_driver ti_2port_device = {
 	.write_bulk_callback	= ti_bulk_out_callback,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;ti_1port_device, &amp;ti_2port_device, NULL
+};
 
 /* Module */
 
@@ -344,36 +344,17 @@ static int __init ti_init(void)
 		ti_id_table_combined[c].match_flags = USB_DEVICE_ID_MATCH_DEVICE;
 	}
 
-	ret = usb_serial_register(&amp;ti_1port_device);
-	if (ret)
-		goto failed_1port;
-	ret = usb_serial_register(&amp;ti_2port_device);
-	if (ret)
-		goto failed_2port;
-
-	ret = usb_register(&amp;ti_usb_driver);
-	if (ret)
-		goto failed_usb;
-
-	printk(KERN_INFO KBUILD_MODNAME ": " TI_DRIVER_VERSION ":"
-	       TI_DRIVER_DESC "\n");
-
-	return 0;
-
-failed_usb:
-	usb_serial_deregister(&amp;ti_2port_device);
-failed_2port:
-	usb_serial_deregister(&amp;ti_1port_device);
-failed_1port:
+	ret = usb_serial_register_drivers(&amp;ti_usb_driver, serial_drivers);
+	if (ret == 0)
+		printk(KERN_INFO KBUILD_MODNAME ": " TI_DRIVER_VERSION ":"
+			       TI_DRIVER_DESC "\n");
 	return ret;
 }
 
 
 static void __exit ti_exit(void)
 {
-	usb_deregister(&amp;ti_usb_driver);
-	usb_serial_deregister(&amp;ti_1port_device);
-	usb_serial_deregister(&amp;ti_2port_device);
+	usb_serial_deregister_drivers(&amp;ti_usb_driver, serial_drivers);
 }
 
 
diff --git a/drivers/usb/serial/usb_debug.c b/drivers/usb/serial/usb_debug.c
index 9b632e753210..5b29b4a2ebc7 100644
--- a/drivers/usb/serial/usb_debug.c
+++ b/drivers/usb/serial/usb_debug.c
@@ -40,7 +40,6 @@ static struct usb_driver debug_driver = {
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	id_table,
-	.no_dynamic_id =	1,
 };
 
 /* This HW really does not support a serial break, so one will be
@@ -74,30 +73,24 @@ static struct usb_serial_driver debug_device = {
 		.name =		"debug",
 	},
 	.id_table =		id_table,
-	.usb_driver =		&amp;debug_driver,
 	.num_ports =		1,
 	.bulk_out_size =	USB_DEBUG_MAX_PACKET_SIZE,
 	.break_ctl =		usb_debug_break_ctl,
 	.process_read_urb =	usb_debug_process_read_urb,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;debug_device, NULL
+};
+
 static int __init debug_init(void)
 {
-	int retval;
-
-	retval = usb_serial_register(&amp;debug_device);
-	if (retval)
-		return retval;
-	retval = usb_register(&amp;debug_driver);
-	if (retval)
-		usb_serial_deregister(&amp;debug_device);
-	return retval;
+	return usb_serial_register_drivers(&amp;debug_driver, serial_drivers);
 }
 
 static void __exit debug_exit(void)
 {
-	usb_deregister(&amp;debug_driver);
-	usb_serial_deregister(&amp;debug_device);
+	usb_serial_deregister_drivers(&amp;debug_driver, serial_drivers);
 }
 
 module_init(debug_init);
diff --git a/drivers/usb/serial/visor.c b/drivers/usb/serial/visor.c
index 210e4b10dc11..71d696474f24 100644
--- a/drivers/usb/serial/visor.c
+++ b/drivers/usb/serial/visor.c
@@ -173,7 +173,6 @@ static struct usb_driver visor_driver = {
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	id_table_combined,
-	.no_dynamic_id = 	1,
 };
 
 /* All of the device info needed for the Handspring Visor,
@@ -184,7 +183,6 @@ static struct usb_serial_driver handspring_device = {
 		.name =		"visor",
 	},
 	.description =		"Handspring Visor / Palm OS",
-	.usb_driver =		&amp;visor_driver,
 	.id_table =		id_table,
 	.num_ports =		2,
 	.bulk_out_size =	256,
@@ -205,7 +203,6 @@ static struct usb_serial_driver clie_5_device = {
 		.name =		"clie_5",
 	},
 	.description =		"Sony Clie 5.0",
-	.usb_driver =		&amp;visor_driver,
 	.id_table =		clie_id_5_table,
 	.num_ports =		2,
 	.bulk_out_size =	256,
@@ -226,7 +223,6 @@ static struct usb_serial_driver clie_3_5_device = {
 		.name =		"clie_3.5",
 	},
 	.description =		"Sony Clie 3.5",
-	.usb_driver =		&amp;visor_driver,
 	.id_table =		clie_id_3_5_table,
 	.num_ports =		1,
 	.bulk_out_size =	256,
@@ -237,6 +233,10 @@ static struct usb_serial_driver clie_3_5_device = {
 	.attach =		clie_3_5_startup,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;handspring_device, &amp;clie_5_device, &amp;clie_3_5_device, NULL
+};
+
 /******************************************************************************
  * Handspring Visor specific driver functions
  ******************************************************************************/
@@ -685,38 +685,17 @@ static int __init visor_init(void)
 		       ": Adding Palm OS protocol 4.x support for unknown device: 0x%x/0x%x\n",
 			vendor, product);
 	}
-	retval = usb_serial_register(&amp;handspring_device);
-	if (retval)
-		goto failed_handspring_register;
-	retval = usb_serial_register(&amp;clie_3_5_device);
-	if (retval)
-		goto failed_clie_3_5_register;
-	retval = usb_serial_register(&amp;clie_5_device);
-	if (retval)
-		goto failed_clie_5_register;
-	retval = usb_register(&amp;visor_driver);
-	if (retval)
-		goto failed_usb_register;
-	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_DESC "\n");
 
-	return 0;
-failed_usb_register:
-	usb_serial_deregister(&amp;clie_5_device);
-failed_clie_5_register:
-	usb_serial_deregister(&amp;clie_3_5_device);
-failed_clie_3_5_register:
-	usb_serial_deregister(&amp;handspring_device);
-failed_handspring_register:
+	retval = usb_serial_register_drivers(&amp;visor_driver, serial_drivers);
+	if (retval == 0)
+		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_DESC "\n");
 	return retval;
 }
 
 
 static void __exit visor_exit (void)
 {
-	usb_deregister(&amp;visor_driver);
-	usb_serial_deregister(&amp;handspring_device);
-	usb_serial_deregister(&amp;clie_3_5_device);
-	usb_serial_deregister(&amp;clie_5_device);
+	usb_serial_deregister_drivers(&amp;visor_driver, serial_drivers);
 }
 
 
diff --git a/drivers/usb/serial/vivopay-serial.c b/drivers/usb/serial/vivopay-serial.c
index f719d00972fc..a6f113bd4fae 100644
--- a/drivers/usb/serial/vivopay-serial.c
+++ b/drivers/usb/serial/vivopay-serial.c
@@ -30,7 +30,6 @@ static struct usb_driver vivopay_serial_driver = {
 	.probe =		usb_serial_probe,
 	.disconnect =		usb_serial_disconnect,
 	.id_table =		id_table,
-	.no_dynamic_id =	1,
 };
 
 static struct usb_serial_driver vivopay_serial_device = {
@@ -39,32 +38,28 @@ static struct usb_serial_driver vivopay_serial_device = {
 		.name =		"vivopay-serial",
 	},
 	.id_table =		id_table,
-	.usb_driver =		&amp;vivopay_serial_driver,
 	.num_ports =		1,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;vivopay_serial_device, NULL
+};
+
 static int __init vivopay_serial_init(void)
 {
 	int retval;
-	retval = usb_serial_register(&amp;vivopay_serial_device);
-	if (retval)
-		goto failed_usb_serial_register;
-	retval = usb_register(&amp;vivopay_serial_driver);
-	if (retval)
-		goto failed_usb_register;
-	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
-	    DRIVER_DESC "\n");
-	return 0;
-failed_usb_register:
-	usb_serial_deregister(&amp;vivopay_serial_device);
-failed_usb_serial_register:
+
+	retval = usb_serial_register_drivers(&amp;vivopay_serial_driver,
+			serial_drivers);
+	if (retval == 0)
+		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+				DRIVER_DESC "\n");
 	return retval;
 }
 
 static void __exit vivopay_serial_exit(void)
 {
-	usb_deregister(&amp;vivopay_serial_driver);
-	usb_serial_deregister(&amp;vivopay_serial_device);
+	usb_serial_deregister_drivers(&amp;vivopay_serial_driver, serial_drivers);
 }
 
 module_init(vivopay_serial_init);
diff --git a/drivers/usb/serial/whiteheat.c b/drivers/usb/serial/whiteheat.c
index 007cf3a2481a..a29be37a3a67 100644
--- a/drivers/usb/serial/whiteheat.c
+++ b/drivers/usb/serial/whiteheat.c
@@ -83,7 +83,6 @@ static struct usb_driver whiteheat_driver = {
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	id_table_combined,
-	.no_dynamic_id = 	1,
 };
 
 /* function prototypes for the Connect Tech WhiteHEAT prerenumeration device */
@@ -121,7 +120,6 @@ static struct usb_serial_driver whiteheat_fake_device = {
 		.name =		"whiteheatnofirm",
 	},
 	.description =		"Connect Tech - WhiteHEAT - (prerenumeration)",
-	.usb_driver =		&amp;whiteheat_driver,
 	.id_table =		id_table_prerenumeration,
 	.num_ports =		1,
 	.probe =		whiteheat_firmware_download,
@@ -134,7 +132,6 @@ static struct usb_serial_driver whiteheat_device = {
 		.name =		"whiteheat",
 	},
 	.description =		"Connect Tech - WhiteHEAT",
-	.usb_driver =		&amp;whiteheat_driver,
 	.id_table =		id_table_std,
 	.num_ports =		4,
 	.attach =		whiteheat_attach,
@@ -155,6 +152,9 @@ static struct usb_serial_driver whiteheat_device = {
 	.write_bulk_callback =	whiteheat_write_callback,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;whiteheat_fake_device, &amp;whiteheat_device, NULL
+};
 
 struct whiteheat_command_private {
 	struct mutex		mutex;
@@ -1461,32 +1461,18 @@ static void rx_data_softint(struct work_struct *work)
 static int __init whiteheat_init(void)
 {
 	int retval;
-	retval = usb_serial_register(&amp;whiteheat_fake_device);
-	if (retval)
-		goto failed_fake_register;
-	retval = usb_serial_register(&amp;whiteheat_device);
-	if (retval)
-		goto failed_device_register;
-	retval = usb_register(&amp;whiteheat_driver);
-	if (retval)
-		goto failed_usb_register;
-	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
-	       DRIVER_DESC "\n");
-	return 0;
-failed_usb_register:
-	usb_serial_deregister(&amp;whiteheat_device);
-failed_device_register:
-	usb_serial_deregister(&amp;whiteheat_fake_device);
-failed_fake_register:
+
+	retval = usb_serial_register_drivers(&amp;whiteheat_driver, serial_drivers);
+	if (retval == 0)
+		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+				DRIVER_DESC "\n");
 	return retval;
 }
 
 
 static void __exit whiteheat_exit(void)
 {
-	usb_deregister(&amp;whiteheat_driver);
-	usb_serial_deregister(&amp;whiteheat_fake_device);
-	usb_serial_deregister(&amp;whiteheat_device);
+	usb_serial_deregister_drivers(&amp;whiteheat_driver, serial_drivers);
 }
 
 
diff --git a/drivers/usb/serial/zio.c b/drivers/usb/serial/zio.c
index f57967278833..ae8115aab77d 100644
--- a/drivers/usb/serial/zio.c
+++ b/drivers/usb/serial/zio.c
@@ -27,7 +27,6 @@ static struct usb_driver zio_driver = {
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	id_table,
-	.no_dynamic_id =	1,
 };
 
 static struct usb_serial_driver zio_device = {
@@ -36,27 +35,21 @@ static struct usb_serial_driver zio_device = {
 		.name =		"zio",
 	},
 	.id_table =		id_table,
-	.usb_driver =		&amp;zio_driver,
 	.num_ports =		1,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;zio_device, NULL
+};
+
 static int __init zio_init(void)
 {
-	int retval;
-
-	retval = usb_serial_register(&amp;zio_device);
-	if (retval)
-		return retval;
-	retval = usb_register(&amp;zio_driver);
-	if (retval)
-		usb_serial_deregister(&amp;zio_device);
-	return retval;
+	return usb_serial_register_drivers(&amp;zio_driver, serial_drivers);
 }
 
 static void __exit zio_exit(void)
 {
-	usb_deregister(&amp;zio_driver);
-	usb_serial_deregister(&amp;zio_device);
+	usb_serial_deregister_drivers(&amp;zio_driver, serial_drivers);
 }
 
 module_init(zio_init);</pre><hr><pre>commit d860322f34e4a53f347b1aeae23d5b72f1e91b8c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Feb 23 14:57:25 2012 -0500

    usb-serial: use new registration API in [q-s]* drivers
    
    This patch (as1528) modifies the following usb-serial drivers to
    utilize the new usb_serial_{de}register_drivers() routines:
    
            qcaux, qcserial, safe_serial, siemens_mpi, sierra,
            spcp8x5, ssu100, and symbolserial.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/serial/qcaux.c b/drivers/usb/serial/qcaux.c
index a34819884c1a..a2ce274b3f28 100644
--- a/drivers/usb/serial/qcaux.c
+++ b/drivers/usb/serial/qcaux.c
@@ -82,7 +82,6 @@ static struct usb_driver qcaux_driver = {
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	id_table,
-	.no_dynamic_id = 	1,
 };
 
 static struct usb_serial_driver qcaux_device = {
@@ -91,27 +90,21 @@ static struct usb_serial_driver qcaux_device = {
 		.name =		"qcaux",
 	},
 	.id_table =		id_table,
-	.usb_driver =		&amp;qcaux_driver,
 	.num_ports =		1,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;qcaux_device, NULL
+};
+
 static int __init qcaux_init(void)
 {
-	int retval;
-
-	retval = usb_serial_register(&amp;qcaux_device);
-	if (retval)
-		return retval;
-	retval = usb_register(&amp;qcaux_driver);
-	if (retval)
-		usb_serial_deregister(&amp;qcaux_device);
-	return retval;
+	return usb_serial_register_drivers(&amp;qcaux_driver, serial_drivers);
 }
 
 static void __exit qcaux_exit(void)
 {
-	usb_deregister(&amp;qcaux_driver);
-	usb_serial_deregister(&amp;qcaux_device);
+	usb_serial_deregister_drivers(&amp;qcaux_driver, serial_drivers);
 }
 
 module_init(qcaux_init);
diff --git a/drivers/usb/serial/qcserial.c b/drivers/usb/serial/qcserial.c
index f98800f2324c..70e9f1abdad1 100644
--- a/drivers/usb/serial/qcserial.c
+++ b/drivers/usb/serial/qcserial.c
@@ -246,7 +246,6 @@ static struct usb_serial_driver qcdevice = {
 	},
 	.description         = "Qualcomm USB modem",
 	.id_table            = id_table,
-	.usb_driver          = &amp;qcdriver,
 	.num_ports           = 1,
 	.probe               = qcprobe,
 	.open		     = usb_wwan_open,
@@ -263,27 +262,18 @@ static struct usb_serial_driver qcdevice = {
 #endif
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;qcdevice, NULL
+};
+
 static int __init qcinit(void)
 {
-	int retval;
-
-	retval = usb_serial_register(&amp;qcdevice);
-	if (retval)
-		return retval;
-
-	retval = usb_register(&amp;qcdriver);
-	if (retval) {
-		usb_serial_deregister(&amp;qcdevice);
-		return retval;
-	}
-
-	return 0;
+	return usb_serial_register_drivers(&amp;qcdriver, serial_drivers);
 }
 
 static void __exit qcexit(void)
 {
-	usb_deregister(&amp;qcdriver);
-	usb_serial_deregister(&amp;qcdevice);
+	usb_serial_deregister_drivers(&amp;qcdriver, serial_drivers);
 }
 
 module_init(qcinit);
diff --git a/drivers/usb/serial/safe_serial.c b/drivers/usb/serial/safe_serial.c
index d074b3740dcb..ae4ee30c7411 100644
--- a/drivers/usb/serial/safe_serial.c
+++ b/drivers/usb/serial/safe_serial.c
@@ -156,7 +156,6 @@ static struct usb_driver safe_driver = {
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	id_table,
-	.no_dynamic_id = 	1,
 };
 
 static const __u16 crc10_table[256] = {
@@ -309,16 +308,19 @@ static struct usb_serial_driver safe_device = {
 		.name =		"safe_serial",
 	},
 	.id_table =		id_table,
-	.usb_driver =		&amp;safe_driver,
 	.num_ports =		1,
 	.process_read_urb =	safe_process_read_urb,
 	.prepare_write_buffer =	safe_prepare_write_buffer,
 	.attach =		safe_startup,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;safe_device, NULL
+};
+
 static int __init safe_init(void)
 {
-	int i, retval;
+	int i;
 
 	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
 	       DRIVER_DESC "\n");
@@ -337,24 +339,12 @@ static int __init safe_init(void)
 		}
 	}
 
-	retval = usb_serial_register(&amp;safe_device);
-	if (retval)
-		goto failed_usb_serial_register;
-	retval = usb_register(&amp;safe_driver);
-	if (retval)
-		goto failed_usb_register;
-
-	return 0;
-failed_usb_register:
-	usb_serial_deregister(&amp;safe_device);
-failed_usb_serial_register:
-	return retval;
+	return usb_serial_register_drivers(&amp;safe_driver, serial_drivers);
 }
 
 static void __exit safe_exit(void)
 {
-	usb_deregister(&amp;safe_driver);
-	usb_serial_deregister(&amp;safe_device);
+	usb_serial_deregister_drivers(&amp;safe_driver, serial_drivers);
 }
 
 module_init(safe_init);
diff --git a/drivers/usb/serial/siemens_mpi.c b/drivers/usb/serial/siemens_mpi.c
index 74cd4ccdb3fc..8aa4c1aef6d1 100644
--- a/drivers/usb/serial/siemens_mpi.c
+++ b/drivers/usb/serial/siemens_mpi.c
@@ -42,33 +42,29 @@ static struct usb_serial_driver siemens_usb_mpi_device = {
 		.name =		"siemens_mpi",
 	},
 	.id_table =		id_table,
-	.usb_driver =		&amp;siemens_usb_mpi_driver,
 	.num_ports =		1,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;siemens_usb_mpi_device, NULL
+};
+
 static int __init siemens_usb_mpi_init(void)
 {
 	int retval;
 
-	retval = usb_serial_register(&amp;siemens_usb_mpi_device);
-	if (retval)
-		goto failed_usb_serial_register;
-	retval = usb_register(&amp;siemens_usb_mpi_driver);
-	if (retval)
-		goto failed_usb_register;
-	printk(KERN_INFO DRIVER_DESC "\n");
-	printk(KERN_INFO DRIVER_VERSION " " DRIVER_AUTHOR "\n");
-	return retval;
-failed_usb_register:
-	usb_serial_deregister(&amp;siemens_usb_mpi_device);
-failed_usb_serial_register:
+	retval = usb_serial_register_drivers(&amp;siemens_usb_mpi_driver,
+			serial_drivers);
+	if (retval == 0) {
+		printk(KERN_INFO DRIVER_DESC "\n");
+		printk(KERN_INFO DRIVER_VERSION " " DRIVER_AUTHOR "\n");
+	}
 	return retval;
 }
 
 static void __exit siemens_usb_mpi_exit(void)
 {
-	usb_deregister(&amp;siemens_usb_mpi_driver);
-	usb_serial_deregister(&amp;siemens_usb_mpi_device);
+	usb_serial_deregister_drivers(&amp;siemens_usb_mpi_driver, serial_drivers);
 }
 
 module_init(siemens_usb_mpi_init);
diff --git a/drivers/usb/serial/sierra.c b/drivers/usb/serial/sierra.c
index fdae0a4407cb..d75a75b83e9f 100644
--- a/drivers/usb/serial/sierra.c
+++ b/drivers/usb/serial/sierra.c
@@ -1084,7 +1084,6 @@ static struct usb_driver sierra_driver = {
 	.resume     = usb_serial_resume,
 	.reset_resume = sierra_reset_resume,
 	.id_table   = id_table,
-	.no_dynamic_id = 	1,
 	.supports_autosuspend =	1,
 };
 
@@ -1095,7 +1094,6 @@ static struct usb_serial_driver sierra_device = {
 	},
 	.description       = "Sierra USB modem",
 	.id_table          = id_table,
-	.usb_driver        = &amp;sierra_driver,
 	.calc_num_ports	   = sierra_calc_num_ports,
 	.probe		   = sierra_probe,
 	.open              = sierra_open,
@@ -1113,34 +1111,25 @@ static struct usb_serial_driver sierra_device = {
 	.read_int_callback = sierra_instat_callback,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;sierra_device, NULL
+};
+
 /* Functions used by new usb-serial code. */
 static int __init sierra_init(void)
 {
 	int retval;
-	retval = usb_serial_register(&amp;sierra_device);
-	if (retval)
-		goto failed_device_register;
-
-
-	retval = usb_register(&amp;sierra_driver);
-	if (retval)
-		goto failed_driver_register;
-
-	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
-	       DRIVER_DESC "\n");
-
-	return 0;
 
-failed_driver_register:
-	usb_serial_deregister(&amp;sierra_device);
-failed_device_register:
+	retval = usb_serial_register_drivers(&amp;sierra_driver, serial_drivers);
+	if (retval == 0)
+		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+			       DRIVER_DESC "\n");
 	return retval;
 }
 
 static void __exit sierra_exit(void)
 {
-	usb_deregister(&amp;sierra_driver);
-	usb_serial_deregister(&amp;sierra_device);
+	usb_serial_deregister_drivers(&amp;sierra_driver, serial_drivers);
 }
 
 module_init(sierra_init);
diff --git a/drivers/usb/serial/spcp8x5.c b/drivers/usb/serial/spcp8x5.c
index d7f5eee18f00..af898937d4b1 100644
--- a/drivers/usb/serial/spcp8x5.c
+++ b/drivers/usb/serial/spcp8x5.c
@@ -156,7 +156,6 @@ static struct usb_driver spcp8x5_driver = {
 	.probe =		usb_serial_probe,
 	.disconnect =		usb_serial_disconnect,
 	.id_table =		id_table,
-	.no_dynamic_id =	1,
 };
 
 
@@ -649,7 +648,6 @@ static struct usb_serial_driver spcp8x5_device = {
 		.name =		"SPCP8x5",
 	},
 	.id_table		= id_table,
-	.usb_driver		= &amp;spcp8x5_driver,
 	.num_ports		= 1,
 	.open 			= spcp8x5_open,
 	.dtr_rts		= spcp8x5_dtr_rts,
@@ -664,28 +662,24 @@ static struct usb_serial_driver spcp8x5_device = {
 	.process_read_urb	= spcp8x5_process_read_urb,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;spcp8x5_device, NULL
+};
+
 static int __init spcp8x5_init(void)
 {
 	int retval;
-	retval = usb_serial_register(&amp;spcp8x5_device);
-	if (retval)
-		goto failed_usb_serial_register;
-	retval = usb_register(&amp;spcp8x5_driver);
-	if (retval)
-		goto failed_usb_register;
-	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
-	       DRIVER_DESC "\n");
-	return 0;
-failed_usb_register:
-	usb_serial_deregister(&amp;spcp8x5_device);
-failed_usb_serial_register:
+
+	retval = usb_serial_register_drivers(&amp;spcp8x5_driver, serial_drivers);
+	if (retval == 0)
+		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+			       DRIVER_DESC "\n");
 	return retval;
 }
 
 static void __exit spcp8x5_exit(void)
 {
-	usb_deregister(&amp;spcp8x5_driver);
-	usb_serial_deregister(&amp;spcp8x5_device);
+	usb_serial_deregister_drivers(&amp;spcp8x5_driver, serial_drivers);
 }
 
 module_init(spcp8x5_init);
diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index 7697858d8858..ab8842107a8b 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -70,7 +70,6 @@ static struct usb_driver ssu100_driver = {
 	.id_table		       = id_table,
 	.suspend		       = usb_serial_suspend,
 	.resume			       = usb_serial_resume,
-	.no_dynamic_id		       = 1,
 	.supports_autosuspend	       = 1,
 };
 
@@ -677,7 +676,6 @@ static struct usb_serial_driver ssu100_device = {
 	},
 	.description	     = DRIVER_DESC,
 	.id_table	     = id_table,
-	.usb_driver	     = &amp;ssu100_driver,
 	.num_ports	     = 1,
 	.open		     = ssu100_open,
 	.close		     = ssu100_close,
@@ -693,37 +691,26 @@ static struct usb_serial_driver ssu100_device = {
 	.disconnect          = usb_serial_generic_disconnect,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;ssu100_device, NULL
+};
+
 static int __init ssu100_init(void)
 {
 	int retval;
 
 	dbg("%s", __func__);
 
-	/* register with usb-serial */
-	retval = usb_serial_register(&amp;ssu100_device);
-
-	if (retval)
-		goto failed_usb_sio_register;
-
-	retval = usb_register(&amp;ssu100_driver);
-	if (retval)
-		goto failed_usb_register;
-
-	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
-	       DRIVER_DESC "\n");
-
-	return 0;
-
-failed_usb_register:
-	usb_serial_deregister(&amp;ssu100_device);
-failed_usb_sio_register:
+	retval = usb_serial_register_drivers(&amp;ssu100_driver, serial_drivers);
+	if (retval == 0)
+		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+			       DRIVER_DESC "\n");
 	return retval;
 }
 
 static void __exit ssu100_exit(void)
 {
-	usb_deregister(&amp;ssu100_driver);
-	usb_serial_deregister(&amp;ssu100_device);
+	usb_serial_deregister_drivers(&amp;ssu100_driver, serial_drivers);
 }
 
 module_init(ssu100_init);
diff --git a/drivers/usb/serial/symbolserial.c b/drivers/usb/serial/symbolserial.c
index 50651cf4fc61..76cd9f2a08c0 100644
--- a/drivers/usb/serial/symbolserial.c
+++ b/drivers/usb/serial/symbolserial.c
@@ -287,7 +287,6 @@ static struct usb_driver symbol_driver = {
 	.probe =		usb_serial_probe,
 	.disconnect =		usb_serial_disconnect,
 	.id_table =		id_table,
-	.no_dynamic_id = 	1,
 };
 
 static struct usb_serial_driver symbol_device = {
@@ -296,7 +295,6 @@ static struct usb_serial_driver symbol_device = {
 		.name =		"symbol",
 	},
 	.id_table =		id_table,
-	.usb_driver = 		&amp;symbol_driver,
 	.num_ports =		1,
 	.attach =		symbol_startup,
 	.open =			symbol_open,
@@ -307,23 +305,18 @@ static struct usb_serial_driver symbol_device = {
 	.unthrottle =		symbol_unthrottle,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;symbol_device, NULL
+};
+
 static int __init symbol_init(void)
 {
-	int retval;
-
-	retval = usb_serial_register(&amp;symbol_device);
-	if (retval)
-		return retval;
-	retval = usb_register(&amp;symbol_driver);
-	if (retval)
-		usb_serial_deregister(&amp;symbol_device);
-	return retval;
+	return usb_serial_register_drivers(&amp;symbol_driver, serial_drivers);
 }
 
 static void __exit symbol_exit(void)
 {
-	usb_deregister(&amp;symbol_driver);
-	usb_serial_deregister(&amp;symbol_device);
+	usb_serial_deregister_drivers(&amp;symbol_driver, serial_drivers);
 }
 
 module_init(symbol_init);</pre><hr><pre>commit f667ddad41e303ebc2c6d5bf3105dffe2fbdd717
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Feb 23 14:57:18 2012 -0500

    usb-serial: use new registration API in [n-p]* drivers
    
    This patch (as1527) modifies the following usb-serial drivers to
    utilize the new usb_serial_{de}register_drivers() routines:
    
            navman, omninet, opticon, option, oti6858, and pl2303.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/serial/navman.c b/drivers/usb/serial/navman.c
index b28f1db0195f..fd4b2c833c0b 100644
--- a/drivers/usb/serial/navman.c
+++ b/drivers/usb/serial/navman.c
@@ -35,7 +35,6 @@ static struct usb_driver navman_driver = {
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	id_table,
-	.no_dynamic_id = 	1,
 };
 
 static void navman_read_int_callback(struct urb *urb)
@@ -122,7 +121,6 @@ static struct usb_serial_driver navman_device = {
 		.name =		"navman",
 	},
 	.id_table =		id_table,
-	.usb_driver =		&amp;navman_driver,
 	.num_ports =		1,
 	.open =			navman_open,
 	.close = 		navman_close,
@@ -130,23 +128,18 @@ static struct usb_serial_driver navman_device = {
 	.read_int_callback =	navman_read_int_callback,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;navman_device, NULL
+};
+
 static int __init navman_init(void)
 {
-	int retval;
-
-	retval = usb_serial_register(&amp;navman_device);
-	if (retval)
-		return retval;
-	retval = usb_register(&amp;navman_driver);
-	if (retval)
-		usb_serial_deregister(&amp;navman_device);
-	return retval;
+	return usb_serial_register_drivers(&amp;navman_driver, serial_drivers);
 }
 
 static void __exit navman_exit(void)
 {
-	usb_deregister(&amp;navman_driver);
-	usb_serial_deregister(&amp;navman_device);
+	usb_serial_deregister_drivers(&amp;navman_driver, serial_drivers);
 }
 
 module_init(navman_init);
diff --git a/drivers/usb/serial/omninet.c b/drivers/usb/serial/omninet.c
index 033e8afa6c77..975d5c559ccb 100644
--- a/drivers/usb/serial/omninet.c
+++ b/drivers/usb/serial/omninet.c
@@ -62,7 +62,6 @@ static struct usb_driver omninet_driver = {
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	id_table,
-	.no_dynamic_id = 	1,
 };
 
 
@@ -72,7 +71,6 @@ static struct usb_serial_driver zyxel_omninet_device = {
 		.name =		"omninet",
 	},
 	.description =		"ZyXEL - omni.net lcd plus usb",
-	.usb_driver =		&amp;omninet_driver,
 	.id_table =		id_table,
 	.num_ports =		1,
 	.attach =		omninet_attach,
@@ -86,6 +84,10 @@ static struct usb_serial_driver zyxel_omninet_device = {
 	.release =		omninet_release,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;zyxel_omninet_device, NULL
+};
+
 
 /* The protocol.
  *
@@ -323,26 +325,18 @@ static void omninet_release(struct usb_serial *serial)
 static int __init omninet_init(void)
 {
 	int retval;
-	retval = usb_serial_register(&amp;zyxel_omninet_device);
-	if (retval)
-		goto failed_usb_serial_register;
-	retval = usb_register(&amp;omninet_driver);
-	if (retval)
-		goto failed_usb_register;
-	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
-	       DRIVER_DESC "\n");
-	return 0;
-failed_usb_register:
-	usb_serial_deregister(&amp;zyxel_omninet_device);
-failed_usb_serial_register:
+
+	retval = usb_serial_register_drivers(&amp;omninet_driver, serial_drivers);
+	if (retval == 0)
+		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+			       DRIVER_DESC "\n");
 	return retval;
 }
 
 
 static void __exit omninet_exit(void)
 {
-	usb_deregister(&amp;omninet_driver);
-	usb_serial_deregister(&amp;zyxel_omninet_device);
+	usb_serial_deregister_drivers(&amp;omninet_driver, serial_drivers);
 }
 
 
diff --git a/drivers/usb/serial/opticon.c b/drivers/usb/serial/opticon.c
index 262ded9e076b..7001ad779b94 100644
--- a/drivers/usb/serial/opticon.c
+++ b/drivers/usb/serial/opticon.c
@@ -604,7 +604,6 @@ static struct usb_driver opticon_driver = {
 	.suspend =	opticon_suspend,
 	.resume =	opticon_resume,
 	.id_table =	id_table,
-	.no_dynamic_id = 	1,
 };
 
 static struct usb_serial_driver opticon_device = {
@@ -613,7 +612,6 @@ static struct usb_serial_driver opticon_device = {
 		.name =		"opticon",
 	},
 	.id_table =		id_table,
-	.usb_driver = 		&amp;opticon_driver,
 	.num_ports =		1,
 	.attach =		opticon_startup,
 	.open =			opticon_open,
@@ -629,23 +627,18 @@ static struct usb_serial_driver opticon_device = {
 	.tiocmset =		opticon_tiocmset,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;opticon_device, NULL
+};
+
 static int __init opticon_init(void)
 {
-	int retval;
-
-	retval = usb_serial_register(&amp;opticon_device);
-	if (retval)
-		return retval;
-	retval = usb_register(&amp;opticon_driver);
-	if (retval)
-		usb_serial_deregister(&amp;opticon_device);
-	return retval;
+	return usb_serial_register_drivers(&amp;opticon_driver, serial_drivers);
 }
 
 static void __exit opticon_exit(void)
 {
-	usb_deregister(&amp;opticon_driver);
-	usb_serial_deregister(&amp;opticon_device);
+	usb_serial_deregister_drivers(&amp;opticon_driver, serial_drivers);
 }
 
 module_init(opticon_init);
diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c
index b54afceb9611..138a7b98cda4 100644
--- a/drivers/usb/serial/option.c
+++ b/drivers/usb/serial/option.c
@@ -1212,7 +1212,6 @@ static struct usb_driver option_driver = {
 	.supports_autosuspend =	1,
 #endif
 	.id_table   = option_ids,
-	.no_dynamic_id = 	1,
 };
 
 /* The card has three separate interfaces, which the serial driver
@@ -1225,7 +1224,6 @@ static struct usb_serial_driver option_1port_device = {
 		.name =		"option1",
 	},
 	.description       = "GSM modem (1-port)",
-	.usb_driver        = &amp;option_driver,
 	.id_table          = option_ids,
 	.num_ports         = 1,
 	.probe             = option_probe,
@@ -1249,6 +1247,10 @@ static struct usb_serial_driver option_1port_device = {
 #endif
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;option_1port_device, NULL
+};
+
 static bool debug;
 
 /* per port private data */
@@ -1284,28 +1286,17 @@ struct option_port_private {
 static int __init option_init(void)
 {
 	int retval;
-	retval = usb_serial_register(&amp;option_1port_device);
-	if (retval)
-		goto failed_1port_device_register;
-	retval = usb_register(&amp;option_driver);
-	if (retval)
-		goto failed_driver_register;
-
-	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
-	       DRIVER_DESC "\n");
-
-	return 0;
 
-failed_driver_register:
-	usb_serial_deregister(&amp;option_1port_device);
-failed_1port_device_register:
+	retval = usb_serial_register_drivers(&amp;option_driver, serial_drivers);
+	if (retval == 0)
+		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+			       DRIVER_DESC "\n");
 	return retval;
 }
 
 static void __exit option_exit(void)
 {
-	usb_deregister(&amp;option_driver);
-	usb_serial_deregister(&amp;option_1port_device);
+	usb_serial_deregister_drivers(&amp;option_driver, serial_drivers);
 }
 
 module_init(option_init);
diff --git a/drivers/usb/serial/oti6858.c b/drivers/usb/serial/oti6858.c
index 343e626a06f8..53f2768c9a36 100644
--- a/drivers/usb/serial/oti6858.c
+++ b/drivers/usb/serial/oti6858.c
@@ -71,7 +71,6 @@ static struct usb_driver oti6858_driver = {
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	id_table,
-	.no_dynamic_id = 	1,
 };
 
 static bool debug;
@@ -157,7 +156,6 @@ static struct usb_serial_driver oti6858_device = {
 		.name =		"oti6858",
 	},
 	.id_table =		id_table,
-	.usb_driver =		&amp;oti6858_driver,
 	.num_ports =		1,
 	.open =			oti6858_open,
 	.close =		oti6858_close,
@@ -176,6 +174,10 @@ static struct usb_serial_driver oti6858_device = {
 	.release =		oti6858_release,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;oti6858_device, NULL
+};
+
 struct oti6858_private {
 	spinlock_t lock;
 
@@ -960,21 +962,12 @@ static void oti6858_write_bulk_callback(struct urb *urb)
 
 static int __init oti6858_init(void)
 {
-	int retval;
-
-	retval = usb_serial_register(&amp;oti6858_device);
-	if (retval == 0) {
-		retval = usb_register(&amp;oti6858_driver);
-		if (retval)
-			usb_serial_deregister(&amp;oti6858_device);
-	}
-	return retval;
+	return usb_serial_register_drivers(&amp;oti6858_driver, serial_drivers);
 }
 
 static void __exit oti6858_exit(void)
 {
-	usb_deregister(&amp;oti6858_driver);
-	usb_serial_deregister(&amp;oti6858_device);
+	usb_serial_deregister_drivers(&amp;oti6858_driver, serial_drivers);
 }
 
 module_init(oti6858_init);
diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 3d8cda57ce7a..cc65d810c8f5 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -104,7 +104,6 @@ static struct usb_driver pl2303_driver = {
 	.id_table =	id_table,
 	.suspend =      usb_serial_suspend,
 	.resume =       usb_serial_resume,
-	.no_dynamic_id = 	1,
 	.supports_autosuspend =	1,
 };
 
@@ -834,7 +833,6 @@ static struct usb_serial_driver pl2303_device = {
 		.name =		"pl2303",
 	},
 	.id_table =		id_table,
-	.usb_driver = 		&amp;pl2303_driver,
 	.num_ports =		1,
 	.bulk_in_size =		256,
 	.bulk_out_size =	256,
@@ -853,28 +851,23 @@ static struct usb_serial_driver pl2303_device = {
 	.release =		pl2303_release,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;pl2303_device, NULL
+};
+
 static int __init pl2303_init(void)
 {
 	int retval;
 
-	retval = usb_serial_register(&amp;pl2303_device);
-	if (retval)
-		goto failed_usb_serial_register;
-	retval = usb_register(&amp;pl2303_driver);
-	if (retval)
-		goto failed_usb_register;
-	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_DESC "\n");
-	return 0;
-failed_usb_register:
-	usb_serial_deregister(&amp;pl2303_device);
-failed_usb_serial_register:
+	retval = usb_serial_register_drivers(&amp;pl2303_driver, serial_drivers);
+	if (retval == 0)
+		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_DESC "\n");
 	return retval;
 }
 
 static void __exit pl2303_exit(void)
 {
-	usb_deregister(&amp;pl2303_driver);
-	usb_serial_deregister(&amp;pl2303_device);
+	usb_serial_deregister_drivers(&amp;pl2303_driver, serial_drivers);
 }
 
 module_init(pl2303_init);</pre><hr><pre>commit 4d2a7aff1062048ea59214b49ca1d915586d6d6d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Feb 23 14:57:09 2012 -0500

    usb-serial: use new registration API in [k-m]* drivers
    
    This patch (as1526) modifies the following usb-serial drivers to
    utilize the new usb_serial_{de}register_drivers() routines:
    
            keyspan, kl5kusb105, kobil_sct, mct_u232, mos7720,
            mos7840, and moto_modem.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/serial/keyspan.c b/drivers/usb/serial/keyspan.c
index 4cc36c761801..0d5d3025a663 100644
--- a/drivers/usb/serial/keyspan.c
+++ b/drivers/usb/serial/keyspan.c
@@ -134,45 +134,17 @@ struct keyspan_port_private {
 static int __init keyspan_init(void)
 {
 	int retval;
-	retval = usb_serial_register(&amp;keyspan_pre_device);
-	if (retval)
-		goto failed_pre_device_register;
-	retval = usb_serial_register(&amp;keyspan_1port_device);
-	if (retval)
-		goto failed_1port_device_register;
-	retval = usb_serial_register(&amp;keyspan_2port_device);
-	if (retval)
-		goto failed_2port_device_register;
-	retval = usb_serial_register(&amp;keyspan_4port_device);
-	if (retval)
-		goto failed_4port_device_register;
-	retval = usb_register(&amp;keyspan_driver);
-	if (retval)
-		goto failed_usb_register;
-
-	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
-	       DRIVER_DESC "\n");
 
-	return 0;
-failed_usb_register:
-	usb_serial_deregister(&amp;keyspan_4port_device);
-failed_4port_device_register:
-	usb_serial_deregister(&amp;keyspan_2port_device);
-failed_2port_device_register:
-	usb_serial_deregister(&amp;keyspan_1port_device);
-failed_1port_device_register:
-	usb_serial_deregister(&amp;keyspan_pre_device);
-failed_pre_device_register:
+	retval = usb_serial_register_drivers(&amp;keyspan_driver, serial_drivers);
+	if (retval == 0)
+		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+			       DRIVER_DESC "\n");
 	return retval;
 }
 
 static void __exit keyspan_exit(void)
 {
-	usb_deregister(&amp;keyspan_driver);
-	usb_serial_deregister(&amp;keyspan_pre_device);
-	usb_serial_deregister(&amp;keyspan_1port_device);
-	usb_serial_deregister(&amp;keyspan_2port_device);
-	usb_serial_deregister(&amp;keyspan_4port_device);
+	usb_serial_deregister_drivers(&amp;keyspan_driver, serial_drivers);
 }
 
 module_init(keyspan_init);
diff --git a/drivers/usb/serial/keyspan.h b/drivers/usb/serial/keyspan.h
index 13fa1d1cc900..622853c9e384 100644
--- a/drivers/usb/serial/keyspan.h
+++ b/drivers/usb/serial/keyspan.h
@@ -492,7 +492,6 @@ static struct usb_driver keyspan_driver = {
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	keyspan_ids_combined,
-	.no_dynamic_id = 	1,
 };
 
 /* usb_device_id table for the pre-firmware download keyspan devices */
@@ -545,7 +544,6 @@ static struct usb_serial_driver keyspan_pre_device = {
 		.name		= "keyspan_no_firm",
 	},
 	.description		= "Keyspan - (without firmware)",
-	.usb_driver		= &amp;keyspan_driver,
 	.id_table		= keyspan_pre_ids,
 	.num_ports		= 1,
 	.attach			= keyspan_fake_startup,
@@ -557,7 +555,6 @@ static struct usb_serial_driver keyspan_1port_device = {
 		.name		= "keyspan_1",
 	},
 	.description		= "Keyspan 1 port adapter",
-	.usb_driver		= &amp;keyspan_driver,
 	.id_table		= keyspan_1port_ids,
 	.num_ports		= 1,
 	.open			= keyspan_open,
@@ -580,7 +577,6 @@ static struct usb_serial_driver keyspan_2port_device = {
 		.name		= "keyspan_2",
 	},
 	.description		= "Keyspan 2 port adapter",
-	.usb_driver		= &amp;keyspan_driver,
 	.id_table		= keyspan_2port_ids,
 	.num_ports		= 2,
 	.open			= keyspan_open,
@@ -603,7 +599,6 @@ static struct usb_serial_driver keyspan_4port_device = {
 		.name		= "keyspan_4",
 	},
 	.description		= "Keyspan 4 port adapter",
-	.usb_driver		= &amp;keyspan_driver,
 	.id_table		= keyspan_4port_ids,
 	.num_ports		= 4,
 	.open			= keyspan_open,
@@ -620,4 +615,9 @@ static struct usb_serial_driver keyspan_4port_device = {
 	.release		= keyspan_release,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;keyspan_pre_device, &amp;keyspan_1port_device,
+	&amp;keyspan_2port_device, &amp;keyspan_4port_device, NULL
+};
+
 #endif
diff --git a/drivers/usb/serial/kl5kusb105.c b/drivers/usb/serial/kl5kusb105.c
index fc064e1442ca..0e65e50edd50 100644
--- a/drivers/usb/serial/kl5kusb105.c
+++ b/drivers/usb/serial/kl5kusb105.c
@@ -91,7 +91,6 @@ static struct usb_driver kl5kusb105d_driver = {
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	id_table,
-	.no_dynamic_id =	1,
 };
 
 static struct usb_serial_driver kl5kusb105d_device = {
@@ -100,7 +99,6 @@ static struct usb_serial_driver kl5kusb105d_device = {
 		.name =		"kl5kusb105d",
 	},
 	.description =		"KL5KUSB105D / PalmConnect",
-	.usb_driver =		&amp;kl5kusb105d_driver,
 	.id_table =		id_table,
 	.num_ports =		1,
 	.bulk_out_size =	64,
@@ -118,6 +116,10 @@ static struct usb_serial_driver kl5kusb105d_device = {
 	.prepare_write_buffer =	klsi_105_prepare_write_buffer,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;kl5kusb105d_device, NULL
+};
+
 struct klsi_105_port_settings {
 	__u8	pktlen;		/* always 5, it seems */
 	__u8	baudrate;
@@ -694,26 +696,18 @@ static int klsi_105_tiocmset(struct tty_struct *tty,
 static int __init klsi_105_init(void)
 {
 	int retval;
-	retval = usb_serial_register(&amp;kl5kusb105d_device);
-	if (retval)
-		goto failed_usb_serial_register;
-	retval = usb_register(&amp;kl5kusb105d_driver);
-	if (retval)
-		goto failed_usb_register;
-
-	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
-	       DRIVER_DESC "\n");
-	return 0;
-failed_usb_register:
-	usb_serial_deregister(&amp;kl5kusb105d_device);
-failed_usb_serial_register:
+
+	retval = usb_serial_register_drivers(&amp;kl5kusb105d_driver,
+			serial_drivers);
+	if (retval == 0)
+		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+			       DRIVER_DESC "\n");
 	return retval;
 }
 
 static void __exit klsi_105_exit(void)
 {
-	usb_deregister(&amp;kl5kusb105d_driver);
-	usb_serial_deregister(&amp;kl5kusb105d_device);
+	usb_serial_deregister_drivers(&amp;kl5kusb105d_driver, serial_drivers);
 }
 
 
diff --git a/drivers/usb/serial/kobil_sct.c b/drivers/usb/serial/kobil_sct.c
index a92a3efb507b..a033dd7dc265 100644
--- a/drivers/usb/serial/kobil_sct.c
+++ b/drivers/usb/serial/kobil_sct.c
@@ -90,7 +90,6 @@ static struct usb_driver kobil_driver = {
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	id_table,
-	.no_dynamic_id = 	1,
 };
 
 
@@ -100,7 +99,6 @@ static struct usb_serial_driver kobil_device = {
 		.name =		"kobil",
 	},
 	.description =		"KOBIL USB smart card terminal",
-	.usb_driver = 		&amp;kobil_driver,
 	.id_table =		id_table,
 	.num_ports =		1,
 	.attach =		kobil_startup,
@@ -117,6 +115,9 @@ static struct usb_serial_driver kobil_device = {
 	.read_int_callback =	kobil_read_int_callback,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;kobil_device, NULL
+};
 
 struct kobil_private {
 	int write_int_endpoint_address;
@@ -685,28 +686,18 @@ static int kobil_ioctl(struct tty_struct *tty,
 static int __init kobil_init(void)
 {
 	int retval;
-	retval = usb_serial_register(&amp;kobil_device);
-	if (retval)
-		goto failed_usb_serial_register;
-	retval = usb_register(&amp;kobil_driver);
-	if (retval)
-		goto failed_usb_register;
-
-	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
-	       DRIVER_DESC "\n");
 
-	return 0;
-failed_usb_register:
-	usb_serial_deregister(&amp;kobil_device);
-failed_usb_serial_register:
+	retval = usb_serial_register_drivers(&amp;kobil_driver, serial_drivers);
+	if (retval == 0)
+		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+			       DRIVER_DESC "\n");
 	return retval;
 }
 
 
 static void __exit kobil_exit(void)
 {
-	usb_deregister(&amp;kobil_driver);
-	usb_serial_deregister(&amp;kobil_device);
+	usb_serial_deregister_drivers(&amp;kobil_driver, serial_drivers);
 }
 
 module_init(kobil_init);
diff --git a/drivers/usb/serial/mct_u232.c b/drivers/usb/serial/mct_u232.c
index 27fa9c8a77b0..6d9a7f8b13db 100644
--- a/drivers/usb/serial/mct_u232.c
+++ b/drivers/usb/serial/mct_u232.c
@@ -88,7 +88,6 @@ static struct usb_driver mct_u232_driver = {
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	id_table_combined,
-	.no_dynamic_id = 	1,
 };
 
 static struct usb_serial_driver mct_u232_device = {
@@ -97,7 +96,6 @@ static struct usb_serial_driver mct_u232_device = {
 		.name =		"mct_u232",
 	},
 	.description =	     "MCT U232",
-	.usb_driver = 	     &amp;mct_u232_driver,
 	.id_table =	     id_table_combined,
 	.num_ports =	     1,
 	.open =		     mct_u232_open,
@@ -116,6 +114,10 @@ static struct usb_serial_driver mct_u232_device = {
 	.get_icount =        mct_u232_get_icount,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;mct_u232_device, NULL
+};
+
 struct mct_u232_private {
 	spinlock_t lock;
 	unsigned int	     control_state; /* Modem Line Setting (TIOCM) */
@@ -907,26 +909,18 @@ static int  mct_u232_get_icount(struct tty_struct *tty,
 static int __init mct_u232_init(void)
 {
 	int retval;
-	retval = usb_serial_register(&amp;mct_u232_device);
-	if (retval)
-		goto failed_usb_serial_register;
-	retval = usb_register(&amp;mct_u232_driver);
-	if (retval)
-		goto failed_usb_register;
-	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
-	       DRIVER_DESC "\n");
-	return 0;
-failed_usb_register:
-	usb_serial_deregister(&amp;mct_u232_device);
-failed_usb_serial_register:
+
+	retval = usb_serial_register_drivers(&amp;mct_u232_driver, serial_drivers);
+	if (retval == 0)
+		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+			       DRIVER_DESC "\n");
 	return retval;
 }
 
 
 static void __exit mct_u232_exit(void)
 {
-	usb_deregister(&amp;mct_u232_driver);
-	usb_serial_deregister(&amp;mct_u232_device);
+	usb_serial_deregister_drivers(&amp;mct_u232_driver, serial_drivers);
 }
 
 module_init(mct_u232_init);
diff --git a/drivers/usb/serial/mos7720.c b/drivers/usb/serial/mos7720.c
index 4fb29b4aaad6..4dfbad80418c 100644
--- a/drivers/usb/serial/mos7720.c
+++ b/drivers/usb/serial/mos7720.c
@@ -2169,7 +2169,6 @@ static struct usb_driver usb_driver = {
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	moschip_port_id_table,
-	.no_dynamic_id =	1,
 };
 
 static struct usb_serial_driver moschip7720_2port_driver = {
@@ -2178,7 +2177,6 @@ static struct usb_serial_driver moschip7720_2port_driver = {
 		.name =		"moschip7720",
 	},
 	.description		= "Moschip 2 port adapter",
-	.usb_driver		= &amp;usb_driver,
 	.id_table		= moschip_port_id_table,
 	.calc_num_ports		= mos77xx_calc_num_ports,
 	.open			= mos7720_open,
@@ -2201,38 +2199,26 @@ static struct usb_serial_driver moschip7720_2port_driver = {
 	.read_int_callback	= NULL  /* dynamically assigned in probe() */
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;moschip7720_2port_driver, NULL
+};
+
 static int __init moschip7720_init(void)
 {
 	int retval;
 
 	dbg("%s: Entering ..........", __func__);
 
-	/* Register with the usb serial */
-	retval = usb_serial_register(&amp;moschip7720_2port_driver);
-	if (retval)
-		goto failed_port_device_register;
-
-	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
-	       DRIVER_DESC "\n");
-
-	/* Register with the usb */
-	retval = usb_register(&amp;usb_driver);
-	if (retval)
-		goto failed_usb_register;
-
-	return 0;
-
-failed_usb_register:
-	usb_serial_deregister(&amp;moschip7720_2port_driver);
-
-failed_port_device_register:
+	retval = usb_serial_register_drivers(&amp;usb_driver, serial_drivers);
+	if (retval == 0)
+		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+			       DRIVER_DESC "\n");
 	return retval;
 }
 
 static void __exit moschip7720_exit(void)
 {
-	usb_deregister(&amp;usb_driver);
-	usb_serial_deregister(&amp;moschip7720_2port_driver);
+	usb_serial_deregister_drivers(&amp;usb_driver, serial_drivers);
 }
 
 module_init(moschip7720_init);
diff --git a/drivers/usb/serial/mos7840.c b/drivers/usb/serial/mos7840.c
index 19b11cece6ba..b45522e12f68 100644
--- a/drivers/usb/serial/mos7840.c
+++ b/drivers/usb/serial/mos7840.c
@@ -2638,7 +2638,6 @@ static struct usb_driver io_driver = {
 	.probe = usb_serial_probe,
 	.disconnect = usb_serial_disconnect,
 	.id_table = moschip_id_table_combined,
-	.no_dynamic_id = 1,
 };
 
 static struct usb_serial_driver moschip7840_4port_device = {
@@ -2647,7 +2646,6 @@ static struct usb_serial_driver moschip7840_4port_device = {
 		   .name = "mos7840",
 		   },
 	.description = DRIVER_DESC,
-	.usb_driver = &amp;io_driver,
 	.id_table = moschip_port_id_table,
 	.num_ports = 4,
 	.open = mos7840_open,
@@ -2674,6 +2672,10 @@ static struct usb_serial_driver moschip7840_4port_device = {
 	.read_int_callback = mos7840_interrupt_callback,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;moschip7840_4port_device, NULL
+};
+
 /****************************************************************************
  * moschip7840_init
  *	This is called by the module subsystem, or on startup to initialize us
@@ -2684,24 +2686,12 @@ static int __init moschip7840_init(void)
 
 	dbg("%s", " mos7840_init :entering..........");
 
-	/* Register with the usb serial */
-	retval = usb_serial_register(&amp;moschip7840_4port_device);
-
-	if (retval)
-		goto failed_port_device_register;
-
-	dbg("%s", "Entering...");
-	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
-	       DRIVER_DESC "\n");
+	retval = usb_serial_register_drivers(&amp;io_driver, serial_drivers);
+	if (retval == 0)
+		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+			       DRIVER_DESC "\n");
 
-	/* Register with the usb */
-	retval = usb_register(&amp;io_driver);
-	if (retval == 0) {
-		dbg("%s", "Leaving...");
-		return 0;
-	}
-	usb_serial_deregister(&amp;moschip7840_4port_device);
-failed_port_device_register:
+	dbg("%s", "Leaving...");
 	return retval;
 }
 
@@ -2714,9 +2704,7 @@ static void __exit moschip7840_exit(void)
 
 	dbg("%s", " mos7840_exit :entering..........");
 
-	usb_deregister(&amp;io_driver);
-
-	usb_serial_deregister(&amp;moschip7840_4port_device);
+	usb_serial_deregister_drivers(&amp;io_driver, serial_drivers);
 
 	dbg("%s", "Entering...");
 }
diff --git a/drivers/usb/serial/moto_modem.c b/drivers/usb/serial/moto_modem.c
index e2bfecc46402..0af57d31ab82 100644
--- a/drivers/usb/serial/moto_modem.c
+++ b/drivers/usb/serial/moto_modem.c
@@ -36,7 +36,6 @@ static struct usb_driver moto_driver = {
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	id_table,
-	.no_dynamic_id = 	1,
 };
 
 static struct usb_serial_driver moto_device = {
@@ -45,27 +44,21 @@ static struct usb_serial_driver moto_device = {
 		.name =		"moto-modem",
 	},
 	.id_table =		id_table,
-	.usb_driver =		&amp;moto_driver,
 	.num_ports =		1,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;moto_device, NULL
+};
+
 static int __init moto_init(void)
 {
-	int retval;
-
-	retval = usb_serial_register(&amp;moto_device);
-	if (retval)
-		return retval;
-	retval = usb_register(&amp;moto_driver);
-	if (retval)
-		usb_serial_deregister(&amp;moto_device);
-	return retval;
+	return usb_serial_register_drivers(&amp;moto_driver, serial_drivers);
 }
 
 static void __exit moto_exit(void)
 {
-	usb_deregister(&amp;moto_driver);
-	usb_serial_deregister(&amp;moto_device);
+	usb_serial_deregister_drivers(&amp;moto_driver, serial_drivers);
 }
 
 module_init(moto_init);</pre><hr><pre>commit 7dbe2460989b10644651e779b17b683627feea48
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Feb 23 14:56:57 2012 -0500

    usb-serial: use new registration API in [i-j]* drivers
    
    This patch (as1525) modifies the following usb-serial drivers to
    utilize the new usb_serial_{de}register_drivers() routines:
    
            io_edgeport, io_ti, ipaq, ipw, ir-usb, and iuu_phoenix.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/serial/io_edgeport.c b/drivers/usb/serial/io_edgeport.c
index 616b07862771..55afa233aacd 100644
--- a/drivers/usb/serial/io_edgeport.c
+++ b/drivers/usb/serial/io_edgeport.c
@@ -3189,35 +3189,12 @@ static int __init edgeport_init(void)
 {
 	int retval;
 
-	retval = usb_serial_register(&amp;edgeport_2port_device);
-	if (retval)
-		goto failed_2port_device_register;
-	retval = usb_serial_register(&amp;edgeport_4port_device);
-	if (retval)
-		goto failed_4port_device_register;
-	retval = usb_serial_register(&amp;edgeport_8port_device);
-	if (retval)
-		goto failed_8port_device_register;
-	retval = usb_serial_register(&amp;epic_device);
-	if (retval)
-		goto failed_epic_device_register;
-	retval = usb_register(&amp;io_driver);
-	if (retval)
-		goto failed_usb_register;
-	atomic_set(&amp;CmdUrbs, 0);
-	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
-	       DRIVER_DESC "\n");
-	return 0;
-
-failed_usb_register:
-	usb_serial_deregister(&amp;epic_device);
-failed_epic_device_register:
-	usb_serial_deregister(&amp;edgeport_8port_device);
-failed_8port_device_register:
-	usb_serial_deregister(&amp;edgeport_4port_device);
-failed_4port_device_register:
-	usb_serial_deregister(&amp;edgeport_2port_device);
-failed_2port_device_register:
+	retval = usb_serial_register_drivers(&amp;io_driver, serial_drivers);
+	if (retval == 0) {
+		atomic_set(&amp;CmdUrbs, 0);
+		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+			       DRIVER_DESC "\n");
+	}
 	return retval;
 }
 
@@ -3228,11 +3205,7 @@ static int __init edgeport_init(void)
  ****************************************************************************/
 static void __exit edgeport_exit (void)
 {
-	usb_deregister(&amp;io_driver);
-	usb_serial_deregister(&amp;edgeport_2port_device);
-	usb_serial_deregister(&amp;edgeport_4port_device);
-	usb_serial_deregister(&amp;edgeport_8port_device);
-	usb_serial_deregister(&amp;epic_device);
+	usb_serial_deregister_drivers(&amp;io_driver, serial_drivers);
 }
 
 module_init(edgeport_init);
diff --git a/drivers/usb/serial/io_tables.h b/drivers/usb/serial/io_tables.h
index 178b22eb32b1..d0e7c9affb6f 100644
--- a/drivers/usb/serial/io_tables.h
+++ b/drivers/usb/serial/io_tables.h
@@ -100,7 +100,6 @@ static struct usb_driver io_driver = {
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	id_table_combined,
-	.no_dynamic_id = 	1,
 };
 
 static struct usb_serial_driver edgeport_2port_device = {
@@ -109,7 +108,6 @@ static struct usb_serial_driver edgeport_2port_device = {
 		.name		= "edgeport_2",
 	},
 	.description		= "Edgeport 2 port adapter",
-	.usb_driver		= &amp;io_driver,
 	.id_table		= edgeport_2port_id_table,
 	.num_ports		= 2,
 	.open			= edge_open,
@@ -139,7 +137,6 @@ static struct usb_serial_driver edgeport_4port_device = {
 		.name		= "edgeport_4",
 	},
 	.description		= "Edgeport 4 port adapter",
-	.usb_driver		= &amp;io_driver,
 	.id_table		= edgeport_4port_id_table,
 	.num_ports		= 4,
 	.open			= edge_open,
@@ -169,7 +166,6 @@ static struct usb_serial_driver edgeport_8port_device = {
 		.name		= "edgeport_8",
 	},
 	.description		= "Edgeport 8 port adapter",
-	.usb_driver		= &amp;io_driver,
 	.id_table		= edgeport_8port_id_table,
 	.num_ports		= 8,
 	.open			= edge_open,
@@ -199,7 +195,6 @@ static struct usb_serial_driver epic_device = {
 		.name		= "epic",
 	},
 	.description		= "EPiC device",
-	.usb_driver		= &amp;io_driver,
 	.id_table		= Epic_port_id_table,
 	.num_ports		= 1,
 	.open			= edge_open,
@@ -223,5 +218,10 @@ static struct usb_serial_driver epic_device = {
 	.write_bulk_callback	= edge_bulk_out_data_callback,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;edgeport_2port_device, &amp;edgeport_4port_device,
+	&amp;edgeport_8port_device, &amp;epic_device, NULL
+};
+
 #endif
 
diff --git a/drivers/usb/serial/io_ti.c b/drivers/usb/serial/io_ti.c
index 58a3697246a8..484db3331f88 100644
--- a/drivers/usb/serial/io_ti.c
+++ b/drivers/usb/serial/io_ti.c
@@ -202,7 +202,6 @@ static struct usb_driver io_driver = {
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	id_table_combined,
-	.no_dynamic_id = 	1,
 };
 
 
@@ -2725,7 +2724,6 @@ static struct usb_serial_driver edgeport_1port_device = {
 		.name		= "edgeport_ti_1",
 	},
 	.description		= "Edgeport TI 1 port adapter",
-	.usb_driver		= &amp;io_driver,
 	.id_table		= edgeport_1port_id_table,
 	.num_ports		= 1,
 	.open			= edge_open,
@@ -2757,7 +2755,6 @@ static struct usb_serial_driver edgeport_2port_device = {
 		.name		= "edgeport_ti_2",
 	},
 	.description		= "Edgeport TI 2 port adapter",
-	.usb_driver		= &amp;io_driver,
 	.id_table		= edgeport_2port_id_table,
 	.num_ports		= 2,
 	.open			= edge_open,
@@ -2782,35 +2779,25 @@ static struct usb_serial_driver edgeport_2port_device = {
 	.write_bulk_callback	= edge_bulk_out_callback,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;edgeport_1port_device, &amp;edgeport_2port_device, NULL
+};
+
 
 static int __init edgeport_init(void)
 {
 	int retval;
-	retval = usb_serial_register(&amp;edgeport_1port_device);
-	if (retval)
-		goto failed_1port_device_register;
-	retval = usb_serial_register(&amp;edgeport_2port_device);
-	if (retval)
-		goto failed_2port_device_register;
-	retval = usb_register(&amp;io_driver);
-	if (retval)
-		goto failed_usb_register;
-	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
-	       DRIVER_DESC "\n");
-	return 0;
-failed_usb_register:
-	usb_serial_deregister(&amp;edgeport_2port_device);
-failed_2port_device_register:
-	usb_serial_deregister(&amp;edgeport_1port_device);
-failed_1port_device_register:
+
+	retval = usb_serial_register_drivers(&amp;io_driver, serial_drivers);
+	if (retval == 0)
+		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+			       DRIVER_DESC "\n");
 	return retval;
 }
 
 static void __exit edgeport_exit(void)
 {
-	usb_deregister(&amp;io_driver);
-	usb_serial_deregister(&amp;edgeport_1port_device);
-	usb_serial_deregister(&amp;edgeport_2port_device);
+	usb_serial_deregister_drivers(&amp;io_driver, serial_drivers);
 }
 
 module_init(edgeport_init);
diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 06053a920dd8..10c02b8b5664 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -510,7 +510,6 @@ static struct usb_driver ipaq_driver = {
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	ipaq_id_table,
-	.no_dynamic_id =	1,
 };
 
 
@@ -521,7 +520,6 @@ static struct usb_serial_driver ipaq_device = {
 		.name =		"ipaq",
 	},
 	.description =		"PocketPC PDA",
-	.usb_driver =		&amp;ipaq_driver,
 	.id_table =		ipaq_id_table,
 	.bulk_in_size =		256,
 	.bulk_out_size =	256,
@@ -530,6 +528,10 @@ static struct usb_serial_driver ipaq_device = {
 	.calc_num_ports =	ipaq_calc_num_ports,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;ipaq_device, NULL
+};
+
 static int ipaq_open(struct tty_struct *tty,
 			struct usb_serial_port *port)
 {
@@ -624,30 +626,22 @@ static int ipaq_startup(struct usb_serial *serial)
 static int __init ipaq_init(void)
 {
 	int retval;
-	retval = usb_serial_register(&amp;ipaq_device);
-	if (retval)
-		goto failed_usb_serial_register;
+
 	if (vendor) {
 		ipaq_id_table[0].idVendor = vendor;
 		ipaq_id_table[0].idProduct = product;
 	}
-	retval = usb_register(&amp;ipaq_driver);
-	if (retval)
-		goto failed_usb_register;
-
-	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
-	       DRIVER_DESC "\n");
-	return 0;
-failed_usb_register:
-	usb_serial_deregister(&amp;ipaq_device);
-failed_usb_serial_register:
+
+	retval = usb_serial_register_drivers(&amp;ipaq_driver, serial_drivers);
+	if (retval == 0)
+		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+			       DRIVER_DESC "\n");
 	return retval;
 }
 
 static void __exit ipaq_exit(void)
 {
-	usb_deregister(&amp;ipaq_driver);
-	usb_serial_deregister(&amp;ipaq_device);
+	usb_serial_deregister_drivers(&amp;ipaq_driver, serial_drivers);
 }
 
 
diff --git a/drivers/usb/serial/ipw.c b/drivers/usb/serial/ipw.c
index 6f9356f3f99e..27b8886f1055 100644
--- a/drivers/usb/serial/ipw.c
+++ b/drivers/usb/serial/ipw.c
@@ -144,7 +144,6 @@ static struct usb_driver usb_ipw_driver = {
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	usb_ipw_ids,
-	.no_dynamic_id = 	1,
 };
 
 static bool debug;
@@ -318,7 +317,6 @@ static struct usb_serial_driver ipw_device = {
 		.name =		"ipw",
 	},
 	.description =		"IPWireless converter",
-	.usb_driver =		&amp;usb_ipw_driver,
 	.id_table =		usb_ipw_ids,
 	.num_ports =		1,
 	.disconnect =		usb_wwan_disconnect,
@@ -331,29 +329,25 @@ static struct usb_serial_driver ipw_device = {
 	.write =		usb_wwan_write,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;ipw_device, NULL
+};
 
 
 static int __init usb_ipw_init(void)
 {
 	int retval;
 
-	retval = usb_serial_register(&amp;ipw_device);
-	if (retval)
-		return retval;
-	retval = usb_register(&amp;usb_ipw_driver);
-	if (retval) {
-		usb_serial_deregister(&amp;ipw_device);
-		return retval;
-	}
-	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
-	       DRIVER_DESC "\n");
-	return 0;
+	retval = usb_serial_register_drivers(&amp;usb_ipw_driver, serial_drivers);
+	if (retval == 0)
+		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+			       DRIVER_DESC "\n");
+	return retval;
 }
 
 static void __exit usb_ipw_exit(void)
 {
-	usb_deregister(&amp;usb_ipw_driver);
-	usb_serial_deregister(&amp;ipw_device);
+	usb_serial_deregister_drivers(&amp;usb_ipw_driver, serial_drivers);
 }
 
 module_init(usb_ipw_init);
diff --git a/drivers/usb/serial/ir-usb.c b/drivers/usb/serial/ir-usb.c
index 84a396e83671..84965cd65c76 100644
--- a/drivers/usb/serial/ir-usb.c
+++ b/drivers/usb/serial/ir-usb.c
@@ -82,7 +82,6 @@ static struct usb_driver ir_driver = {
 	.probe		= usb_serial_probe,
 	.disconnect	= usb_serial_disconnect,
 	.id_table	= ir_id_table,
-	.no_dynamic_id	= 1,
 };
 
 static struct usb_serial_driver ir_device = {
@@ -91,7 +90,6 @@ static struct usb_serial_driver ir_device = {
 		.name	= "ir-usb",
 	},
 	.description		= "IR Dongle",
-	.usb_driver		= &amp;ir_driver,
 	.id_table		= ir_id_table,
 	.num_ports		= 1,
 	.set_termios		= ir_set_termios,
@@ -101,6 +99,10 @@ static struct usb_serial_driver ir_device = {
 	.process_read_urb	= ir_process_read_urb,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;ir_device, NULL
+};
+
 static inline void irda_usb_dump_class_desc(struct usb_irda_cs_descriptor *desc)
 {
 	dbg("bLength=%x", desc-&gt;bLength);
@@ -445,30 +447,16 @@ static int __init ir_init(void)
 		ir_device.bulk_out_size = buffer_size;
 	}
 
-	retval = usb_serial_register(&amp;ir_device);
-	if (retval)
-		goto failed_usb_serial_register;
-
-	retval = usb_register(&amp;ir_driver);
-	if (retval)
-		goto failed_usb_register;
-
-	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
-	       DRIVER_DESC "\n");
-
-	return 0;
-
-failed_usb_register:
-	usb_serial_deregister(&amp;ir_device);
-
-failed_usb_serial_register:
+	retval = usb_serial_register_drivers(&amp;ir_driver, serial_drivers);
+	if (retval == 0)
+		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+			       DRIVER_DESC "\n");
 	return retval;
 }
 
 static void __exit ir_exit(void)
 {
-	usb_deregister(&amp;ir_driver);
-	usb_serial_deregister(&amp;ir_device);
+	usb_serial_deregister_drivers(&amp;ir_driver, serial_drivers);
 }
 
 
diff --git a/drivers/usb/serial/iuu_phoenix.c b/drivers/usb/serial/iuu_phoenix.c
index 3077a4436976..97a7ea2a5e4f 100644
--- a/drivers/usb/serial/iuu_phoenix.c
+++ b/drivers/usb/serial/iuu_phoenix.c
@@ -56,7 +56,6 @@ static struct usb_driver iuu_driver = {
 	.probe = usb_serial_probe,
 	.disconnect = usb_serial_disconnect,
 	.id_table = id_table,
-	.no_dynamic_id = 1,
 };
 
 /* turbo parameter */
@@ -1274,7 +1273,6 @@ static struct usb_serial_driver iuu_device = {
 		   .name = "iuu_phoenix",
 		   },
 	.id_table = id_table,
-	.usb_driver = &amp;iuu_driver,
 	.num_ports = 1,
 	.bulk_in_size = 512,
 	.bulk_out_size = 512,
@@ -1292,28 +1290,24 @@ static struct usb_serial_driver iuu_device = {
 	.release = iuu_release,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;iuu_device, NULL
+};
+
 static int __init iuu_init(void)
 {
 	int retval;
-	retval = usb_serial_register(&amp;iuu_device);
-	if (retval)
-		goto failed_usb_serial_register;
-	retval = usb_register(&amp;iuu_driver);
-	if (retval)
-		goto failed_usb_register;
-	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
-	       DRIVER_DESC "\n");
-	return 0;
-failed_usb_register:
-	usb_serial_deregister(&amp;iuu_device);
-failed_usb_serial_register:
+
+	retval = usb_serial_register_drivers(&amp;iuu_driver, serial_drivers);
+	if (retval == 0)
+		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+			       DRIVER_DESC "\n");
 	return retval;
 }
 
 static void __exit iuu_exit(void)
 {
-	usb_deregister(&amp;iuu_driver);
-	usb_serial_deregister(&amp;iuu_device);
+	usb_serial_deregister_drivers(&amp;iuu_driver, serial_drivers);
 }
 
 module_init(iuu_init);</pre><hr><pre>commit 97b6b6d2339f67eb17d954930a908b762af66228
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Feb 23 14:56:32 2012 -0500

    usb-serial: use new registration API in [d-h]* drivers
    
    This patch (as1524) modifies the following usb-serial drivers to
    utilize the new usb_serial_{de}register_drivers() routines:
    
            digi_acceleport, empeg, ftdi_sio, funsoft, garmin_gps,
            and hp4x.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/serial/digi_acceleport.c b/drivers/usb/serial/digi_acceleport.c
index 2b1da0cc071a..f0e776bb1ffb 100644
--- a/drivers/usb/serial/digi_acceleport.c
+++ b/drivers/usb/serial/digi_acceleport.c
@@ -276,7 +276,6 @@ static struct usb_driver digi_driver = {
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	id_table_combined,
-	.no_dynamic_id = 	1,
 };
 
 
@@ -288,7 +287,6 @@ static struct usb_serial_driver digi_acceleport_2_device = {
 		.name =			"digi_2",
 	},
 	.description =			"Digi 2 port USB adapter",
-	.usb_driver = 			&amp;digi_driver,
 	.id_table =			id_table_2,
 	.num_ports =			3,
 	.open =				digi_open,
@@ -316,7 +314,6 @@ static struct usb_serial_driver digi_acceleport_4_device = {
 		.name =			"digi_4",
 	},
 	.description =			"Digi 4 port USB adapter",
-	.usb_driver = 			&amp;digi_driver,
 	.id_table =			id_table_4,
 	.num_ports =			4,
 	.open =				digi_open,
@@ -337,6 +334,9 @@ static struct usb_serial_driver digi_acceleport_4_device = {
 	.release =			digi_release,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;digi_acceleport_2_device, &amp;digi_acceleport_4_device, NULL
+};
 
 /* Functions */
 
@@ -1583,31 +1583,17 @@ static int digi_read_oob_callback(struct urb *urb)
 static int __init digi_init(void)
 {
 	int retval;
-	retval = usb_serial_register(&amp;digi_acceleport_2_device);
-	if (retval)
-		goto failed_acceleport_2_device;
-	retval = usb_serial_register(&amp;digi_acceleport_4_device);
-	if (retval)
-		goto failed_acceleport_4_device;
-	retval = usb_register(&amp;digi_driver);
-	if (retval)
-		goto failed_usb_register;
-	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
-	       DRIVER_DESC "\n");
-	return 0;
-failed_usb_register:
-	usb_serial_deregister(&amp;digi_acceleport_4_device);
-failed_acceleport_4_device:
-	usb_serial_deregister(&amp;digi_acceleport_2_device);
-failed_acceleport_2_device:
+
+	retval = usb_serial_register_drivers(&amp;digi_driver, serial_drivers);
+	if (retval == 0)
+		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+			       DRIVER_DESC "\n");
 	return retval;
 }
 
 static void __exit digi_exit (void)
 {
-	usb_deregister(&amp;digi_driver);
-	usb_serial_deregister(&amp;digi_acceleport_2_device);
-	usb_serial_deregister(&amp;digi_acceleport_4_device);
+	usb_serial_deregister_drivers(&amp;digi_driver, serial_drivers);
 }
 
 
diff --git a/drivers/usb/serial/empeg.c b/drivers/usb/serial/empeg.c
index aced6817bf95..51bcbd5d5e8e 100644
--- a/drivers/usb/serial/empeg.c
+++ b/drivers/usb/serial/empeg.c
@@ -56,7 +56,6 @@ static struct usb_driver empeg_driver = {
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	id_table,
-	.no_dynamic_id =	1,
 };
 
 static struct usb_serial_driver empeg_device = {
@@ -65,7 +64,6 @@ static struct usb_serial_driver empeg_device = {
 		.name =		"empeg",
 	},
 	.id_table =		id_table,
-	.usb_driver =		&amp;empeg_driver,
 	.num_ports =		1,
 	.bulk_out_size =	256,
 	.throttle =		usb_serial_generic_throttle,
@@ -74,6 +72,10 @@ static struct usb_serial_driver empeg_device = {
 	.init_termios =		empeg_init_termios,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;empeg_device, NULL
+};
+
 static int empeg_startup(struct usb_serial *serial)
 {
 	int r;
@@ -140,24 +142,16 @@ static int __init empeg_init(void)
 {
 	int retval;
 
-	retval = usb_serial_register(&amp;empeg_device);
-	if (retval)
-		return retval;
-	retval = usb_register(&amp;empeg_driver);
-	if (retval) {
-		usb_serial_deregister(&amp;empeg_device);
-		return retval;
-	}
-	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
-	       DRIVER_DESC "\n");
-
-	return 0;
+	retval = usb_serial_register_drivers(&amp;empeg_driver, serial_drivers);
+	if (retval == 0)
+		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+			       DRIVER_DESC "\n");
+	return retval;
 }
 
 static void __exit empeg_exit(void)
 {
-	usb_deregister(&amp;empeg_driver);
-	usb_serial_deregister(&amp;empeg_device);
+	usb_serial_deregister_drivers(&amp;empeg_driver, serial_drivers);
 }
 
 
diff --git a/drivers/usb/serial/ftdi_sio.c b/drivers/usb/serial/ftdi_sio.c
index f770415305f8..615cf2c4915c 100644
--- a/drivers/usb/serial/ftdi_sio.c
+++ b/drivers/usb/serial/ftdi_sio.c
@@ -857,7 +857,6 @@ static struct usb_driver ftdi_driver = {
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	id_table_combined,
-	.no_dynamic_id =	1,
 };
 
 static const char *ftdi_chip_name[] = {
@@ -915,7 +914,6 @@ static struct usb_serial_driver ftdi_sio_device = {
 		.name =		"ftdi_sio",
 	},
 	.description =		"FTDI USB Serial Device",
-	.usb_driver = 		&amp;ftdi_driver,
 	.id_table =		id_table_combined,
 	.num_ports =		1,
 	.bulk_in_size =		512,
@@ -938,6 +936,10 @@ static struct usb_serial_driver ftdi_sio_device = {
 	.break_ctl =		ftdi_break_ctl,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;ftdi_sio_device, NULL
+};
+
 
 #define WDR_TIMEOUT 5000 /* default urb timeout */
 #define WDR_SHORT_TIMEOUT 1000	/* shorter urb timeout */
@@ -2420,19 +2422,10 @@ static int __init ftdi_init(void)
 		id_table_combined[i].idVendor = vendor;
 		id_table_combined[i].idProduct = product;
 	}
-	retval = usb_serial_register(&amp;ftdi_sio_device);
-	if (retval)
-		goto failed_sio_register;
-	retval = usb_register(&amp;ftdi_driver);
-	if (retval)
-		goto failed_usb_register;
-
-	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
-	       DRIVER_DESC "\n");
-	return 0;
-failed_usb_register:
-	usb_serial_deregister(&amp;ftdi_sio_device);
-failed_sio_register:
+	retval = usb_serial_register_drivers(&amp;ftdi_driver, serial_drivers);
+	if (retval == 0)
+		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+			       DRIVER_DESC "\n");
 	return retval;
 }
 
@@ -2440,8 +2433,7 @@ static void __exit ftdi_exit(void)
 {
 	dbg("%s", __func__);
 
-	usb_deregister(&amp;ftdi_driver);
-	usb_serial_deregister(&amp;ftdi_sio_device);
+	usb_serial_deregister_drivers(&amp;ftdi_driver, serial_drivers);
 }
 
 
diff --git a/drivers/usb/serial/funsoft.c b/drivers/usb/serial/funsoft.c
index 5d4b099dcf8b..bb274a244ae9 100644
--- a/drivers/usb/serial/funsoft.c
+++ b/drivers/usb/serial/funsoft.c
@@ -29,7 +29,6 @@ static struct usb_driver funsoft_driver = {
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	id_table,
-	.no_dynamic_id = 	1,
 };
 
 static struct usb_serial_driver funsoft_device = {
@@ -38,27 +37,21 @@ static struct usb_serial_driver funsoft_device = {
 		.name =		"funsoft",
 	},
 	.id_table =		id_table,
-	.usb_driver = 		&amp;funsoft_driver,
 	.num_ports =		1,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;funsoft_device, NULL
+};
+
 static int __init funsoft_init(void)
 {
-	int retval;
-
-	retval = usb_serial_register(&amp;funsoft_device);
-	if (retval)
-		return retval;
-	retval = usb_register(&amp;funsoft_driver);
-	if (retval)
-		usb_serial_deregister(&amp;funsoft_device);
-	return retval;
+	return usb_serial_register_drivers(&amp;funsoft_driver, serial_drivers);
 }
 
 static void __exit funsoft_exit(void)
 {
-	usb_deregister(&amp;funsoft_driver);
-	usb_serial_deregister(&amp;funsoft_device);
+	usb_serial_deregister_drivers(&amp;funsoft_driver, serial_drivers);
 }
 
 module_init(funsoft_init);
diff --git a/drivers/usb/serial/garmin_gps.c b/drivers/usb/serial/garmin_gps.c
index 21343378c322..69da3abcb363 100644
--- a/drivers/usb/serial/garmin_gps.c
+++ b/drivers/usb/serial/garmin_gps.c
@@ -224,7 +224,6 @@ static struct usb_driver garmin_driver = {
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	id_table,
-	.no_dynamic_id = 1,
 };
 
 
@@ -1497,7 +1496,6 @@ static struct usb_serial_driver garmin_device = {
 		.name        = "garmin_gps",
 	},
 	.description         = "Garmin GPS usb/tty",
-	.usb_driver          = &amp;garmin_driver,
 	.id_table            = id_table,
 	.num_ports           = 1,
 	.open                = garmin_open,
@@ -1514,33 +1512,26 @@ static struct usb_serial_driver garmin_device = {
 	.read_int_callback   = garmin_read_int_callback,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;garmin_device, NULL
+};
 
 
 static int __init garmin_init(void)
 {
 	int retval;
 
-	retval = usb_serial_register(&amp;garmin_device);
-	if (retval)
-		goto failed_garmin_register;
-	retval = usb_register(&amp;garmin_driver);
-	if (retval)
-		goto failed_usb_register;
-	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
-	       DRIVER_DESC "\n");
-
-	return 0;
-failed_usb_register:
-	usb_serial_deregister(&amp;garmin_device);
-failed_garmin_register:
+	retval = usb_serial_register_drivers(&amp;garmin_driver, serial_drivers);
+	if (retval == 0)
+		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+			       DRIVER_DESC "\n");
 	return retval;
 }
 
 
 static void __exit garmin_exit(void)
 {
-	usb_deregister(&amp;garmin_driver);
-	usb_serial_deregister(&amp;garmin_device);
+	usb_serial_deregister_drivers(&amp;garmin_driver, serial_drivers);
 }
 
 
diff --git a/drivers/usb/serial/hp4x.c b/drivers/usb/serial/hp4x.c
index 809379159b0e..325cf092b61c 100644
--- a/drivers/usb/serial/hp4x.c
+++ b/drivers/usb/serial/hp4x.c
@@ -41,7 +41,6 @@ static struct usb_driver hp49gp_driver = {
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	id_table,
-	.no_dynamic_id = 	1,
 };
 
 static struct usb_serial_driver hp49gp_device = {
@@ -50,32 +49,27 @@ static struct usb_serial_driver hp49gp_device = {
 		.name =		"hp4X",
 	},
 	.id_table =		id_table,
-	.usb_driver = 		&amp;hp49gp_driver,
 	.num_ports =		1,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;hp49gp_device, NULL
+};
+
 static int __init hp49gp_init(void)
 {
 	int retval;
-	retval = usb_serial_register(&amp;hp49gp_device);
-	if (retval)
-		goto failed_usb_serial_register;
-	retval = usb_register(&amp;hp49gp_driver);
-	if (retval)
-		goto failed_usb_register;
-	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
-	       DRIVER_DESC "\n");
-	return 0;
-failed_usb_register:
-	usb_serial_deregister(&amp;hp49gp_device);
-failed_usb_serial_register:
+
+	retval = usb_serial_register_drivers(&amp;hp49gp_driver, serial_drivers);
+	if (retval == 0)
+		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+			       DRIVER_DESC "\n");
 	return retval;
 }
 
 static void __exit hp49gp_exit(void)
 {
-	usb_deregister(&amp;hp49gp_driver);
-	usb_serial_deregister(&amp;hp49gp_device);
+	usb_serial_deregister_drivers(&amp;hp49gp_driver, serial_drivers);
 }
 
 module_init(hp49gp_init);</pre><hr><pre>commit 08a4f6bc2e7046ce50849d7589b7d0763926d808
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Feb 23 14:56:17 2012 -0500

    usb-serial: use new registration API in [a-c]* drivers
    
    This patch (as1523) modifies the following usb-serial drivers to
    utilize the new usb_serial_{de}register_drivers() routines:
    
            aircable, ark3116, belkin_sa, ch341, cp210x, cyberjack,
            and cypress_m8.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/serial/aircable.c b/drivers/usb/serial/aircable.c
index 123bf9155339..dbf3bddc1b51 100644
--- a/drivers/usb/serial/aircable.c
+++ b/drivers/usb/serial/aircable.c
@@ -175,7 +175,6 @@ static struct usb_driver aircable_driver = {
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	id_table,
-	.no_dynamic_id =	1,
 };
 
 static struct usb_serial_driver aircable_device = {
@@ -183,7 +182,6 @@ static struct usb_serial_driver aircable_device = {
 		.owner =	THIS_MODULE,
 		.name =		"aircable",
 	},
-	.usb_driver = 		&amp;aircable_driver,
 	.id_table = 		id_table,
 	.num_ports =		1,
 	.bulk_out_size =	HCI_COMPLETE_FRAME,
@@ -194,27 +192,18 @@ static struct usb_serial_driver aircable_device = {
 	.unthrottle =		usb_serial_generic_unthrottle,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;aircable_device, NULL
+};
+
 static int __init aircable_init(void)
 {
-	int retval;
-	retval = usb_serial_register(&amp;aircable_device);
-	if (retval)
-		goto failed_serial_register;
-	retval = usb_register(&amp;aircable_driver);
-	if (retval)
-		goto failed_usb_register;
-	return 0;
-
-failed_usb_register:
-	usb_serial_deregister(&amp;aircable_device);
-failed_serial_register:
-	return retval;
+	return usb_serial_register_drivers(&amp;aircable_driver, serial_drivers);
 }
 
 static void __exit aircable_exit(void)
 {
-	usb_deregister(&amp;aircable_driver);
-	usb_serial_deregister(&amp;aircable_device);
+	usb_serial_deregister_drivers(&amp;aircable_driver, serial_drivers);
 }
 
 MODULE_AUTHOR(DRIVER_AUTHOR);
diff --git a/drivers/usb/serial/ark3116.c b/drivers/usb/serial/ark3116.c
index 69328dcfd91a..ab2cf1165c60 100644
--- a/drivers/usb/serial/ark3116.c
+++ b/drivers/usb/serial/ark3116.c
@@ -719,7 +719,6 @@ static struct usb_driver ark3116_driver = {
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	id_table,
-	.no_dynamic_id =	1,
 };
 
 static struct usb_serial_driver ark3116_device = {
@@ -728,7 +727,6 @@ static struct usb_serial_driver ark3116_device = {
 		.name =		"ark3116",
 	},
 	.id_table =		id_table,
-	.usb_driver =		&amp;ark3116_driver,
 	.num_ports =		1,
 	.attach =		ark3116_attach,
 	.release =		ark3116_release,
@@ -745,28 +743,27 @@ static struct usb_serial_driver ark3116_device = {
 	.process_read_urb =	ark3116_process_read_urb,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;ark3116_device, NULL
+};
+
 static int __init ark3116_init(void)
 {
 	int retval;
 
-	retval = usb_serial_register(&amp;ark3116_device);
-	if (retval)
-		return retval;
-	retval = usb_register(&amp;ark3116_driver);
+	retval = usb_serial_register_drivers(&amp;ark3116_driver, serial_drivers);
 	if (retval == 0) {
 		printk(KERN_INFO "%s:"
 		       DRIVER_VERSION ":"
 		       DRIVER_DESC "\n",
 		       KBUILD_MODNAME);
-	} else
-		usb_serial_deregister(&amp;ark3116_device);
+	}
 	return retval;
 }
 
 static void __exit ark3116_exit(void)
 {
-	usb_deregister(&amp;ark3116_driver);
-	usb_serial_deregister(&amp;ark3116_device);
+	usb_serial_deregister_drivers(&amp;ark3116_driver, serial_drivers);
 }
 
 module_init(ark3116_init);
diff --git a/drivers/usb/serial/belkin_sa.c b/drivers/usb/serial/belkin_sa.c
index 29ffeb6279c7..e8b473f5acf7 100644
--- a/drivers/usb/serial/belkin_sa.c
+++ b/drivers/usb/serial/belkin_sa.c
@@ -78,7 +78,6 @@ static struct usb_driver belkin_driver = {
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	id_table_combined,
-	.no_dynamic_id =	1,
 };
 
 /* All of the device info needed for the serial converters */
@@ -88,7 +87,6 @@ static struct usb_serial_driver belkin_device = {
 		.name =		"belkin",
 	},
 	.description =		"Belkin / Peracom / GoHubs USB Serial Adapter",
-	.usb_driver =		&amp;belkin_driver,
 	.id_table =		id_table_combined,
 	.num_ports =		1,
 	.open =			belkin_sa_open,
@@ -103,6 +101,10 @@ static struct usb_serial_driver belkin_device = {
 	.release =		belkin_sa_release,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;belkin_device, NULL
+};
+
 struct belkin_sa_private {
 	spinlock_t		lock;
 	unsigned long		control_state;
@@ -526,25 +528,17 @@ static int belkin_sa_tiocmset(struct tty_struct *tty,
 static int __init belkin_sa_init(void)
 {
 	int retval;
-	retval = usb_serial_register(&amp;belkin_device);
-	if (retval)
-		goto failed_usb_serial_register;
-	retval = usb_register(&amp;belkin_driver);
-	if (retval)
-		goto failed_usb_register;
-	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
-	       DRIVER_DESC "\n");
-	return 0;
-failed_usb_register:
-	usb_serial_deregister(&amp;belkin_device);
-failed_usb_serial_register:
+
+	retval = usb_serial_register_drivers(&amp;belkin_driver, serial_drivers);
+	if (retval == 0)
+		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+			       DRIVER_DESC "\n");
 	return retval;
 }
 
 static void __exit belkin_sa_exit (void)
 {
-	usb_deregister(&amp;belkin_driver);
-	usb_serial_deregister(&amp;belkin_device);
+	usb_serial_deregister_drivers(&amp;belkin_driver, serial_drivers);
 }
 
 
diff --git a/drivers/usb/serial/ch341.c b/drivers/usb/serial/ch341.c
index 5e53cc59e652..23de3b039a28 100644
--- a/drivers/usb/serial/ch341.c
+++ b/drivers/usb/serial/ch341.c
@@ -625,7 +625,6 @@ static struct usb_driver ch341_driver = {
 	.resume		= usb_serial_resume,
 	.reset_resume	= ch341_reset_resume,
 	.id_table	= id_table,
-	.no_dynamic_id	= 1,
 	.supports_autosuspend =	1,
 };
 
@@ -635,7 +634,6 @@ static struct usb_serial_driver ch341_device = {
 		.name	= "ch341-uart",
 	},
 	.id_table          = id_table,
-	.usb_driver        = &amp;ch341_driver,
 	.num_ports         = 1,
 	.open              = ch341_open,
 	.dtr_rts	   = ch341_dtr_rts,
@@ -650,23 +648,18 @@ static struct usb_serial_driver ch341_device = {
 	.attach            = ch341_attach,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;ch341_device, NULL
+};
+
 static int __init ch341_init(void)
 {
-	int retval;
-
-	retval = usb_serial_register(&amp;ch341_device);
-	if (retval)
-		return retval;
-	retval = usb_register(&amp;ch341_driver);
-	if (retval)
-		usb_serial_deregister(&amp;ch341_device);
-	return retval;
+	return usb_serial_register_drivers(&amp;ch341_driver, serial_drivers);
 }
 
 static void __exit ch341_exit(void)
 {
-	usb_deregister(&amp;ch341_driver);
-	usb_serial_deregister(&amp;ch341_device);
+	usb_serial_deregister_drivers(&amp;ch341_driver, serial_drivers);
 }
 
 module_init(ch341_init);
diff --git a/drivers/usb/serial/cp210x.c b/drivers/usb/serial/cp210x.c
index ec9dc4e9a3ff..01a9374357f1 100644
--- a/drivers/usb/serial/cp210x.c
+++ b/drivers/usb/serial/cp210x.c
@@ -154,7 +154,6 @@ static struct usb_driver cp210x_driver = {
 	.probe		= usb_serial_probe,
 	.disconnect	= usb_serial_disconnect,
 	.id_table	= id_table,
-	.no_dynamic_id	= 	1,
 };
 
 static struct usb_serial_driver cp210x_device = {
@@ -162,7 +161,6 @@ static struct usb_serial_driver cp210x_device = {
 		.owner =	THIS_MODULE,
 		.name = 	"cp210x",
 	},
-	.usb_driver		= &amp;cp210x_driver,
 	.id_table		= id_table,
 	.num_ports		= 1,
 	.bulk_in_size		= 256,
@@ -177,6 +175,10 @@ static struct usb_serial_driver cp210x_device = {
 	.dtr_rts		= cp210x_dtr_rts
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;cp210x_device, NULL
+};
+
 /* Config request types */
 #define REQTYPE_HOST_TO_DEVICE	0x41
 #define REQTYPE_DEVICE_TO_HOST	0xc1
@@ -852,27 +854,16 @@ static int __init cp210x_init(void)
 {
 	int retval;
 
-	retval = usb_serial_register(&amp;cp210x_device);
-	if (retval)
-		return retval; /* Failed to register */
-
-	retval = usb_register(&amp;cp210x_driver);
-	if (retval) {
-		/* Failed to register */
-		usb_serial_deregister(&amp;cp210x_device);
-		return retval;
-	}
-
-	/* Success */
-	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
-	       DRIVER_DESC "\n");
-	return 0;
+	retval = usb_serial_register_drivers(&amp;cp210x_driver, serial_drivers);
+	if (retval == 0)
+		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+			       DRIVER_DESC "\n");
+	return retval;
 }
 
 static void __exit cp210x_exit(void)
 {
-	usb_deregister(&amp;cp210x_driver);
-	usb_serial_deregister(&amp;cp210x_device);
+	usb_serial_deregister_drivers(&amp;cp210x_driver, serial_drivers);
 }
 
 module_init(cp210x_init);
diff --git a/drivers/usb/serial/cyberjack.c b/drivers/usb/serial/cyberjack.c
index 6bc3802a581a..d2e536f649ba 100644
--- a/drivers/usb/serial/cyberjack.c
+++ b/drivers/usb/serial/cyberjack.c
@@ -82,7 +82,6 @@ static struct usb_driver cyberjack_driver = {
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	id_table,
-	.no_dynamic_id = 	1,
 };
 
 static struct usb_serial_driver cyberjack_device = {
@@ -91,7 +90,6 @@ static struct usb_serial_driver cyberjack_device = {
 		.name =		"cyberjack",
 	},
 	.description =		"Reiner SCT Cyberjack USB card reader",
-	.usb_driver = 		&amp;cyberjack_driver,
 	.id_table =		id_table,
 	.num_ports =		1,
 	.attach =		cyberjack_startup,
@@ -106,6 +104,10 @@ static struct usb_serial_driver cyberjack_device = {
 	.write_bulk_callback =	cyberjack_write_bulk_callback,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;cyberjack_device, NULL
+};
+
 struct cyberjack_private {
 	spinlock_t	lock;		/* Lock for SMP */
 	short		rdtodo;		/* Bytes still to read */
@@ -476,28 +478,19 @@ static void cyberjack_write_bulk_callback(struct urb *urb)
 static int __init cyberjack_init(void)
 {
 	int retval;
-	retval  = usb_serial_register(&amp;cyberjack_device);
-	if (retval)
-		goto failed_usb_serial_register;
-	retval = usb_register(&amp;cyberjack_driver);
-	if (retval)
-		goto failed_usb_register;
-
-	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION " "
-	       DRIVER_AUTHOR "\n");
-	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_DESC "\n");
 
-	return 0;
-failed_usb_register:
-	usb_serial_deregister(&amp;cyberjack_device);
-failed_usb_serial_register:
+	retval = usb_serial_register_drivers(&amp;cyberjack_driver, serial_drivers);
+	if (retval == 0) {
+		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION " "
+			       DRIVER_AUTHOR "\n");
+		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_DESC "\n");
+	}
 	return retval;
 }
 
 static void __exit cyberjack_exit(void)
 {
-	usb_deregister(&amp;cyberjack_driver);
-	usb_serial_deregister(&amp;cyberjack_device);
+	usb_serial_deregister_drivers(&amp;cyberjack_driver, serial_drivers);
 }
 
 module_init(cyberjack_init);
diff --git a/drivers/usb/serial/cypress_m8.c b/drivers/usb/serial/cypress_m8.c
index 5ae86b349cad..bc5057513d5d 100644
--- a/drivers/usb/serial/cypress_m8.c
+++ b/drivers/usb/serial/cypress_m8.c
@@ -94,7 +94,6 @@ static struct usb_driver cypress_driver = {
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	id_table_combined,
-	.no_dynamic_id = 	1,
 };
 
 enum packet_format {
@@ -163,7 +162,6 @@ static struct usb_serial_driver cypress_earthmate_device = {
 		.name =			"earthmate",
 	},
 	.description =			"DeLorme Earthmate USB",
-	.usb_driver = 			&amp;cypress_driver,
 	.id_table =			id_table_earthmate,
 	.num_ports =			1,
 	.attach =			cypress_earthmate_startup,
@@ -190,7 +188,6 @@ static struct usb_serial_driver cypress_hidcom_device = {
 		.name =			"cyphidcom",
 	},
 	.description =			"HID-&gt;COM RS232 Adapter",
-	.usb_driver = 			&amp;cypress_driver,
 	.id_table =			id_table_cyphidcomrs232,
 	.num_ports =			1,
 	.attach =			cypress_hidcom_startup,
@@ -217,7 +214,6 @@ static struct usb_serial_driver cypress_ca42v2_device = {
 		.name =			"nokiaca42v2",
 	},
 	.description =			"Nokia CA-42 V2 Adapter",
-	.usb_driver = 			&amp;cypress_driver,
 	.id_table =			id_table_nokiaca42v2,
 	.num_ports =			1,
 	.attach =			cypress_ca42v2_startup,
@@ -238,6 +234,11 @@ static struct usb_serial_driver cypress_ca42v2_device = {
 	.write_int_callback =		cypress_write_int_callback,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;cypress_earthmate_device, &amp;cypress_hidcom_device,
+	&amp;cypress_ca42v2_device, NULL
+};
+
 /*****************************************************************************
  * Cypress serial helper functions
  *****************************************************************************/
@@ -1356,30 +1357,10 @@ static int __init cypress_init(void)
 
 	dbg("%s", __func__);
 
-	retval = usb_serial_register(&amp;cypress_earthmate_device);
-	if (retval)
-		goto failed_em_register;
-	retval = usb_serial_register(&amp;cypress_hidcom_device);
-	if (retval)
-		goto failed_hidcom_register;
-	retval = usb_serial_register(&amp;cypress_ca42v2_device);
-	if (retval)
-		goto failed_ca42v2_register;
-	retval = usb_register(&amp;cypress_driver);
-	if (retval)
-		goto failed_usb_register;
-
-	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
-	       DRIVER_DESC "\n");
-	return 0;
-
-failed_usb_register:
-	usb_serial_deregister(&amp;cypress_ca42v2_device);
-failed_ca42v2_register:
-	usb_serial_deregister(&amp;cypress_hidcom_device);
-failed_hidcom_register:
-	usb_serial_deregister(&amp;cypress_earthmate_device);
-failed_em_register:
+	retval = usb_serial_register_drivers(&amp;cypress_driver, serial_drivers);
+	if (retval == 0)
+		printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+			       DRIVER_DESC "\n");
 	return retval;
 }
 
@@ -1388,10 +1369,7 @@ static void __exit cypress_exit(void)
 {
 	dbg("%s", __func__);
 
-	usb_deregister(&amp;cypress_driver);
-	usb_serial_deregister(&amp;cypress_earthmate_device);
-	usb_serial_deregister(&amp;cypress_hidcom_device);
-	usb_serial_deregister(&amp;cypress_ca42v2_device);
+	usb_serial_deregister_drivers(&amp;cypress_driver, serial_drivers);
 }
 
 </pre><hr><pre>commit 765e0ba62613fb90f09c1b5926750df0aa56f349
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Feb 23 14:55:59 2012 -0500

    usb-serial: new API for driver registration
    
    This patch (as1522) adds two new routines to the usb-serial core, for
    registering and unregistering serial drivers.  Instead of registering
    the usb_driver and usb_serial_drivers separately, with error checking
    for each one, the drivers can all be registered and unregistered by a
    single function call.  This reduces duplicated code.
    
    More importantly, the new core routines change the order in which the
    drivers are registered.  Currently the usb-serial drivers are all
    registered first and the usb_driver is done last, which leaves a
    window for problems.  A udev script may quickly add a new dynamic-ID
    for a usb-serial driver, causing the corresponding usb_driver to be
    probed.  If the usb_driver hasn't been registered yet then an oops
    will occur.
    
    The new routine prevents such problems by registering the usb_driver
    first.  To insure that it gets probed properly for already-attached
    serial devices, we call driver_attach() after all the usb-serial
    drivers have been registered.
    
    Along with adding the new routines, the patch modifies the "generic"
    serial driver to use them.  Further patches will similarly modify all
    the other in-tree USB serial drivers.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/serial/generic.c b/drivers/usb/serial/generic.c
index 2a2fa2d0489d..664deb63807c 100644
--- a/drivers/usb/serial/generic.c
+++ b/drivers/usb/serial/generic.c
@@ -54,7 +54,6 @@ static struct usb_driver generic_driver = {
 	.probe =	generic_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	generic_serial_ids,
-	.no_dynamic_id =	1,
 };
 
 /* All of the device info needed for the Generic Serial Converter */
@@ -64,7 +63,6 @@ struct usb_serial_driver usb_serial_generic_device = {
 		.name =		"generic",
 	},
 	.id_table =		generic_device_ids,
-	.usb_driver = 		&amp;generic_driver,
 	.num_ports =		1,
 	.disconnect =		usb_serial_generic_disconnect,
 	.release =		usb_serial_generic_release,
@@ -73,6 +71,10 @@ struct usb_serial_driver usb_serial_generic_device = {
 	.resume =		usb_serial_generic_resume,
 };
 
+static struct usb_serial_driver * const serial_drivers[] = {
+	&amp;usb_serial_generic_device, NULL
+};
+
 static int generic_probe(struct usb_interface *interface,
 			       const struct usb_device_id *id)
 {
@@ -97,13 +99,7 @@ int usb_serial_generic_register(int _debug)
 		USB_DEVICE_ID_MATCH_VENDOR | USB_DEVICE_ID_MATCH_PRODUCT;
 
 	/* register our generic driver with ourselves */
-	retval = usb_serial_register(&amp;usb_serial_generic_device);
-	if (retval)
-		goto exit;
-	retval = usb_register(&amp;generic_driver);
-	if (retval)
-		usb_serial_deregister(&amp;usb_serial_generic_device);
-exit:
+	retval = usb_serial_register_drivers(&amp;generic_driver, serial_drivers);
 #endif
 	return retval;
 }
@@ -112,8 +108,7 @@ void usb_serial_generic_deregister(void)
 {
 #ifdef CONFIG_USB_SERIAL_GENERIC
 	/* remove our generic driver */
-	usb_deregister(&amp;generic_driver);
-	usb_serial_deregister(&amp;usb_serial_generic_device);
+	usb_serial_deregister_drivers(&amp;generic_driver, serial_drivers);
 #endif
 }
 
diff --git a/drivers/usb/serial/usb-serial.c b/drivers/usb/serial/usb-serial.c
index 611b206591cb..45b3658c601f 100644
--- a/drivers/usb/serial/usb-serial.c
+++ b/drivers/usb/serial/usb-serial.c
@@ -1338,6 +1338,11 @@ static void fixup_generic(struct usb_serial_driver *device)
 	set_to_generic_if_null(device, prepare_write_buffer);
 }
 
+/*
+ * The next two routines are mainly for internal use.
+ * They are exported only for out-of-tree modules.
+ * New drivers should call usb_serial_{de}register_drivers() instead.
+ */
 int usb_serial_register(struct usb_serial_driver *driver)
 {
 	int retval;
@@ -1386,6 +1391,76 @@ void usb_serial_deregister(struct usb_serial_driver *device)
 }
 EXPORT_SYMBOL_GPL(usb_serial_deregister);
 
+/**
+ * usb_serial_register_drivers - register drivers for a usb-serial module
+ * @udriver: usb_driver used for matching devices/interfaces
+ * @serial_drivers: NULL-terminated array of pointers to drivers to be registered
+ *
+ * Registers @udriver and all the drivers in the @serial_drivers array.
+ * Automatically fills in the .no_dynamic_id field in @udriver and
+ * the .usb_driver field in each serial driver.
+ */
+int usb_serial_register_drivers(struct usb_driver *udriver,
+		struct usb_serial_driver * const serial_drivers[])
+{
+	int rc;
+	const struct usb_device_id *saved_id_table;
+	struct usb_serial_driver * const *sd;
+
+	/*
+	 * udriver must be registered before any of the serial drivers,
+	 * because the store_new_id() routine for the serial drivers (in
+	 * bus.c) probes udriver.
+	 *
+	 * Performance hack: We don't want udriver to be probed until
+	 * the serial drivers are registered, because the probe would
+	 * simply fail for lack of a matching serial driver.
+	 * Therefore save off udriver's id_table until we are all set.
+	 */
+	saved_id_table = udriver-&gt;id_table;
+	udriver-&gt;id_table = NULL;
+
+	udriver-&gt;no_dynamic_id = 1;
+	rc = usb_register(udriver);
+	if (rc)
+		return rc;
+
+	for (sd = serial_drivers; *sd; ++sd) {
+		(*sd)-&gt;usb_driver = udriver;
+		rc = usb_serial_register(*sd);
+		if (rc)
+			goto failed;
+	}
+
+	/* Now restore udriver's id_table and look for matches */
+	udriver-&gt;id_table = saved_id_table;
+	rc = driver_attach(&amp;udriver-&gt;drvwrap.driver);
+	return 0;
+
+ failed:
+	while (sd-- &gt; serial_drivers)
+		usb_serial_deregister(*sd);
+	usb_deregister(udriver);
+	return rc;
+}
+EXPORT_SYMBOL_GPL(usb_serial_register_drivers);
+
+/**
+ * usb_serial_deregister_drivers - deregister drivers for a usb-serial module
+ * @udriver: usb_driver to unregister
+ * @serial_drivers: NULL-terminated array of pointers to drivers to be deregistered
+ *
+ * Deregisters @udriver and all the drivers in the @serial_drivers array.
+ */
+void usb_serial_deregister_drivers(struct usb_driver *udriver,
+		struct usb_serial_driver * const serial_drivers[])
+{
+	for (; *serial_drivers; ++serial_drivers)
+		usb_serial_deregister(*serial_drivers);
+	usb_deregister(udriver);
+}
+EXPORT_SYMBOL_GPL(usb_serial_deregister_drivers);
+
 /* Module information */
 MODULE_AUTHOR(DRIVER_AUTHOR);
 MODULE_DESCRIPTION(DRIVER_DESC);
diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 10cb74d2ad1d..8c8dbf9c5b89 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -300,8 +300,17 @@ struct usb_serial_driver {
 #define to_usb_serial_driver(d) \
 	container_of(d, struct usb_serial_driver, driver)
 
+/*
+ * These two routines are kept only for backward compatibility.
+ * Don't use them; call usb_serial_{de}register_drivers() instead.
+ */
 extern int  usb_serial_register(struct usb_serial_driver *driver);
 extern void usb_serial_deregister(struct usb_serial_driver *driver);
+
+extern int usb_serial_register_drivers(struct usb_driver *udriver,
+		struct usb_serial_driver * const serial_drivers[]);
+extern void usb_serial_deregister_drivers(struct usb_driver *udriver,
+		struct usb_serial_driver * const serial_drivers[]);
 extern void usb_serial_port_softint(struct usb_serial_port *port);
 
 extern int usb_serial_probe(struct usb_interface *iface,</pre><hr><pre>commit bb94a406682770a35305daaa241ccdb7cab399de
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Feb 21 13:16:32 2012 -0500

    usb-storage: fix freezing of the scanning thread
    
    This patch (as1521b) fixes the interaction between usb-storage's
    scanning thread and the freezer.  The current implementation has a
    race: If the device is unplugged shortly after being plugged in and
    just as a system sleep begins, the scanning thread may get frozen
    before the khubd task.  Khubd won't be able to freeze until the
    disconnect processing is complete, and the disconnect processing can't
    proceed until the scanning thread finishes, so the sleep transition
    will fail.
    
    The implementation in the 3.2 kernel suffers from an additional
    problem.  There the scanning thread calls set_freezable_with_signal(),
    and the signals sent by the freezer will mess up the thread's I/O
    delays, which are all interruptible.
    
    The solution to both problems is the same: Replace the kernel thread
    used for scanning with a delayed-work routine on the system freezable
    work queue.  Freezable work queues have the nice property that you can
    cancel a work item even while the work queue is frozen, and no signals
    are needed.
    
    The 3.2 version of this patch solves the problem in Bugzilla #42730.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Seth Forshee &lt;seth.forshee@canonical.com&gt;
    CC: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/storage/usb.c b/drivers/usb/storage/usb.c
index 3dd7da9fd504..db51ba16dc07 100644
--- a/drivers/usb/storage/usb.c
+++ b/drivers/usb/storage/usb.c
@@ -788,15 +788,19 @@ static void quiesce_and_remove_host(struct us_data *us)
 	struct Scsi_Host *host = us_to_host(us);
 
 	/* If the device is really gone, cut short reset delays */
-	if (us-&gt;pusb_dev-&gt;state == USB_STATE_NOTATTACHED)
+	if (us-&gt;pusb_dev-&gt;state == USB_STATE_NOTATTACHED) {
 		set_bit(US_FLIDX_DISCONNECTING, &amp;us-&gt;dflags);
+		wake_up(&amp;us-&gt;delay_wait);
+	}
 
-	/* Prevent SCSI-scanning (if it hasn't started yet)
-	 * and wait for the SCSI-scanning thread to stop.
+	/* Prevent SCSI scanning (if it hasn't started yet)
+	 * or wait for the SCSI-scanning routine to stop.
 	 */
-	set_bit(US_FLIDX_DONT_SCAN, &amp;us-&gt;dflags);
-	wake_up(&amp;us-&gt;delay_wait);
-	wait_for_completion(&amp;us-&gt;scanning_done);
+	cancel_delayed_work_sync(&amp;us-&gt;scan_dwork);
+
+	/* Balance autopm calls if scanning was cancelled */
+	if (test_bit(US_FLIDX_SCAN_PENDING, &amp;us-&gt;dflags))
+		usb_autopm_put_interface_no_suspend(us-&gt;pusb_intf);
 
 	/* Removing the host will perform an orderly shutdown: caches
 	 * synchronized, disks spun down, etc.
@@ -823,53 +827,28 @@ static void release_everything(struct us_data *us)
 	scsi_host_put(us_to_host(us));
 }
 
-/* Thread to carry out delayed SCSI-device scanning */
-static int usb_stor_scan_thread(void * __us)
+/* Delayed-work routine to carry out SCSI-device scanning */
+static void usb_stor_scan_dwork(struct work_struct *work)
 {
-	struct us_data *us = (struct us_data *)__us;
+	struct us_data *us = container_of(work, struct us_data,
+			scan_dwork.work);
 	struct device *dev = &amp;us-&gt;pusb_intf-&gt;dev;
 
-	dev_dbg(dev, "device found\n");
-
-	set_freezable();
+	dev_dbg(dev, "starting scan\n");
 
-	/*
-	 * Wait for the timeout to expire or for a disconnect
-	 *
-	 * We can't freeze in this thread or we risk causing khubd to
-	 * fail to freeze, but we can't be non-freezable either. Nor can
-	 * khubd freeze while waiting for scanning to complete as it may
-	 * hold the device lock, causing a hang when suspending devices.
-	 * So instead of using wait_event_freezable(), explicitly test
-	 * for (DONT_SCAN || freezing) in interruptible wait and proceed
-	 * if any of DONT_SCAN, freezing or timeout has happened.
-	 */
-	if (delay_use &gt; 0) {
-		dev_dbg(dev, "waiting for device to settle "
-				"before scanning\n");
-		wait_event_interruptible_timeout(us-&gt;delay_wait,
-				test_bit(US_FLIDX_DONT_SCAN, &amp;us-&gt;dflags) ||
-				freezing(current), delay_use * HZ);
+	/* For bulk-only devices, determine the max LUN value */
+	if (us-&gt;protocol == USB_PR_BULK &amp;&amp; !(us-&gt;fflags &amp; US_FL_SINGLE_LUN)) {
+		mutex_lock(&amp;us-&gt;dev_mutex);
+		us-&gt;max_lun = usb_stor_Bulk_max_lun(us);
+		mutex_unlock(&amp;us-&gt;dev_mutex);
 	}
+	scsi_scan_host(us_to_host(us));
+	dev_dbg(dev, "scan complete\n");
 
-	/* If the device is still connected, perform the scanning */
-	if (!test_bit(US_FLIDX_DONT_SCAN, &amp;us-&gt;dflags)) {
-
-		/* For bulk-only devices, determine the max LUN value */
-		if (us-&gt;protocol == USB_PR_BULK &amp;&amp;
-				!(us-&gt;fflags &amp; US_FL_SINGLE_LUN)) {
-			mutex_lock(&amp;us-&gt;dev_mutex);
-			us-&gt;max_lun = usb_stor_Bulk_max_lun(us);
-			mutex_unlock(&amp;us-&gt;dev_mutex);
-		}
-		scsi_scan_host(us_to_host(us));
-		dev_dbg(dev, "scan complete\n");
-
-		/* Should we unbind if no devices were detected? */
-	}
+	/* Should we unbind if no devices were detected? */
 
 	usb_autopm_put_interface(us-&gt;pusb_intf);
-	complete_and_exit(&amp;us-&gt;scanning_done, 0);
+	clear_bit(US_FLIDX_SCAN_PENDING, &amp;us-&gt;dflags);
 }
 
 static unsigned int usb_stor_sg_tablesize(struct usb_interface *intf)
@@ -916,7 +895,7 @@ int usb_stor_probe1(struct us_data **pus,
 	init_completion(&amp;us-&gt;cmnd_ready);
 	init_completion(&amp;(us-&gt;notify));
 	init_waitqueue_head(&amp;us-&gt;delay_wait);
-	init_completion(&amp;us-&gt;scanning_done);
+	INIT_DELAYED_WORK(&amp;us-&gt;scan_dwork, usb_stor_scan_dwork);
 
 	/* Associate the us_data structure with the USB device */
 	result = associate_dev(us, intf);
@@ -947,7 +926,6 @@ EXPORT_SYMBOL_GPL(usb_stor_probe1);
 /* Second part of general USB mass-storage probing */
 int usb_stor_probe2(struct us_data *us)
 {
-	struct task_struct *th;
 	int result;
 	struct device *dev = &amp;us-&gt;pusb_intf-&gt;dev;
 
@@ -988,20 +966,14 @@ int usb_stor_probe2(struct us_data *us)
 		goto BadDevice;
 	}
 
-	/* Start up the thread for delayed SCSI-device scanning */
-	th = kthread_create(usb_stor_scan_thread, us, "usb-stor-scan");
-	if (IS_ERR(th)) {
-		dev_warn(dev,
-				"Unable to start the device-scanning thread\n");
-		complete(&amp;us-&gt;scanning_done);
-		quiesce_and_remove_host(us);
-		result = PTR_ERR(th);
-		goto BadDevice;
-	}
-
+	/* Submit the delayed_work for SCSI-device scanning */
 	usb_autopm_get_interface_no_resume(us-&gt;pusb_intf);
-	wake_up_process(th);
+	set_bit(US_FLIDX_SCAN_PENDING, &amp;us-&gt;dflags);
 
+	if (delay_use &gt; 0)
+		dev_dbg(dev, "waiting for device to settle before scanning\n");
+	queue_delayed_work(system_freezable_wq, &amp;us-&gt;scan_dwork,
+			delay_use * HZ);
 	return 0;
 
 	/* We come here if there are any problems */
diff --git a/drivers/usb/storage/usb.h b/drivers/usb/storage/usb.h
index 7b0f2113632e..75f70f04f37b 100644
--- a/drivers/usb/storage/usb.h
+++ b/drivers/usb/storage/usb.h
@@ -47,6 +47,7 @@
 #include &lt;linux/blkdev.h&gt;
 #include &lt;linux/completion.h&gt;
 #include &lt;linux/mutex.h&gt;
+#include &lt;linux/workqueue.h&gt;
 #include &lt;scsi/scsi_host.h&gt;
 
 struct us_data;
@@ -72,7 +73,7 @@ struct us_unusual_dev {
 #define US_FLIDX_DISCONNECTING	3	/* disconnect in progress   */
 #define US_FLIDX_RESETTING	4	/* device reset in progress */
 #define US_FLIDX_TIMED_OUT	5	/* SCSI midlayer timed out  */
-#define US_FLIDX_DONT_SCAN	6	/* don't scan (disconnect)  */
+#define US_FLIDX_SCAN_PENDING	6	/* scanning not yet done    */
 #define US_FLIDX_REDO_READ10	7	/* redo READ(10) command    */
 #define US_FLIDX_READ10_WORKED	8	/* previous READ(10) succeeded */
 
@@ -147,8 +148,8 @@ struct us_data {
 	/* mutual exclusion and synchronization structures */
 	struct completion	cmnd_ready;	 /* to sleep thread on	    */
 	struct completion	notify;		 /* thread begin/end	    */
-	wait_queue_head_t	delay_wait;	 /* wait during scan, reset */
-	struct completion	scanning_done;	 /* wait for scan thread    */
+	wait_queue_head_t	delay_wait;	 /* wait during reset	    */
+	struct delayed_work	scan_dwork;	 /* for async scanning      */
 
 	/* subdriver information */
 	void			*extra;		 /* Any extra data          */</pre>
    <div class="pagination">
        <a href='2_50.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><span>[51]</span><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_52.html'>Next&gt;&gt;</a>
    <div>
</body>
