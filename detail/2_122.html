<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_121.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><span>[122]</span><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_123.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 349710c3a79c0405911b8b604953f0c665e17756
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Jul 1 22:05:56 2006 -0400

    usbfs: detect device unregistration
    
    This patch (as711b) is a revised version of an earlier submission.  It
    modifies the usbfs code to detect when a device has been unregistered from
    usbfs, even if the device is still connected.  Although this can't happen
    now, it will be able to happen after the upcoming changes to usb_generic.
    
    Nobody objected to this patch when it was submitted before, so it should
    be okay to apply this version.  The revision is merely to take into
    account the changes introduced by as723, which touches the same driver.
    
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index d8b0476237f3..e84f19d4089c 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -90,9 +90,10 @@ MODULE_PARM_DESC (usbfs_snoop, "true to log all usbfs traffic");
 
 #define	MAX_USBFS_BUFFER_SIZE	16384
 
-static inline int connected (struct usb_device *dev)
+static inline int connected (struct dev_state *ps)
 {
-	return dev-&gt;state != USB_STATE_NOTATTACHED;
+	return (!list_empty(&amp;ps-&gt;list) &amp;&amp;
+			ps-&gt;dev-&gt;state != USB_STATE_NOTATTACHED);
 }
 
 static loff_t usbdev_lseek(struct file *file, loff_t offset, int orig)
@@ -130,7 +131,7 @@ static ssize_t usbdev_read(struct file *file, char __user *buf, size_t nbytes, l
 
 	pos = *ppos;
 	usb_lock_device(dev);
-	if (!connected(dev)) {
+	if (!connected(ps)) {
 		ret = -ENODEV;
 		goto err;
 	} else if (pos &lt; 0) {
@@ -1326,7 +1327,7 @@ static int proc_ioctl(struct dev_state *ps, struct usbdevfs_ioctl *ctl)
 		}
 	}
 
-	if (!connected(ps-&gt;dev)) {
+	if (!connected(ps)) {
 		kfree(buf);
 		return -ENODEV;
 	}
@@ -1425,7 +1426,7 @@ static int usbdev_ioctl(struct inode *inode, struct file *file, unsigned int cmd
 	if (!(file-&gt;f_mode &amp; FMODE_WRITE))
 		return -EPERM;
 	usb_lock_device(dev);
-	if (!connected(dev)) {
+	if (!connected(ps)) {
 		usb_unlock_device(dev);
 		return -ENODEV;
 	}
@@ -1566,7 +1567,7 @@ static unsigned int usbdev_poll(struct file *file, struct poll_table_struct *wai
 	poll_wait(file, &amp;ps-&gt;wait, wait);
 	if (file-&gt;f_mode &amp; FMODE_WRITE &amp;&amp; !list_empty(&amp;ps-&gt;async_completed))
 		mask |= POLLOUT | POLLWRNORM;
-	if (!connected(ps-&gt;dev))
+	if (!connected(ps))
 		mask |= POLLERR | POLLHUP;
 	return mask;
 }</pre><hr><pre>commit 4a2a8a2cce86b9d001378cc25acb5c61e6ca7d63
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Jul 1 22:05:01 2006 -0400

    usbfs: private mutex for open, release, and remove
    
    The usbfs code doesn't provide sufficient mutual exclusion among open,
    release, and remove.  Release vs. remove is okay because they both
    acquire the device lock, but open is not exclusive with either one.  All
    three routines modify the udev-&gt;filelist linked list, so they must not
    run concurrently.
    
    Apparently someone gave this a minimum amount of thought in the past by
    explicitly acquiring the BKL at the start of the usbdev_open routine.
    Oddly enough, there's a comment pointing out that locking is unnecessary
    because chrdev_open already has acquired the BKL.
    
    But this ignores the point that the files in /proc/bus/usb/* are not
    char device files; they are regular files and so they don't get any
    special locking.  Furthermore it's necessary to acquire the same lock in
    the release and remove routines, which the code does not do.
    
    Yet another problem arises because the same file_operations structure is
    accessible through both the /proc/bus/usb/* and /dev/usb/usbdev* file
    nodes.  Even when one of them has been removed, it's still possible for
    userspace to open the other.  So simple locking around the individual
    remove routines is insufficient; we need to lock the entire
    usb_notify_remove_device notifier chain.
    
    Rather than rely on the BKL, this patch (as723) introduces a new private
    mutex for the purpose.  Holding the BKL while invoking a notifier chain
    doesn't seem like a good idea.
    
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 32e03000420c..d8b0476237f3 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -59,6 +59,9 @@
 #define USB_DEVICE_MAX			USB_MAXBUS * 128
 static struct class *usb_device_class;
 
+/* Mutual exclusion for removal, open, and release */
+DEFINE_MUTEX(usbfs_mutex);
+
 struct async {
 	struct list_head asynclist;
 	struct dev_state *ps;
@@ -541,15 +544,13 @@ static int usbdev_open(struct inode *inode, struct file *file)
 	struct dev_state *ps;
 	int ret;
 
-	/* 
-	 * no locking necessary here, as chrdev_open has the kernel lock
-	 * (still acquire the kernel lock for safety)
-	 */
+	/* Protect against simultaneous removal or release */
+	mutex_lock(&amp;usbfs_mutex);
+
 	ret = -ENOMEM;
 	if (!(ps = kmalloc(sizeof(struct dev_state), GFP_KERNEL)))
-		goto out_nolock;
+		goto out;
 
-	lock_kernel();
 	ret = -ENOENT;
 	/* check if we are called from a real node or usbfs */
 	if (imajor(inode) == USB_DEVICE_MAJOR)
@@ -579,9 +580,8 @@ static int usbdev_open(struct inode *inode, struct file *file)
 	list_add_tail(&amp;ps-&gt;list, &amp;dev-&gt;filelist);
 	file-&gt;private_data = ps;
  out:
-	unlock_kernel();
- out_nolock:
-        return ret;
+	mutex_unlock(&amp;usbfs_mutex);
+	return ret;
 }
 
 static int usbdev_release(struct inode *inode, struct file *file)
@@ -591,7 +591,12 @@ static int usbdev_release(struct inode *inode, struct file *file)
 	unsigned int ifnum;
 
 	usb_lock_device(dev);
+
+	/* Protect against simultaneous open */
+	mutex_lock(&amp;usbfs_mutex);
 	list_del_init(&amp;ps-&gt;list);
+	mutex_unlock(&amp;usbfs_mutex);
+
 	for (ifnum = 0; ps-&gt;ifclaimed &amp;&amp; ifnum &lt; 8*sizeof(ps-&gt;ifclaimed);
 			ifnum++) {
 		if (test_bit(ifnum, &amp;ps-&gt;ifclaimed))
@@ -600,9 +605,8 @@ static int usbdev_release(struct inode *inode, struct file *file)
 	destroy_all_async(ps);
 	usb_unlock_device(dev);
 	usb_put_dev(dev);
-	ps-&gt;dev = NULL;
 	kfree(ps);
-        return 0;
+	return 0;
 }
 
 static int proc_control(struct dev_state *ps, void __user *arg)
diff --git a/drivers/usb/core/notify.c b/drivers/usb/core/notify.c
index b042676af0a5..6b36897ca151 100644
--- a/drivers/usb/core/notify.c
+++ b/drivers/usb/core/notify.c
@@ -50,8 +50,11 @@ void usb_notify_add_device(struct usb_device *udev)
 
 void usb_notify_remove_device(struct usb_device *udev)
 {
+	/* Protect against simultaneous usbfs open */
+	mutex_lock(&amp;usbfs_mutex);
 	blocking_notifier_call_chain(&amp;usb_notifier_list,
 			USB_DEVICE_REMOVE, udev);
+	mutex_unlock(&amp;usbfs_mutex);
 }
 
 void usb_notify_add_bus(struct usb_bus *ubus)
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 49f69236b420..1217fbbe5829 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -59,6 +59,7 @@ static inline int is_active(struct usb_interface *f)
 extern const char *usbcore_name;
 
 /* usbfs stuff */
+extern struct mutex usbfs_mutex;
 extern struct usb_driver usbfs_driver;
 extern struct file_operations usbfs_devices_fops;
 extern struct file_operations usbfs_device_file_operations;</pre><hr><pre>commit b6eb2d84d2bb01e9fcc46a032a3429b4747b1c47
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jul 6 15:37:42 2006 -0400

    usbcore: add configuration_string to attribute group
    
    This patch (as737b) does a very small cleanup of core/sysfs.c by adding
    the configuration_string attribute file to the existing attribute group
    instead of treating it separately.  It doesn't need this separate
    treatment because unlike the other device string attributes, it changes
    along with the active configuration.
    
    The patch also fixes a simple typo (which, oddly enough, doesn't seem to
    bother the compiler).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c
index dec973affb0f..cd2286246f6a 100644
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -60,7 +60,7 @@ static ssize_t
 set_bConfigurationValue (struct device *dev, struct device_attribute *attr,
 		const char *buf, size_t count)
 {
-	struct usb_device	*udev = udev = to_usb_device (dev);
+	struct usb_device	*udev = to_usb_device (dev);
 	int			config, value;
 
 	if (sscanf (buf, "%u", &amp;config) != 1 || config &gt; 255)
@@ -186,6 +186,7 @@ usb_descriptor_attr (bMaxPacketSize0, "%d\n")
 
 static struct attribute *dev_attrs[] = {
 	/* current configuration's attributes */
+	&amp;dev_attr_configuration.attr,
 	&amp;dev_attr_bNumInterfaces.attr,
 	&amp;dev_attr_bConfigurationValue.attr,
 	&amp;dev_attr_bmAttributes.attr,
@@ -221,7 +222,6 @@ void usb_create_sysfs_dev_files (struct usb_device *udev)
 		device_create_file (dev, &amp;dev_attr_product);
 	if (udev-&gt;serial)
 		device_create_file (dev, &amp;dev_attr_serial);
-	device_create_file (dev, &amp;dev_attr_configuration);
 	usb_create_ep_files(dev, &amp;udev-&gt;ep0, udev);
 }
 
@@ -238,7 +238,6 @@ void usb_remove_sysfs_dev_files (struct usb_device *udev)
 		device_remove_file(dev, &amp;dev_attr_product);
 	if (udev-&gt;serial)
 		device_remove_file(dev, &amp;dev_attr_serial);
-	device_remove_file (dev, &amp;dev_attr_configuration);
 }
 
 /* Interface fields */</pre><hr><pre>commit b97b196c9d351a501ed89fc836e4e2fe71ff93c9
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Sep 14 15:18:54 2006 -0400

    USB: unusual_devs entry for Lacie DVD+-RW
    
    This patch (as781) adds an entry to unusual_devs.h for the Lacie DVD+-RW
    drive.  Apparently its USB interface has requirements similar to the
    Genesys Logic interface; it doesn't like data to be sent too soon after
    a command.
    
    This fixes Bugzilla #6817.
    
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Phil Dibowitz &lt;phil@ipom.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index b130e170b4a8..4b06ac34430f 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -631,6 +631,13 @@ UNUSUAL_DEV(  0x0595, 0x4343, 0x0000, 0x2210,
 		"Digital Camera EX-20 DSC",
 		US_SC_8070, US_PR_DEVICE, NULL, 0 ),
 
+/* Reported by &lt;Hendryk.Pfeiffer@gmx.de&gt; */
+UNUSUAL_DEV(  0x059f, 0x0643, 0x0000, 0x0000,
+		"LaCie",
+		"DVD+-RW",
+		US_SC_DEVICE, US_PR_DEVICE, NULL,
+		US_FL_GO_SLOW ),
+
 /* Submitted by Joel Bourquard &lt;numlock@freesurf.ch&gt;
  * Some versions of this device need the SubClass and Protocol overrides
  * while others don't.</pre><hr><pre>commit 7e9f4b2d3e21e87c26025810413ef1592834e63b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Sep 18 16:28:06 2006 -0400

    Driver core: Don't call put methods while holding a spinlock
    
    The klist utility routines currently call _put methods while holding a
    spinlock.  This is of course illegal; a put routine could try to
    unregister a device and hence need to sleep.
    
    No problems have arisen until now because in many cases klist removals
    were done synchronously, so the _put methods were never actually used.
    In other cases we may simply have been lucky.
    
    This patch (as784) reworks the klist routines so that _put methods are
    called only _after_ the klist's spinlock has been released.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/lib/klist.c b/lib/klist.c
index 9c94f0b163a1..120bd175aa78 100644
--- a/lib/klist.c
+++ b/lib/klist.c
@@ -123,12 +123,10 @@ EXPORT_SYMBOL_GPL(klist_add_tail);
 static void klist_release(struct kref * kref)
 {
 	struct klist_node * n = container_of(kref, struct klist_node, n_ref);
-	void (*put)(struct klist_node *) = n-&gt;n_klist-&gt;put;
+
 	list_del(&amp;n-&gt;n_node);
 	complete(&amp;n-&gt;n_removed);
 	n-&gt;n_klist = NULL;
-	if (put)
-		put(n);
 }
 
 static int klist_dec_and_del(struct klist_node * n)
@@ -145,10 +143,14 @@ static int klist_dec_and_del(struct klist_node * n)
 void klist_del(struct klist_node * n)
 {
 	struct klist * k = n-&gt;n_klist;
+	void (*put)(struct klist_node *) = k-&gt;put;
 
 	spin_lock(&amp;k-&gt;k_lock);
-	klist_dec_and_del(n);
+	if (!klist_dec_and_del(n))
+		put = NULL;
 	spin_unlock(&amp;k-&gt;k_lock);
+	if (put)
+		put(n);
 }
 
 EXPORT_SYMBOL_GPL(klist_del);
@@ -161,10 +163,7 @@ EXPORT_SYMBOL_GPL(klist_del);
 
 void klist_remove(struct klist_node * n)
 {
-	struct klist * k = n-&gt;n_klist;
-	spin_lock(&amp;k-&gt;k_lock);
-	klist_dec_and_del(n);
-	spin_unlock(&amp;k-&gt;k_lock);
+	klist_del(n);
 	wait_for_completion(&amp;n-&gt;n_removed);
 }
 
@@ -260,12 +259,15 @@ static struct klist_node * to_klist_node(struct list_head * n)
 struct klist_node * klist_next(struct klist_iter * i)
 {
 	struct list_head * next;
+	struct klist_node * lnode = i-&gt;i_cur;
 	struct klist_node * knode = NULL;
+	void (*put)(struct klist_node *) = i-&gt;i_klist-&gt;put;
 
 	spin_lock(&amp;i-&gt;i_klist-&gt;k_lock);
-	if (i-&gt;i_cur) {
-		next = i-&gt;i_cur-&gt;n_node.next;
-		klist_dec_and_del(i-&gt;i_cur);
+	if (lnode) {
+		next = lnode-&gt;n_node.next;
+		if (!klist_dec_and_del(lnode))
+			put = NULL;
 	} else
 		next = i-&gt;i_head-&gt;next;
 
@@ -275,6 +277,8 @@ struct klist_node * klist_next(struct klist_iter * i)
 	}
 	i-&gt;i_cur = knode;
 	spin_unlock(&amp;i-&gt;i_klist-&gt;k_lock);
+	if (put &amp;&amp; lnode)
+		put(lnode);
 	return knode;
 }
 </pre><hr><pre>commit 81107bf531d2524afbcd61f3b4ad57a71295d591
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Sep 18 16:24:28 2006 -0400

    Driver core: Remove unneeded routines from driver core
    
    This patch (as783) simplifies the driver core slightly by removing four
    unnecessary _get and _put methods.
    
    It is vital that when a driver is removed from its bus's klist of
    registered drivers, or when a device is removed from a driver's klist
    of bound devices, that the klist updates complete synchronously.
    Otherwise the kernel might try binding an unregistered driver to a
    newly-registered device, or adding a device to the klist for a new
    driver before it has been removed from the old driver's klist.
    
    Since the removals must be synchronous, they don't need to update any
    reference counts.  Hence the _get and _put methods can be dispensed
    with.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/base/bus.c b/drivers/base/bus.c
index 636af538a2b5..12173d16bea7 100644
--- a/drivers/base/bus.c
+++ b/drivers/base/bus.c
@@ -696,22 +696,6 @@ static void klist_devices_put(struct klist_node *n)
 	put_device(dev);
 }
 
-static void klist_drivers_get(struct klist_node *n)
-{
-	struct device_driver *drv = container_of(n, struct device_driver,
-						 knode_bus);
-
-	get_driver(drv);
-}
-
-static void klist_drivers_put(struct klist_node *n)
-{
-	struct device_driver *drv = container_of(n, struct device_driver,
-						 knode_bus);
-
-	put_driver(drv);
-}
-
 /**
  *	bus_register - register a bus with the system.
  *	@bus:	bus.
@@ -747,7 +731,7 @@ int bus_register(struct bus_type * bus)
 		goto bus_drivers_fail;
 
 	klist_init(&amp;bus-&gt;klist_devices, klist_devices_get, klist_devices_put);
-	klist_init(&amp;bus-&gt;klist_drivers, klist_drivers_get, klist_drivers_put);
+	klist_init(&amp;bus-&gt;klist_drivers, NULL, NULL);
 	bus_add_attrs(bus);
 
 	pr_debug("bus type '%s' registered\n", bus-&gt;name);
diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index 562600dd540a..1214cbd17d86 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -142,20 +142,6 @@ void put_driver(struct device_driver * drv)
 	kobject_put(&amp;drv-&gt;kobj);
 }
 
-static void klist_devices_get(struct klist_node *n)
-{
-	struct device *dev = container_of(n, struct device, knode_driver);
-
-	get_device(dev);
-}
-
-static void klist_devices_put(struct klist_node *n)
-{
-	struct device *dev = container_of(n, struct device, knode_driver);
-
-	put_device(dev);
-}
-
 /**
  *	driver_register - register driver with bus
  *	@drv:	driver to register
@@ -175,7 +161,7 @@ int driver_register(struct device_driver * drv)
 	    (drv-&gt;bus-&gt;shutdown &amp;&amp; drv-&gt;shutdown)) {
 		printk(KERN_WARNING "Driver '%s' needs updating - please use bus_type methods\n", drv-&gt;name);
 	}
-	klist_init(&amp;drv-&gt;klist_devices, klist_devices_get, klist_devices_put);
+	klist_init(&amp;drv-&gt;klist_devices, NULL, NULL);
 	init_completion(&amp;drv-&gt;unloaded);
 	return bus_add_driver(drv);
 }</pre><hr><pre>commit f2eaae197f4590c4d96f31b09b0ee9067421a95c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Sep 18 16:22:34 2006 -0400

    Driver core: Fix potential deadlock in driver core
    
    There is a potential deadlock in the driver core.  It boils down to
    the fact that bus_remove_device() calls klist_remove() instead of
    klist_del(), thereby waiting until the reference count of the
    klist_node in the bus's klist of devices drops to 0.  The refcount
    can't reach 0 so long as a modprobe process is trying to bind a new
    driver to the device being removed, by calling __driver_attach().  The
    problem is that __driver_attach() tries to acquire the device's
    parent's semaphore, but the caller of bus_remove_device() is quite
    likely to own that semaphore already.
    
    It isn't sufficient just to replace klist_remove() with klist_del().
    Doing so runs the risk that the device would remain on the bus's klist
    of devices for some time, and so could be bound to another driver even
    after it was unregistered.  What's needed is a new way to distinguish
    whether or not a device is registered, based on a criterion other than
    whether its klist_node is linked into the bus's klist of devices.  That
    way driver binding can fail when the device is unregistered, even if
    it is still linked into the klist.
    
    This patch (as782) implements the solution, by adding a new bitflag to
    indiate when a struct device is registered, by testing the flag before
    allowing a driver to bind a device, and by changing the definition of
    the device_is_registered() inline.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/base/bus.c b/drivers/base/bus.c
index aa685a20b649..636af538a2b5 100644
--- a/drivers/base/bus.c
+++ b/drivers/base/bus.c
@@ -392,6 +392,7 @@ int bus_add_device(struct device * dev)
  *	bus_attach_device - add device to bus
  *	@dev:	device tried to attach to a driver
  *
+ *	- Add device to bus's list of devices.
  *	- Try to attach to driver.
  */
 int bus_attach_device(struct device * dev)
@@ -400,11 +401,13 @@ int bus_attach_device(struct device * dev)
 	int ret = 0;
 
 	if (bus) {
+		dev-&gt;is_registered = 1;
 		ret = device_attach(dev);
 		if (ret &gt;= 0) {
 			klist_add_tail(&amp;dev-&gt;knode_bus, &amp;bus-&gt;klist_devices);
 			ret = 0;
-		}
+		} else
+			dev-&gt;is_registered = 0;
 	}
 	return ret;
 }
@@ -425,7 +428,8 @@ void bus_remove_device(struct device * dev)
 		sysfs_remove_link(&amp;dev-&gt;kobj, "bus");
 		sysfs_remove_link(&amp;dev-&gt;bus-&gt;devices.kobj, dev-&gt;bus_id);
 		device_remove_attrs(dev-&gt;bus, dev);
-		klist_remove(&amp;dev-&gt;knode_bus);
+		dev-&gt;is_registered = 0;
+		klist_del(&amp;dev-&gt;knode_bus);
 		pr_debug("bus %s: remove device %s\n", dev-&gt;bus-&gt;name, dev-&gt;bus_id);
 		device_release_driver(dev);
 		put_bus(dev-&gt;bus);
diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 319a73be4180..b5f43c3e44fa 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -162,6 +162,8 @@ int driver_probe_device(struct device_driver * drv, struct device * dev)
 	struct task_struct *probe_task;
 	int ret = 0;
 
+	if (!device_is_registered(dev))
+		return -ENODEV;
 	if (drv-&gt;bus-&gt;match &amp;&amp; !drv-&gt;bus-&gt;match(dev, drv))
 		goto done;
 
diff --git a/include/linux/device.h b/include/linux/device.h
index 74246efba931..662e6a10144e 100644
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@ -329,6 +329,7 @@ struct device {
 
 	struct kobject kobj;
 	char	bus_id[BUS_ID_SIZE];	/* position on parent bus */
+	unsigned		is_registered:1;
 	struct device_attribute uevent_attr;
 	struct device_attribute *devt_attr;
 
@@ -381,7 +382,7 @@ dev_set_drvdata (struct device *dev, void *data)
 
 static inline int device_is_registered(struct device *dev)
 {
-	return klist_node_attached(&amp;dev-&gt;knode_bus);
+	return dev-&gt;is_registered;
 }
 
 /*</pre><hr><pre>commit e5b3cd42960a10c1bc3701d4f00767463c88ec9d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Aug 21 15:53:25 2006 -0400

    [SCSI] SCSI: sanitize INQUIRY strings
    
    Sanitize the Vendor, Product, and Revision strings contained in an
    INQUIRY result by setting all non-graphic or non-ASCII characters to ' '.
    Since the standard disallows such characters, this will affect
    only non-compliant devices.
    
    To help maintain backward compatibility, NUL characters are treated
    specially.  They are taken as string terminators; they and all the
    following characters are set to ' '.  If some valid characters get
    erased as a result... well, we weren't seeing them before so we haven't
    lost anything.
    
    The primary purpose of this change is to allow blacklist entries to
    match devices with illegal Vendor or Product strings.
    
    In addition, the patch updates a couple of function prototypes, giving
    inq_result its correct type (unsigned char *).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c
index a24d3461fc78..31d05ab0b2fc 100644
--- a/drivers/scsi/scsi_scan.c
+++ b/drivers/scsi/scsi_scan.c
@@ -396,6 +396,32 @@ void scsi_target_reap(struct scsi_target *starget)
 	return;
 }
 
+/**
+ * sanitize_inquiry_string - remove non-graphical chars from an INQUIRY result string
+ * @s: INQUIRY result string to sanitize
+ * @len: length of the string
+ *
+ * Description:
+ *	The SCSI spec says that INQUIRY vendor, product, and revision
+ *	strings must consist entirely of graphic ASCII characters,
+ *	padded on the right with spaces.  Since not all devices obey
+ *	this rule, we will replace non-graphic or non-ASCII characters
+ *	with spaces.  Exception: a NUL character is interpreted as a
+ *	string terminator, so all the following characters are set to
+ *	spaces.
+ **/
+static void sanitize_inquiry_string(unsigned char *s, int len)
+{
+	int terminated = 0;
+
+	for (; len &gt; 0; (--len, ++s)) {
+		if (*s == 0)
+			terminated = 1;
+		if (terminated || *s &lt; 0x20 || *s &gt; 0x7e)
+			*s = ' ';
+	}
+}
+
 /**
  * scsi_probe_lun - probe a single LUN using a SCSI INQUIRY
  * @sdev:	scsi_device to probe
@@ -410,7 +436,7 @@ void scsi_target_reap(struct scsi_target *starget)
  *     INQUIRY data is in @inq_result; the scsi_level and INQUIRY length
  *     are copied to the scsi_device any flags value is stored in *@bflags.
  **/
-static int scsi_probe_lun(struct scsi_device *sdev, char *inq_result,
+static int scsi_probe_lun(struct scsi_device *sdev, unsigned char *inq_result,
 			  int result_len, int *bflags)
 {
 	unsigned char scsi_cmd[MAX_COMMAND_SIZE];
@@ -469,7 +495,11 @@ static int scsi_probe_lun(struct scsi_device *sdev, char *inq_result,
 	}
 
 	if (result == 0) {
-		response_len = (unsigned char) inq_result[4] + 5;
+		sanitize_inquiry_string(&amp;inq_result[8], 8);
+		sanitize_inquiry_string(&amp;inq_result[16], 16);
+		sanitize_inquiry_string(&amp;inq_result[32], 4);
+
+		response_len = inq_result[4] + 5;
 		if (response_len &gt; 255)
 			response_len = first_inquiry_len;	/* sanity */
 
@@ -575,7 +605,8 @@ static int scsi_probe_lun(struct scsi_device *sdev, char *inq_result,
  *     SCSI_SCAN_NO_RESPONSE: could not allocate or setup a scsi_device
  *     SCSI_SCAN_LUN_PRESENT: a new scsi_device was allocated and initialized
  **/
-static int scsi_add_lun(struct scsi_device *sdev, char *inq_result, int *bflags)
+static int scsi_add_lun(struct scsi_device *sdev, unsigned char *inq_result,
+		int *bflags)
 {
 	/*
 	 * XXX do not save the inquiry, since it can change underneath us,</pre><hr><pre>commit db59b464f8708cdba857f16b183cff0b7466d6b5
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Aug 31 14:18:39 2006 -0400

    uhci-hcd: fix list access bug
    
    When skipping to the last TD of an URB, go to the _last_ entry in the
    list instead of the _first_ entry (as780).  This fixes Bugzilla #6747
    and possibly others.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 026dad06f82b..431e8f31f1a9 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -372,7 +372,7 @@ static void uhci_fixup_toggles(struct uhci_qh *qh, int skip_first)
 		 * need to change any toggles in this URB */
 		td = list_entry(urbp-&gt;td_list.next, struct uhci_td, list);
 		if (toggle &gt; 1 || uhci_toggle(td_token(td)) == toggle) {
-			td = list_entry(urbp-&gt;td_list.next, struct uhci_td,
+			td = list_entry(urbp-&gt;td_list.prev, struct uhci_td,
 					list);
 			toggle = uhci_toggle(td_token(td)) ^ 1;
 </pre><hr><pre>commit 7ceb932f489e86b555258e5f7d7f061f9c1863eb
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Aug 21 11:58:50 2006 -0400

    UHCI: don't stop at an Iso error
    
    Unlike other sorts of endpoint queues, Isochronous queues don't stop
    when an error is encountered.  This patch (as772) fixes the scanning
    routine in uhci-hcd, to make it keep on going when it finds an Iso
    error.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 66c3f61bc9d1..026dad06f82b 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -1348,7 +1348,7 @@ static void uhci_scan_qh(struct uhci_hcd *uhci, struct uhci_qh *qh,
 		}
 
 		uhci_giveback_urb(uhci, qh, urb, regs);
-		if (status &lt; 0)
+		if (status &lt; 0 &amp;&amp; qh-&gt;type != USB_ENDPOINT_XFER_ISOC)
 			break;
 	}
 </pre>
    <div class="pagination">
        <a href='2_121.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><span>[122]</span><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_123.html'>Next&gt;&gt;</a>
    <div>
</body>
