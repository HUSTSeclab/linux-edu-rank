<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_49.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><span>[50]</span><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_51.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit b446b96fd11b69b7c4ecd47d869cff9094fd8802
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Apr 3 15:24:43 2012 -0400

    UHCI: hub_status_data should indicate if ports are resuming
    
    This patch (as1538) causes uhci_hub_status_data() to return a nonzero
    value when any port is undergoing a resume transition while the root
    hub is suspended.  This will allow usbcore to handle races between
    root-hub suspend and port wakeup.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/uhci-hub.c b/drivers/usb/host/uhci-hub.c
index 045cde4cbc3d..768d54295a20 100644
--- a/drivers/usb/host/uhci-hub.c
+++ b/drivers/usb/host/uhci-hub.c
@@ -196,11 +196,12 @@ static int uhci_hub_status_data(struct usb_hcd *hcd, char *buf)
 	status = get_hub_status_data(uhci, buf);
 
 	switch (uhci-&gt;rh_state) {
-	    case UHCI_RH_SUSPENDING:
 	    case UHCI_RH_SUSPENDED:
 		/* if port change, ask to be resumed */
-		if (status || uhci-&gt;resuming_ports)
+		if (status || uhci-&gt;resuming_ports) {
+			status = 1;
 			usb_hcd_resume_root_hub(hcd);
+		}
 		break;
 
 	    case UHCI_RH_AUTO_STOPPED:</pre><hr><pre>commit a448e4dc25303fe551e4dafe16c8c7c34f1b9d82
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Apr 3 15:24:30 2012 -0400

    EHCI: keep track of ports being resumed and indicate in hub_status_data
    
    This patch (as1537) adds a bit-array to ehci-hcd for keeping track of
    which ports are undergoing a resume transition.  If any of the bits
    are set when ehci_hub_status_data() is called, the routine will return
    a nonzero value even if no ports have any status changes pending.
    This will allow usbcore to handle races between root-hub suspend and
    port wakeup.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Sarah Sharp &lt;sarah.a.sharp@linux.intel.com&gt;
    CC: Chen Peter-B29397 &lt;B29397@freescale.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 057cdda7a489..806cc95317aa 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -347,6 +347,8 @@ static int ehci_reset (struct ehci_hcd *ehci)
 	if (ehci-&gt;debug)
 		dbgp_external_startup();
 
+	ehci-&gt;port_c_suspend = ehci-&gt;suspended_ports =
+			ehci-&gt;resuming_ports = 0;
 	return retval;
 }
 
@@ -939,6 +941,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 			 * like usb_port_resume() does.
 			 */
 			ehci-&gt;reset_done[i] = jiffies + msecs_to_jiffies(25);
+			set_bit(i, &amp;ehci-&gt;resuming_ports);
 			ehci_dbg (ehci, "port %d remote wakeup\n", i + 1);
 			mod_timer(&amp;hcd-&gt;rh_timer, ehci-&gt;reset_done[i]);
 		}
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 256fbd42e48c..38fe07623152 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -223,15 +223,10 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 	 * remote wakeup, we must fail the suspend.
 	 */
 	if (hcd-&gt;self.root_hub-&gt;do_remote_wakeup) {
-		port = HCS_N_PORTS(ehci-&gt;hcs_params);
-		while (port--) {
-			if (ehci-&gt;reset_done[port] != 0) {
-				spin_unlock_irq(&amp;ehci-&gt;lock);
-				ehci_dbg(ehci, "suspend failed because "
-						"port %d is resuming\n",
-						port + 1);
-				return -EBUSY;
-			}
+		if (ehci-&gt;resuming_ports) {
+			spin_unlock_irq(&amp;ehci-&gt;lock);
+			ehci_dbg(ehci, "suspend failed because a port is resuming\n");
+			return -EBUSY;
 		}
 	}
 
@@ -554,16 +549,12 @@ static int
 ehci_hub_status_data (struct usb_hcd *hcd, char *buf)
 {
 	struct ehci_hcd	*ehci = hcd_to_ehci (hcd);
-	u32		temp, status = 0;
+	u32		temp, status;
 	u32		mask;
 	int		ports, i, retval = 1;
 	unsigned long	flags;
 	u32		ppcd = 0;
 
-	/* if !USB_SUSPEND, root hub timers won't get shut down ... */
-	if (ehci-&gt;rh_state != EHCI_RH_RUNNING)
-		return 0;
-
 	/* init status to no-changes */
 	buf [0] = 0;
 	ports = HCS_N_PORTS (ehci-&gt;hcs_params);
@@ -572,6 +563,11 @@ ehci_hub_status_data (struct usb_hcd *hcd, char *buf)
 		retval++;
 	}
 
+	/* Inform the core about resumes-in-progress by returning
+	 * a non-zero value even if there are no status changes.
+	 */
+	status = ehci-&gt;resuming_ports;
+
 	/* Some boards (mostly VIA?) report bogus overcurrent indications,
 	 * causing massive log spam unless we completely ignore them.  It
 	 * may be relevant that VIA VT8235 controllers, where PORT_POWER is
@@ -846,6 +842,7 @@ static int ehci_hub_control (
 				ehci_writel(ehci,
 					temp &amp; ~(PORT_RWC_BITS | PORT_RESUME),
 					status_reg);
+				clear_bit(wIndex, &amp;ehci-&gt;resuming_ports);
 				retval = handshake(ehci, status_reg,
 					   PORT_RESUME, 0, 2000 /* 2msec */);
 				if (retval != 0) {
@@ -864,6 +861,7 @@ static int ehci_hub_control (
 					ehci-&gt;reset_done[wIndex])) {
 			status |= USB_PORT_STAT_C_RESET &lt;&lt; 16;
 			ehci-&gt;reset_done [wIndex] = 0;
+			clear_bit(wIndex, &amp;ehci-&gt;resuming_ports);
 
 			/* force reset to complete */
 			ehci_writel(ehci, temp &amp; ~(PORT_RWC_BITS | PORT_RESET),
@@ -884,8 +882,10 @@ static int ehci_hub_control (
 					ehci_readl(ehci, status_reg));
 		}
 
-		if (!(temp &amp; (PORT_RESUME|PORT_RESET)))
+		if (!(temp &amp; (PORT_RESUME|PORT_RESET))) {
 			ehci-&gt;reset_done[wIndex] = 0;
+			clear_bit(wIndex, &amp;ehci-&gt;resuming_ports);
+		}
 
 		/* transfer dedicated ports to the companion hc */
 		if ((temp &amp; PORT_CONNECT) &amp;&amp;
@@ -920,6 +920,7 @@ static int ehci_hub_control (
 			status |= USB_PORT_STAT_SUSPEND;
 		} else if (test_bit(wIndex, &amp;ehci-&gt;suspended_ports)) {
 			clear_bit(wIndex, &amp;ehci-&gt;suspended_ports);
+			clear_bit(wIndex, &amp;ehci-&gt;resuming_ports);
 			ehci-&gt;reset_done[wIndex] = 0;
 			if (temp &amp; PORT_PE)
 				set_bit(wIndex, &amp;ehci-&gt;port_c_suspend);
diff --git a/drivers/usb/host/ehci-tegra.c b/drivers/usb/host/ehci-tegra.c
index 3de48a2d7955..73544bd440bd 100644
--- a/drivers/usb/host/ehci-tegra.c
+++ b/drivers/usb/host/ehci-tegra.c
@@ -224,6 +224,7 @@ static int tegra_ehci_hub_control(
 		temp &amp;= ~(PORT_RWC_BITS | PORT_WAKE_BITS);
 		/* start resume signalling */
 		ehci_writel(ehci, temp | PORT_RESUME, status_reg);
+		set_bit(wIndex-1, &amp;ehci-&gt;resuming_ports);
 
 		spin_unlock_irqrestore(&amp;ehci-&gt;lock, flags);
 		msleep(20);
@@ -236,6 +237,7 @@ static int tegra_ehci_hub_control(
 			pr_err("%s: timeout waiting for SUSPEND\n", __func__);
 
 		ehci-&gt;reset_done[wIndex-1] = 0;
+		clear_bit(wIndex-1, &amp;ehci-&gt;resuming_ports);
 
 		tegra-&gt;port_resuming = 1;
 		goto done;
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 8f9acbc96fde..2694ed6558d2 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -117,6 +117,8 @@ struct ehci_hcd {			/* one per controller */
 			the change-suspend feature turned on */
 	unsigned long		suspended_ports;	/* which ports are
 			suspended */
+	unsigned long		resuming_ports;		/* which ports have
+			started to resume */
 
 	/* per-HC memory pools (could be per-bus, but ...) */
 	struct dma_pool		*qh_pool;	/* qh per active urb */</pre><hr><pre>commit 879d38e6bc36d73b0ac40ec9b0d839fda9fa8b1a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Apr 3 15:24:18 2012 -0400

    USB: fix race between root-hub suspend and remote wakeup
    
    This patch (as1533) fixes a race between root-hub suspend and remote
    wakeup.  If a wakeup event occurs while a root hub is suspending, it
    might not cause the suspend to fail.  Although the host controller
    drivers check for pending wakeup events at the start of their
    bus_suspend routines, they generally do not check for wakeup events
    while the routines are running.
    
    In addition, if a wakeup event occurs any time after khubd is frozen
    and before the root hub is fully suspended, it might not cause a
    system sleep transition to fail.  For example, the host controller
    drivers do not fail root-hub suspends when a connect-change event is
    pending.
    
    To fix both these issues, this patch causes hcd_bus_suspend() to query
    the controller driver's hub_status_data method after a root hub is
    suspended, if the root hub is enabled for wakeup.  Any pending status
    changes will count as wakeup events, causing the root hub to be
    resumed and the overall suspend to fail with -EBUSY.
    
    A significant point is that not all events are reflected immediately
    in the status bits.  Both EHCI and UHCI controllers notify the CPU
    when remote wakeup begins on a port, but the port's suspend-change
    status bit doesn't get set until after the port has completed the
    transition out of the suspend state, some 25 milliseconds later.
    Consequently, the patch will interpret any nonzero return value from
    hub_status_data as indicating a pending event, even if none of the
    status bits are set in the data buffer.  Follow-up patches make the
    necessary changes to ehci-hcd and uhci-hcd.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Sarah Sharp &lt;sarah.a.sharp@linux.intel.com&gt;
    CC: Chen Peter-B29397 &lt;B29397@freescale.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 9d7fc9a39933..140d3e11f212 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1978,6 +1978,18 @@ int hcd_bus_suspend(struct usb_device *rhdev, pm_message_t msg)
 	if (status == 0) {
 		usb_set_device_state(rhdev, USB_STATE_SUSPENDED);
 		hcd-&gt;state = HC_STATE_SUSPENDED;
+
+		/* Did we race with a root-hub wakeup event? */
+		if (rhdev-&gt;do_remote_wakeup) {
+			char	buffer[6];
+
+			status = hcd-&gt;driver-&gt;hub_status_data(hcd, buffer);
+			if (status != 0) {
+				dev_dbg(&amp;rhdev-&gt;dev, "suspend raced with wakeup event\n");
+				hcd_bus_resume(rhdev, PMSG_AUTO_RESUME);
+				status = -EBUSY;
+			}
+		}
 	} else {
 		spin_lock_irq(&amp;hcd_root_hub_lock);
 		if (!HCD_DEAD(hcd)) {</pre><hr><pre>commit cd4376e23a59a2adf3084cb5f4a523e6d5fd4e49
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Mar 28 15:56:17 2012 -0400

    USB: don't ignore suspend errors for root hubs
    
    This patch (as1532) fixes a mistake in the USB suspend code.  When the
    system is going to sleep, we should ignore errors in powering down USB
    devices, because they don't really matter.  The devices will go to low
    power anyway when the entire USB bus gets suspended (except for
    SuperSpeed devices; maybe they will need special treatment later).
    
    However we should not ignore errors in suspending root hubs,
    especially if the error indicates that the suspend raced with a wakeup
    request.  Doing so might leave the bus powered on while the system was
    supposed to be asleep, or it might cause the suspend of the root hub's
    parent controller device to fail, or it might cause a wakeup request
    to be ignored.
    
    The patch fixes the problem by ignoring errors only when the device in
    question is not a root hub.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Chen Peter &lt;B29397@freescale.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Tested-by: Chen Peter &lt;peter.chen@freescale.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index f8e2d6d52e5c..9a56635dc19c 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -1189,8 +1189,13 @@ static int usb_suspend_both(struct usb_device *udev, pm_message_t msg)
 	if (status == 0) {
 		status = usb_suspend_device(udev, msg);
 
-		/* Again, ignore errors during system sleep transitions */
-		if (!PMSG_IS_AUTO(msg))
+		/*
+		 * Ignore errors from non-root-hub devices during
+		 * system sleep transitions.  For the most part,
+		 * these devices should go to low power anyway when
+		 * the entire bus is suspended.
+		 */
+		if (udev-&gt;parent &amp;&amp; !PMSG_IS_AUTO(msg))
 			status = 0;
 	}
 </pre><hr><pre>commit 891a3b1fddb24b4b53426685bd0390bb74c9b5b3
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Mar 28 16:10:49 2012 -0400

    USB: fix bug in serial driver unregistration
    
    This patch (as1536) fixes a bug in the USB serial core.  Unloading and
    reloading a serial driver while a serial device is plugged in causes
    errors because of the code in usb_serial_disconnect() that tries to
    make sure the port_remove method is called.  With the new order of
    driver registration introduced in the 3.4 kernel, this is definitely
    not the right thing to do (if indeed it ever was).
    
    The patch removes that whole section code, along with the mechanism
    for keeping track of each port's registration state, which is no
    longer needed.  The driver core can handle all that stuff for us.
    
    Note: This has been tested only with one or two USB serial drivers.
    In theory, other drivers might still run into trouble.  But if they
    do, it will be the fault of the drivers, not of this patch -- that is,
    the drivers will need to be fixed.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Johan Hovold &lt;jhovold@gmail.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/serial/bus.c b/drivers/usb/serial/bus.c
index 7f547dc3a590..ed8adb052ca7 100644
--- a/drivers/usb/serial/bus.c
+++ b/drivers/usb/serial/bus.c
@@ -60,8 +60,6 @@ static int usb_serial_device_probe(struct device *dev)
 		retval = -ENODEV;
 		goto exit;
 	}
-	if (port-&gt;dev_state != PORT_REGISTERING)
-		goto exit;
 
 	driver = port-&gt;serial-&gt;type;
 	if (driver-&gt;port_probe) {
@@ -98,9 +96,6 @@ static int usb_serial_device_remove(struct device *dev)
 	if (!port)
 		return -ENODEV;
 
-	if (port-&gt;dev_state != PORT_UNREGISTERING)
-		return retval;
-
 	device_remove_file(&amp;port-&gt;dev, &amp;dev_attr_port_number);
 
 	driver = port-&gt;serial-&gt;type;
diff --git a/drivers/usb/serial/usb-serial.c b/drivers/usb/serial/usb-serial.c
index 69230f01056a..5413bd500781 100644
--- a/drivers/usb/serial/usb-serial.c
+++ b/drivers/usb/serial/usb-serial.c
@@ -1070,17 +1070,12 @@ int usb_serial_probe(struct usb_interface *interface,
 		port = serial-&gt;port[i];
 		dev_set_name(&amp;port-&gt;dev, "ttyUSB%d", port-&gt;number);
 		dbg ("%s - registering %s", __func__, dev_name(&amp;port-&gt;dev));
-		port-&gt;dev_state = PORT_REGISTERING;
 		device_enable_async_suspend(&amp;port-&gt;dev);
 
 		retval = device_add(&amp;port-&gt;dev);
-		if (retval) {
+		if (retval)
 			dev_err(&amp;port-&gt;dev, "Error registering port device, "
 				"continuing\n");
-			port-&gt;dev_state = PORT_UNREGISTERED;
-		} else {
-			port-&gt;dev_state = PORT_REGISTERED;
-		}
 	}
 
 	usb_serial_console_init(debug, minor);
@@ -1124,22 +1119,8 @@ void usb_serial_disconnect(struct usb_interface *interface)
 			}
 			kill_traffic(port);
 			cancel_work_sync(&amp;port-&gt;work);
-			if (port-&gt;dev_state == PORT_REGISTERED) {
-
-				/* Make sure the port is bound so that the
-				 * driver's port_remove method is called.
-				 */
-				if (!port-&gt;dev.driver) {
-					int rc;
-
-					port-&gt;dev.driver =
-							&amp;serial-&gt;type-&gt;driver;
-					rc = device_bind_driver(&amp;port-&gt;dev);
-				}
-				port-&gt;dev_state = PORT_UNREGISTERING;
+			if (device_is_registered(&amp;port-&gt;dev))
 				device_del(&amp;port-&gt;dev);
-				port-&gt;dev_state = PORT_UNREGISTERED;
-			}
 		}
 	}
 	serial-&gt;type-&gt;disconnect(serial);
diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index fbb666b1b670..474283888233 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -28,13 +28,6 @@
 /* parity check flag */
 #define RELEVANT_IFLAG(iflag)	(iflag &amp; (IGNBRK|BRKINT|IGNPAR|PARMRK|INPCK))
 
-enum port_dev_state {
-	PORT_UNREGISTERED,
-	PORT_REGISTERING,
-	PORT_REGISTERED,
-	PORT_UNREGISTERING,
-};
-
 /* USB serial flags */
 #define USB_SERIAL_WRITE_BUSY	0
 
@@ -124,7 +117,6 @@ struct usb_serial_port {
 	char			throttle_req;
 	unsigned long		sysrq; /* sysrq timeout */
 	struct device		dev;
-	enum port_dev_state	dev_state;
 };
 #define to_usb_serial_port(d) container_of(d, struct usb_serial_port, dev)
 </pre><hr><pre>commit da8bfb090c2b30af9f3879443355f7eb1d0fe10a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Mar 28 16:13:28 2012 -0400

    USB documentation: explain lifetime rules for unlinking URBs
    
    This patch (as1534c) updates the documentation for usb_unlink_urb and
    related functions.  It explains that the caller must prevent the URB
    being unlinked from getting deallocated while the unlink is taking
    place.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Ming Lei &lt;tom.leiming@gmail.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/Documentation/usb/URB.txt b/Documentation/usb/URB.txt
index 8ffce746d496..00d2c644068e 100644
--- a/Documentation/usb/URB.txt
+++ b/Documentation/usb/URB.txt
@@ -168,6 +168,28 @@ that if the completion handler or anyone else tries to resubmit it
 they will get a -EPERM error.  Thus you can be sure that when
 usb_kill_urb() returns, the URB is totally idle.
 
+There is a lifetime issue to consider.  An URB may complete at any
+time, and the completion handler may free the URB.  If this happens
+while usb_unlink_urb or usb_kill_urb is running, it will cause a
+memory-access violation.  The driver is responsible for avoiding this,
+which often means some sort of lock will be needed to prevent the URB
+from being deallocated while it is still in use.
+
+On the other hand, since usb_unlink_urb may end up calling the
+completion handler, the handler must not take any lock that is held
+when usb_unlink_urb is invoked.  The general solution to this problem
+is to increment the URB's reference count while holding the lock, then
+drop the lock and call usb_unlink_urb or usb_kill_urb, and then
+decrement the URB's reference count.  You increment the reference
+count by calling
+
+	struct urb *usb_get_urb(struct urb *urb)
+
+(ignore the return value; it is the same as the argument) and
+decrement the reference count by calling usb_free_urb.  Of course,
+none of this is necessary if there's no danger of the URB being freed
+by the completion handler.
+
 
 1.7. What about the completion handler?
 
diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 7239a73c1b8c..cd9b3a2cd8a7 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -539,6 +539,10 @@ EXPORT_SYMBOL_GPL(usb_submit_urb);
  * never submitted, or it was unlinked before, or the hardware is already
  * finished with it), even if the completion handler has not yet run.
  *
+ * The URB must not be deallocated while this routine is running.  In
+ * particular, when a driver calls this routine, it must insure that the
+ * completion handler cannot deallocate the URB.
+ *
  * Unlinking and Endpoint Queues:
  *
  * [The behaviors and guarantees described below do not apply to virtual
@@ -603,6 +607,10 @@ EXPORT_SYMBOL_GPL(usb_unlink_urb);
  * with error -EPERM.  Thus even if the URB's completion handler always
  * tries to resubmit, it will not succeed and the URB will become idle.
  *
+ * The URB must not be deallocated while this routine is running.  In
+ * particular, when a driver calls this routine, it must insure that the
+ * completion handler cannot deallocate the URB.
+ *
  * This routine may not be used in an interrupt context (such as a bottom
  * half or a completion handler), or when holding a spinlock, or in other
  * situations where the caller can't schedule().
@@ -640,6 +648,10 @@ EXPORT_SYMBOL_GPL(usb_kill_urb);
  * with error -EPERM.  Thus even if the URB's completion handler always
  * tries to resubmit, it will not succeed and the URB will become idle.
  *
+ * The URB must not be deallocated while this routine is running.  In
+ * particular, when a driver calls this routine, it must insure that the
+ * completion handler cannot deallocate the URB.
+ *
  * This routine may not be used in an interrupt context (such as a bottom
  * half or a completion handler), or when holding a spinlock, or in other
  * situations where the caller can't schedule().</pre><hr><pre>commit bcf398537630bf20b4dbe59ba855b69f404c93cf
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Mar 22 11:00:21 2012 -0400

    USB: don't clear urb-&gt;dev in scatter-gather library
    
    This patch (as1517b) fixes an error in the USB scatter-gather library.
    The library code uses urb-&gt;dev to determine whether or nor an URB is
    currently active; the completion handler sets urb-&gt;dev to NULL.
    However the core unlinking routines need to use urb-&gt;dev.  Since
    unlinking always racing with completion, the completion handler must
    not clear urb-&gt;dev -- it can lead to invalid memory accesses when a
    transfer has to be cancelled.
    
    This patch fixes the problem by getting rid of the lines that clear
    urb-&gt;dev after urb has been submitted.  As a result we may end up
    trying to unlink an URB that failed in submission or that has already
    completed, so an extra check is added after each unlink to avoid
    printing an error message when this happens.  The checks are updated
    in both sg_complete() and sg_cancel(), and the second is updated to
    match the first (currently it prints out unnecessary warning messages
    if a device is unplugged while a transfer is in progress).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Illia Zaitsev &lt;I.Zaitsev@adbglobal.com&gt;
    CC: Ming Lei &lt;tom.leiming@gmail.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index b3bdfede45e6..aed3e07942d4 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -308,7 +308,8 @@ static void sg_complete(struct urb *urb)
 				retval = usb_unlink_urb(io-&gt;urbs [i]);
 				if (retval != -EINPROGRESS &amp;&amp;
 				    retval != -ENODEV &amp;&amp;
-				    retval != -EBUSY)
+				    retval != -EBUSY &amp;&amp;
+				    retval != -EIDRM)
 					dev_err(&amp;io-&gt;dev-&gt;dev,
 						"%s, unlink --&gt; %d\n",
 						__func__, retval);
@@ -317,7 +318,6 @@ static void sg_complete(struct urb *urb)
 		}
 		spin_lock(&amp;io-&gt;lock);
 	}
-	urb-&gt;dev = NULL;
 
 	/* on the last completion, signal usb_sg_wait() */
 	io-&gt;bytes += urb-&gt;actual_length;
@@ -524,7 +524,6 @@ void usb_sg_wait(struct usb_sg_request *io)
 		case -ENXIO:	/* hc didn't queue this one */
 		case -EAGAIN:
 		case -ENOMEM:
-			io-&gt;urbs[i]-&gt;dev = NULL;
 			retval = 0;
 			yield();
 			break;
@@ -542,7 +541,6 @@ void usb_sg_wait(struct usb_sg_request *io)
 
 			/* fail any uncompleted urbs */
 		default:
-			io-&gt;urbs[i]-&gt;dev = NULL;
 			io-&gt;urbs[i]-&gt;status = retval;
 			dev_dbg(&amp;io-&gt;dev-&gt;dev, "%s, submit --&gt; %d\n",
 				__func__, retval);
@@ -593,7 +591,10 @@ void usb_sg_cancel(struct usb_sg_request *io)
 			if (!io-&gt;urbs [i]-&gt;dev)
 				continue;
 			retval = usb_unlink_urb(io-&gt;urbs [i]);
-			if (retval != -EINPROGRESS &amp;&amp; retval != -EBUSY)
+			if (retval != -EINPROGRESS
+					&amp;&amp; retval != -ENODEV
+					&amp;&amp; retval != -EBUSY
+					&amp;&amp; retval != -EIDRM)
 				dev_warn(&amp;io-&gt;dev-&gt;dev, "%s, unlink --&gt; %d\n",
 					__func__, retval);
 		}</pre><hr><pre>commit f2791d733a2f06997b573d1a3cfde21e6f529826
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Mar 26 22:46:52 2012 +0200

    PM / Runtime: don't forget to wake up waitqueue on failure
    
    This patch (as1535) fixes a bug in the runtime PM core.  When a
    runtime suspend attempt completes, whether successfully or not, the
    device's power.wait_queue is supposed to be signalled.  But this
    doesn't happen in the failure pathway of rpm_suspend() when another
    autosuspend attempt is rescheduled.  As a result, a task can get stuck
    indefinitely on the wait queue (I have seen this happen in testing).
    
    The patch fixes the problem by moving the wake_up_all() call up near
    the start of the failure code.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;

diff --git a/drivers/base/power/runtime.c b/drivers/base/power/runtime.c
index 541f821d4ea6..bd0f3949bcf9 100644
--- a/drivers/base/power/runtime.c
+++ b/drivers/base/power/runtime.c
@@ -532,6 +532,8 @@ static int rpm_suspend(struct device *dev, int rpmflags)
 	dev-&gt;power.suspend_time = ktime_set(0, 0);
 	dev-&gt;power.max_time_suspended_ns = -1;
 	dev-&gt;power.deferred_resume = false;
+	wake_up_all(&amp;dev-&gt;power.wait_queue);
+
 	if (retval == -EAGAIN || retval == -EBUSY) {
 		dev-&gt;power.runtime_error = 0;
 
@@ -547,7 +549,6 @@ static int rpm_suspend(struct device *dev, int rpmflags)
 	} else {
 		pm_runtime_cancel_pending(dev);
 	}
-	wake_up_all(&amp;dev-&gt;power.wait_queue);
 	goto out;
 }
 </pre><hr><pre>commit 62d3c5439c534b0e6c653fc63e6d8c67be3a57b1
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Mar 2 10:51:00 2012 +0100

    Block: use a freezable workqueue for disk-event polling
    
    This patch (as1519) fixes a bug in the block layer's disk-events
    polling.  The polling is done by a work routine queued on the
    system_nrt_wq workqueue.  Since that workqueue isn't freezable, the
    polling continues even in the middle of a system sleep transition.
    
    Obviously, polling a suspended drive for media changes and such isn't
    a good thing to do; in the case of USB mass-storage devices it can
    lead to real problems requiring device resets and even re-enumeration.
    
    The patch fixes things by creating a new system-wide, non-reentrant,
    freezable workqueue and using it for disk-events polling.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@kernel.org&gt;
    Acked-by: Tejun Heo &lt;tj@kernel.org&gt;
    Acked-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;
    Signed-off-by: Jens Axboe &lt;axboe@kernel.dk&gt;

diff --git a/block/genhd.c b/block/genhd.c
index b26c4085590d..df9816ede75b 100644
--- a/block/genhd.c
+++ b/block/genhd.c
@@ -1478,9 +1478,9 @@ static void __disk_unblock_events(struct gendisk *disk, bool check_now)
 	intv = disk_events_poll_jiffies(disk);
 	set_timer_slack(&amp;ev-&gt;dwork.timer, intv / 4);
 	if (check_now)
-		queue_delayed_work(system_nrt_wq, &amp;ev-&gt;dwork, 0);
+		queue_delayed_work(system_nrt_freezable_wq, &amp;ev-&gt;dwork, 0);
 	else if (intv)
-		queue_delayed_work(system_nrt_wq, &amp;ev-&gt;dwork, intv);
+		queue_delayed_work(system_nrt_freezable_wq, &amp;ev-&gt;dwork, intv);
 out_unlock:
 	spin_unlock_irqrestore(&amp;ev-&gt;lock, flags);
 }
@@ -1524,7 +1524,7 @@ void disk_flush_events(struct gendisk *disk, unsigned int mask)
 	ev-&gt;clearing |= mask;
 	if (!ev-&gt;block) {
 		cancel_delayed_work(&amp;ev-&gt;dwork);
-		queue_delayed_work(system_nrt_wq, &amp;ev-&gt;dwork, 0);
+		queue_delayed_work(system_nrt_freezable_wq, &amp;ev-&gt;dwork, 0);
 	}
 	spin_unlock_irq(&amp;ev-&gt;lock);
 }
@@ -1561,7 +1561,7 @@ unsigned int disk_clear_events(struct gendisk *disk, unsigned int mask)
 
 	/* uncondtionally schedule event check and wait for it to finish */
 	disk_block_events(disk);
-	queue_delayed_work(system_nrt_wq, &amp;ev-&gt;dwork, 0);
+	queue_delayed_work(system_nrt_freezable_wq, &amp;ev-&gt;dwork, 0);
 	flush_delayed_work(&amp;ev-&gt;dwork);
 	__disk_unblock_events(disk, false);
 
@@ -1598,7 +1598,7 @@ static void disk_events_workfn(struct work_struct *work)
 
 	intv = disk_events_poll_jiffies(disk);
 	if (!ev-&gt;block &amp;&amp; intv)
-		queue_delayed_work(system_nrt_wq, &amp;ev-&gt;dwork, intv);
+		queue_delayed_work(system_nrt_freezable_wq, &amp;ev-&gt;dwork, intv);
 
 	spin_unlock_irq(&amp;ev-&gt;lock);
 
diff --git a/include/linux/workqueue.h b/include/linux/workqueue.h
index eb8b9f15f2e0..af155450cabb 100644
--- a/include/linux/workqueue.h
+++ b/include/linux/workqueue.h
@@ -289,12 +289,16 @@ enum {
  *
  * system_freezable_wq is equivalent to system_wq except that it's
  * freezable.
+ *
+ * system_nrt_freezable_wq is equivalent to system_nrt_wq except that
+ * it's freezable.
  */
 extern struct workqueue_struct *system_wq;
 extern struct workqueue_struct *system_long_wq;
 extern struct workqueue_struct *system_nrt_wq;
 extern struct workqueue_struct *system_unbound_wq;
 extern struct workqueue_struct *system_freezable_wq;
+extern struct workqueue_struct *system_nrt_freezable_wq;
 
 extern struct workqueue_struct *
 __alloc_workqueue_key(const char *fmt, unsigned int flags, int max_active,
diff --git a/kernel/workqueue.c b/kernel/workqueue.c
index bec7b5b53e03..f2c5638bb5ab 100644
--- a/kernel/workqueue.c
+++ b/kernel/workqueue.c
@@ -253,11 +253,13 @@ struct workqueue_struct *system_long_wq __read_mostly;
 struct workqueue_struct *system_nrt_wq __read_mostly;
 struct workqueue_struct *system_unbound_wq __read_mostly;
 struct workqueue_struct *system_freezable_wq __read_mostly;
+struct workqueue_struct *system_nrt_freezable_wq __read_mostly;
 EXPORT_SYMBOL_GPL(system_wq);
 EXPORT_SYMBOL_GPL(system_long_wq);
 EXPORT_SYMBOL_GPL(system_nrt_wq);
 EXPORT_SYMBOL_GPL(system_unbound_wq);
 EXPORT_SYMBOL_GPL(system_freezable_wq);
+EXPORT_SYMBOL_GPL(system_nrt_freezable_wq);
 
 #define CREATE_TRACE_POINTS
 #include &lt;trace/events/workqueue.h&gt;
@@ -3833,8 +3835,11 @@ static int __init init_workqueues(void)
 					    WQ_UNBOUND_MAX_ACTIVE);
 	system_freezable_wq = alloc_workqueue("events_freezable",
 					      WQ_FREEZABLE, 0);
+	system_nrt_freezable_wq = alloc_workqueue("events_nrt_freezable",
+			WQ_NON_REENTRANT | WQ_FREEZABLE, 0);
 	BUG_ON(!system_wq || !system_long_wq || !system_nrt_wq ||
-	       !system_unbound_wq || !system_freezable_wq);
+	       !system_unbound_wq || !system_freezable_wq ||
+		!system_nrt_freezable_wq);
 	return 0;
 }
 early_initcall(init_workqueues);</pre><hr><pre>commit 37891abc8464637964a26ae4b61d307fef831f80
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Feb 27 11:23:45 2012 -0500

    HID: usbhid: Add NOGET quirk for the AIREN Slim+ keyboard
    
    This patch (as1531) adds a NOGET quirk for the Slim+ keyboard marketed
    by AIREN.  This keyboard seems to have a lot of bugs; NOGET works
    around only one of them.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: okias &lt;d.okias@gmail.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/hid-ids.h b/drivers/hid/hid-ids.h
index b8574cddd953..63552e30d0c3 100644
--- a/drivers/hid/hid-ids.h
+++ b/drivers/hid/hid-ids.h
@@ -59,6 +59,9 @@
 #define USB_VENDOR_ID_AIRCABLE		0x16CA
 #define USB_DEVICE_ID_AIRCABLE1		0x1502
 
+#define USB_VENDOR_ID_AIREN		0x1a2c
+#define USB_DEVICE_ID_AIREN_SLIMPLUS	0x0002
+
 #define USB_VENDOR_ID_ALCOR		0x058f
 #define USB_DEVICE_ID_ALCOR_USBRS232	0x9720
 
diff --git a/drivers/hid/usbhid/hid-quirks.c b/drivers/hid/usbhid/hid-quirks.c
index c831af937481..57d4e1e1df48 100644
--- a/drivers/hid/usbhid/hid-quirks.c
+++ b/drivers/hid/usbhid/hid-quirks.c
@@ -54,6 +54,7 @@ static const struct hid_blacklist {
 	{ USB_VENDOR_ID_PLAYDOTCOM, USB_DEVICE_ID_PLAYDOTCOM_EMS_USBII, HID_QUIRK_MULTI_INPUT },
 	{ USB_VENDOR_ID_TOUCHPACK, USB_DEVICE_ID_TOUCHPACK_RTS, HID_QUIRK_MULTI_INPUT },
 
+	{ USB_VENDOR_ID_AIREN, USB_DEVICE_ID_AIREN_SLIMPLUS, HID_QUIRK_NOGET },
 	{ USB_VENDOR_ID_ATEN, USB_DEVICE_ID_ATEN_UC100KM, HID_QUIRK_NOGET },
 	{ USB_VENDOR_ID_ATEN, USB_DEVICE_ID_ATEN_CS124U, HID_QUIRK_NOGET },
 	{ USB_VENDOR_ID_ATEN, USB_DEVICE_ID_ATEN_2PORTKVM, HID_QUIRK_NOGET },</pre>
    <div class="pagination">
        <a href='2_49.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><span>[50]</span><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_51.html'>Next&gt;&gt;</a>
    <div>
</body>
