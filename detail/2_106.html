<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_105.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><span>[106]</span><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_107.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit cfa59dab27d1b282886e7772a8f9548236883892
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jun 21 16:25:35 2007 -0400

    USB: Don't resume root hub if the controller is suspended
    
    Root hubs can't be resumed if their parent controller device is still
    suspended.  This patch (as925) adds a check for that condition in
    hcd_bus_resume() and prevents it from being treated as a fatal
    controller failure.
    
    ehci-hcd is updated to add the corresponding test.  Unnecessary
    debugging messages are removed from uhci-hcd and dummy-hcd.  The
    error return code from dummy-hcd is changed to -ESHUTDOWN, the same as
    the others.  ohci-hcd doesn't need any changes.
    
    Suspend handling in the non-PCI host drivers is somewhat hit-and-miss.
    This patch shouldn't have any effect on them.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 5254c50086a8..963520fbef90 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1291,6 +1291,7 @@ int hcd_bus_resume(struct usb_device *rhdev)
 {
 	struct usb_hcd	*hcd = container_of(rhdev-&gt;bus, struct usb_hcd, self);
 	int		status;
+	int		old_state = hcd-&gt;state;
 
 	dev_dbg(&amp;rhdev-&gt;dev, "usb %s%s\n",
 			rhdev-&gt;auto_pm ? "auto-" : "", "resume");
@@ -1309,9 +1310,11 @@ int hcd_bus_resume(struct usb_device *rhdev)
 				: USB_STATE_ADDRESS);
 		hcd-&gt;state = HC_STATE_RUNNING;
 	} else {
+		hcd-&gt;state = old_state;
 		dev_dbg(&amp;rhdev-&gt;dev, "bus %s fail, err %d\n",
 				"resume", status);
-		usb_hc_died(hcd);
+		if (status != -ESHUTDOWN)
+			usb_hc_died(hcd);
 	}
 	return status;
 }
diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index fcb5526cb085..9040b50d6425 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -1784,8 +1784,7 @@ static int dummy_bus_resume (struct usb_hcd *hcd)
 
 	spin_lock_irq (&amp;dum-&gt;lock);
 	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags)) {
-		dev_warn (&amp;hcd-&gt;self.root_hub-&gt;dev, "HC isn't running!\n");
-		rc = -ENODEV;
+		rc = -ESHUTDOWN;
 	} else {
 		dum-&gt;rh_state = DUMMY_RH_RUNNING;
 		set_link_state (dum);
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 71aeca019e88..0dcb4164dc83 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -199,6 +199,10 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 	if (time_before (jiffies, ehci-&gt;next_statechange))
 		msleep(5);
 	spin_lock_irq (&amp;ehci-&gt;lock);
+	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags)) {
+		spin_unlock_irq(&amp;ehci-&gt;lock);
+		return -ESHUTDOWN;
+	}
 
 	/* Ideally and we've got a real resume here, and no port's power
 	 * was lost.  (For PCI, that means Vaux was maintained.)  But we
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index d22da26ff167..76c555a67dac 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -730,10 +730,9 @@ static int uhci_rh_resume(struct usb_hcd *hcd)
 	int rc = 0;
 
 	spin_lock_irq(&amp;uhci-&gt;lock);
-	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags)) {
-		dev_warn(&amp;hcd-&gt;self.root_hub-&gt;dev, "HC isn't running!\n");
+	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags))
 		rc = -ESHUTDOWN;
-	} else if (!uhci-&gt;dead)
+	else if (!uhci-&gt;dead)
 		wakeup_rh(uhci);
 	spin_unlock_irq(&amp;uhci-&gt;lock);
 	return rc;</pre><hr><pre>commit e7e6da9eb189dfa221e3bf9c21d58f02adc8983c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jun 21 16:25:17 2007 -0400

    USB: Remove usages of dev-&gt;power.power_state
    
    This patch (as922) removes all but one of the remaining vestiges of
    dev-&gt;power.power_state from usbcore.  The only usage left must remain
    until the deprecated "power/state" sysfs attribute is gone.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 3cd9af2638fc..a3aed8d87ddc 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -1196,11 +1196,7 @@ static int usb_resume_both(struct usb_device *udev)
 			/* We can't progagate beyond the USB subsystem,
 			 * so if a root hub's controller is suspended
 			 * then we're stuck. */
-			if (udev-&gt;dev.parent-&gt;power.power_state.event !=
-					PM_EVENT_ON)
-				status = -EHOSTUNREACH;
-			else
-				status = usb_resume_device(udev);
+			status = usb_resume_device(udev);
  		}
 	} else {
 
diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 3df538539b48..5254c50086a8 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -965,19 +965,9 @@ int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
 	else switch (hcd-&gt;state) {
 	case HC_STATE_RUNNING:
 	case HC_STATE_RESUMING:
-doit:
 		list_add_tail (&amp;urb-&gt;urb_list, &amp;ep-&gt;urb_list);
 		status = 0;
 		break;
-	case HC_STATE_SUSPENDED:
-		/* HC upstream links (register access, wakeup signaling) can work
-		 * even when the downstream links (and DMA etc) are quiesced; let
-		 * usbcore talk to the root hub.
-		 */
-		if (hcd-&gt;self.controller-&gt;power.power_state.event == PM_EVENT_ON
-				&amp;&amp; urb-&gt;dev-&gt;parent == NULL)
-			goto doit;
-		/* FALL THROUGH */
 	default:
 		status = -ESHUTDOWN;
 		break;</pre><hr><pre>commit 60aac1ec26b960fe77bf600457bc6c06f8aa7db4
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jun 8 15:25:02 2007 -0400

    USB: Handle bogus low-speed Bulk endpoints
    
    A noticeable number of low-speed devices mistakenly include
    descriptors for Bulk endpoints, which is forbidden by the USB spec.
    In an attempt to make such devices more usable, this patch (as924)
    converts the descriptors to Interrupt with an interval of 1 ms.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c
index dd3482328ad2..9152e12dcf71 100644
--- a/drivers/usb/core/config.c
+++ b/drivers/usb/core/config.c
@@ -124,6 +124,21 @@ static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,
 		endpoint-&gt;desc.bInterval = n;
 	}
 
+	/* Some buggy low-speed devices have Bulk endpoints, which is
+	 * explicitly forbidden by the USB spec.  In an attempt to make
+	 * them usable, we will try treating them as Interrupt endpoints.
+	 */
+	if (to_usb_device(ddev)-&gt;speed == USB_SPEED_LOW &amp;&amp;
+			usb_endpoint_xfer_bulk(d)) {
+		dev_warn(ddev, "config %d interface %d altsetting %d "
+		    "endpoint 0x%X is Bulk; changing to Interrupt\n",
+		    cfgno, inum, asnum, d-&gt;bEndpointAddress);
+		endpoint-&gt;desc.bmAttributes = USB_ENDPOINT_XFER_INT;
+		endpoint-&gt;desc.bInterval = 1;
+		if (le16_to_cpu(endpoint-&gt;desc.wMaxPacketSize) &gt; 8)
+			endpoint-&gt;desc.wMaxPacketSize = cpu_to_le16(8);
+	}
+
 	/* Skip over any Class Specific or Vendor Specific descriptors;
 	 * find the next endpoint or interface descriptor */
 	endpoint-&gt;extra = buffer;</pre><hr><pre>commit ed76cacbea08ebfdb678c8687f98237cb7c67bb6
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jun 7 17:12:25 2007 -0400

    USB: usb-storage: use kthread_stop() for the control thread
    
    This patch (as923) makes usb-storage's control thread use
    kthread_should_stop()/kthread_stop().  The scanning thread can't be
    similarly converted until the core kthread implementation allows
    threads to call do_exit().
    
    The advantage of this change is that we can now be certain the control
    thread has terminated before storage_disconnect() returns.  This will
    simplify the locking requirements when autosuspend support is added.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Matthew Dharm &lt;mdharm-usb@one-eyed-alien.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/usb.c b/drivers/usb/storage/usb.c
index 00521f1d6a6b..cf3fc91234e7 100644
--- a/drivers/usb/storage/usb.c
+++ b/drivers/usb/storage/usb.c
@@ -425,23 +425,15 @@ static int usb_stor_control_thread(void * __us)
 		mutex_unlock(&amp;us-&gt;dev_mutex);
 	} /* for (;;) */
 
-	scsi_host_put(host);
-
-	/* notify the exit routine that we're actually exiting now 
-	 *
-	 * complete()/wait_for_completion() is similar to up()/down(),
-	 * except that complete() is safe in the case where the structure
-	 * is getting deleted in a parallel mode of execution (i.e. just
-	 * after the down() -- that's necessary for the thread-shutdown
-	 * case.
-	 *
-	 * complete_and_exit() goes even further than this -- it is safe in
-	 * the case that the thread of the caller is going away (not just
-	 * the structure) -- this is necessary for the module-remove case.
-	 * This is important in preemption kernels, which transfer the flow
-	 * of execution immediately upon a complete().
-	 */
-	complete_and_exit(&amp;threads_gone, 0);
+	/* Wait until we are told to stop */
+	for (;;) {
+		set_current_state(TASK_INTERRUPTIBLE);
+		if (kthread_should_stop())
+			break;
+		schedule();
+	}
+	__set_current_state(TASK_RUNNING);
+	return 0;
 }	
 
 /***********************************************************************
@@ -809,19 +801,13 @@ static int usb_stor_acquire_resources(struct us_data *us)
 	}
 
 	/* Start up our control thread */
-	th = kthread_create(usb_stor_control_thread, us, "usb-storage");
+	th = kthread_run(usb_stor_control_thread, us, "usb-storage");
 	if (IS_ERR(th)) {
 		printk(KERN_WARNING USB_STORAGE 
 		       "Unable to start control thread\n");
 		return PTR_ERR(th);
 	}
-
-	/* Take a reference to the host for the control thread and
-	 * count it among all the threads we have launched.  Then
-	 * start it up. */
-	scsi_host_get(us_to_host(us));
-	atomic_inc(&amp;total_threads);
-	wake_up_process(th);
+	us-&gt;ctl_thread = th;
 
 	return 0;
 }
@@ -838,6 +824,8 @@ static void usb_stor_release_resources(struct us_data *us)
 	US_DEBUGP("-- sending exit command to thread\n");
 	set_bit(US_FLIDX_DISCONNECTING, &amp;us-&gt;flags);
 	up(&amp;us-&gt;sema);
+	if (us-&gt;ctl_thread)
+		kthread_stop(us-&gt;ctl_thread);
 
 	/* Call the destructor routine, if it exists */
 	if (us-&gt;extra_destructor) {
diff --git a/drivers/usb/storage/usb.h b/drivers/usb/storage/usb.h
index 6dac1ffdde86..6445665b1577 100644
--- a/drivers/usb/storage/usb.h
+++ b/drivers/usb/storage/usb.h
@@ -144,6 +144,7 @@ struct us_data {
 	unsigned char		*sensebuf;	 /* sense data buffer	 */
 	dma_addr_t		cr_dma;		 /* buffer DMA addresses */
 	dma_addr_t		iobuf_dma;
+	struct task_struct	*ctl_thread;	 /* the control thread   */
 
 	/* mutual exclusion and synchronization structures */
 	struct semaphore	sema;		 /* to sleep thread on	    */</pre><hr><pre>commit 59c2afa072506aae10ef93126aab651142e0c908
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jun 5 16:46:26 2007 -0700

    USB: option: fix usage of urb-&gt;status abuse
    
    Might fix bug 8561
    
    On Mon, 4 Jun 2007, Paulo Pereira wrote:
    
    &gt; The patch that you send is not resolving the problem... :(
    &gt; I stil have Kernel panic after 45/60 min of work with Ktorrent/Amule...
    &gt;
    &gt; The Drump is:
    &gt;
    &gt; Call Trace:
    &gt; [&lt;c055fb36&gt;] usb_hcd_submit+0xb1/0x763
    &gt; [&lt;f9276488&gt;] ipt_do_table+0x2c7/0x2ef [ip_tables]
    &gt; [&lt;f929a6d7&gt;] nf_ct_deliver_cached_events+0x41/0x96 [nf_conntrak]
    &gt; [&lt;f9288254&gt;] ipv4_confirm+0x36/0c3b [nf_conntrack_ipv4]
    &gt; [&lt;c05ce7c2&gt;] tcp_v4_rcv+0x827/0x899
    &gt; [&lt;c05afcc0&gt;] nf_hook_slow+0x4d/0xb5
    &gt; [&lt;c042826f&gt;] irq_enter+0x19/0x23
    &gt; [&lt;c042826f&gt;] irq_enter+0x19/0x23
    &gt; [&lt;c040794c&gt;] do_IRQ+0xbd/0xd1
    &gt; [&lt;f90893c9&gt;] option_write+0xa7/0xef [option]
    
    Okay, from this it looks like there's a problem in the option.c serial
    driver.  Glancing at the code, it's obvious why: The thing totally
    abuses the USB API.
    
    Try applying this patch; it should help.
    
    From: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: Paulo Pereira &lt;pfmp.404@gmail.com&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c
index 5d3999e3ff61..b37d65fc8752 100644
--- a/drivers/usb/serial/option.c
+++ b/drivers/usb/serial/option.c
@@ -38,6 +38,7 @@
 #include &lt;linux/tty.h&gt;
 #include &lt;linux/tty_flip.h&gt;
 #include &lt;linux/module.h&gt;
+#include &lt;linux/bitops.h&gt;
 #include &lt;linux/usb.h&gt;
 #include &lt;linux/usb/serial.h&gt;
 
@@ -240,6 +241,7 @@ struct option_port_private {
 	/* Output endpoints and buffer for this port */
 	struct urb *out_urbs[N_OUT_URB];
 	char out_buffer[N_OUT_URB][OUT_BUFLEN];
+	unsigned long out_busy;		/* Bit vector of URBs in use */
 
 	/* Settings for the port */
 	int rts_state;	/* Handshaking pins (outputs) */
@@ -370,7 +372,7 @@ static int option_write(struct usb_serial_port *port,
 			todo = OUT_BUFLEN;
 
 		this_urb = portdata-&gt;out_urbs[i];
-		if (this_urb-&gt;status == -EINPROGRESS) {
+		if (test_and_set_bit(i, &amp;portdata-&gt;out_busy)) {
 			if (time_before(jiffies,
 					portdata-&gt;tx_start_time[i] + 10 * HZ))
 				continue;
@@ -394,6 +396,7 @@ static int option_write(struct usb_serial_port *port,
 			dbg("usb_submit_urb %p (write bulk) failed "
 				"(%d, has %d)", this_urb,
 				err, this_urb-&gt;status);
+			clear_bit(i, &amp;portdata-&gt;out_busy);
 			continue;
 		}
 		portdata-&gt;tx_start_time[i] = jiffies;
@@ -446,12 +449,23 @@ static void option_indat_callback(struct urb *urb)
 static void option_outdat_callback(struct urb *urb)
 {
 	struct usb_serial_port *port;
+	struct option_port_private *portdata;
+	int i;
 
 	dbg("%s", __FUNCTION__);
 
 	port = (struct usb_serial_port *) urb-&gt;context;
 
 	usb_serial_port_softint(port);
+
+	portdata = usb_get_serial_port_data(port);
+	for (i = 0; i &lt; N_OUT_URB; ++i) {
+		if (portdata-&gt;out_urbs[i] == urb) {
+			smp_mb__before_clear_bit();
+			clear_bit(i, &amp;portdata-&gt;out_busy);
+			break;
+		}
+	}
 }
 
 static void option_instat_callback(struct urb *urb)
@@ -518,7 +532,7 @@ static int option_write_room(struct usb_serial_port *port)
 
 	for (i=0; i &lt; N_OUT_URB; i++) {
 		this_urb = portdata-&gt;out_urbs[i];
-		if (this_urb &amp;&amp; this_urb-&gt;status != -EINPROGRESS)
+		if (this_urb &amp;&amp; !test_bit(i, &amp;portdata-&gt;out_busy))
 			data_len += OUT_BUFLEN;
 	}
 
@@ -537,7 +551,7 @@ static int option_chars_in_buffer(struct usb_serial_port *port)
 
 	for (i=0; i &lt; N_OUT_URB; i++) {
 		this_urb = portdata-&gt;out_urbs[i];
-		if (this_urb &amp;&amp; this_urb-&gt;status == -EINPROGRESS)
+		if (this_urb &amp;&amp; test_bit(i, &amp;portdata-&gt;out_busy))
 			data_len += this_urb-&gt;transfer_buffer_length;
 	}
 	dbg("%s: %d", __FUNCTION__, data_len);</pre><hr><pre>commit b41a60eca833d76593d4dac8a59f5c38714194ee
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed May 30 15:39:33 2007 -0400

    USB: add power/persist device attribute
    
    This patch (as920) adds an extra level of protection to the
    USB-Persist facility.  Now it will apply by default only to hubs; for
    all other devices the user must enable it explicitly by setting the
    power/persist device attribute.
    
    The disconnect_all_children() routine in hub.c has been removed and
    its code placed inline.  This is the way it was originally as part of
    hub_pre_reset(); the revised usage in hub_reset_resume() is
    sufficiently different that the code can no longer be shared.
    Likewise, mark_children_for_reset() is now inline as part of
    hub_reset_resume().  The end result looks much cleaner than before.
    
    The sysfs interface is updated to add the new attribute file, and
    there are corresponding documentation updates.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/Documentation/ABI/testing/sysfs-bus-usb b/Documentation/ABI/testing/sysfs-bus-usb
index f9937add033d..9734577d1711 100644
--- a/Documentation/ABI/testing/sysfs-bus-usb
+++ b/Documentation/ABI/testing/sysfs-bus-usb
@@ -39,3 +39,16 @@ Description:
 		If you want to suspend a device immediately but leave it
 		free to wake up in response to I/O requests, you should
 		write "0" to power/autosuspend.
+
+What:		/sys/bus/usb/devices/.../power/persist
+Date:		May 2007
+KernelVersion:	2.6.23
+Contact:	Alan Stern &lt;stern@rowland.harvard.edu&gt;
+Description:
+		If CONFIG_USB_PERSIST is set, then each USB device directory
+		will contain a file named power/persist.  The file holds a
+		boolean value (0 or 1) indicating whether or not the
+		"USB-Persist" facility is enabled for the device.  Since the
+		facility is inherently dangerous, it is disabled by default
+		for all devices except hubs.  For more information, see
+		Documentation/usb/persist.txt.
diff --git a/Documentation/usb/persist.txt b/Documentation/usb/persist.txt
index 6dcd5f884795..df54d645cbb5 100644
--- a/Documentation/usb/persist.txt
+++ b/Documentation/usb/persist.txt
@@ -2,7 +2,7 @@
 
 		   Alan Stern &lt;stern@rowland.harvard.edu&gt;
 
-		 September 2, 2006 (Updated March 27, 2007)
+		 September 2, 2006 (Updated May 29, 2007)
 
 
 	What is the problem?
@@ -52,9 +52,9 @@ you can convince the BIOS supplier to fix the problem (lots of luck!).
 
 On many systems the USB host controllers will get reset after a
 suspend-to-RAM.  On almost all systems, no suspend current is
-available during suspend-to-disk (also known as swsusp).  You can
-check the kernel log after resuming to see if either of these has
-happened; look for lines saying "root hub lost power or was reset".
+available during hibernation (also known as swsusp or suspend-to-disk).
+You can check the kernel log after resuming to see if either of these
+has happened; look for lines saying "root hub lost power or was reset".
 
 In practice, people are forced to unmount any filesystems on a USB
 device before suspending.  If the root filesystem is on a USB device,
@@ -71,15 +71,16 @@ structures are allowed to persist across a power-session disruption.
 It works like this.  If the kernel sees that a USB host controller is
 not in the expected state during resume (i.e., if the controller was
 reset or otherwise had lost power) then it applies a persistence check
-to each of the USB devices below that controller.  It doesn't try to
-resume the device; that can't work once the power session is gone.
-Instead it issues a USB port reset and then re-enumerates the device.
-(This is exactly the same thing that happens whenever a USB device is
-reset.)  If the re-enumeration shows that the device now attached to
-that port has the same descriptors as before, including the Vendor and
-Product IDs, then the kernel continues to use the same device
-structure.  In effect, the kernel treats the device as though it had
-merely been reset instead of unplugged.
+to each of the USB devices below that controller for which the
+"persist" attribute is set.  It doesn't try to resume the device; that
+can't work once the power session is gone.  Instead it issues a USB
+port reset and then re-enumerates the device.  (This is exactly the
+same thing that happens whenever a USB device is reset.)  If the
+re-enumeration shows that the device now attached to that port has the
+same descriptors as before, including the Vendor and Product IDs, then
+the kernel continues to use the same device structure.  In effect, the
+kernel treats the device as though it had merely been reset instead of
+unplugged.
 
 If no device is now attached to the port, or if the descriptors are
 different from what the kernel remembers, then the treatment is what
@@ -91,6 +92,17 @@ The end result is that the USB device remains available and usable.
 Filesystem mounts and memory mappings are unaffected, and the world is
 now a good and happy place.
 
+Note that even when CONFIG_USB_PERSIST is set, the "persist" feature
+will be applied only to those devices for which it is enabled.  You
+can enable the feature by doing (as root):
+
+	echo 1 &gt;/sys/bus/usb/devices/.../power/persist
+
+where the "..." should be filled in the with the device's ID.  Disable
+the feature by writing 0 instead of 1.  For hubs the feature is
+automatically and permanently enabled, so you only have to worry about
+setting it for devices where it really matters.
+
 
 	Is this the best solution?
 
diff --git a/drivers/usb/core/Kconfig b/drivers/usb/core/Kconfig
index 5113ef4cb7f6..97b09f282705 100644
--- a/drivers/usb/core/Kconfig
+++ b/drivers/usb/core/Kconfig
@@ -91,12 +91,15 @@ config USB_PERSIST
 	depends on USB &amp;&amp; PM &amp;&amp; EXPERIMENTAL
 	default n
 	help
-	  If you say Y here, USB device data structures will remain
+
+	  If you say Y here and enable the "power/persist" attribute
+	  for a USB device, the device's data structures will remain
 	  persistent across system suspend, even if the USB bus loses
-	  power.  (This includes software-suspend, also known as swsusp,
-	  or suspend-to-disk.)  The devices will reappear as if by magic
-	  when the system wakes up, with no need to unmount USB filesystems,
-	  rmmod host-controller drivers, or do anything else.
+	  power.  (This includes hibernation, also known as swsusp or
+	  suspend-to-disk.)  The devices will reappear as if by magic
+	  when the system wakes up, with no need to unmount USB
+	  filesystems, rmmod host-controller drivers, or do anything
+	  else.
 
 	  	WARNING: This option can be dangerous!
 
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index c4cdb69a6e9e..50e79010401c 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -596,27 +596,18 @@ static void hub_port_logical_disconnect(struct usb_hub *hub, int port1)
  	kick_khubd(hub);
 }
 
-static void disconnect_all_children(struct usb_hub *hub, int logical)
-{
-	struct usb_device *hdev = hub-&gt;hdev;
-	int port1;
-
-	for (port1 = 1; port1 &lt;= hdev-&gt;maxchild; ++port1) {
-		if (hdev-&gt;children[port1-1]) {
-			if (logical)
-				hub_port_logical_disconnect(hub, port1);
-			else
-				usb_disconnect(&amp;hdev-&gt;children[port1-1]);
-		}
-	}
-}
-
 /* caller has locked the hub device */
 static int hub_pre_reset(struct usb_interface *intf)
 {
 	struct usb_hub *hub = usb_get_intfdata(intf);
+	struct usb_device *hdev = hub-&gt;hdev;
+	int i;
 
-	disconnect_all_children(hub, 0);
+	/* Disconnect all the children */
+	for (i = 0; i &lt; hdev-&gt;maxchild; ++i) {
+		if (hdev-&gt;children[i])
+			usb_disconnect(&amp;hdev-&gt;children[i]);
+	}
 	hub_quiesce(hub);
 	return 0;
 }
@@ -1872,50 +1863,39 @@ static int hub_resume(struct usb_interface *intf)
 	return 0;
 }
 
-#ifdef	CONFIG_USB_PERSIST
-
-/* For "persistent-device" resets we must mark the child devices for reset
- * and turn off a possible connect-change status (so khubd won't disconnect
- * them later).
- */
-static void mark_children_for_reset_resume(struct usb_hub *hub)
+static int hub_reset_resume(struct usb_interface *intf)
 {
+	struct usb_hub *hub = usb_get_intfdata(intf);
 	struct usb_device *hdev = hub-&gt;hdev;
 	int port1;
 
+	hub_power_on(hub);
+
 	for (port1 = 1; port1 &lt;= hdev-&gt;maxchild; ++port1) {
 		struct usb_device *child = hdev-&gt;children[port1-1];
 
 		if (child) {
-			child-&gt;reset_resume = 1;
-			clear_port_feature(hdev, port1,
-					USB_PORT_FEAT_C_CONNECTION);
+
+			/* For "USB_PERSIST"-enabled children we must
+			 * mark the child device for reset-resume and
+			 * turn off the connect-change status to prevent
+			 * khubd from disconnecting it later.
+			 */
+			if (USB_PERSIST &amp;&amp; child-&gt;persist_enabled) {
+				child-&gt;reset_resume = 1;
+				clear_port_feature(hdev, port1,
+						USB_PORT_FEAT_C_CONNECTION);
+
+			/* Otherwise we must disconnect the child,
+			 * but as we may not lock the child device here
+			 * we have to do a "logical" disconnect.
+			 */
+			} else {
+				hub_port_logical_disconnect(hub, port1);
+			}
 		}
 	}
-}
-
-#else
-
-static inline void mark_children_for_reset_resume(struct usb_hub *hub)
-{ }
-
-#endif	/* CONFIG_USB_PERSIST */
-
-static int hub_reset_resume(struct usb_interface *intf)
-{
-	struct usb_hub *hub = usb_get_intfdata(intf);
 
-	hub_power_on(hub);
-	if (USB_PERSIST)
-		mark_children_for_reset_resume(hub);
-	else {
-		/* Reset-resume doesn't call pre_reset, so we have to
-		 * disconnect the children here.  But we may not lock
-		 * the child devices, so we have to do a "logical"
-		 * disconnect.
-		 */
-		disconnect_all_children(hub, 1);
-	}
 	hub_activate(hub);
 	return 0;
 }
diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c
index be37c863fdfb..5dfe31bc32ba 100644
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -169,6 +169,73 @@ show_quirks(struct device *dev, struct device_attribute *attr, char *buf)
 }
 static DEVICE_ATTR(quirks, S_IRUGO, show_quirks, NULL);
 
+
+#if defined(CONFIG_USB_PERSIST) || defined(CONFIG_USB_SUSPEND)
+static const char power_group[] = "power";
+#endif
+
+#ifdef	CONFIG_USB_PERSIST
+
+static ssize_t
+show_persist(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct usb_device *udev = to_usb_device(dev);
+
+	return sprintf(buf, "%d\n", udev-&gt;persist_enabled);
+}
+
+static ssize_t
+set_persist(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct usb_device *udev = to_usb_device(dev);
+	int value;
+
+	/* Hubs are always enabled for USB_PERSIST */
+	if (udev-&gt;descriptor.bDeviceClass == USB_CLASS_HUB)
+		return -EPERM;
+
+	if (sscanf(buf, "%d", &amp;value) != 1)
+		return -EINVAL;
+	usb_pm_lock(udev);
+	udev-&gt;persist_enabled = !!value;
+	usb_pm_unlock(udev);
+	return count;
+}
+
+static DEVICE_ATTR(persist, S_IRUGO | S_IWUSR, show_persist, set_persist);
+
+static int add_persist_attributes(struct device *dev)
+{
+	int rc = 0;
+
+	if (is_usb_device(dev)) {
+		struct usb_device *udev = to_usb_device(dev);
+
+		/* Hubs are automatically enabled for USB_PERSIST */
+		if (udev-&gt;descriptor.bDeviceClass == USB_CLASS_HUB)
+			udev-&gt;persist_enabled = 1;
+		rc = sysfs_add_file_to_group(&amp;dev-&gt;kobj,
+				&amp;dev_attr_persist.attr,
+				power_group);
+	}
+	return rc;
+}
+
+static void remove_persist_attributes(struct device *dev)
+{
+	sysfs_remove_file_from_group(&amp;dev-&gt;kobj,
+			&amp;dev_attr_persist.attr,
+			power_group);
+}
+
+#else
+
+#define add_persist_attributes(dev)	0
+#define remove_persist_attributes(dev)	do {} while (0)
+
+#endif	/* CONFIG_USB_PERSIST */
+
 #ifdef	CONFIG_USB_SUSPEND
 
 static ssize_t
@@ -276,8 +343,6 @@ set_level(struct device *dev, struct device_attribute *attr,
 
 static DEVICE_ATTR(level, S_IRUGO | S_IWUSR, show_level, set_level);
 
-static char power_group[] = "power";
-
 static int add_power_attributes(struct device *dev)
 {
 	int rc = 0;
@@ -311,6 +376,7 @@ static void remove_power_attributes(struct device *dev)
 
 #endif	/* CONFIG_USB_SUSPEND */
 
+
 /* Descriptor fields */
 #define usb_descriptor_attr_le16(field, format_string)			\
 static ssize_t								\
@@ -384,6 +450,10 @@ int usb_create_sysfs_dev_files(struct usb_device *udev)
 	if (retval)
 		return retval;
 
+	retval = add_persist_attributes(dev);
+	if (retval)
+		goto error;
+
 	retval = add_power_attributes(dev);
 	if (retval)
 		goto error;
@@ -421,6 +491,7 @@ void usb_remove_sysfs_dev_files(struct usb_device *udev)
 	device_remove_file(dev, &amp;dev_attr_product);
 	device_remove_file(dev, &amp;dev_attr_serial);
 	remove_power_attributes(dev);
+	remove_persist_attributes(dev);
 	sysfs_remove_group(&amp;dev-&gt;kobj, &amp;dev_attr_grp);
 }
 
diff --git a/include/linux/usb.h b/include/linux/usb.h
index bde8c65e2bfc..efce9a4c511c 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -404,6 +404,7 @@ struct usb_device {
 	unsigned auto_pm:1;		/* autosuspend/resume in progress */
 	unsigned do_remote_wakeup:1;	/* remote wakeup should be enabled */
 	unsigned reset_resume:1;	/* needs reset instead of resume */
+	unsigned persist_enabled:1;	/* USB_PERSIST enabled for this dev */
 	unsigned autosuspend_disabled:1; /* autosuspend and autoresume */
 	unsigned autoresume_disabled:1;  /*  disabled by the user */
 #endif</pre><hr><pre>commit 54515fe528d8c6f9bfaf7d0b9fffb908deecad78
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed May 30 15:38:58 2007 -0400

    USB: unify reset_resume and normal resume
    
    This patch (as919) unifies the code paths used for normal resume and
    for reset-resume.  Earlier I had failed to note a section in the USB
    spec which requires the host to resume a suspended port before
    resetting it if the attached device is enabled for remote wakeup.
    Since the port has to be resumed anyway, we might as well reuse the
    existing code.
    
    The main changes are:
    
            usb_reset_suspended_device() is eliminated.
    
            usb_root_hub_lost_power() is moved down next to the
            hub_reset_resume() routine, to which it is logically
            related.
    
            finish_port_resume() does a port reset() if the device's
            reset_resume flag is set.
    
            usb_port_resume() doesn't check whether the port is initially
            enabled if this is a USB-Persist sort of resume.
    
            Code to perform the port reset is added to the resume pathway
            for the non-CONFIG_USB_SUSPEND case.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index 4cbe7b339513..b2fc2b115256 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -219,8 +219,6 @@ static int generic_resume(struct usb_device *udev)
 	 */
 	if (!udev-&gt;parent)
 		rc = hcd_bus_resume(udev);
-	else if (udev-&gt;reset_resume)
-		rc = usb_reset_suspended_device(udev);
 	else
 		rc = usb_port_resume(udev);
 	return rc;
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 0b8ed414d5cf..c4cdb69a6e9e 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -31,6 +31,12 @@
 #include "hcd.h"
 #include "hub.h"
 
+#ifdef	CONFIG_USB_PERSIST
+#define	USB_PERSIST	1
+#else
+#define	USB_PERSIST	0
+#endif
+
 struct usb_hub {
 	struct device		*intfdev;	/* the "interface" device */
 	struct usb_device	*hdev;
@@ -1080,72 +1086,6 @@ void usb_set_device_state(struct usb_device *udev,
 	spin_unlock_irqrestore(&amp;device_state_lock, flags);
 }
 
-
-#ifdef	CONFIG_PM
-
-/**
- * usb_reset_suspended_device - reset a suspended device instead of resuming it
- * @udev: device to be reset instead of resumed
- *
- * If a host controller doesn't maintain VBUS suspend current during a
- * system sleep or is reset when the system wakes up, all the USB
- * power sessions below it will be broken.  This is especially troublesome
- * for mass-storage devices containing mounted filesystems, since the
- * device will appear to have disconnected and all the memory mappings
- * to it will be lost.
- *
- * As an alternative, this routine attempts to recover power sessions for
- * devices that are still present by resetting them instead of resuming
- * them.  If all goes well, the devices will appear to persist across the
- * the interruption of the power sessions.
- *
- * This facility is inherently dangerous.  Although usb_reset_device()
- * makes every effort to insure that the same device is present after the
- * reset as before, it cannot provide a 100% guarantee.  Furthermore it's
- * quite possible for a device to remain unaltered but its media to be
- * changed.  If the user replaces a flash memory card while the system is
- * asleep, he will have only himself to blame when the filesystem on the
- * new card is corrupted and the system crashes.
- */
-int usb_reset_suspended_device(struct usb_device *udev)
-{
-	int rc = 0;
-
-	dev_dbg(&amp;udev-&gt;dev, "usb %sresume\n", "reset-");
-
-	/* After we're done the device won't be suspended any more.
-	 * In addition, the reset won't work if udev-&gt;state is SUSPENDED.
-	 */
-	usb_set_device_state(udev, udev-&gt;actconfig
-			? USB_STATE_CONFIGURED
-			: USB_STATE_ADDRESS);
-
-	/* Root hubs don't need to be (and can't be) reset */
-	if (udev-&gt;parent)
-		rc = usb_reset_device(udev);
-	return rc;
-}
-
-/**
- * usb_root_hub_lost_power - called by HCD if the root hub lost Vbus power
- * @rhdev: struct usb_device for the root hub
- *
- * The USB host controller driver calls this function when its root hub
- * is resumed and Vbus power has been interrupted or the controller
- * has been reset.  The routine marks @rhdev as having lost power.  When
- * the hub driver is resumed it will take notice; if CONFIG_USB_PERSIST
- * is enabled then it will carry out power-session recovery, otherwise
- * it will disconnect all the child devices.
- */
-void usb_root_hub_lost_power(struct usb_device *rhdev)
-{
-	dev_warn(&amp;rhdev-&gt;dev, "root hub lost power or was reset\n");
-	rhdev-&gt;reset_resume = 1;
-}
-EXPORT_SYMBOL_GPL(usb_root_hub_lost_power);
-
-#endif	/* CONFIG_PM */
-
 static void choose_address(struct usb_device *udev)
 {
 	int		devnum;
@@ -1672,18 +1612,22 @@ int usb_port_suspend(struct usb_device *udev)
 /*
  * If the USB "suspend" state is in use (rather than "global suspend"),
  * many devices will be individually taken out of suspend state using
- * special" resume" signaling.  These routines kick in shortly after
+ * special "resume" signaling.  This routine kicks in shortly after
  * hardware resume signaling is finished, either because of selective
  * resume (by host) or remote wakeup (by device) ... now see what changed
  * in the tree that's rooted at this device.
+ *
+ * If @udev-&gt;reset_resume is set then the device is reset before the
+ * status check is done.
  */
 static int finish_port_resume(struct usb_device *udev)
 {
-	int	status;
+	int	status = 0;
 	u16	devstatus;
 
 	/* caller owns the udev device lock */
-	dev_dbg(&amp;udev-&gt;dev, "finish resume\n");
+	dev_dbg(&amp;udev-&gt;dev, "finish %sresume\n",
+			udev-&gt;reset_resume ? "reset-" : "");
 
 	/* usb ch9 identifies four variants of SUSPENDED, based on what
 	 * state the device resumes to.  Linux currently won't see the
@@ -1694,13 +1638,23 @@ static int finish_port_resume(struct usb_device *udev)
 			? USB_STATE_CONFIGURED
 			: USB_STATE_ADDRESS);
 
+	/* 10.5.4.5 says not to reset a suspended port if the attached
+	 * device is enabled for remote wakeup.  Hence the reset
+	 * operation is carried out here, after the port has been
+	 * resumed.
+	 */
+	if (udev-&gt;reset_resume)
+		status = usb_reset_device(udev);
+
  	/* 10.5.4.5 says be sure devices in the tree are still there.
  	 * For now let's assume the device didn't go crazy on resume,
 	 * and device drivers will know about any resume quirks.
 	 */
-	status = usb_get_status(udev, USB_RECIP_DEVICE, 0, &amp;devstatus);
-	if (status &gt;= 0)
-		status = (status == 2 ? 0 : -ENODEV);
+	if (status == 0) {
+		status = usb_get_status(udev, USB_RECIP_DEVICE, 0, &amp;devstatus);
+		if (status &gt;= 0)
+			status = (status == 2 ? 0 : -ENODEV);
+	}
 
 	if (status) {
 		dev_dbg(&amp;udev-&gt;dev, "gone after usb resume? status %d\n",
@@ -1735,6 +1689,28 @@ static int finish_port_resume(struct usb_device *udev)
  * the host and the device is the same as it was when the device
  * suspended.
  *
+ * If CONFIG_USB_PERSIST and @udev-&gt;reset_resume are both set then this
+ * routine won't check that the port is still enabled.  Furthermore,
+ * if @udev-&gt;reset_resume is set then finish_port_resume() above will
+ * reset @udev.  The end result is that a broken power session can be
+ * recovered and @udev will appear to persist across a loss of VBUS power.
+ *
+ * For example, if a host controller doesn't maintain VBUS suspend current
+ * during a system sleep or is reset when the system wakes up, all the USB
+ * power sessions below it will be broken.  This is especially troublesome
+ * for mass-storage devices containing mounted filesystems, since the
+ * device will appear to have disconnected and all the memory mappings
+ * to it will be lost.  Using the USB_PERSIST facility, the device can be
+ * made to appear as if it had not disconnected.
+ *
+ * This facility is inherently dangerous.  Although usb_reset_device()
+ * makes every effort to insure that the same device is present after the
+ * reset as before, it cannot provide a 100% guarantee.  Furthermore it's
+ * quite possible for a device to remain unaltered but its media to be
+ * changed.  If the user replaces a flash memory card while the system is
+ * asleep, he will have only himself to blame when the filesystem on the
+ * new card is corrupted and the system crashes.
+ *
  * Returns 0 on success, else negative errno.
  */
 int usb_port_resume(struct usb_device *udev)
@@ -1743,6 +1719,7 @@ int usb_port_resume(struct usb_device *udev)
 	int		port1 = udev-&gt;portnum;
 	int		status;
 	u16		portchange, portstatus;
+	unsigned	mask_flags, want_flags;
 
 	/* Skip the initial Clear-Suspend step for a remote wakeup */
 	status = hub_port_status(hub, port1, &amp;portstatus, &amp;portchange);
@@ -1765,20 +1742,23 @@ int usb_port_resume(struct usb_device *udev)
 				udev-&gt;auto_pm ? "auto-" : "");
 		msleep(25);
 
-#define LIVE_FLAGS	( USB_PORT_STAT_POWER \
-			| USB_PORT_STAT_ENABLE \
-			| USB_PORT_STAT_CONNECTION)
-
 		/* Virtual root hubs can trigger on GET_PORT_STATUS to
 		 * stop resume signaling.  Then finish the resume
 		 * sequence.
 		 */
 		status = hub_port_status(hub, port1, &amp;portstatus, &amp;portchange);
-SuspendCleared:
-		if (status &lt; 0
-				|| (portstatus &amp; LIVE_FLAGS) != LIVE_FLAGS
-				|| (portstatus &amp; USB_PORT_STAT_SUSPEND) != 0
-				) {
+
+ SuspendCleared:
+		if (USB_PERSIST &amp;&amp; udev-&gt;reset_resume)
+			want_flags = USB_PORT_STAT_POWER
+					| USB_PORT_STAT_CONNECTION;
+		else
+			want_flags = USB_PORT_STAT_POWER
+					| USB_PORT_STAT_CONNECTION
+					| USB_PORT_STAT_ENABLE;
+		mask_flags = want_flags | USB_PORT_STAT_SUSPEND;
+
+		if (status &lt; 0 || (portstatus &amp; mask_flags) != want_flags) {
 			dev_dbg(hub-&gt;intfdev,
 				"port %d status %04x.%04x after resume, %d\n",
 				port1, portchange, portstatus, status);
@@ -1790,18 +1770,19 @@ int usb_port_resume(struct usb_device *udev)
 						USB_PORT_FEAT_C_SUSPEND);
 			/* TRSMRCY = 10 msec */
 			msleep(10);
-			status = finish_port_resume(udev);
 		}
 	}
-	if (status &lt; 0) {
-		dev_dbg(&amp;udev-&gt;dev, "can't resume, status %d\n", status);
-		hub_port_logical_disconnect(hub, port1);
-	}
 
 	clear_bit(port1, hub-&gt;busy_bits);
 	if (!hub-&gt;hdev-&gt;parent &amp;&amp; !hub-&gt;busy_bits[0])
 		usb_enable_root_hub_irq(hub-&gt;hdev-&gt;bus);
 
+	if (status == 0)
+		status = finish_port_resume(udev);
+	if (status &lt; 0) {
+		dev_dbg(&amp;udev-&gt;dev, "can't resume, status %d\n", status);
+		hub_port_logical_disconnect(hub, port1);
+	}
 	return status;
 }
 
@@ -1830,7 +1811,14 @@ int usb_port_suspend(struct usb_device *udev)
 
 int usb_port_resume(struct usb_device *udev)
 {
-	return 0;
+	int status = 0;
+
+	/* However we may need to do a reset-resume */
+	if (udev-&gt;reset_resume) {
+		dev_dbg(&amp;udev-&gt;dev, "reset-resume\n");
+		status = usb_reset_device(udev);
+	}
+	return status;
 }
 
 static inline int remote_wakeup(struct usb_device *udev)
@@ -1886,8 +1874,6 @@ static int hub_resume(struct usb_interface *intf)
 
 #ifdef	CONFIG_USB_PERSIST
 
-#define USB_PERSIST	1
-
 /* For "persistent-device" resets we must mark the child devices for reset
  * and turn off a possible connect-change status (so khubd won't disconnect
  * them later).
@@ -1910,8 +1896,6 @@ static void mark_children_for_reset_resume(struct usb_hub *hub)
 
 #else
 
-#define USB_PERSIST	0
-
 static inline void mark_children_for_reset_resume(struct usb_hub *hub)
 { }
 
@@ -1936,6 +1920,24 @@ static int hub_reset_resume(struct usb_interface *intf)
 	return 0;
 }
 
+/**
+ * usb_root_hub_lost_power - called by HCD if the root hub lost Vbus power
+ * @rhdev: struct usb_device for the root hub
+ *
+ * The USB host controller driver calls this function when its root hub
+ * is resumed and Vbus power has been interrupted or the controller
+ * has been reset.  The routine marks @rhdev as having lost power.  When
+ * the hub driver is resumed it will take notice; if CONFIG_USB_PERSIST
+ * is enabled then it will carry out power-session recovery, otherwise
+ * it will disconnect all the child devices.
+ */
+void usb_root_hub_lost_power(struct usb_device *rhdev)
+{
+	dev_warn(&amp;rhdev-&gt;dev, "root hub lost power or was reset\n");
+	rhdev-&gt;reset_resume = 1;
+}
+EXPORT_SYMBOL_GPL(usb_root_hub_lost_power);
+
 #else	/* CONFIG_PM */
 
 static inline int remote_wakeup(struct usb_device *udev)
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index a547499c45f4..ad5fa0338f49 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -36,7 +36,6 @@ extern void usb_host_cleanup(void);
 extern void usb_autosuspend_work(struct work_struct *work);
 extern int usb_port_suspend(struct usb_device *dev);
 extern int usb_port_resume(struct usb_device *dev);
-extern int usb_reset_suspended_device(struct usb_device *udev);
 extern int usb_external_suspend_device(struct usb_device *udev,
 		pm_message_t msg);
 extern int usb_external_resume_device(struct usb_device *udev);</pre><hr><pre>commit f07600cf9eb3ee92777b2001e564faa413144a99
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed May 30 15:38:16 2007 -0400

    USB: add reset_resume method
    
    This patch (as918) introduces a new USB driver method: reset_resume.
    It is called when a device needs to be reset as part of a resume
    procedure (whether because of a device quirk or because of the
    USB-Persist facility), thereby taking over a role formerly assigned to
    the post_reset method.  As a consequence, post_reset no longer needs
    an argument indicating whether it is being called as part of a
    reset-resume.  This separation of functions makes the code clearer.
    
    In addition, the pre_reset and post_reset method return types are
    changed; they now must return an error code.  The return value is
    unused at present, but at some later time we may unbind drivers and
    re-probe if they encounter an error during reset handling.
    
    The existing pre_reset and post_reset methods in the usbhid,
    usb-storage, and hub drivers are updated to match the new
    requirements.  For usbhid the post_reset routine is also used for
    reset_resume (duplicate method pointers); for the other drivers a new
    reset_resume routine is added.  The change to hub.c looks bigger than
    it really is, because mark_children_for_reset_resume() gets moved down
    next to the new hub_reset_resume() routine.
    
    A minor change to usb-storage makes the usb_stor_report_bus_reset()
    routine acquire the host lock instead of requiring the caller to hold
    it already.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;
    CC: Matthew Dharm &lt;mdharm-usb@one-eyed-alien.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c
index e221b0d1f667..b2baeaeba9be 100644
--- a/drivers/hid/usbhid/hid-core.c
+++ b/drivers/hid/usbhid/hid-core.c
@@ -1009,20 +1009,22 @@ static int hid_resume(struct usb_interface *intf)
 }
 
 /* Treat USB reset pretty much the same as suspend/resume */
-static void hid_pre_reset(struct usb_interface *intf)
+static int hid_pre_reset(struct usb_interface *intf)
 {
 	/* FIXME: What if the interface is already suspended? */
 	hid_suspend(intf, PMSG_ON);
+	return 0;
 }
 
-static void hid_post_reset(struct usb_interface *intf, int reset_resume)
+/* Same routine used for post_reset and reset_resume */
+static int hid_post_reset(struct usb_interface *intf)
 {
 	struct usb_device *dev = interface_to_usbdev (intf);
 
 	hid_set_idle(dev, intf-&gt;cur_altsetting-&gt;desc.bInterfaceNumber, 0, 0);
 	/* FIXME: Any more reinitialization needed? */
 
-	hid_resume(intf);
+	return hid_resume(intf);
 }
 
 static struct usb_device_id hid_usb_ids [] = {
@@ -1039,6 +1041,7 @@ static struct usb_driver hid_driver = {
 	.disconnect =	hid_disconnect,
 	.suspend =	hid_suspend,
 	.resume =	hid_resume,
+	.reset_resume =	hid_post_reset,
 	.pre_reset =	hid_pre_reset,
 	.post_reset =	hid_post_reset,
 	.id_table =	hid_usb_ids,
diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 6c62a6d91484..3cd9af2638fc 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -915,21 +915,37 @@ static int usb_resume_interface(struct usb_interface *intf, int reset_resume)
 	}
 	driver = to_usb_driver(intf-&gt;dev.driver);
 
-	if (reset_resume &amp;&amp; driver-&gt;post_reset)
-		driver-&gt;post_reset(intf, reset_resume);
-	else if (driver-&gt;resume) {
-		status = driver-&gt;resume(intf);
-		if (status)
-			dev_err(&amp;intf-&gt;dev, "%s error %d\n",
-					"resume", status);
-	} else
-		dev_warn(&amp;intf-&gt;dev, "no resume for driver %s?\n",
-				driver-&gt;name);
+	if (reset_resume) {
+		if (driver-&gt;reset_resume) {
+			status = driver-&gt;reset_resume(intf);
+			if (status)
+				dev_err(&amp;intf-&gt;dev, "%s error %d\n",
+						"reset_resume", status);
+		} else {
+			// status = -EOPNOTSUPP;
+			dev_warn(&amp;intf-&gt;dev, "no %s for driver %s?\n",
+					"reset_resume", driver-&gt;name);
+		}
+	} else {
+		if (driver-&gt;resume) {
+			status = driver-&gt;resume(intf);
+			if (status)
+				dev_err(&amp;intf-&gt;dev, "%s error %d\n",
+						"resume", status);
+		} else {
+			// status = -EOPNOTSUPP;
+			dev_warn(&amp;intf-&gt;dev, "no %s for driver %s?\n",
+					"resume", driver-&gt;name);
+		}
+	}
 
 done:
 	dev_vdbg(&amp;intf-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
 	if (status == 0)
 		mark_active(intf);
+
+	/* FIXME: Unbind the driver and reprobe if the resume failed
+	 * (not possible if auto_pm is set) */
 	return status;
 }
 
@@ -966,6 +982,18 @@ static int autosuspend_check(struct usb_device *udev)
 						"for autosuspend\n");
 				return -EOPNOTSUPP;
 			}
+
+			/* Don't allow autosuspend if the device will need
+			 * a reset-resume and any of its interface drivers
+			 * doesn't include support.
+			 */
+			if (udev-&gt;quirks &amp; USB_QUIRK_RESET_RESUME) {
+				struct usb_driver *driver;
+
+				driver = to_usb_driver(intf-&gt;dev.driver);
+				if (!driver-&gt;reset_resume)
+					return -EOPNOTSUPP;
+			}
 		}
 	}
 
@@ -1146,7 +1174,8 @@ static int usb_resume_both(struct usb_device *udev)
 			status = usb_autoresume_device(parent);
 			if (status == 0) {
 				status = usb_resume_device(udev);
-				if (status) {
+				if (status || udev-&gt;state ==
+						USB_STATE_NOTATTACHED) {
 					usb_autosuspend_device(parent);
 
 					/* It's possible usb_resume_device()
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index ca3dbf84e800..0b8ed414d5cf 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -605,73 +605,26 @@ static void disconnect_all_children(struct usb_hub *hub, int logical)
 	}
 }
 
-#ifdef	CONFIG_USB_PERSIST
-
-#define USB_PERSIST	1
-
-/* For "persistent-device" resets we must mark the child devices for reset
- * and turn off a possible connect-change status (so khubd won't disconnect
- * them later).
- */
-static void mark_children_for_reset_resume(struct usb_hub *hub)
-{
-	struct usb_device *hdev = hub-&gt;hdev;
-	int port1;
-
-	for (port1 = 1; port1 &lt;= hdev-&gt;maxchild; ++port1) {
-		struct usb_device *child = hdev-&gt;children[port1-1];
-
-		if (child) {
-			child-&gt;reset_resume = 1;
-			clear_port_feature(hdev, port1,
-					USB_PORT_FEAT_C_CONNECTION);
-		}
-	}
-}
-
-#else
-
-#define USB_PERSIST	0
-
-static inline void mark_children_for_reset_resume(struct usb_hub *hub)
-{ }
-
-#endif	/* CONFIG_USB_PERSIST */
-
 /* caller has locked the hub device */
-static void hub_pre_reset(struct usb_interface *intf)
+static int hub_pre_reset(struct usb_interface *intf)
 {
 	struct usb_hub *hub = usb_get_intfdata(intf);
 
-	/* This routine doesn't run as part of a reset-resume, so it's safe
-	 * to disconnect all the drivers below the hub.
-	 */
 	disconnect_all_children(hub, 0);
 	hub_quiesce(hub);
+	return 0;
 }
 
 /* caller has locked the hub device */
-static void hub_post_reset(struct usb_interface *intf, int reset_resume)
+static int hub_post_reset(struct usb_interface *intf)
 {
 	struct usb_hub *hub = usb_get_intfdata(intf);
 
 	hub_power_on(hub);
-	if (reset_resume) {
-		if (USB_PERSIST)
-			mark_children_for_reset_resume(hub);
-		else {
-			/* Reset-resume doesn't call pre_reset, so we have to
-			 * disconnect the children here.  But we may not lock
-			 * the child devices, so we have to do a "logical"
-			 * disconnect.
-			 */
-			disconnect_all_children(hub, 1);
-		}
-	}
 	hub_activate(hub);
+	return 0;
 }
 
-
 static int hub_configure(struct usb_hub *hub,
 	struct usb_endpoint_descriptor *endpoint)
 {
@@ -1931,6 +1884,58 @@ static int hub_resume(struct usb_interface *intf)
 	return 0;
 }
 
+#ifdef	CONFIG_USB_PERSIST
+
+#define USB_PERSIST	1
+
+/* For "persistent-device" resets we must mark the child devices for reset
+ * and turn off a possible connect-change status (so khubd won't disconnect
+ * them later).
+ */
+static void mark_children_for_reset_resume(struct usb_hub *hub)
+{
+	struct usb_device *hdev = hub-&gt;hdev;
+	int port1;
+
+	for (port1 = 1; port1 &lt;= hdev-&gt;maxchild; ++port1) {
+		struct usb_device *child = hdev-&gt;children[port1-1];
+
+		if (child) {
+			child-&gt;reset_resume = 1;
+			clear_port_feature(hdev, port1,
+					USB_PORT_FEAT_C_CONNECTION);
+		}
+	}
+}
+
+#else
+
+#define USB_PERSIST	0
+
+static inline void mark_children_for_reset_resume(struct usb_hub *hub)
+{ }
+
+#endif	/* CONFIG_USB_PERSIST */
+
+static int hub_reset_resume(struct usb_interface *intf)
+{
+	struct usb_hub *hub = usb_get_intfdata(intf);
+
+	hub_power_on(hub);
+	if (USB_PERSIST)
+		mark_children_for_reset_resume(hub);
+	else {
+		/* Reset-resume doesn't call pre_reset, so we have to
+		 * disconnect the children here.  But we may not lock
+		 * the child devices, so we have to do a "logical"
+		 * disconnect.
+		 */
+		disconnect_all_children(hub, 1);
+	}
+	hub_activate(hub);
+	return 0;
+}
+
 #else	/* CONFIG_PM */
 
 static inline int remote_wakeup(struct usb_device *udev)
@@ -1938,8 +1943,9 @@ static inline int remote_wakeup(struct usb_device *udev)
 	return 0;
 }
 
-#define hub_suspend NULL
-#define hub_resume NULL
+#define hub_suspend		NULL
+#define hub_resume		NULL
+#define hub_reset_resume	NULL
 #endif
 
 
@@ -2768,6 +2774,7 @@ static struct usb_driver hub_driver = {
 	.disconnect =	hub_disconnect,
 	.suspend =	hub_suspend,
 	.resume =	hub_resume,
+	.reset_resume =	hub_reset_resume,
 	.pre_reset =	hub_pre_reset,
 	.post_reset =	hub_post_reset,
 	.ioctl =	hub_ioctl,
@@ -3021,6 +3028,7 @@ int usb_reset_composite_device(struct usb_device *udev,
 				drv = to_usb_driver(cintf-&gt;dev.driver);
 				if (drv-&gt;pre_reset)
 					(drv-&gt;pre_reset)(cintf);
+	/* FIXME: Unbind if pre_reset returns an error or isn't defined */
 			}
 		}
 	}
@@ -3038,7 +3046,8 @@ int usb_reset_composite_device(struct usb_device *udev,
 					cintf-&gt;dev.driver) {
 				drv = to_usb_driver(cintf-&gt;dev.driver);
 				if (drv-&gt;post_reset)
-					(drv-&gt;post_reset)(cintf, 0);
+					(drv-&gt;post_reset)(cintf);
+	/* FIXME: Unbind if post_reset returns an error or isn't defined */
 			}
 			if (cintf != iface)
 				up(&amp;cintf-&gt;dev.sem);
diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index e227f64d5641..1ba19eaa1970 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -321,10 +321,14 @@ void usb_stor_report_device_reset(struct us_data *us)
 
 /* Report a driver-initiated bus reset to the SCSI layer.
  * Calling this for a SCSI-initiated reset is unnecessary but harmless.
- * The caller must own the SCSI host lock. */
+ * The caller must not own the SCSI host lock. */
 void usb_stor_report_bus_reset(struct us_data *us)
 {
-	scsi_report_bus_reset(us_to_host(us), 0);
+	struct Scsi_Host *host = us_to_host(us);
+
+	scsi_lock(host);
+	scsi_report_bus_reset(host, 0);
+	scsi_unlock(host);
 }
 
 /***********************************************************************
diff --git a/drivers/usb/storage/usb.c b/drivers/usb/storage/usb.c
index be4cd8fe4ce6..00521f1d6a6b 100644
--- a/drivers/usb/storage/usb.c
+++ b/drivers/usb/storage/usb.c
@@ -219,6 +219,20 @@ static int storage_resume(struct usb_interface *iface)
 	return 0;
 }
 
+static int storage_reset_resume(struct usb_interface *iface)
+{
+	struct us_data *us = usb_get_intfdata(iface);
+
+	US_DEBUGP("%s\n", __FUNCTION__);
+
+	/* Report the reset to the SCSI core */
+	usb_stor_report_bus_reset(us);
+
+	/* FIXME: Notify the subdrivers that they need to reinitialize
+	 * the device */
+	return 0;
+}
+
 #endif /* CONFIG_PM */
 
 /*
@@ -226,7 +240,7 @@ static int storage_resume(struct usb_interface *iface)
  * a USB port reset, whether from this driver or a different one.
  */
 
-static void storage_pre_reset(struct usb_interface *iface)
+static int storage_pre_reset(struct usb_interface *iface)
 {
 	struct us_data *us = usb_get_intfdata(iface);
 
@@ -234,26 +248,23 @@ static void storage_pre_reset(struct usb_interface *iface)
 
 	/* Make sure no command runs during the reset */
 	mutex_lock(&amp;us-&gt;dev_mutex);
+	return 0;
 }
 
-static void storage_post_reset(struct usb_interface *iface, int reset_resume)
+static int storage_post_reset(struct usb_interface *iface)
 {
 	struct us_data *us = usb_get_intfdata(iface);
 
 	US_DEBUGP("%s\n", __FUNCTION__);
 
 	/* Report the reset to the SCSI core */
-	scsi_lock(us_to_host(us));
 	usb_stor_report_bus_reset(us);
-	scsi_unlock(us_to_host(us));
 
 	/* FIXME: Notify the subdrivers that they need to reinitialize
 	 * the device */
 
-	/* If this is a reset-resume then the pre_reset routine wasn't
-	 * called, so we don't need to unlock the mutex. */
-	if (!reset_resume)
-		mutex_unlock(&amp;us-&gt;dev_mutex);
+	mutex_unlock(&amp;us-&gt;dev_mutex);
+	return 0;
 }
 
 /*
@@ -1061,6 +1072,7 @@ static struct usb_driver usb_storage_driver = {
 #ifdef CONFIG_PM
 	.suspend =	storage_suspend,
 	.resume =	storage_resume,
+	.reset_resume =	storage_reset_resume,
 #endif
 	.pre_reset =	storage_pre_reset,
 	.post_reset =	storage_post_reset,
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 0873c6219efc..bde8c65e2bfc 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -839,6 +839,8 @@ struct usbdrv_wrap {
  *	do (or don't) show up otherwise in the filesystem.
  * @suspend: Called when the device is going to be suspended by the system.
  * @resume: Called when the device is being resumed by the system.
+ * @reset_resume: Called when the suspended device has been reset instead
+ *	of being resumed.
  * @pre_reset: Called by usb_reset_composite_device() when the device
  *	is about to be reset.
  * @post_reset: Called by usb_reset_composite_device() after the device
@@ -885,9 +887,10 @@ struct usb_driver {
 
 	int (*suspend) (struct usb_interface *intf, pm_message_t message);
 	int (*resume) (struct usb_interface *intf);
+	int (*reset_resume)(struct usb_interface *intf);
 
-	void (*pre_reset) (struct usb_interface *intf);
-	void (*post_reset) (struct usb_interface *intf, int reset_resume);
+	int (*pre_reset)(struct usb_interface *intf);
+	int (*post_reset)(struct usb_interface *intf);
 
 	const struct usb_device_id *id_table;
 </pre><hr><pre>commit 624d6c0732d2c4ac00945ad79dbb6ff39ba90ee3
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed May 30 15:35:16 2007 -0400

    USB: remove excess code from hub.c
    
    This patch (as917) removes a now-unnecessary level of subroutine
    nesting from hub.c.  Since usb_port_suspend() does nothing but call
    hub_port_suspend(), and usb_port_resume() does nothing but call
    hub_port_resume(), there's no reason to keep the routines separate.
    
    Also included in the patch are a few cosmetic changes involving
    whitespace and use of braces.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index ac1ef1527dd2..ca3dbf84e800 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1625,6 +1625,19 @@ static int hub_port_reset(struct usb_hub *hub, int port1,
 #ifdef	CONFIG_USB_SUSPEND
 
 /*
+ * usb_port_suspend - suspend a usb device's upstream port
+ * @udev: device that's no longer in active use, not a root hub
+ * Context: must be able to sleep; device not locked; pm locks held
+ *
+ * Suspends a USB device that isn't in active use, conserving power.
+ * Devices may wake out of a suspend, if anything important happens,
+ * using the remote wakeup mechanism.  They may also be taken out of
+ * suspend by the host, using usb_port_resume().  It's also routine
+ * to disconnect devices while they are suspended.
+ *
+ * This only affects the USB hardware for a device; its interfaces
+ * (and, for hubs, child devices) must already have been suspended.
+ *
  * Selective port suspend reduces power; most suspended devices draw
  * less than 500 uA.  It's also used in OTG, along with remote wakeup.
  * All devices below the suspended port are also suspended.
@@ -1633,11 +1646,35 @@ static int hub_port_reset(struct usb_hub *hub, int port1,
  * also support "remote wakeup", where the device can activate the USB
  * tree above them to deliver data, such as a keypress or packet.  In
  * some cases, this wakes the USB host.
+ *
+ * Suspending OTG devices may trigger HNP, if that's been enabled
+ * between a pair of dual-role devices.  That will change roles, such
+ * as from A-Host to A-Peripheral or from B-Host back to B-Peripheral.
+ *
+ * Devices on USB hub ports have only one "suspend" state, corresponding
+ * to ACPI D2, "may cause the device to lose some context".
+ * State transitions include:
+ *
+ *   - suspend, resume ... when the VBUS power link stays live
+ *   - suspend, disconnect ... VBUS lost
+ *
+ * Once VBUS drop breaks the circuit, the port it's using has to go through
+ * normal re-enumeration procedures, starting with enabling VBUS power.
+ * Other than re-initializing the hub (plug/unplug, except for root hubs),
+ * Linux (2.6) currently has NO mechanisms to initiate that:  no khubd
+ * timer, no SRP, no requests through sysfs.
+ *
+ * If CONFIG_USB_SUSPEND isn't enabled, devices only really suspend when
+ * the root hub for their bus goes into global suspend ... so we don't
+ * (falsely) update the device power state to say it suspended.
+ *
+ * Returns 0 on success, else negative errno.
  */
-static int hub_port_suspend(struct usb_hub *hub, int port1,
-		struct usb_device *udev)
+int usb_port_suspend(struct usb_device *udev)
 {
-	int	status;
+	struct usb_hub	*hub = hdev_to_hub(udev-&gt;parent);
+	int		port1 = udev-&gt;portnum;
+	int		status;
 
 	// dev_dbg(hub-&gt;intfdev, "suspend port %d\n", port1);
 
@@ -1654,17 +1691,15 @@ static int hub_port_suspend(struct usb_hub *hub, int port1,
 				NULL, 0,
 				USB_CTRL_SET_TIMEOUT);
 		if (status)
-			dev_dbg(&amp;udev-&gt;dev,
-				"won't remote wakeup, status %d\n",
-				status);
+			dev_dbg(&amp;udev-&gt;dev, "won't remote wakeup, status %d\n",
+					status);
 	}
 
 	/* see 7.1.7.6 */
 	status = set_port_feature(hub-&gt;hdev, port1, USB_PORT_FEAT_SUSPEND);
 	if (status) {
-		dev_dbg(hub-&gt;intfdev,
-			"can't suspend port %d, status %d\n",
-			port1, status);
+		dev_dbg(hub-&gt;intfdev, "can't suspend port %d, status %d\n",
+				port1, status);
 		/* paranoia:  "should not happen" */
 		(void) usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
 				USB_REQ_CLEAR_FEATURE, USB_RECIP_DEVICE,
@@ -1681,52 +1716,6 @@ static int hub_port_suspend(struct usb_hub *hub, int port1,
 	return status;
 }
 
-/*
- * usb_port_suspend - suspend a usb device's upstream port
- * @udev: device that's no longer in active use
- * Context: must be able to sleep; device not locked; pm locks held
- *
- * Suspends a USB device that isn't in active use, conserving power.
- * Devices may wake out of a suspend, if anything important happens,
- * using the remote wakeup mechanism.  They may also be taken out of
- * suspend by the host, using usb_port_resume().  It's also routine
- * to disconnect devices while they are suspended.
- *
- * This only affects the USB hardware for a device; its interfaces
- * (and, for hubs, child devices) must already have been suspended.
- *
- * Suspending OTG devices may trigger HNP, if that's been enabled
- * between a pair of dual-role devices.  That will change roles, such
- * as from A-Host to A-Peripheral or from B-Host back to B-Peripheral.
- *
- * Devices on USB hub ports have only one "suspend" state, corresponding
- * to ACPI D2, "may cause the device to lose some context".
- * State transitions include:
- *
- *   - suspend, resume ... when the VBUS power link stays live
- *   - suspend, disconnect ... VBUS lost
- *
- * Once VBUS drop breaks the circuit, the port it's using has to go through
- * normal re-enumeration procedures, starting with enabling VBUS power.
- * Other than re-initializing the hub (plug/unplug, except for root hubs),
- * Linux (2.6) currently has NO mechanisms to initiate that:  no khubd
- * timer, no SRP, no requests through sysfs.
- *
- * If CONFIG_USB_SUSPEND isn't enabled, devices only really suspend when
- * the root hub for their bus goes into global suspend ... so we don't
- * (falsely) update the device power state to say it suspended.
- *
- * Returns 0 on success, else negative errno.
- */
-int usb_port_suspend(struct usb_device *udev)
-{
-	int	status = 0;
-
-	status = hub_port_suspend(hdev_to_hub(udev-&gt;parent),
-			udev-&gt;portnum, udev);
-	return status;
-}
-
 /*
  * If the USB "suspend" state is in use (rather than "global suspend"),
  * many devices will be individually taken out of suspend state using
@@ -1760,11 +1749,10 @@ static int finish_port_resume(struct usb_device *udev)
 	if (status &gt;= 0)
 		status = (status == 2 ? 0 : -ENODEV);
 
-	if (status)
-		dev_dbg(&amp;udev-&gt;dev,
-			"gone after usb resume? status %d\n",
-			status);
-	else if (udev-&gt;actconfig) {
+	if (status) {
+		dev_dbg(&amp;udev-&gt;dev, "gone after usb resume? status %d\n",
+				status);
+	} else if (udev-&gt;actconfig) {
 		le16_to_cpus(&amp;devstatus);
 		if (devstatus &amp; (1 &lt;&lt; USB_DEVICE_REMOTE_WAKEUP)) {
 			status = usb_control_msg(udev,
@@ -1783,11 +1771,25 @@ static int finish_port_resume(struct usb_device *udev)
 	return status;
 }
 
-static int
-hub_port_resume(struct usb_hub *hub, int port1, struct usb_device *udev)
+/*
+ * usb_port_resume - re-activate a suspended usb device's upstream port
+ * @udev: device to re-activate, not a root hub
+ * Context: must be able to sleep; device not locked; pm locks held
+ *
+ * This will re-activate the suspended device, increasing power usage
+ * while letting drivers communicate again with its endpoints.
+ * USB resume explicitly guarantees that the power session between
+ * the host and the device is the same as it was when the device
+ * suspended.
+ *
+ * Returns 0 on success, else negative errno.
+ */
+int usb_port_resume(struct usb_device *udev)
 {
-	int	status;
-	u16	portchange, portstatus;
+	struct usb_hub	*hub = hdev_to_hub(udev-&gt;parent);
+	int		port1 = udev-&gt;portnum;
+	int		status;
+	u16		portchange, portstatus;
 
 	/* Skip the initial Clear-Suspend step for a remote wakeup */
 	status = hub_port_status(hub, port1, &amp;portstatus, &amp;portchange);
@@ -1802,9 +1804,8 @@ hub_port_resume(struct usb_hub *hub, int port1, struct usb_device *udev)
 	status = clear_port_feature(hub-&gt;hdev,
 			port1, USB_PORT_FEAT_SUSPEND);
 	if (status) {
-		dev_dbg(hub-&gt;intfdev,
-			"can't resume port %d, status %d\n",
-			port1, status);
+		dev_dbg(hub-&gt;intfdev, "can't resume port %d, status %d\n",
+				port1, status);
 	} else {
 		/* drive resume for at least 20 msec */
 		dev_dbg(&amp;udev-&gt;dev, "usb %sresume\n",
@@ -1839,8 +1840,10 @@ hub_port_resume(struct usb_hub *hub, int port1, struct usb_device *udev)
 			status = finish_port_resume(udev);
 		}
 	}
-	if (status &lt; 0)
+	if (status &lt; 0) {
+		dev_dbg(&amp;udev-&gt;dev, "can't resume, status %d\n", status);
 		hub_port_logical_disconnect(hub, port1);
+	}
 
 	clear_bit(port1, hub-&gt;busy_bits);
 	if (!hub-&gt;hdev-&gt;parent &amp;&amp; !hub-&gt;busy_bits[0])
@@ -1849,30 +1852,6 @@ hub_port_resume(struct usb_hub *hub, int port1, struct usb_device *udev)
 	return status;
 }
 
-/*
- * usb_port_resume - re-activate a suspended usb device's upstream port
- * @udev: device to re-activate
- * Context: must be able to sleep; device not locked; pm locks held
- *
- * This will re-activate the suspended device, increasing power usage
- * while letting drivers communicate again with its endpoints.
- * USB resume explicitly guarantees that the power session between
- * the host and the device is the same as it was when the device
- * suspended.
- *
- * Returns 0 on success, else negative errno.
- */
-int usb_port_resume(struct usb_device *udev)
-{
-	int	status;
-
-	status = hub_port_resume(hdev_to_hub(udev-&gt;parent),
-			udev-&gt;portnum, udev);
-	if (status &lt; 0)
-		dev_dbg(&amp;udev-&gt;dev, "can't resume, status %d\n", status);
-	return status;
-}
-
 static int remote_wakeup(struct usb_device *udev)
 {
 	int	status = 0;
@@ -1896,18 +1875,6 @@ int usb_port_suspend(struct usb_device *udev)
 	return 0;
 }
 
-static inline int
-finish_port_resume(struct usb_device *udev)
-{
-	return 0;
-}
-
-static inline int
-hub_port_resume(struct usb_hub *hub, int port1, struct usb_device *udev)
-{
-	return 0;
-}
-
 int usb_port_resume(struct usb_device *udev)
 {
 	return 0;</pre><hr><pre>commit 686314cfbdac21c9019c0e04487b5d940db62406
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed May 30 15:34:36 2007 -0400

    USB: separate root and non-root suspend/resume
    
    This patch (as916) completes the separation of code paths for suspend
    and resume of root hubs as opposed to non-root devices.  Root hubs
    will be power-managed through their bus_suspend and bus_resume
    methods, whereas normal devices will use usb_port_suspend() and
    usb_port_resume().
    
    Changes to the hcd_bus_{suspend,resume} routines mostly represent
    motion of code that was already present elsewhere.  They include:
    
            Adding debugging log messages,
    
            Setting the device state appropriately, and
    
            Adding a resume recovery time delay.
    
    Changes to the port-suspend and port-resume routines in hub.c include:
    
            Removal of checks for root devices (since they will never
            be triggered), and
    
            Removal of checks for NULL or invalid device pointers (these
            were left over from earlier kernel versions and aren't needed
            at all).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index d363b0ea7345..4cbe7b339513 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -196,20 +196,15 @@ static int generic_suspend(struct usb_device *udev, pm_message_t msg)
 {
 	int rc;
 
-	rc = usb_port_suspend(udev);
-
-	/* Root hubs don't have upstream ports to suspend,
-	 * so the line above won't do much for them.  We have to
-	 * shut down their downstream HC-to-USB interfaces manually,
-	 * by doing a bus (or "global") suspend.
+	/* Normal USB devices suspend through their upstream port.
+	 * Root hubs don't have upstream ports to suspend,
+	 * so we have to shut down their downstream HC-to-USB
+	 * interfaces manually by doing a bus (or "global") suspend.
 	 */
-	if (rc == 0 &amp;&amp; !udev-&gt;parent) {
-		rc = hcd_bus_suspend(udev-&gt;bus);
-		if (rc) {
-			dev_dbg(&amp;udev-&gt;dev, "'global' suspend %d\n", rc);
-			usb_port_resume(udev);
-		}
-	}
+	if (!udev-&gt;parent)
+		rc = hcd_bus_suspend(udev);
+	else
+		rc = usb_port_suspend(udev);
 	return rc;
 }
 
@@ -217,25 +212,17 @@ static int generic_resume(struct usb_device *udev)
 {
 	int rc;
 
-	if (udev-&gt;reset_resume)
+	/* Normal USB devices resume/reset through their upstream port.
+	 * Root hubs don't have upstream ports to resume or reset,
+	 * so we have to start up their downstream HC-to-USB
+	 * interfaces manually by doing a bus (or "global") resume.
+	 */
+	if (!udev-&gt;parent)
+		rc = hcd_bus_resume(udev);
+	else if (udev-&gt;reset_resume)
 		rc = usb_reset_suspended_device(udev);
 	else
 		rc = usb_port_resume(udev);
-
-	/* Root hubs don't have upstream ports to resume or reset,
-	 * so the line above won't do much for them.  We have to
-	 * start up their downstream HC-to-USB interfaces manually,
-	 * by doing a bus (or "global") resume.
-	 */
-	if (rc == 0 &amp;&amp; !udev-&gt;parent) {
-		rc = hcd_bus_resume(udev-&gt;bus);
-		if (rc)
-			dev_dbg(&amp;udev-&gt;dev, "'global' resume %d\n", rc);
-		else {
-			/* TRSMRCY = 10 msec */
-			msleep(10);
-		}
-	}
 	return rc;
 }
 
diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 87d6edf11f92..e5058fb26a7e 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1257,40 +1257,54 @@ void usb_hcd_endpoint_disable (struct usb_device *udev,
 
 #ifdef	CONFIG_PM
 
-int hcd_bus_suspend (struct usb_bus *bus)
+int hcd_bus_suspend(struct usb_device *rhdev)
 {
-	struct usb_hcd		*hcd;
-	int			status;
+	struct usb_hcd	*hcd = container_of(rhdev-&gt;bus, struct usb_hcd, self);
+	int		status;
+	int		old_state = hcd-&gt;state;
 
-	hcd = container_of (bus, struct usb_hcd, self);
-	if (!hcd-&gt;driver-&gt;bus_suspend)
-		return -ENOENT;
-	hcd-&gt;state = HC_STATE_QUIESCING;
-	status = hcd-&gt;driver-&gt;bus_suspend (hcd);
-	if (status == 0)
+	dev_dbg(&amp;rhdev-&gt;dev, "bus %s%s\n",
+			rhdev-&gt;auto_pm ? "auto-" : "", "suspend");
+	if (!hcd-&gt;driver-&gt;bus_suspend) {
+		status = -ENOENT;
+	} else {
+		hcd-&gt;state = HC_STATE_QUIESCING;
+		status = hcd-&gt;driver-&gt;bus_suspend(hcd);
+	}
+	if (status == 0) {
+		usb_set_device_state(rhdev, USB_STATE_SUSPENDED);
 		hcd-&gt;state = HC_STATE_SUSPENDED;
-	else
-		dev_dbg(&amp;bus-&gt;root_hub-&gt;dev, "%s fail, err %d\n",
+	} else {
+		hcd-&gt;state = old_state;
+		dev_dbg(&amp;rhdev-&gt;dev, "bus %s fail, err %d\n",
 				"suspend", status);
+	}
 	return status;
 }
 
-int hcd_bus_resume (struct usb_bus *bus)
+int hcd_bus_resume(struct usb_device *rhdev)
 {
-	struct usb_hcd		*hcd;
-	int			status;
+	struct usb_hcd	*hcd = container_of(rhdev-&gt;bus, struct usb_hcd, self);
+	int		status;
 
-	hcd = container_of (bus, struct usb_hcd, self);
+	dev_dbg(&amp;rhdev-&gt;dev, "usb %s%s\n",
+			rhdev-&gt;auto_pm ? "auto-" : "", "resume");
 	if (!hcd-&gt;driver-&gt;bus_resume)
 		return -ENOENT;
 	if (hcd-&gt;state == HC_STATE_RUNNING)
 		return 0;
+
 	hcd-&gt;state = HC_STATE_RESUMING;
-	status = hcd-&gt;driver-&gt;bus_resume (hcd);
-	if (status == 0)
+	status = hcd-&gt;driver-&gt;bus_resume(hcd);
+	if (status == 0) {
+		/* TRSMRCY = 10 msec */
+		msleep(10);
+		usb_set_device_state(rhdev, rhdev-&gt;actconfig
+				? USB_STATE_CONFIGURED
+				: USB_STATE_ADDRESS);
 		hcd-&gt;state = HC_STATE_RUNNING;
-	else {
-		dev_dbg(&amp;bus-&gt;root_hub-&gt;dev, "%s fail, err %d\n",
+	} else {
+		dev_dbg(&amp;rhdev-&gt;dev, "bus %s fail, err %d\n",
 				"resume", status);
 		usb_hc_died(hcd);
 	}
diff --git a/drivers/usb/core/hcd.h b/drivers/usb/core/hcd.h
index ef50fa494e47..b5ebb73c2332 100644
--- a/drivers/usb/core/hcd.h
+++ b/drivers/usb/core/hcd.h
@@ -364,23 +364,13 @@ extern int usb_find_interface_driver (struct usb_device *dev,
 #ifdef CONFIG_PM
 extern void usb_hcd_resume_root_hub (struct usb_hcd *hcd);
 extern void usb_root_hub_lost_power (struct usb_device *rhdev);
-extern int hcd_bus_suspend (struct usb_bus *bus);
-extern int hcd_bus_resume (struct usb_bus *bus);
+extern int hcd_bus_suspend(struct usb_device *rhdev);
+extern int hcd_bus_resume(struct usb_device *rhdev);
 #else
 static inline void usb_hcd_resume_root_hub(struct usb_hcd *hcd)
 {
 	return;
 }
-
-static inline int hcd_bus_suspend(struct usb_bus *bus)
-{
-	return 0;
-}
-
-static inline int hcd_bus_resume (struct usb_bus *bus)
-{
-	return 0;
-}
 #endif /* CONFIG_PM */
 
 /*
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 04d6fde57d88..ac1ef1527dd2 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1722,17 +1722,8 @@ int usb_port_suspend(struct usb_device *udev)
 {
 	int	status = 0;
 
-	/* we change the device's upstream USB link,
-	 * but root hubs have no upstream USB link.
-	 */
-	if (udev-&gt;parent)
-		status = hub_port_suspend(hdev_to_hub(udev-&gt;parent),
-				udev-&gt;portnum, udev);
-	else {
-		dev_dbg(&amp;udev-&gt;dev, "usb %ssuspend\n",
-				udev-&gt;auto_pm ? "auto-" : "");
-		usb_set_device_state(udev, USB_STATE_SUSPENDED);
-	}
+	status = hub_port_suspend(hdev_to_hub(udev-&gt;parent),
+			udev-&gt;portnum, udev);
 	return status;
 }
 
@@ -1775,8 +1766,7 @@ static int finish_port_resume(struct usb_device *udev)
 			status);
 	else if (udev-&gt;actconfig) {
 		le16_to_cpus(&amp;devstatus);
-		if ((devstatus &amp; (1 &lt;&lt; USB_DEVICE_REMOTE_WAKEUP))
-				&amp;&amp; udev-&gt;parent) {
+		if (devstatus &amp; (1 &lt;&lt; USB_DEVICE_REMOTE_WAKEUP)) {
 			status = usb_control_msg(udev,
 					usb_sndctrlpipe(udev, 0),
 					USB_REQ_CLEAR_FEATURE,
@@ -1789,10 +1779,6 @@ static int finish_port_resume(struct usb_device *udev)
 					"wakeup, status %d\n", status);
 		}
 		status = 0;
-
-	} else if (udev-&gt;devnum &lt;= 0) {
-		dev_dbg(&amp;udev-&gt;dev, "bogus resume!\n");
-		status = -EINVAL;
 	}
 	return status;
 }
@@ -1821,9 +1807,8 @@ hub_port_resume(struct usb_hub *hub, int port1, struct usb_device *udev)
 			port1, status);
 	} else {
 		/* drive resume for at least 20 msec */
-		if (udev)
-			dev_dbg(&amp;udev-&gt;dev, "usb %sresume\n",
-					udev-&gt;auto_pm ? "auto-" : "");
+		dev_dbg(&amp;udev-&gt;dev, "usb %sresume\n",
+				udev-&gt;auto_pm ? "auto-" : "");
 		msleep(25);
 
 #define LIVE_FLAGS	( USB_PORT_STAT_POWER \
@@ -1851,8 +1836,7 @@ hub_port_resume(struct usb_hub *hub, int port1, struct usb_device *udev)
 						USB_PORT_FEAT_C_SUSPEND);
 			/* TRSMRCY = 10 msec */
 			msleep(10);
-			if (udev)
-				status = finish_port_resume(udev);
+			status = finish_port_resume(udev);
 		}
 	}
 	if (status &lt; 0)
@@ -1882,18 +1866,8 @@ int usb_port_resume(struct usb_device *udev)
 {
 	int	status;
 
-	/* we change the device's upstream USB link,
-	 * but root hubs have no upstream USB link.
-	 */
-	if (udev-&gt;parent) {
-		// NOTE this fails if parent is also suspended...
-		status = hub_port_resume(hdev_to_hub(udev-&gt;parent),
-				udev-&gt;portnum, udev);
-	} else {
-		dev_dbg(&amp;udev-&gt;dev, "usb %sresume\n",
-				udev-&gt;auto_pm ? "auto-" : "");
-		status = finish_port_resume(udev);
-	}
+	status = hub_port_resume(hdev_to_hub(udev-&gt;parent),
+			udev-&gt;portnum, udev);
 	if (status &lt; 0)
 		dev_dbg(&amp;udev-&gt;dev, "can't resume, status %d\n", status);
 	return status;</pre>
    <div class="pagination">
        <a href='2_105.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><span>[106]</span><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_107.html'>Next&gt;&gt;</a>
    <div>
</body>
