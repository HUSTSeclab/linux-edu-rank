<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_97.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><span>[98]</span><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_99.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 442258e2ff69276ff767f3703b30ce6a31fdd181
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Dec 6 14:47:08 2007 -0500

    USB: use IRQF_DISABLED for HCD interrupt handlers
    
    Host controller IRQs are supposed to be serviced with interrupts
    disabled.  This patch (as1026) adds an IRQF_DISABLED flag to all the
    controller drivers that lack it.  It also replaces the
    spin_lock_irqsave() and spin_unlock_irqrestore() calls in uhci_irq()
    with simple spin_lock() and spin_unlock().
    
    This fixes Bugzilla #9335.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: David Brownell &lt;david-b@pacbell.net&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd-pci.c b/drivers/usb/core/hcd-pci.c
index 5cf6d5f9acbd..3fb9af80cbf4 100644
--- a/drivers/usb/core/hcd-pci.c
+++ b/drivers/usb/core/hcd-pci.c
@@ -125,7 +125,7 @@ int usb_hcd_pci_probe (struct pci_dev *dev, const struct pci_device_id *id)
 
 	pci_set_master (dev);
 
-	retval = usb_add_hcd (hcd, dev-&gt;irq, IRQF_SHARED);
+	retval = usb_add_hcd(hcd, dev-&gt;irq, IRQF_DISABLED | IRQF_SHARED);
 	if (retval != 0)
 		goto err4;
 	return retval;
diff --git a/drivers/usb/host/ehci-fsl.c b/drivers/usb/host/ehci-fsl.c
index b7b7bfbce527..430821cb95c8 100644
--- a/drivers/usb/host/ehci-fsl.c
+++ b/drivers/usb/host/ehci-fsl.c
@@ -122,7 +122,7 @@ int usb_hcd_fsl_probe(const struct hc_driver *driver,
 	temp = in_le32(hcd-&gt;regs + 0x1a8);
 	out_le32(hcd-&gt;regs + 0x1a8, temp | 0x3);
 
-	retval = usb_add_hcd(hcd, irq, IRQF_SHARED);
+	retval = usb_add_hcd(hcd, irq, IRQF_DISABLED | IRQF_SHARED);
 	if (retval != 0)
 		goto err4;
 	return retval;
diff --git a/drivers/usb/host/ohci-ppc-of.c b/drivers/usb/host/ohci-ppc-of.c
index 0a7426920150..0c3e6b790b7b 100644
--- a/drivers/usb/host/ohci-ppc-of.c
+++ b/drivers/usb/host/ohci-ppc-of.c
@@ -142,7 +142,7 @@ ohci_hcd_ppc_of_probe(struct of_device *op, const struct of_device_id *match)
 
 	ohci_hcd_init(ohci);
 
-	rv = usb_add_hcd(hcd, irq, 0);
+	rv = usb_add_hcd(hcd, irq, IRQF_DISABLED);
 	if (rv == 0)
 		return 0;
 
diff --git a/drivers/usb/host/ohci-ssb.c b/drivers/usb/host/ohci-ssb.c
index fe70e72340de..6e9c2d6db887 100644
--- a/drivers/usb/host/ohci-ssb.c
+++ b/drivers/usb/host/ohci-ssb.c
@@ -160,7 +160,7 @@ static int ssb_ohci_attach(struct ssb_device *dev)
 	hcd-&gt;regs = ioremap_nocache(hcd-&gt;rsrc_start, hcd-&gt;rsrc_len);
 	if (!hcd-&gt;regs)
 		goto err_put_hcd;
-	err = usb_add_hcd(hcd, dev-&gt;irq, IRQF_SHARED);
+	err = usb_add_hcd(hcd, dev-&gt;irq, IRQF_DISABLED | IRQF_SHARED);
 	if (err)
 		goto err_iounmap;
 
diff --git a/drivers/usb/host/r8a66597-hcd.c b/drivers/usb/host/r8a66597-hcd.c
index ae8ec4474eb8..0ce2fc5e396b 100644
--- a/drivers/usb/host/r8a66597-hcd.c
+++ b/drivers/usb/host/r8a66597-hcd.c
@@ -2197,7 +2197,7 @@ static int __init r8a66597_probe(struct platform_device *pdev)
 	INIT_LIST_HEAD(&amp;r8a66597-&gt;child_device);
 
 	hcd-&gt;rsrc_start = res-&gt;start;
-	ret = usb_add_hcd(hcd, irq, 0);
+	ret = usb_add_hcd(hcd, irq, IRQF_DISABLED);
 	if (ret != 0) {
 		err("Failed to add hcd");
 		goto clean_up;
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 4db17f75f4f1..ec987897b8ed 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -378,7 +378,6 @@ static irqreturn_t uhci_irq(struct usb_hcd *hcd)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 	unsigned short status;
-	unsigned long flags;
 
 	/*
 	 * Read the interrupt status, and write it back to clear the
@@ -398,7 +397,7 @@ static irqreturn_t uhci_irq(struct usb_hcd *hcd)
 			dev_err(uhci_dev(uhci), "host controller process "
 					"error, something bad happened!\n");
 		if (status &amp; USBSTS_HCH) {
-			spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
+			spin_lock(&amp;uhci-&gt;lock);
 			if (uhci-&gt;rh_state &gt;= UHCI_RH_RUNNING) {
 				dev_err(uhci_dev(uhci),
 					"host controller halted, "
@@ -415,16 +414,16 @@ static irqreturn_t uhci_irq(struct usb_hcd *hcd)
 				 * pending unlinks */
 				mod_timer(&amp;hcd-&gt;rh_timer, jiffies);
 			}
-			spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
+			spin_unlock(&amp;uhci-&gt;lock);
 		}
 	}
 
 	if (status &amp; USBSTS_RD)
 		usb_hcd_poll_rh_status(hcd);
 	else {
-		spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
+		spin_lock(&amp;uhci-&gt;lock);
 		uhci_scan_schedule(uhci);
-		spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
+		spin_unlock(&amp;uhci-&gt;lock);
 	}
 
 	return IRQ_HANDLED;</pre><hr><pre>commit d48bd977e0dd8c17081d12242bfc09d743ea0d26
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Dec 11 16:02:23 2007 -0500

    USB: fix locking loop by avoiding flush_scheduled_work
    
    This patch (as1027) replaces a call to flush_scheduled_work() -- a
    dangerous routine to invoke, especially while holding any sort of lock
    -- with calls to cancel_work_sync() and cancel_delayed_work_sync().
    
    This fixes Bugzilla #9532.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 13b326a13377..b04d232d4c65 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -522,9 +522,9 @@ static void hub_quiesce(struct usb_hub *hub)
 	/* (blocking) stop khubd and related activity */
 	usb_kill_urb(hub-&gt;urb);
 	if (hub-&gt;has_indicators)
-		cancel_delayed_work(&amp;hub-&gt;leds);
-	if (hub-&gt;has_indicators || hub-&gt;tt.hub)
-		flush_scheduled_work();
+		cancel_delayed_work_sync(&amp;hub-&gt;leds);
+	if (hub-&gt;tt.hub)
+		cancel_work_sync(&amp;hub-&gt;tt.kevent);
 }
 
 static void hub_activate(struct usb_hub *hub)</pre><hr><pre>commit f1e8de0dbb9ee30cd6eb9c510249847d28443cb1
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Nov 26 10:23:05 2007 -0500

    USB: usb-storage: unusual_devs entry for JetFlash TS1GJF2A
    
    This patch (as1018) adds an unusual_devs entry for the JetFlash
    TS1GJF2A.  This device doesn't like read requests for more than 188
    sectors.  Setting max_sectors down to 64 is overkill, but at least
    it will work without errors.
    
    For the torturous debugging history, see this thread:
    
            http://marc.info/?t=118745764700005&amp;r=1&amp;w=2
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index 7398229c5255..2c27721bd259 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -731,6 +731,13 @@ UNUSUAL_DEV(  0x0584, 0x0008, 0x0102, 0x0102,
  		US_SC_SCSI, US_PR_ALAUDA, init_alauda, 0 ),
 #endif
 
+/* Reported by RTE &lt;raszilki@yandex.ru&gt; */
+UNUSUAL_DEV(  0x058f, 0x6387, 0x0141, 0x0141,
+		"JetFlash",
+		"TS1GJF2A/120",
+		US_SC_DEVICE, US_PR_DEVICE, NULL,
+		US_FL_MAX_SECTORS_64 ),
+
 /* Fabrizio Fellini &lt;fello@libero.it&gt; */
 UNUSUAL_DEV(  0x0595, 0x4343, 0x0000, 0x2210,
 		"Fujifilm",</pre><hr><pre>commit 4a9bee8256a2dec26290a3bfff86ab86b8992547
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Nov 6 15:01:52 2007 -0500

    USB: uevent environment key fix
    
    This patch (as1010) was written by both Kay Sievers and me.  It solves
    the problem of duplicated keys in USB uevent structures by refactoring
    the uevent subroutines, taking advantage of the way the hotplug core
    calls uevent handlers for the device's bus and for the device's type.
    Keys needed for both USB-device and USB-interface events are added in
    usb_uevent(), which is the bus handler.  Keys appropriate only for
    USB-device or USB-interface events are added in usb_dev_uevent() or
    usb_if_uevent() respectively, the type handlers.
    
    In addition, unnecessary tests for NULL pointers are removed as are
    duplicated debugging log statements.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: Kay Sievers &lt;kay.sievers@vrfy.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 8586817698ad..c51f8e9312e0 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -585,9 +585,6 @@ static int usb_uevent(struct device *dev, struct kobj_uevent_env *env)
 {
 	struct usb_device *usb_dev;
 
-	if (!dev)
-		return -ENODEV;
-
 	/* driver is often null here; dev_dbg() would oops */
 	pr_debug ("usb %s: uevent\n", dev-&gt;bus_id);
 
@@ -631,14 +628,6 @@ static int usb_uevent(struct device *dev, struct kobj_uevent_env *env)
 			   usb_dev-&gt;descriptor.bDeviceProtocol))
 		return -ENOMEM;
 
-	if (add_uevent_var(env, "BUSNUM=%03d",
-			   usb_dev-&gt;bus-&gt;busnum))
-		return -ENOMEM;
-
-	if (add_uevent_var(env, "DEVNUM=%03d",
-			   usb_dev-&gt;devnum))
-		return -ENOMEM;
-
 	return 0;
 }
 
diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 40fd39de5bf9..fcd40ecbeecc 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1346,34 +1346,10 @@ static int usb_if_uevent(struct device *dev, struct kobj_uevent_env *env)
 	struct usb_interface *intf;
 	struct usb_host_interface *alt;
 
-	if (!dev)
-		return -ENODEV;
-
-	/* driver is often null here; dev_dbg() would oops */
-	pr_debug ("usb %s: uevent\n", dev-&gt;bus_id);
-
 	intf = to_usb_interface(dev);
 	usb_dev = interface_to_usbdev(intf);
 	alt = intf-&gt;cur_altsetting;
 
-#ifdef CONFIG_USB_DEVICEFS
-	if (add_uevent_var(env, "DEVICE=/proc/bus/usb/%03d/%03d",
-			   usb_dev-&gt;bus-&gt;busnum, usb_dev-&gt;devnum))
-		return -ENOMEM;
-#endif
-
-	if (add_uevent_var(env, "PRODUCT=%x/%x/%x",
-			   le16_to_cpu(usb_dev-&gt;descriptor.idVendor),
-			   le16_to_cpu(usb_dev-&gt;descriptor.idProduct),
-			   le16_to_cpu(usb_dev-&gt;descriptor.bcdDevice)))
-		return -ENOMEM;
-
-	if (add_uevent_var(env, "TYPE=%d/%d/%d",
-			   usb_dev-&gt;descriptor.bDeviceClass,
-			   usb_dev-&gt;descriptor.bDeviceSubClass,
-			   usb_dev-&gt;descriptor.bDeviceProtocol))
-		return -ENOMEM;
-
 	if (add_uevent_var(env, "INTERFACE=%d/%d/%d",
 		   alt-&gt;desc.bInterfaceClass,
 		   alt-&gt;desc.bInterfaceSubClass,
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index c4a6f1095b8b..8f142370103d 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -192,9 +192,34 @@ static void usb_release_dev(struct device *dev)
 	kfree(udev);
 }
 
+#ifdef	CONFIG_HOTPLUG
+static int usb_dev_uevent(struct device *dev, struct kobj_uevent_env *env)
+{
+	struct usb_device *usb_dev;
+
+	usb_dev = to_usb_device(dev);
+
+	if (add_uevent_var(env, "BUSNUM=%03d", usb_dev-&gt;bus-&gt;busnum))
+		return -ENOMEM;
+
+	if (add_uevent_var(env, "DEVNUM=%03d", usb_dev-&gt;devnum))
+		return -ENOMEM;
+
+	return 0;
+}
+
+#else
+
+static int usb_dev_uevent(struct device *dev, struct kobj_uevent_env *env)
+{
+	return -ENODEV;
+}
+#endif	/* CONFIG_HOTPLUG */
+
 struct device_type usb_device_type = {
 	.name =		"usb_device",
 	.release =	usb_release_dev,
+	.uevent =	usb_dev_uevent,
 };
 
 #ifdef	CONFIG_PM</pre><hr><pre>commit 7e61559f6199bb387037abfc7d10a893973561fc
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Nov 6 11:43:42 2007 -0500

    USB: keep track of whether interface sysfs files exist
    
    This patch (as1009) solves the problem of multiple registrations for
    USB sysfs files in a more satisfying way than the existing code.  It
    simply adds a flag to keep track of whether or not the files have been
    created; that way the files can be created or removed as needed.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 316a746e0080..40fd39de5bf9 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1172,7 +1172,6 @@ int usb_set_interface(struct usb_device *dev, int interface, int alternate)
 	struct usb_host_interface *alt;
 	int ret;
 	int manual = 0;
-	int changed;
 
 	if (dev-&gt;state == USB_STATE_SUSPENDED)
 		return -EHOSTUNREACH;
@@ -1212,8 +1211,7 @@ int usb_set_interface(struct usb_device *dev, int interface, int alternate)
 	 */
 
 	/* prevent submissions using previous endpoint settings */
-	changed = (iface-&gt;cur_altsetting != alt);
-	if (changed &amp;&amp; device_is_registered(&amp;iface-&gt;dev))
+	if (iface-&gt;cur_altsetting != alt &amp;&amp; device_is_registered(&amp;iface-&gt;dev))
 		usb_remove_sysfs_intf_files(iface);
 	usb_disable_interface(dev, iface);
 
@@ -1250,7 +1248,7 @@ int usb_set_interface(struct usb_device *dev, int interface, int alternate)
 	 * (Likewise, EP0 never "halts" on well designed devices.)
 	 */
 	usb_enable_interface(dev, iface);
-	if (changed &amp;&amp; device_is_registered(&amp;iface-&gt;dev))
+	if (device_is_registered(&amp;iface-&gt;dev))
 		usb_create_sysfs_intf_files(iface);
 
 	return 0;
@@ -1641,12 +1639,6 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 				intf-&gt;dev.bus_id, ret);
 			continue;
 		}
-
-		/* The driver's probe method can call usb_set_interface(),
-		 * which would mean the interface's sysfs files are already
-		 * created.  Just in case, we'll remove them first.
-		 */
-		usb_remove_sysfs_intf_files(intf);
 		usb_create_sysfs_intf_files(intf);
 	}
 
diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c
index b04afd06e502..32bd130b1eed 100644
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -735,6 +735,8 @@ int usb_create_sysfs_intf_files(struct usb_interface *intf)
 	struct usb_host_interface *alt = intf-&gt;cur_altsetting;
 	int retval;
 
+	if (intf-&gt;sysfs_files_created)
+		return 0;
 	retval = sysfs_create_group(&amp;dev-&gt;kobj, &amp;intf_attr_grp);
 	if (retval)
 		return retval;
@@ -746,6 +748,7 @@ int usb_create_sysfs_intf_files(struct usb_interface *intf)
 	if (intf-&gt;intf_assoc)
 		retval = sysfs_create_group(&amp;dev-&gt;kobj, &amp;intf_assoc_attr_grp);
 	usb_create_intf_ep_files(intf, udev);
+	intf-&gt;sysfs_files_created = 1;
 	return 0;
 }
 
@@ -753,8 +756,11 @@ void usb_remove_sysfs_intf_files(struct usb_interface *intf)
 {
 	struct device *dev = &amp;intf-&gt;dev;
 
+	if (!intf-&gt;sysfs_files_created)
+		return;
 	usb_remove_intf_ep_files(intf);
 	device_remove_file(dev, &amp;dev_attr_interface);
 	sysfs_remove_group(&amp;dev-&gt;kobj, &amp;intf_attr_grp);
 	sysfs_remove_group(&amp;intf-&gt;dev.kobj, &amp;intf_assoc_attr_grp);
+	intf-&gt;sysfs_files_created = 0;
 }
diff --git a/include/linux/usb.h b/include/linux/usb.h
index c5c8f169d3cf..416ee7617d9e 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -157,6 +157,7 @@ struct usb_interface {
 					 * bound to */
 	enum usb_interface_condition condition;		/* state of binding */
 	unsigned is_active:1;		/* the interface is not suspended */
+	unsigned sysfs_files_created:1;	/* the sysfs attributes exist */
 	unsigned needs_remote_wakeup:1;	/* driver requires remote wakeup */
 
 	struct device dev;		/* interface specific device info */</pre><hr><pre>commit ddc1fd6ac1f3ad3275e19451fb07d2eff249161c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Nov 21 15:13:10 2007 -0800

    USB HCD: avoid duplicate local_irq_disable()
    
    Arnd Bergmann wrote:
    
    usb_hcd_flush_endpoint() has a retry loop that starts with a spin_lock_irq(),
    but only gives up the spinlock, not the irq_disable before jumping to the
    rescan label.
    
    Alan Stern:
    
    I agree with your sentiment, but it would be better to solve this
    problem without using local_irq_disable().
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: Arnd Bergmann &lt;arnd@arndb.de&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index fea8256a18d6..d5ed3fa9e304 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1311,8 +1311,8 @@ void usb_hcd_flush_endpoint(struct usb_device *udev,
 	hcd = bus_to_hcd(udev-&gt;bus);
 
 	/* No more submits can occur */
-rescan:
 	spin_lock_irq(&amp;hcd_urb_list_lock);
+rescan:
 	list_for_each_entry (urb, &amp;ep-&gt;urb_list, urb_list) {
 		int	is_in;
 
@@ -1345,6 +1345,7 @@ void usb_hcd_flush_endpoint(struct usb_device *udev,
 		usb_put_urb (urb);
 
 		/* list contents may have changed */
+		spin_lock(&amp;hcd_urb_list_lock);
 		goto rescan;
 	}
 	spin_unlock_irq(&amp;hcd_urb_list_lock);</pre><hr><pre>commit 3c886c50486cfbef2a2382b99bf4083a465c970a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Nov 16 11:58:15 2007 -0500

    USB: power-management documenation update
    
    This patch (as1014) was partly written by Tilman Schmidt.  It
    clarifies the USB power-management documentation by explaining that
    when a disconnect occurs, a suspend method call might not be followed
    by either a resume or a reset_resume call.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Tilman Schmidt &lt;tilman@imap.cc&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/Documentation/usb/power-management.txt b/Documentation/usb/power-management.txt
index 97842deec471..b2fc4d4a9917 100644
--- a/Documentation/usb/power-management.txt
+++ b/Documentation/usb/power-management.txt
@@ -278,6 +278,14 @@ optional.  The methods' jobs are quite simple:
 	(although the interfaces will be in the same altsettings as
 	before the suspend).
 
+If the device is disconnected or powered down while it is suspended,
+the disconnect method will be called instead of the resume or
+reset_resume method.  This is also quite likely to happen when
+waking up from hibernation, as many systems do not maintain suspend
+current to the USB host controllers during hibernation.  (It's
+possible to work around the hibernation-forces-disconnect problem by
+using the USB Persist facility.)
+
 The reset_resume method is used by the USB Persist facility (see
 Documentation/usb/persist.txt) and it can also be used under certain
 circumstances when CONFIG_USB_PERSIST is not enabled.  Currently, if a</pre><hr><pre>commit 439a903a9663c0caa8094f3907ca60069d6c36e7
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Oct 19 09:51:58 2007 -0400

    USB: fix interface sysfs file-creation bug
    
    This patch (as1005) fixes a rather subtle problem.  When
    usb_set_configuration() registers the interfaces and their files in
    sysfs, it doesn't expect those files to exist already.  But when an
    interface is registered, its driver may call usb_set_interface() and
    thereby cause the sysfs files to be created.  The result is an error
    when usb_set_configuration() goes on to create those same files again.
    
    The (not-so-great) solution is to have usb_set_configuration() remove
    any existing files before creating them.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 8bdaa157ffe7..eb4ac47612a5 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1641,7 +1641,13 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 				intf-&gt;dev.bus_id, ret);
 			continue;
 		}
-		usb_create_sysfs_intf_files (intf);
+
+		/* The driver's probe method can call usb_set_interface(),
+		 * which would mean the interface's sysfs files are already
+		 * created.  Just in case, we'll remove them first.
+		 */
+		usb_remove_sysfs_intf_files(intf);
+		usb_create_sysfs_intf_files(intf);
 	}
 
 	usb_autosuspend_device(dev);</pre><hr><pre>commit 7898ffc543566a9c4a1b4ff39f43857d2d84a51c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Oct 16 11:55:30 2007 -0400

    USB: fix scheduling of Iso URBs in uhci-hcd
    
    This patch (as1003) changes uhci-hcd to treat the URB_ISO_ASAP flag
    the same as other host controller drivers, namely, to schedule an Iso
    URB for the first available time slot that hasn't already expired.
    URBs in which the flag isn't set will be scheduled for the first slot
    following the last URB, even if it has expired.
    
    This fixes a problem reported by Martin Bachem.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index e5d60d5b105a..60379b17bbc1 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -1271,7 +1271,8 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb,
 	} else if (qh-&gt;period != urb-&gt;interval) {
 		return -EINVAL;		/* Can't change the period */
 
-	} else {	/* Pick up where the last URB leaves off */
+	} else {
+		/* Find the next unused frame */
 		if (list_empty(&amp;qh-&gt;queue)) {
 			frame = qh-&gt;iso_frame;
 		} else {
@@ -1283,10 +1284,18 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb,
 					lurb-&gt;number_of_packets *
 					lurb-&gt;interval;
 		}
-		if (urb-&gt;transfer_flags &amp; URB_ISO_ASAP)
-			urb-&gt;start_frame = frame;
-		else if (urb-&gt;start_frame != frame)
-			return -EINVAL;
+		if (urb-&gt;transfer_flags &amp; URB_ISO_ASAP) {
+			/* Skip some frames if necessary to insure
+			 * the start frame is in the future.
+			 */
+			uhci_get_current_frame_number(uhci);
+			if (uhci_frame_before_eq(frame, uhci-&gt;frame_number)) {
+				frame = uhci-&gt;frame_number + 1;
+				frame += ((qh-&gt;phase - frame) &amp;
+					(qh-&gt;period - 1));
+			}
+		}	/* Otherwise pick up where the last URB leaves off */
+		urb-&gt;start_frame = frame;
 	}
 
 	/* Make sure we won't have to go too far into the future */</pre><hr><pre>commit d1aa3e6aa8edfeb864af7c930523d9e588b28bea
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Oct 11 16:47:36 2007 -0400

    USB: fix race in autosuspend reschedule
    
    This patch (as1002) fixes a small race which can occur when a driver
    expects usbcore to reschedule an autosuspend request.  If the request
    arrives too late, it won't be rescheduled.  The patch adds an extra
    argument to autosuspend_check(), indicating that a reschedule is
    needed no matter how much time has elapsed.
    
    It also tries to avoid letting asynchronous changes to the value of
    jiffies cause a delay to become negative, by caching a local copy of
    the current time.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 8c1eac27f2de..c27bc080d84e 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -950,11 +950,11 @@ static int usb_resume_interface(struct usb_interface *intf, int reset_resume)
 #ifdef	CONFIG_USB_SUSPEND
 
 /* Internal routine to check whether we may autosuspend a device. */
-static int autosuspend_check(struct usb_device *udev)
+static int autosuspend_check(struct usb_device *udev, int reschedule)
 {
 	int			i;
 	struct usb_interface	*intf;
-	unsigned long		suspend_time;
+	unsigned long		suspend_time, j;
 
 	/* For autosuspend, fail fast if anything is in use or autosuspend
 	 * is disabled.  Also fail if any interfaces require remote wakeup
@@ -996,20 +996,20 @@ static int autosuspend_check(struct usb_device *udev)
 	}
 
 	/* If everything is okay but the device hasn't been idle for long
-	 * enough, queue a delayed autosuspend request.
+	 * enough, queue a delayed autosuspend request.  If the device
+	 * _has_ been idle for long enough and the reschedule flag is set,
+	 * likewise queue a delayed (1 second) autosuspend request.
 	 */
-	if (time_after(suspend_time, jiffies)) {
+	j = jiffies;
+	if (time_before(j, suspend_time))
+		reschedule = 1;
+	else
+		suspend_time = j + HZ;
+	if (reschedule) {
 		if (!timer_pending(&amp;udev-&gt;autosuspend.timer)) {
-
-			/* The value of jiffies may change between the
-			 * time_after() comparison above and the subtraction
-			 * below.  That's okay; the system behaves sanely
-			 * when a timer is registered for the present moment
-			 * or for the past.
-			 */
 			queue_delayed_work(ksuspend_usb_wq, &amp;udev-&gt;autosuspend,
-				round_jiffies_relative(suspend_time - jiffies));
-			}
+				round_jiffies_relative(suspend_time - j));
+		}
 		return -EAGAIN;
 	}
 	return 0;
@@ -1017,7 +1017,7 @@ static int autosuspend_check(struct usb_device *udev)
 
 #else
 
-static inline int autosuspend_check(struct usb_device *udev)
+static inline int autosuspend_check(struct usb_device *udev, int reschedule)
 {
 	return 0;
 }
@@ -1074,7 +1074,7 @@ static int usb_suspend_both(struct usb_device *udev, pm_message_t msg)
 	udev-&gt;do_remote_wakeup = device_may_wakeup(&amp;udev-&gt;dev);
 
 	if (udev-&gt;auto_pm) {
-		status = autosuspend_check(udev);
+		status = autosuspend_check(udev, 0);
 		if (status &lt; 0)
 			goto done;
 	}
@@ -1100,7 +1100,7 @@ static int usb_suspend_both(struct usb_device *udev, pm_message_t msg)
 
 		/* Try another autosuspend when the interfaces aren't busy */
 		if (udev-&gt;auto_pm)
-			autosuspend_check(udev);
+			autosuspend_check(udev, status == -EBUSY);
 
 	/* If the suspend succeeded then prevent any more URB submissions,
 	 * flush any outstanding URBs, and propagate the suspend up the tree.</pre>
    <div class="pagination">
        <a href='2_97.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><span>[98]</span><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_99.html'>Next&gt;&gt;</a>
    <div>
</body>
