<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_103.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><span>[104]</span><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_105.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit c39772d82ad453647ea4bf9d793010d86ef5e597
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Aug 20 10:45:28 2007 -0400

    USB: allow retry on descriptor fetch errors
    
    This patch (as964) was suggested by Steffen Koepf.  It makes
    usb_get_descriptor() retry on all errors other than ETIMEDOUT, instead
    of only on EPIPE.  This helps with some devices.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index b6bd05e3d439..5498506e9c5e 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -637,12 +637,12 @@ int usb_get_descriptor(struct usb_device *dev, unsigned char type, unsigned char
 	memset(buf,0,size);	// Make sure we parse really received data
 
 	for (i = 0; i &lt; 3; ++i) {
-		/* retry on length 0 or stall; some devices are flakey */
+		/* retry on length 0 or error; some devices are flakey */
 		result = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
 				USB_REQ_GET_DESCRIPTOR, USB_DIR_IN,
 				(type &lt;&lt; 8) + index, 0, buf, size,
 				USB_CTRL_GET_TIMEOUT);
-		if (result == 0 || result == -EPIPE)
+		if (result &lt;= 0 &amp;&amp; result != -ETIMEDOUT)
 			continue;
 		if (result &gt; 1 &amp;&amp; ((u8 *)buf)[1] != type) {
 			result = -EPROTO;</pre><hr><pre>commit 2f67cd5b1d5066d11761aebb0bf4b76bc253cc99
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Aug 16 16:16:00 2007 -0400

    usb-storage: fix bugs in the disconnect pathway
    
    This patch (as961) fixes a couple of bugs in the disconnect pathway of
    usb-storage.
    
    The first problem, which apparently has been around for a while
    although nobody noticed it, shows up when an aborted command is still
    pending when a disconnect occurs.  The SCSI error-handler will
    continue to wait in command_abort() until the us-&gt;notify completion is
    signalled.  Thus quiesce_and_remove_host() needs to signal it.
    
    The second problem was introduced recently along with autosuspend
    support.  Since usb_stor_scan_thread() now calls
    usb_autopm_put_interface() before exiting, we can't simply leave the
    scanning thread running after a disconnect; we must wait until the
    thread exits.  This is solved by adding a new struct completion to the
    private data structure.  Fortuitously, it allows the removal of the
    rather clunky mechanism used in the past to insure that all threads
    have finished before the module is unloaded.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Matthew Dharm &lt;mdharm-usb@one-eyed-alien.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/usb.c b/drivers/usb/storage/usb.c
index 28842d208bb0..25e557d4fe6b 100644
--- a/drivers/usb/storage/usb.c
+++ b/drivers/usb/storage/usb.c
@@ -112,13 +112,6 @@ module_param(delay_use, uint, S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(delay_use, "seconds to delay before using a new device");
 
 
-/* These are used to make sure the module doesn't unload before all the
- * threads have exited.
- */
-static atomic_t total_threads = ATOMIC_INIT(0);
-static DECLARE_COMPLETION(threads_gone);
-
-
 /*
  * The entries in this table correspond, line for line,
  * with the entries of us_unusual_dev_list[].
@@ -879,9 +872,6 @@ static void quiesce_and_remove_host(struct us_data *us)
 	usb_stor_stop_transport(us);
 	wake_up(&amp;us-&gt;delay_wait);
 
-	/* It doesn't matter if the SCSI-scanning thread is still running.
-	 * The thread will exit when it sees the DISCONNECTING flag. */
-
 	/* queuecommand won't accept any new commands and the control
 	 * thread won't execute a previously-queued command.  If there
 	 * is such a command pending, complete it with an error. */
@@ -891,12 +881,16 @@ static void quiesce_and_remove_host(struct us_data *us)
 		scsi_lock(host);
 		us-&gt;srb-&gt;scsi_done(us-&gt;srb);
 		us-&gt;srb = NULL;
+		complete(&amp;us-&gt;notify);		/* in case of an abort */
 		scsi_unlock(host);
 	}
 	mutex_unlock(&amp;us-&gt;dev_mutex);
 
 	/* Now we own no commands so it's safe to remove the SCSI host */
 	scsi_remove_host(host);
+
+	/* Wait for the SCSI-scanning thread to stop */
+	wait_for_completion(&amp;us-&gt;scanning_done);
 }
 
 /* Second stage of disconnect processing: deallocate all resources */
@@ -947,9 +941,8 @@ static int usb_stor_scan_thread(void * __us)
 		/* Should we unbind if no devices were detected? */
 	}
 
-	scsi_host_put(us_to_host(us));
 	usb_autopm_put_interface(us-&gt;pusb_intf);
-	complete_and_exit(&amp;threads_gone, 0);
+	complete_and_exit(&amp;us-&gt;scanning_done, 0);
 }
 
 
@@ -984,6 +977,7 @@ static int storage_probe(struct usb_interface *intf,
 	init_MUTEX_LOCKED(&amp;(us-&gt;sema));
 	init_completion(&amp;(us-&gt;notify));
 	init_waitqueue_head(&amp;us-&gt;delay_wait);
+	init_completion(&amp;us-&gt;scanning_done);
 
 	/* Associate the us_data structure with the USB device */
 	result = associate_dev(us, intf);
@@ -1033,11 +1027,6 @@ static int storage_probe(struct usb_interface *intf,
 		goto BadDevice;
 	}
 
-	/* Take a reference to the host for the scanning thread and
-	 * count it among all the threads we have launched.  Then
-	 * start it up. */
-	scsi_host_get(us_to_host(us));
-	atomic_inc(&amp;total_threads);
 	usb_autopm_get_interface(intf); /* dropped in the scanning thread */
 	wake_up_process(th);
 
@@ -1104,16 +1093,6 @@ static void __exit usb_stor_exit(void)
 	US_DEBUGP("-- calling usb_deregister()\n");
 	usb_deregister(&amp;usb_storage_driver) ;
 
-	/* Don't return until all of our control and scanning threads
-	 * have exited.  Since each thread signals threads_gone as its
-	 * last act, we have to call wait_for_completion the right number
-	 * of times.
-	 */
-	while (atomic_read(&amp;total_threads) &gt; 0) {
-		wait_for_completion(&amp;threads_gone);
-		atomic_dec(&amp;total_threads);
-	}
-
 	usb_usual_clear_present(USB_US_TYPE_STOR);
 }
 
diff --git a/drivers/usb/storage/usb.h b/drivers/usb/storage/usb.h
index 6445665b1577..8d87503e2560 100644
--- a/drivers/usb/storage/usb.h
+++ b/drivers/usb/storage/usb.h
@@ -150,6 +150,7 @@ struct us_data {
 	struct semaphore	sema;		 /* to sleep thread on	    */
 	struct completion	notify;		 /* thread begin/end	    */
 	wait_queue_head_t	delay_wait;	 /* wait during scan, reset */
+	struct completion	scanning_done;	 /* wait for scan thread    */
 
 	/* subdriver information */
 	void			*extra;		 /* Any extra data          */</pre><hr><pre>commit 46dede4690bbb23a2c9d60561e2e4fdc3e6bee61
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Aug 14 10:56:10 2007 -0400

    USB: accept 1-byte Device Status replies, fixing some b0rken devices
    
    Some devices have a bug which causes them to send a 1-byte reply to
    Get-Device-Status requests instead of 2 bytes as required by the
    spec.  This doesn't play well with autosuspend, since we look for a
    valid status reply to make sure the device is still present when it
    resumes.  Without both bytes, we assume the device has been
    disconnected.
    
    Lack of the second byte shouldn't matter much, since the spec requires
    it always to be equal to 0.  Hence this patch (as959) causes
    finish_port_resume() to accept a 1-byte reply as valid.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: David Brownell &lt;david-b@pacbell.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index e341a1da517f..f7b337feb3ea 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1644,9 +1644,10 @@ static int finish_port_resume(struct usb_device *udev)
 	 * and device drivers will know about any resume quirks.
 	 */
 	if (status == 0) {
+		devstatus = 0;
 		status = usb_get_status(udev, USB_RECIP_DEVICE, 0, &amp;devstatus);
 		if (status &gt;= 0)
-			status = (status == 2 ? 0 : -ENODEV);
+			status = (status &gt; 0 ? 0 : -ENODEV);
 	}
 
 	if (status) {</pre><hr><pre>commit 0bd307e1b950e0aca1dbbc2b76f542f9c96b9a95
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 8 17:16:12 2007 -0400

    USB: remove DEBUG definition from dummy_hcd
    
    This patch (as958) removes an unneeded and unwanted #define line from
    dummy_hcd.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index f2fbdc7fe376..d008d1360a7a 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -34,8 +34,6 @@
  * bypassing some hardware (and driver) issues.  UML could help too.
  */
 
-#define DEBUG
-
 #include &lt;linux/module.h&gt;
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/delay.h&gt;</pre><hr><pre>commit 74da5d68a54d66667664fbe233ededab2376a070
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Aug 2 13:29:10 2007 -0400

    USB: cdc-acm: fix sysfs attribute registration bug
    
    This patch (as950) fixes a bug in the cdc-acm driver.  It doesn't keep
    track of which interface (control or data) the sysfs attributes get
    registered for, and as a result, during disconnect it will sometimes
    attempt to remove the attributes from the wrong interface.  The
    left-over attributes can cause a crash later on, particularly if the driver
    module has been unloaded.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Oliver Neukum &lt;oneukum@suse.de&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/class/cdc-acm.c b/drivers/usb/class/cdc-acm.c
index fe940e0536e0..f51e22490edf 100644
--- a/drivers/usb/class/cdc-acm.c
+++ b/drivers/usb/class/cdc-acm.c
@@ -921,6 +921,10 @@ static int acm_probe (struct usb_interface *intf,
 			return -EINVAL;
 		}
 	}
+
+	/* Accept probe requests only for the control interface */
+	if (intf != control_interface)
+		return -ENODEV;
 	
 	if (usb_interface_claimed(data_interface)) { /* valid in this context */
 		dev_dbg(&amp;intf-&gt;dev,"The data interface isn't available");
@@ -1109,10 +1113,12 @@ static void acm_disconnect(struct usb_interface *intf)
 		return;
 	}
 	if (acm-&gt;country_codes){
-		device_remove_file(&amp;intf-&gt;dev, &amp;dev_attr_wCountryCodes);
-		device_remove_file(&amp;intf-&gt;dev, &amp;dev_attr_iCountryCodeRelDate);
+		device_remove_file(&amp;acm-&gt;control-&gt;dev,
+				&amp;dev_attr_wCountryCodes);
+		device_remove_file(&amp;acm-&gt;control-&gt;dev,
+				&amp;dev_attr_iCountryCodeRelDate);
 	}
-	device_remove_file(&amp;intf-&gt;dev, &amp;dev_attr_bmCapabilities);
+	device_remove_file(&amp;acm-&gt;control-&gt;dev, &amp;dev_attr_bmCapabilities);
 	acm-&gt;dev = NULL;
 	usb_set_intfdata(acm-&gt;control, NULL);
 	usb_set_intfdata(acm-&gt;data, NULL);</pre><hr><pre>commit eb9a9a56316f4fea98ee32873ccbf7098b7bd69b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 10 13:01:07 2007 -0700

    hex_dump: add missing "const" qualifiers
    
    Add missing "const" qualifiers to the print_hex_dump_bytes() library routines.
    
    (akpm: rumoured to fix some compile warning somewhere)
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: Artem Bityutskiy &lt;Artem.Bityutskiy@nokia.com&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;

diff --git a/include/linux/kernel.h b/include/linux/kernel.h
index b4f5b81b4257..f592df74b3cf 100644
--- a/include/linux/kernel.h
+++ b/include/linux/kernel.h
@@ -226,7 +226,7 @@ extern void print_hex_dump(const char *level, const char *prefix_str,
 				int prefix_type, int rowsize, int groupsize,
 				const void *buf, size_t len, bool ascii);
 extern void print_hex_dump_bytes(const char *prefix_str, int prefix_type,
-			void *buf, size_t len);
+			const void *buf, size_t len);
 #define hex_asc(x)	"0123456789abcdef"[x]
 
 #ifdef DEBUG
diff --git a/lib/hexdump.c b/lib/hexdump.c
index 16f2e2935e87..bd5edaeaa80b 100644
--- a/lib/hexdump.c
+++ b/lib/hexdump.c
@@ -189,7 +189,7 @@ EXPORT_SYMBOL(print_hex_dump);
  * rowsize of 16, groupsize of 1, and ASCII output included.
  */
 void print_hex_dump_bytes(const char *prefix_str, int prefix_type,
-			void *buf, size_t len)
+			const void *buf, size_t len)
 {
 	print_hex_dump(KERN_DEBUG, prefix_str, prefix_type, 16, 1,
 			buf, len, 1);</pre><hr><pre>commit 67f5dde3d4961032aeeecaf0d1c7a9232bef3f44
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jul 24 18:23:23 2007 -0400

    USB: Fix a bug in usb_start_wait_urb
    
    This patch (as941) fixes a bug recently added to the USB synchronous
    API.  The status of a completed URB must be preserved separately
    across a completion callback.  Also, the actual_length value isn't
    available until after the URB has fully completed.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index ad4b956380d2..b6bd05e3d439 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -18,9 +18,17 @@
 #include "hcd.h"	/* for usbcore internals */
 #include "usb.h"
 
+struct api_context {
+	struct completion	done;
+	int			status;
+};
+
 static void usb_api_blocking_completion(struct urb *urb)
 {
-	complete((struct completion *)urb-&gt;context);
+	struct api_context *ctx = urb-&gt;context;
+
+	ctx-&gt;status = urb-&gt;status;
+	complete(&amp;ctx-&gt;done);
 }
 
 
@@ -32,20 +40,21 @@ static void usb_api_blocking_completion(struct urb *urb)
  */
 static int usb_start_wait_urb(struct urb *urb, int timeout, int *actual_length)
 { 
-	struct completion done;
+	struct api_context ctx;
 	unsigned long expire;
 	int retval;
-	int status = urb-&gt;status;
 
-	init_completion(&amp;done); 	
-	urb-&gt;context = &amp;done;
+	init_completion(&amp;ctx.done);
+	urb-&gt;context = &amp;ctx;
 	urb-&gt;actual_length = 0;
 	retval = usb_submit_urb(urb, GFP_NOIO);
 	if (unlikely(retval))
 		goto out;
 
 	expire = timeout ? msecs_to_jiffies(timeout) : MAX_SCHEDULE_TIMEOUT;
-	if (!wait_for_completion_timeout(&amp;done, expire)) {
+	if (!wait_for_completion_timeout(&amp;ctx.done, expire)) {
+		usb_kill_urb(urb);
+		retval = (ctx.status == -ENOENT ? -ETIMEDOUT : ctx.status);
 
 		dev_dbg(&amp;urb-&gt;dev-&gt;dev,
 			"%s timed out on ep%d%s len=%d/%d\n",
@@ -54,11 +63,8 @@ static int usb_start_wait_urb(struct urb *urb, int timeout, int *actual_length)
 			usb_pipein(urb-&gt;pipe) ? "in" : "out",
 			urb-&gt;actual_length,
 			urb-&gt;transfer_buffer_length);
-
-		usb_kill_urb(urb);
-		retval = status == -ENOENT ? -ETIMEDOUT : status;
 	} else
-		retval = status;
+		retval = ctx.status;
 out:
 	if (actual_length)
 		*actual_length = urb-&gt;actual_length;</pre><hr><pre>commit bb1995d52b05f7e671914454d0ae57bd4170ef47
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Jul 21 17:10:42 2007 +0200

    x86: Make Alt-SysRq-p display the debug register contents
    
    This patch (as921) adds code to the show_regs() routine in i386 and x86_64
    to print the contents of the debug registers along with all the others.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Roland McGrath &lt;roland@redhat.com&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;
    Signed-off-by: Andi Kleen &lt;ak@suse.de&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;

diff --git a/arch/i386/kernel/process.c b/arch/i386/kernel/process.c
index 6c49acb96982..84664710b784 100644
--- a/arch/i386/kernel/process.c
+++ b/arch/i386/kernel/process.c
@@ -300,6 +300,7 @@ early_param("idle", idle_setup);
 void show_regs(struct pt_regs * regs)
 {
 	unsigned long cr0 = 0L, cr2 = 0L, cr3 = 0L, cr4 = 0L;
+	unsigned long d0, d1, d2, d3, d6, d7;
 
 	printk("\n");
 	printk("Pid: %d, comm: %20s\n", current-&gt;pid, current-&gt;comm);
@@ -324,6 +325,17 @@ void show_regs(struct pt_regs * regs)
 	cr3 = read_cr3();
 	cr4 = read_cr4_safe();
 	printk("CR0: %08lx CR2: %08lx CR3: %08lx CR4: %08lx\n", cr0, cr2, cr3, cr4);
+
+	get_debugreg(d0, 0);
+	get_debugreg(d1, 1);
+	get_debugreg(d2, 2);
+	get_debugreg(d3, 3);
+	printk("DR0: %08lx DR1: %08lx DR2: %08lx DR3: %08lx\n",
+			d0, d1, d2, d3);
+	get_debugreg(d6, 6);
+	get_debugreg(d7, 7);
+	printk("DR6: %08lx DR7: %08lx\n", d6, d7);
+
 	show_trace(NULL, regs, &amp;regs-&gt;esp);
 }
 
diff --git a/arch/x86_64/kernel/process.c b/arch/x86_64/kernel/process.c
index 180f4c0fcbc4..bbfc957f045f 100644
--- a/arch/x86_64/kernel/process.c
+++ b/arch/x86_64/kernel/process.c
@@ -306,6 +306,7 @@ early_param("idle", idle_setup);
 void __show_regs(struct pt_regs * regs)
 {
 	unsigned long cr0 = 0L, cr2 = 0L, cr3 = 0L, cr4 = 0L, fs, gs, shadowgs;
+	unsigned long d0, d1, d2, d3, d6, d7;
 	unsigned int fsindex,gsindex;
 	unsigned int ds,cs,es; 
 
@@ -350,6 +351,15 @@ void __show_regs(struct pt_regs * regs)
 	       fs,fsindex,gs,gsindex,shadowgs); 
 	printk("CS:  %04x DS: %04x ES: %04x CR0: %016lx\n", cs, ds, es, cr0); 
 	printk("CR2: %016lx CR3: %016lx CR4: %016lx\n", cr2, cr3, cr4);
+
+	get_debugreg(d0, 0);
+	get_debugreg(d1, 1);
+	get_debugreg(d2, 2);
+	printk("DR0: %016lx DR1: %016lx DR2: %016lx\n", d0, d1, d2);
+	get_debugreg(d3, 3);
+	get_debugreg(d6, 6);
+	get_debugreg(d7, 7);
+	printk("DR3: %016lx DR6: %016lx DR7: %016lx\n", d3, d6, d7);
 }
 
 void show_regs(struct pt_regs *regs)</pre><hr><pre>commit 809a58b896ba07e771adc76a47c83e4ca1969da8
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 18 12:14:24 2007 -0400

    USB: change name of spinlock in hcd.c
    
    This patch (as940 renames hcd_data_lock in hcd.c to hcd_urb_list_lock,
    which is more descriptive of the lock's job.  It also introduces a
    convenient inline routine for testing whether a particular USB device
    is a root hub.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 032b118c2883..42ef1d5f6c8a 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -99,12 +99,17 @@ EXPORT_SYMBOL_GPL (usb_bus_list_lock);
 /* used for controlling access to virtual root hubs */
 static DEFINE_SPINLOCK(hcd_root_hub_lock);
 
-/* used when updating hcd data */
-static DEFINE_SPINLOCK(hcd_data_lock);
+/* used when updating an endpoint's URB list */
+static DEFINE_SPINLOCK(hcd_urb_list_lock);
 
 /* wait queue for synchronous unlinks */
 DECLARE_WAIT_QUEUE_HEAD(usb_kill_urb_queue);
 
+static inline int is_root_hub(struct usb_device *udev)
+{
+	return (udev-&gt;parent == NULL);
+}
+
 /*-------------------------------------------------------------------------*/
 
 /*
@@ -906,14 +911,13 @@ EXPORT_SYMBOL (usb_calc_bus_time);
 static void urb_unlink(struct usb_hcd *hcd, struct urb *urb)
 {
 	unsigned long		flags;
-	int at_root_hub = (urb-&gt;dev == hcd-&gt;self.root_hub);
 
 	/* clear all state linking urb to this dev (and hcd) */
-	spin_lock_irqsave (&amp;hcd_data_lock, flags);
+	spin_lock_irqsave(&amp;hcd_urb_list_lock, flags);
 	list_del_init (&amp;urb-&gt;urb_list);
-	spin_unlock_irqrestore (&amp;hcd_data_lock, flags);
+	spin_unlock_irqrestore(&amp;hcd_urb_list_lock, flags);
 
-	if (hcd-&gt;self.uses_dma &amp;&amp; !at_root_hub) {
+	if (hcd-&gt;self.uses_dma &amp;&amp; !is_root_hub(urb-&gt;dev)) {
 		if (usb_pipecontrol (urb-&gt;pipe)
 			&amp;&amp; !(urb-&gt;transfer_flags &amp; URB_NO_SETUP_DMA_MAP))
 			dma_unmap_single (hcd-&gt;self.controller, urb-&gt;setup_dma,
@@ -955,7 +959,7 @@ int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
 
 	// FIXME:  verify that quiescing hc works right (RH cleans up)
 
-	spin_lock_irqsave (&amp;hcd_data_lock, flags);
+	spin_lock_irqsave(&amp;hcd_urb_list_lock, flags);
 	ep = (usb_pipein(urb-&gt;pipe) ? urb-&gt;dev-&gt;ep_in : urb-&gt;dev-&gt;ep_out)
 			[usb_pipeendpoint(urb-&gt;pipe)];
 	if (unlikely (!ep))
@@ -972,7 +976,7 @@ int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
 		status = -ESHUTDOWN;
 		break;
 	}
-	spin_unlock_irqrestore (&amp;hcd_data_lock, flags);
+	spin_unlock_irqrestore(&amp;hcd_urb_list_lock, flags);
 	if (status) {
 		INIT_LIST_HEAD (&amp;urb-&gt;urb_list);
 		usbmon_urb_submit_error(&amp;hcd-&gt;self, urb, status);
@@ -986,7 +990,7 @@ int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
 	urb = usb_get_urb (urb);
 	atomic_inc (&amp;urb-&gt;use_count);
 
-	if (urb-&gt;dev == hcd-&gt;self.root_hub) {
+	if (is_root_hub(urb-&gt;dev)) {
 		/* NOTE:  requirement on hub callers (usbfs and the hub
 		 * driver, for now) that URBs' urb-&gt;transfer_buffer be
 		 * valid and usb_buffer_{sync,unmap}() not be needed, since
@@ -1043,7 +1047,7 @@ unlink1 (struct usb_hcd *hcd, struct urb *urb)
 {
 	int		value;
 
-	if (urb-&gt;dev == hcd-&gt;self.root_hub)
+	if (is_root_hub(urb-&gt;dev))
 		value = usb_rh_urb_dequeue (hcd, urb);
 	else {
 
@@ -1091,11 +1095,11 @@ int usb_hcd_unlink_urb (struct urb *urb, int status)
 	 * that it was submitted.  But as a rule it can't know whether or
 	 * not it's already been unlinked ... so we respect the reversed
 	 * lock sequence needed for the usb_hcd_giveback_urb() code paths
-	 * (urb lock, then hcd_data_lock) in case some other CPU is now
+	 * (urb lock, then hcd_urb_list_lock) in case some other CPU is now
 	 * unlinking it.
 	 */
 	spin_lock_irqsave (&amp;urb-&gt;lock, flags);
-	spin_lock (&amp;hcd_data_lock);
+	spin_lock(&amp;hcd_urb_list_lock);
 
 	sys = &amp;urb-&gt;dev-&gt;dev;
 	hcd = bus_to_hcd(urb-&gt;dev-&gt;bus);
@@ -1127,17 +1131,16 @@ int usb_hcd_unlink_urb (struct urb *urb, int status)
 	 * finish unlinking the initial failed usb_set_address()
 	 * or device descriptor fetch.
 	 */
-	if (!test_bit(HCD_FLAG_SAW_IRQ, &amp;hcd-&gt;flags)
-	    &amp;&amp; hcd-&gt;self.root_hub != urb-&gt;dev) {
+	if (!test_bit(HCD_FLAG_SAW_IRQ, &amp;hcd-&gt;flags) &amp;&amp;
+			!is_root_hub(urb-&gt;dev)) {
 		dev_warn (hcd-&gt;self.controller, "Unlink after no-IRQ?  "
-			"Controller is probably using the wrong IRQ."
-			"\n");
+			"Controller is probably using the wrong IRQ.\n");
 		set_bit(HCD_FLAG_SAW_IRQ, &amp;hcd-&gt;flags);
 	}
 
 	urb-&gt;status = status;
 
-	spin_unlock (&amp;hcd_data_lock);
+	spin_unlock(&amp;hcd_urb_list_lock);
 	spin_unlock_irqrestore (&amp;urb-&gt;lock, flags);
 
 	retval = unlink1 (hcd, urb);
@@ -1146,7 +1149,7 @@ int usb_hcd_unlink_urb (struct urb *urb, int status)
 	return retval;
 
 done:
-	spin_unlock (&amp;hcd_data_lock);
+	spin_unlock(&amp;hcd_urb_list_lock);
 	spin_unlock_irqrestore (&amp;urb-&gt;lock, flags);
 	if (retval != -EIDRM &amp;&amp; sys &amp;&amp; sys-&gt;driver)
 		dev_dbg (sys, "hcd_unlink_urb %p fail %d\n", urb, retval);
@@ -1203,7 +1206,7 @@ void usb_hcd_endpoint_disable (struct usb_device *udev,
 
 	/* ep is already gone from udev-&gt;ep_{in,out}[]; no more submits */
 rescan:
-	spin_lock (&amp;hcd_data_lock);
+	spin_lock(&amp;hcd_urb_list_lock);
 	list_for_each_entry (urb, &amp;ep-&gt;urb_list, urb_list) {
 		int	tmp;
 
@@ -1211,7 +1214,7 @@ void usb_hcd_endpoint_disable (struct usb_device *udev,
 		if (urb-&gt;status != -EINPROGRESS)
 			continue;
 		usb_get_urb (urb);
-		spin_unlock (&amp;hcd_data_lock);
+		spin_unlock(&amp;hcd_urb_list_lock);
 
 		spin_lock (&amp;urb-&gt;lock);
 		tmp = urb-&gt;status;
@@ -1240,7 +1243,7 @@ void usb_hcd_endpoint_disable (struct usb_device *udev,
 		/* list contents may have changed */
 		goto rescan;
 	}
-	spin_unlock (&amp;hcd_data_lock);
+	spin_unlock(&amp;hcd_urb_list_lock);
 	local_irq_enable ();
 
 	/* synchronize with the hardware, so old configuration state
@@ -1257,7 +1260,7 @@ void usb_hcd_endpoint_disable (struct usb_device *udev,
 	 * endpoint_disable methods.
 	 */
 	while (!list_empty (&amp;ep-&gt;urb_list)) {
-		spin_lock_irq (&amp;hcd_data_lock);
+		spin_lock_irq(&amp;hcd_urb_list_lock);
 
 		/* The list may have changed while we acquired the spinlock */
 		urb = NULL;
@@ -1266,7 +1269,7 @@ void usb_hcd_endpoint_disable (struct usb_device *udev,
 					urb_list);
 			usb_get_urb (urb);
 		}
-		spin_unlock_irq (&amp;hcd_data_lock);
+		spin_unlock_irq(&amp;hcd_urb_list_lock);
 
 		if (urb) {
 			usb_kill_urb (urb);</pre><hr><pre>commit 32aca5600526189dd876e6c92b64fd88cf052c8d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 18 12:08:02 2007 -0400

    USB: move routines in hcd.c
    
    This patch (as939) moves a couple of routine in hcd.c around.  The
    purpose is to put all the general URB- and endpoint-related routines
    (submit, unlink, giveback, and disable) together in one spot.
    
    There are no functional changes.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 963520fbef90..032b118c2883 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1033,18 +1033,6 @@ int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
 
 /*-------------------------------------------------------------------------*/
 
-/* called in any context */
-int usb_hcd_get_frame_number (struct usb_device *udev)
-{
-	struct usb_hcd	*hcd = bus_to_hcd(udev-&gt;bus);
-
-	if (!HC_IS_RUNNING (hcd-&gt;state))
-		return -ESHUTDOWN;
-	return hcd-&gt;driver-&gt;get_frame_number (hcd);
-}
-
-/*-------------------------------------------------------------------------*/
-
 /* this makes the hcd giveback() the urb more quickly, by kicking it
  * off hardware queues (which may take a while) and returning it as
  * soon as practical.  we've already set up the urb's return status,
@@ -1167,6 +1155,35 @@ int usb_hcd_unlink_urb (struct urb *urb, int status)
 
 /*-------------------------------------------------------------------------*/
 
+/**
+ * usb_hcd_giveback_urb - return URB from HCD to device driver
+ * @hcd: host controller returning the URB
+ * @urb: urb being returned to the USB device driver.
+ * Context: in_interrupt()
+ *
+ * This hands the URB from HCD to its USB device driver, using its
+ * completion function.  The HCD has freed all per-urb resources
+ * (and is done using urb-&gt;hcpriv).  It also released all HCD locks;
+ * the device driver won't cause problems if it frees, modifies,
+ * or resubmits this URB.
+ */
+void usb_hcd_giveback_urb (struct usb_hcd *hcd, struct urb *urb)
+{
+	urb_unlink(hcd, urb);
+	usbmon_urb_complete (&amp;hcd-&gt;self, urb);
+	usb_unanchor_urb(urb);
+
+	/* pass ownership to the completion handler */
+	urb-&gt;complete (urb);
+	atomic_dec (&amp;urb-&gt;use_count);
+	if (unlikely (urb-&gt;reject))
+		wake_up (&amp;usb_kill_urb_queue);
+	usb_put_urb (urb);
+}
+EXPORT_SYMBOL (usb_hcd_giveback_urb);
+
+/*-------------------------------------------------------------------------*/
+
 /* disables the endpoint: cancels any pending urbs, then synchronizes with
  * the hcd to make sure all endpoint state is gone from hardware, and then
  * waits until the endpoint's queue is completely drained. use for
@@ -1260,6 +1277,18 @@ void usb_hcd_endpoint_disable (struct usb_device *udev,
 
 /*-------------------------------------------------------------------------*/
 
+/* called in any context */
+int usb_hcd_get_frame_number (struct usb_device *udev)
+{
+	struct usb_hcd	*hcd = bus_to_hcd(udev-&gt;bus);
+
+	if (!HC_IS_RUNNING (hcd-&gt;state))
+		return -ESHUTDOWN;
+	return hcd-&gt;driver-&gt;get_frame_number (hcd);
+}
+
+/*-------------------------------------------------------------------------*/
+
 #ifdef	CONFIG_PM
 
 int hcd_bus_suspend(struct usb_device *rhdev)
@@ -1394,35 +1423,6 @@ EXPORT_SYMBOL (usb_bus_start_enum);
 
 /*-------------------------------------------------------------------------*/
 
-/**
- * usb_hcd_giveback_urb - return URB from HCD to device driver
- * @hcd: host controller returning the URB
- * @urb: urb being returned to the USB device driver.
- * Context: in_interrupt()
- *
- * This hands the URB from HCD to its USB device driver, using its
- * completion function.  The HCD has freed all per-urb resources
- * (and is done using urb-&gt;hcpriv).  It also released all HCD locks;
- * the device driver won't cause problems if it frees, modifies,
- * or resubmits this URB.
- */
-void usb_hcd_giveback_urb (struct usb_hcd *hcd, struct urb *urb)
-{
-	urb_unlink(hcd, urb);
-	usbmon_urb_complete (&amp;hcd-&gt;self, urb);
-	usb_unanchor_urb(urb);
-
-	/* pass ownership to the completion handler */
-	urb-&gt;complete (urb);
-	atomic_dec (&amp;urb-&gt;use_count);
-	if (unlikely (urb-&gt;reject))
-		wake_up (&amp;usb_kill_urb_queue);
-	usb_put_urb (urb);
-}
-EXPORT_SYMBOL (usb_hcd_giveback_urb);
-
-/*-------------------------------------------------------------------------*/
-
 /**
  * usb_hcd_irq - hook IRQs to HCD framework (bus glue)
  * @irq: the IRQ being raised</pre>
    <div class="pagination">
        <a href='2_103.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><span>[104]</span><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_105.html'>Next&gt;&gt;</a>
    <div>
</body>
