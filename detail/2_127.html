<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_126.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><span>[127]</span><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_128.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 3e95637a48820ff8bedb33e6439def96ccff1de5
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jun 16 17:10:48 2006 -0400

    [PATCH] Driver Core: Make dev_info and friends print the bus name if there is no driver
    
    This patch (as721) makes dev_info and related macros print the device's
    bus name if the device doesn't have a driver, instead of printing just a
    blank.  If the device isn't on a bus either... well, then it does leave
    a blank space.  But it will be easier for someone else to change if they
    want.
    
    Cc: Matthew Wilcox &lt;matthew@wil.cx&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/base/core.c b/drivers/base/core.c
index a979bc3f49a9..d0f84ff78776 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -29,6 +29,22 @@ int (*platform_notify_remove)(struct device * dev) = NULL;
  * sysfs bindings for devices.
  */
 
+/**
+ * dev_driver_string - Return a device's driver name, if at all possible
+ * @dev: struct device to get the name of
+ *
+ * Will return the device's driver's name if it is bound to a device.  If
+ * the device is not bound to a device, it will return the name of the bus
+ * it is attached to.  If it is not attached to a bus either, an empty
+ * string will be returned.
+ */
+const char *dev_driver_string(struct device *dev)
+{
+	return dev-&gt;driver ? dev-&gt;driver-&gt;name :
+			(dev-&gt;bus ? dev-&gt;bus-&gt;name : "");
+}
+EXPORT_SYMBOL_GPL(dev_driver_string);
+
 #define to_dev(obj) container_of(obj, struct device, kobj)
 #define to_dev_attr(_attr) container_of(_attr, struct device_attribute, attr)
 
diff --git a/include/linux/device.h b/include/linux/device.h
index b473f4278910..1e5f30da98bc 100644
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@ -416,8 +416,9 @@ extern int firmware_register(struct subsystem *);
 extern void firmware_unregister(struct subsystem *);
 
 /* debugging and troubleshooting/diagnostic helpers. */
+extern const char *dev_driver_string(struct device *dev);
 #define dev_printk(level, dev, format, arg...)	\
-	printk(level "%s %s: " format , (dev)-&gt;driver ? (dev)-&gt;driver-&gt;name : "" , (dev)-&gt;bus_id , ## arg)
+	printk(level "%s %s: " format , dev_driver_string(dev) , (dev)-&gt;bus_id , ## arg)
 
 #ifdef DEBUG
 #define dev_dbg(dev, format, arg...)		\</pre><hr><pre>commit f07d5b946510a54937a75a3654941e855ffdc4c2
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 9 15:23:03 2006 -0700

    [NET]: Make netdev_chain a raw notifier.
    
    From: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    
    This chain does it's own locking via the RTNL semaphore, and
    can also run recursively so adding a new mutex here was causing
    deadlocks.
    
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/net/core/dev.c b/net/core/dev.c
index 9ab3cfa58466..ced57430f6d8 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -193,7 +193,7 @@ static inline struct hlist_head *dev_index_hash(int ifindex)
  *	Our notifier list
  */
 
-static BLOCKING_NOTIFIER_HEAD(netdev_chain);
+static RAW_NOTIFIER_HEAD(netdev_chain);
 
 /*
  *	Device drivers call our routines to queue packets here. We empty the
@@ -736,7 +736,7 @@ int dev_change_name(struct net_device *dev, char *newname)
 	if (!err) {
 		hlist_del(&amp;dev-&gt;name_hlist);
 		hlist_add_head(&amp;dev-&gt;name_hlist, dev_name_hash(dev-&gt;name));
-		blocking_notifier_call_chain(&amp;netdev_chain,
+		raw_notifier_call_chain(&amp;netdev_chain,
 				NETDEV_CHANGENAME, dev);
 	}
 
@@ -751,7 +751,7 @@ int dev_change_name(struct net_device *dev, char *newname)
  */
 void netdev_features_change(struct net_device *dev)
 {
-	blocking_notifier_call_chain(&amp;netdev_chain, NETDEV_FEAT_CHANGE, dev);
+	raw_notifier_call_chain(&amp;netdev_chain, NETDEV_FEAT_CHANGE, dev);
 }
 EXPORT_SYMBOL(netdev_features_change);
 
@@ -766,7 +766,7 @@ EXPORT_SYMBOL(netdev_features_change);
 void netdev_state_change(struct net_device *dev)
 {
 	if (dev-&gt;flags &amp; IFF_UP) {
-		blocking_notifier_call_chain(&amp;netdev_chain,
+		raw_notifier_call_chain(&amp;netdev_chain,
 				NETDEV_CHANGE, dev);
 		rtmsg_ifinfo(RTM_NEWLINK, dev, 0);
 	}
@@ -864,7 +864,7 @@ int dev_open(struct net_device *dev)
 		/*
 		 *	... and announce new interface.
 		 */
-		blocking_notifier_call_chain(&amp;netdev_chain, NETDEV_UP, dev);
+		raw_notifier_call_chain(&amp;netdev_chain, NETDEV_UP, dev);
 	}
 	return ret;
 }
@@ -887,7 +887,7 @@ int dev_close(struct net_device *dev)
 	 *	Tell people we are going down, so that they can
 	 *	prepare to death, when device is still operating.
 	 */
-	blocking_notifier_call_chain(&amp;netdev_chain, NETDEV_GOING_DOWN, dev);
+	raw_notifier_call_chain(&amp;netdev_chain, NETDEV_GOING_DOWN, dev);
 
 	dev_deactivate(dev);
 
@@ -924,7 +924,7 @@ int dev_close(struct net_device *dev)
 	/*
 	 * Tell people we are down
 	 */
-	blocking_notifier_call_chain(&amp;netdev_chain, NETDEV_DOWN, dev);
+	raw_notifier_call_chain(&amp;netdev_chain, NETDEV_DOWN, dev);
 
 	return 0;
 }
@@ -955,7 +955,7 @@ int register_netdevice_notifier(struct notifier_block *nb)
 	int err;
 
 	rtnl_lock();
-	err = blocking_notifier_chain_register(&amp;netdev_chain, nb);
+	err = raw_notifier_chain_register(&amp;netdev_chain, nb);
 	if (!err) {
 		for (dev = dev_base; dev; dev = dev-&gt;next) {
 			nb-&gt;notifier_call(nb, NETDEV_REGISTER, dev);
@@ -983,7 +983,7 @@ int unregister_netdevice_notifier(struct notifier_block *nb)
 	int err;
 
 	rtnl_lock();
-	err = blocking_notifier_chain_unregister(&amp;netdev_chain, nb);
+	err = raw_notifier_chain_unregister(&amp;netdev_chain, nb);
 	rtnl_unlock();
 	return err;
 }
@@ -994,12 +994,12 @@ int unregister_netdevice_notifier(struct notifier_block *nb)
  *      @v:   pointer passed unmodified to notifier function
  *
  *	Call all network notifier blocks.  Parameters and return value
- *	are as for blocking_notifier_call_chain().
+ *	are as for raw_notifier_call_chain().
  */
 
 int call_netdevice_notifiers(unsigned long val, void *v)
 {
-	return blocking_notifier_call_chain(&amp;netdev_chain, val, v);
+	return raw_notifier_call_chain(&amp;netdev_chain, val, v);
 }
 
 /* When &gt; 0 there are consumers of rx skb time stamps */
@@ -2308,7 +2308,7 @@ int dev_change_flags(struct net_device *dev, unsigned flags)
 	if (dev-&gt;flags &amp; IFF_UP &amp;&amp;
 	    ((old_flags ^ dev-&gt;flags) &amp;~ (IFF_UP | IFF_PROMISC | IFF_ALLMULTI |
 					  IFF_VOLATILE)))
-		blocking_notifier_call_chain(&amp;netdev_chain,
+		raw_notifier_call_chain(&amp;netdev_chain,
 				NETDEV_CHANGE, dev);
 
 	if ((flags ^ dev-&gt;gflags) &amp; IFF_PROMISC) {
@@ -2353,7 +2353,7 @@ int dev_set_mtu(struct net_device *dev, int new_mtu)
 	else
 		dev-&gt;mtu = new_mtu;
 	if (!err &amp;&amp; dev-&gt;flags &amp; IFF_UP)
-		blocking_notifier_call_chain(&amp;netdev_chain,
+		raw_notifier_call_chain(&amp;netdev_chain,
 				NETDEV_CHANGEMTU, dev);
 	return err;
 }
@@ -2370,7 +2370,7 @@ int dev_set_mac_address(struct net_device *dev, struct sockaddr *sa)
 		return -ENODEV;
 	err = dev-&gt;set_mac_address(dev, sa);
 	if (!err)
-		blocking_notifier_call_chain(&amp;netdev_chain,
+		raw_notifier_call_chain(&amp;netdev_chain,
 				NETDEV_CHANGEADDR, dev);
 	return err;
 }
@@ -2427,7 +2427,7 @@ static int dev_ifsioc(struct ifreq *ifr, unsigned int cmd)
 				return -EINVAL;
 			memcpy(dev-&gt;broadcast, ifr-&gt;ifr_hwaddr.sa_data,
 			       min(sizeof ifr-&gt;ifr_hwaddr.sa_data, (size_t) dev-&gt;addr_len));
-			blocking_notifier_call_chain(&amp;netdev_chain,
+			raw_notifier_call_chain(&amp;netdev_chain,
 					    NETDEV_CHANGEADDR, dev);
 			return 0;
 
@@ -2882,7 +2882,7 @@ int register_netdevice(struct net_device *dev)
 	write_unlock_bh(&amp;dev_base_lock);
 
 	/* Notify protocols, that a new device appeared. */
-	blocking_notifier_call_chain(&amp;netdev_chain, NETDEV_REGISTER, dev);
+	raw_notifier_call_chain(&amp;netdev_chain, NETDEV_REGISTER, dev);
 
 	/* Finish registration after unlock */
 	net_set_todo(dev);
@@ -2961,7 +2961,7 @@ static void netdev_wait_allrefs(struct net_device *dev)
 			rtnl_lock();
 
 			/* Rebroadcast unregister notification */
-			blocking_notifier_call_chain(&amp;netdev_chain,
+			raw_notifier_call_chain(&amp;netdev_chain,
 					    NETDEV_UNREGISTER, dev);
 
 			if (test_bit(__LINK_STATE_LINKWATCH_PENDING,
@@ -3216,7 +3216,7 @@ int unregister_netdevice(struct net_device *dev)
 	/* Notify protocols, that we are about to destroy
 	   this device. They should clean all the things.
 	*/
-	blocking_notifier_call_chain(&amp;netdev_chain, NETDEV_UNREGISTER, dev);
+	raw_notifier_call_chain(&amp;netdev_chain, NETDEV_UNREGISTER, dev);
 	
 	/*
 	 *	Flush the multicast chain</pre><hr><pre>commit 436f5762bcd4929825a0725d4bc78337e6fc0d8f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 2 15:22:41 2006 -0400

    [PATCH] USB: usbcore: don't check the device's power source
    
    The choose_configuration() routine contains code the determine the
    device's power source, so that configurations requiring external power
    can be ruled out if the device is running on bus power.  Unfortunately
    it turns out that some devices have errors in their config descriptors
    and other devices don't like the GET_DEVICE_STATUS request.
    
    Since that information wasn't used for anything else, this patch (as673)
    removes the code, leaving only a comment.  It fixes bugzilla entry
    #6448.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 0c87f73f2933..90b8d43c6b33 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1168,19 +1168,9 @@ static inline const char *plural(int n)
 static int choose_configuration(struct usb_device *udev)
 {
 	int i;
-	u16 devstatus;
-	int bus_powered;
 	int num_configs;
 	struct usb_host_config *c, *best;
 
-	/* If this fails, assume the device is bus-powered */
-	devstatus = 0;
-	usb_get_status(udev, USB_RECIP_DEVICE, 0, &amp;devstatus);
-	le16_to_cpus(&amp;devstatus);
-	bus_powered = ((devstatus &amp; (1 &lt;&lt; USB_DEVICE_SELF_POWERED)) == 0);
-	dev_dbg(&amp;udev-&gt;dev, "device is %s-powered\n",
-			bus_powered ? "bus" : "self");
-
 	best = NULL;
 	c = udev-&gt;config;
 	num_configs = udev-&gt;descriptor.bNumConfigurations;
@@ -1197,6 +1187,19 @@ static int choose_configuration(struct usb_device *udev)
 		 * similar errors in their descriptors.  If the next test
 		 * were allowed to execute, such configurations would always
 		 * be rejected and the devices would not work as expected.
+		 * In the meantime, we run the risk of selecting a config
+		 * that requires external power at a time when that power
+		 * isn't available.  It seems to be the lesser of two evils.
+		 *
+		 * Bugzilla #6448 reports a device that appears to crash
+		 * when it receives a GET_DEVICE_STATUS request!  We don't
+		 * have any other way to tell whether a device is self-powered,
+		 * but since we don't use that information anywhere but here,
+		 * the call has been removed.
+		 *
+		 * Maybe the GET_DEVICE_STATUS call and the test below can
+		 * be reinstated when device firmwares become more reliable.
+		 * Don't hold your breath.
 		 */
 #if 0
 		/* Rule out self-powered configs for a bus-powered device */</pre><hr><pre>commit 9fb81ce63671f9743517f628dac935269f2581a9
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Apr 14 16:46:28 2006 -0400

    [PATCH] USB: net2280: set driver data before it is used
    
    This patch (as671) fixes a bug in the error pathway for the net2280
    probe routine.  A failure during probe will cause the driver to call
    pci_get_drvdata before the corresponding pci_set_drvdata has been set.
    The patch also does a kzalloc conversion.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/net2280.c b/drivers/usb/gadget/net2280.c
index b2d507f16b85..0b9293493957 100644
--- a/drivers/usb/gadget/net2280.c
+++ b/drivers/usb/gadget/net2280.c
@@ -2833,13 +2833,13 @@ static int net2280_probe (struct pci_dev *pdev, const struct pci_device_id *id)
 	}
 
 	/* alloc, and start init */
-	dev = kmalloc (sizeof *dev, SLAB_KERNEL);
+	dev = kzalloc (sizeof *dev, SLAB_KERNEL);
 	if (dev == NULL){
 		retval = -ENOMEM;
 		goto done;
 	}
 
-	memset (dev, 0, sizeof *dev);
+	pci_set_drvdata (pdev, dev);
 	spin_lock_init (&amp;dev-&gt;lock);
 	dev-&gt;pdev = pdev;
 	dev-&gt;gadget.ops = &amp;net2280_ops;
@@ -2952,7 +2952,6 @@ static int net2280_probe (struct pci_dev *pdev, const struct pci_device_id *id)
 	dev-&gt;chiprev = get_idx_reg (dev-&gt;regs, REG_CHIPREV) &amp; 0xffff;
 
 	/* done */
-	pci_set_drvdata (pdev, dev);
 	INFO (dev, "%s\n", driver_desc);
 	INFO (dev, "irq %s, pci mem %p, chip rev %04x\n",
 			bufp, base, dev-&gt;chiprev);</pre><hr><pre>commit 658ad5e001a17be5fadaa8d57d1aa7f7c62628c1
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Apr 14 16:44:11 2006 -0400

    [PATCH] USB: net2280: check for shared IRQs
    
    This patch (as670) adds a check for whether a shared IRQ was actually
    generated by the net2280 device.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/net2280.c b/drivers/usb/gadget/net2280.c
index c842b194cf0f..b2d507f16b85 100644
--- a/drivers/usb/gadget/net2280.c
+++ b/drivers/usb/gadget/net2280.c
@@ -2742,6 +2742,10 @@ static irqreturn_t net2280_irq (int irq, void *_dev, struct pt_regs * r)
 {
 	struct net2280		*dev = _dev;
 
+	/* shared interrupt, not ours */
+	if (!(readl(&amp;dev-&gt;regs-&gt;irqstat0) &amp; (1 &lt;&lt; INTA_ASSERTED)))
+		return IRQ_NONE;
+
 	spin_lock (&amp;dev-&gt;lock);
 
 	/* handle disconnect, dma, and more */</pre><hr><pre>commit 317e83b842ba39776054219ae29844127876416a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Apr 14 16:42:03 2006 -0400

    [PATCH] USB: net2280: send 0-length packets for ep0
    
    This patch (as669) fixes a bug in the net2280 driver.  Now it will
    properly send zero-length packets on ep0 until the control status stage
    occurs.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/net2280.c b/drivers/usb/gadget/net2280.c
index 2d5cededcbd7..c842b194cf0f 100644
--- a/drivers/usb/gadget/net2280.c
+++ b/drivers/usb/gadget/net2280.c
@@ -2280,9 +2280,7 @@ static void handle_ep_small (struct net2280_ep *ep)
 		/* if we wrote it all, we're usually done */
 		if (req-&gt;req.actual == req-&gt;req.length) {
 			if (ep-&gt;num == 0) {
-				/* wait for control status */
-				if (mode != 2)
-					req = NULL;
+				/* send zlps until the status stage */
 			} else if (!req-&gt;req.zero || len != ep-&gt;ep.maxpacket)
 				mode = 2;
 		}</pre><hr><pre>commit a29fccd7993a3d411674e148cb0759a017be3e21
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Apr 14 16:40:00 2006 -0400

    [PATCH] USB: net2280: Handle STALLs for 0-length control-IN requests
    
    This patch (as668) fixes a typo in net2280.  The handler for 0-length
    control-IN requests should check that the endpoint _isn't_ halted before
    sending a 0-length packet.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/net2280.c b/drivers/usb/gadget/net2280.c
index 6a4b93ad1082..2d5cededcbd7 100644
--- a/drivers/usb/gadget/net2280.c
+++ b/drivers/usb/gadget/net2280.c
@@ -2166,7 +2166,7 @@ static void handle_ep_small (struct net2280_ep *ep)
 					ep-&gt;stopped = 1;
 					set_halt (ep);
 					mode = 2;
-				} else if (!req &amp;&amp; ep-&gt;stopped)
+				} else if (!req &amp;&amp; !ep-&gt;stopped)
 					write_fifo (ep, NULL);
 			}
 		} else {</pre><hr><pre>commit 0f836ca4c122f4ef096110d652a6326fe34e6961
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Mar 31 11:52:25 2006 -0500

    [PATCH] driver core: safely unbind drivers for devices not on a bus
    
    This patch (as667) changes the __device_release_driver() routine to
    prevent it from crashing when it runs across a device not on any bus.
    This seems logical, inasmuch as the corresponding bus_add_device()
    routine has an explicit check allowing it to accept such devices.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 730a9ce0a14a..889c71111239 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -209,7 +209,7 @@ static void __device_release_driver(struct device * dev)
 		sysfs_remove_link(&amp;dev-&gt;kobj, "driver");
 		klist_remove(&amp;dev-&gt;knode_driver);
 
-		if (dev-&gt;bus-&gt;remove)
+		if (dev-&gt;bus &amp;&amp; dev-&gt;bus-&gt;remove)
 			dev-&gt;bus-&gt;remove(dev);
 		else if (drv-&gt;remove)
 			drv-&gt;remove(dev);</pre><hr><pre>commit 8e32640672bdcb01e0d83f087f09dd65fcbc3275
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Apr 4 14:47:44 2006 -0400

    [PATCH] USB: UHCI: don't track suspended ports
    
    Someone recently posted a bug report where it turned out that uhci-hcd
    was disagreeing with the UHCI controller over whether or not a port was
    suspended: The driver thought it wasn't and the hardware thought it was.
    This patch (as665) fixes the problem and simplifies the driver by
    removing the internal state-tracking completely.  Now the driver just
    asks the hardware whether a port is suspended.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 3d511690c9b7..c0c4db78b590 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -115,8 +115,7 @@ static void finish_reset(struct uhci_hcd *uhci)
 	for (port = 0; port &lt; uhci-&gt;rh_numports; ++port)
 		outw(0, uhci-&gt;io_addr + USBPORTSC1 + (port * 2));
 
-	uhci-&gt;port_c_suspend = uhci-&gt;suspended_ports =
-			uhci-&gt;resuming_ports = 0;
+	uhci-&gt;port_c_suspend = uhci-&gt;resuming_ports = 0;
 	uhci-&gt;rh_state = UHCI_RH_RESET;
 	uhci-&gt;is_stopped = UHCI_IS_STOPPED;
 	uhci_to_hcd(uhci)-&gt;state = HC_STATE_HALT;
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index 4a69c7eb09bd..d5c8f4d92823 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -415,7 +415,6 @@ struct uhci_hcd {
 
 	/* Support for port suspend/resume/reset */
 	unsigned long port_c_suspend;		/* Bit-arrays of ports */
-	unsigned long suspended_ports;
 	unsigned long resuming_ports;
 	unsigned long ports_timeout;		/* Time to stop signalling */
 
diff --git a/drivers/usb/host/uhci-hub.c b/drivers/usb/host/uhci-hub.c
index 152971d16769..c8451d9578f1 100644
--- a/drivers/usb/host/uhci-hub.c
+++ b/drivers/usb/host/uhci-hub.c
@@ -85,11 +85,10 @@ static void uhci_finish_suspend(struct uhci_hcd *uhci, int port,
 {
 	int status;
 
-	if (test_bit(port, &amp;uhci-&gt;suspended_ports)) {
+	if (inw(port_addr) &amp; (USBPORTSC_SUSP | USBPORTSC_RD)) {
 		CLR_RH_PORTSTAT(USBPORTSC_SUSP | USBPORTSC_RD);
-		clear_bit(port, &amp;uhci-&gt;suspended_ports);
-		clear_bit(port, &amp;uhci-&gt;resuming_ports);
-		set_bit(port, &amp;uhci-&gt;port_c_suspend);
+		if (test_bit(port, &amp;uhci-&gt;resuming_ports))
+			set_bit(port, &amp;uhci-&gt;port_c_suspend);
 
 		/* The controller won't actually turn off the RD bit until
 		 * it has had a chance to send a low-speed EOP sequence,
@@ -97,6 +96,7 @@ static void uhci_finish_suspend(struct uhci_hcd *uhci, int port,
 		 * slightly longer for good luck. */
 		udelay(4);
 	}
+	clear_bit(port, &amp;uhci-&gt;resuming_ports);
 }
 
 /* Wait for the UHCI controller in HP's iLO2 server management chip.
@@ -265,8 +265,6 @@ static int uhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 			wPortChange |= USB_PORT_STAT_C_SUSPEND;
 			lstatus |= 1;
 		}
-		if (test_bit(port, &amp;uhci-&gt;suspended_ports))
-			lstatus |= 2;
 		if (test_bit(port, &amp;uhci-&gt;resuming_ports))
 			lstatus |= 4;
 
@@ -309,7 +307,6 @@ static int uhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 
 		switch (wValue) {
 		case USB_PORT_FEAT_SUSPEND:
-			set_bit(port, &amp;uhci-&gt;suspended_ports);
 			SET_RH_PORTSTAT(USBPORTSC_SUSP);
 			OK(0);
 		case USB_PORT_FEAT_RESET:
@@ -343,8 +340,11 @@ static int uhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 			CLR_RH_PORTSTAT(USBPORTSC_PEC);
 			OK(0);
 		case USB_PORT_FEAT_SUSPEND:
-			if (test_bit(port, &amp;uhci-&gt;suspended_ports) &amp;&amp;
-					!test_and_set_bit(port,
+			if (!(inw(port_addr) &amp; USBPORTSC_SUSP)) {
+
+				/* Make certain the port isn't suspended */
+				uhci_finish_suspend(uhci, port, port_addr);
+			} else if (!test_and_set_bit(port,
 						&amp;uhci-&gt;resuming_ports)) {
 				SET_RH_PORTSTAT(USBPORTSC_RD);
 </pre><hr><pre>commit aafe5bd6ec341edfaf3233d272febbb8862a7251
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Mar 31 11:46:43 2006 -0500

    [PATCH] USB: g_file_storage: use module_param_array_named macro
    
    Randy Dunlap pointed out that there now is a module_param_array_named
    macro available.  This patch (as666) updates g_file_storage to make use of
    it.  It also adds a comment listing the specifications documents used in
    the design of the driver's SCSI operation (at Pat LaVarre's request).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/file_storage.c b/drivers/usb/gadget/file_storage.c
index b6d920f349ea..6f887478b148 100644
--- a/drivers/usb/gadget/file_storage.c
+++ b/drivers/usb/gadget/file_storage.c
@@ -114,6 +114,14 @@
  * setting are not allowed when the medium is loaded.
  *
  * This gadget driver is heavily based on "Gadget Zero" by David Brownell.
+ * The driver's SCSI command interface was based on the "Information
+ * technology - Small Computer System Interface - 2" document from
+ * X3T9.2 Project 375D, Revision 10L, 7-SEP-93, available at
+ * &lt;http://www.t10.org/ftp/t10/drafts/s2/s2-r10l.pdf&gt;.  The single exception
+ * is opcode 0x23 (READ FORMAT CAPACITIES), which was based on the
+ * "Universal Serial Bus Mass Storage Class UFI Command Specification"
+ * document, Revision 1.0, December 14, 1998, available at
+ * &lt;http://www.usb.org/developers/devclass_docs/usbmass-ufi10.pdf&gt;.
  */
 
 
@@ -340,11 +348,9 @@ MODULE_LICENSE("Dual BSD/GPL");
 
 #define MAX_LUNS	8
 
-	/* Arggh!  There should be a module_param_array_named macro! */
-static char		*file[MAX_LUNS];
-static int		ro[MAX_LUNS];
-
 static struct {
+	char		*file[MAX_LUNS];
+	int		ro[MAX_LUNS];
 	int		num_filenames;
 	int		num_ros;
 	unsigned int	nluns;
@@ -376,10 +382,11 @@ static struct {
 	};
 
 
-module_param_array(file, charp, &amp;mod_data.num_filenames, S_IRUGO);
+module_param_array_named(file, mod_data.file, charp, &amp;mod_data.num_filenames,
+		S_IRUGO);
 MODULE_PARM_DESC(file, "names of backing files or devices");
 
-module_param_array(ro, bool, &amp;mod_data.num_ros, S_IRUGO);
+module_param_array_named(ro, mod_data.ro, bool, &amp;mod_data.num_ros, S_IRUGO);
 MODULE_PARM_DESC(ro, "true to force read-only");
 
 module_param_named(luns, mod_data.nluns, uint, S_IRUGO);
@@ -3868,7 +3875,7 @@ static int __init fsg_bind(struct usb_gadget *gadget)
 
 	for (i = 0; i &lt; fsg-&gt;nluns; ++i) {
 		curlun = &amp;fsg-&gt;luns[i];
-		curlun-&gt;ro = ro[i];
+		curlun-&gt;ro = mod_data.ro[i];
 		curlun-&gt;dev.parent = &amp;gadget-&gt;dev;
 		curlun-&gt;dev.driver = &amp;fsg_driver.driver;
 		dev_set_drvdata(&amp;curlun-&gt;dev, fsg);
@@ -3885,8 +3892,9 @@ static int __init fsg_bind(struct usb_gadget *gadget)
 			kref_get(&amp;fsg-&gt;ref);
 		}
 
-		if (file[i] &amp;&amp; *file[i]) {
-			if ((rc = open_backing_file(curlun, file[i])) != 0)
+		if (mod_data.file[i] &amp;&amp; *mod_data.file[i]) {
+			if ((rc = open_backing_file(curlun,
+					mod_data.file[i])) != 0)
 				goto out;
 		} else if (!mod_data.removable) {
 			ERROR(fsg, "no file given for LUN%d\n", i);</pre>
    <div class="pagination">
        <a href='2_126.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><span>[127]</span><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_128.html'>Next&gt;&gt;</a>
    <div>
</body>
