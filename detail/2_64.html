<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_63.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><span>[64]</span><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_65.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 2138a1f1835274b1d131a1aafa1655f60b2af122
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jun 25 14:01:49 2010 -0400

    USB: refactor the powermac-specific ASIC clock code
    
    This patch (as1383) takes the powermac-specific code from the PCI HCD
    glue layer and encapsulates it in its own subroutine.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Benjamin Herrenschmidt &lt;benh@kernel.crashing.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd-pci.c b/drivers/usb/core/hcd-pci.c
index 7e2d5271b0c9..7c3b0af62241 100644
--- a/drivers/usb/core/hcd-pci.c
+++ b/drivers/usb/core/hcd-pci.c
@@ -332,6 +332,27 @@ EXPORT_SYMBOL_GPL(usb_hcd_pci_shutdown);
 
 #ifdef	CONFIG_PM_SLEEP
 
+#ifdef	CONFIG_PPC_PMAC
+static void powermac_set_asic(struct pci_dev *pci_dev, int enable)
+{
+	/* Enanble or disable ASIC clocks for USB */
+	if (machine_is(powermac)) {
+		struct device_node	*of_node;
+
+		of_node = pci_device_to_OF_node(pci_dev);
+		if (of_node)
+			pmac_call_feature(PMAC_FTR_USB_ENABLE,
+					of_node, 0, enable);
+	}
+}
+
+#else
+
+static inline void powermac_set_asic(struct pci_dev *pci_dev, int enable)
+{}
+
+#endif	/* CONFIG_PPC_PMAC */
+
 static int check_root_hub_suspended(struct device *dev)
 {
 	struct pci_dev		*pci_dev = to_pci_dev(dev);
@@ -416,16 +437,7 @@ static int hcd_pci_suspend_noirq(struct device *dev)
 		return retval;
 	}
 
-#ifdef CONFIG_PPC_PMAC
-	/* Disable ASIC clocks for USB */
-	if (machine_is(powermac)) {
-		struct device_node	*of_node;
-
-		of_node = pci_device_to_OF_node(pci_dev);
-		if (of_node)
-			pmac_call_feature(PMAC_FTR_USB_ENABLE, of_node, 0, 0);
-	}
-#endif
+	powermac_set_asic(pci_dev, 0);
 	return retval;
 }
 
@@ -433,17 +445,7 @@ static int hcd_pci_resume_noirq(struct device *dev)
 {
 	struct pci_dev		*pci_dev = to_pci_dev(dev);
 
-#ifdef CONFIG_PPC_PMAC
-	/* Reenable ASIC clocks for USB */
-	if (machine_is(powermac)) {
-		struct device_node *of_node;
-
-		of_node = pci_device_to_OF_node(pci_dev);
-		if (of_node)
-			pmac_call_feature(PMAC_FTR_USB_ENABLE,
-						of_node, 0, 1);
-	}
-#endif
+	powermac_set_asic(pci_dev, 1);
 
 	/* Go back to D0 and disable remote wakeup */
 	pci_back_from_sleep(pci_dev);</pre><hr><pre>commit 541c7d432f76771079e7c295d596ea47cc6a3030
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jun 22 16:39:10 2010 -0400

    USB: convert usb_hcd bitfields into atomic flags
    
    This patch (as1393) converts several of the single-bit fields in
    struct usb_hcd to atomic flags.  This is for safety's sake; not all
    CPUs can update bitfield values atomically, and these flags are used
    in multiple contexts.
    
    The flag fields that are set only during registration or removal can
    remain as they are, since non-atomic accesses at those times will not
    cause any problems.
    
    (Strictly speaking, the authorized_default flag should become atomic
    as well.  I didn't bother with it because it gets changed only via
    sysfs.  It can be done later, if anyone wants.)
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/usbip/vhci_hcd.c b/drivers/staging/usbip/vhci_hcd.c
index be5d8db98165..0574d848b900 100644
--- a/drivers/staging/usbip/vhci_hcd.c
+++ b/drivers/staging/usbip/vhci_hcd.c
@@ -215,7 +215,7 @@ static int vhci_hub_status(struct usb_hcd *hcd, char *buf)
 	vhci = hcd_to_vhci(hcd);
 
 	spin_lock_irqsave(&amp;vhci-&gt;lock, flags);
-	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags)) {
+	if (!HCD_HW_ACCESSIBLE(hcd)) {
 		usbip_dbg_vhci_rh("hw accessible flag in on?\n");
 		goto done;
 	}
@@ -269,7 +269,7 @@ static int vhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 
 	u32 prev_port_status[VHCI_NPORTS];
 
-	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags))
+	if (!HCD_HW_ACCESSIBLE(hcd))
 		return -ETIMEDOUT;
 
 	/*
@@ -1041,7 +1041,7 @@ static int vhci_bus_resume(struct usb_hcd *hcd)
 	dev_dbg(&amp;hcd-&gt;self.root_hub-&gt;dev, "%s\n", __func__);
 
 	spin_lock_irq(&amp;vhci-&gt;lock);
-	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags)) {
+	if (!HCD_HW_ACCESSIBLE(hcd)) {
 		rc = -ESHUTDOWN;
 	} else {
 		/* vhci-&gt;rh_state = DUMMY_RH_RUNNING;
diff --git a/drivers/usb/c67x00/c67x00-hcd.c b/drivers/usb/c67x00/c67x00-hcd.c
index a22b887f4e9e..d3e1356d091e 100644
--- a/drivers/usb/c67x00/c67x00-hcd.c
+++ b/drivers/usb/c67x00/c67x00-hcd.c
@@ -264,7 +264,7 @@ static void c67x00_hcd_irq(struct c67x00_sie *sie, u16 int_status, u16 msg)
 	if (unlikely(hcd-&gt;state == HC_STATE_HALT))
 		return;
 
-	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags))
+	if (!HCD_HW_ACCESSIBLE(hcd))
 		return;
 
 	/* Handle Start of frame events */
@@ -282,7 +282,7 @@ static int c67x00_hcd_start(struct usb_hcd *hcd)
 {
 	hcd-&gt;uses_new_polling = 1;
 	hcd-&gt;state = HC_STATE_RUNNING;
-	hcd-&gt;poll_rh = 1;
+	set_bit(HCD_FLAG_POLL_RH, &amp;hcd-&gt;flags);
 
 	return 0;
 }
diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 53f14c82ff2e..f2fe7c8e991d 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -679,7 +679,7 @@ void usb_hcd_poll_rh_status(struct usb_hcd *hcd)
 		spin_lock_irqsave(&amp;hcd_root_hub_lock, flags);
 		urb = hcd-&gt;status_urb;
 		if (urb) {
-			hcd-&gt;poll_pending = 0;
+			clear_bit(HCD_FLAG_POLL_PENDING, &amp;hcd-&gt;flags);
 			hcd-&gt;status_urb = NULL;
 			urb-&gt;actual_length = length;
 			memcpy(urb-&gt;transfer_buffer, buffer, length);
@@ -690,7 +690,7 @@ void usb_hcd_poll_rh_status(struct usb_hcd *hcd)
 			spin_lock(&amp;hcd_root_hub_lock);
 		} else {
 			length = 0;
-			hcd-&gt;poll_pending = 1;
+			set_bit(HCD_FLAG_POLL_PENDING, &amp;hcd-&gt;flags);
 		}
 		spin_unlock_irqrestore(&amp;hcd_root_hub_lock, flags);
 	}
@@ -699,7 +699,7 @@ void usb_hcd_poll_rh_status(struct usb_hcd *hcd)
 	 * exceed that limit if HZ is 100. The math is more clunky than
 	 * maybe expected, this is to make sure that all timers for USB devices
 	 * fire at the same time to give the CPU a break inbetween */
-	if (hcd-&gt;uses_new_polling ? hcd-&gt;poll_rh :
+	if (hcd-&gt;uses_new_polling ? HCD_POLL_RH(hcd) :
 			(length == 0 &amp;&amp; hcd-&gt;status_urb != NULL))
 		mod_timer (&amp;hcd-&gt;rh_timer, (jiffies/(HZ/4) + 1) * (HZ/4));
 }
@@ -736,7 +736,7 @@ static int rh_queue_status (struct usb_hcd *hcd, struct urb *urb)
 		mod_timer(&amp;hcd-&gt;rh_timer, (jiffies/(HZ/4) + 1) * (HZ/4));
 
 	/* If a status change has already occurred, report it ASAP */
-	else if (hcd-&gt;poll_pending)
+	else if (HCD_POLL_PENDING(hcd))
 		mod_timer(&amp;hcd-&gt;rh_timer, jiffies);
 	retval = 0;
  done:
@@ -1150,8 +1150,7 @@ int usb_hcd_check_unlink_urb(struct usb_hcd *hcd, struct urb *urb,
 	 * finish unlinking the initial failed usb_set_address()
 	 * or device descriptor fetch.
 	 */
-	if (!test_bit(HCD_FLAG_SAW_IRQ, &amp;hcd-&gt;flags) &amp;&amp;
-			!is_root_hub(urb-&gt;dev)) {
+	if (!HCD_SAW_IRQ(hcd) &amp;&amp; !is_root_hub(urb-&gt;dev)) {
 		dev_warn(hcd-&gt;self.controller, "Unlink after no-IRQ?  "
 			"Controller is probably using the wrong IRQ.\n");
 		set_bit(HCD_FLAG_SAW_IRQ, &amp;hcd-&gt;flags);
@@ -2063,8 +2062,7 @@ irqreturn_t usb_hcd_irq (int irq, void *__hcd)
 	 */
 	local_irq_save(flags);
 
-	if (unlikely(hcd-&gt;state == HC_STATE_HALT ||
-		     !test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags))) {
+	if (unlikely(hcd-&gt;state == HC_STATE_HALT || !HCD_HW_ACCESSIBLE(hcd))) {
 		rc = IRQ_NONE;
 	} else if (hcd-&gt;driver-&gt;irq(hcd) == IRQ_NONE) {
 		rc = IRQ_NONE;
@@ -2098,7 +2096,7 @@ void usb_hc_died (struct usb_hcd *hcd)
 
 	spin_lock_irqsave (&amp;hcd_root_hub_lock, flags);
 	if (hcd-&gt;rh_registered) {
-		hcd-&gt;poll_rh = 0;
+		clear_bit(HCD_FLAG_POLL_RH, &amp;hcd-&gt;flags);
 
 		/* make khubd clean up old urbs and devices */
 		usb_set_device_state (hcd-&gt;self.root_hub,
@@ -2301,7 +2299,7 @@ int usb_add_hcd(struct usb_hcd *hcd,
 		       retval);
 		goto error_create_attr_group;
 	}
-	if (hcd-&gt;uses_new_polling &amp;&amp; hcd-&gt;poll_rh)
+	if (hcd-&gt;uses_new_polling &amp;&amp; HCD_POLL_RH(hcd))
 		usb_hcd_poll_rh_status(hcd);
 	return retval;
 
@@ -2320,11 +2318,11 @@ int usb_add_hcd(struct usb_hcd *hcd,
 	mutex_unlock(&amp;usb_bus_list_lock);
 err_register_root_hub:
 	hcd-&gt;rh_pollable = 0;
-	hcd-&gt;poll_rh = 0;
+	clear_bit(HCD_FLAG_POLL_RH, &amp;hcd-&gt;flags);
 	del_timer_sync(&amp;hcd-&gt;rh_timer);
 	hcd-&gt;driver-&gt;stop(hcd);
 	hcd-&gt;state = HC_STATE_HALT;
-	hcd-&gt;poll_rh = 0;
+	clear_bit(HCD_FLAG_POLL_RH, &amp;hcd-&gt;flags);
 	del_timer_sync(&amp;hcd-&gt;rh_timer);
 err_hcd_driver_start:
 	if (hcd-&gt;irq &gt;= 0)
@@ -2380,14 +2378,14 @@ void usb_remove_hcd(struct usb_hcd *hcd)
 	 * the hub_status_data() callback.
 	 */
 	hcd-&gt;rh_pollable = 0;
-	hcd-&gt;poll_rh = 0;
+	clear_bit(HCD_FLAG_POLL_RH, &amp;hcd-&gt;flags);
 	del_timer_sync(&amp;hcd-&gt;rh_timer);
 
 	hcd-&gt;driver-&gt;stop(hcd);
 	hcd-&gt;state = HC_STATE_HALT;
 
 	/* In case the HCD restarted the timer, stop it again. */
-	hcd-&gt;poll_rh = 0;
+	clear_bit(HCD_FLAG_POLL_RH, &amp;hcd-&gt;flags);
 	del_timer_sync(&amp;hcd-&gt;rh_timer);
 
 	if (hcd-&gt;irq &gt;= 0)
diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index 4f9e578cde9d..dc6546248ed9 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -1542,7 +1542,7 @@ static int dummy_hub_status (struct usb_hcd *hcd, char *buf)
 	dum = hcd_to_dummy (hcd);
 
 	spin_lock_irqsave (&amp;dum-&gt;lock, flags);
-	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags))
+	if (!HCD_HW_ACCESSIBLE(hcd))
 		goto done;
 
 	if (dum-&gt;resuming &amp;&amp; time_after_eq (jiffies, dum-&gt;re_timeout)) {
@@ -1588,7 +1588,7 @@ static int dummy_hub_control (
 	int		retval = 0;
 	unsigned long	flags;
 
-	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags))
+	if (!HCD_HW_ACCESSIBLE(hcd))
 		return -ETIMEDOUT;
 
 	dum = hcd_to_dummy (hcd);
@@ -1739,7 +1739,7 @@ static int dummy_bus_resume (struct usb_hcd *hcd)
 	dev_dbg (&amp;hcd-&gt;self.root_hub-&gt;dev, "%s\n", __func__);
 
 	spin_lock_irq (&amp;dum-&gt;lock);
-	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags)) {
+	if (!HCD_HW_ACCESSIBLE(hcd)) {
 		rc = -ESHUTDOWN;
 	} else {
 		dum-&gt;rh_state = DUMMY_RH_RUNNING;
diff --git a/drivers/usb/host/ehci-dbg.c b/drivers/usb/host/ehci-dbg.c
index df5546bb8367..4498efb49b95 100644
--- a/drivers/usb/host/ehci-dbg.c
+++ b/drivers/usb/host/ehci-dbg.c
@@ -712,7 +712,7 @@ static ssize_t fill_registers_buffer(struct debug_buffer *buf)
 
 	spin_lock_irqsave (&amp;ehci-&gt;lock, flags);
 
-	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags)) {
+	if (!HCD_HW_ACCESSIBLE(hcd)) {
 		size = scnprintf (next, size,
 			"bus %s, device %s\n"
 			"%s\n"
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 8697ad19f313..2a19336c9824 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -642,7 +642,6 @@ static int ehci_run (struct usb_hcd *hcd)
 	u32			hcc_params;
 
 	hcd-&gt;uses_new_polling = 1;
-	hcd-&gt;poll_rh = 0;
 
 	/* EHCI spec section 4.1 */
 	if ((retval = ehci_reset(ehci)) != 0) {
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 84e792d71c22..0931f5a7dec4 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -316,7 +316,7 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 	if (time_before (jiffies, ehci-&gt;next_statechange))
 		msleep(5);
 	spin_lock_irq (&amp;ehci-&gt;lock);
-	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags)) {
+	if (!HCD_HW_ACCESSIBLE(hcd)) {
 		spin_unlock_irq(&amp;ehci-&gt;lock);
 		return -ESHUTDOWN;
 	}
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 11a79c4f4a9d..233c288e3f93 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -1126,8 +1126,7 @@ submit_async (
 #endif
 
 	spin_lock_irqsave (&amp;ehci-&gt;lock, flags);
-	if (unlikely(!test_bit(HCD_FLAG_HW_ACCESSIBLE,
-			       &amp;ehci_to_hcd(ehci)-&gt;flags))) {
+	if (unlikely(!HCD_HW_ACCESSIBLE(ehci_to_hcd(ehci)))) {
 		rc = -ESHUTDOWN;
 		goto done;
 	}
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 805ec633a652..d640346f9b56 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -880,8 +880,7 @@ static int intr_submit (
 
 	spin_lock_irqsave (&amp;ehci-&gt;lock, flags);
 
-	if (unlikely(!test_bit(HCD_FLAG_HW_ACCESSIBLE,
-			&amp;ehci_to_hcd(ehci)-&gt;flags))) {
+	if (unlikely(!HCD_HW_ACCESSIBLE(ehci_to_hcd(ehci)))) {
 		status = -ESHUTDOWN;
 		goto done_not_linked;
 	}
@@ -1815,8 +1814,7 @@ static int itd_submit (struct ehci_hcd *ehci, struct urb *urb,
 
 	/* schedule ... need to lock */
 	spin_lock_irqsave (&amp;ehci-&gt;lock, flags);
-	if (unlikely(!test_bit(HCD_FLAG_HW_ACCESSIBLE,
-			       &amp;ehci_to_hcd(ehci)-&gt;flags))) {
+	if (unlikely(!HCD_HW_ACCESSIBLE(ehci_to_hcd(ehci)))) {
 		status = -ESHUTDOWN;
 		goto done_not_linked;
 	}
@@ -2201,8 +2199,7 @@ static int sitd_submit (struct ehci_hcd *ehci, struct urb *urb,
 
 	/* schedule ... need to lock */
 	spin_lock_irqsave (&amp;ehci-&gt;lock, flags);
-	if (unlikely(!test_bit(HCD_FLAG_HW_ACCESSIBLE,
-			       &amp;ehci_to_hcd(ehci)-&gt;flags))) {
+	if (unlikely(!HCD_HW_ACCESSIBLE(ehci_to_hcd(ehci)))) {
 		status = -ESHUTDOWN;
 		goto done_not_linked;
 	}
diff --git a/drivers/usb/host/hwa-hc.c b/drivers/usb/host/hwa-hc.c
index 35742f8c7cda..9bfac657572e 100644
--- a/drivers/usb/host/hwa-hc.c
+++ b/drivers/usb/host/hwa-hc.c
@@ -159,7 +159,7 @@ static int hwahc_op_start(struct usb_hcd *usb_hcd)
 		goto error_set_cluster_id;
 
 	usb_hcd-&gt;uses_new_polling = 1;
-	usb_hcd-&gt;poll_rh = 1;
+	set_bit(HCD_FLAG_POLL_RH, &amp;usb_hcd-&gt;flags);
 	usb_hcd-&gt;state = HC_STATE_RUNNING;
 	result = 0;
 out:
@@ -776,7 +776,7 @@ static int hwahc_probe(struct usb_interface *usb_iface,
 		goto error_alloc;
 	}
 	usb_hcd-&gt;wireless = 1;
-	usb_hcd-&gt;flags |= HCD_FLAG_SAW_IRQ;
+	set_bit(HCD_FLAG_SAW_IRQ, &amp;usb_hcd-&gt;flags);
 	wusbhc = usb_hcd_to_wusbhc(usb_hcd);
 	hwahc = container_of(wusbhc, struct hwahc, wusbhc);
 	hwahc_init(hwahc);
diff --git a/drivers/usb/host/isp1760-hcd.c b/drivers/usb/host/isp1760-hcd.c
index dbcafa29c775..d1a3dfc9a408 100644
--- a/drivers/usb/host/isp1760-hcd.c
+++ b/drivers/usb/host/isp1760-hcd.c
@@ -482,7 +482,6 @@ static int isp1760_run(struct usb_hcd *hcd)
 	u32 chipid;
 
 	hcd-&gt;uses_new_polling = 1;
-	hcd-&gt;poll_rh = 0;
 
 	hcd-&gt;state = HC_STATE_RUNNING;
 	isp1760_enable_interrupts(hcd);
@@ -1450,7 +1449,7 @@ static int isp1760_prepare_enqueue(struct isp1760_hcd *priv, struct urb *urb,
 	epnum = urb-&gt;ep-&gt;desc.bEndpointAddress;
 
 	spin_lock_irqsave(&amp;priv-&gt;lock, flags);
-	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;priv_to_hcd(priv)-&gt;flags)) {
+	if (!HCD_HW_ACCESSIBLE(priv_to_hcd(priv))) {
 		rc = -ESHUTDOWN;
 		goto done;
 	}
diff --git a/drivers/usb/host/ohci-dbg.c b/drivers/usb/host/ohci-dbg.c
index 8ad2441b0284..36abd2baa3ea 100644
--- a/drivers/usb/host/ohci-dbg.c
+++ b/drivers/usb/host/ohci-dbg.c
@@ -645,7 +645,7 @@ static ssize_t fill_registers_buffer(struct debug_buffer *buf)
 		hcd-&gt;product_desc,
 		hcd_name);
 
-	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags)) {
+	if (!HCD_HW_ACCESSIBLE(hcd)) {
 		size -= scnprintf (next, size,
 			"SUSPENDED (no register access)\n");
 		goto done;
@@ -687,7 +687,7 @@ static ssize_t fill_registers_buffer(struct debug_buffer *buf)
 	next += temp;
 
 	temp = scnprintf (next, size, "hub poll timer %s\n",
-			ohci_to_hcd(ohci)-&gt;poll_rh ? "ON" : "off");
+			HCD_POLL_RH(ohci_to_hcd(ohci)) ? "ON" : "off");
 	size -= temp;
 	next += temp;
 
diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index 02864a237a2c..c3b4ccc7337b 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -212,7 +212,7 @@ static int ohci_urb_enqueue (
 	spin_lock_irqsave (&amp;ohci-&gt;lock, flags);
 
 	/* don't submit to a dead HC */
-	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags)) {
+	if (!HCD_HW_ACCESSIBLE(hcd)) {
 		retval = -ENODEV;
 		goto fail;
 	}
@@ -685,7 +685,7 @@ static int ohci_run (struct ohci_hcd *ohci)
 	}
 
 	/* use rhsc irqs after khubd is fully initialized */
-	hcd-&gt;poll_rh = 1;
+	set_bit(HCD_FLAG_POLL_RH, &amp;hcd-&gt;flags);
 	hcd-&gt;uses_new_polling = 1;
 
 	/* start controller operations */
@@ -822,7 +822,7 @@ static irqreturn_t ohci_irq (struct usb_hcd *hcd)
 	else if (ints &amp; OHCI_INTR_RD) {
 		ohci_vdbg(ohci, "resume detect\n");
 		ohci_writel(ohci, OHCI_INTR_RD, &amp;regs-&gt;intrstatus);
-		hcd-&gt;poll_rh = 1;
+		set_bit(HCD_FLAG_POLL_RH, &amp;hcd-&gt;flags);
 		if (ohci-&gt;autostop) {
 			spin_lock (&amp;ohci-&gt;lock);
 			ohci_rh_resume (ohci);
diff --git a/drivers/usb/host/ohci-hub.c b/drivers/usb/host/ohci-hub.c
index 65cac8cc8921..4dd39022c388 100644
--- a/drivers/usb/host/ohci-hub.c
+++ b/drivers/usb/host/ohci-hub.c
@@ -284,7 +284,7 @@ static int ohci_bus_suspend (struct usb_hcd *hcd)
 
 	spin_lock_irq (&amp;ohci-&gt;lock);
 
-	if (unlikely(!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags)))
+	if (unlikely(!HCD_HW_ACCESSIBLE(hcd)))
 		rc = -ESHUTDOWN;
 	else
 		rc = ohci_rh_suspend (ohci, 0);
@@ -302,7 +302,7 @@ static int ohci_bus_resume (struct usb_hcd *hcd)
 
 	spin_lock_irq (&amp;ohci-&gt;lock);
 
-	if (unlikely(!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags)))
+	if (unlikely(!HCD_HW_ACCESSIBLE(hcd)))
 		rc = -ESHUTDOWN;
 	else
 		rc = ohci_rh_resume (ohci);
@@ -489,7 +489,7 @@ ohci_hub_status_data (struct usb_hcd *hcd, char *buf)
 	unsigned long	flags;
 
 	spin_lock_irqsave (&amp;ohci-&gt;lock, flags);
-	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags))
+	if (!HCD_HW_ACCESSIBLE(hcd))
 		goto done;
 
 	/* undocumented erratum seen on at least rev D */
@@ -533,8 +533,12 @@ ohci_hub_status_data (struct usb_hcd *hcd, char *buf)
 		}
 	}
 
-	hcd-&gt;poll_rh = ohci_root_hub_state_changes(ohci, changed,
-			any_connected, rhsc_status);
+	if (ohci_root_hub_state_changes(ohci, changed,
+			any_connected, rhsc_status))
+		set_bit(HCD_FLAG_POLL_RH, &amp;hcd-&gt;flags);
+	else
+		clear_bit(HCD_FLAG_POLL_RH, &amp;hcd-&gt;flags);
+
 
 done:
 	spin_unlock_irqrestore (&amp;ohci-&gt;lock, flags);
@@ -701,7 +705,7 @@ static int ohci_hub_control (
 	u32		temp;
 	int		retval = 0;
 
-	if (unlikely(!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags)))
+	if (unlikely(!HCD_HW_ACCESSIBLE(hcd)))
 		return -ESHUTDOWN;
 
 	switch (typeReq) {
diff --git a/drivers/usb/host/oxu210hp-hcd.c b/drivers/usb/host/oxu210hp-hcd.c
index f608dfd09a8a..d9c85a292737 100644
--- a/drivers/usb/host/oxu210hp-hcd.c
+++ b/drivers/usb/host/oxu210hp-hcd.c
@@ -1641,8 +1641,7 @@ static int submit_async(struct oxu_hcd	*oxu, struct urb *urb,
 #endif
 
 	spin_lock_irqsave(&amp;oxu-&gt;lock, flags);
-	if (unlikely(!test_bit(HCD_FLAG_HW_ACCESSIBLE,
-			       &amp;oxu_to_hcd(oxu)-&gt;flags))) {
+	if (unlikely(!HCD_HW_ACCESSIBLE(oxu_to_hcd(oxu)))) {
 		rc = -ESHUTDOWN;
 		goto done;
 	}
@@ -2209,8 +2208,7 @@ static int intr_submit(struct oxu_hcd *oxu, struct urb *urb,
 
 	spin_lock_irqsave(&amp;oxu-&gt;lock, flags);
 
-	if (unlikely(!test_bit(HCD_FLAG_HW_ACCESSIBLE,
-			       &amp;oxu_to_hcd(oxu)-&gt;flags))) {
+	if (unlikely(!HCD_HW_ACCESSIBLE(oxu_to_hcd(oxu)))) {
 		status = -ESHUTDOWN;
 		goto done;
 	}
@@ -2715,7 +2713,6 @@ static int oxu_run(struct usb_hcd *hcd)
 	u32 temp, hcc_params;
 
 	hcd-&gt;uses_new_polling = 1;
-	hcd-&gt;poll_rh = 0;
 
 	/* EHCI spec section 4.1 */
 	retval = ehci_reset(oxu);
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index d1dce2166eff..2743ec770f0c 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -140,7 +140,7 @@ static void finish_reset(struct uhci_hcd *uhci)
 	uhci-&gt;rh_state = UHCI_RH_RESET;
 	uhci-&gt;is_stopped = UHCI_IS_STOPPED;
 	uhci_to_hcd(uhci)-&gt;state = HC_STATE_HALT;
-	uhci_to_hcd(uhci)-&gt;poll_rh = 0;
+	clear_bit(HCD_FLAG_POLL_RH, &amp;uhci_to_hcd(uhci)-&gt;flags);
 
 	uhci-&gt;dead = 0;		/* Full reset resurrects the controller */
 }
@@ -344,7 +344,10 @@ __acquires(uhci-&gt;lock)
 	/* If interrupts don't work and remote wakeup is enabled then
 	 * the suspended root hub needs to be polled.
 	 */
-	uhci_to_hcd(uhci)-&gt;poll_rh = (!int_enable &amp;&amp; wakeup_enable);
+	if (!int_enable &amp;&amp; wakeup_enable)
+		set_bit(HCD_FLAG_POLL_RH, &amp;uhci_to_hcd(uhci)-&gt;flags);
+	else
+		clear_bit(HCD_FLAG_POLL_RH, &amp;uhci_to_hcd(uhci)-&gt;flags);
 
 	uhci_scan_schedule(uhci);
 	uhci_fsbr_off(uhci);
@@ -363,7 +366,7 @@ static void start_rh(struct uhci_hcd *uhci)
 			uhci-&gt;io_addr + USBINTR);
 	mb();
 	uhci-&gt;rh_state = UHCI_RH_RUNNING;
-	uhci_to_hcd(uhci)-&gt;poll_rh = 1;
+	set_bit(HCD_FLAG_POLL_RH, &amp;uhci_to_hcd(uhci)-&gt;flags);
 }
 
 static void wakeup_rh(struct uhci_hcd *uhci)
@@ -733,7 +736,7 @@ static void uhci_stop(struct usb_hcd *hcd)
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 
 	spin_lock_irq(&amp;uhci-&gt;lock);
-	if (test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags) &amp;&amp; !uhci-&gt;dead)
+	if (HCD_HW_ACCESSIBLE(hcd) &amp;&amp; !uhci-&gt;dead)
 		uhci_hc_died(uhci);
 	uhci_scan_schedule(uhci);
 	spin_unlock_irq(&amp;uhci-&gt;lock);
@@ -750,7 +753,7 @@ static int uhci_rh_suspend(struct usb_hcd *hcd)
 	int rc = 0;
 
 	spin_lock_irq(&amp;uhci-&gt;lock);
-	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags))
+	if (!HCD_HW_ACCESSIBLE(hcd))
 		rc = -ESHUTDOWN;
 	else if (uhci-&gt;dead)
 		;		/* Dead controllers tell no tales */
@@ -777,7 +780,7 @@ static int uhci_rh_resume(struct usb_hcd *hcd)
 	int rc = 0;
 
 	spin_lock_irq(&amp;uhci-&gt;lock);
-	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags))
+	if (!HCD_HW_ACCESSIBLE(hcd))
 		rc = -ESHUTDOWN;
 	else if (!uhci-&gt;dead)
 		wakeup_rh(uhci);
@@ -793,7 +796,7 @@ static int uhci_pci_suspend(struct usb_hcd *hcd)
 	dev_dbg(uhci_dev(uhci), "%s\n", __func__);
 
 	spin_lock_irq(&amp;uhci-&gt;lock);
-	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags) || uhci-&gt;dead)
+	if (!HCD_HW_ACCESSIBLE(hcd) || uhci-&gt;dead)
 		goto done_okay;		/* Already suspended or dead */
 
 	if (uhci-&gt;rh_state &gt; UHCI_RH_SUSPENDED) {
@@ -807,7 +810,7 @@ static int uhci_pci_suspend(struct usb_hcd *hcd)
 	 */
 	pci_write_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP, 0);
 	mb();
-	hcd-&gt;poll_rh = 0;
+	clear_bit(HCD_FLAG_POLL_RH, &amp;hcd-&gt;flags);
 
 	/* FIXME: Enable non-PME# remote wakeup? */
 
@@ -860,7 +863,7 @@ static int uhci_pci_resume(struct usb_hcd *hcd, bool hibernated)
 	 * the suspended root hub needs to be polled.
 	 */
 	if (!uhci-&gt;RD_enable &amp;&amp; hcd-&gt;self.root_hub-&gt;do_remote_wakeup) {
-		hcd-&gt;poll_rh = 1;
+		set_bit(HCD_FLAG_POLL_RH, &amp;hcd-&gt;flags);
 		usb_hcd_poll_rh_status(hcd);
 	}
 	return 0;
diff --git a/drivers/usb/host/uhci-hub.c b/drivers/usb/host/uhci-hub.c
index 8270055848ca..f0c58116c0ad 100644
--- a/drivers/usb/host/uhci-hub.c
+++ b/drivers/usb/host/uhci-hub.c
@@ -190,7 +190,7 @@ static int uhci_hub_status_data(struct usb_hcd *hcd, char *buf)
 	spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
 
 	uhci_scan_schedule(uhci);
-	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags) || uhci-&gt;dead)
+	if (!HCD_HW_ACCESSIBLE(hcd) || uhci-&gt;dead)
 		goto done;
 	uhci_check_ports(uhci);
 
@@ -246,7 +246,7 @@ static int uhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 	u16 wPortChange, wPortStatus;
 	unsigned long flags;
 
-	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags) || uhci-&gt;dead)
+	if (!HCD_HW_ACCESSIBLE(hcd) || uhci-&gt;dead)
 		return -ETIMEDOUT;
 
 	spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
diff --git a/drivers/usb/host/whci/hcd.c b/drivers/usb/host/whci/hcd.c
index e0d3401285c8..72b6892fda67 100644
--- a/drivers/usb/host/whci/hcd.c
+++ b/drivers/usb/host/whci/hcd.c
@@ -68,7 +68,7 @@ static int whc_start(struct usb_hcd *usb_hcd)
 	whc_write_wusbcmd(whc, WUSBCMD_RUN, WUSBCMD_RUN);
 
 	usb_hcd-&gt;uses_new_polling = 1;
-	usb_hcd-&gt;poll_rh = 1;
+	set_bit(HCD_FLAG_POLL_RH, &amp;usb_hcd-&gt;flags);
 	usb_hcd-&gt;state = HC_STATE_RUNNING;
 
 out:
diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c
index 343f1047f5d0..5e73386b3899 100644
--- a/drivers/usb/host/xhci.c
+++ b/drivers/usb/host/xhci.c
@@ -427,7 +427,6 @@ int xhci_run(struct usb_hcd *hcd)
 	void (*doorbell)(struct xhci_hcd *) = NULL;
 
 	hcd-&gt;uses_new_polling = 1;
-	hcd-&gt;poll_rh = 0;
 
 	xhci_dbg(xhci, "xhci_run\n");
 #if 0	/* FIXME: MSI not setup yet */
@@ -733,7 +732,7 @@ int xhci_urb_enqueue(struct usb_hcd *hcd, struct urb *urb, gfp_t mem_flags)
 		ret = -EINVAL;
 		goto exit;
 	}
-	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags)) {
+	if (!HCD_HW_ACCESSIBLE(hcd)) {
 		if (!in_interrupt())
 			xhci_dbg(xhci, "urb submitted during PCI suspend\n");
 		ret = -ESHUTDOWN;
diff --git a/drivers/usb/musb/musb_virthub.c b/drivers/usb/musb/musb_virthub.c
index 92e85e027cfb..43233c397b6e 100644
--- a/drivers/usb/musb/musb_virthub.c
+++ b/drivers/usb/musb/musb_virthub.c
@@ -244,7 +244,7 @@ int musb_hub_control(
 
 	spin_lock_irqsave(&amp;musb-&gt;lock, flags);
 
-	if (unlikely(!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags))) {
+	if (unlikely(!HCD_HW_ACCESSIBLE(hcd))) {
 		spin_unlock_irqrestore(&amp;musb-&gt;lock, flags);
 		return -ESHUTDOWN;
 	}
diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 9b867e64a0f4..f8f8fa7a56e8 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -89,19 +89,31 @@ struct usb_hcd {
 	 */
 	const struct hc_driver	*driver;	/* hw-specific hooks */
 
-	/* Flags that need to be manipulated atomically */
+	/* Flags that need to be manipulated atomically because they can
+	 * change while the host controller is running.  Always use
+	 * set_bit() or clear_bit() to change their values.
+	 */
 	unsigned long		flags;
-#define HCD_FLAG_HW_ACCESSIBLE	0x00000001
-#define HCD_FLAG_SAW_IRQ	0x00000002
+#define HCD_FLAG_HW_ACCESSIBLE		0	/* at full power */
+#define HCD_FLAG_SAW_IRQ		1
+#define HCD_FLAG_POLL_RH		2	/* poll for rh status? */
+#define HCD_FLAG_POLL_PENDING		3	/* status has changed? */
+
+	/* The flags can be tested using these macros; they are likely to
+	 * be slightly faster than test_bit().
+	 */
+#define HCD_HW_ACCESSIBLE(hcd)	((hcd)-&gt;flags &amp; (1U &lt;&lt; HCD_FLAG_HW_ACCESSIBLE))
+#define HCD_SAW_IRQ(hcd)	((hcd)-&gt;flags &amp; (1U &lt;&lt; HCD_FLAG_SAW_IRQ))
+#define HCD_POLL_RH(hcd)	((hcd)-&gt;flags &amp; (1U &lt;&lt; HCD_FLAG_POLL_RH))
+#define HCD_POLL_PENDING(hcd)	((hcd)-&gt;flags &amp; (1U &lt;&lt; HCD_FLAG_POLL_PENDING))
 
+	/* Flags that get set only during HCD registration or removal. */
 	unsigned		rh_registered:1;/* is root hub registered? */
 	unsigned		rh_pollable:1;	/* may we poll the root hub? */
 
 	/* The next flag is a stopgap, to be removed when all the HCDs
 	 * support the new root-hub polling mechanism. */
 	unsigned		uses_new_polling:1;
-	unsigned		poll_rh:1;	/* poll for rh status? */
-	unsigned		poll_pending:1;	/* status has changed? */
 	unsigned		wireless:1;	/* Wireless USB HCD */
 	unsigned		authorized_default:1;
 	unsigned		has_tt:1;	/* Integrated TT in root hub */</pre><hr><pre>commit 37cd681c022a0a46ebcff025897a57457d3ca8cd
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 21 17:08:21 2010 -0400

    USB: EHCI: make CONFIG_USB_EHCI_TT_NEWSCHED default to Y
    
    This patch (as1382) changes the USB_EHCI_TT_NEWSCHED Kconfig option to
    be non-experimental and to default to Y.  This option has existed for
    a long time, and I have not heard any complaints concerning it.  By
    contrast, several people have reported that their devices could be
    made to work only by enabling the option.
    
    The point of changing the default is to cause the option to be enabled
    by distros that simply use the default settings for esoteric things
    like this.
    
    This change was motivated by Bugzilla #15649.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index f865be2276d4..2d926cec0725 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -72,8 +72,9 @@ config USB_EHCI_ROOT_HUB_TT
 	  from ARC, and has since changed hands a few times.
 
 config USB_EHCI_TT_NEWSCHED
-	bool "Improved Transaction Translator scheduling (EXPERIMENTAL)"
-	depends on USB_EHCI_HCD &amp;&amp; EXPERIMENTAL
+	bool "Improved Transaction Translator scheduling"
+	depends on USB_EHCI_HCD
+	default y
 	---help---
 	  This changes the periodic scheduling code to fill more of the low
 	  and full speed bandwidth available from the Transaction Translator
@@ -84,9 +85,11 @@ config USB_EHCI_TT_NEWSCHED
 	  If you have multiple periodic low/fullspeed devices connected to a
 	  highspeed USB hub which is connected to a highspeed USB Host
 	  Controller, and some of those devices will not work correctly
-	  (possibly due to "ENOSPC" or "-28" errors), say Y.
+	  (possibly due to "ENOSPC" or "-28" errors), say Y.  Conversely, if
+	  you have only one such device and it doesn't work, you could try
+	  saying N.
 
-	  If unsure, say N.
+	  If unsure, say Y.
 
 config USB_EHCI_BIG_ENDIAN_MMIO
 	bool</pre><hr><pre>commit ba297edde4dd7376832bafb23e032a40d5928b56
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jun 9 17:34:39 2010 -0400

    USB: UHCI: acquire spinlock before calling start_rh()
    
    This patch (as1392) fixes a bug in uhci-hcd: The start_rh() routine is
    supposed to be called with the private spinlock held.  If an IRQ comes
    in at just the wrong time, the driver will think the controller has
    died when in fact it simply hasn't start yet.
    
    The patch also addresses some issues that may prevent an URB from
    being unlinked after the controller has stopped.  This is an abnormal
    occurrence (ordinarily the controller stops only when the entire bus
    is suspended and hence there are no active URBs), so the pathways
    haven't gotten much testing.  These two changes may be a little more
    than is strictly necessary, but clearly they won't hurt.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 6637e52736dd..d1dce2166eff 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -691,7 +691,9 @@ static int uhci_start(struct usb_hcd *hcd)
 
 	configure_hc(uhci);
 	uhci-&gt;is_initialized = 1;
+	spin_lock_irq(&amp;uhci-&gt;lock);
 	start_rh(uhci);
+	spin_unlock_irq(&amp;uhci-&gt;lock);
 	return 0;
 
 /*
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index acd582c02802..d3ade4018487 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -565,7 +565,7 @@ static void uhci_unlink_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
 	qh-&gt;unlink_frame = uhci-&gt;frame_number;
 
 	/* Force an interrupt so we know when the QH is fully unlinked */
-	if (list_empty(&amp;uhci-&gt;skel_unlink_qh-&gt;node))
+	if (list_empty(&amp;uhci-&gt;skel_unlink_qh-&gt;node) || uhci-&gt;is_stopped)
 		uhci_set_next_interrupt(uhci);
 
 	/* Move the QH from its old list to the end of the unlinking list */
@@ -1667,7 +1667,7 @@ static int uhci_advance_check(struct uhci_hcd *uhci, struct uhci_qh *qh)
 			qh-&gt;advance_jiffies = jiffies;
 			goto done;
 		}
-		ret = 0;
+		ret = uhci-&gt;is_stopped;
 	}
 
 	/* The queue hasn't advanced; check for timeout */</pre><hr><pre>commit c548795abe0d3520b74e18f23ca0a0d72deddab9
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jun 9 17:34:27 2010 -0400

    USB: add check to detect host controller hardware removal
    
    This patch (as1391) fixes a problem that can occur when USB host
    controller hardware is hot-unplugged.  If no interrupts are generated
    by the unplug then the HCD may not realize that the controller is
    gone, and the subsequent unbind may hang waiting for interrupts that
    never arrive.
    
    The solution (for PCI-based controllers) is to call the HCD's
    interrupt handler at the start of usb_hcd_pci_remove().  If the
    hardware is gone, the handler will realize this when it tries to read
    the controller's status register.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd-pci.c b/drivers/usb/core/hcd-pci.c
index 1cf2d1e79a5c..7e2d5271b0c9 100644
--- a/drivers/usb/core/hcd-pci.c
+++ b/drivers/usb/core/hcd-pci.c
@@ -292,6 +292,14 @@ void usb_hcd_pci_remove(struct pci_dev *dev)
 	if (!hcd)
 		return;
 
+	/* Fake an interrupt request in order to give the driver a chance
+	 * to test whether the controller hardware has been removed (e.g.,
+	 * cardbus physical eject).
+	 */
+	local_irq_disable();
+	usb_hcd_irq(0, hcd);
+	local_irq_enable();
+
 	usb_remove_hcd(hcd);
 	if (hcd-&gt;driver-&gt;flags &amp; HCD_MEMORY) {
 		iounmap(hcd-&gt;regs);</pre><hr><pre>commit 6d88e6792574497bfac9a81403cc47712040636f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jun 9 17:34:17 2010 -0400

    USB: don't stop root-hub status polls too soon
    
    This patch (as1390) fixes a problem that crops up when a UHCI host
    controller is unbound from uhci-hcd while there are still some active
    URBs.  The URBs have to be unlinked when the root hub is unregistered,
    and uhci-hcd relies upon root-hub status polls as part of its
    unlinking procedure.  But usb_hcd_poll_rh_status() won't make those
    status calls if hcd-&gt;rh_registered is clear, and the flag is cleared
    _before_ the unregistration takes place.
    
    Since hcd-&gt;rh_registered is used for other things and needs to be
    cleared early, the solution is to add a new flag (rh_pollable) and use
    it instead.  It gets cleared _after_ the root hub is unregistered.
    
    Now that the status polls don't end too soon, we have to make sure
    they also don't occur too late -- after the root hub's usb_device
    structure or the HCD's private structures are deallocated.  Therefore
    the patch adds usb_get_device() and usb_put_device() calls to protect
    the root hub structure, and it adds an extra del_timer_sync() to
    prevent the root-hub timer from causing an unexpected status poll.
    
    This additional complexity would not be needed if the HCD framework
    had provided separate stop() and release() callbacks instead of just
    stop().  This lack could be fixed at some future time (although it
    would require changes to every host controller driver); when that
    happens this patch won't be needed any more.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index caae4625a1f1..53f14c82ff2e 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -667,7 +667,7 @@ void usb_hcd_poll_rh_status(struct usb_hcd *hcd)
 	unsigned long	flags;
 	char		buffer[6];	/* Any root hubs with &gt; 31 ports? */
 
-	if (unlikely(!hcd-&gt;rh_registered))
+	if (unlikely(!hcd-&gt;rh_pollable))
 		return;
 	if (!hcd-&gt;uses_new_polling &amp;&amp; !hcd-&gt;status_urb)
 		return;
@@ -2217,6 +2217,7 @@ int usb_add_hcd(struct usb_hcd *hcd,
 		retval = -ENOMEM;
 		goto err_allocate_root_hub;
 	}
+	hcd-&gt;self.root_hub = rhdev;
 
 	switch (hcd-&gt;driver-&gt;flags &amp; HCD_MASK) {
 	case HCD_USB11:
@@ -2231,7 +2232,6 @@ int usb_add_hcd(struct usb_hcd *hcd,
 	default:
 		goto err_set_rh_speed;
 	}
-	hcd-&gt;self.root_hub = rhdev;
 
 	/* wakeup flag init defaults to "everything works" for root hubs,
 	 * but drivers can override it in reset() if needed, along with
@@ -2246,6 +2246,7 @@ int usb_add_hcd(struct usb_hcd *hcd,
 		dev_err(hcd-&gt;self.controller, "can't setup\n");
 		goto err_hcd_driver_setup;
 	}
+	hcd-&gt;rh_pollable = 1;
 
 	/* NOTE: root hub and controller capabilities may not be the same */
 	if (device_can_wakeup(hcd-&gt;self.controller)
@@ -2315,9 +2316,12 @@ int usb_add_hcd(struct usb_hcd *hcd,
 	cancel_work_sync(&amp;hcd-&gt;wakeup_work);
 #endif
 	mutex_lock(&amp;usb_bus_list_lock);
-	usb_disconnect(&amp;hcd-&gt;self.root_hub);
+	usb_disconnect(&amp;rhdev);		/* Sets rhdev to NULL */
 	mutex_unlock(&amp;usb_bus_list_lock);
 err_register_root_hub:
+	hcd-&gt;rh_pollable = 0;
+	hcd-&gt;poll_rh = 0;
+	del_timer_sync(&amp;hcd-&gt;rh_timer);
 	hcd-&gt;driver-&gt;stop(hcd);
 	hcd-&gt;state = HC_STATE_HALT;
 	hcd-&gt;poll_rh = 0;
@@ -2328,8 +2332,7 @@ int usb_add_hcd(struct usb_hcd *hcd,
 err_request_irq:
 err_hcd_driver_setup:
 err_set_rh_speed:
-	hcd-&gt;self.root_hub = NULL;
-	usb_put_dev(rhdev);
+	usb_put_dev(hcd-&gt;self.root_hub);
 err_allocate_root_hub:
 	usb_deregister_bus(&amp;hcd-&gt;self);
 err_register_bus:
@@ -2348,9 +2351,12 @@ EXPORT_SYMBOL_GPL(usb_add_hcd);
  */
 void usb_remove_hcd(struct usb_hcd *hcd)
 {
+	struct usb_device *rhdev = hcd-&gt;self.root_hub;
+
 	dev_info(hcd-&gt;self.controller, "remove, state %x\n", hcd-&gt;state);
 
-	sysfs_remove_group(&amp;hcd-&gt;self.root_hub-&gt;dev.kobj, &amp;usb_bus_attr_group);
+	usb_get_dev(rhdev);
+	sysfs_remove_group(&amp;rhdev-&gt;dev.kobj, &amp;usb_bus_attr_group);
 
 	if (HC_IS_RUNNING (hcd-&gt;state))
 		hcd-&gt;state = HC_STATE_QUIESCING;
@@ -2365,17 +2371,29 @@ void usb_remove_hcd(struct usb_hcd *hcd)
 #endif
 
 	mutex_lock(&amp;usb_bus_list_lock);
-	usb_disconnect(&amp;hcd-&gt;self.root_hub);
+	usb_disconnect(&amp;rhdev);		/* Sets rhdev to NULL */
 	mutex_unlock(&amp;usb_bus_list_lock);
 
+	/* Prevent any more root-hub status calls from the timer.
+	 * The HCD might still restart the timer (if a port status change
+	 * interrupt occurs), but usb_hcd_poll_rh_status() won't invoke
+	 * the hub_status_data() callback.
+	 */
+	hcd-&gt;rh_pollable = 0;
+	hcd-&gt;poll_rh = 0;
+	del_timer_sync(&amp;hcd-&gt;rh_timer);
+
 	hcd-&gt;driver-&gt;stop(hcd);
 	hcd-&gt;state = HC_STATE_HALT;
 
+	/* In case the HCD restarted the timer, stop it again. */
 	hcd-&gt;poll_rh = 0;
 	del_timer_sync(&amp;hcd-&gt;rh_timer);
 
 	if (hcd-&gt;irq &gt;= 0)
 		free_irq(hcd-&gt;irq, hcd);
+
+	usb_put_dev(hcd-&gt;self.root_hub);
 	usb_deregister_bus(&amp;hcd-&gt;self);
 	hcd_buffer_destroy(hcd);
 }
diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 2e3a4ea1a3da..11b638195901 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -95,6 +95,7 @@ struct usb_hcd {
 #define HCD_FLAG_SAW_IRQ	0x00000002
 
 	unsigned		rh_registered:1;/* is root hub registered? */
+	unsigned		rh_pollable:1;	/* may we poll the root hub? */
 
 	/* The next flag is a stopgap, to be removed when all the HCDs
 	 * support the new root-hub polling mechanism. */</pre><hr><pre>commit 96e077ae347912dfce0e93f5958efc3ed6f311f4
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jun 9 17:34:05 2010 -0400

    USB: fix failure path in usb_add_hcd()
    
    This patch (as1389) fixes some errors in the failure pathway of
    usb_add_hcd().  The actions it takes ought to be exactly the same as
    those taken by usb_remove_hcd(), but they aren't.
    
    In one case (removal of the usb_bus_attr_group), the two routines are
    brought into agreement by changing usb_remove_hcd().  All the other
    discrepancies are fixed by changing usb_add_hcd().
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 12742f152f43..caae4625a1f1 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -2229,7 +2229,7 @@ int usb_add_hcd(struct usb_hcd *hcd,
 		rhdev-&gt;speed = USB_SPEED_SUPER;
 		break;
 	default:
-		goto err_allocate_root_hub;
+		goto err_set_rh_speed;
 	}
 	hcd-&gt;self.root_hub = rhdev;
 
@@ -2305,16 +2305,29 @@ int usb_add_hcd(struct usb_hcd *hcd,
 	return retval;
 
 error_create_attr_group:
+	if (HC_IS_RUNNING(hcd-&gt;state))
+		hcd-&gt;state = HC_STATE_QUIESCING;
+	spin_lock_irq(&amp;hcd_root_hub_lock);
+	hcd-&gt;rh_registered = 0;
+	spin_unlock_irq(&amp;hcd_root_hub_lock);
+
+#ifdef CONFIG_USB_SUSPEND
+	cancel_work_sync(&amp;hcd-&gt;wakeup_work);
+#endif
 	mutex_lock(&amp;usb_bus_list_lock);
 	usb_disconnect(&amp;hcd-&gt;self.root_hub);
 	mutex_unlock(&amp;usb_bus_list_lock);
 err_register_root_hub:
 	hcd-&gt;driver-&gt;stop(hcd);
+	hcd-&gt;state = HC_STATE_HALT;
+	hcd-&gt;poll_rh = 0;
+	del_timer_sync(&amp;hcd-&gt;rh_timer);
 err_hcd_driver_start:
 	if (hcd-&gt;irq &gt;= 0)
 		free_irq(irqnum, hcd);
 err_request_irq:
 err_hcd_driver_setup:
+err_set_rh_speed:
 	hcd-&gt;self.root_hub = NULL;
 	usb_put_dev(rhdev);
 err_allocate_root_hub:
@@ -2337,6 +2350,8 @@ void usb_remove_hcd(struct usb_hcd *hcd)
 {
 	dev_info(hcd-&gt;self.controller, "remove, state %x\n", hcd-&gt;state);
 
+	sysfs_remove_group(&amp;hcd-&gt;self.root_hub-&gt;dev.kobj, &amp;usb_bus_attr_group);
+
 	if (HC_IS_RUNNING (hcd-&gt;state))
 		hcd-&gt;state = HC_STATE_QUIESCING;
 
@@ -2349,7 +2364,6 @@ void usb_remove_hcd(struct usb_hcd *hcd)
 	cancel_work_sync(&amp;hcd-&gt;wakeup_work);
 #endif
 
-	sysfs_remove_group(&amp;hcd-&gt;self.root_hub-&gt;dev.kobj, &amp;usb_bus_attr_group);
 	mutex_lock(&amp;usb_bus_list_lock);
 	usb_disconnect(&amp;hcd-&gt;self.root_hub);
 	mutex_unlock(&amp;usb_bus_list_lock);</pre><hr><pre>commit e6da54d84f9286edbe4c92ff5023ff481ce2a5c9
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Aug 5 13:17:10 2010 -0400

    SCSI: remove fake "address-of" expression
    
    Fake "address-of" expressions that evaluate to NULL generally confuse
    readers and can provoke compiler warnings.  This patch (as1411) removes
    one such fake expression, using an "#ifdef" in its place.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;

diff --git a/drivers/scsi/scsi_priv.h b/drivers/scsi/scsi_priv.h
index 026295e2c539..b4056d14f812 100644
--- a/drivers/scsi/scsi_priv.h
+++ b/drivers/scsi/scsi_priv.h
@@ -148,8 +148,6 @@ static inline void scsi_netlink_exit(void) {}
 /* scsi_pm.c */
 #ifdef CONFIG_PM_OPS
 extern const struct dev_pm_ops scsi_bus_pm_ops;
-#else /* CONFIG_PM_OPS */
-#define scsi_bus_pm_ops		(*NULL)
 #endif
 #ifdef CONFIG_PM_RUNTIME
 extern void scsi_autopm_get_target(struct scsi_target *);
diff --git a/drivers/scsi/scsi_sysfs.c b/drivers/scsi/scsi_sysfs.c
index 562fb3bce261..c3f67373a4f8 100644
--- a/drivers/scsi/scsi_sysfs.c
+++ b/drivers/scsi/scsi_sysfs.c
@@ -381,7 +381,9 @@ struct bus_type scsi_bus_type = {
         .name		= "scsi",
         .match		= scsi_bus_match,
 	.uevent		= scsi_bus_uevent,
+#ifdef CONFIG_PM_OPS
 	.pm		= &amp;scsi_bus_pm_ops,
+#endif
 };
 EXPORT_SYMBOL_GPL(scsi_bus_type);
 </pre><hr><pre>commit 26845f585fad66dc23d87dad89d403cd64b48780
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Aug 5 13:17:10 2010 -0400

    [SCSI] remove fake "address-of" expression
    
    Fake "address-of" expressions that evaluate to NULL generally confuse
    readers and can provoke compiler warnings.  This patch (as1411)
    removes one such fake expression introduced by:
    
    commit db5bd1e0b505c54ff492172ce4abc245cf6cd639
    Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Date:   Thu Jun 17 10:36:49 2010 -0400
    
        [SCSI] convert to the new PM framework
    
    using an "#ifdef" in its place.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/scsi_priv.h b/drivers/scsi/scsi_priv.h
index 026295e2c539..b4056d14f812 100644
--- a/drivers/scsi/scsi_priv.h
+++ b/drivers/scsi/scsi_priv.h
@@ -148,8 +148,6 @@ static inline void scsi_netlink_exit(void) {}
 /* scsi_pm.c */
 #ifdef CONFIG_PM_OPS
 extern const struct dev_pm_ops scsi_bus_pm_ops;
-#else /* CONFIG_PM_OPS */
-#define scsi_bus_pm_ops		(*NULL)
 #endif
 #ifdef CONFIG_PM_RUNTIME
 extern void scsi_autopm_get_target(struct scsi_target *);
diff --git a/drivers/scsi/scsi_sysfs.c b/drivers/scsi/scsi_sysfs.c
index 562fb3bce261..c3f67373a4f8 100644
--- a/drivers/scsi/scsi_sysfs.c
+++ b/drivers/scsi/scsi_sysfs.c
@@ -381,7 +381,9 @@ struct bus_type scsi_bus_type = {
         .name		= "scsi",
         .match		= scsi_bus_match,
 	.uevent		= scsi_bus_uevent,
+#ifdef CONFIG_PM_OPS
 	.pm		= &amp;scsi_bus_pm_ops,
+#endif
 };
 EXPORT_SYMBOL_GPL(scsi_bus_type);
 </pre><hr><pre>commit f3ec4f87d607f40497afdb5ac03f11e2ea253d52
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jun 8 15:23:51 2010 -0400

    PCI: change device runtime PM settings for probe and remove
    
    This patch (as1388) changes the way the PCI core handles runtime PM
    settings when probing or unbinding drivers.  Now the core will make
    sure the device is enabled for runtime PM, with a usage count &gt;= 1,
    when a driver is probed.  It does the same when calling a driver's
    remove method.
    
    If the driver wants to use runtime PM, all it has to do is call
    pm_runtime_pu_noidle() near the end of its probe routine (to cancel
    the core's usage increment) and pm_runtime_get_noresume() near the
    start of its remove routine (to restore the usage count).  It does not
    need to mess around with setting the runtime state to enabled,
    disabled, active, or suspended.
    
    The patch updates e1000e and r8169, the only PCI drivers that already
    use the existing runtime PM interface.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;
    Signed-off-by: Jesse Barnes &lt;jbarnes@virtuousgeek.org&gt;

diff --git a/drivers/net/e1000e/netdev.c b/drivers/net/e1000e/netdev.c
index 57a7e41da69e..4afc8dd9b935 100644
--- a/drivers/net/e1000e/netdev.c
+++ b/drivers/net/e1000e/netdev.c
@@ -5721,11 +5721,8 @@ static int __devinit e1000_probe(struct pci_dev *pdev,
 
 	e1000_print_device_info(adapter);
 
-	if (pci_dev_run_wake(pdev)) {
-		pm_runtime_set_active(&amp;pdev-&gt;dev);
-		pm_runtime_enable(&amp;pdev-&gt;dev);
-	}
-	pm_schedule_suspend(&amp;pdev-&gt;dev, MSEC_PER_SEC);
+	if (pci_dev_run_wake(pdev))
+		pm_runtime_put_noidle(&amp;pdev-&gt;dev);
 
 	return 0;
 
@@ -5771,8 +5768,6 @@ static void __devexit e1000_remove(struct pci_dev *pdev)
 	struct e1000_adapter *adapter = netdev_priv(netdev);
 	bool down = test_bit(__E1000_DOWN, &amp;adapter-&gt;state);
 
-	pm_runtime_get_sync(&amp;pdev-&gt;dev);
-
 	/*
 	 * flush_scheduled work may reschedule our watchdog task, so
 	 * explicitly disable watchdog tasks from being rescheduled
@@ -5797,11 +5792,8 @@ static void __devexit e1000_remove(struct pci_dev *pdev)
 		clear_bit(__E1000_DOWN, &amp;adapter-&gt;state);
 	unregister_netdev(netdev);
 
-	if (pci_dev_run_wake(pdev)) {
-		pm_runtime_disable(&amp;pdev-&gt;dev);
-		pm_runtime_set_suspended(&amp;pdev-&gt;dev);
-	}
-	pm_runtime_put_noidle(&amp;pdev-&gt;dev);
+	if (pci_dev_run_wake(pdev))
+		pm_runtime_get_noresume(&amp;pdev-&gt;dev);
 
 	/*
 	 * Release control of h/w to f/w.  If f/w is AMT enabled, this
diff --git a/drivers/net/r8169.c b/drivers/net/r8169.c
index cdc6a5c2e70d..c982a4763bef 100644
--- a/drivers/net/r8169.c
+++ b/drivers/net/r8169.c
@@ -3219,11 +3219,8 @@ rtl8169_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	device_set_wakeup_enable(&amp;pdev-&gt;dev, tp-&gt;features &amp; RTL_FEATURE_WOL);
 
-	if (pci_dev_run_wake(pdev)) {
-		pm_runtime_set_active(&amp;pdev-&gt;dev);
-		pm_runtime_enable(&amp;pdev-&gt;dev);
-	}
-	pm_runtime_idle(&amp;pdev-&gt;dev);
+	if (pci_dev_run_wake(pdev))
+		pm_runtime_put_noidle(&amp;pdev-&gt;dev);
 
 out:
 	return rc;
@@ -3246,17 +3243,12 @@ static void __devexit rtl8169_remove_one(struct pci_dev *pdev)
 	struct net_device *dev = pci_get_drvdata(pdev);
 	struct rtl8169_private *tp = netdev_priv(dev);
 
-	pm_runtime_get_sync(&amp;pdev-&gt;dev);
-
 	flush_scheduled_work();
 
 	unregister_netdev(dev);
 
-	if (pci_dev_run_wake(pdev)) {
-		pm_runtime_disable(&amp;pdev-&gt;dev);
-		pm_runtime_set_suspended(&amp;pdev-&gt;dev);
-	}
-	pm_runtime_put_noidle(&amp;pdev-&gt;dev);
+	if (pci_dev_run_wake(pdev))
+		pm_runtime_get_noresume(&amp;pdev-&gt;dev);
 
 	/* restore original MAC address */
 	rtl_rar_set(tp, dev-&gt;perm_addr);
diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index f9a0aec3abcf..8a6f797de8e5 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -289,8 +289,26 @@ struct drv_dev_and_id {
 static long local_pci_probe(void *_ddi)
 {
 	struct drv_dev_and_id *ddi = _ddi;
-
-	return ddi-&gt;drv-&gt;probe(ddi-&gt;dev, ddi-&gt;id);
+	struct device *dev = &amp;ddi-&gt;dev-&gt;dev;
+	int rc;
+
+	/* Unbound PCI devices are always set to disabled and suspended.
+	 * During probe, the device is set to enabled and active and the
+	 * usage count is incremented.  If the driver supports runtime PM,
+	 * it should call pm_runtime_put_noidle() in its probe routine and
+	 * pm_runtime_get_noresume() in its remove routine.
+	 */
+	pm_runtime_get_noresume(dev);
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+
+	rc = ddi-&gt;drv-&gt;probe(ddi-&gt;dev, ddi-&gt;id);
+	if (rc) {
+		pm_runtime_disable(dev);
+		pm_runtime_set_suspended(dev);
+		pm_runtime_put_noidle(dev);
+	}
+	return rc;
 }
 
 static int pci_call_probe(struct pci_driver *drv, struct pci_dev *dev,
@@ -369,11 +387,19 @@ static int pci_device_remove(struct device * dev)
 	struct pci_driver * drv = pci_dev-&gt;driver;
 
 	if (drv) {
-		if (drv-&gt;remove)
+		if (drv-&gt;remove) {
+			pm_runtime_get_sync(dev);
 			drv-&gt;remove(pci_dev);
+			pm_runtime_put_noidle(dev);
+		}
 		pci_dev-&gt;driver = NULL;
 	}
 
+	/* Undo the runtime PM settings in local_pci_probe() */
+	pm_runtime_disable(dev);
+	pm_runtime_set_suspended(dev);
+	pm_runtime_put_noidle(dev);
+
 	/*
 	 * If the device is still on, set the power state as "unknown",
 	 * since it might change by the next time we load the driver.</pre>
    <div class="pagination">
        <a href='2_63.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><span>[64]</span><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_65.html'>Next&gt;&gt;</a>
    <div>
</body>
