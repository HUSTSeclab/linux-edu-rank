<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_129.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><span>[130]</span><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_131.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit a2149bce2535047371a1309f032f0320b05db791
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Feb 2 09:52:45 2006 -0500

    [PATCH] usb-storage: new unusual_devs entry
    
    This patch (as631) for unusual_devs.h fixes bugzilla entry 5913.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Phil Dibowitz &lt;phil@ipom.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index ee958f986eb8..c5d6d84b9b2b 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -1162,6 +1162,13 @@ UNUSUAL_DEV(  0x55aa, 0xa103, 0x0000, 0x9999,
 		US_FL_SINGLE_LUN),
 #endif
 
+/* Reported by Andrew Simmons &lt;andrew.simmons@gmail.com&gt; */
+UNUSUAL_DEV(  0xed06, 0x4500, 0x0001, 0x0001,
+		"DataStor",
+		"USB4500 FW1.04",
+		US_SC_DEVICE, US_PR_DEVICE, NULL,
+		US_FL_FIX_CAPACITY),
+
 /* Control/Bulk transport for all SubClass values */
 USUAL_DEV(US_SC_RBC, US_PR_CB, USB_US_TYPE_STOR),
 USUAL_DEV(US_SC_8020, US_PR_CB, USB_US_TYPE_STOR),</pre><hr><pre>commit 979063692726fa40863345fb1b62daf2f795ddc0
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jan 3 10:30:31 2006 -0500

    [PATCH] USB: gadgetfs: set "zero" flag for short control-IN response
    
    This patch (as622) makes gadgetfs set the "zero" flag for control-IN
    responses, when the length of the response is shorter than the length of
    the request.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: David Brownell &lt;david-b@pacbell.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/inode.c b/drivers/usb/gadget/inode.c
index 9a4edc5657aa..0aab7d24c768 100644
--- a/drivers/usb/gadget/inode.c
+++ b/drivers/usb/gadget/inode.c
@@ -135,6 +135,7 @@ struct dev_data {
 					setup_out_ready : 1,
 					setup_out_error : 1,
 					setup_abort : 1;
+	unsigned			setup_wLength;
 
 	/* the rest is basically write-once */
 	struct usb_config_descriptor	*config, *hs_config;
@@ -942,6 +943,7 @@ static int setup_req (struct usb_ep *ep, struct usb_request *req, u16 len)
 	}
 	req-&gt;complete = ep0_complete;
 	req-&gt;length = len;
+	req-&gt;zero = 0;
 	return 0;
 }
 
@@ -1161,10 +1163,13 @@ ep0_write (struct file *fd, const char __user *buf, size_t len, loff_t *ptr)
 				spin_unlock_irq (&amp;dev-&gt;lock);
 				if (copy_from_user (dev-&gt;req-&gt;buf, buf, len))
 					retval = -EFAULT;
-				else
+				else {
+					if (len &lt; dev-&gt;setup_wLength)
+						dev-&gt;req-&gt;zero = 1;
 					retval = usb_ep_queue (
 						dev-&gt;gadget-&gt;ep0, dev-&gt;req,
 						GFP_KERNEL);
+				}
 				if (retval &lt; 0) {
 					spin_lock_irq (&amp;dev-&gt;lock);
 					clean_req (dev-&gt;gadget-&gt;ep0, dev-&gt;req);
@@ -1483,6 +1488,7 @@ gadgetfs_setup (struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 delegate:
 			dev-&gt;setup_in = (ctrl-&gt;bRequestType &amp; USB_DIR_IN)
 						? 1 : 0;
+			dev-&gt;setup_wLength = w_length;
 			dev-&gt;setup_out_ready = 0;
 			dev-&gt;setup_out_error = 0;
 			value = 0;</pre><hr><pre>commit 630aa3cfd5f0bae9547fe7dff175d7323d60140d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jan 23 17:17:21 2006 -0500

    [PATCH] USB: UHCI: No FSBR until device is configured
    
    Some USB devices don't enumerate well with FSBR turned on.  This patch
    keeps devices on the low-speed part of the schedule (which doesn't use
    FSBR) until they have been fully configured.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index b6076004a437..782398045f9f 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -672,9 +672,9 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb, struct ur
 	/* Low-speed transfers get a different queue, and won't hog the bus.
 	 * Also, some devices enumerate better without FSBR; the easiest way
 	 * to do that is to put URBs on the low-speed queue while the device
-	 * is in the DEFAULT state. */
+	 * isn't in the CONFIGURED state. */
 	if (urb-&gt;dev-&gt;speed == USB_SPEED_LOW ||
-			urb-&gt;dev-&gt;state == USB_STATE_DEFAULT)
+			urb-&gt;dev-&gt;state != USB_STATE_CONFIGURED)
 		skelqh = uhci-&gt;skel_ls_control_qh;
 	else {
 		skelqh = uhci-&gt;skel_fs_control_qh;</pre><hr><pre>commit bf74ad5bc41727d5f2f1c6bedb2c1fac394de731
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Nov 17 16:54:12 2005 -0500

    [PATCH] Hold the device's parent's lock during probe and remove
    
    This patch (as604) makes the driver core hold a device's parent's lock
    as well as the device's lock during calls to the probe and remove
    methods in a driver.  This facility is needed by USB device drivers,
    owing to the peculiar way USB devices work:
    
            A device provides multiple interfaces, and drivers are bound
            to interfaces rather than to devices;
    
            Nevertheless a reset, reset-configuration, suspend, or resume
            affects the entire device and requires the caller to hold the
            lock for the device, not just a lock for one of the interfaces.
    
    Since a USB driver's probe method is always called with the interface
    lock held, the locking order rules (always lock parent before child)
    prevent these methods from acquiring the device lock.  The solution
    provided here is to call all probe and remove methods, for all devices
    (not just USB), with the parent lock already acquired.
    
    Although currently only the USB subsystem requires these changes, people
    have mentioned in prior discussion that the overhead of acquiring an
    extra semaphore in all the prove/remove sequences is not overly large.
    
    Up to now, the USB core has been using its own set of private
    semaphores.  A followup patch will remove them, relying entirely on the
    device semaphores provided by the driver core.
    
    The code paths affected by this patch are:
    
            device_add and device_del: The USB core already holds the parent
            lock, so no actual change is needed.
    
            driver_register and driver_unregister: The driver core will now
            lock both the parent and the device before probing or removing.
    
            driver_bind and driver_unbind (in sysfs): These routines will
            now lock both the parent and the device before binding or
            unbinding.
    
            bus_rescan_devices: The helper routine will lock the parent
            before probing a device.
    
    I have not tested this patch for conflicts with other subsystems.  As
    far as I can see, the only possibility of conflict would lie in the
    bus_rescan_devices pathway, and it seems pretty remote.  Nevertheless,
    it would be good for this to get a lot of testing in -mm.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/base/bus.c b/drivers/base/bus.c
index fa601b085eba..e3f915a24891 100644
--- a/drivers/base/bus.c
+++ b/drivers/base/bus.c
@@ -152,7 +152,11 @@ static ssize_t driver_unbind(struct device_driver *drv,
 
 	dev = bus_find_device(bus, NULL, (void *)buf, driver_helper);
 	if (dev &amp;&amp; dev-&gt;driver == drv) {
+		if (dev-&gt;parent)	/* Needed for USB */
+			down(&amp;dev-&gt;parent-&gt;sem);
 		device_release_driver(dev);
+		if (dev-&gt;parent)
+			up(&amp;dev-&gt;parent-&gt;sem);
 		err = count;
 	}
 	put_device(dev);
@@ -175,9 +179,13 @@ static ssize_t driver_bind(struct device_driver *drv,
 
 	dev = bus_find_device(bus, NULL, (void *)buf, driver_helper);
 	if (dev &amp;&amp; dev-&gt;driver == NULL) {
+		if (dev-&gt;parent)	/* Needed for USB */
+			down(&amp;dev-&gt;parent-&gt;sem);
 		down(&amp;dev-&gt;sem);
 		err = driver_probe_device(drv, dev);
 		up(&amp;dev-&gt;sem);
+		if (dev-&gt;parent)
+			up(&amp;dev-&gt;parent-&gt;sem);
 	}
 	put_device(dev);
 	put_bus(bus);
@@ -484,8 +492,13 @@ void bus_remove_driver(struct device_driver * drv)
 /* Helper for bus_rescan_devices's iter */
 static int bus_rescan_devices_helper(struct device *dev, void *data)
 {
-	if (!dev-&gt;driver)
+	if (!dev-&gt;driver) {
+		if (dev-&gt;parent)	/* Needed for USB */
+			down(&amp;dev-&gt;parent-&gt;sem);
 		device_attach(dev);
+		if (dev-&gt;parent)
+			up(&amp;dev-&gt;parent-&gt;sem);
+	}
 	return 0;
 }
 
diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 3b419c9a1e7e..2b905016664d 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -65,7 +65,8 @@ void device_bind_driver(struct device * dev)
  *	This function returns 1 if a match is found, an error if one
  *	occurs (that is not -ENODEV or -ENXIO), and 0 otherwise.
  *
- *	This function must be called with @dev-&gt;sem held.
+ *	This function must be called with @dev-&gt;sem held.  When called
+ *	for a USB interface, @dev-&gt;parent-&gt;sem must be held as well.
  */
 int driver_probe_device(struct device_driver * drv, struct device * dev)
 {
@@ -123,6 +124,8 @@ static int __device_attach(struct device_driver * drv, void * data)
  *
  *	Returns 1 if the device was bound to a driver;
  *	0 if no matching device was found; error code otherwise.
+ *
+ *	When called for a USB interface, @dev-&gt;parent-&gt;sem must be held.
  */
 int device_attach(struct device * dev)
 {
@@ -152,10 +155,14 @@ static int __driver_attach(struct device * dev, void * data)
 	 * is an error.
 	 */
 
+	if (dev-&gt;parent)	/* Needed for USB */
+		down(&amp;dev-&gt;parent-&gt;sem);
 	down(&amp;dev-&gt;sem);
 	if (!dev-&gt;driver)
 		driver_probe_device(drv, dev);
 	up(&amp;dev-&gt;sem);
+	if (dev-&gt;parent)
+		up(&amp;dev-&gt;parent-&gt;sem);
 
 	return 0;
 }
@@ -181,6 +188,8 @@ void driver_attach(struct device_driver * drv)
  *	Manually detach device from driver.
  *
  *	__device_release_driver() must be called with @dev-&gt;sem held.
+ *	When called for a USB interface, @dev-&gt;parent-&gt;sem must be held
+ *	as well.
  */
 
 static void __device_release_driver(struct device * dev)
@@ -233,10 +242,14 @@ void driver_detach(struct device_driver * drv)
 		get_device(dev);
 		spin_unlock(&amp;drv-&gt;klist_devices.k_lock);
 
+		if (dev-&gt;parent)	/* Needed for USB */
+			down(&amp;dev-&gt;parent-&gt;sem);
 		down(&amp;dev-&gt;sem);
 		if (dev-&gt;driver == drv)
 			__device_release_driver(dev);
 		up(&amp;dev-&gt;sem);
+		if (dev-&gt;parent)
+			up(&amp;dev-&gt;parent-&gt;sem);
 		put_device(dev);
 	}
 }</pre><hr><pre>commit f3d34ed48c80903544b509031fee64838d29f35f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Dec 13 10:32:13 2005 -0500

    [PATCH] USB: fix local variable clash
    
    This patch (as621) fixes a local variable conflict I accidently
    introduced into usb_set_configuration.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 99ab774d4fdb..319de03944e7 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1387,11 +1387,11 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 	if (dev-&gt;state != USB_STATE_ADDRESS)
 		usb_disable_device (dev, 1);	// Skip ep0
 
-	n = dev-&gt;bus_mA - cp-&gt;desc.bMaxPower * 2;
-	if (n &lt; 0)
+	i = dev-&gt;bus_mA - cp-&gt;desc.bMaxPower * 2;
+	if (i &lt; 0)
 		dev_warn(&amp;dev-&gt;dev, "new config #%d exceeds power "
 				"limit by %dmA\n",
-				configuration, -n);
+				configuration, -i);
 
 	if ((ret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
 			USB_REQ_SET_CONFIGURATION, 0, configuration, 0,</pre><hr><pre>commit 687f5f3428157bea4940dd967fd7b4e59c1b13b4
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Nov 30 17:16:19 2005 -0500

    [PATCH] USB: UHCI: edit some comments
    
    This patch (as615b) edits a large number of comments in the uhci-hcd code,
    mainly removing excess apostrophes.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-debug.c b/drivers/usb/host/uhci-debug.c
index cab02e15bfee..5832953086f8 100644
--- a/drivers/usb/host/uhci-debug.c
+++ b/drivers/usb/host/uhci-debug.c
@@ -2,8 +2,8 @@
  * UHCI-specific debugging code. Invaluable when something
  * goes wrong, but don't get in my face.
  *
- * Kernel visible pointers are surrounded in []'s and bus
- * visible pointers are surrounded in ()'s
+ * Kernel visible pointers are surrounded in []s and bus
+ * visible pointers are surrounded in ()s
  *
  * (C) Copyright 1999 Linus Torvalds
  * (C) Copyright 1999-2001 Johannes Erdfelt
@@ -19,7 +19,7 @@
 
 static struct dentry *uhci_debugfs_root = NULL;
 
-/* Handle REALLY large printk's so we don't overflow buffers */
+/* Handle REALLY large printks so we don't overflow buffers */
 static inline void lprintk(char *buf)
 {
 	char *p;
@@ -160,7 +160,7 @@ static int uhci_show_qh(struct uhci_qh *qh, char *buf, int len, int space)
 			}
 
 			if (active &amp;&amp; ni &gt; i) {
-				out += sprintf(out, "%*s[skipped %d active TD's]\n", space, "", ni - i);
+				out += sprintf(out, "%*s[skipped %d active TDs]\n", space, "", ni - i);
 				tmp = ntmp;
 				td = ntd;
 				i = ni;
@@ -173,7 +173,7 @@ static int uhci_show_qh(struct uhci_qh *qh, char *buf, int len, int space)
 	if (list_empty(&amp;urbp-&gt;queue_list) || urbp-&gt;queued)
 		goto out;
 
-	out += sprintf(out, "%*sQueued QH's:\n", -space, "--");
+	out += sprintf(out, "%*sQueued QHs:\n", -space, "--");
 
 	head = &amp;urbp-&gt;queue_list;
 	tmp = head-&gt;next;
@@ -464,7 +464,7 @@ static int uhci_sprint_schedule(struct uhci_hcd *uhci, char *buf, int len)
 		} while (tmp != head);
 	}
 
-	out += sprintf(out, "Skeleton QH's\n");
+	out += sprintf(out, "Skeleton QHs\n");
 
 	for (i = 0; i &lt; UHCI_NUM_SKELQH; ++i) {
 		int shown = 0;
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 120ca64fe3f7..dfe121d35887 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -62,10 +62,10 @@ Alan Stern"
 
 /*
  * debug = 0, no debugging messages
- * debug = 1, dump failed URB's except for stalls
- * debug = 2, dump all failed URB's (including stalls)
+ * debug = 1, dump failed URBs except for stalls
+ * debug = 2, dump all failed URBs (including stalls)
  *            show all queues in /debug/uhci/[pci_addr]
- * debug = 3, show all TD's in URB's when dumping
+ * debug = 3, show all TDs in URBs when dumping
  */
 #ifdef DEBUG
 static int debug = 1;
@@ -88,7 +88,7 @@ static void uhci_get_current_frame_number(struct uhci_hcd *uhci);
 #define FSBR_DELAY	msecs_to_jiffies(50)
 
 /* When we timeout an idle transfer for FSBR, we'll switch it over to */
-/* depth first traversal. We'll do it in groups of this number of TD's */
+/* depth first traversal. We'll do it in groups of this number of TDs */
 /* to make sure it doesn't hog all of the bandwidth */
 #define DEPTH_INTERVAL 5
 
@@ -728,8 +728,9 @@ static int uhci_resume(struct usb_hcd *hcd)
 
 	dev_dbg(uhci_dev(uhci), "%s\n", __FUNCTION__);
 
-	/* We aren't in D3 state anymore, we do that even if dead as I
-	 * really don't want to keep a stale HCD_FLAG_HW_ACCESSIBLE=0
+	/* Since we aren't in D3 any more, it's safe to set this flag
+	 * even if the controller was dead.  It might not even be dead
+	 * any more, if the firmware or quirks code has reset it.
 	 */
 	set_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
 	mb();
@@ -879,7 +880,7 @@ static int __init uhci_hcd_init(void)
 
 init_failed:
 	if (kmem_cache_destroy(uhci_up_cachep))
-		warn("not all urb_priv's were freed!");
+		warn("not all urb_privs were freed!");
 
 up_failed:
 	debugfs_remove(uhci_debugfs_root);
@@ -897,7 +898,7 @@ static void __exit uhci_hcd_cleanup(void)
 	pci_unregister_driver(&amp;uhci_pci_driver);
 	
 	if (kmem_cache_destroy(uhci_up_cachep))
-		warn("not all urb_priv's were freed!");
+		warn("not all urb_privs were freed!");
 
 	debugfs_remove(uhci_debugfs_root);
 	kfree(errbuf);
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index e43282e4e806..8b4b887a7d41 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -223,10 +223,10 @@ static u32 inline td_status(struct uhci_td *td) {
  */
 
 /*
- * The UHCI driver places Interrupt, Control and Bulk into QH's both
- * to group together TD's for one transfer, and also to faciliate queuing
- * of URB's. To make it easy to insert entries into the schedule, we have
- * a skeleton of QH's for each predefined Interrupt latency, low-speed
+ * The UHCI driver places Interrupt, Control and Bulk into QHs both
+ * to group together TDs for one transfer, and also to facilitate queuing
+ * of URBs. To make it easy to insert entries into the schedule, we have
+ * a skeleton of QHs for each predefined Interrupt latency, low-speed
  * control, full-speed control and terminating QH (see explanation for
  * the terminating QH below).
  *
@@ -257,8 +257,8 @@ static u32 inline td_status(struct uhci_td *td) {
  *   reclamation.
  *
  * Isochronous transfers are stored before the start of the skeleton
- * schedule and don't use QH's. While the UHCI spec doesn't forbid the
- * use of QH's for Isochronous, it doesn't use them either. And the spec
+ * schedule and don't use QHs. While the UHCI spec doesn't forbid the
+ * use of QHs for Isochronous, it doesn't use them either. And the spec
  * says that queues never advance on an error completion status, which
  * makes them totally unsuitable for Isochronous transfers.
  */
@@ -359,7 +359,7 @@ struct uhci_hcd {
 	struct dma_pool *td_pool;
 
 	struct uhci_td *term_td;	/* Terminating TD, see UHCI bug */
-	struct uhci_qh *skelqh[UHCI_NUM_SKELQH];	/* Skeleton QH's */
+	struct uhci_qh *skelqh[UHCI_NUM_SKELQH];	/* Skeleton QHs */
 
 	spinlock_t lock;
 
@@ -389,22 +389,22 @@ struct uhci_hcd {
 	unsigned long resuming_ports;
 	unsigned long ports_timeout;		/* Time to stop signalling */
 
-	/* Main list of URB's currently controlled by this HC */
+	/* Main list of URBs currently controlled by this HC */
 	struct list_head urb_list;
 
-	/* List of QH's that are done, but waiting to be unlinked (race) */
+	/* List of QHs that are done, but waiting to be unlinked (race) */
 	struct list_head qh_remove_list;
 	unsigned int qh_remove_age;		/* Age in frames */
 
-	/* List of TD's that are done, but waiting to be freed (race) */
+	/* List of TDs that are done, but waiting to be freed (race) */
 	struct list_head td_remove_list;
 	unsigned int td_remove_age;		/* Age in frames */
 
-	/* List of asynchronously unlinked URB's */
+	/* List of asynchronously unlinked URBs */
 	struct list_head urb_remove_list;
 	unsigned int urb_remove_age;		/* Age in frames */
 
-	/* List of URB's awaiting completion callback */
+	/* List of URBs awaiting completion callback */
 	struct list_head complete_list;
 
 	int rh_numports;			/* Number of root-hub ports */
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index ace9d15f85d2..b6076004a437 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -80,7 +80,7 @@ static inline void uhci_fill_td(struct uhci_td *td, u32 status,
 }
 
 /*
- * We insert Isochronous URB's directly into the frame list at the beginning
+ * We insert Isochronous URBs directly into the frame list at the beginning
  */
 static void uhci_insert_td_frame_list(struct uhci_hcd *uhci, struct uhci_td *td, unsigned framenum)
 {
@@ -369,7 +369,7 @@ static void uhci_append_queued_urb(struct uhci_hcd *uhci, struct urb *eurb, stru
 				uhci_fixup_toggle(urb,
 					uhci_toggle(td_token(lltd)) ^ 1));
 
-	/* All qh's in the queue need to link to the next queue */
+	/* All qhs in the queue need to link to the next queue */
 	urbp-&gt;qh-&gt;link = eurbp-&gt;qh-&gt;link;
 
 	wmb();			/* Make sure we flush everything */
@@ -502,7 +502,7 @@ static void uhci_destroy_urb_priv(struct uhci_hcd *uhci, struct urb *urb)
 	}
 
 	/* Check to see if the remove list is empty. Set the IOC bit */
-	/* to force an interrupt so we can remove the TD's*/
+	/* to force an interrupt so we can remove the TDs*/
 	if (list_empty(&amp;uhci-&gt;td_remove_list))
 		uhci_set_next_interrupt(uhci);
 
@@ -612,7 +612,7 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb, struct ur
 	}
 
 	/*
-	 * Build the DATA TD's
+	 * Build the DATA TDs
 	 */
 	while (len &gt; 0) {
 		int pktsze = len;
@@ -744,7 +744,7 @@ static int uhci_result_control(struct uhci_hcd *uhci, struct urb *urb)
 
 	urb-&gt;actual_length = 0;
 
-	/* The rest of the TD's (but the last) are data */
+	/* The rest of the TDs (but the last) are data */
 	tmp = tmp-&gt;next;
 	while (tmp != head &amp;&amp; tmp-&gt;next != head) {
 		unsigned int ctrlstat;
@@ -848,7 +848,7 @@ static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb, struct urb
 		status |= TD_CTRL_SPD;
 
 	/*
-	 * Build the DATA TD's
+	 * Build the DATA TDs
 	 */
 	do {	/* Allow zero length packets */
 		int pktsze = maxsze;
@@ -1025,7 +1025,7 @@ static int isochronous_find_limits(struct uhci_hcd *uhci, struct urb *urb, unsig
 	list_for_each_entry(up, &amp;uhci-&gt;urb_list, urb_list) {
 		struct urb *u = up-&gt;urb;
 
-		/* look for pending URB's with identical pipe handle */
+		/* look for pending URBs with identical pipe handle */
 		if ((urb-&gt;pipe == u-&gt;pipe) &amp;&amp; (urb-&gt;dev == u-&gt;dev) &amp;&amp;
 		    (u-&gt;status == -EINPROGRESS) &amp;&amp; (u != urb)) {
 			if (!last_urb)
@@ -1355,7 +1355,7 @@ static void uhci_unlink_generic(struct uhci_hcd *uhci, struct urb *urb)
 
 	uhci_delete_queued_urb(uhci, urb);
 
-	/* The interrupt loop will reclaim the QH's */
+	/* The interrupt loop will reclaim the QHs */
 	uhci_remove_qh(uhci, urbp-&gt;qh);
 	urbp-&gt;qh = NULL;
 }
@@ -1413,7 +1413,7 @@ static int uhci_fsbr_timeout(struct uhci_hcd *uhci, struct urb *urb)
 	list_for_each_entry(td, head, list) {
 		/*
 		 * Make sure we don't do the last one (since it'll have the
-		 * TERM bit set) as well as we skip every so many TD's to
+		 * TERM bit set) as well as we skip every so many TDs to
 		 * make sure it doesn't hog the bandwidth
 		 */
 		if (td-&gt;list.next != head &amp;&amp; (count % DEPTH_INTERVAL) ==</pre><hr><pre>commit fa3465689f93331834a831bbe98e3863701e1068
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Nov 30 11:57:51 2005 -0500

    [PATCH] USB: UHCI: change uhci_explen macro
    
    This patch (as616) changed the uhci_explen macro in uhci-hcd.h so that
    it now accepts the desired length, rather than length - 1 with special
    handling for 0.  This also fixes a minor bug that would show up only
    when a driver submits a 0-length bulk URB.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 071fab6b6475..120ca64fe3f7 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -566,7 +566,7 @@ static int uhci_start(struct usb_hcd *hcd)
 	uhci-&gt;skel_bulk_qh-&gt;link = cpu_to_le32(uhci-&gt;skel_term_qh-&gt;dma_handle) | UHCI_PTR_QH;
 
 	/* This dummy TD is to work around a bug in Intel PIIX controllers */
-	uhci_fill_td(uhci-&gt;term_td, 0, (UHCI_NULL_DATA_SIZE &lt;&lt; 21) |
+	uhci_fill_td(uhci-&gt;term_td, 0, uhci_explen(0) |
 		(0x7f &lt;&lt; TD_TOKEN_DEVADDR_SHIFT) | USB_PID_IN, 0);
 	uhci-&gt;term_td-&gt;link = cpu_to_le32(uhci-&gt;term_td-&gt;dma_handle);
 
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index e576db57a926..e43282e4e806 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -71,8 +71,6 @@
 #define   USBLEGSUP_RWC		0x8f00	/* the R/WC bits */
 #define   USBLEGSUP_RO		0x5040	/* R/O and reserved bits */
 
-#define UHCI_NULL_DATA_SIZE	0x7FF	/* for UHCI controller TD */
-
 #define UHCI_PTR_BITS		cpu_to_le32(0x000F)
 #define UHCI_PTR_TERM		cpu_to_le32(0x0001)
 #define UHCI_PTR_QH		cpu_to_le32(0x0002)
@@ -168,9 +166,11 @@ static __le32 inline qh_element(struct uhci_qh *qh) {
 #define TD_TOKEN_EXPLEN_MASK	0x7FF		/* expected length, encoded as n - 1 */
 #define TD_TOKEN_PID_MASK	0xFF
 
-#define uhci_explen(len)	((len) &lt;&lt; TD_TOKEN_EXPLEN_SHIFT)
+#define uhci_explen(len)	((((len) - 1) &amp; TD_TOKEN_EXPLEN_MASK) &lt;&lt; \
+					TD_TOKEN_EXPLEN_SHIFT)
 
-#define uhci_expected_length(token) ((((token) &gt;&gt; 21) + 1) &amp; TD_TOKEN_EXPLEN_MASK)
+#define uhci_expected_length(token) ((((token) &gt;&gt; TD_TOKEN_EXPLEN_SHIFT) + \
+					1) &amp; TD_TOKEN_EXPLEN_MASK)
 #define uhci_toggle(token)	(((token) &gt;&gt; TD_TOKEN_TOGGLE_SHIFT) &amp; 1)
 #define uhci_endpoint(token)	(((token) &gt;&gt; 15) &amp; 0xf)
 #define uhci_devaddr(token)	(((token) &gt;&gt; TD_TOKEN_DEVADDR_SHIFT) &amp; 0x7f)
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 7e46887d9e12..ace9d15f85d2 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -596,7 +596,7 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb, struct ur
 		return -ENOMEM;
 
 	uhci_add_td_to_urb(urb, td);
-	uhci_fill_td(td, status, destination | uhci_explen(7),
+	uhci_fill_td(td, status, destination | uhci_explen(8),
 		urb-&gt;setup_dma);
 
 	/*
@@ -628,7 +628,7 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb, struct ur
 		destination ^= TD_TOKEN_TOGGLE;
 	
 		uhci_add_td_to_urb(urb, td);
-		uhci_fill_td(td, status, destination | uhci_explen(pktsze - 1),
+		uhci_fill_td(td, status, destination | uhci_explen(pktsze),
 			data);
 
 		data += pktsze;
@@ -658,7 +658,7 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb, struct ur
 
 	uhci_add_td_to_urb(urb, td);
 	uhci_fill_td(td, status | TD_CTRL_IOC,
-		destination | uhci_explen(UHCI_NULL_DATA_SIZE), 0);
+		destination | uhci_explen(0), 0);
 
 	qh = uhci_alloc_qh(uhci);
 	if (!qh)
@@ -864,7 +864,7 @@ static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb, struct urb
 			return -ENOMEM;
 
 		uhci_add_td_to_urb(urb, td);
-		uhci_fill_td(td, status, destination | uhci_explen(pktsze - 1) |
+		uhci_fill_td(td, status, destination | uhci_explen(pktsze) |
 			(usb_gettoggle(urb-&gt;dev, usb_pipeendpoint(urb-&gt;pipe),
 			 usb_pipeout(urb-&gt;pipe)) &lt;&lt; TD_TOKEN_TOGGLE_SHIFT),
 			data);
@@ -890,7 +890,7 @@ static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb, struct urb
 			return -ENOMEM;
 
 		uhci_add_td_to_urb(urb, td);
-		uhci_fill_td(td, status, destination | uhci_explen(UHCI_NULL_DATA_SIZE) |
+		uhci_fill_td(td, status, destination | uhci_explen(0) |
 			(usb_gettoggle(urb-&gt;dev, usb_pipeendpoint(urb-&gt;pipe),
 			 usb_pipeout(urb-&gt;pipe)) &lt;&lt; TD_TOKEN_TOGGLE_SHIFT),
 			data);
@@ -1092,7 +1092,7 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb)
 			return -ENOMEM;
 
 		uhci_add_td_to_urb(urb, td);
-		uhci_fill_td(td, status, destination | uhci_explen(urb-&gt;iso_frame_desc[i].length - 1),
+		uhci_fill_td(td, status, destination | uhci_explen(urb-&gt;iso_frame_desc[i].length),
 			urb-&gt;transfer_dma + urb-&gt;iso_frame_desc[i].offset);
 
 		if (i + 1 &gt;= urb-&gt;number_of_packets)</pre><hr><pre>commit 2425e9fe67cb5e66c173c4f604ddd8a5970d89e9
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Nov 29 12:13:31 2005 -0500

    [PATCH] USB: Don't assume root-hub resume succeeds
    
    This patch (as614) makes a small change to the part of the hub driver
    responsible for remote wakeup of root hubs.  When these wakeups occur
    the driver is suspended, and in case the resume fails the driver should
    remain suspended -- it shouldn't try to proceed with its normal
    processing.
    
    This will hardly ever matter in normal use, but it did crop up while I
    was debugging a different problem.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index a523c8f20b5d..650d5ee5871b 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2697,6 +2697,8 @@ static void hub_events(void)
 		if (i) {
 			dpm_runtime_resume(&amp;hdev-&gt;dev);
 			dpm_runtime_resume(&amp;intf-&gt;dev);
+			usb_put_intf(intf);
+			continue;
 		}
 
 		/* Lock the device, then check to see if we were</pre><hr><pre>commit 3cf0a22e8b1b3f44288db773d315e72e89d51c4c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Nov 29 12:08:15 2005 -0500

    [PATCH] USB Gadget: dummy_hcd: updates to hcd-&gt;state
    
    This patch (as613) moves the updates to hcd-&gt;state in the dummy_hcd
    driver to where they now belong.  It also uses the new
    HC_FLAG_HW_ACCESSIBLE flag in a way that simulates a real PCI
    controller, and it adds checks for attempts to resume the bus while the
    controller is suspended or to suspend the controller while the bus is
    active.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index 4932b07b316d..ce0d4b412dfe 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -1576,7 +1576,7 @@ static int dummy_hub_status (struct usb_hcd *hcd, char *buf)
 	dum = hcd_to_dummy (hcd);
 
 	spin_lock_irqsave (&amp;dum-&gt;lock, flags);
-	if (hcd-&gt;state != HC_STATE_RUNNING)
+	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags))
 		goto done;
 
 	if (dum-&gt;resuming &amp;&amp; time_after_eq (jiffies, dum-&gt;re_timeout)) {
@@ -1623,7 +1623,7 @@ static int dummy_hub_control (
 	int		retval = 0;
 	unsigned long	flags;
 
-	if (hcd-&gt;state != HC_STATE_RUNNING)
+	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags))
 		return -ETIMEDOUT;
 
 	dum = hcd_to_dummy (hcd);
@@ -1756,9 +1756,12 @@ static int dummy_bus_suspend (struct usb_hcd *hcd)
 {
 	struct dummy *dum = hcd_to_dummy (hcd);
 
+	dev_dbg (&amp;hcd-&gt;self.root_hub-&gt;dev, "%s\n", __FUNCTION__);
+
 	spin_lock_irq (&amp;dum-&gt;lock);
 	dum-&gt;rh_state = DUMMY_RH_SUSPENDED;
 	set_link_state (dum);
+	hcd-&gt;state = HC_STATE_SUSPENDED;
 	spin_unlock_irq (&amp;dum-&gt;lock);
 	return 0;
 }
@@ -1766,14 +1769,23 @@ static int dummy_bus_suspend (struct usb_hcd *hcd)
 static int dummy_bus_resume (struct usb_hcd *hcd)
 {
 	struct dummy *dum = hcd_to_dummy (hcd);
+	int rc = 0;
+
+	dev_dbg (&amp;hcd-&gt;self.root_hub-&gt;dev, "%s\n", __FUNCTION__);
 
 	spin_lock_irq (&amp;dum-&gt;lock);
-	dum-&gt;rh_state = DUMMY_RH_RUNNING;
-	set_link_state (dum);
-	if (!list_empty(&amp;dum-&gt;urbp_list))
-		mod_timer (&amp;dum-&gt;timer, jiffies);
+	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags)) {
+		dev_warn (&amp;hcd-&gt;self.root_hub-&gt;dev, "HC isn't running!\n");
+		rc = -ENODEV;
+	} else {
+		dum-&gt;rh_state = DUMMY_RH_RUNNING;
+		set_link_state (dum);
+		if (!list_empty(&amp;dum-&gt;urbp_list))
+			mod_timer (&amp;dum-&gt;timer, jiffies);
+		hcd-&gt;state = HC_STATE_RUNNING;
+	}
 	spin_unlock_irq (&amp;dum-&gt;lock);
-	return 0;
+	return rc;
 }
 
 /*-------------------------------------------------------------------------*/
@@ -1933,12 +1945,19 @@ static int dummy_hcd_remove (struct platform_device *pdev)
 static int dummy_hcd_suspend (struct platform_device *pdev, pm_message_t state)
 {
 	struct usb_hcd		*hcd;
+	struct dummy		*dum;
+	int			rc = 0;
 
 	dev_dbg (&amp;pdev-&gt;dev, "%s\n", __FUNCTION__);
-	hcd = platform_get_drvdata (pdev);
 
-	hcd-&gt;state = HC_STATE_SUSPENDED;
-	return 0;
+	hcd = platform_get_drvdata (pdev);
+	dum = hcd_to_dummy (hcd);
+	if (dum-&gt;rh_state == DUMMY_RH_RUNNING) {
+		dev_warn(&amp;pdev-&gt;dev, "Root hub isn't suspended!\n");
+		rc = -EBUSY;
+	} else
+		clear_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
+	return rc;
 }
 
 static int dummy_hcd_resume (struct platform_device *pdev)
@@ -1946,9 +1965,9 @@ static int dummy_hcd_resume (struct platform_device *pdev)
 	struct usb_hcd		*hcd;
 
 	dev_dbg (&amp;pdev-&gt;dev, "%s\n", __FUNCTION__);
-	hcd = platform_get_drvdata (pdev);
-	hcd-&gt;state = HC_STATE_RUNNING;
 
+	hcd = platform_get_drvdata (pdev);
+	set_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
 	usb_hcd_poll_rh_status (hcd);
 	return 0;
 }</pre><hr><pre>commit a21d4fed4b00eaf7e7c3b2e2b25de24f540bfa66
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Nov 29 12:04:24 2005 -0500

    [PATCH] USB Gadget: file_storage: remove "volatile" declarations
    
    This patch (as612) removes the "volatile" declarations from the
    file-storage gadget.  It turns out that they aren't needed for anything
    much; adding a few memory barriers does a sufficient job.
    
    The patch also removes a wait_queue.  Not much point having a queue when
    only one task is ever going to be on it!
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/file_storage.c b/drivers/usb/gadget/file_storage.c
index f6c49b717d3f..0cea9782d7d4 100644
--- a/drivers/usb/gadget/file_storage.c
+++ b/drivers/usb/gadget/file_storage.c
@@ -239,7 +239,6 @@
 #include &lt;linux/string.h&gt;
 #include &lt;linux/suspend.h&gt;
 #include &lt;linux/utsname.h&gt;
-#include &lt;linux/wait.h&gt;
 
 #include &lt;linux/usb_ch9.h&gt;
 #include &lt;linux/usb_gadget.h&gt;
@@ -251,7 +250,7 @@
 
 #define DRIVER_DESC		"File-backed Storage Gadget"
 #define DRIVER_NAME		"g_file_storage"
-#define DRIVER_VERSION		"20 October 2004"
+#define DRIVER_VERSION		"28 November 2005"
 
 static const char longname[] = DRIVER_DESC;
 static const char shortname[] = DRIVER_NAME;
@@ -588,7 +587,7 @@ enum fsg_buffer_state {
 struct fsg_buffhd {
 	void				*buf;
 	dma_addr_t			dma;
-	volatile enum fsg_buffer_state	state;
+	enum fsg_buffer_state		state;
 	struct fsg_buffhd		*next;
 
 	/* The NetChip 2280 is faster, and handles some protocol faults
@@ -597,9 +596,9 @@ struct fsg_buffhd {
 	unsigned int			bulk_out_intended_length;
 
 	struct usb_request		*inreq;
-	volatile int			inreq_busy;
+	int				inreq_busy;
 	struct usb_request		*outreq;
-	volatile int			outreq_busy;
+	int				outreq_busy;
 };
 
 enum fsg_state {
@@ -637,11 +636,11 @@ struct fsg_dev {
 
 	struct usb_ep		*ep0;		// Handy copy of gadget-&gt;ep0
 	struct usb_request	*ep0req;	// For control responses
-	volatile unsigned int	ep0_req_tag;
+	unsigned int		ep0_req_tag;
 	const char		*ep0req_name;
 
 	struct usb_request	*intreq;	// For interrupt responses
-	volatile int		intreq_busy;
+	int			intreq_busy;
 	struct fsg_buffhd	*intr_buffhd;
 
  	unsigned int		bulk_out_maxpacket;
@@ -671,7 +670,6 @@ struct fsg_dev {
 	struct fsg_buffhd	*next_buffhd_to_drain;
 	struct fsg_buffhd	buffhds[NUM_BUFFERS];
 
-	wait_queue_head_t	thread_wqh;
 	int			thread_wakeup_needed;
 	struct completion	thread_notifier;
 	struct task_struct	*thread_task;
@@ -1076,11 +1074,13 @@ static int populate_config_buf(struct usb_gadget *gadget,
 
 /* These routines may be called in process context or in_irq */
 
+/* Caller must hold fsg-&gt;lock */
 static void wakeup_thread(struct fsg_dev *fsg)
 {
 	/* Tell the main thread that something has happened */
 	fsg-&gt;thread_wakeup_needed = 1;
-	wake_up_all(&amp;fsg-&gt;thread_wqh);
+	if (fsg-&gt;thread_task)
+		wake_up_process(fsg-&gt;thread_task);
 }
 
 
@@ -1167,11 +1167,12 @@ static void bulk_in_complete(struct usb_ep *ep, struct usb_request *req)
 		usb_ep_fifo_flush(ep);
 
 	/* Hold the lock while we update the request and buffer states */
+	smp_wmb();
 	spin_lock(&amp;fsg-&gt;lock);
 	bh-&gt;inreq_busy = 0;
 	bh-&gt;state = BUF_STATE_EMPTY;
-	spin_unlock(&amp;fsg-&gt;lock);
 	wakeup_thread(fsg);
+	spin_unlock(&amp;fsg-&gt;lock);
 }
 
 static void bulk_out_complete(struct usb_ep *ep, struct usb_request *req)
@@ -1188,11 +1189,12 @@ static void bulk_out_complete(struct usb_ep *ep, struct usb_request *req)
 		usb_ep_fifo_flush(ep);
 
 	/* Hold the lock while we update the request and buffer states */
+	smp_wmb();
 	spin_lock(&amp;fsg-&gt;lock);
 	bh-&gt;outreq_busy = 0;
 	bh-&gt;state = BUF_STATE_FULL;
-	spin_unlock(&amp;fsg-&gt;lock);
 	wakeup_thread(fsg);
+	spin_unlock(&amp;fsg-&gt;lock);
 }
 
 
@@ -1209,11 +1211,12 @@ static void intr_in_complete(struct usb_ep *ep, struct usb_request *req)
 		usb_ep_fifo_flush(ep);
 
 	/* Hold the lock while we update the request and buffer states */
+	smp_wmb();
 	spin_lock(&amp;fsg-&gt;lock);
 	fsg-&gt;intreq_busy = 0;
 	bh-&gt;state = BUF_STATE_EMPTY;
-	spin_unlock(&amp;fsg-&gt;lock);
 	wakeup_thread(fsg);
+	spin_unlock(&amp;fsg-&gt;lock);
 }
 
 #else
@@ -1264,8 +1267,8 @@ static void received_cbi_adsc(struct fsg_dev *fsg, struct fsg_buffhd *bh)
 	fsg-&gt;cbbuf_cmnd_size = req-&gt;actual;
 	memcpy(fsg-&gt;cbbuf_cmnd, req-&gt;buf, fsg-&gt;cbbuf_cmnd_size);
 
-	spin_unlock(&amp;fsg-&gt;lock);
 	wakeup_thread(fsg);
+	spin_unlock(&amp;fsg-&gt;lock);
 }
 
 #else
@@ -1517,8 +1520,8 @@ static int fsg_setup(struct usb_gadget *gadget,
 
 /* Use this for bulk or interrupt transfers, not ep0 */
 static void start_transfer(struct fsg_dev *fsg, struct usb_ep *ep,
-		struct usb_request *req, volatile int *pbusy,
-		volatile enum fsg_buffer_state *state)
+		struct usb_request *req, int *pbusy,
+		enum fsg_buffer_state *state)
 {
 	int	rc;
 
@@ -1526,8 +1529,11 @@ static void start_transfer(struct fsg_dev *fsg, struct usb_ep *ep,
 		dump_msg(fsg, "bulk-in", req-&gt;buf, req-&gt;length);
 	else if (ep == fsg-&gt;intr_in)
 		dump_msg(fsg, "intr-in", req-&gt;buf, req-&gt;length);
+
+	spin_lock_irq(&amp;fsg-&gt;lock);
 	*pbusy = 1;
 	*state = BUF_STATE_BUSY;
+	spin_unlock_irq(&amp;fsg-&gt;lock);
 	rc = usb_ep_queue(ep, req, GFP_KERNEL);
 	if (rc != 0) {
 		*pbusy = 0;
@@ -1547,14 +1553,23 @@ static void start_transfer(struct fsg_dev *fsg, struct usb_ep *ep,
 
 static int sleep_thread(struct fsg_dev *fsg)
 {
-	int	rc;
+	int	rc = 0;
 
 	/* Wait until a signal arrives or we are woken up */
-	rc = wait_event_interruptible(fsg-&gt;thread_wqh,
-			fsg-&gt;thread_wakeup_needed);
+	for (;;) {
+		try_to_freeze();
+		set_current_state(TASK_INTERRUPTIBLE);
+		if (signal_pending(current)) {
+			rc = -EINTR;
+			break;
+		}
+		if (fsg-&gt;thread_wakeup_needed)
+			break;
+		schedule();
+	}
+	__set_current_state(TASK_RUNNING);
 	fsg-&gt;thread_wakeup_needed = 0;
-	try_to_freeze();
-	return (rc ? -EINTR : 0);
+	return rc;
 }
 
 
@@ -1791,6 +1806,7 @@ static int do_write(struct fsg_dev *fsg)
 		if (bh-&gt;state == BUF_STATE_EMPTY &amp;&amp; !get_some_more)
 			break;			// We stopped early
 		if (bh-&gt;state == BUF_STATE_FULL) {
+			smp_rmb();
 			fsg-&gt;next_buffhd_to_drain = bh-&gt;next;
 			bh-&gt;state = BUF_STATE_EMPTY;
 
@@ -2359,6 +2375,7 @@ static int throw_away_data(struct fsg_dev *fsg)
 
 		/* Throw away the data in a filled buffer */
 		if (bh-&gt;state == BUF_STATE_FULL) {
+			smp_rmb();
 			bh-&gt;state = BUF_STATE_EMPTY;
 			fsg-&gt;next_buffhd_to_drain = bh-&gt;next;
 
@@ -3024,6 +3041,7 @@ static int get_next_command(struct fsg_dev *fsg)
 			if ((rc = sleep_thread(fsg)) != 0)
 				return rc;
 			}
+		smp_rmb();
 		rc = received_cbw(fsg, bh);
 		bh-&gt;state = BUF_STATE_EMPTY;
 
@@ -4072,7 +4090,6 @@ static int __init fsg_alloc(void)
 	spin_lock_init(&amp;fsg-&gt;lock);
 	init_rwsem(&amp;fsg-&gt;filesem);
 	kref_init(&amp;fsg-&gt;ref);
-	init_waitqueue_head(&amp;fsg-&gt;thread_wqh);
 	init_completion(&amp;fsg-&gt;thread_notifier);
 
 	the_fsg = fsg;</pre>
    <div class="pagination">
        <a href='2_129.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><span>[130]</span><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_131.html'>Next&gt;&gt;</a>
    <div>
</body>
