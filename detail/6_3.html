<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Zhejiang University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Zhejiang University</h1>
    <div class="pagination">
        <a href='6_2.html'>&lt;&lt;Prev</a><a href='6.html'>1</a><a href='6_2.html'>2</a><span>[3]</span><a href='6_4.html'>4</a><a href='6_5.html'>5</a><a href='6_6.html'>6</a><a href='6_7.html'>7</a><a href='6_8.html'>8</a><a href='6_9.html'>9</a><a href='6_10.html'>10</a><a href='6_11.html'>11</a><a href='6_12.html'>12</a><a href='6_13.html'>13</a><a href='6_14.html'>14</a><a href='6_15.html'>15</a><a href='6_16.html'>16</a><a href='6_17.html'>17</a><a href='6_18.html'>18</a><a href='6_19.html'>19</a><a href='6_20.html'>20</a><a href='6_21.html'>21</a><a href='6_22.html'>22</a><a href='6_23.html'>23</a><a href='6_24.html'>24</a><a href='6_25.html'>25</a><a href='6_26.html'>26</a><a href='6_27.html'>27</a><a href='6_28.html'>28</a><a href='6_29.html'>29</a><a href='6_30.html'>30</a><a href='6_31.html'>31</a><a href='6_32.html'>32</a><a href='6_33.html'>33</a><a href='6_34.html'>34</a><a href='6_4.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit ebeae8adf89d9a82359f6659b1663d09beec2faa
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Sun Jan 21 15:35:06 2024 +0800

    ksmbd: fix global oob in ksmbd_nl_policy
    
    Similar to a reported issue (check the commit b33fb5b801c6 ("net:
    qualcomm: rmnet: fix global oob in rmnet_policy"), my local fuzzer finds
    another global out-of-bounds read for policy ksmbd_nl_policy. See bug
    trace below:
    
    ==================================================================
    BUG: KASAN: global-out-of-bounds in validate_nla lib/nlattr.c:386 [inline]
    BUG: KASAN: global-out-of-bounds in __nla_validate_parse+0x24af/0x2750 lib/nlattr.c:600
    Read of size 1 at addr ffffffff8f24b100 by task syz-executor.1/62810
    
    CPU: 0 PID: 62810 Comm: syz-executor.1 Tainted: G                 N 6.1.0 #3
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014
    Call Trace:
     &lt;TASK&gt;
     __dump_stack lib/dump_stack.c:88 [inline]
     dump_stack_lvl+0x8b/0xb3 lib/dump_stack.c:106
     print_address_description mm/kasan/report.c:284 [inline]
     print_report+0x172/0x475 mm/kasan/report.c:395
     kasan_report+0xbb/0x1c0 mm/kasan/report.c:495
     validate_nla lib/nlattr.c:386 [inline]
     __nla_validate_parse+0x24af/0x2750 lib/nlattr.c:600
     __nla_parse+0x3e/0x50 lib/nlattr.c:697
     __nlmsg_parse include/net/netlink.h:748 [inline]
     genl_family_rcv_msg_attrs_parse.constprop.0+0x1b0/0x290 net/netlink/genetlink.c:565
     genl_family_rcv_msg_doit+0xda/0x330 net/netlink/genetlink.c:734
     genl_family_rcv_msg net/netlink/genetlink.c:833 [inline]
     genl_rcv_msg+0x441/0x780 net/netlink/genetlink.c:850
     netlink_rcv_skb+0x14f/0x410 net/netlink/af_netlink.c:2540
     genl_rcv+0x24/0x40 net/netlink/genetlink.c:861
     netlink_unicast_kernel net/netlink/af_netlink.c:1319 [inline]
     netlink_unicast+0x54e/0x800 net/netlink/af_netlink.c:1345
     netlink_sendmsg+0x930/0xe50 net/netlink/af_netlink.c:1921
     sock_sendmsg_nosec net/socket.c:714 [inline]
     sock_sendmsg+0x154/0x190 net/socket.c:734
     ____sys_sendmsg+0x6df/0x840 net/socket.c:2482
     ___sys_sendmsg+0x110/0x1b0 net/socket.c:2536
     __sys_sendmsg+0xf3/0x1c0 net/socket.c:2565
     do_syscall_x64 arch/x86/entry/common.c:50 [inline]
     do_syscall_64+0x3b/0x90 arch/x86/entry/common.c:80
     entry_SYSCALL_64_after_hwframe+0x63/0xcd
    RIP: 0033:0x7fdd66a8f359
    Code: 28 00 00 00 75 05 48 83 c4 28 c3 e8 f1 19 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 &lt;48&gt; 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b8 ff ff ff f7 d8 64 89 01 48
    RSP: 002b:00007fdd65e00168 EFLAGS: 00000246 ORIG_RAX: 000000000000002e
    RAX: ffffffffffffffda RBX: 00007fdd66bbcf80 RCX: 00007fdd66a8f359
    RDX: 0000000000000000 RSI: 0000000020000500 RDI: 0000000000000003
    RBP: 00007fdd66ada493 R08: 0000000000000000 R09: 0000000000000000
    R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000
    R13: 00007ffc84b81aff R14: 00007fdd65e00300 R15: 0000000000022000
     &lt;/TASK&gt;
    
    The buggy address belongs to the variable:
     ksmbd_nl_policy+0x100/0xa80
    
    The buggy address belongs to the physical page:
    page:0000000034f47940 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x1ccc4b
    flags: 0x200000000001000(reserved|node=0|zone=2)
    raw: 0200000000001000 ffffea00073312c8 ffffea00073312c8 0000000000000000
    raw: 0000000000000000 0000000000000000 00000001ffffffff 0000000000000000
    page dumped because: kasan: bad access detected
    
    Memory state around the buggy address:
     ffffffff8f24b000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
     ffffffff8f24b080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    &gt;ffffffff8f24b100: f9 f9 f9 f9 00 00 f9 f9 f9 f9 f9 f9 00 00 07 f9
                       ^
     ffffffff8f24b180: f9 f9 f9 f9 00 05 f9 f9 f9 f9 f9 f9 00 00 00 05
     ffffffff8f24b200: f9 f9 f9 f9 00 00 03 f9 f9 f9 f9 f9 00 00 04 f9
    ==================================================================
    
    To fix it, add a placeholder named __KSMBD_EVENT_MAX and let
    KSMBD_EVENT_MAX to be its original value - 1 according to what other
    netlink families do. Also change two sites that refer the
    KSMBD_EVENT_MAX to correct value.
    
    Cc: stable@vger.kernel.org
    Fixes: 0626e6641f6b ("cifsd: add server handler for central processing and tranport layers")
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Acked-by: Namjae Jeon &lt;linkinjeon@kernel.org&gt;
    Signed-off-by: Steve French &lt;stfrench@microsoft.com&gt;

diff --git a/fs/smb/server/ksmbd_netlink.h b/fs/smb/server/ksmbd_netlink.h
index b7521e41402e..0ebf91ffa236 100644
--- a/fs/smb/server/ksmbd_netlink.h
+++ b/fs/smb/server/ksmbd_netlink.h
@@ -304,7 +304,8 @@ enum ksmbd_event {
 	KSMBD_EVENT_SPNEGO_AUTHEN_REQUEST,
 	KSMBD_EVENT_SPNEGO_AUTHEN_RESPONSE	= 15,
 
-	KSMBD_EVENT_MAX
+	__KSMBD_EVENT_MAX,
+	KSMBD_EVENT_MAX = __KSMBD_EVENT_MAX - 1
 };
 
 /*
diff --git a/fs/smb/server/transport_ipc.c b/fs/smb/server/transport_ipc.c
index b49d47bdafc9..f29bb03f0dc4 100644
--- a/fs/smb/server/transport_ipc.c
+++ b/fs/smb/server/transport_ipc.c
@@ -74,7 +74,7 @@ static int handle_unsupported_event(struct sk_buff *skb, struct genl_info *info)
 static int handle_generic_event(struct sk_buff *skb, struct genl_info *info);
 static int ksmbd_ipc_heartbeat_request(void);
 
-static const struct nla_policy ksmbd_nl_policy[KSMBD_EVENT_MAX] = {
+static const struct nla_policy ksmbd_nl_policy[KSMBD_EVENT_MAX + 1] = {
 	[KSMBD_EVENT_UNSPEC] = {
 		.len = 0,
 	},
@@ -403,7 +403,7 @@ static int handle_generic_event(struct sk_buff *skb, struct genl_info *info)
 		return -EPERM;
 #endif
 
-	if (type &gt;= KSMBD_EVENT_MAX) {
+	if (type &gt; KSMBD_EVENT_MAX) {
 		WARN_ON(1);
 		return -EINVAL;
 	}</pre><hr><pre>commit f6cc4b6a3ae53df425771000e9c9540cce9b7bb1
Author: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
Date:   Tue Jan 23 01:24:42 2024 +0800

    fjes: fix memleaks in fjes_hw_setup
    
    In fjes_hw_setup, it allocates several memory and delay the deallocation
    to the fjes_hw_exit in fjes_probe through the following call chain:
    
    fjes_probe
      |-&gt; fjes_hw_init
            |-&gt; fjes_hw_setup
      |-&gt; fjes_hw_exit
    
    However, when fjes_hw_setup fails, fjes_hw_exit won't be called and thus
    all the resources allocated in fjes_hw_setup will be leaked. In this
    patch, we free those resources in fjes_hw_setup and prevents such leaks.
    
    Fixes: 2fcbca687702 ("fjes: platform_driver's .probe and .remove routine")
    Signed-off-by: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
    Reviewed-by: Simon Horman &lt;horms@kernel.org&gt;
    Link: https://lore.kernel.org/r/20240122172445.3841883-1-alexious@zju.edu.cn
    Signed-off-by: Jakub Kicinski &lt;kuba@kernel.org&gt;

diff --git a/drivers/net/fjes/fjes_hw.c b/drivers/net/fjes/fjes_hw.c
index 704e949484d0..b9b5554ea862 100644
--- a/drivers/net/fjes/fjes_hw.c
+++ b/drivers/net/fjes/fjes_hw.c
@@ -221,21 +221,25 @@ static int fjes_hw_setup(struct fjes_hw *hw)
 
 	mem_size = FJES_DEV_REQ_BUF_SIZE(hw-&gt;max_epid);
 	hw-&gt;hw_info.req_buf = kzalloc(mem_size, GFP_KERNEL);
-	if (!(hw-&gt;hw_info.req_buf))
-		return -ENOMEM;
+	if (!(hw-&gt;hw_info.req_buf)) {
+		result = -ENOMEM;
+		goto free_ep_info;
+	}
 
 	hw-&gt;hw_info.req_buf_size = mem_size;
 
 	mem_size = FJES_DEV_RES_BUF_SIZE(hw-&gt;max_epid);
 	hw-&gt;hw_info.res_buf = kzalloc(mem_size, GFP_KERNEL);
-	if (!(hw-&gt;hw_info.res_buf))
-		return -ENOMEM;
+	if (!(hw-&gt;hw_info.res_buf)) {
+		result = -ENOMEM;
+		goto free_req_buf;
+	}
 
 	hw-&gt;hw_info.res_buf_size = mem_size;
 
 	result = fjes_hw_alloc_shared_status_region(hw);
 	if (result)
-		return result;
+		goto free_res_buf;
 
 	hw-&gt;hw_info.buffer_share_bit = 0;
 	hw-&gt;hw_info.buffer_unshare_reserve_bit = 0;
@@ -246,11 +250,11 @@ static int fjes_hw_setup(struct fjes_hw *hw)
 
 			result = fjes_hw_alloc_epbuf(&amp;buf_pair-&gt;tx);
 			if (result)
-				return result;
+				goto free_epbuf;
 
 			result = fjes_hw_alloc_epbuf(&amp;buf_pair-&gt;rx);
 			if (result)
-				return result;
+				goto free_epbuf;
 
 			spin_lock_irqsave(&amp;hw-&gt;rx_status_lock, flags);
 			fjes_hw_setup_epbuf(&amp;buf_pair-&gt;tx, mac,
@@ -273,6 +277,25 @@ static int fjes_hw_setup(struct fjes_hw *hw)
 	fjes_hw_init_command_registers(hw, &amp;param);
 
 	return 0;
+
+free_epbuf:
+	for (epidx = 0; epidx &lt; hw-&gt;max_epid ; epidx++) {
+		if (epidx == hw-&gt;my_epid)
+			continue;
+		fjes_hw_free_epbuf(&amp;hw-&gt;ep_shm_info[epidx].tx);
+		fjes_hw_free_epbuf(&amp;hw-&gt;ep_shm_info[epidx].rx);
+	}
+	fjes_hw_free_shared_status_region(hw);
+free_res_buf:
+	kfree(hw-&gt;hw_info.res_buf);
+	hw-&gt;hw_info.res_buf = NULL;
+free_req_buf:
+	kfree(hw-&gt;hw_info.req_buf);
+	hw-&gt;hw_info.req_buf = NULL;
+free_ep_info:
+	kfree(hw-&gt;ep_shm_info);
+	hw-&gt;ep_shm_info = NULL;
+	return result;
 }
 
 static void fjes_hw_cleanup(struct fjes_hw *hw)</pre><hr><pre>commit aef855df7e1bbd5aa4484851561211500b22707e
Author: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
Date:   Tue Nov 28 17:29:01 2023 +0800

    net/mlx5e: fix a potential double-free in fs_any_create_groups
    
    When kcalloc() for ft-&gt;g succeeds but kvzalloc() for in fails,
    fs_any_create_groups() will free ft-&gt;g. However, its caller
    fs_any_create_table() will free ft-&gt;g again through calling
    mlx5e_destroy_flow_table(), which will lead to a double-free.
    Fix this by setting ft-&gt;g to NULL in fs_any_create_groups().
    
    Fixes: 0f575c20bf06 ("net/mlx5e: Introduce Flow Steering ANY API")
    Signed-off-by: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
    Reviewed-by: Tariq Toukan &lt;tariqt@nvidia.com&gt;
    Reviewed-by: Simon Horman &lt;horms@kernel.org&gt;
    Signed-off-by: Saeed Mahameed &lt;saeedm@nvidia.com&gt;

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/fs_tt_redirect.c b/drivers/net/ethernet/mellanox/mlx5/core/en/fs_tt_redirect.c
index e1283531e0b8..671adbad0a40 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/fs_tt_redirect.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/fs_tt_redirect.c
@@ -436,6 +436,7 @@ static int fs_any_create_groups(struct mlx5e_flow_table *ft)
 	in = kvzalloc(inlen, GFP_KERNEL);
 	if  (!in || !ft-&gt;g) {
 		kfree(ft-&gt;g);
+		ft-&gt;g = NULL;
 		kvfree(in);
 		return -ENOMEM;
 	}</pre><hr><pre>commit 3c6d5189246f590e4e1f167991558bdb72a4738b
Author: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
Date:   Wed Jan 17 15:17:36 2024 +0800

    net/mlx5e: fix a double-free in arfs_create_groups
    
    When `in` allocated by kvzalloc fails, arfs_create_groups will free
    ft-&gt;g and return an error. However, arfs_create_table, the only caller of
    arfs_create_groups, will hold this error and call to
    mlx5e_destroy_flow_table, in which the ft-&gt;g will be freed again.
    
    Fixes: 1cabe6b0965e ("net/mlx5e: Create aRFS flow tables")
    Signed-off-by: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
    Reviewed-by: Simon Horman &lt;horms@kernel.org&gt;
    Signed-off-by: Saeed Mahameed &lt;saeedm@nvidia.com&gt;

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_arfs.c b/drivers/net/ethernet/mellanox/mlx5/core/en_arfs.c
index bb7f86c993e5..e66f486faafe 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_arfs.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_arfs.c
@@ -254,11 +254,13 @@ static int arfs_create_groups(struct mlx5e_flow_table *ft,
 
 	ft-&gt;g = kcalloc(MLX5E_ARFS_NUM_GROUPS,
 			sizeof(*ft-&gt;g), GFP_KERNEL);
-	in = kvzalloc(inlen, GFP_KERNEL);
-	if  (!in || !ft-&gt;g) {
-		kfree(ft-&gt;g);
-		kvfree(in);
+	if (!ft-&gt;g)
 		return -ENOMEM;
+
+	in = kvzalloc(inlen, GFP_KERNEL);
+	if (!in) {
+		err = -ENOMEM;
+		goto err_free_g;
 	}
 
 	mc = MLX5_ADDR_OF(create_flow_group_in, in, match_criteria);
@@ -278,7 +280,7 @@ static int arfs_create_groups(struct mlx5e_flow_table *ft,
 		break;
 	default:
 		err = -EINVAL;
-		goto out;
+		goto err_free_in;
 	}
 
 	switch (type) {
@@ -300,7 +302,7 @@ static int arfs_create_groups(struct mlx5e_flow_table *ft,
 		break;
 	default:
 		err = -EINVAL;
-		goto out;
+		goto err_free_in;
 	}
 
 	MLX5_SET_CFG(in, match_criteria_enable, MLX5_MATCH_OUTER_HEADERS);
@@ -309,7 +311,7 @@ static int arfs_create_groups(struct mlx5e_flow_table *ft,
 	MLX5_SET_CFG(in, end_flow_index, ix - 1);
 	ft-&gt;g[ft-&gt;num_groups] = mlx5_create_flow_group(ft-&gt;t, in);
 	if (IS_ERR(ft-&gt;g[ft-&gt;num_groups]))
-		goto err;
+		goto err_clean_group;
 	ft-&gt;num_groups++;
 
 	memset(in, 0, inlen);
@@ -318,18 +320,20 @@ static int arfs_create_groups(struct mlx5e_flow_table *ft,
 	MLX5_SET_CFG(in, end_flow_index, ix - 1);
 	ft-&gt;g[ft-&gt;num_groups] = mlx5_create_flow_group(ft-&gt;t, in);
 	if (IS_ERR(ft-&gt;g[ft-&gt;num_groups]))
-		goto err;
+		goto err_clean_group;
 	ft-&gt;num_groups++;
 
 	kvfree(in);
 	return 0;
 
-err:
+err_clean_group:
 	err = PTR_ERR(ft-&gt;g[ft-&gt;num_groups]);
 	ft-&gt;g[ft-&gt;num_groups] = NULL;
-out:
+err_free_in:
 	kvfree(in);
-
+err_free_g:
+	kfree(ft-&gt;g);
+	ft-&gt;g = NULL;
 	return err;
 }
 </pre><hr><pre>commit 95a0d596bbd0552a78e13ced43f2be1038883c81
Author: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
Date:   Fri Dec 8 15:31:19 2023 +0800

    iio: core: fix memleak in iio_device_register_sysfs
    
    When iio_device_register_sysfs_group() fails, we should
    free iio_dev_opaque-&gt;chan_attr_group.attrs to prevent
    potential memleak.
    
    Fixes: 32f171724e5c ("iio: core: rework iio device group creation")
    Signed-off-by: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
    Link: https://lore.kernel.org/r/20231208073119.29283-1-dinghao.liu@zju.edu.cn
    Cc: &lt;Stable@vger.kernel.org&gt;
    Signed-off-by: Jonathan Cameron &lt;Jonathan.Cameron@huawei.com&gt;

diff --git a/drivers/iio/industrialio-core.c b/drivers/iio/industrialio-core.c
index 9a85752124dd..173dc00762a1 100644
--- a/drivers/iio/industrialio-core.c
+++ b/drivers/iio/industrialio-core.c
@@ -1584,10 +1584,13 @@ static int iio_device_register_sysfs(struct iio_dev *indio_dev)
 	ret = iio_device_register_sysfs_group(indio_dev,
 					      &amp;iio_dev_opaque-&gt;chan_attr_group);
 	if (ret)
-		goto error_clear_attrs;
+		goto error_free_chan_attrs;
 
 	return 0;
 
+error_free_chan_attrs:
+	kfree(iio_dev_opaque-&gt;chan_attr_group.attrs);
+	iio_dev_opaque-&gt;chan_attr_group.attrs = NULL;
 error_clear_attrs:
 	iio_free_chan_devattr_list(&amp;iio_dev_opaque-&gt;channel_attr_list);
 </pre><hr><pre>commit 6c21660fe221a15c789dee2bc2fd95516bc5aeaf
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Thu Jan 18 21:03:06 2024 +0800

    vlan: skip nested type that is not IFLA_VLAN_QOS_MAPPING
    
    In the vlan_changelink function, a loop is used to parse the nested
    attributes IFLA_VLAN_EGRESS_QOS and IFLA_VLAN_INGRESS_QOS in order to
    obtain the struct ifla_vlan_qos_mapping. These two nested attributes are
    checked in the vlan_validate_qos_map function, which calls
    nla_validate_nested_deprecated with the vlan_map_policy.
    
    However, this deprecated validator applies a LIBERAL strictness, allowing
    the presence of an attribute with the type IFLA_VLAN_QOS_UNSPEC.
    Consequently, the loop in vlan_changelink may parse an attribute of type
    IFLA_VLAN_QOS_UNSPEC and believe it carries a payload of
    struct ifla_vlan_qos_mapping, which is not necessarily true.
    
    To address this issue and ensure compatibility, this patch introduces two
    type checks that skip attributes whose type is not IFLA_VLAN_QOS_MAPPING.
    
    Fixes: 07b5b17e157b ("[VLAN]: Use rtnl_link API")
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Reviewed-by: Simon Horman &lt;horms@kernel.org&gt;
    Link: https://lore.kernel.org/r/20240118130306.1644001-1-linma@zju.edu.cn
    Signed-off-by: Jakub Kicinski &lt;kuba@kernel.org&gt;

diff --git a/net/8021q/vlan_netlink.c b/net/8021q/vlan_netlink.c
index 214532173536..a3b68243fd4b 100644
--- a/net/8021q/vlan_netlink.c
+++ b/net/8021q/vlan_netlink.c
@@ -118,12 +118,16 @@ static int vlan_changelink(struct net_device *dev, struct nlattr *tb[],
 	}
 	if (data[IFLA_VLAN_INGRESS_QOS]) {
 		nla_for_each_nested(attr, data[IFLA_VLAN_INGRESS_QOS], rem) {
+			if (nla_type(attr) != IFLA_VLAN_QOS_MAPPING)
+				continue;
 			m = nla_data(attr);
 			vlan_dev_set_ingress_priority(dev, m-&gt;to, m-&gt;from);
 		}
 	}
 	if (data[IFLA_VLAN_EGRESS_QOS]) {
 		nla_for_each_nested(attr, data[IFLA_VLAN_EGRESS_QOS], rem) {
+			if (nla_type(attr) != IFLA_VLAN_QOS_MAPPING)
+				continue;
 			m = nla_data(attr);
 			err = vlan_dev_set_egress_priority(dev, m-&gt;from, m-&gt;to);
 			if (err)</pre><hr><pre>commit 04ae3eb470e52a3c41babe85ff8cee195e4dcbea
Author: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
Date:   Wed Jan 17 15:13:28 2024 +0800

    drm/lima: fix a memleak in lima_heap_alloc
    
    When lima_vm_map_bo fails, the resources need to be deallocated, or
    there will be memleaks.
    
    Fixes: 6aebc51d7aef ("drm/lima: support heap buffer creation")
    Signed-off-by: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
    Signed-off-by: Qiang Yu &lt;yuq825@gmail.com&gt;
    Link: https://patchwork.freedesktop.org/patch/msgid/20240117071328.3811480-1-alexious@zju.edu.cn

diff --git a/drivers/gpu/drm/lima/lima_gem.c b/drivers/gpu/drm/lima/lima_gem.c
index 4f9736e5f929..7ea244d876ca 100644
--- a/drivers/gpu/drm/lima/lima_gem.c
+++ b/drivers/gpu/drm/lima/lima_gem.c
@@ -75,29 +75,34 @@ int lima_heap_alloc(struct lima_bo *bo, struct lima_vm *vm)
 	} else {
 		bo-&gt;base.sgt = kmalloc(sizeof(*bo-&gt;base.sgt), GFP_KERNEL);
 		if (!bo-&gt;base.sgt) {
-			sg_free_table(&amp;sgt);
-			return -ENOMEM;
+			ret = -ENOMEM;
+			goto err_out0;
 		}
 	}
 
 	ret = dma_map_sgtable(dev, &amp;sgt, DMA_BIDIRECTIONAL, 0);
-	if (ret) {
-		sg_free_table(&amp;sgt);
-		kfree(bo-&gt;base.sgt);
-		bo-&gt;base.sgt = NULL;
-		return ret;
-	}
+	if (ret)
+		goto err_out1;
 
 	*bo-&gt;base.sgt = sgt;
 
 	if (vm) {
 		ret = lima_vm_map_bo(vm, bo, old_size &gt;&gt; PAGE_SHIFT);
 		if (ret)
-			return ret;
+			goto err_out2;
 	}
 
 	bo-&gt;heap_size = new_size;
 	return 0;
+
+err_out2:
+	dma_unmap_sgtable(dev, &amp;sgt, DMA_BIDIRECTIONAL, 0);
+err_out1:
+	kfree(bo-&gt;base.sgt);
+	bo-&gt;base.sgt = NULL;
+err_out0:
+	sg_free_table(&amp;sgt);
+	return ret;
 }
 
 int lima_gem_create_handle(struct drm_device *dev, struct drm_file *file,</pre><hr><pre>commit b33fb5b801c6db408b774a68e7c8722796b59ecc
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Wed Jan 10 14:14:00 2024 +0800

    net: qualcomm: rmnet: fix global oob in rmnet_policy
    
    The variable rmnet_link_ops assign a *bigger* maxtype which leads to a
    global out-of-bounds read when parsing the netlink attributes. See bug
    trace below:
    
    ==================================================================
    BUG: KASAN: global-out-of-bounds in validate_nla lib/nlattr.c:386 [inline]
    BUG: KASAN: global-out-of-bounds in __nla_validate_parse+0x24af/0x2750 lib/nlattr.c:600
    Read of size 1 at addr ffffffff92c438d0 by task syz-executor.6/84207
    
    CPU: 0 PID: 84207 Comm: syz-executor.6 Tainted: G                 N 6.1.0 #3
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014
    Call Trace:
     &lt;TASK&gt;
     __dump_stack lib/dump_stack.c:88 [inline]
     dump_stack_lvl+0x8b/0xb3 lib/dump_stack.c:106
     print_address_description mm/kasan/report.c:284 [inline]
     print_report+0x172/0x475 mm/kasan/report.c:395
     kasan_report+0xbb/0x1c0 mm/kasan/report.c:495
     validate_nla lib/nlattr.c:386 [inline]
     __nla_validate_parse+0x24af/0x2750 lib/nlattr.c:600
     __nla_parse+0x3e/0x50 lib/nlattr.c:697
     nla_parse_nested_deprecated include/net/netlink.h:1248 [inline]
     __rtnl_newlink+0x50a/0x1880 net/core/rtnetlink.c:3485
     rtnl_newlink+0x64/0xa0 net/core/rtnetlink.c:3594
     rtnetlink_rcv_msg+0x43c/0xd70 net/core/rtnetlink.c:6091
     netlink_rcv_skb+0x14f/0x410 net/netlink/af_netlink.c:2540
     netlink_unicast_kernel net/netlink/af_netlink.c:1319 [inline]
     netlink_unicast+0x54e/0x800 net/netlink/af_netlink.c:1345
     netlink_sendmsg+0x930/0xe50 net/netlink/af_netlink.c:1921
     sock_sendmsg_nosec net/socket.c:714 [inline]
     sock_sendmsg+0x154/0x190 net/socket.c:734
     ____sys_sendmsg+0x6df/0x840 net/socket.c:2482
     ___sys_sendmsg+0x110/0x1b0 net/socket.c:2536
     __sys_sendmsg+0xf3/0x1c0 net/socket.c:2565
     do_syscall_x64 arch/x86/entry/common.c:50 [inline]
     do_syscall_64+0x3b/0x90 arch/x86/entry/common.c:80
     entry_SYSCALL_64_after_hwframe+0x63/0xcd
    RIP: 0033:0x7fdcf2072359
    Code: 28 00 00 00 75 05 48 83 c4 28 c3 e8 f1 19 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 &lt;48&gt; 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b8 ff ff ff f7 d8 64 89 01 48
    RSP: 002b:00007fdcf13e3168 EFLAGS: 00000246 ORIG_RAX: 000000000000002e
    RAX: ffffffffffffffda RBX: 00007fdcf219ff80 RCX: 00007fdcf2072359
    RDX: 0000000000000000 RSI: 0000000020000200 RDI: 0000000000000003
    RBP: 00007fdcf20bd493 R08: 0000000000000000 R09: 0000000000000000
    R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000
    R13: 00007fffbb8d7bdf R14: 00007fdcf13e3300 R15: 0000000000022000
     &lt;/TASK&gt;
    
    The buggy address belongs to the variable:
     rmnet_policy+0x30/0xe0
    
    The buggy address belongs to the physical page:
    page:0000000065bdeb3c refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x155243
    flags: 0x200000000001000(reserved|node=0|zone=2)
    raw: 0200000000001000 ffffea00055490c8 ffffea00055490c8 0000000000000000
    raw: 0000000000000000 0000000000000000 00000001ffffffff 0000000000000000
    page dumped because: kasan: bad access detected
    
    Memory state around the buggy address:
     ffffffff92c43780: f9 f9 f9 f9 00 00 00 02 f9 f9 f9 f9 00 00 00 07
     ffffffff92c43800: f9 f9 f9 f9 00 00 00 05 f9 f9 f9 f9 06 f9 f9 f9
    &gt;ffffffff92c43880: f9 f9 f9 f9 00 00 00 00 00 00 f9 f9 f9 f9 f9 f9
                                                     ^
     ffffffff92c43900: 00 00 00 00 00 00 00 00 07 f9 f9 f9 f9 f9 f9 f9
     ffffffff92c43980: 00 00 00 07 f9 f9 f9 f9 00 00 00 05 f9 f9 f9 f9
    
    According to the comment of `nla_parse_nested_deprecated`, the maxtype
    should be len(destination array) - 1. Hence use `IFLA_RMNET_MAX` here.
    
    Fixes: 14452ca3b5ce ("net: qualcomm: rmnet: Export mux_id and flags to netlink")
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Reviewed-by: Subash Abhinov Kasiviswanathan &lt;quic_subashab@quicinc.com&gt;
    Reviewed-by: Simon Horman &lt;horms@kernel.org&gt;
    Reviewed-by: Jiri Pirko &lt;jiri@nvidia.com&gt;
    Link: https://lore.kernel.org/r/20240110061400.3356108-1-linma@zju.edu.cn
    Signed-off-by: Jakub Kicinski &lt;kuba@kernel.org&gt;

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
index 39d24e07f306..5b69b9268c75 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
@@ -396,7 +396,7 @@ static int rmnet_fill_info(struct sk_buff *skb, const struct net_device *dev)
 
 struct rtnl_link_ops rmnet_link_ops __read_mostly = {
 	.kind		= "rmnet",
-	.maxtype	= __IFLA_RMNET_MAX,
+	.maxtype	= IFLA_RMNET_MAX,
 	.priv_size	= sizeof(struct rmnet_priv),
 	.setup		= rmnet_vnd_setup,
 	.validate	= rmnet_rtnl_validate,</pre><hr><pre>commit 2f3be3ca779b11c332441b10e00443a2510f4d7b
Author: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
Date:   Sun Dec 24 16:22:47 2023 +0800

    drm/amd/pm/smu7: fix a memleak in smu7_hwmgr_backend_init
    
    The hwmgr-&gt;backend, (i.e. data) allocated by kzalloc is not freed in
    the error-handling paths of smu7_get_evv_voltages and
    smu7_update_edc_leakage_table. However, it did be freed in the
    error-handling of phm_initializa_dynamic_state_adjustment_rule_settings,
    by smu7_hwmgr_backend_fini. So the lack of free in smu7_get_evv_voltages
    and smu7_update_edc_leakage_table is considered a memleak in this patch.
    
    Fixes: 599a7e9fe1b6 ("drm/amd/powerplay: implement smu7 hwmgr to manager asics with smu ip version 7.")
    Fixes: 8f0804c6b7d0 ("drm/amd/pm: add edc leakage controller setting")
    Signed-off-by: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
    Signed-off-by: Alex Deucher &lt;alexander.deucher@amd.com&gt;

diff --git a/drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu7_hwmgr.c b/drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu7_hwmgr.c
index 11372fcc59c8..b1a8799e2dee 100644
--- a/drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu7_hwmgr.c
+++ b/drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu7_hwmgr.c
@@ -2974,6 +2974,8 @@ static int smu7_hwmgr_backend_init(struct pp_hwmgr *hwmgr)
 		result = smu7_get_evv_voltages(hwmgr);
 		if (result) {
 			pr_info("Get EVV Voltage Failed.  Abort Driver loading!\n");
+			kfree(hwmgr-&gt;backend);
+			hwmgr-&gt;backend = NULL;
 			return -EINVAL;
 		}
 	} else {
@@ -3019,8 +3021,10 @@ static int smu7_hwmgr_backend_init(struct pp_hwmgr *hwmgr)
 	}
 
 	result = smu7_update_edc_leakage_table(hwmgr);
-	if (result)
+	if (result) {
+		smu7_hwmgr_backend_fini(hwmgr);
 		return result;
+	}
 
 	return 0;
 }</pre><hr><pre>commit 89709105a6091948ffb6ec2427954cbfe45358ce
Author: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
Date:   Mon Dec 4 17:14:16 2023 +0800

    drm/vmwgfx: fix a memleak in vmw_gmrid_man_get_node
    
    When ida_alloc_max fails, resources allocated before should be freed,
    including *res allocated by kmalloc and ttm_resource_init.
    
    Fixes: d3bcb4b02fe9 ("drm/vmwgfx: switch the TTM backends to self alloc")
    Signed-off-by: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
    Signed-off-by: Zack Rusin &lt;zack.rusin@broadcom.com&gt;
    Link: https://patchwork.freedesktop.org/patch/msgid/20231204091416.3308430-1-alexious@zju.edu.cn

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c b/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c
index ceb4d3d3b965..a0b47c9b33f5 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c
@@ -64,8 +64,11 @@ static int vmw_gmrid_man_get_node(struct ttm_resource_manager *man,
 	ttm_resource_init(bo, place, *res);
 
 	id = ida_alloc_max(&amp;gman-&gt;gmr_ida, gman-&gt;max_gmr_ids - 1, GFP_KERNEL);
-	if (id &lt; 0)
+	if (id &lt; 0) {
+		ttm_resource_fini(man, *res);
+		kfree(*res);
 		return id;
+	}
 
 	spin_lock(&amp;gman-&gt;lock);
 </pre>
    <div class="pagination">
        <a href='6_2.html'>&lt;&lt;Prev</a><a href='6.html'>1</a><a href='6_2.html'>2</a><span>[3]</span><a href='6_4.html'>4</a><a href='6_5.html'>5</a><a href='6_6.html'>6</a><a href='6_7.html'>7</a><a href='6_8.html'>8</a><a href='6_9.html'>9</a><a href='6_10.html'>10</a><a href='6_11.html'>11</a><a href='6_12.html'>12</a><a href='6_13.html'>13</a><a href='6_14.html'>14</a><a href='6_15.html'>15</a><a href='6_16.html'>16</a><a href='6_17.html'>17</a><a href='6_18.html'>18</a><a href='6_19.html'>19</a><a href='6_20.html'>20</a><a href='6_21.html'>21</a><a href='6_22.html'>22</a><a href='6_23.html'>23</a><a href='6_24.html'>24</a><a href='6_25.html'>25</a><a href='6_26.html'>26</a><a href='6_27.html'>27</a><a href='6_28.html'>28</a><a href='6_29.html'>29</a><a href='6_30.html'>30</a><a href='6_31.html'>31</a><a href='6_32.html'>32</a><a href='6_33.html'>33</a><a href='6_34.html'>34</a><a href='6_4.html'>Next&gt;&gt;</a>
    <div>
</body>
