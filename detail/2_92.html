<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_91.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><span>[92]</span><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_93.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit c7257bd2ecb7b4cc42f9f152c7c059258d434169
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed May 21 13:53:01 2008 -0400

    USB: usb-storage: unusual_devs update for Cypress ATACB
    
    This patch (as1101) updates the unusual_devs entry for the Cypress
    ATACB pass-through.  The protocol field is changed from US_PR_BULK to
    US_PR_DEVICE, since the Cypress devices already set bInterfaceProtocol
    to Bulk-only.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index 1b09578cbb10..5d56893fc1cc 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -405,7 +405,7 @@ UNUSUAL_DEV(  0x04a5, 0x3010, 0x0100, 0x0100,
 UNUSUAL_DEV(  0x04b4, 0x6830, 0x0000, 0x9999,
 		"Cypress",
 		"Cypress AT2LP",
-		US_SC_CYP_ATACB, US_PR_BULK, NULL,
+		US_SC_CYP_ATACB, US_PR_DEVICE, NULL,
 		0),
 #endif
 </pre><hr><pre>commit fa38dfcc56b5f6cce787f9aaa5d1830509213802
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 20 16:59:33 2008 -0400

    USB: EHCI: fix performance regression
    
    This patch (as1099) fixes a performance regression in ehci-hcd.  The
    fundamental problem is that queue headers get removed from the
    schedule too quickly, since the code checks for a counter advancing
    rather than making an actual time-based check.  The latency involved
    in removing the queue header and then relinking it can severely
    degrade certain kinds of workloads.
    
    The patch replaces a simple counter with a timestamp derived from the
    controller's uframe value.  In addition, the delay for unlinking an
    idle queue header is increased from 5 ms to 10 ms; since some
    controllers (nVidia) have a latency of up to 1 ms for unlinking, this
    reduces the relative impact from 20% to 10%.
    
    Finally, a logical error left over from the IAA watchdog-timer
    conversion is corrected.  Now the driver will always either unlink an
    idle queue header or set up a timer to unlink it later.  The old code
    would sometimes fail to do either.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: David Brownell &lt;david-b@pacbell.net&gt;
    Cc: Leonid &lt;leonidv11@gmail.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 369a8a5ea7bb..3e3c5d3ea0ad 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -84,7 +84,8 @@ static const char	hcd_name [] = "ehci_hcd";
 #define EHCI_IAA_MSECS		10		/* arbitrary */
 #define EHCI_IO_JIFFIES		(HZ/10)		/* io watchdog &gt; irq_thresh */
 #define EHCI_ASYNC_JIFFIES	(HZ/20)		/* async idle timeout */
-#define EHCI_SHRINK_JIFFIES	(HZ/200)	/* async qh unlink delay */
+#define EHCI_SHRINK_JIFFIES	(HZ/100)	/* async qh unlink delay */
+#define EHCI_SHRINK_UFRAMES	(10*8)		/* same value in uframes */
 
 /* Initial IRQ latency:  faster than hw default */
 static int log2_irq_thresh = 0;		// 0 to 6
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index b85b54160cda..5200481deb27 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -1116,8 +1116,7 @@ static void scan_async (struct ehci_hcd *ehci)
 	struct ehci_qh		*qh;
 	enum ehci_timer_action	action = TIMER_IO_WATCHDOG;
 
-	if (!++(ehci-&gt;stamp))
-		ehci-&gt;stamp++;
+	ehci-&gt;stamp = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;frame_index);
 	timer_action_done (ehci, TIMER_ASYNC_SHRINK);
 rescan:
 	qh = ehci-&gt;async-&gt;qh_next.qh;
@@ -1148,12 +1147,14 @@ static void scan_async (struct ehci_hcd *ehci)
 			 * doesn't stay idle for long.
 			 * (plus, avoids some kind of re-activation race.)
 			 */
-			if (list_empty (&amp;qh-&gt;qtd_list)) {
-				if (qh-&gt;stamp == ehci-&gt;stamp)
+			if (list_empty(&amp;qh-&gt;qtd_list) &amp;&amp;
+					qh-&gt;qh_state == QH_STATE_LINKED) {
+				if (!ehci-&gt;reclaim &amp;&amp;
+				    ((ehci-&gt;stamp - qh-&gt;stamp) &amp; 8191) &gt;=
+						EHCI_SHRINK_UFRAMES)
+					start_unlink_async(ehci, qh);
+				else
 					action = TIMER_ASYNC_SHRINK;
-				else if (!ehci-&gt;reclaim
-					    &amp;&amp; qh-&gt;qh_state == QH_STATE_LINKED)
-					start_unlink_async (ehci, qh);
 			}
 
 			qh = qh-&gt;qh_next.qh;</pre><hr><pre>commit b40e43fcc532fa44a375a37d592e32cd0d50fe7a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 20 16:59:10 2008 -0400

    USB: EHCI: fix bug in Iso scheduling
    
    This patch (as1098) changes the way ehci-hcd schedules its periodic
    Iso transfers.  That the current scheduling code is wrong is clear on
    the face of it: Sometimes it returns -EL2NSYNC (meaning that an URB
    couldn't be scheduled because it was submitted too late), but it does
    this even when the URB_ISO_ASAP flag is set (meaning the URB should be
    scheduled as soon as possible).
    
    The new code properly implements as-soon-as-possible scheduling,
    assigning the next unexpired slot as the URB's starting point.  It
    also is more careful about checking for Iso URB completion: It doesn't
    bother to check for activity during frames that are already over,
    and it allows for the possibility that some of the URB's packets may
    have raced the hardware when they were submitted and so never got used
    (the packet status is set to -EXDEV).
    
    This fixes problems several people have experienced with USB video
    applications.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: David Brownell &lt;dbrownell@users.sourceforge.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index be575e46eac3..b7853c8bac0f 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -1349,18 +1349,27 @@ iso_stream_schedule (
 	/* when's the last uframe this urb could start? */
 	max = now + mod;
 
-	/* typical case: reuse current schedule. stream is still active,
-	 * and no gaps from host falling behind (irq delays etc)
+	/* Typical case: reuse current schedule, stream is still active.
+	 * Hopefully there are no gaps from the host falling behind
+	 * (irq delays etc), but if there are we'll take the next
+	 * slot in the schedule, implicitly assuming URB_ISO_ASAP.
 	 */
 	if (likely (!list_empty (&amp;stream-&gt;td_list))) {
 		start = stream-&gt;next_uframe;
 		if (start &lt; now)
 			start += mod;
-		if (likely ((start + sched-&gt;span) &lt; max))
-			goto ready;
-		/* else fell behind; someday, try to reschedule */
-		status = -EL2NSYNC;
-		goto fail;
+
+		/* Fell behind (by up to twice the slop amount)? */
+		if (start &gt;= max - 2 * 8 * SCHEDULE_SLOP)
+			start += stream-&gt;interval * DIV_ROUND_UP(
+					max - start, stream-&gt;interval) - mod;
+
+		/* Tried to schedule too far into the future? */
+		if (unlikely((start + sched-&gt;span) &gt;= max)) {
+			status = -EFBIG;
+			goto fail;
+		}
+		goto ready;
 	}
 
 	/* need to schedule; when's the next (u)frame we could start?
@@ -1613,6 +1622,9 @@ itd_complete (
 		} else if (likely ((t &amp; EHCI_ISOC_ACTIVE) == 0)) {
 			desc-&gt;status = 0;
 			desc-&gt;actual_length = EHCI_ITD_LENGTH (t);
+		} else {
+			/* URB was too late */
+			desc-&gt;status = -EXDEV;
 		}
 	}
 
@@ -2095,7 +2107,7 @@ static int sitd_submit (struct ehci_hcd *ehci, struct urb *urb,
 static void
 scan_periodic (struct ehci_hcd *ehci)
 {
-	unsigned	frame, clock, now_uframe, mod;
+	unsigned	now_uframe, frame, clock, clock_frame, mod;
 	unsigned	modified;
 
 	mod = ehci-&gt;periodic_size &lt;&lt; 3;
@@ -2111,6 +2123,7 @@ scan_periodic (struct ehci_hcd *ehci)
 	else
 		clock = now_uframe + mod - 1;
 	clock %= mod;
+	clock_frame = clock &gt;&gt; 3;
 
 	for (;;) {
 		union ehci_shadow	q, *q_p;
@@ -2157,22 +2170,26 @@ scan_periodic (struct ehci_hcd *ehci)
 			case Q_TYPE_ITD:
 				/* If this ITD is still active, leave it for
 				 * later processing ... check the next entry.
+				 * No need to check for activity unless the
+				 * frame is current.
 				 */
-				rmb ();
-				for (uf = 0; uf &lt; 8 &amp;&amp; live; uf++) {
-					if (0 == (q.itd-&gt;hw_transaction [uf]
-							&amp; ITD_ACTIVE(ehci)))
-						continue;
-					incomplete = true;
-					q_p = &amp;q.itd-&gt;itd_next;
-					hw_p = &amp;q.itd-&gt;hw_next;
-					type = Q_NEXT_TYPE(ehci,
+				if (frame == clock_frame &amp;&amp; live) {
+					rmb();
+					for (uf = 0; uf &lt; 8; uf++) {
+						if (q.itd-&gt;hw_transaction[uf] &amp;
+							    ITD_ACTIVE(ehci))
+							break;
+					}
+					if (uf &lt; 8) {
+						incomplete = true;
+						q_p = &amp;q.itd-&gt;itd_next;
+						hw_p = &amp;q.itd-&gt;hw_next;
+						type = Q_NEXT_TYPE(ehci,
 							q.itd-&gt;hw_next);
-					q = *q_p;
-					break;
+						q = *q_p;
+						break;
+					}
 				}
-				if (uf &lt; 8 &amp;&amp; live)
-					break;
 
 				/* Take finished ITDs out of the schedule
 				 * and process them:  recycle, maybe report
@@ -2189,9 +2206,12 @@ scan_periodic (struct ehci_hcd *ehci)
 			case Q_TYPE_SITD:
 				/* If this SITD is still active, leave it for
 				 * later processing ... check the next entry.
+				 * No need to check for activity unless the
+				 * frame is current.
 				 */
-				if ((q.sitd-&gt;hw_results &amp; SITD_ACTIVE(ehci))
-						&amp;&amp; live) {
+				if (frame == clock_frame &amp;&amp; live &amp;&amp;
+						(q.sitd-&gt;hw_results &amp;
+							SITD_ACTIVE(ehci))) {
 					incomplete = true;
 					q_p = &amp;q.sitd-&gt;sitd_next;
 					hw_p = &amp;q.sitd-&gt;hw_next;
@@ -2260,6 +2280,7 @@ scan_periodic (struct ehci_hcd *ehci)
 
 			/* rescan the rest of this frame, then ... */
 			clock = now;
+			clock_frame = clock &gt;&gt; 3;
 		} else {
 			now_uframe++;
 			now_uframe %= mod;</pre><hr><pre>commit d1f114d12bb4db3147e1b1342ae31083c5a79c84
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 20 16:58:58 2008 -0400

    USB: EHCI: fix remote-wakeup regression
    
    This patch (as1097) fixes a bug in the remote-wakeup handling in
    ehci-hcd.  The driver currently does not keep track of whether the
    change-suspend feature is enabled for each port; the feature is
    automatically reset the first time it is read.  But recent changes to
    the hub driver require that the feature be read at least twice in
    order to work properly.
    
    A bit-vector is added for storing the change-suspend feature values.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: David Brownell &lt;dbrownell@users.sourceforge.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index d613dc9e9c05..740835bb8575 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -609,7 +609,7 @@ static int ehci_hub_control (
 			}
 			break;
 		case USB_PORT_FEAT_C_SUSPEND:
-			/* we auto-clear this feature */
+			clear_bit(wIndex, &amp;ehci-&gt;port_c_suspend);
 			break;
 		case USB_PORT_FEAT_POWER:
 			if (HCS_PPC (ehci-&gt;hcs_params))
@@ -688,7 +688,7 @@ static int ehci_hub_control (
 			/* resume completed? */
 			else if (time_after_eq(jiffies,
 					ehci-&gt;reset_done[wIndex])) {
-				status |= 1 &lt;&lt; USB_PORT_FEAT_C_SUSPEND;
+				set_bit(wIndex, &amp;ehci-&gt;port_c_suspend);
 				ehci-&gt;reset_done[wIndex] = 0;
 
 				/* stop resume signaling */
@@ -765,6 +765,8 @@ static int ehci_hub_control (
 			status |= 1 &lt;&lt; USB_PORT_FEAT_RESET;
 		if (temp &amp; PORT_POWER)
 			status |= 1 &lt;&lt; USB_PORT_FEAT_POWER;
+		if (test_bit(wIndex, &amp;ehci-&gt;port_c_suspend))
+			status |= 1 &lt;&lt; USB_PORT_FEAT_C_SUSPEND;
 
 #ifndef	VERBOSE_DEBUG
 	if (status &amp; ~0xffff)	/* only if wPortChange is interesting */
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 3cb482308343..35a03095757e 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -97,6 +97,8 @@ struct ehci_hcd {			/* one per controller */
 			dedicated to the companion controller */
 	unsigned long		owned_ports;		/* which ports are
 			owned by the companion during a bus suspend */
+	unsigned long		port_c_suspend;		/* which ports have
+			the change-suspend feature turned on */
 
 	/* per-HC memory pools (could be per-bus, but ...) */
 	struct dma_pool		*qh_pool;	/* qh per active urb */</pre><hr><pre>commit 3a31155cfff0935e4b178f3dca733d2d60d2eb8d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 20 16:58:29 2008 -0400

    USB: EHCI: suppress unwanted error messages
    
    This patch (as1096) fixes an annoying problem: When a full-speed or
    low-speed device is plugged into an EHCI controller, it fails to
    enumerate at high speed and then is handed over to the companion
    controller.  But usbcore logs a misleading and unwanted error message
    when the high-speed enumeration fails.
    
    The patch adds a new HCD method, port_handed_over, which asks whether
    a port has been handed over to a companion controller.  If it has, the
    error message is suppressed.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.h b/drivers/usb/core/hcd.h
index 1e4b81e9eb50..a0bf5df6cb6f 100644
--- a/drivers/usb/core/hcd.h
+++ b/drivers/usb/core/hcd.h
@@ -213,6 +213,8 @@ struct hc_driver {
 
 		/* force handover of high-speed port to full-speed companion */
 	void	(*relinquish_port)(struct usb_hcd *, int);
+		/* has a port been handed over to a companion? */
+	int	(*port_handed_over)(struct usb_hcd *, int);
 };
 
 extern int usb_hcd_link_urb_to_ep(struct usb_hcd *hcd, struct urb *urb);
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 1a3d2879bc1d..8eb4da332f56 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2753,7 +2753,11 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 		if ((status == -ENOTCONN) || (status == -ENOTSUPP))
 			break;
 	}
-	dev_err(hub_dev, "unable to enumerate USB device on port %d\n", port1);
+	if (hub-&gt;hdev-&gt;parent ||
+			!hcd-&gt;driver-&gt;port_handed_over ||
+			!(hcd-&gt;driver-&gt;port_handed_over)(hcd, port1))
+		dev_err(hub_dev, "unable to enumerate USB device on port %d\n",
+				port1);
  
 done:
 	hub_port_disable(hub, port1, 1);
diff --git a/drivers/usb/host/ehci-au1xxx.c b/drivers/usb/host/ehci-au1xxx.c
index 8b5f991e949c..08a4335401a9 100644
--- a/drivers/usb/host/ehci-au1xxx.c
+++ b/drivers/usb/host/ehci-au1xxx.c
@@ -223,6 +223,7 @@ static const struct hc_driver ehci_au1xxx_hc_driver = {
 	.bus_suspend = ehci_bus_suspend,
 	.bus_resume = ehci_bus_resume,
 	.relinquish_port = ehci_relinquish_port,
+	.port_handed_over = ehci_port_handed_over,
 };
 
 /*-------------------------------------------------------------------------*/
diff --git a/drivers/usb/host/ehci-fsl.c b/drivers/usb/host/ehci-fsl.c
index 4843062e6e21..7370d6187c64 100644
--- a/drivers/usb/host/ehci-fsl.c
+++ b/drivers/usb/host/ehci-fsl.c
@@ -318,6 +318,7 @@ static const struct hc_driver ehci_fsl_hc_driver = {
 	.bus_suspend = ehci_bus_suspend,
 	.bus_resume = ehci_bus_resume,
 	.relinquish_port = ehci_relinquish_port,
+	.port_handed_over = ehci_port_handed_over,
 };
 
 static int ehci_fsl_drv_probe(struct platform_device *pdev)
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 382587c4457c..d613dc9e9c05 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -875,3 +875,13 @@ static void ehci_relinquish_port(struct usb_hcd *hcd, int portnum)
 	set_owner(ehci, --portnum, PORT_OWNER);
 }
 
+static int ehci_port_handed_over(struct usb_hcd *hcd, int portnum)
+{
+	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
+	u32 __iomem		*reg;
+
+	if (ehci_is_TDI(ehci))
+		return 0;
+	reg = &amp;ehci-&gt;regs-&gt;port_status[portnum - 1];
+	return ehci_readl(ehci, reg) &amp; PORT_OWNER;
+}
diff --git a/drivers/usb/host/ehci-ixp4xx.c b/drivers/usb/host/ehci-ixp4xx.c
index 539257f15924..9d042f220097 100644
--- a/drivers/usb/host/ehci-ixp4xx.c
+++ b/drivers/usb/host/ehci-ixp4xx.c
@@ -59,6 +59,7 @@ static const struct hc_driver ixp4xx_ehci_hc_driver = {
 	.bus_resume		= ehci_bus_resume,
 #endif
 	.relinquish_port	= ehci_relinquish_port,
+	.port_handed_over	= ehci_port_handed_over,
 };
 
 static int ixp4xx_ehci_probe(struct platform_device *pdev)
diff --git a/drivers/usb/host/ehci-orion.c b/drivers/usb/host/ehci-orion.c
index 9c5266d02d6c..ab625f0ba1d9 100644
--- a/drivers/usb/host/ehci-orion.c
+++ b/drivers/usb/host/ehci-orion.c
@@ -162,6 +162,7 @@ static const struct hc_driver ehci_orion_hc_driver = {
 	.bus_suspend = ehci_bus_suspend,
 	.bus_resume = ehci_bus_resume,
 	.relinquish_port = ehci_relinquish_port,
+	.port_handed_over = ehci_port_handed_over,
 };
 
 static void __init
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 6ff453f935e7..c46a58f9181d 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -379,6 +379,7 @@ static const struct hc_driver ehci_pci_hc_driver = {
 	.bus_suspend =		ehci_bus_suspend,
 	.bus_resume =		ehci_bus_resume,
 	.relinquish_port =	ehci_relinquish_port,
+	.port_handed_over =	ehci_port_handed_over,
 };
 
 /*-------------------------------------------------------------------------*/
diff --git a/drivers/usb/host/ehci-ppc-of.c b/drivers/usb/host/ehci-ppc-of.c
index d94a2ef4944c..b018deed2e8f 100644
--- a/drivers/usb/host/ehci-ppc-of.c
+++ b/drivers/usb/host/ehci-ppc-of.c
@@ -77,6 +77,7 @@ static const struct hc_driver ehci_ppc_of_hc_driver = {
 	.bus_resume		= ehci_bus_resume,
 #endif
 	.relinquish_port	= ehci_relinquish_port,
+	.port_handed_over	= ehci_port_handed_over,
 };
 
 
diff --git a/drivers/usb/host/ehci-ppc-soc.c b/drivers/usb/host/ehci-ppc-soc.c
index 6c76036783a1..529590eb4037 100644
--- a/drivers/usb/host/ehci-ppc-soc.c
+++ b/drivers/usb/host/ehci-ppc-soc.c
@@ -163,6 +163,7 @@ static const struct hc_driver ehci_ppc_soc_hc_driver = {
 	.bus_suspend = ehci_bus_suspend,
 	.bus_resume = ehci_bus_resume,
 	.relinquish_port = ehci_relinquish_port,
+	.port_handed_over = ehci_port_handed_over,
 };
 
 static int ehci_hcd_ppc_soc_drv_probe(struct platform_device *pdev)
diff --git a/drivers/usb/host/ehci-ps3.c b/drivers/usb/host/ehci-ps3.c
index 69782221bcf3..37e6abeb794c 100644
--- a/drivers/usb/host/ehci-ps3.c
+++ b/drivers/usb/host/ehci-ps3.c
@@ -73,6 +73,7 @@ static const struct hc_driver ps3_ehci_hc_driver = {
 	.bus_resume		= ehci_bus_resume,
 #endif
 	.relinquish_port	= ehci_relinquish_port,
+	.port_handed_over	= ehci_port_handed_over,
 };
 
 static int ps3_ehci_probe(struct ps3_system_bus_device *dev)</pre><hr><pre>commit a8e5177583e975fc1f7c621c93956f494df9b979
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 20 16:58:11 2008 -0400

    USB: EHCI: fix up root-hub TT mess
    
    This patch (as1095) cleans up the HCD glue and several of the EHCI
    bus-glue files.  The ehci-&gt;is_tdi_rh_tt flag is redundant, since it
    means the same thing as the hcd-&gt;has_tt flag, so it is removed and the
    other flag used in its place.
    
    Some of the bus-glue files didn't get the relinquish_port method added
    to their hc_driver structures.  Although that routine currently
    doesn't do anything for controllers with an integrated TT, in the
    future it might.  So the patch adds it where it is missing.
    
    Lastly, some of the bus-glue files have erroneous entries for their
    hc_driver's suspend and resume methods.  These method pointers are
    specific to PCI and shouldn't be used otherwise.
    
    (The patch also includes an invisible whitespace fix.)
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: David Brownell &lt;dbrownell@users.sourceforge.net&gt;

diff --git a/drivers/usb/host/ehci-fsl.c b/drivers/usb/host/ehci-fsl.c
index 6d9bed6c1f48..4843062e6e21 100644
--- a/drivers/usb/host/ehci-fsl.c
+++ b/drivers/usb/host/ehci-fsl.c
@@ -269,7 +269,7 @@ static int ehci_fsl_setup(struct usb_hcd *hcd)
 	if (retval)
 		return retval;
 
-	ehci-&gt;is_tdi_rh_tt = 1;
+	hcd-&gt;has_tt = 1;
 
 	ehci-&gt;sbrn = 0x20;
 
@@ -295,10 +295,6 @@ static const struct hc_driver ehci_fsl_hc_driver = {
 	 */
 	.reset = ehci_fsl_setup,
 	.start = ehci_run,
-#ifdef	CONFIG_PM
-	.suspend = ehci_bus_suspend,
-	.resume = ehci_bus_resume,
-#endif
 	.stop = ehci_stop,
 	.shutdown = ehci_shutdown,
 
diff --git a/drivers/usb/host/ehci-ixp4xx.c b/drivers/usb/host/ehci-ixp4xx.c
index 601c8795a854..539257f15924 100644
--- a/drivers/usb/host/ehci-ixp4xx.c
+++ b/drivers/usb/host/ehci-ixp4xx.c
@@ -26,7 +26,7 @@ static int ixp4xx_ehci_init(struct usb_hcd *hcd)
 		+ HC_LENGTH(ehci_readl(ehci, &amp;ehci-&gt;caps-&gt;hc_capbase));
 	ehci-&gt;hcs_params = ehci_readl(ehci, &amp;ehci-&gt;caps-&gt;hcs_params);
 
-	ehci-&gt;is_tdi_rh_tt = 1;
+	hcd-&gt;has_tt = 1;
 	ehci_reset(ehci);
 
 	retval = ehci_init(hcd);
@@ -58,6 +58,7 @@ static const struct hc_driver ixp4xx_ehci_hc_driver = {
 	.bus_suspend		= ehci_bus_suspend,
 	.bus_resume		= ehci_bus_resume,
 #endif
+	.relinquish_port	= ehci_relinquish_port,
 };
 
 static int ixp4xx_ehci_probe(struct platform_device *pdev)
diff --git a/drivers/usb/host/ehci-orion.c b/drivers/usb/host/ehci-orion.c
index 3adfda813a7b..9c5266d02d6c 100644
--- a/drivers/usb/host/ehci-orion.c
+++ b/drivers/usb/host/ehci-orion.c
@@ -139,10 +139,6 @@ static const struct hc_driver ehci_orion_hc_driver = {
 	 */
 	.reset = ehci_orion_setup,
 	.start = ehci_run,
-#ifdef CONFIG_PM
-	.suspend = ehci_bus_suspend,
-	.resume = ehci_bus_resume,
-#endif
 	.stop = ehci_stop,
 	.shutdown = ehci_shutdown,
 
@@ -165,6 +161,7 @@ static const struct hc_driver ehci_orion_hc_driver = {
 	.hub_control = ehci_hub_control,
 	.bus_suspend = ehci_bus_suspend,
 	.bus_resume = ehci_bus_resume,
+	.relinquish_port = ehci_relinquish_port,
 };
 
 static void __init
@@ -250,7 +247,7 @@ static int __init ehci_orion_drv_probe(struct platform_device *pdev)
 	ehci-&gt;regs = hcd-&gt;regs + 0x100 +
 		HC_LENGTH(ehci_readl(ehci, &amp;ehci-&gt;caps-&gt;hc_capbase));
 	ehci-&gt;hcs_params = ehci_readl(ehci, &amp;ehci-&gt;caps-&gt;hcs_params);
-	ehci-&gt;is_tdi_rh_tt = 1;
+	hcd-&gt;has_tt = 1;
 	ehci-&gt;sbrn = 0x20;
 
 	/*
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 5bb7f6bb13f3..6ff453f935e7 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -129,7 +129,6 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 	switch (pdev-&gt;vendor) {
 	case PCI_VENDOR_ID_TDI:
 		if (pdev-&gt;device == PCI_DEVICE_ID_TDI_EHCI) {
-			ehci-&gt;is_tdi_rh_tt = 1;
 			hcd-&gt;has_tt = 1;
 			tdi_reset(ehci);
 		}
@@ -379,7 +378,7 @@ static const struct hc_driver ehci_pci_hc_driver = {
 	.hub_control =		ehci_hub_control,
 	.bus_suspend =		ehci_bus_suspend,
 	.bus_resume =		ehci_bus_resume,
-	.relinquish_port = 	ehci_relinquish_port,
+	.relinquish_port =	ehci_relinquish_port,
 };
 
 /*-------------------------------------------------------------------------*/
diff --git a/drivers/usb/host/ehci-ppc-of.c b/drivers/usb/host/ehci-ppc-of.c
index ee305b1f99ff..d94a2ef4944c 100644
--- a/drivers/usb/host/ehci-ppc-of.c
+++ b/drivers/usb/host/ehci-ppc-of.c
@@ -76,6 +76,7 @@ static const struct hc_driver ehci_ppc_of_hc_driver = {
 	.bus_suspend		= ehci_bus_suspend,
 	.bus_resume		= ehci_bus_resume,
 #endif
+	.relinquish_port	= ehci_relinquish_port,
 };
 
 
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index bf92d209a1a9..3cb482308343 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -112,7 +112,6 @@ struct ehci_hcd {			/* one per controller */
 	u32			command;
 
 	/* SILICON QUIRKS */
-	unsigned		is_tdi_rh_tt:1;	/* TDI roothub with TT */
 	unsigned		no_selective_suspend:1;
 	unsigned		has_fsl_port_bug:1; /* FreeScale */
 	unsigned		big_endian_mmio:1;
@@ -678,7 +677,7 @@ struct ehci_fstn {
  * needed (mostly in root hub code).
  */
 
-#define	ehci_is_TDI(e)			((e)-&gt;is_tdi_rh_tt)
+#define	ehci_is_TDI(e)			(ehci_to_hcd(e)-&gt;has_tt)
 
 /* Returns the speed of a device attached to a port on the root hub. */
 static inline unsigned int</pre><hr><pre>commit 217a9081d8e69026186067711131b77f0ce219ed
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 20 16:40:42 2008 -0400

    USB: add all configs to the "descriptors" attribute
    
    This patch (as1094) changes the output of the "descriptors" binary
    attribute.  Now it will contain the device descriptor followed by all
    the configuration descriptors, not just the descriptor for the current
    config.
    
    Userspace libraries want to have access to the kernel's cached
    descriptor information, so they can learn about device characteristics
    without having to wake up suspended devices.  So far the only user of
    this attribute is the new libusb-1.0 library; thus changing its
    contents shouldn't cause any problems.
    
    This should be considered for 2.6.26, if for no other reason than to
    minimize the range of releases in which the attribute contains only the
    current config descriptor.
    
    Also, it doesn't hurt that the patch removes the device locking --
    which was formerly needed in order to know for certain which config was
    indeed current.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c
index c783cb111847..5e1f5d55bf04 100644
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -588,35 +588,33 @@ read_descriptors(struct kobject *kobj, struct bin_attribute *attr,
 			container_of(kobj, struct device, kobj));
 	size_t nleft = count;
 	size_t srclen, n;
+	int cfgno;
+	void *src;
 
-	usb_lock_device(udev);
-
-	/* The binary attribute begins with the device descriptor */
-	srclen = sizeof(struct usb_device_descriptor);
-	if (off &lt; srclen) {
-		n = min_t(size_t, nleft, srclen - off);
-		memcpy(buf, off + (char *) &amp;udev-&gt;descriptor, n);
-		nleft -= n;
-		buf += n;
-		off = 0;
-	} else {
-		off -= srclen;
-	}
-
-	/* Then follows the raw descriptor entry for the current
-	 * configuration (config plus subsidiary descriptors).
+	/* The binary attribute begins with the device descriptor.
+	 * Following that are the raw descriptor entries for all the
+	 * configurations (config plus subsidiary descriptors).
 	 */
-	if (udev-&gt;actconfig) {
-		int cfgno = udev-&gt;actconfig - udev-&gt;config;
-
-		srclen = __le16_to_cpu(udev-&gt;actconfig-&gt;desc.wTotalLength);
+	for (cfgno = -1; cfgno &lt; udev-&gt;descriptor.bNumConfigurations &amp;&amp;
+			nleft &gt; 0; ++cfgno) {
+		if (cfgno &lt; 0) {
+			src = &amp;udev-&gt;descriptor;
+			srclen = sizeof(struct usb_device_descriptor);
+		} else {
+			src = udev-&gt;rawdescriptors[cfgno];
+			srclen = __le16_to_cpu(udev-&gt;config[cfgno].desc.
+					wTotalLength);
+		}
 		if (off &lt; srclen) {
-			n = min_t(size_t, nleft, srclen - off);
-			memcpy(buf, off + udev-&gt;rawdescriptors[cfgno], n);
+			n = min(nleft, srclen - (size_t) off);
+			memcpy(buf, src + off, n);
 			nleft -= n;
+			buf += n;
+			off = 0;
+		} else {
+			off -= srclen;
 		}
 	}
-	usb_unlock_device(udev);
 	return count - nleft;
 }
 </pre><hr><pre>commit e16362a0c8d90e9adbfe477acbe32b021823fb22
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 20 16:37:34 2008 -0400

    USB: fix possible deadlock involving sysfs attributes
    
    There is a potential deadlock when the usb_generic driver is unbound
    from a device.  The problem is that generic_disconnect() is called
    with the device lock held, and it removes a bunch of device attributes
    from sysfs.  If a user task happens to be running an attribute method
    at the time, the removal will block until the method returns.  But at
    least one of the attribute methods (the store routine for power/level)
    needs to acquire the device lock!
    
    This patch (as1093) eliminates the deadlock by moving the calls to
    create and remove the sysfs attributes from the usb_generic driver
    into usb_new_device() and usb_disconnect(), where they can be invoked
    without holding the device lock.
    
    Besides, the other sysfs attributes are created when the device is
    registered and removed when the device is unregistered.  So it seems
    only fitting for the extra attributes to be created and removed at the
    same time.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index c1cb94e9f242..7e912f21fd36 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -155,9 +155,6 @@ static int generic_probe(struct usb_device *udev)
 {
 	int err, c;
 
-	/* put device-specific files into sysfs */
-	usb_create_sysfs_dev_files(udev);
-
 	/* Choose and set the configuration.  This registers the interfaces
 	 * with the driver core and lets interface drivers bind to them.
 	 */
@@ -189,8 +186,6 @@ static void generic_disconnect(struct usb_device *udev)
 	 * unconfigure the device */
 	if (udev-&gt;actconfig)
 		usb_set_configuration(udev, -1);
-
-	usb_remove_sysfs_dev_files(udev);
 }
 
 #ifdef	CONFIG_PM
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index eb57fcc701d7..1a3d2879bc1d 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1326,6 +1326,12 @@ void usb_disconnect(struct usb_device **pdev)
 
 	usb_unlock_device(udev);
 
+	/* Remove the device-specific files from sysfs.  This must be
+	 * done with udev unlocked, because some of the attribute
+	 * routines try to acquire the device lock.
+	 */
+	usb_remove_sysfs_dev_files(udev);
+
 	/* Unregister the device.  The device driver is responsible
 	 * for removing the device files from usbfs and sysfs and for
 	 * de-configuring the device.
@@ -1541,6 +1547,9 @@ int usb_new_device(struct usb_device *udev)
 		goto fail;
 	}
 
+	/* put device-specific files into sysfs */
+	usb_create_sysfs_dev_files(udev);
+
 	/* Tell the world! */
 	announce_device(udev);
 	return err;</pre><hr><pre>commit 2e5f10e4f0a9649186d8a8c793822b2e0dae8373
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Apr 30 15:37:19 2008 -0400

    USB: create attributes before sending uevent
    
    This patch (as1087d) fixes a long-standing problem in usbcore: Device,
    interface, and endpoint attributes aren't added until _after_ the
    creation uevent has already been broadcast.
    
    Unfortunately there are a few attributes which cannot be created that
    early.  The "descriptors" attribute is binary and so must be created
    separately.  The power-management attributes can't be created until
    the dev/power/ group exists.  And the interface string can vary from
    one altsetting to another, so it has to be created dynamically.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: Kay Sievers &lt;kay.sievers@vrfy.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/endpoint.c b/drivers/usb/core/endpoint.c
index 99e5a68a3f12..fae55a31e26d 100644
--- a/drivers/usb/core/endpoint.c
+++ b/drivers/usb/core/endpoint.c
@@ -156,6 +156,10 @@ static struct attribute *ep_dev_attrs[] = {
 static struct attribute_group ep_dev_attr_grp = {
 	.attrs = ep_dev_attrs,
 };
+static struct attribute_group *ep_dev_groups[] = {
+	&amp;ep_dev_attr_grp,
+	NULL
+};
 
 static int usb_endpoint_major_init(void)
 {
@@ -298,6 +302,7 @@ int usb_create_ep_files(struct device *parent,
 
 	ep_dev-&gt;desc = &amp;endpoint-&gt;desc;
 	ep_dev-&gt;udev = udev;
+	ep_dev-&gt;dev.groups = ep_dev_groups;
 	ep_dev-&gt;dev.devt = MKDEV(usb_endpoint_major, ep_dev-&gt;minor);
 	ep_dev-&gt;dev.class = ep_class-&gt;class;
 	ep_dev-&gt;dev.parent = parent;
@@ -309,9 +314,6 @@ int usb_create_ep_files(struct device *parent,
 	retval = device_register(&amp;ep_dev-&gt;dev);
 	if (retval)
 		goto error_chrdev;
-	retval = sysfs_create_group(&amp;ep_dev-&gt;dev.kobj, &amp;ep_dev_attr_grp);
-	if (retval)
-		goto error_group;
 
 	/* create the symlink to the old-style "ep_XX" directory */
 	sprintf(name, "ep_%02x", endpoint-&gt;desc.bEndpointAddress);
@@ -322,8 +324,6 @@ int usb_create_ep_files(struct device *parent,
 	return retval;
 
 error_link:
-	sysfs_remove_group(&amp;ep_dev-&gt;dev.kobj, &amp;ep_dev_attr_grp);
-error_group:
 	device_unregister(&amp;ep_dev-&gt;dev);
 	destroy_endpoint_class();
 	return retval;
@@ -348,7 +348,6 @@ void usb_remove_ep_files(struct usb_host_endpoint *endpoint)
 
 		sprintf(name, "ep_%02x", endpoint-&gt;desc.bEndpointAddress);
 		sysfs_remove_link(&amp;ep_dev-&gt;dev.parent-&gt;kobj, name);
-		sysfs_remove_group(&amp;ep_dev-&gt;dev.kobj, &amp;ep_dev_attr_grp);
 		device_unregister(&amp;ep_dev-&gt;dev);
 		endpoint-&gt;ep_dev = NULL;
 		destroy_endpoint_class();
diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 3e69266e1f4d..fe47d145255a 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1607,6 +1607,7 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 		intf-&gt;dev.driver = NULL;
 		intf-&gt;dev.bus = &amp;usb_bus_type;
 		intf-&gt;dev.type = &amp;usb_if_device_type;
+		intf-&gt;dev.groups = usb_interface_groups;
 		intf-&gt;dev.dma_mask = dev-&gt;dev.dma_mask;
 		device_initialize(&amp;intf-&gt;dev);
 		mark_quiesced(intf);
diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c
index 5b20a60de8ba..c783cb111847 100644
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -538,6 +538,46 @@ static struct attribute_group dev_attr_grp = {
 	.attrs = dev_attrs,
 };
 
+/* When modifying this list, be sure to modify dev_string_attrs_are_visible()
+ * accordingly.
+ */
+static struct attribute *dev_string_attrs[] = {
+	&amp;dev_attr_manufacturer.attr,
+	&amp;dev_attr_product.attr,
+	&amp;dev_attr_serial.attr,
+	NULL
+};
+
+static mode_t dev_string_attrs_are_visible(struct kobject *kobj,
+		struct attribute *a, int n)
+{
+	struct usb_device *udev = to_usb_device(
+			container_of(kobj, struct device, kobj));
+
+	if (a == &amp;dev_attr_manufacturer.attr) {
+		if (udev-&gt;manufacturer == NULL)
+			return 0;
+	} else if (a == &amp;dev_attr_product.attr) {
+		if (udev-&gt;product == NULL)
+			return 0;
+	} else if (a == &amp;dev_attr_serial.attr) {
+		if (udev-&gt;serial == NULL)
+			return 0;
+	}
+	return a-&gt;mode;
+}
+
+static struct attribute_group dev_string_attr_grp = {
+	.attrs =	dev_string_attrs,
+	.is_visible =	dev_string_attrs_are_visible,
+};
+
+struct attribute_group *usb_device_groups[] = {
+	&amp;dev_attr_grp,
+	&amp;dev_string_attr_grp,
+	NULL
+};
+
 /* Binary descriptors */
 
 static ssize_t
@@ -591,10 +631,9 @@ int usb_create_sysfs_dev_files(struct usb_device *udev)
 	struct device *dev = &amp;udev-&gt;dev;
 	int retval;
 
-	retval = sysfs_create_group(&amp;dev-&gt;kobj, &amp;dev_attr_grp);
-	if (retval)
-		return retval;
-
+	/* Unforunately these attributes cannot be created before
+	 * the uevent is broadcast.
+	 */
 	retval = device_create_bin_file(dev, &amp;dev_bin_attr_descriptors);
 	if (retval)
 		goto error;
@@ -607,21 +646,6 @@ int usb_create_sysfs_dev_files(struct usb_device *udev)
 	if (retval)
 		goto error;
 
-	if (udev-&gt;manufacturer) {
-		retval = device_create_file(dev, &amp;dev_attr_manufacturer);
-		if (retval)
-			goto error;
-	}
-	if (udev-&gt;product) {
-		retval = device_create_file(dev, &amp;dev_attr_product);
-		if (retval)
-			goto error;
-	}
-	if (udev-&gt;serial) {
-		retval = device_create_file(dev, &amp;dev_attr_serial);
-		if (retval)
-			goto error;
-	}
 	retval = usb_create_ep_files(dev, &amp;udev-&gt;ep0, udev);
 	if (retval)
 		goto error;
@@ -636,13 +660,9 @@ void usb_remove_sysfs_dev_files(struct usb_device *udev)
 	struct device *dev = &amp;udev-&gt;dev;
 
 	usb_remove_ep_files(&amp;udev-&gt;ep0);
-	device_remove_file(dev, &amp;dev_attr_manufacturer);
-	device_remove_file(dev, &amp;dev_attr_product);
-	device_remove_file(dev, &amp;dev_attr_serial);
 	remove_power_attributes(dev);
 	remove_persist_attributes(dev);
 	device_remove_bin_file(dev, &amp;dev_bin_attr_descriptors);
-	sysfs_remove_group(&amp;dev-&gt;kobj, &amp;dev_attr_grp);
 }
 
 /* Interface Accociation Descriptor fields */
@@ -688,17 +708,15 @@ static ssize_t show_interface_string(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
 	struct usb_interface *intf;
-	struct usb_device *udev;
-	int len;
+	char *string;
 
 	intf = to_usb_interface(dev);
-	udev = interface_to_usbdev(intf);
-	len = snprintf(buf, 256, "%s", intf-&gt;cur_altsetting-&gt;string);
-	if (len &lt; 0)
+	string = intf-&gt;cur_altsetting-&gt;string;
+	barrier();		/* The altsetting might change! */
+
+	if (!string)
 		return 0;
-	buf[len] = '\n';
-	buf[len+1] = 0;
-	return len+1;
+	return sprintf(buf, "%s\n", string);
 }
 static DEVICE_ATTR(interface, S_IRUGO, show_interface_string, NULL);
 
@@ -727,18 +745,6 @@ static ssize_t show_modalias(struct device *dev,
 }
 static DEVICE_ATTR(modalias, S_IRUGO, show_modalias, NULL);
 
-static struct attribute *intf_assoc_attrs[] = {
-	&amp;dev_attr_iad_bFirstInterface.attr,
-	&amp;dev_attr_iad_bInterfaceCount.attr,
-	&amp;dev_attr_iad_bFunctionClass.attr,
-	&amp;dev_attr_iad_bFunctionSubClass.attr,
-	&amp;dev_attr_iad_bFunctionProtocol.attr,
-	NULL,
-};
-static struct attribute_group intf_assoc_attr_grp = {
-	.attrs = intf_assoc_attrs,
-};
-
 static struct attribute *intf_attrs[] = {
 	&amp;dev_attr_bInterfaceNumber.attr,
 	&amp;dev_attr_bAlternateSetting.attr,
@@ -753,6 +759,37 @@ static struct attribute_group intf_attr_grp = {
 	.attrs = intf_attrs,
 };
 
+static struct attribute *intf_assoc_attrs[] = {
+	&amp;dev_attr_iad_bFirstInterface.attr,
+	&amp;dev_attr_iad_bInterfaceCount.attr,
+	&amp;dev_attr_iad_bFunctionClass.attr,
+	&amp;dev_attr_iad_bFunctionSubClass.attr,
+	&amp;dev_attr_iad_bFunctionProtocol.attr,
+	NULL,
+};
+
+static mode_t intf_assoc_attrs_are_visible(struct kobject *kobj,
+		struct attribute *a, int n)
+{
+	struct usb_interface *intf = to_usb_interface(
+			container_of(kobj, struct device, kobj));
+
+	if (intf-&gt;intf_assoc == NULL)
+		return 0;
+	return a-&gt;mode;
+}
+
+static struct attribute_group intf_assoc_attr_grp = {
+	.attrs =	intf_assoc_attrs,
+	.is_visible =	intf_assoc_attrs_are_visible,
+};
+
+struct attribute_group *usb_interface_groups[] = {
+	&amp;intf_attr_grp,
+	&amp;intf_assoc_attr_grp,
+	NULL
+};
+
 static inline void usb_create_intf_ep_files(struct usb_interface *intf,
 		struct usb_device *udev)
 {
@@ -777,23 +814,21 @@ static inline void usb_remove_intf_ep_files(struct usb_interface *intf)
 
 int usb_create_sysfs_intf_files(struct usb_interface *intf)
 {
-	struct device *dev = &amp;intf-&gt;dev;
 	struct usb_device *udev = interface_to_usbdev(intf);
 	struct usb_host_interface *alt = intf-&gt;cur_altsetting;
 	int retval;
 
 	if (intf-&gt;sysfs_files_created)
 		return 0;
-	retval = sysfs_create_group(&amp;dev-&gt;kobj, &amp;intf_attr_grp);
-	if (retval)
-		return retval;
 
+	/* The interface string may be present in some altsettings
+	 * and missing in others.  Hence its attribute cannot be created
+	 * before the uevent is broadcast.
+	 */
 	if (alt-&gt;string == NULL)
 		alt-&gt;string = usb_cache_string(udev, alt-&gt;desc.iInterface);
 	if (alt-&gt;string)
-		retval = device_create_file(dev, &amp;dev_attr_interface);
-	if (intf-&gt;intf_assoc)
-		retval = sysfs_create_group(&amp;dev-&gt;kobj, &amp;intf_assoc_attr_grp);
+		retval = device_create_file(&amp;intf-&gt;dev, &amp;dev_attr_interface);
 	usb_create_intf_ep_files(intf, udev);
 	intf-&gt;sysfs_files_created = 1;
 	return 0;
@@ -807,7 +842,5 @@ void usb_remove_sysfs_intf_files(struct usb_interface *intf)
 		return;
 	usb_remove_intf_ep_files(intf);
 	device_remove_file(dev, &amp;dev_attr_interface);
-	sysfs_remove_group(&amp;dev-&gt;kobj, &amp;intf_attr_grp);
-	sysfs_remove_group(&amp;intf-&gt;dev.kobj, &amp;intf_assoc_attr_grp);
 	intf-&gt;sysfs_files_created = 0;
 }
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index 1f0db51190cc..325774375837 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -291,6 +291,7 @@ struct usb_device *usb_alloc_dev(struct usb_device *parent,
 	device_initialize(&amp;dev-&gt;dev);
 	dev-&gt;dev.bus = &amp;usb_bus_type;
 	dev-&gt;dev.type = &amp;usb_device_type;
+	dev-&gt;dev.groups = usb_device_groups;
 	dev-&gt;dev.dma_mask = bus-&gt;controller-&gt;dma_mask;
 	set_dev_node(&amp;dev-&gt;dev, dev_to_node(bus-&gt;controller));
 	dev-&gt;state = USB_STATE_ATTACHED;
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 1bf8ccb9c58d..1a8bc21c335e 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -130,6 +130,10 @@ static inline int is_active(const struct usb_interface *f)
 /* for labeling diagnostics */
 extern const char *usbcore_name;
 
+/* sysfs stuff */
+extern struct attribute_group *usb_device_groups[];
+extern struct attribute_group *usb_interface_groups[];
+
 /* usbfs stuff */
 extern struct mutex usbfs_mutex;
 extern struct usb_driver usbfs_driver;</pre><hr><pre>commit d8f12ab5d984761726e638a4222299a9fc516233
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Apr 22 10:49:15 2008 -0400

    USB: UHCI: disable remote wakeup when it's not needed
    
    This patch (as1084b) fixes the way uhci-hcd handles polling and
    remote wakeups for its root hubs.  When remote wakeup is disabled,
    neither interrupts nor polling should be enabled during a root-hub
    suspend.  Likewise, if interrupts are enabled during suspend then
    polling isn't needed.
    
    Furthermore the EGSM (Enter Global Suspend Mode) bit shouldn't be set
    in the Command register unless remote wakeup is enabled.  Apparently
    some controllers will issue a remote-wakeup interrupt whenever EGSM
    is on, even if Resume-Detect interrupts are supposedly disabled.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index d3e0d8aa3980..3a7bfe7a8874 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -234,7 +234,7 @@ static int resume_detect_interrupts_are_broken(struct uhci_hcd *uhci)
 	return 0;
 }
 
-static int remote_wakeup_is_broken(struct uhci_hcd *uhci)
+static int global_suspend_mode_is_broken(struct uhci_hcd *uhci)
 {
 	int port;
 	const char *sys_info;
@@ -261,27 +261,60 @@ __releases(uhci-&gt;lock)
 __acquires(uhci-&gt;lock)
 {
 	int auto_stop;
-	int int_enable, egsm_enable;
+	int int_enable, egsm_enable, wakeup_enable;
 	struct usb_device *rhdev = uhci_to_hcd(uhci)-&gt;self.root_hub;
 
 	auto_stop = (new_state == UHCI_RH_AUTO_STOPPED);
 	dev_dbg(&amp;rhdev-&gt;dev, "%s%s\n", __func__,
 			(auto_stop ? " (auto-stop)" : ""));
 
-	/* Enable resume-detect interrupts if they work.
-	 * Then enter Global Suspend mode if _it_ works, still configured.
+	/* Start off by assuming Resume-Detect interrupts and EGSM work
+	 * and that remote wakeups should be enabled.
 	 */
 	egsm_enable = USBCMD_EGSM;
-	uhci-&gt;working_RD = 1;
+	uhci-&gt;RD_enable = 1;
 	int_enable = USBINTR_RESUME;
-	if (remote_wakeup_is_broken(uhci))
-		egsm_enable = 0;
-	if (resume_detect_interrupts_are_broken(uhci) || !egsm_enable ||
+	wakeup_enable = 1;
+
+	/* In auto-stop mode wakeups must always be detected, but
+	 * Resume-Detect interrupts may be prohibited.  (In the absence
+	 * of CONFIG_PM, they are always disallowed.)
+	 */
+	if (auto_stop) {
+		if (!device_may_wakeup(&amp;rhdev-&gt;dev))
+			int_enable = 0;
+
+	/* In bus-suspend mode wakeups may be disabled, but if they are
+	 * allowed then so are Resume-Detect interrupts.
+	 */
+	} else {
 #ifdef CONFIG_PM
-			(!auto_stop &amp;&amp; !rhdev-&gt;do_remote_wakeup) ||
+		if (!rhdev-&gt;do_remote_wakeup)
+			wakeup_enable = 0;
 #endif
-			(auto_stop &amp;&amp; !device_may_wakeup(&amp;rhdev-&gt;dev)))
-		uhci-&gt;working_RD = int_enable = 0;
+	}
+
+	/* EGSM causes the root hub to echo a 'K' signal (resume) out any
+	 * port which requests a remote wakeup.  According to the USB spec,
+	 * every hub is supposed to do this.  But if we are ignoring
+	 * remote-wakeup requests anyway then there's no point to it.
+	 * We also shouldn't enable EGSM if it's broken.
+	 */
+	if (!wakeup_enable || global_suspend_mode_is_broken(uhci))
+		egsm_enable = 0;
+
+	/* If we're ignoring wakeup events then there's no reason to
+	 * enable Resume-Detect interrupts.  We also shouldn't enable
+	 * them if they are broken or disallowed.
+	 *
+	 * This logic may lead us to enabling RD but not EGSM.  The UHCI
+	 * spec foolishly says that RD works only when EGSM is on, but
+	 * there's no harm in enabling it anyway -- perhaps some chips
+	 * will implement it!
+	 */
+	if (!wakeup_enable || resume_detect_interrupts_are_broken(uhci) ||
+			!int_enable)
+		uhci-&gt;RD_enable = int_enable = 0;
 
 	outw(int_enable, uhci-&gt;io_addr + USBINTR);
 	outw(egsm_enable | USBCMD_CF, uhci-&gt;io_addr + USBCMD);
@@ -308,7 +341,11 @@ __acquires(uhci-&gt;lock)
 
 	uhci-&gt;rh_state = new_state;
 	uhci-&gt;is_stopped = UHCI_IS_STOPPED;
-	uhci_to_hcd(uhci)-&gt;poll_rh = !int_enable;
+
+	/* If interrupts don't work and remote wakeup is enabled then
+	 * the suspended root hub needs to be polled.
+	 */
+	uhci_to_hcd(uhci)-&gt;poll_rh = (!int_enable &amp;&amp; wakeup_enable);
 
 	uhci_scan_schedule(uhci);
 	uhci_fsbr_off(uhci);
@@ -344,9 +381,12 @@ __acquires(uhci-&gt;lock)
 	 * for 20 ms.
 	 */
 	if (uhci-&gt;rh_state == UHCI_RH_SUSPENDED) {
+		unsigned egsm;
+
+		/* Keep EGSM on if it was set before */
+		egsm = inw(uhci-&gt;io_addr + USBCMD) &amp; USBCMD_EGSM;
 		uhci-&gt;rh_state = UHCI_RH_RESUMING;
-		outw(USBCMD_FGR | USBCMD_EGSM | USBCMD_CF,
-				uhci-&gt;io_addr + USBCMD);
+		outw(USBCMD_FGR | USBCMD_CF | egsm, uhci-&gt;io_addr + USBCMD);
 		spin_unlock_irq(&amp;uhci-&gt;lock);
 		msleep(20);
 		spin_lock_irq(&amp;uhci-&gt;lock);
@@ -801,8 +841,10 @@ static int uhci_pci_resume(struct usb_hcd *hcd)
 
 	spin_unlock_irq(&amp;uhci-&gt;lock);
 
-	if (!uhci-&gt;working_RD) {
-		/* Suspended root hub needs to be polled */
+	/* If interrupts don't work and remote wakeup is enabled then
+	 * the suspended root hub needs to be polled.
+	 */
+	if (!uhci-&gt;RD_enable &amp;&amp; hcd-&gt;self.root_hub-&gt;do_remote_wakeup) {
 		hcd-&gt;poll_rh = 1;
 		usb_hcd_poll_rh_status(hcd);
 	}
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index 340d6ed3e6e9..7d01c5677f92 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -400,8 +400,9 @@ struct uhci_hcd {
 	unsigned int scan_in_progress:1;	/* Schedule scan is running */
 	unsigned int need_rescan:1;		/* Redo the schedule scan */
 	unsigned int dead:1;			/* Controller has died */
-	unsigned int working_RD:1;		/* Suspended root hub doesn't
-						   need to be polled */
+	unsigned int RD_enable:1;		/* Suspended root hub with
+						   Resume-Detect interrupts
+						   enabled */
 	unsigned int is_initialized:1;		/* Data structure is usable */
 	unsigned int fsbr_is_on:1;		/* FSBR is turned on */
 	unsigned int fsbr_is_wanted:1;		/* Does any URB want FSBR? */</pre>
    <div class="pagination">
        <a href='2_91.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><span>[92]</span><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_93.html'>Next&gt;&gt;</a>
    <div>
</body>
