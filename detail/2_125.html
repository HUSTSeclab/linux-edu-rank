<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_124.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><span>[125]</span><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_126.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 79efa097e75018a2918155f343f0e08e61ee8a8c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jun 1 13:33:42 2006 -0400

    [PATCH] usbcore: port reset for composite devices
    
    This patch (as699) adds usb_reset_composite_device(), a routine for
    sending a USB port reset to a device with multiple interfaces owned by
    different drivers.  Drivers are notified about impending and completed
    resets through two new methods in the usb_driver structure.
    
    The patch modifieds the usbfs ioctl code to make it use the new routine
    instead of usb_reset_device().  Follow-up patches will modify the hub,
    usb-storage, and usbhid drivers so they can utilize this new API.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index b04ede772f2c..df3fb57d71e6 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -823,8 +823,7 @@ static int proc_connectinfo(struct dev_state *ps, void __user *arg)
 
 static int proc_resetdevice(struct dev_state *ps)
 {
-	return usb_reset_device(ps-&gt;dev);
-
+	return usb_reset_composite_device(ps-&gt;dev, NULL);
 }
 
 static int proc_setintf(struct dev_state *ps, void __user *arg)
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index f41c08946a52..37c67d7e8b84 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -3007,9 +3007,9 @@ static int config_descriptors_changed(struct usb_device *udev)
  * usb_reset_device - perform a USB port reset to reinitialize a device
  * @udev: device to reset (not in SUSPENDED or NOTATTACHED state)
  *
- * WARNING - don't reset any device unless drivers for all of its
- * interfaces are expecting that reset!  Maybe some driver-&gt;reset()
- * method should eventually help ensure sufficient cooperation.
+ * WARNING - don't use this routine to reset a composite device
+ * (one with multiple interfaces owned by separate drivers)!
+ * Use usb_reset_composite_device() instead.
  *
  * Do a port reset, reassign the device's address, and establish its
  * former operating configuration.  If the reset fails, or the device's
@@ -3125,3 +3125,81 @@ int usb_reset_device(struct usb_device *udev)
 	hub_port_logical_disconnect(parent_hub, port1);
 	return -ENODEV;
 }
+
+/**
+ * usb_reset_composite_device - warn interface drivers and perform a USB port reset
+ * @udev: device to reset (not in SUSPENDED or NOTATTACHED state)
+ * @iface: interface bound to the driver making the request (optional)
+ *
+ * Warns all drivers bound to registered interfaces (using their pre_reset
+ * method), performs the port reset, and then lets the drivers know that
+ * the reset is over (using their post_reset method).
+ *
+ * Return value is the same as for usb_reset_device().
+ *
+ * The caller must own the device lock.  For example, it's safe to use
+ * this from a driver probe() routine after downloading new firmware.
+ * For calls that might not occur during probe(), drivers should lock
+ * the device using usb_lock_device_for_reset().
+ *
+ * The interface locks are acquired during the pre_reset stage and released
+ * during the post_reset stage.  However if iface is not NULL and is
+ * currently being probed, we assume that the caller already owns its
+ * lock.
+ */
+int usb_reset_composite_device(struct usb_device *udev,
+		struct usb_interface *iface)
+{
+	int ret;
+	struct usb_host_config *config = udev-&gt;actconfig;
+
+	if (udev-&gt;state == USB_STATE_NOTATTACHED ||
+			udev-&gt;state == USB_STATE_SUSPENDED) {
+		dev_dbg(&amp;udev-&gt;dev, "device reset not allowed in state %d\n",
+				udev-&gt;state);
+		return -EINVAL;
+	}
+
+	if (iface &amp;&amp; iface-&gt;condition != USB_INTERFACE_BINDING)
+		iface = NULL;
+
+	if (config) {
+		int i;
+		struct usb_interface *cintf;
+		struct usb_driver *drv;
+
+		for (i = 0; i &lt; config-&gt;desc.bNumInterfaces; ++i) {
+			cintf = config-&gt;interface[i];
+			if (cintf != iface)
+				down(&amp;cintf-&gt;dev.sem);
+			if (device_is_registered(&amp;cintf-&gt;dev) &amp;&amp;
+					cintf-&gt;dev.driver) {
+				drv = to_usb_driver(cintf-&gt;dev.driver);
+				if (drv-&gt;pre_reset)
+					(drv-&gt;pre_reset)(cintf);
+			}
+		}
+	}
+
+	ret = usb_reset_device(udev);
+
+	if (config) {
+		int i;
+		struct usb_interface *cintf;
+		struct usb_driver *drv;
+
+		for (i = config-&gt;desc.bNumInterfaces - 1; i &gt;= 0; --i) {
+			cintf = config-&gt;interface[i];
+			if (device_is_registered(&amp;cintf-&gt;dev) &amp;&amp;
+					cintf-&gt;dev.driver) {
+				drv = to_usb_driver(cintf-&gt;dev.driver);
+				if (drv-&gt;post_reset)
+					(drv-&gt;post_reset)(cintf);
+			}
+			if (cintf != iface)
+				up(&amp;cintf-&gt;dev.sem);
+		}
+	}
+
+	return ret;
+}
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index b7fdc1cd134a..515310751303 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -1207,6 +1207,7 @@ EXPORT_SYMBOL(usb_ifnum_to_if);
 EXPORT_SYMBOL(usb_altnum_to_altsetting);
 
 EXPORT_SYMBOL(usb_reset_device);
+EXPORT_SYMBOL(usb_reset_composite_device);
 
 EXPORT_SYMBOL(__usb_get_extra_descriptor);
 
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 317ec9f28bce..5ad30cefe7b2 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -386,6 +386,8 @@ extern int usb_lock_device_for_reset(struct usb_device *udev,
 
 /* USB port reset for device reinitialization */
 extern int usb_reset_device(struct usb_device *dev);
+extern int usb_reset_composite_device(struct usb_device *dev,
+		struct usb_interface *iface);
 
 extern struct usb_device *usb_find_device(u16 vendor_id, u16 product_id);
 
@@ -554,6 +556,10 @@ struct usb_dynids {
  *	do (or don't) show up otherwise in the filesystem.
  * @suspend: Called when the device is going to be suspended by the system.
  * @resume: Called when the device is being resumed by the system.
+ * @pre_reset: Called by usb_reset_composite_device() when the device
+ *	is about to be reset.
+ * @post_reset: Called by usb_reset_composite_device() after the device
+ *	has been reset.
  * @id_table: USB drivers use ID table to support hotplugging.
  *	Export this with MODULE_DEVICE_TABLE(usb,...).  This must be set
  *	or your driver's probe function will never get called.
@@ -592,6 +598,9 @@ struct usb_driver {
 	int (*suspend) (struct usb_interface *intf, pm_message_t message);
 	int (*resume) (struct usb_interface *intf);
 
+	void (*pre_reset) (struct usb_interface *intf);
+	void (*post_reset) (struct usb_interface *intf);
+
 	const struct usb_device_id *id_table;
 
 	struct usb_dynids dynids;</pre><hr><pre>commit 633a7ecf89587879161179ac4f5a03722626866f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 30 10:21:14 2006 -0400

    [PATCH] usbhid: Remove unneeded blacklist entries
    
    Now that usbhid automatically applies HID_QUIRK_NOGET to keyboards and
    mice, we no longer need the blacklist entries that were present for no
    other purpose.  This patch (as698) removes them.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Vojtech Pavlik &lt;vojtech@suse.cz&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/input/hid-core.c b/drivers/usb/input/hid-core.c
index 061002fc66fc..c6051beeabdc 100644
--- a/drivers/usb/input/hid-core.c
+++ b/drivers/usb/input/hid-core.c
@@ -1374,9 +1374,6 @@ void hid_close(struct hid_device *hid)
 
 #define USB_VENDOR_ID_PANJIT		0x134c
 
-#define USB_VENDOR_ID_SILVERCREST	0x062a
-#define USB_DEVICE_ID_SILVERCREST_KB	0x0201
-
 /*
  * Initialize all reports
  */
@@ -1461,9 +1458,6 @@ void hid_init_reports(struct hid_device *hid)
 #define USB_VENDOR_ID_ONTRAK		0x0a07
 #define USB_DEVICE_ID_ONTRAK_ADU100	0x0064
 
-#define USB_VENDOR_ID_TANGTOP		0x0d3d
-#define USB_DEVICE_ID_TANGTOP_USBPS2	0x0001
-
 #define USB_VENDOR_ID_ESSENTIAL_REALITY	0x0d7f
 #define USB_DEVICE_ID_ESSENTIAL_REALITY_P5 0x0100
 
@@ -1520,12 +1514,6 @@ void hid_init_reports(struct hid_device *hid)
 #define USB_DEVICE_ID_MCC_PMD1024LS	0x0076
 #define USB_DEVICE_ID_MCC_PMD1208LS	0x007a
 
-#define USB_VENDOR_ID_CHICONY		0x04f2
-#define USB_DEVICE_ID_CHICONY_USBHUB_KB	0x0100
-
-#define USB_VENDOR_ID_BTC		0x046e
-#define USB_DEVICE_ID_BTC_KEYBOARD	0x5303
-
 #define USB_VENDOR_ID_VERNIER		0x08f7
 #define USB_DEVICE_ID_VERNIER_LABPRO	0x0001
 #define USB_DEVICE_ID_VERNIER_GOTEMP	0x0002
@@ -1554,15 +1542,6 @@ void hid_init_reports(struct hid_device *hid)
 #define USB_VENDOR_ID_CHERRY		0x046a
 #define USB_DEVICE_ID_CHERRY_CYMOTION	0x0023
 
-#define USB_VENDOR_ID_HP		0x03f0
-#define USB_DEVICE_ID_HP_USBHUB_KB	0x020c
-
-#define USB_VENDOR_ID_IBM		0x04b3
-#define USB_DEVICE_ID_IBM_USBHUB_KB	0x3005
-
-#define USB_VENDOR_ID_CREATIVELABS	0x062a
-#define USB_DEVICE_ID_CREATIVELABS_SILVERCREST	0x0201
-
 #define USB_VENDOR_ID_YEALINK		0x6993
 #define USB_DEVICE_ID_YEALINK_P1K_P4K_B2K	0xb001
 /*
@@ -1683,14 +1662,7 @@ static const struct hid_blacklist {
 	{ USB_VENDOR_ID_ATEN, USB_DEVICE_ID_ATEN_2PORTKVM, HID_QUIRK_NOGET },
 	{ USB_VENDOR_ID_ATEN, USB_DEVICE_ID_ATEN_4PORTKVM, HID_QUIRK_NOGET },
 	{ USB_VENDOR_ID_ATEN, USB_DEVICE_ID_ATEN_4PORTKVMC, HID_QUIRK_NOGET },
-	{ USB_VENDOR_ID_BTC, USB_DEVICE_ID_BTC_KEYBOARD, HID_QUIRK_NOGET},
-	{ USB_VENDOR_ID_CHICONY, USB_DEVICE_ID_CHICONY_USBHUB_KB, HID_QUIRK_NOGET},
-	{ USB_VENDOR_ID_CREATIVELABS, USB_DEVICE_ID_CREATIVELABS_SILVERCREST, HID_QUIRK_NOGET },
-	{ USB_VENDOR_ID_HP, USB_DEVICE_ID_HP_USBHUB_KB, HID_QUIRK_NOGET },
-	{ USB_VENDOR_ID_IBM, USB_DEVICE_ID_IBM_USBHUB_KB, HID_QUIRK_NOGET },
-	{ USB_VENDOR_ID_TANGTOP, USB_DEVICE_ID_TANGTOP_USBPS2, HID_QUIRK_NOGET },
 	{ USB_VENDOR_ID_WISEGROUP, USB_DEVICE_ID_DUAL_USB_JOYPAD, HID_QUIRK_NOGET | HID_QUIRK_MULTI_INPUT },
-	{ USB_VENDOR_ID_SILVERCREST, USB_DEVICE_ID_SILVERCREST_KB, HID_QUIRK_NOGET },
 
 	{ USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_MIGHTYMOUSE, HID_QUIRK_MIGHTYMOUSE | HID_QUIRK_INVERT_HWHEEL },
 	{ USB_VENDOR_ID_A4TECH, USB_DEVICE_ID_A4TECH_WCP32PU, HID_QUIRK_2WHEEL_MOUSE_HACK_7 },</pre><hr><pre>commit 9da2150f59e885d88b9eabe0a677f0fa4962f7b4
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon May 22 16:47:13 2006 -0400

    [PATCH] usbtest: report errors in iso tests
    
    This patch (as693b) makes the usbtest driver report errors in the
    isochronous bulk transfer tests instead of always returning 0.  As an
    arbitrary cutoff, an error is returned if more than 10% of the packet
    transfers fail.  It also stops a test immediately upon receiving an URB
    submission error.
    
    For a test harness, it's especially important to report when errors occur!
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index b42ae6bfb12b..81ba14c73dc7 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -1337,7 +1337,9 @@ struct iso_context {
 	unsigned		pending;
 	spinlock_t		lock;
 	struct completion	done;
+	int			submit_error;
 	unsigned long		errors;
+	unsigned long		packet_count;
 	struct usbtest_dev	*dev;
 };
 
@@ -1348,10 +1350,14 @@ static void iso_callback (struct urb *urb, struct pt_regs *regs)
 	spin_lock(&amp;ctx-&gt;lock);
 	ctx-&gt;count--;
 
+	ctx-&gt;packet_count += urb-&gt;number_of_packets;
 	if (urb-&gt;error_count &gt; 0)
 		ctx-&gt;errors += urb-&gt;error_count;
+	else if (urb-&gt;status != 0)
+		ctx-&gt;errors += urb-&gt;number_of_packets;
 
-	if (urb-&gt;status == 0 &amp;&amp; ctx-&gt;count &gt; (ctx-&gt;pending - 1)) {
+	if (urb-&gt;status == 0 &amp;&amp; ctx-&gt;count &gt; (ctx-&gt;pending - 1)
+			&amp;&amp; !ctx-&gt;submit_error) {
 		int status = usb_submit_urb (urb, GFP_ATOMIC);
 		switch (status) {
 		case 0:
@@ -1362,6 +1368,8 @@ static void iso_callback (struct urb *urb, struct pt_regs *regs)
 					status);
 			/* FALLTHROUGH */
 		case -ENODEV:			/* disconnected */
+		case -ESHUTDOWN:		/* endpoint disabled */
+			ctx-&gt;submit_error = 1;
 			break;
 		}
 	}
@@ -1371,8 +1379,8 @@ static void iso_callback (struct urb *urb, struct pt_regs *regs)
 	if (ctx-&gt;pending == 0) {
 		if (ctx-&gt;errors)
 			dev_dbg (&amp;ctx-&gt;dev-&gt;intf-&gt;dev,
-				"iso test, %lu errors\n",
-				ctx-&gt;errors);
+				"iso test, %lu errors out of %lu\n",
+				ctx-&gt;errors, ctx-&gt;packet_count);
 		complete (&amp;ctx-&gt;done);
 	}
 done:
@@ -1433,15 +1441,14 @@ test_iso_queue (struct usbtest_dev *dev, struct usbtest_param *param,
 	struct usb_device	*udev;
 	unsigned		i;
 	unsigned long		packets = 0;
-	int			status;
+	int			status = 0;
 	struct urb		*urbs[10];	/* FIXME no limit */
 
 	if (param-&gt;sglen &gt; 10)
 		return -EDOM;
 
+	memset(&amp;context, 0, sizeof context);
 	context.count = param-&gt;iterations * param-&gt;sglen;
-	context.pending = param-&gt;sglen;
-	context.errors = 0;
 	context.dev = dev;
 	init_completion (&amp;context.done);
 	spin_lock_init (&amp;context.lock);
@@ -1473,6 +1480,7 @@ test_iso_queue (struct usbtest_dev *dev, struct usbtest_param *param,
 
 	spin_lock_irq (&amp;context.lock);
 	for (i = 0; i &lt; param-&gt;sglen; i++) {
+		++context.pending;
 		status = usb_submit_urb (urbs [i], SLAB_ATOMIC);
 		if (status &lt; 0) {
 			ERROR (dev, "submit iso[%d], error %d\n", i, status);
@@ -1483,12 +1491,26 @@ test_iso_queue (struct usbtest_dev *dev, struct usbtest_param *param,
 
 			simple_free_urb (urbs [i]);
 			context.pending--;
+			context.submit_error = 1;
+			break;
 		}
 	}
 	spin_unlock_irq (&amp;context.lock);
 
 	wait_for_completion (&amp;context.done);
-	return 0;
+
+	/*
+	 * Isochronous transfers are expected to fail sometimes.  As an
+	 * arbitrary limit, we will report an error if any submissions
+	 * fail or if the transfer failure rate is &gt; 10%.
+	 */
+	if (status != 0)
+		;
+	else if (context.submit_error)
+		status = -EACCES;
+	else if (context.errors &gt; context.packet_count / 10)
+		status = -EIO;
+	return status;
 
 fail:
 	for (i = 0; i &lt; param-&gt;sglen; i++) {</pre><hr><pre>commit 0ae4ea8092e1277cfca07cade7eaba5f594076c1
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon May 22 12:27:38 2006 -0400

    [PATCH] gadgetfs: fix memory leaks
    
    This patch (as692) fixes a few memory leaks in some unimportant error
    pathways of the gadgetfs driver.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: David Brownell &lt;david-b@pacbell.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/inode.c b/drivers/usb/gadget/inode.c
index 57bf24810f9b..aef0722b8f17 100644
--- a/drivers/usb/gadget/inode.c
+++ b/drivers/usb/gadget/inode.c
@@ -1038,7 +1038,7 @@ ep0_read (struct file *fd, char __user *buf, size_t len, loff_t *ptr)
 		/* ep0 can't deliver events when STATE_SETUP */
 		for (i = 0; i &lt; n; i++) {
 			if (dev-&gt;event [i].type == GADGETFS_SETUP) {
-				len = n = i + 1;
+				len = i + 1;
 				len *= sizeof (struct usb_gadgetfs_event);
 				n = 0;
 				break;
@@ -1586,13 +1586,13 @@ gadgetfs_create_file (struct super_block *sb, char const *name,
 static int activate_ep_files (struct dev_data *dev)
 {
 	struct usb_ep	*ep;
+	struct ep_data	*data;
 
 	gadget_for_each_ep (ep, dev-&gt;gadget) {
-		struct ep_data	*data;
 
 		data = kzalloc(sizeof(*data), GFP_KERNEL);
 		if (!data)
-			goto enomem;
+			goto enomem0;
 		data-&gt;state = STATE_EP_DISABLED;
 		init_MUTEX (&amp;data-&gt;lock);
 		init_waitqueue_head (&amp;data-&gt;wait);
@@ -1607,21 +1607,23 @@ static int activate_ep_files (struct dev_data *dev)
 
 		data-&gt;req = usb_ep_alloc_request (ep, GFP_KERNEL);
 		if (!data-&gt;req)
-			goto enomem;
+			goto enomem1;
 
 		data-&gt;inode = gadgetfs_create_file (dev-&gt;sb, data-&gt;name,
 				data, &amp;ep_config_operations,
 				&amp;data-&gt;dentry);
-		if (!data-&gt;inode) {
-			usb_ep_free_request(ep, data-&gt;req);
-			kfree (data);
-			goto enomem;
-		}
+		if (!data-&gt;inode)
+			goto enomem2;
 		list_add_tail (&amp;data-&gt;epfiles, &amp;dev-&gt;epfiles);
 	}
 	return 0;
 
-enomem:
+enomem2:
+	usb_ep_free_request (ep, data-&gt;req);
+enomem1:
+	put_dev (dev);
+	kfree (data);
+enomem0:
 	DBG (dev, "%s enomem\n", __FUNCTION__);
 	destroy_ep_files (dev);
 	return -ENOMEM;
@@ -1792,7 +1794,7 @@ static struct usb_gadget_driver probe_driver = {
  *
  * After initialization, the device stays active for as long as that
  * $CHIP file is open.  Events may then be read from that descriptor,
- * such configuration notifications.  More complex drivers will handle
+ * such as configuration notifications.  More complex drivers will handle
  * some control requests in user space.
  */
 
@@ -2032,12 +2034,10 @@ gadgetfs_fill_super (struct super_block *sb, void *opts, int silent)
 			NULL, &amp;simple_dir_operations,
 			S_IFDIR | S_IRUGO | S_IXUGO);
 	if (!inode)
-		return -ENOMEM;
+		goto enomem0;
 	inode-&gt;i_op = &amp;simple_dir_inode_operations;
-	if (!(d = d_alloc_root (inode))) {
-		iput (inode);
-		return -ENOMEM;
-	}
+	if (!(d = d_alloc_root (inode)))
+		goto enomem1;
 	sb-&gt;s_root = d;
 
 	/* the ep0 file is named after the controller we expect;
@@ -2045,21 +2045,28 @@ gadgetfs_fill_super (struct super_block *sb, void *opts, int silent)
 	 */
 	dev = dev_new ();
 	if (!dev)
-		return -ENOMEM;
+		goto enomem2;
 
 	dev-&gt;sb = sb;
-	if (!(inode = gadgetfs_create_file (sb, CHIP,
+	if (!gadgetfs_create_file (sb, CHIP,
 				dev, &amp;dev_init_operations,
-				&amp;dev-&gt;dentry))) {
-		put_dev(dev);
-		return -ENOMEM;
-	}
+				&amp;dev-&gt;dentry))
+		goto enomem3;
 
 	/* other endpoint files are available after hardware setup,
 	 * from binding to a controller.
 	 */
 	the_device = dev;
 	return 0;
+
+enomem3:
+	put_dev (dev);
+enomem2:
+	dput (d);
+enomem1:
+	iput (inode);
+enomem0:
+	return -ENOMEM;
 }
 
 /* "mount -t gadgetfs path /dev/gadget" ends up here */</pre><hr><pre>commit 83196b52053068f0240371ad2efd9d6ad685bbeb
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon May 22 12:26:31 2006 -0400

    [PATCH] gadgetfs: fix AIO interface bugs
    
    This patch (as691) fixes a few errors in the AIO interface for the
    gadgetfs driver.  Now requests will complete properly instead of hanging.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/inode.c b/drivers/usb/gadget/inode.c
index 0eb010a3f5bc..57bf24810f9b 100644
--- a/drivers/usb/gadget/inode.c
+++ b/drivers/usb/gadget/inode.c
@@ -528,7 +528,7 @@ struct kiocb_priv {
 	struct usb_request	*req;
 	struct ep_data		*epdata;
 	void			*buf;
-	char __user		*ubuf;
+	char __user		*ubuf;		/* NULL for writes */
 	unsigned		actual;
 };
 
@@ -566,7 +566,6 @@ static ssize_t ep_aio_read_retry(struct kiocb *iocb)
 		status = priv-&gt;actual;
 	kfree(priv-&gt;buf);
 	kfree(priv);
-	aio_put_req(iocb);
 	return status;
 }
 
@@ -580,8 +579,8 @@ static void ep_aio_complete(struct usb_ep *ep, struct usb_request *req)
 	spin_lock(&amp;epdata-&gt;dev-&gt;lock);
 	priv-&gt;req = NULL;
 	priv-&gt;epdata = NULL;
-	if (NULL == iocb-&gt;ki_retry
-			|| unlikely(0 == req-&gt;actual)
+	if (priv-&gt;ubuf == NULL
+			|| unlikely(req-&gt;actual == 0)
 			|| unlikely(kiocbIsCancelled(iocb))) {
 		kfree(req-&gt;buf);
 		kfree(priv);
@@ -618,7 +617,7 @@ ep_aio_rwtail(
 	char __user	*ubuf
 )
 {
-	struct kiocb_priv	*priv = (void *) &amp;iocb-&gt;private;
+	struct kiocb_priv	*priv;
 	struct usb_request	*req;
 	ssize_t			value;
 
@@ -670,7 +669,7 @@ ep_aio_rwtail(
 		kfree(priv);
 		put_ep(epdata);
 	} else
-		value = -EIOCBQUEUED;
+		value = (ubuf ? -EIOCBRETRY : -EIOCBQUEUED);
 	return value;
 }
 </pre><hr><pre>commit c8155cc5d839838f8425dbea568fc537337176a7
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 19 16:52:35 2006 -0400

    [PATCH] UHCI: remove ISO TDs as they are used
    
    This patch (as690) does the same thing for ISO TDs as as680 did for
    non-ISO TDs: free them as they are used rather than all at once when an
    URB is complete.  At the same time it fixes a minor buglet (I'm not
    aware of it ever affecting anyone): An ISO TD should be retired when its
    frame is over, regardless of whether or not the hardware has marked it
    inactive.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-debug.c b/drivers/usb/host/uhci-debug.c
index ab8ba8220ad1..6637a0e49978 100644
--- a/drivers/usb/host/uhci-debug.c
+++ b/drivers/usb/host/uhci-debug.c
@@ -127,7 +127,8 @@ static int uhci_show_urbp(struct urb_priv *urbp, char *buf, int len, int space)
 
 	i = nactive = ninactive = 0;
 	list_for_each_entry(td, &amp;urbp-&gt;td_list, list) {
-		if (++i &lt;= 10 || debug &gt; 2) {
+		if (urbp-&gt;qh-&gt;type != USB_ENDPOINT_XFER_ISOC &amp;&amp;
+				(++i &lt;= 10 || debug &gt; 2)) {
 			out += sprintf(out, "%*s%d: ", space + 2, "", i);
 			out += uhci_show_td(td, out, len - (out - buf), 0);
 		} else {
@@ -168,8 +169,9 @@ static int uhci_show_qh(struct uhci_qh *qh, char *buf, int len, int space)
 			space, "", qh, qtype,
 			le32_to_cpu(qh-&gt;link), le32_to_cpu(element));
 	if (qh-&gt;type == USB_ENDPOINT_XFER_ISOC)
-		out += sprintf(out, "%*s    period %d\n",
-				space, "", qh-&gt;period);
+		out += sprintf(out, "%*s    period %d frame %x desc [%p]\n",
+				space, "", qh-&gt;period, qh-&gt;iso_frame,
+				qh-&gt;iso_packet_desc);
 
 	if (element &amp; UHCI_PTR_QH)
 		out += sprintf(out, "%*s  Element points to QH (bug?)\n", space, "");
@@ -331,8 +333,10 @@ static int uhci_show_status(struct uhci_hcd *uhci, char *buf, int len)
 	out += sprintf(out, "  sof       =       %02x\n", sof);
 	out += uhci_show_sc(1, portsc1, out, len - (out - buf));
 	out += uhci_show_sc(2, portsc2, out, len - (out - buf));
-	out += sprintf(out, "Most recent frame: %x\n",
-			uhci-&gt;frame_number);
+	out += sprintf(out, "Most recent frame: %x (%d)   "
+			"Last ISO frame: %x (%d)\n",
+			uhci-&gt;frame_number, uhci-&gt;frame_number &amp; 1023,
+			uhci-&gt;last_iso_frame, uhci-&gt;last_iso_frame &amp; 1023);
 
 	return out - buf;
 }
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index eaac6ddf03a0..469b4268b850 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -128,8 +128,6 @@ struct uhci_qh {
 	__le32 element;			/* Queue element (TD) pointer */
 
 	/* Software fields */
-	dma_addr_t dma_handle;
-
 	struct list_head node;		/* Node in the list of QHs */
 	struct usb_host_endpoint *hep;	/* Endpoint information */
 	struct usb_device *udev;
@@ -138,13 +136,19 @@ struct uhci_qh {
 	struct uhci_td *dummy_td;	/* Dummy TD to end the queue */
 	struct uhci_td *post_td;	/* Last TD completed */
 
+	struct usb_iso_packet_descriptor *iso_packet_desc;
+					/* Next urb-&gt;iso_frame_desc entry */
 	unsigned long advance_jiffies;	/* Time of last queue advance */
 	unsigned int unlink_frame;	/* When the QH was unlinked */
 	unsigned int period;		/* For Interrupt and Isochronous QHs */
+	unsigned int iso_frame;		/* Frame # for iso_packet_desc */
+	int iso_status;			/* Status for Isochronous URBs */
 
 	int state;			/* QH_STATE_xxx; see above */
 	int type;			/* Queue type (control, bulk, etc) */
 
+	dma_addr_t dma_handle;
+
 	unsigned int initial_toggle:1;	/* Endpoint's current toggle value */
 	unsigned int needs_fixup:1;	/* Must fix the TD toggle values */
 	unsigned int is_stopped:1;	/* Queue was stopped by error/unlink */
@@ -386,6 +390,8 @@ struct uhci_hcd {
 	unsigned int frame_number;		/* As of last check */
 	unsigned int is_stopped;
 #define UHCI_IS_STOPPED		9999		/* Larger than a frame # */
+	unsigned int last_iso_frame;		/* Frame of last scan */
+	unsigned int cur_iso_frame;		/* Frame for current scan */
 
 	unsigned int scan_in_progress:1;	/* Schedule scan is running */
 	unsigned int need_rescan:1;		/* Redo the schedule scan */
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 7acc23473c63..cbbaa4c1740f 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -184,6 +184,24 @@ static inline void uhci_remove_td_from_frame_list(struct uhci_hcd *uhci,
 	td-&gt;frame = -1;
 }
 
+static inline void uhci_remove_tds_from_frame(struct uhci_hcd *uhci,
+		unsigned int framenum)
+{
+	struct uhci_td *ftd, *ltd;
+
+	framenum &amp;= (UHCI_NUMFRAMES - 1);
+
+	ftd = uhci-&gt;frame_cpu[framenum];
+	if (ftd) {
+		ltd = list_entry(ftd-&gt;fl_list.prev, struct uhci_td, fl_list);
+		uhci-&gt;frame[framenum] = ltd-&gt;link;
+		uhci-&gt;frame_cpu[framenum] = NULL;
+
+		while (!list_empty(&amp;ftd-&gt;fl_list))
+			list_del_init(ftd-&gt;fl_list.prev);
+	}
+}
+
 /*
  * Remove all the TDs for an Isochronous URB from the frame list
  */
@@ -523,7 +541,6 @@ static int uhci_map_status(int status, int dir_out)
 		return -ENOSR;
 	if (status &amp; TD_CTRL_STALLED)			/* Stalled */
 		return -EPIPE;
-	WARN_ON(status &amp; TD_CTRL_ACTIVE);		/* Active */
 	return 0;
 }
 
@@ -960,12 +977,12 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb,
 		return -EFBIG;
 
 	/* Check the period and figure out the starting frame number */
-	uhci_get_current_frame_number(uhci);
 	if (qh-&gt;period == 0) {
 		if (urb-&gt;transfer_flags &amp; URB_ISO_ASAP) {
+			uhci_get_current_frame_number(uhci);
 			urb-&gt;start_frame = uhci-&gt;frame_number + 10;
 		} else {
-			i = urb-&gt;start_frame - uhci-&gt;frame_number;
+			i = urb-&gt;start_frame - uhci-&gt;last_iso_frame;
 			if (i &lt;= 0 || i &gt;= UHCI_NUMFRAMES)
 				return -EINVAL;
 		}
@@ -974,7 +991,7 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb,
 
 	} else {	/* Pick up where the last URB leaves off */
 		if (list_empty(&amp;qh-&gt;queue)) {
-			frame = uhci-&gt;frame_number + 10;
+			frame = qh-&gt;iso_frame;
 		} else {
 			struct urb *lurb;
 
@@ -986,11 +1003,12 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb,
 		}
 		if (urb-&gt;transfer_flags &amp; URB_ISO_ASAP)
 			urb-&gt;start_frame = frame;
-		/* FIXME: Sanity check */
+		else if (urb-&gt;start_frame != frame)
+			return -EINVAL;
 	}
 
 	/* Make sure we won't have to go too far into the future */
-	if (uhci_frame_before_eq(uhci-&gt;frame_number + UHCI_NUMFRAMES,
+	if (uhci_frame_before_eq(uhci-&gt;last_iso_frame + UHCI_NUMFRAMES,
 			urb-&gt;start_frame + urb-&gt;number_of_packets *
 				urb-&gt;interval))
 		return -EFBIG;
@@ -1020,7 +1038,13 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb,
 	frame = urb-&gt;start_frame;
 	list_for_each_entry(td, &amp;urbp-&gt;td_list, list) {
 		uhci_insert_td_in_frame_list(uhci, td, frame);
-		frame += urb-&gt;interval;
+		frame += qh-&gt;period;
+	}
+
+	if (list_empty(&amp;qh-&gt;queue)) {
+		qh-&gt;iso_packet_desc = &amp;urb-&gt;iso_frame_desc[0];
+		qh-&gt;iso_frame = urb-&gt;start_frame;
+		qh-&gt;iso_status = 0;
 	}
 
 	return 0;
@@ -1028,37 +1052,44 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb,
 
 static int uhci_result_isochronous(struct uhci_hcd *uhci, struct urb *urb)
 {
-	struct uhci_td *td;
-	struct urb_priv *urbp = (struct urb_priv *)urb-&gt;hcpriv;
-	int status;
-	int i, ret = 0;
-
-	urb-&gt;actual_length = urb-&gt;error_count = 0;
+	struct uhci_td *td, *tmp;
+	struct urb_priv *urbp = urb-&gt;hcpriv;
+	struct uhci_qh *qh = urbp-&gt;qh;
 
-	i = 0;
-	list_for_each_entry(td, &amp;urbp-&gt;td_list, list) {
+	list_for_each_entry_safe(td, tmp, &amp;urbp-&gt;td_list, list) {
+		unsigned int ctrlstat;
+		int status;
 		int actlength;
-		unsigned int ctrlstat = td_status(td);
 
-		if (ctrlstat &amp; TD_CTRL_ACTIVE)
+		if (uhci_frame_before_eq(uhci-&gt;cur_iso_frame, qh-&gt;iso_frame))
 			return -EINPROGRESS;
 
-		actlength = uhci_actual_length(ctrlstat);
-		urb-&gt;iso_frame_desc[i].actual_length = actlength;
-		urb-&gt;actual_length += actlength;
+		uhci_remove_tds_from_frame(uhci, qh-&gt;iso_frame);
+
+		ctrlstat = td_status(td);
+		if (ctrlstat &amp; TD_CTRL_ACTIVE) {
+			status = -EXDEV;	/* TD was added too late? */
+		} else {
+			status = uhci_map_status(uhci_status_bits(ctrlstat),
+					usb_pipeout(urb-&gt;pipe));
+			actlength = uhci_actual_length(ctrlstat);
+
+			urb-&gt;actual_length += actlength;
+			qh-&gt;iso_packet_desc-&gt;actual_length = actlength;
+			qh-&gt;iso_packet_desc-&gt;status = status;
+		}
 
-		status = uhci_map_status(uhci_status_bits(ctrlstat),
-				usb_pipeout(urb-&gt;pipe));
-		urb-&gt;iso_frame_desc[i].status = status;
 		if (status) {
 			urb-&gt;error_count++;
-			ret = status;
+			qh-&gt;iso_status = status;
 		}
 
-		i++;
+		uhci_remove_td_from_urbp(td);
+		uhci_free_td(uhci, td);
+		qh-&gt;iso_frame += qh-&gt;period;
+		++qh-&gt;iso_packet_desc;
 	}
-
-	return ret;
+	return qh-&gt;iso_status;
 }
 
 static int uhci_urb_enqueue(struct usb_hcd *hcd,
@@ -1119,6 +1150,7 @@ static int uhci_urb_enqueue(struct usb_hcd *hcd,
 		}
 		break;
 	case USB_ENDPOINT_XFER_ISOC:
+		urb-&gt;error_count = 0;
 		bustime = usb_check_bandwidth(urb-&gt;dev, urb);
 		if (bustime &lt; 0) {
 			ret = bustime;
@@ -1200,9 +1232,18 @@ __acquires(uhci-&gt;lock)
 {
 	struct urb_priv *urbp = (struct urb_priv *) urb-&gt;hcpriv;
 
-	/* Isochronous TDs get unlinked directly from the frame list */
-	if (qh-&gt;type == USB_ENDPOINT_XFER_ISOC)
-		uhci_unlink_isochronous_tds(uhci, urb);
+	/* When giving back the first URB in an Isochronous queue,
+	 * reinitialize the QH's iso-related members for the next URB. */
+	if (qh-&gt;type == USB_ENDPOINT_XFER_ISOC &amp;&amp;
+			urbp-&gt;node.prev == &amp;qh-&gt;queue &amp;&amp;
+			urbp-&gt;node.next != &amp;qh-&gt;queue) {
+		struct urb *nurb = list_entry(urbp-&gt;node.next,
+				struct urb_priv, node)-&gt;urb;
+
+		qh-&gt;iso_packet_desc = &amp;nurb-&gt;iso_frame_desc[0];
+		qh-&gt;iso_frame = nurb-&gt;start_frame;
+		qh-&gt;iso_status = 0;
+	}
 
 	/* Take the URB off the QH's queue.  If the queue is now empty,
 	 * this is a perfect time for a toggle fixup. */
@@ -1434,6 +1475,7 @@ static void uhci_scan_schedule(struct uhci_hcd *uhci, struct pt_regs *regs)
 
 	uhci_clear_next_interrupt(uhci);
 	uhci_get_current_frame_number(uhci);
+	uhci-&gt;cur_iso_frame = uhci-&gt;frame_number;
 
 	/* Go through all the QH queues and process the URBs in each one */
 	for (i = 0; i &lt; UHCI_NUM_SKELQH - 1; ++i) {
@@ -1451,6 +1493,7 @@ static void uhci_scan_schedule(struct uhci_hcd *uhci, struct pt_regs *regs)
 		}
 	}
 
+	uhci-&gt;last_iso_frame = uhci-&gt;cur_iso_frame;
 	if (uhci-&gt;need_rescan)
 		goto rescan;
 	uhci-&gt;scan_in_progress = 0;</pre><hr><pre>commit caf3827a65af476c71eaeb79636869a4ab128d48
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 19 16:44:55 2006 -0400

    [PATCH] UHCI: store the period in the queue header
    
    This patch (as689) stores the period for periodic transfers (interrupt
    and ISO) in the queue header.  This is necessary for proper bandwidth
    tracking (not yet implemented).  It also makes the scheduling of ISO
    transfers a bit more rigorous, with checks for out-of-bounds frame
    numbers.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-debug.c b/drivers/usb/host/uhci-debug.c
index ecef5880cfd9..ab8ba8220ad1 100644
--- a/drivers/usb/host/uhci-debug.c
+++ b/drivers/usb/host/uhci-debug.c
@@ -153,7 +153,7 @@ static int uhci_show_qh(struct uhci_qh *qh, char *buf, int len, int space)
 	char *qtype;
 
 	/* Try to make sure there's enough memory */
-	if (len &lt; 80 * 6)
+	if (len &lt; 80 * 7)
 		return 0;
 
 	switch (qh-&gt;type) {
@@ -167,6 +167,9 @@ static int uhci_show_qh(struct uhci_qh *qh, char *buf, int len, int space)
 	out += sprintf(out, "%*s[%p] %s QH link (%08x) element (%08x)\n",
 			space, "", qh, qtype,
 			le32_to_cpu(qh-&gt;link), le32_to_cpu(element));
+	if (qh-&gt;type == USB_ENDPOINT_XFER_ISOC)
+		out += sprintf(out, "%*s    period %d\n",
+				space, "", qh-&gt;period);
 
 	if (element &amp; UHCI_PTR_QH)
 		out += sprintf(out, "%*s  Element points to QH (bug?)\n", space, "");
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index c87ceaa178b6..eaac6ddf03a0 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -140,6 +140,8 @@ struct uhci_qh {
 
 	unsigned long advance_jiffies;	/* Time of last queue advance */
 	unsigned int unlink_frame;	/* When the QH was unlinked */
+	unsigned int period;		/* For Interrupt and Isochronous QHs */
+
 	int state;			/* QH_STATE_xxx; see above */
 	int type;			/* Queue type (control, bulk, etc) */
 
@@ -315,38 +317,8 @@ static inline u32 td_status(struct uhci_td *td) {
 #define skel_bulk_qh		skelqh[12]
 #define skel_term_qh		skelqh[13]
 
-/*
- * Search tree for determining where &lt;interval&gt; fits in the skelqh[]
- * skeleton.
- *
- * An interrupt request should be placed into the slowest skelqh[]
- * which meets the interval/period/frequency requirement.
- * An interrupt request is allowed to be faster than &lt;interval&gt; but not slower.
- *
- * For a given &lt;interval&gt;, this function returns the appropriate/matching
- * skelqh[] index value.
- */
-static inline int __interval_to_skel(int interval)
-{
-	if (interval &lt; 16) {
-		if (interval &lt; 4) {
-			if (interval &lt; 2)
-				return 9;	/* int1 for 0-1 ms */
-			return 8;		/* int2 for 2-3 ms */
-		}
-		if (interval &lt; 8)
-			return 7;		/* int4 for 4-7 ms */
-		return 6;			/* int8 for 8-15 ms */
-	}
-	if (interval &lt; 64) {
-		if (interval &lt; 32)
-			return 5;		/* int16 for 16-31 ms */
-		return 4;			/* int32 for 32-63 ms */
-	}
-	if (interval &lt; 128)
-		return 3;			/* int64 for 64-127 ms */
-	return 2;				/* int128 for 128-255 ms (Max.) */
-}
+/* Find the skelqh entry corresponding to an interval exponent */
+#define UHCI_SKEL_INDEX(exponent)	(9 - exponent)
 
 
 /*
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 96ce4c87c871..7acc23473c63 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -763,6 +763,7 @@ static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb,
 	wmb();
 	qh-&gt;dummy_td-&gt;status |= __constant_cpu_to_le32(TD_CTRL_ACTIVE);
 	qh-&gt;dummy_td = td;
+	qh-&gt;period = urb-&gt;interval;
 
 	usb_settoggle(urb-&gt;dev, usb_pipeendpoint(urb-&gt;pipe),
 			usb_pipeout(urb-&gt;pipe), toggle);
@@ -790,14 +791,30 @@ static inline int uhci_submit_bulk(struct uhci_hcd *uhci, struct urb *urb,
 	return ret;
 }
 
-static inline int uhci_submit_interrupt(struct uhci_hcd *uhci, struct urb *urb,
+static int uhci_submit_interrupt(struct uhci_hcd *uhci, struct urb *urb,
 		struct uhci_qh *qh)
 {
+	int exponent;
+
 	/* USB 1.1 interrupt transfers only involve one packet per interval.
 	 * Drivers can submit URBs of any length, but longer ones will need
 	 * multiple intervals to complete.
 	 */
-	qh-&gt;skel = uhci-&gt;skelqh[__interval_to_skel(urb-&gt;interval)];
+
+	/* Figure out which power-of-two queue to use */
+	for (exponent = 7; exponent &gt;= 0; --exponent) {
+		if ((1 &lt;&lt; exponent) &lt;= urb-&gt;interval)
+			break;
+	}
+	if (exponent &lt; 0)
+		return -EINVAL;
+	urb-&gt;interval = 1 &lt;&lt; exponent;
+
+	if (qh-&gt;period == 0)
+		qh-&gt;skel = uhci-&gt;skelqh[UHCI_SKEL_INDEX(exponent)];
+	else if (qh-&gt;period != urb-&gt;interval)
+		return -EINVAL;		/* Can't change the period */
+
 	return uhci_submit_common(uhci, urb, qh);
 }
 
@@ -937,31 +954,50 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb,
 	unsigned long destination, status;
 	struct urb_priv *urbp = (struct urb_priv *) urb-&gt;hcpriv;
 
-	if (urb-&gt;number_of_packets &gt; 900)	/* 900? Why? */
+	/* Values must not be too big (could overflow below) */
+	if (urb-&gt;interval &gt;= UHCI_NUMFRAMES ||
+			urb-&gt;number_of_packets &gt;= UHCI_NUMFRAMES)
 		return -EFBIG;
 
-	status = TD_CTRL_ACTIVE | TD_CTRL_IOS;
-	destination = (urb-&gt;pipe &amp; PIPE_DEVEP_MASK) | usb_packetid(urb-&gt;pipe);
+	/* Check the period and figure out the starting frame number */
+	uhci_get_current_frame_number(uhci);
+	if (qh-&gt;period == 0) {
+		if (urb-&gt;transfer_flags &amp; URB_ISO_ASAP) {
+			urb-&gt;start_frame = uhci-&gt;frame_number + 10;
+		} else {
+			i = urb-&gt;start_frame - uhci-&gt;frame_number;
+			if (i &lt;= 0 || i &gt;= UHCI_NUMFRAMES)
+				return -EINVAL;
+		}
+	} else if (qh-&gt;period != urb-&gt;interval) {
+		return -EINVAL;		/* Can't change the period */
 
-	/* Figure out the starting frame number */
-	if (urb-&gt;transfer_flags &amp; URB_ISO_ASAP) {
+	} else {	/* Pick up where the last URB leaves off */
 		if (list_empty(&amp;qh-&gt;queue)) {
-			uhci_get_current_frame_number(uhci);
-			urb-&gt;start_frame = (uhci-&gt;frame_number + 10);
-
-		} else {		/* Go right after the last one */
-			struct urb *last_urb;
+			frame = uhci-&gt;frame_number + 10;
+		} else {
+			struct urb *lurb;
 
-			last_urb = list_entry(qh-&gt;queue.prev,
+			lurb = list_entry(qh-&gt;queue.prev,
 					struct urb_priv, node)-&gt;urb;
-			urb-&gt;start_frame = (last_urb-&gt;start_frame +
-					last_urb-&gt;number_of_packets *
-					last_urb-&gt;interval);
+			frame = lurb-&gt;start_frame +
+					lurb-&gt;number_of_packets *
+					lurb-&gt;interval;
 		}
-	} else {
+		if (urb-&gt;transfer_flags &amp; URB_ISO_ASAP)
+			urb-&gt;start_frame = frame;
 		/* FIXME: Sanity check */
 	}
 
+	/* Make sure we won't have to go too far into the future */
+	if (uhci_frame_before_eq(uhci-&gt;frame_number + UHCI_NUMFRAMES,
+			urb-&gt;start_frame + urb-&gt;number_of_packets *
+				urb-&gt;interval))
+		return -EFBIG;
+
+	status = TD_CTRL_ACTIVE | TD_CTRL_IOS;
+	destination = (urb-&gt;pipe &amp; PIPE_DEVEP_MASK) | usb_packetid(urb-&gt;pipe);
+
 	for (i = 0; i &lt; urb-&gt;number_of_packets; i++) {
 		td = uhci_alloc_td(uhci);
 		if (!td)
@@ -978,6 +1014,7 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb,
 	td-&gt;status |= __constant_cpu_to_le32(TD_CTRL_IOC);
 
 	qh-&gt;skel = uhci-&gt;skel_iso_qh;
+	qh-&gt;period = urb-&gt;interval;
 
 	/* Add the TDs to the frame list */
 	frame = urb-&gt;start_frame;
@@ -1206,6 +1243,7 @@ __acquires(uhci-&gt;lock)
 		uhci_unlink_qh(uhci, qh);
 
 		/* Bandwidth stuff not yet implemented */
+		qh-&gt;period = 0;
 	}
 }
 </pre><hr><pre>commit 10b8e47d6b32bfba22874354c62770cb4e42aa6c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 19 16:39:52 2006 -0400

    [PATCH] UHCI: fix race in ISO dequeuing
    
    This patch (as688) fixes a small race in uhci-hcd.  Because ISO queues
    aren't controlled by queue headers, they can't be unlinked.  Only
    individual URBs can.  So whenever multiple ISO URBs are dequeued, it's
    necessary to make sure the hardware is done with each one.  We can't
    assume that dequeuing the first URB will suffice to unlink the entire
    queue.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 76b0a9e95a7a..96ce4c87c871 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -194,7 +194,6 @@ static void uhci_unlink_isochronous_tds(struct uhci_hcd *uhci, struct urb *urb)
 
 	list_for_each_entry(td, &amp;urbp-&gt;td_list, list)
 		uhci_remove_td_from_frame_list(uhci, td);
-	wmb();
 }
 
 static struct uhci_qh *uhci_alloc_qh(struct uhci_hcd *uhci,
@@ -253,17 +252,25 @@ static void uhci_free_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
  * When a queue is stopped and a dequeued URB is given back, adjust
  * the previous TD link (if the URB isn't first on the queue) or
  * save its toggle value (if it is first and is currently executing).
+ *
+ * Returns 0 if the URB should not yet be given back, 1 otherwise.
  */
-static void uhci_cleanup_queue(struct uhci_qh *qh,
+static int uhci_cleanup_queue(struct uhci_hcd *uhci, struct uhci_qh *qh,
 		struct urb *urb)
 {
 	struct urb_priv *urbp = urb-&gt;hcpriv;
 	struct uhci_td *td;
+	int ret = 1;
 
 	/* Isochronous pipes don't use toggles and their TD link pointers
-	 * get adjusted during uhci_urb_dequeue(). */
-	if (qh-&gt;type == USB_ENDPOINT_XFER_ISOC)
-		return;
+	 * get adjusted during uhci_urb_dequeue().  But since their queues
+	 * cannot truly be stopped, we have to watch out for dequeues
+	 * occurring after the nominal unlink frame. */
+	if (qh-&gt;type == USB_ENDPOINT_XFER_ISOC) {
+		ret = (uhci-&gt;frame_number + uhci-&gt;is_stopped !=
+				qh-&gt;unlink_frame);
+		return ret;
+	}
 
 	/* If the URB isn't first on its queue, adjust the link pointer
 	 * of the last TD in the previous URB.  The toggle doesn't need
@@ -279,24 +286,25 @@ static void uhci_cleanup_queue(struct uhci_qh *qh,
 		td = list_entry(urbp-&gt;td_list.prev, struct uhci_td,
 				list);
 		ptd-&gt;link = td-&gt;link;
-		return;
+		return ret;
 	}
 
 	/* If the QH element pointer is UHCI_PTR_TERM then then currently
 	 * executing URB has already been unlinked, so this one isn't it. */
 	if (qh_element(qh) == UHCI_PTR_TERM)
-		return;
+		return ret;
 	qh-&gt;element = UHCI_PTR_TERM;
 
 	/* Control pipes have to worry about toggles */
 	if (qh-&gt;type == USB_ENDPOINT_XFER_CONTROL)
-		return;
+		return ret;
 
 	/* Save the next toggle value */
 	WARN_ON(list_empty(&amp;urbp-&gt;td_list));
 	td = list_entry(urbp-&gt;td_list.next, struct uhci_td, list);
 	qh-&gt;needs_fixup = 1;
 	qh-&gt;initial_toggle = uhci_toggle(td_token(td));
+	return ret;
 }
 
 /*
@@ -953,7 +961,6 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb,
 	} else {
 		/* FIXME: Sanity check */
 	}
-	urb-&gt;start_frame &amp;= (UHCI_NUMFRAMES - 1);
 
 	for (i = 0; i &lt; urb-&gt;number_of_packets; i++) {
 		td = uhci_alloc_td(uhci);
@@ -1120,16 +1127,26 @@ static int uhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb)
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 	unsigned long flags;
 	struct urb_priv *urbp;
+	struct uhci_qh *qh;
 
 	spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
 	urbp = urb-&gt;hcpriv;
 	if (!urbp)			/* URB was never linked! */
 		goto done;
+	qh = urbp-&gt;qh;
 
 	/* Remove Isochronous TDs from the frame list ASAP */
-	if (urbp-&gt;qh-&gt;type == USB_ENDPOINT_XFER_ISOC)
+	if (qh-&gt;type == USB_ENDPOINT_XFER_ISOC) {
 		uhci_unlink_isochronous_tds(uhci, urb);
-	uhci_unlink_qh(uhci, urbp-&gt;qh);
+		mb();
+
+		/* If the URB has already started, update the QH unlink time */
+		uhci_get_current_frame_number(uhci);
+		if (uhci_frame_before_eq(urb-&gt;start_frame, uhci-&gt;frame_number))
+			qh-&gt;unlink_frame = uhci-&gt;frame_number;
+	}
+
+	uhci_unlink_qh(uhci, qh);
 
 done:
 	spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
@@ -1250,7 +1267,14 @@ static void uhci_scan_qh(struct uhci_hcd *uhci, struct uhci_qh *qh,
 	list_for_each_entry(urbp, &amp;qh-&gt;queue, node) {
 		urb = urbp-&gt;urb;
 		if (urb-&gt;status != -EINPROGRESS) {
-			uhci_cleanup_queue(qh, urb);
+
+			/* Fix up the TD links and save the toggles for
+			 * non-Isochronous queues.  For Isochronous queues,
+			 * test for too-recent dequeues. */
+			if (!uhci_cleanup_queue(uhci, qh, urb)) {
+				qh-&gt;is_stopped = 0;
+				return;
+			}
 			uhci_giveback_urb(uhci, qh, urb, regs);
 			goto restart;
 		}</pre><hr><pre>commit c433472658b4df11bd3590a59be79194a1ff43ae
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 19 16:34:57 2006 -0400

    [PATCH] UHCI: use integer-sized frame numbers
    
    This patch (as687) changes uhci-hcd to keep track of frame numbers as
    full-sized integers rather than 11-bit values.  This makes them a lot
    easier to handle and makes it possible to schedule beyond a 2-second
    window, should anyone ever want to do so.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-debug.c b/drivers/usb/host/uhci-debug.c
index 081c592fe8b1..ecef5880cfd9 100644
--- a/drivers/usb/host/uhci-debug.c
+++ b/drivers/usb/host/uhci-debug.c
@@ -289,7 +289,7 @@ static int uhci_show_status(struct uhci_hcd *uhci, char *buf, int len)
 	unsigned short portsc1, portsc2;
 
 	/* Try to make sure there's enough memory */
-	if (len &lt; 80 * 6)
+	if (len &lt; 80 * 9)
 		return 0;
 
 	usbcmd    = inw(io_addr + 0);
@@ -328,6 +328,8 @@ static int uhci_show_status(struct uhci_hcd *uhci, char *buf, int len)
 	out += sprintf(out, "  sof       =       %02x\n", sof);
 	out += uhci_show_sc(1, portsc1, out, len - (out - buf));
 	out += uhci_show_sc(2, portsc2, out, len - (out - buf));
+	out += sprintf(out, "Most recent frame: %x\n",
+			uhci-&gt;frame_number);
 
 	return out - buf;
 }
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 395402eec5ef..5e75ad6dc29f 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -13,7 +13,7 @@
  * (C) Copyright 2000 Yggdrasil Computing, Inc. (port of new PCI interface
  *               support from usb-ohci.c by Adam Richter, adam@yggdrasil.com).
  * (C) Copyright 1999 Gregory P. Smith (from usb-ohci.c)
- * (C) Copyright 2004-2005 Alan Stern, stern@rowland.harvard.edu
+ * (C) Copyright 2004-2006 Alan Stern, stern@rowland.harvard.edu
  *
  * Intel documents this fairly well, and as far as I know there
  * are no royalties or anything like that, but even so there are
@@ -31,7 +31,6 @@
 #include &lt;linux/ioport.h&gt;
 #include &lt;linux/sched.h&gt;
 #include &lt;linux/slab.h&gt;
-#include &lt;linux/smp_lock.h&gt;
 #include &lt;linux/errno.h&gt;
 #include &lt;linux/unistd.h&gt;
 #include &lt;linux/interrupt.h&gt;
@@ -146,7 +145,8 @@ static void configure_hc(struct uhci_hcd *uhci)
 	outl(uhci-&gt;frame_dma_handle, uhci-&gt;io_addr + USBFLBASEADD);
 
 	/* Set the current frame number */
-	outw(uhci-&gt;frame_number, uhci-&gt;io_addr + USBFRNUM);
+	outw(uhci-&gt;frame_number &amp; UHCI_MAX_SOF_NUMBER,
+			uhci-&gt;io_addr + USBFRNUM);
 
 	/* Mark controller as not halted before we enable interrupts */
 	uhci_to_hcd(uhci)-&gt;state = HC_STATE_SUSPENDED;
@@ -239,7 +239,6 @@ __acquires(uhci-&gt;lock)
 		dev_warn(uhci_dev(uhci), "Controller not stopped yet!\n");
 
 	uhci_get_current_frame_number(uhci);
-	smp_wmb();
 
 	uhci-&gt;rh_state = new_state;
 	uhci-&gt;is_stopped = UHCI_IS_STOPPED;
@@ -253,7 +252,6 @@ static void start_rh(struct uhci_hcd *uhci)
 {
 	uhci_to_hcd(uhci)-&gt;state = HC_STATE_RUNNING;
 	uhci-&gt;is_stopped = 0;
-	smp_wmb();
 
 	/* Mark it configured and running with a 64-byte max packet.
 	 * All interrupts are enabled, even though RESUME won't do anything.
@@ -360,12 +358,21 @@ static irqreturn_t uhci_irq(struct usb_hcd *hcd, struct pt_regs *regs)
 
 /*
  * Store the current frame number in uhci-&gt;frame_number if the controller
- * is runnning
+ * is runnning.  Expand from 11 bits (of which we use only 10) to a
+ * full-sized integer.
+ *
+ * Like many other parts of the driver, this code relies on being polled
+ * more than once per second as long as the controller is running.
  */
 static void uhci_get_current_frame_number(struct uhci_hcd *uhci)
 {
-	if (!uhci-&gt;is_stopped)
-		uhci-&gt;frame_number = inw(uhci-&gt;io_addr + USBFRNUM);
+	if (!uhci-&gt;is_stopped) {
+		unsigned delta;
+
+		delta = (inw(uhci-&gt;io_addr + USBFRNUM) - uhci-&gt;frame_number) &amp;
+				(UHCI_NUMFRAMES - 1);
+		uhci-&gt;frame_number += delta;
+	}
 }
 
 /*
@@ -798,18 +805,15 @@ static void uhci_hcd_endpoint_disable(struct usb_hcd *hcd,
 static int uhci_hcd_get_frame_number(struct usb_hcd *hcd)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
-	unsigned long flags;
-	int is_stopped;
-	int frame_number;
+	unsigned frame_number;
+	unsigned delta;
 
 	/* Minimize latency by avoiding the spinlock */
-	local_irq_save(flags);
-	is_stopped = uhci-&gt;is_stopped;
-	smp_rmb();
-	frame_number = (is_stopped ? uhci-&gt;frame_number :
-			inw(uhci-&gt;io_addr + USBFRNUM));
-	local_irq_restore(flags);
-	return frame_number;
+	frame_number = uhci-&gt;frame_number;
+	barrier();
+	delta = (inw(uhci-&gt;io_addr + USBFRNUM) - frame_number) &amp;
+			(UHCI_NUMFRAMES - 1);
+	return frame_number + delta;
 }
 
 static const char hcd_name[] = "uhci_hcd";
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index 04938e64799f..c87ceaa178b6 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -448,6 +448,9 @@ static inline struct usb_hcd *uhci_to_hcd(struct uhci_hcd *uhci)
 
 #define uhci_dev(u)	(uhci_to_hcd(u)-&gt;self.controller)
 
+/* Utility macro for comparing frame numbers */
+#define uhci_frame_before_eq(f1, f2)	(0 &lt;= (int) ((f2) - (f1)))
+
 
 /*
  *	Private per-URB data</pre><hr><pre>commit b761d9d867bcc29e8de3e62d1d72b27e75078ca6
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 12 11:41:59 2006 -0400

    [PATCH] UHCI: Work around old Intel bug
    
    Some old Intel UHCI controllers have a bug that has shown up in a few
    systems (the PIIX3 "Neptune" chip set).  Until now there has not been
    any simple way to work around the bug, but the lastest changes in
    uhci-hcd have made it easy.  This patch (as684) adds the work-around.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 2be84b3b40fe..76b0a9e95a7a 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -13,7 +13,7 @@
  * (C) Copyright 2000 Yggdrasil Computing, Inc. (port of new PCI interface
  *               support from usb-ohci.c by Adam Richter, adam@yggdrasil.com).
  * (C) Copyright 1999 Gregory P. Smith (from usb-ohci.c)
- * (C) Copyright 2004-2005 Alan Stern, stern@rowland.harvard.edu
+ * (C) Copyright 2004-2006 Alan Stern, stern@rowland.harvard.edu
  */
 
 
@@ -1287,6 +1287,11 @@ static void uhci_scan_qh(struct uhci_hcd *uhci, struct uhci_qh *qh,
  * Check for queues that have made some forward progress.
  * Returns 0 if the queue is not Isochronous, is ACTIVE, and
  * has not advanced since last examined; 1 otherwise.
+ *
+ * Early Intel controllers have a bug which causes qh-&gt;element sometimes
+ * not to advance when a TD completes successfully.  The queue remains
+ * stuck on the inactive completed TD.  We detect such cases and advance
+ * the element pointer by hand.
  */
 static int uhci_advance_check(struct uhci_hcd *uhci, struct uhci_qh *qh)
 {
@@ -1327,6 +1332,15 @@ static int uhci_advance_check(struct uhci_hcd *uhci, struct uhci_qh *qh)
 	/* The queue hasn't advanced; check for timeout */
 	if (!qh-&gt;wait_expired &amp;&amp; time_after(jiffies,
 			qh-&gt;advance_jiffies + QH_WAIT_TIMEOUT)) {
+
+		/* Detect the Intel bug and work around it */
+		if (qh-&gt;post_td &amp;&amp; qh_element(qh) ==
+				cpu_to_le32(qh-&gt;post_td-&gt;dma_handle)) {
+			qh-&gt;element = qh-&gt;post_td-&gt;link;
+			qh-&gt;advance_jiffies = jiffies;
+			return 1;
+		}
+
 		qh-&gt;wait_expired = 1;
 
 		/* If the current URB wants FSBR, unlink it temporarily</pre>
    <div class="pagination">
        <a href='2_124.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><span>[125]</span><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_126.html'>Next&gt;&gt;</a>
    <div>
</body>
