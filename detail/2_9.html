<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_8.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><span>[9]</span><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_10.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 9b719c7119e77e8ddeefe4772c554d2863579c2b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 21 10:55:46 2020 +0800

    USB: UDC: net2272: Fix memory leaks
    
    Like net2280 (on which it was based), the net2272 UDC driver has a
    problem with leaking memory along some of its failure pathways.  It
    also has another problem, not previously noted, in that some of the
    failure pathways will call usb_del_gadget_udc() without first calling
    usb_add_gadget_udc_release().  And it leaks memory by calling kfree()
    when it should call put_device().
    
    Until now it has been impossible to handle the memory leaks, because of
    lack of support in the UDC core for separately initializing and adding
    gadgets, or for separately deleting and freeing gadgets.  An earlier
    patch in this series adds the necessary support, making it possible to
    fix the outstanding problems properly.
    
    This patch adds an "added" flag to the net2272 structure to indicate
    whether or not the gadget has been registered (and thus whether or not
    to call usb_del_gadget()), and it fixes the deallocation issues by
    calling usb_put_gadget() at the appropriate places.
    
    A similar memory leak issue, apparently never before recognized, stems
    from the fact that the driver never initializes the drvdata field in
    the gadget's embedded struct device!  Evidently this wasn't noticed
    because the pointer is only ever used as an argument to kfree(), which
    doesn't mind getting called with a NULL pointer. In fact, the drvdata
    for gadget device will be written by usb_composite_dev structure if
    any gadget class is loaded, so it needs to use usb_gadget structure
    to get net2280 private data.
    
    CC: Anton Vasilyev &lt;vasilyev@ispras.ru&gt;
    CC: Evgeny Novikov &lt;novikov@ispras.ru&gt;
    CC: Benjamin Herrenschmidt &lt;benh@kernel.crashing.org&gt;
    Reviewed-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Peter Chen &lt;peter.chen@nxp.com&gt;
    Signed-off-by: Felipe Balbi &lt;balbi@kernel.org&gt;

diff --git a/drivers/usb/gadget/udc/net2272.c b/drivers/usb/gadget/udc/net2272.c
index 440bcb3b6c23..23a735641c3d 100644
--- a/drivers/usb/gadget/udc/net2272.c
+++ b/drivers/usb/gadget/udc/net2272.c
@@ -2195,7 +2195,8 @@ static int net2272_present(struct net2272 *dev)
 static void
 net2272_gadget_release(struct device *_dev)
 {
-	struct net2272 *dev = dev_get_drvdata(_dev);
+	struct net2272 *dev = container_of(_dev, struct net2272, gadget.dev);
+
 	kfree(dev);
 }
 
@@ -2204,7 +2205,8 @@ net2272_gadget_release(struct device *_dev)
 static void
 net2272_remove(struct net2272 *dev)
 {
-	usb_del_gadget_udc(&amp;dev-&gt;gadget);
+	if (dev-&gt;added)
+		usb_del_gadget(&amp;dev-&gt;gadget);
 	free_irq(dev-&gt;irq, dev);
 	iounmap(dev-&gt;base_addr);
 	device_remove_file(dev-&gt;dev, &amp;dev_attr_registers);
@@ -2234,6 +2236,7 @@ static struct net2272 *net2272_probe_init(struct device *dev, unsigned int irq)
 
 	/* the "gadget" abstracts/virtualizes the controller */
 	ret-&gt;gadget.name = driver_name;
+	usb_initialize_gadget(dev, &amp;ret-&gt;gadget, net2272_gadget_release);
 
 	return ret;
 }
@@ -2272,10 +2275,10 @@ net2272_probe_fin(struct net2272 *dev, unsigned int irqflags)
 	if (ret)
 		goto err_irq;
 
-	ret = usb_add_gadget_udc_release(dev-&gt;dev, &amp;dev-&gt;gadget,
-			net2272_gadget_release);
+	ret = usb_add_gadget(&amp;dev-&gt;gadget);
 	if (ret)
 		goto err_add_udc;
+	dev-&gt;added = 1;
 
 	return 0;
 
@@ -2450,7 +2453,7 @@ net2272_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 
 	if (pci_enable_device(pdev) &lt; 0) {
 		ret = -ENODEV;
-		goto err_free;
+		goto err_put;
 	}
 
 	pci_set_master(pdev);
@@ -2473,8 +2476,8 @@ net2272_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 
  err_pci:
 	pci_disable_device(pdev);
- err_free:
-	kfree(dev);
+ err_put:
+	usb_put_gadget(&amp;dev-&gt;gadget);
 
 	return ret;
 }
@@ -2535,7 +2538,7 @@ net2272_pci_remove(struct pci_dev *pdev)
 
 	pci_disable_device(pdev);
 
-	kfree(dev);
+	usb_put_gadget(&amp;dev-&gt;gadget);
 }
 
 /* Table of matching PCI IDs */
@@ -2648,7 +2651,7 @@ net2272_plat_probe(struct platform_device *pdev)
  err_req:
 	release_mem_region(base, len);
  err:
-	kfree(dev);
+	usb_put_gadget(&amp;dev-&gt;gadget);
 
 	return ret;
 }
@@ -2663,7 +2666,7 @@ net2272_plat_remove(struct platform_device *pdev)
 	release_mem_region(pdev-&gt;resource[0].start,
 		resource_size(&amp;pdev-&gt;resource[0]));
 
-	kfree(dev);
+	usb_put_gadget(&amp;dev-&gt;gadget);
 
 	return 0;
 }
diff --git a/drivers/usb/gadget/udc/net2272.h b/drivers/usb/gadget/udc/net2272.h
index 87d0ab9ffeeb..c669308111c2 100644
--- a/drivers/usb/gadget/udc/net2272.h
+++ b/drivers/usb/gadget/udc/net2272.h
@@ -441,6 +441,7 @@ struct net2272 {
 	unsigned protocol_stall:1,
 	         softconnect:1,
 	         wakeup:1,
+		 added:1,
 	         dma_eot_polarity:1,
 	         dma_dack_polarity:1,
 	         dma_dreq_polarity:1,</pre><hr><pre>commit f770fbec4165b1acfabdeadb01ad6008d2c537b5
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 21 10:55:45 2020 +0800

    USB: UDC: net2280: Fix memory leaks
    
    As Anton and Evgeny have noted, the net2280 UDC driver has a problem
    with leaking memory along some of its failure pathways.  It also has
    another problem, not previously noted, in that some of the failure
    pathways will call usb_del_gadget_udc() without first calling
    usb_add_gadget_udc_release().  And it leaks memory by calling kfree()
    when it should call put_device().
    
    Previous attempts to fix the problems have failed because of lack of
    support in the UDC core for separately initializing and adding
    gadgets, or for separately deleting and freeing gadgets.  The previous
    patch in this series adds the necessary support, making it possible to
    fix the outstanding problems properly.
    
    This patch adds an "added" flag to the net2280 structure to indicate
    whether or not the gadget has been registered (and thus whether or not
    to call usb_del_gadget()), and it fixes the deallocation issues by
    calling usb_put_gadget() at the appropriate point.
    
    A similar memory leak issue, apparently never before recognized, stems
    from the fact that the driver never initializes the drvdata field in
    the gadget's embedded struct device!  Evidently this wasn't noticed
    because the pointer is only ever used as an argument to kfree(), which
    doesn't mind getting called with a NULL pointer. In fact, the drvdata
    for gadget device will be written by usb_composite_dev structure if
    any gadget class is loaded, so it needs to use usb_gadget structure
    to get net2280 private data.
    
    CC: Benjamin Herrenschmidt &lt;benh@kernel.crashing.org&gt;
    Reported-by: Anton Vasilyev &lt;vasilyev@ispras.ru&gt;
    Reported-by: Evgeny Novikov &lt;novikov@ispras.ru&gt;
    Reviewed-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Peter Chen &lt;peter.chen@nxp.com&gt;
    Signed-off-by: Felipe Balbi &lt;balbi@kernel.org&gt;

diff --git a/drivers/usb/gadget/udc/net2280.c b/drivers/usb/gadget/udc/net2280.c
index 7530bd9a08c4..d50bc6e19f2a 100644
--- a/drivers/usb/gadget/udc/net2280.c
+++ b/drivers/usb/gadget/udc/net2280.c
@@ -3561,7 +3561,7 @@ static irqreturn_t net2280_irq(int irq, void *_dev)
 
 static void gadget_release(struct device *_dev)
 {
-	struct net2280	*dev = dev_get_drvdata(_dev);
+	struct net2280	*dev = container_of(_dev, struct net2280, gadget.dev);
 
 	kfree(dev);
 }
@@ -3572,7 +3572,8 @@ static void net2280_remove(struct pci_dev *pdev)
 {
 	struct net2280		*dev = pci_get_drvdata(pdev);
 
-	usb_del_gadget_udc(&amp;dev-&gt;gadget);
+	if (dev-&gt;added)
+		usb_del_gadget(&amp;dev-&gt;gadget);
 
 	BUG_ON(dev-&gt;driver);
 
@@ -3603,6 +3604,7 @@ static void net2280_remove(struct pci_dev *pdev)
 	device_remove_file(&amp;pdev-&gt;dev, &amp;dev_attr_registers);
 
 	ep_info(dev, "unbind\n");
+	usb_put_gadget(&amp;dev-&gt;gadget);
 }
 
 /* wrap this driver around the specified device, but
@@ -3624,6 +3626,7 @@ static int net2280_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	}
 
 	pci_set_drvdata(pdev, dev);
+	usb_initialize_gadget(&amp;pdev-&gt;dev, &amp;dev-&gt;gadget, gadget_release);
 	spin_lock_init(&amp;dev-&gt;lock);
 	dev-&gt;quirks = id-&gt;driver_data;
 	dev-&gt;pdev = pdev;
@@ -3774,10 +3777,10 @@ static int net2280_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	if (retval)
 		goto done;
 
-	retval = usb_add_gadget_udc_release(&amp;pdev-&gt;dev, &amp;dev-&gt;gadget,
-			gadget_release);
+	retval = usb_add_gadget(&amp;dev-&gt;gadget);
 	if (retval)
 		goto done;
+	dev-&gt;added = 1;
 	return 0;
 
 done:
diff --git a/drivers/usb/gadget/udc/net2280.h b/drivers/usb/gadget/udc/net2280.h
index 85d3ca1698ba..7da3dc1e9729 100644
--- a/drivers/usb/gadget/udc/net2280.h
+++ b/drivers/usb/gadget/udc/net2280.h
@@ -156,6 +156,7 @@ struct net2280 {
 					softconnect : 1,
 					got_irq : 1,
 					region:1,
+					added:1,
 					u1_enable:1,
 					u2_enable:1,
 					ltm_enable:1,</pre><hr><pre>commit 3301c215a2bb94b5a0afcb444bbe9bf2a395a65d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 21 10:55:44 2020 +0800

    USB: UDC: Expand device model API interface
    
    The routines used by the UDC core to interface with the kernel's
    device model, namely usb_add_gadget_udc(),
    usb_add_gadget_udc_release(), and usb_del_gadget_udc(), provide access
    to only a subset of the device model's full API.  They include
    functionality equivalent to device_register() and device_unregister()
    for gadgets, but they omit device_initialize(), device_add(),
    device_del(), get_device(), and put_device().
    
    This patch expands the UDC API by adding usb_initialize_gadget(),
    usb_add_gadget(), usb_del_gadget(), usb_get_gadget(), and
    usb_put_gadget() to fill in the gap.  It rewrites the existing
    routines to call the new ones.
    
    CC: Anton Vasilyev &lt;vasilyev@ispras.ru&gt;
    CC: Evgeny Novikov &lt;novikov@ispras.ru&gt;
    CC: Benjamin Herrenschmidt &lt;benh@kernel.crashing.org&gt;
    Reviewed-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Peter Chen &lt;peter.chen@nxp.com&gt;
    Signed-off-by: Felipe Balbi &lt;balbi@kernel.org&gt;

diff --git a/drivers/usb/gadget/udc/core.c b/drivers/usb/gadget/udc/core.c
index 4f82bcd31fd3..2b6770d9fb3f 100644
--- a/drivers/usb/gadget/udc/core.c
+++ b/drivers/usb/gadget/udc/core.c
@@ -1164,21 +1164,18 @@ static int check_pending_gadget_drivers(struct usb_udc *udc)
 }
 
 /**
- * usb_add_gadget_udc_release - adds a new gadget to the udc class driver list
+ * usb_initialize_gadget - initialize a gadget and its embedded struct device
  * @parent: the parent device to this udc. Usually the controller driver's
  * device.
- * @gadget: the gadget to be added to the list.
+ * @gadget: the gadget to be initialized.
  * @release: a gadget release function.
  *
  * Returns zero on success, negative errno otherwise.
  * Calls the gadget release function in the latter case.
  */
-int usb_add_gadget_udc_release(struct device *parent, struct usb_gadget *gadget,
+void usb_initialize_gadget(struct device *parent, struct usb_gadget *gadget,
 		void (*release)(struct device *dev))
 {
-	struct usb_udc		*udc;
-	int			ret = -ENOMEM;
-
 	dev_set_name(&amp;gadget-&gt;dev, "gadget");
 	INIT_WORK(&amp;gadget-&gt;work, usb_gadget_state_work);
 	gadget-&gt;dev.parent = parent;
@@ -1189,17 +1186,32 @@ int usb_add_gadget_udc_release(struct device *parent, struct usb_gadget *gadget,
 		gadget-&gt;dev.release = usb_udc_nop_release;
 
 	device_initialize(&amp;gadget-&gt;dev);
+}
+EXPORT_SYMBOL_GPL(usb_initialize_gadget);
+
+/**
+ * usb_add_gadget - adds a new gadget to the udc class driver list
+ * @gadget: the gadget to be added to the list.
+ *
+ * Returns zero on success, negative errno otherwise.
+ * Does not do a final usb_put_gadget() if an error occurs.
+ */
+int usb_add_gadget(struct usb_gadget *gadget)
+{
+	struct usb_udc		*udc;
+	int			ret = -ENOMEM;
 
 	udc = kzalloc(sizeof(*udc), GFP_KERNEL);
 	if (!udc)
-		goto err_put_gadget;
+		goto error;
 
 	device_initialize(&amp;udc-&gt;dev);
 	udc-&gt;dev.release = usb_udc_release;
 	udc-&gt;dev.class = udc_class;
 	udc-&gt;dev.groups = usb_udc_attr_groups;
-	udc-&gt;dev.parent = parent;
-	ret = dev_set_name(&amp;udc-&gt;dev, "%s", kobject_name(&amp;parent-&gt;kobj));
+	udc-&gt;dev.parent = gadget-&gt;dev.parent;
+	ret = dev_set_name(&amp;udc-&gt;dev, "%s",
+			kobject_name(&amp;gadget-&gt;dev.parent-&gt;kobj));
 	if (ret)
 		goto err_put_udc;
 
@@ -1242,8 +1254,30 @@ int usb_add_gadget_udc_release(struct device *parent, struct usb_gadget *gadget,
  err_put_udc:
 	put_device(&amp;udc-&gt;dev);
 
- err_put_gadget:
-	put_device(&amp;gadget-&gt;dev);
+ error:
+	return ret;
+}
+EXPORT_SYMBOL_GPL(usb_add_gadget);
+
+/**
+ * usb_add_gadget_udc_release - adds a new gadget to the udc class driver list
+ * @parent: the parent device to this udc. Usually the controller driver's
+ * device.
+ * @gadget: the gadget to be added to the list.
+ * @release: a gadget release function.
+ *
+ * Returns zero on success, negative errno otherwise.
+ * Calls the gadget release function in the latter case.
+ */
+int usb_add_gadget_udc_release(struct device *parent, struct usb_gadget *gadget,
+		void (*release)(struct device *dev))
+{
+	int	ret;
+
+	usb_initialize_gadget(parent, gadget, release);
+	ret = usb_add_gadget(gadget);
+	if (ret)
+		usb_put_gadget(gadget);
 	return ret;
 }
 EXPORT_SYMBOL_GPL(usb_add_gadget_udc_release);
@@ -1311,13 +1345,14 @@ static void usb_gadget_remove_driver(struct usb_udc *udc)
 }
 
 /**
- * usb_del_gadget_udc - deletes @udc from udc_list
+ * usb_del_gadget - deletes @udc from udc_list
  * @gadget: the gadget to be removed.
  *
- * This, will call usb_gadget_unregister_driver() if
+ * This will call usb_gadget_unregister_driver() if
  * the @udc is still busy.
+ * It will not do a final usb_put_gadget().
  */
-void usb_del_gadget_udc(struct usb_gadget *gadget)
+void usb_del_gadget(struct usb_gadget *gadget)
 {
 	struct usb_udc *udc = gadget-&gt;udc;
 
@@ -1340,7 +1375,20 @@ void usb_del_gadget_udc(struct usb_gadget *gadget)
 	kobject_uevent(&amp;udc-&gt;dev.kobj, KOBJ_REMOVE);
 	flush_work(&amp;gadget-&gt;work);
 	device_unregister(&amp;udc-&gt;dev);
-	device_unregister(&amp;gadget-&gt;dev);
+	device_del(&amp;gadget-&gt;dev);
+}
+EXPORT_SYMBOL_GPL(usb_del_gadget);
+
+/**
+ * usb_del_gadget_udc - deletes @udc from udc_list
+ * @gadget: the gadget to be removed.
+ *
+ * Calls usb_del_gadget() and does a final usb_put_gadget().
+ */
+void usb_del_gadget_udc(struct usb_gadget *gadget)
+{
+	usb_del_gadget(gadget);
+	usb_put_gadget(gadget);
 	memset(&amp;gadget-&gt;dev, 0x00, sizeof(gadget-&gt;dev));
 }
 EXPORT_SYMBOL_GPL(usb_del_gadget_udc);
diff --git a/include/linux/usb/gadget.h b/include/linux/usb/gadget.h
index 52ce1f6b8f83..e7351d64f11f 100644
--- a/include/linux/usb/gadget.h
+++ b/include/linux/usb/gadget.h
@@ -436,6 +436,7 @@ struct usb_gadget {
 };
 #define work_to_gadget(w)	(container_of((w), struct usb_gadget, work))
 
+/* Interface to the device model */
 static inline void set_gadget_data(struct usb_gadget *gadget, void *data)
 	{ dev_set_drvdata(&amp;gadget-&gt;dev, data); }
 static inline void *get_gadget_data(struct usb_gadget *gadget)
@@ -444,6 +445,26 @@ static inline struct usb_gadget *dev_to_usb_gadget(struct device *dev)
 {
 	return container_of(dev, struct usb_gadget, dev);
 }
+static inline struct usb_gadget *usb_get_gadget(struct usb_gadget *gadget)
+{
+	get_device(&amp;gadget-&gt;dev);
+	return gadget;
+}
+static inline void usb_put_gadget(struct usb_gadget *gadget)
+{
+	put_device(&amp;gadget-&gt;dev);
+}
+extern void usb_initialize_gadget(struct device *parent,
+		struct usb_gadget *gadget, void (*release)(struct device *dev));
+extern int usb_add_gadget(struct usb_gadget *gadget);
+extern void usb_del_gadget(struct usb_gadget *gadget);
+
+/* Legacy device-model interface */
+extern int usb_add_gadget_udc_release(struct device *parent,
+		struct usb_gadget *gadget, void (*release)(struct device *dev));
+extern int usb_add_gadget_udc(struct device *parent, struct usb_gadget *gadget);
+extern void usb_del_gadget_udc(struct usb_gadget *gadget);
+extern char *usb_get_gadget_udc_name(void);
 
 /* iterates the non-control endpoints; 'tmp' is a struct usb_ep pointer */
 #define gadget_for_each_ep(tmp, gadget) \
@@ -735,12 +756,6 @@ int usb_gadget_probe_driver(struct usb_gadget_driver *driver);
  */
 int usb_gadget_unregister_driver(struct usb_gadget_driver *driver);
 
-extern int usb_add_gadget_udc_release(struct device *parent,
-		struct usb_gadget *gadget, void (*release)(struct device *dev));
-extern int usb_add_gadget_udc(struct device *parent, struct usb_gadget *gadget);
-extern void usb_del_gadget_udc(struct usb_gadget *gadget);
-extern char *usb_get_gadget_udc_name(void);
-
 /*-------------------------------------------------------------------------*/
 
 /* utility to simplify dealing with string descriptors */</pre><hr><pre>commit 20934c0de13b49a072fb1e0ca79fe0fe0e40eae5
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 26 10:32:29 2020 -0400

    usb: storage: Add unusual_uas entry for Sony PSZ drives
    
    The PSZ-HA* family of USB disk drives from Sony can't handle the
    REPORT OPCODES command when using the UAS protocol.  This patch adds
    an appropriate quirks entry.
    
    Reported-and-tested-by: Till Dörges &lt;doerges@pre-sense.de&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Link: https://lore.kernel.org/r/20200826143229.GB400430@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/storage/unusual_uas.h b/drivers/usb/storage/unusual_uas.h
index 971f8a4354c8..711ab240058c 100644
--- a/drivers/usb/storage/unusual_uas.h
+++ b/drivers/usb/storage/unusual_uas.h
@@ -28,6 +28,13 @@
  * and don't forget to CC: the USB development list &lt;linux-usb@vger.kernel.org&gt;
  */
 
+/* Reported-by: Till Dörges &lt;doerges@pre-sense.de&gt; */
+UNUSUAL_DEV(0x054c, 0x087d, 0x0000, 0x9999,
+		"Sony",
+		"PSZ-HA*",
+		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
+		US_FL_NO_REPORT_OPCODES),
+
 /* Reported-by: Julian Groß &lt;julian.g@posteo.de&gt; */
 UNUSUAL_DEV(0x059f, 0x105f, 0x0000, 0x9999,
 		"LaCie",</pre><hr><pre>commit 068834a2773b6a12805105cfadbb3d4229fc6e0a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 26 15:46:24 2020 -0400

    USB: quirks: Ignore duplicate endpoint on Sound Devices MixPre-D
    
    The Sound Devices MixPre-D audio card suffers from the same defect
    as the Sound Devices USBPre2: an endpoint shared between a normal
    audio interface and a vendor-specific interface, in violation of the
    USB spec.  Since the USB core now treats duplicated endpoints as bugs
    and ignores them, the audio endpoint isn't available and the card
    can't be used for audio capture.
    
    Along the same lines as commit bdd1b147b802 ("USB: quirks: blacklist
    duplicate ep on Sound Devices USBPre2"), this patch adds a quirks
    entry saying to ignore ep5in for interface 1, leaving it available for
    use with standard audio interface 2.
    
    Reported-and-tested-by: Jean-Christophe Barnoud &lt;jcbarnoud@gmail.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Fixes: 3e4f8e21c4f2 ("USB: core: fix check for duplicate endpoints")
    Link: https://lore.kernel.org/r/20200826194624.GA412633@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c
index d1f38956b210..f232914de5fd 100644
--- a/drivers/usb/core/quirks.c
+++ b/drivers/usb/core/quirks.c
@@ -370,6 +370,10 @@ static const struct usb_device_id usb_quirk_list[] = {
 	{ USB_DEVICE(0x0926, 0x0202), .driver_info =
 			USB_QUIRK_ENDPOINT_IGNORE },
 
+	/* Sound Devices MixPre-D */
+	{ USB_DEVICE(0x0926, 0x0208), .driver_info =
+			USB_QUIRK_ENDPOINT_IGNORE },
+
 	/* Keytouch QWERTY Panel keyboard */
 	{ USB_DEVICE(0x0926, 0x3333), .driver_info =
 			USB_QUIRK_CONFIG_INTF_STRINGS },
@@ -511,6 +515,7 @@ static const struct usb_device_id usb_amd_resume_quirk_list[] = {
  */
 static const struct usb_device_id usb_endpoint_ignore[] = {
 	{ USB_DEVICE_INTERFACE_NUMBER(0x0926, 0x0202, 1), .driver_info = 0x85 },
+	{ USB_DEVICE_INTERFACE_NUMBER(0x0926, 0x0208, 1), .driver_info = 0x85 },
 	{ }
 };
 </pre><hr><pre>commit f176ede3a3bde5b398a6777a7f9ff091baa2d3ff
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Aug 10 14:29:54 2020 -0400

    USB: yurex: Fix bad gfp argument
    
    The syzbot fuzzer identified a bug in the yurex driver: It passes
    GFP_KERNEL as a memory-allocation flag to usb_submit_urb() at a time
    when its state is TASK_INTERRUPTIBLE, not TASK_RUNNING:
    
    do not call blocking ops when !TASK_RUNNING; state=1 set at [&lt;00000000370c7c68&gt;] prepare_to_wait+0xb1/0x2a0 kernel/sched/wait.c:247
    WARNING: CPU: 1 PID: 340 at kernel/sched/core.c:7253 __might_sleep+0x135/0x190
    kernel/sched/core.c:7253
    Kernel panic - not syncing: panic_on_warn set ...
    CPU: 1 PID: 340 Comm: syz-executor677 Not tainted 5.8.0-syzkaller #0
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google
    01/01/2011
    Call Trace:
     __dump_stack lib/dump_stack.c:77 [inline]
     dump_stack+0xf6/0x16e lib/dump_stack.c:118
     panic+0x2aa/0x6e1 kernel/panic.c:231
     __warn.cold+0x20/0x50 kernel/panic.c:600
     report_bug+0x1bd/0x210 lib/bug.c:198
     handle_bug+0x41/0x80 arch/x86/kernel/traps.c:234
     exc_invalid_op+0x14/0x40 arch/x86/kernel/traps.c:254
     asm_exc_invalid_op+0x12/0x20 arch/x86/include/asm/idtentry.h:536
    RIP: 0010:__might_sleep+0x135/0x190 kernel/sched/core.c:7253
    Code: 65 48 8b 1c 25 40 ef 01 00 48 8d 7b 10 48 89 fe 48 c1 ee 03 80 3c 06 00 75
    2b 48 8b 73 10 48 c7 c7 e0 9e 06 86 e8 ed 12 f6 ff &lt;0f&gt; 0b e9 46 ff ff ff e8 1f
    b2 4b 00 e9 29 ff ff ff e8 15 b2 4b 00
    RSP: 0018:ffff8881cdb77a28 EFLAGS: 00010282
    RAX: 0000000000000000 RBX: ffff8881c6458000 RCX: 0000000000000000
    RDX: ffff8881c6458000 RSI: ffffffff8129ec93 RDI: ffffed1039b6ef37
    RBP: ffffffff86fdade2 R08: 0000000000000001 R09: ffff8881db32f54f
    R10: 0000000000000000 R11: 0000000030343354 R12: 00000000000001f2
    R13: 0000000000000000 R14: 0000000000000068 R15: ffffffff83c1b1aa
     slab_pre_alloc_hook.constprop.0+0xea/0x200 mm/slab.h:498
     slab_alloc_node mm/slub.c:2816 [inline]
     slab_alloc mm/slub.c:2900 [inline]
     kmem_cache_alloc_trace+0x46/0x220 mm/slub.c:2917
     kmalloc include/linux/slab.h:554 [inline]
     dummy_urb_enqueue+0x7a/0x880 drivers/usb/gadget/udc/dummy_hcd.c:1251
     usb_hcd_submit_urb+0x2b2/0x22d0 drivers/usb/core/hcd.c:1547
     usb_submit_urb+0xb4e/0x13e0 drivers/usb/core/urb.c:570
     yurex_write+0x3ea/0x820 drivers/usb/misc/yurex.c:495
    
    This patch changes the call to use GFP_ATOMIC instead of GFP_KERNEL.
    
    Reported-and-tested-by: syzbot+c2c3302f9c601a4b1be2@syzkaller.appspotmail.com
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Link: https://lore.kernel.org/r/20200810182954.GB307778@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/misc/yurex.c b/drivers/usb/misc/yurex.c
index 6e7d34e7fec4..b2e09883c7e2 100644
--- a/drivers/usb/misc/yurex.c
+++ b/drivers/usb/misc/yurex.c
@@ -492,7 +492,7 @@ static ssize_t yurex_write(struct file *file, const char __user *user_buffer,
 	prepare_to_wait(&amp;dev-&gt;waitq, &amp;wait, TASK_INTERRUPTIBLE);
 	dev_dbg(&amp;dev-&gt;interface-&gt;dev, "%s - submit %c\n", __func__,
 		dev-&gt;cntl_buffer[0]);
-	retval = usb_submit_urb(dev-&gt;cntl_urb, GFP_KERNEL);
+	retval = usb_submit_urb(dev-&gt;cntl_urb, GFP_ATOMIC);
 	if (retval &gt;= 0)
 		timeout = schedule_timeout(YUREX_WRITE_TIMEOUT);
 	finish_wait(&amp;dev-&gt;waitq, &amp;wait);</pre><hr><pre>commit 8f38f8e0a30e1c33cdfc48eba2bd63ac2eae373a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jul 6 11:14:36 2020 -0400

    scsi: block: pm: Simplify resume handling
    
    Commit 05d18ae1cc8a ("scsi: pm: Balance pm_only counter of request queue
    during system resume") fixed a problem in the block layer's runtime-PM
    code: blk_set_runtime_active() failed to call blk_clear_pm_only().
    However, the commit's implementation was awkward; it forced the SCSI
    system-resume handler to choose whether to call blk_post_runtime_resume()
    or blk_set_runtime_active(), depending on whether or not the SCSI device
    had previously been runtime suspended.
    
    This patch simplifies the situation considerably by adding the missing
    function call directly into blk_set_runtime_active() (under the condition
    that the queue is not already in the RPM_ACTIVE state).  This allows the
    SCSI routine to revert back to its original form.  Furthermore, making this
    change reveals that blk_post_runtime_resume() (in its success pathway) does
    exactly the same thing as blk_set_runtime_active().  The duplicate code is
    easily removed by making one routine call the other.
    
    No functional changes are intended.
    
    Link: https://lore.kernel.org/r/20200706151436.GA702867@rowland.harvard.edu
    CC: Can Guo &lt;cang@codeaurora.org&gt;
    CC: Bart Van Assche &lt;bvanassche@acm.org&gt;
    Reviewed-by: Bart Van Assche &lt;bvanassche@acm.org&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Martin K. Petersen &lt;martin.petersen@oracle.com&gt;

diff --git a/block/blk-pm.c b/block/blk-pm.c
index 1adc1cd748b4..b85234d758f7 100644
--- a/block/blk-pm.c
+++ b/block/blk-pm.c
@@ -164,9 +164,8 @@ EXPORT_SYMBOL(blk_pre_runtime_resume);
  *
  * Description:
  *    Update the queue's runtime status according to the return value of the
- *    device's runtime_resume function. If it is successfully resumed, process
- *    the requests that are queued into the device's queue when it is resuming
- *    and then mark last busy and initiate autosuspend for it.
+ *    device's runtime_resume function. If the resume was successful, call
+ *    blk_set_runtime_active() to do the real work of restarting the queue.
  *
  *    This function should be called near the end of the device's
  *    runtime_resume callback.
@@ -175,19 +174,13 @@ void blk_post_runtime_resume(struct request_queue *q, int err)
 {
 	if (!q-&gt;dev)
 		return;
-
-	spin_lock_irq(&amp;q-&gt;queue_lock);
 	if (!err) {
-		q-&gt;rpm_status = RPM_ACTIVE;
-		pm_runtime_mark_last_busy(q-&gt;dev);
-		pm_request_autosuspend(q-&gt;dev);
+		blk_set_runtime_active(q);
 	} else {
+		spin_lock_irq(&amp;q-&gt;queue_lock);
 		q-&gt;rpm_status = RPM_SUSPENDED;
+		spin_unlock_irq(&amp;q-&gt;queue_lock);
 	}
-	spin_unlock_irq(&amp;q-&gt;queue_lock);
-
-	if (!err)
-		blk_clear_pm_only(q);
 }
 EXPORT_SYMBOL(blk_post_runtime_resume);
 
@@ -204,15 +197,25 @@ EXPORT_SYMBOL(blk_post_runtime_resume);
  * This function can be used in driver's resume hook to correct queue
  * runtime PM status and re-enable peeking requests from the queue. It
  * should be called before first request is added to the queue.
+ *
+ * This function is also called by blk_post_runtime_resume() for successful
+ * runtime resumes.  It does everything necessary to restart the queue.
  */
 void blk_set_runtime_active(struct request_queue *q)
 {
-	if (q-&gt;dev) {
-		spin_lock_irq(&amp;q-&gt;queue_lock);
-		q-&gt;rpm_status = RPM_ACTIVE;
-		pm_runtime_mark_last_busy(q-&gt;dev);
-		pm_request_autosuspend(q-&gt;dev);
-		spin_unlock_irq(&amp;q-&gt;queue_lock);
-	}
+	int old_status;
+
+	if (!q-&gt;dev)
+		return;
+
+	spin_lock_irq(&amp;q-&gt;queue_lock);
+	old_status = q-&gt;rpm_status;
+	q-&gt;rpm_status = RPM_ACTIVE;
+	pm_runtime_mark_last_busy(q-&gt;dev);
+	pm_request_autosuspend(q-&gt;dev);
+	spin_unlock_irq(&amp;q-&gt;queue_lock);
+
+	if (old_status != RPM_ACTIVE)
+		blk_clear_pm_only(q);
 }
 EXPORT_SYMBOL(blk_set_runtime_active);
diff --git a/drivers/scsi/scsi_pm.c b/drivers/scsi/scsi_pm.c
index 5f0ad8b32e3a..3717eea37ecb 100644
--- a/drivers/scsi/scsi_pm.c
+++ b/drivers/scsi/scsi_pm.c
@@ -80,10 +80,6 @@ static int scsi_dev_type_resume(struct device *dev,
 	dev_dbg(dev, "scsi resume: %d\n", err);
 
 	if (err == 0) {
-		bool was_runtime_suspended;
-
-		was_runtime_suspended = pm_runtime_suspended(dev);
-
 		pm_runtime_disable(dev);
 		err = pm_runtime_set_active(dev);
 		pm_runtime_enable(dev);
@@ -97,10 +93,8 @@ static int scsi_dev_type_resume(struct device *dev,
 		 */
 		if (!err &amp;&amp; scsi_is_sdev_device(dev)) {
 			struct scsi_device *sdev = to_scsi_device(dev);
-			if (was_runtime_suspended)
-				blk_post_runtime_resume(sdev-&gt;request_queue, 0);
-			else
-				blk_set_runtime_active(sdev-&gt;request_queue);
+
+			blk_set_runtime_active(sdev-&gt;request_queue);
 		}
 	}
 </pre><hr><pre>commit ac854131d9844f79e2fdcef67a7707227538d78a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 1 16:07:28 2020 -0400

    USB: core: Fix misleading driver bug report
    
    The syzbot fuzzer found a race between URB submission to endpoint 0
    and device reset.  Namely, during the reset we call usb_ep0_reinit()
    because the characteristics of ep0 may have changed (if the reset
    follows a firmware update, for example).  While usb_ep0_reinit() is
    running there is a brief period during which the pointers stored in
    udev-&gt;ep_in[0] and udev-&gt;ep_out[0] are set to NULL, and if an URB is
    submitted to ep0 during that period, usb_urb_ep_type_check() will
    report it as a driver bug.  In the absence of those pointers, the
    routine thinks that the endpoint doesn't exist.  The log message looks
    like this:
    
    ------------[ cut here ]------------
    usb 2-1: BOGUS urb xfer, pipe 2 != type 2
    WARNING: CPU: 0 PID: 9241 at drivers/usb/core/urb.c:478
    usb_submit_urb+0x1188/0x1460 drivers/usb/core/urb.c:478
    
    Now, although submitting an URB while the device is being reset is a
    questionable thing to do, it shouldn't count as a driver bug as severe
    as submitting an URB for an endpoint that doesn't exist.  Indeed,
    endpoint 0 always exists, even while the device is in its unconfigured
    state.
    
    To prevent these misleading driver bug reports, this patch updates
    usb_disable_endpoint() to avoid clearing the ep_in[] and ep_out[]
    pointers when the endpoint being disabled is ep0.  There's no danger
    of leaving a stale pointer in place, because the usb_host_endpoint
    structure being pointed to is stored permanently in udev-&gt;ep0; it
    doesn't get deallocated until the entire usb_device structure does.
    
    Reported-and-tested-by: syzbot+db339689b2101f6f6071@syzkaller.appspotmail.com
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    
    Link: https://lore.kernel.org/r/Pine.LNX.4.44L0.2005011558590.903-100000@netrider.rowland.org
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index a48678a0c83a..6197938dcc2d 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1144,11 +1144,11 @@ void usb_disable_endpoint(struct usb_device *dev, unsigned int epaddr,
 
 	if (usb_endpoint_out(epaddr)) {
 		ep = dev-&gt;ep_out[epnum];
-		if (reset_hardware)
+		if (reset_hardware &amp;&amp; epnum != 0)
 			dev-&gt;ep_out[epnum] = NULL;
 	} else {
 		ep = dev-&gt;ep_in[epnum];
-		if (reset_hardware)
+		if (reset_hardware &amp;&amp; epnum != 0)
 			dev-&gt;ep_in[epnum] = NULL;
 	}
 	if (ep) {</pre><hr><pre>commit 0ed08faded1da03eb3def61502b27f81aef2e615
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Apr 22 16:18:48 2020 -0400

    HID: usbhid: Fix race between usbhid_close() and usbhid_stop()
    
    The syzbot fuzzer discovered a bad race between in the usbhid driver
    between usbhid_stop() and usbhid_close().  In particular,
    usbhid_stop() does:
    
            usb_free_urb(usbhid-&gt;urbin);
            ...
            usbhid-&gt;urbin = NULL; /* don't mess up next start */
    
    and usbhid_close() does:
    
            usb_kill_urb(usbhid-&gt;urbin);
    
    with no mutual exclusion.  If the two routines happen to run
    concurrently so that usb_kill_urb() is called in between the
    usb_free_urb() and the NULL assignment, it will access the
    deallocated urb structure -- a use-after-free bug.
    
    This patch adds a mutex to the usbhid private structure and uses it to
    enforce mutual exclusion of the usbhid_start(), usbhid_stop(),
    usbhid_open() and usbhid_close() callbacks.
    
    Reported-and-tested-by: syzbot+7bf5a7b0f0a1f9446f4c@syzkaller.appspotmail.com
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c
index c7bc9db5b192..17a638f15082 100644
--- a/drivers/hid/usbhid/hid-core.c
+++ b/drivers/hid/usbhid/hid-core.c
@@ -682,16 +682,21 @@ static int usbhid_open(struct hid_device *hid)
 	struct usbhid_device *usbhid = hid-&gt;driver_data;
 	int res;
 
+	mutex_lock(&amp;usbhid-&gt;mutex);
+
 	set_bit(HID_OPENED, &amp;usbhid-&gt;iofl);
 
-	if (hid-&gt;quirks &amp; HID_QUIRK_ALWAYS_POLL)
-		return 0;
+	if (hid-&gt;quirks &amp; HID_QUIRK_ALWAYS_POLL) {
+		res = 0;
+		goto Done;
+	}
 
 	res = usb_autopm_get_interface(usbhid-&gt;intf);
 	/* the device must be awake to reliably request remote wakeup */
 	if (res &lt; 0) {
 		clear_bit(HID_OPENED, &amp;usbhid-&gt;iofl);
-		return -EIO;
+		res = -EIO;
+		goto Done;
 	}
 
 	usbhid-&gt;intf-&gt;needs_remote_wakeup = 1;
@@ -725,6 +730,9 @@ static int usbhid_open(struct hid_device *hid)
 		msleep(50);
 
 	clear_bit(HID_RESUME_RUNNING, &amp;usbhid-&gt;iofl);
+
+ Done:
+	mutex_unlock(&amp;usbhid-&gt;mutex);
 	return res;
 }
 
@@ -732,6 +740,8 @@ static void usbhid_close(struct hid_device *hid)
 {
 	struct usbhid_device *usbhid = hid-&gt;driver_data;
 
+	mutex_lock(&amp;usbhid-&gt;mutex);
+
 	/*
 	 * Make sure we don't restart data acquisition due to
 	 * a resumption we no longer care about by avoiding racing
@@ -743,12 +753,13 @@ static void usbhid_close(struct hid_device *hid)
 		clear_bit(HID_IN_POLLING, &amp;usbhid-&gt;iofl);
 	spin_unlock_irq(&amp;usbhid-&gt;lock);
 
-	if (hid-&gt;quirks &amp; HID_QUIRK_ALWAYS_POLL)
-		return;
+	if (!(hid-&gt;quirks &amp; HID_QUIRK_ALWAYS_POLL)) {
+		hid_cancel_delayed_stuff(usbhid);
+		usb_kill_urb(usbhid-&gt;urbin);
+		usbhid-&gt;intf-&gt;needs_remote_wakeup = 0;
+	}
 
-	hid_cancel_delayed_stuff(usbhid);
-	usb_kill_urb(usbhid-&gt;urbin);
-	usbhid-&gt;intf-&gt;needs_remote_wakeup = 0;
+	mutex_unlock(&amp;usbhid-&gt;mutex);
 }
 
 /*
@@ -1057,6 +1068,8 @@ static int usbhid_start(struct hid_device *hid)
 	unsigned int n, insize = 0;
 	int ret;
 
+	mutex_lock(&amp;usbhid-&gt;mutex);
+
 	clear_bit(HID_DISCONNECTED, &amp;usbhid-&gt;iofl);
 
 	usbhid-&gt;bufsize = HID_MIN_BUFFER_SIZE;
@@ -1177,6 +1190,8 @@ static int usbhid_start(struct hid_device *hid)
 		usbhid_set_leds(hid);
 		device_set_wakeup_enable(&amp;dev-&gt;dev, 1);
 	}
+
+	mutex_unlock(&amp;usbhid-&gt;mutex);
 	return 0;
 
 fail:
@@ -1187,6 +1202,7 @@ static int usbhid_start(struct hid_device *hid)
 	usbhid-&gt;urbout = NULL;
 	usbhid-&gt;urbctrl = NULL;
 	hid_free_buffers(dev, hid);
+	mutex_unlock(&amp;usbhid-&gt;mutex);
 	return ret;
 }
 
@@ -1202,6 +1218,8 @@ static void usbhid_stop(struct hid_device *hid)
 		usbhid-&gt;intf-&gt;needs_remote_wakeup = 0;
 	}
 
+	mutex_lock(&amp;usbhid-&gt;mutex);
+
 	clear_bit(HID_STARTED, &amp;usbhid-&gt;iofl);
 	spin_lock_irq(&amp;usbhid-&gt;lock);	/* Sync with error and led handlers */
 	set_bit(HID_DISCONNECTED, &amp;usbhid-&gt;iofl);
@@ -1222,6 +1240,8 @@ static void usbhid_stop(struct hid_device *hid)
 	usbhid-&gt;urbout = NULL;
 
 	hid_free_buffers(hid_to_usb_dev(hid), hid);
+
+	mutex_unlock(&amp;usbhid-&gt;mutex);
 }
 
 static int usbhid_power(struct hid_device *hid, int lvl)
@@ -1382,6 +1402,7 @@ static int usbhid_probe(struct usb_interface *intf, const struct usb_device_id *
 	INIT_WORK(&amp;usbhid-&gt;reset_work, hid_reset);
 	timer_setup(&amp;usbhid-&gt;io_retry, hid_retry_timeout, 0);
 	spin_lock_init(&amp;usbhid-&gt;lock);
+	mutex_init(&amp;usbhid-&gt;mutex);
 
 	ret = hid_add_device(hid);
 	if (ret) {
diff --git a/drivers/hid/usbhid/usbhid.h b/drivers/hid/usbhid/usbhid.h
index 8620408bd7af..75fe85d3d27a 100644
--- a/drivers/hid/usbhid/usbhid.h
+++ b/drivers/hid/usbhid/usbhid.h
@@ -80,6 +80,7 @@ struct usbhid_device {
 	dma_addr_t outbuf_dma;                                          /* Output buffer dma */
 	unsigned long last_out;							/* record of last output for timeouts */
 
+	struct mutex mutex;						/* start/stop/open/close */
 	spinlock_t lock;						/* fifo spinlock */
 	unsigned long iofl;                                             /* I/O flags (CTRL_RUNNING, OUT_RUNNING) */
 	struct timer_list io_retry;                                     /* Retry timer */</pre><hr><pre>commit 598cc93005636e32a98ed003b0158329827c0ccb
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Apr 25 16:35:40 2020 -0400

    PM: sleep: Helpful edits for devices.rst documentation
    
    Here are some minor edits of the devices.rst documentation file,
    intended to improve the clarity and add a couple of missing details.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Rafael J. Wysocki &lt;rafael.j.wysocki@intel.com&gt;

diff --git a/Documentation/driver-api/pm/devices.rst b/Documentation/driver-api/pm/devices.rst
index 782cb37073a3..946ad0b94e31 100644
--- a/Documentation/driver-api/pm/devices.rst
+++ b/Documentation/driver-api/pm/devices.rst
@@ -349,7 +349,7 @@ the phases are: ``prepare``, ``suspend``, ``suspend_late``, ``suspend_noirq``.
 	PM core will skip the ``suspend``, ``suspend_late`` and
 	``suspend_noirq`` phases as well as all of the corresponding phases of
 	the subsequent device resume for all of these devices.	In that case,
-	the ``-&gt;complete`` callback will be invoked directly after the
+	the ``-&gt;complete`` callback will be the next one invoked after the
 	``-&gt;prepare`` callback and is entirely responsible for putting the
 	device into a consistent state as appropriate.
 
@@ -383,11 +383,15 @@ the phases are: ``prepare``, ``suspend``, ``suspend_late``, ``suspend_noirq``.
 	``-&gt;suspend`` methods provided by subsystems (bus types and PM domains
 	in particular) must follow an additional rule regarding what can be done
 	to the devices before their drivers' ``-&gt;suspend`` methods are called.
-	Namely, they can only resume the devices from runtime suspend by
-	calling :c:func:`pm_runtime_resume` for them, if that is necessary, and
+	Namely, they may resume the devices from runtime suspend by
+	calling :c:func:`pm_runtime_resume` for them, if that is necessary, but
 	they must not update the state of the devices in any other way at that
 	time (in case the drivers need to resume the devices from runtime
-	suspend in their ``-&gt;suspend`` methods).
+	suspend in their ``-&gt;suspend`` methods).  In fact, the PM core prevents
+	subsystems or drivers from putting devices into runtime suspend at
+	these times by calling :c:func:`pm_runtime_get_noresume` before issuing
+	the ``-&gt;prepare`` callback (and calling :c:func:`pm_runtime_put` after
+	issuing the ``-&gt;complete`` callback).
 
     3.	For a number of devices it is convenient to split suspend into the
 	"quiesce device" and "save device state" phases, in which cases
@@ -459,22 +463,22 @@ When resuming from freeze, standby or memory sleep, the phases are:
 
 	Note, however, that new children may be registered below the device as
 	soon as the ``-&gt;resume`` callbacks occur; it's not necessary to wait
-	until the ``complete`` phase with that.
+	until the ``complete`` phase runs.
 
 	Moreover, if the preceding ``-&gt;prepare`` callback returned a positive
 	number, the device may have been left in runtime suspend throughout the
-	whole system suspend and resume (the ``suspend``, ``suspend_late``,
-	``suspend_noirq`` phases of system suspend and the ``resume_noirq``,
-	``resume_early``, ``resume`` phases of system resume may have been
-	skipped for it).  In that case, the ``-&gt;complete`` callback is entirely
+	whole system suspend and resume (its ``-&gt;suspend``, ``-&gt;suspend_late``,
+	``-&gt;suspend_noirq``, ``-&gt;resume_noirq``,
+	``-&gt;resume_early``, and ``-&gt;resume`` callbacks may have been
+	skipped).  In that case, the ``-&gt;complete`` callback is entirely
 	responsible for putting the device into a consistent state after system
 	suspend if necessary.  [For example, it may need to queue up a runtime
 	resume request for the device for this purpose.]  To check if that is
 	the case, the ``-&gt;complete`` callback can consult the device's
-	``power.direct_complete`` flag.  Namely, if that flag is set when the
-	``-&gt;complete`` callback is being run, it has been called directly after
-	the preceding ``-&gt;prepare`` and special actions may be required
-	to make the device work correctly afterward.
+	``power.direct_complete`` flag.  If that flag is set when the
+	``-&gt;complete`` callback is being run then the direct-complete mechanism
+	was used, and special actions may be required to make the device work
+	correctly afterward.
 
 At the end of these phases, drivers should be as functional as they were before
 suspending: I/O can be performed using DMA and IRQs, and the relevant clocks are
@@ -575,10 +579,12 @@ and the phases are similar.
 
 The ``-&gt;poweroff``, ``-&gt;poweroff_late`` and ``-&gt;poweroff_noirq`` callbacks
 should do essentially the same things as the ``-&gt;suspend``, ``-&gt;suspend_late``
-and ``-&gt;suspend_noirq`` callbacks, respectively.  The only notable difference is
+and ``-&gt;suspend_noirq`` callbacks, respectively.  A notable difference is
 that they need not store the device register values, because the registers
 should already have been stored during the ``freeze``, ``freeze_late`` or
-``freeze_noirq`` phases.
+``freeze_noirq`` phases.  Also, on many machines the firmware will power-down
+the entire system, so it is not necessary for the callback to put the device in
+a low-power state.
 
 
 Leaving Hibernation
@@ -764,11 +770,10 @@ device driver in question.
 
 If it is necessary to resume a device from runtime suspend during a system-wide
 transition into a sleep state, that can be done by calling
-:c:func:`pm_runtime_resume` for it from the ``-&gt;suspend`` callback (or its
-couterpart for transitions related to hibernation) of either the device's driver
-or a subsystem responsible for it (for example, a bus type or a PM domain).
-That is guaranteed to work by the requirement that subsystems must not change
-the state of devices (possibly except for resuming them from runtime suspend)
+:c:func:`pm_runtime_resume` from the ``-&gt;suspend`` callback (or the ``-&gt;freeze``
+or ``-&gt;poweroff`` callback for transitions related to hibernation) of either the
+device's driver or its subsystem (for example, a bus type or a PM domain).
+However, subsystems must not otherwise change the runtime status of devices
 from their ``-&gt;prepare`` and ``-&gt;suspend`` callbacks (or equivalent) *before*
 invoking device drivers' ``-&gt;suspend`` callbacks (or equivalent).
 
@@ -779,27 +784,29 @@ The ``DPM_FLAG_SMART_SUSPEND`` Driver Flag
 
 Some bus types and PM domains have a policy to resume all devices from runtime
 suspend upfront in their ``-&gt;suspend`` callbacks, but that may not be really
-necessary if the driver of the device can cope with runtime-suspended devices.
-The driver can indicate that by setting ``DPM_FLAG_SMART_SUSPEND`` in
-:c:member:`power.driver_flags` at the probe time with the help of the
+necessary if the device's driver can cope with runtime-suspended devices.
+The driver can indicate this by setting ``DPM_FLAG_SMART_SUSPEND`` in
+:c:member:`power.driver_flags` at probe time, with the assistance of the
 :c:func:`dev_pm_set_driver_flags` helper routine.
 
-However, setting that flag also causes the PM core and middle-layer code
+Setting that flag causes the PM core and middle-layer code
 (bus types, PM domains etc.) to skip the ``-&gt;suspend_late`` and
 ``-&gt;suspend_noirq`` callbacks provided by the driver if the device remains in
-runtime suspend during the ``suspend_late`` phase of system-wide suspend (or
-during the ``poweroff_late`` or ``freeze_late`` phase of hibernation),
-after runtime PM was disabled for it.  [Without doing that, the same driver
+runtime suspend throughout those phases of the system-wide suspend (and
+similarly for the "freeze" and "poweroff" parts of system hibernation).
+[Otherwise the same driver
 callback might be executed twice in a row for the same device, which would not
 be valid in general.]  If the middle-layer system-wide PM callbacks are present
-for the device, they are responsible for doing the above, and the PM core takes
-care of it otherwise.
+for the device then they are responsible for skipping these driver callbacks;
+if not then the PM core skips them.  The subsystem callback routines can
+determine whether they need to skip the driver callbacks by testing the return
+value from the :c:func:`dev_pm_skip_suspend` helper function.
 
-In addition, with ``DPM_FLAG_SMART_SUSPEND`` set, the driver's ``-&gt;thaw_late``
-and ``-&gt;thaw_noirq`` callbacks are skipped if the device remained in runtime
-suspend during the preceding "freeze" transition related to hibernation.
-Again, if the middle-layer callbacks are present for the device, they are
-responsible for doing that, or the PM core takes care of it otherwise.
+In addition, with ``DPM_FLAG_SMART_SUSPEND`` set, the driver's ``-&gt;thaw_noirq``
+and ``-&gt;thaw_early`` callbacks are skipped in hibernation if the device remained
+in runtime suspend throughout the preceding "freeze" transition.  Again, if the
+middle-layer callbacks are present for the device, they are responsible for
+doing this, otherwise the PM core takes care of it.
 
 
 The ``DPM_FLAG_MAY_SKIP_RESUME`` Driver Flag
@@ -820,17 +827,20 @@ indicate to the PM core and middle-layer code that they allow their "noirq" and
 after system-wide PM transitions to the working state.  Whether or not that is
 the case generally depends on the state of the device before the given system
 suspend-resume cycle and on the type of the system transition under way.
-In particular, the "restore" and "thaw" transitions related to hibernation are
-not affected by ``DPM_FLAG_MAY_SKIP_RESUME`` at all.  [All devices are always
-resumed during the "restore" transition and whether or not any driver callbacks
-are skipped during the "freeze" transition depends whether or not the
-``DPM_FLAG_SMART_SUSPEND`` flag is set (see `above &lt;smart_suspend_flag_&gt;`_).]
+In particular, the "thaw" and "restore" transitions related to hibernation are
+not affected by ``DPM_FLAG_MAY_SKIP_RESUME`` at all.  [All callbacks are
+issued during the "restore" transition regardless of the flag settings,
+and whether or not any driver callbacks
+are skipped during the "thaw" transition depends whether or not the
+``DPM_FLAG_SMART_SUSPEND`` flag is set (see `above &lt;smart_suspend_flag_&gt;`_).
+In addition, a device is not allowed to remain in runtime suspend if any of its
+children will be returned to full power.]
 
 The ``DPM_FLAG_MAY_SKIP_RESUME`` flag is taken into account in combination with
 the :c:member:`power.may_skip_resume` status bit set by the PM core during the
 "suspend" phase of suspend-type transitions.  If the driver or the middle layer
 has a reason to prevent the driver's "noirq" and "early" resume callbacks from
-being skipped during the subsequent resume transition of the system, it should
+being skipped during the subsequent system resume transition, it should
 clear :c:member:`power.may_skip_resume` in its ``-&gt;suspend``, ``-&gt;suspend_late``
 or ``-&gt;suspend_noirq`` callback.  [Note that the drivers setting
 ``DPM_FLAG_SMART_SUSPEND`` need to clear :c:member:`power.may_skip_resume` in
@@ -845,8 +855,8 @@ not they should be skipped can be determined by evaluating the
 If that function returns ``true``, the driver's "noirq" and "early" resume
 callbacks should be skipped and the device's runtime PM status will be set to
 "suspended" by the PM core.  Otherwise, if the device was runtime-suspended
-during the preceding system-wide suspend transition and
-``DPM_FLAG_SMART_SUSPEND`` is set for it, its runtime PM status will be set to
+during the preceding system-wide suspend transition and its
+``DPM_FLAG_SMART_SUSPEND`` is set, its runtime PM status will be set to
 "active" by the PM core.  [Hence, the drivers that do not set
 ``DPM_FLAG_SMART_SUSPEND`` should not expect the runtime PM status of their
 devices to be changed from "suspended" to "active" by the PM core during</pre>
    <div class="pagination">
        <a href='2_8.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><span>[9]</span><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_10.html'>Next&gt;&gt;</a>
    <div>
</body>
