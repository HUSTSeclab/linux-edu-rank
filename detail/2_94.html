<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_93.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><span>[94]</span><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_95.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 61a5c657892a43653d6189972159590751a0673e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Apr 4 23:46:59 2008 -0400

    USB: rework sysfs removal of interface files
    
    Removing an interface's sysfs files before unregistering the interface
    doesn't work properly, because usb_unbind_interface() will reinstall
    altsetting 0 and thereby create new sysfs files.  This patch (as1074)
    removes the files after the unregistration is finished.  It's not
    quite as clean, but at least it works.
    
    Also, there's no need to check if an interface has been registered
    before removing its sysfs files.  If it hasn't been registered then
    the files won't have been created, so usb_remove_sysfs_intf_files()
    will simply do nothing.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Jiri Slaby &lt;jirislaby@gmail.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index a3695b5115ff..5b23f6b017d7 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1089,8 +1089,8 @@ void usb_disable_device(struct usb_device *dev, int skip_ep0)
 				continue;
 			dev_dbg(&amp;dev-&gt;dev, "unregistering interface %s\n",
 				interface-&gt;dev.bus_id);
-			usb_remove_sysfs_intf_files(interface);
 			device_del(&amp;interface-&gt;dev);
+			usb_remove_sysfs_intf_files(interface);
 		}
 
 		/* Now that the interfaces are unbound, nobody should
@@ -1231,7 +1231,7 @@ int usb_set_interface(struct usb_device *dev, int interface, int alternate)
 	 */
 
 	/* prevent submissions using previous endpoint settings */
-	if (iface-&gt;cur_altsetting != alt &amp;&amp; device_is_registered(&amp;iface-&gt;dev))
+	if (iface-&gt;cur_altsetting != alt)
 		usb_remove_sysfs_intf_files(iface);
 	usb_disable_interface(dev, iface);
 
@@ -1330,8 +1330,7 @@ int usb_reset_configuration(struct usb_device *dev)
 		struct usb_interface *intf = config-&gt;interface[i];
 		struct usb_host_interface *alt;
 
-		if (device_is_registered(&amp;intf-&gt;dev))
-			usb_remove_sysfs_intf_files(intf);
+		usb_remove_sysfs_intf_files(intf);
 		alt = usb_altnum_to_altsetting(intf, 0);
 
 		/* No altsetting 0?  We'll assume the first altsetting.</pre><hr><pre>commit 43bbb7e015c4380064796c5868b536437b165615
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Apr 3 18:03:17 2008 -0400

    USB: OHCI: host-controller resumes leave root hub suspended
    
    Drivers in the ohci-hcd family should perform certain tasks whenever
    their controller device is resumed.  These include checking for loss
    of power during suspend, turning on port power, and enabling interrupt
    requests.
    
    Until now these jobs have been carried out when the root hub is
    resumed, not when the controller is.  Many drivers work around the
    resulting awkwardness by automatically resuming their root hub
    whenever the controller is resumed.  But this is wasteful and
    unnecessary.
    
    To simplify the situation, this patch (as1066) adds a new core
    routine, ohci_finish_controller_resume(), which can be used by all the
    OHCI-variant drivers.  They can call the new routine instead of
    resuming their root hubs.  And ohci-pci.c can call it instead of using
    its own special-purpose handler.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ohci-at91.c b/drivers/usb/host/ohci-at91.c
index d72dc07dda01..e534f9de0f05 100644
--- a/drivers/usb/host/ohci-at91.c
+++ b/drivers/usb/host/ohci-at91.c
@@ -348,6 +348,7 @@ static int ohci_hcd_at91_drv_resume(struct platform_device *pdev)
 	if (!clocked)
 		at91_start_clock();
 
+	ohci_finish_controller_resume(hcd);
 	return 0;
 }
 #else
diff --git a/drivers/usb/host/ohci-ep93xx.c b/drivers/usb/host/ohci-ep93xx.c
index 40c683f8987d..5adaf36e47d0 100644
--- a/drivers/usb/host/ohci-ep93xx.c
+++ b/drivers/usb/host/ohci-ep93xx.c
@@ -192,8 +192,8 @@ static int ohci_hcd_ep93xx_drv_resume(struct platform_device *pdev)
 	ohci-&gt;next_statechange = jiffies;
 
 	ep93xx_start_hc(&amp;pdev-&gt;dev);
-	usb_hcd_resume_root_hub(hcd);
 
+	ohci_finish_controller_resume(hcd);
 	return 0;
 }
 #endif
diff --git a/drivers/usb/host/ohci-hub.c b/drivers/usb/host/ohci-hub.c
index c638e6b33c43..28d6d775eb5f 100644
--- a/drivers/usb/host/ohci-hub.c
+++ b/drivers/usb/host/ohci-hub.c
@@ -326,6 +326,49 @@ static int ohci_bus_resume (struct usb_hcd *hcd)
 	return rc;
 }
 
+/* Carry out the final steps of resuming the controller device */
+static void ohci_finish_controller_resume(struct usb_hcd *hcd)
+{
+	struct ohci_hcd		*ohci = hcd_to_ohci(hcd);
+	int			port;
+	bool			need_reinit = false;
+
+	/* See if the controller is already running or has been reset */
+	ohci-&gt;hc_control = ohci_readl(ohci, &amp;ohci-&gt;regs-&gt;control);
+	if (ohci-&gt;hc_control &amp; (OHCI_CTRL_IR | OHCI_SCHED_ENABLES)) {
+		need_reinit = true;
+	} else {
+		switch (ohci-&gt;hc_control &amp; OHCI_CTRL_HCFS) {
+		case OHCI_USB_OPER:
+		case OHCI_USB_RESET:
+			need_reinit = true;
+		}
+	}
+
+	/* If needed, reinitialize and suspend the root hub */
+	if (need_reinit) {
+		spin_lock_irq(&amp;ohci-&gt;lock);
+		hcd-&gt;state = HC_STATE_RESUMING;
+		ohci_rh_resume(ohci);
+		hcd-&gt;state = HC_STATE_QUIESCING;
+		ohci_rh_suspend(ohci, 0);
+		hcd-&gt;state = HC_STATE_SUSPENDED;
+		spin_unlock_irq(&amp;ohci-&gt;lock);
+	}
+
+	/* Normally just turn on port power and enable interrupts */
+	else {
+		ohci_dbg(ohci, "powerup ports\n");
+		for (port = 0; port &lt; ohci-&gt;num_ports; port++)
+			ohci_writel(ohci, RH_PS_PPS,
+					&amp;ohci-&gt;regs-&gt;roothub.portstatus[port]);
+
+		ohci_writel(ohci, OHCI_INTR_MIE, &amp;ohci-&gt;regs-&gt;intrenable);
+		ohci_readl(ohci, &amp;ohci-&gt;regs-&gt;intrenable);
+		msleep(20);
+	}
+}
+
 /* Carry out polling-, autostop-, and autoresume-related state changes */
 static int ohci_root_hub_state_changes(struct ohci_hcd *ohci, int changed,
 		int any_connected)
diff --git a/drivers/usb/host/ohci-omap.c b/drivers/usb/host/ohci-omap.c
index 2aafa7b6c81f..3a7c24c03671 100644
--- a/drivers/usb/host/ohci-omap.c
+++ b/drivers/usb/host/ohci-omap.c
@@ -510,14 +510,15 @@ static int ohci_omap_suspend(struct platform_device *dev, pm_message_t message)
 
 static int ohci_omap_resume(struct platform_device *dev)
 {
-	struct ohci_hcd	*ohci = hcd_to_ohci(platform_get_drvdata(dev));
+	struct usb_hcd	*hcd = platform_get_drvdata(dev);
+	struct ohci_hcd	*ohci = hcd_to_ohci(hcd);
 
 	if (time_before(jiffies, ohci-&gt;next_statechange))
 		msleep(5);
 	ohci-&gt;next_statechange = jiffies;
 
 	omap_ohci_clock_power(1);
-	usb_hcd_resume_root_hub(platform_get_drvdata(dev));
+	ohci_finish_controller_resume(hcd);
 	return 0;
 }
 
diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 40b62a35fd3c..4696cc912e16 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -238,42 +238,6 @@ static int __devinit ohci_pci_start (struct usb_hcd *hcd)
 	return ret;
 }
 
-#if	defined(CONFIG_USB_PERSIST) &amp;&amp; (defined(CONFIG_USB_EHCI_HCD) || \
-		defined(CONFIG_USB_EHCI_HCD_MODULE))
-
-/* Following a power loss, we must prepare to regain control of the ports
- * we used to own.  This means turning on the port power before ehci-hcd
- * tries to switch ownership.
- *
- * This isn't a 100% perfect solution.  On most systems the OHCI controllers
- * lie at lower PCI addresses than the EHCI controller, so they will be
- * discovered (and hence resumed) first.  But there is no guarantee things
- * will always work this way.  If the EHCI controller is resumed first and
- * the OHCI ports are unpowered, then the handover will fail.
- */
-static void prepare_for_handover(struct usb_hcd *hcd)
-{
-	struct ohci_hcd	*ohci = hcd_to_ohci(hcd);
-	int		port;
-
-	/* Here we "know" root ports should always stay powered */
-	ohci_dbg(ohci, "powerup ports\n");
-	for (port = 0; port &lt; ohci-&gt;num_ports; port++)
-		ohci_writel(ohci, RH_PS_PPS,
-				&amp;ohci-&gt;regs-&gt;roothub.portstatus[port]);
-
-	/* Flush those writes */
-	ohci_readl(ohci, &amp;ohci-&gt;regs-&gt;control);
-	msleep(20);
-}
-
-#else
-
-static inline void prepare_for_handover(struct usb_hcd *hcd)
-{ }
-
-#endif	/* CONFIG_USB_PERSIST etc. */
-
 #ifdef	CONFIG_PM
 
 static int ohci_pci_suspend (struct usb_hcd *hcd, pm_message_t message)
@@ -312,13 +276,8 @@ static int ohci_pci_suspend (struct usb_hcd *hcd, pm_message_t message)
 
 static int ohci_pci_resume (struct usb_hcd *hcd)
 {
-	struct ohci_hcd	*ohci = hcd_to_ohci(hcd);
-
 	set_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
-
-	/* FIXME: we should try to detect loss of VBUS power here */
-	prepare_for_handover(hcd);
-	ohci_writel(ohci, OHCI_INTR_MIE, &amp;ohci-&gt;regs-&gt;intrenable);
+	ohci_finish_controller_resume(hcd);
 	return 0;
 }
 
diff --git a/drivers/usb/host/ohci-pxa27x.c b/drivers/usb/host/ohci-pxa27x.c
index 5d470263eed8..d4ee27d92be8 100644
--- a/drivers/usb/host/ohci-pxa27x.c
+++ b/drivers/usb/host/ohci-pxa27x.c
@@ -356,8 +356,7 @@ static int ohci_hcd_pxa27x_drv_resume(struct platform_device *pdev)
 	if ((status = pxa27x_start_hc(&amp;pdev-&gt;dev)) &lt; 0)
 		return status;
 
-	usb_hcd_resume_root_hub(hcd);
-
+	ohci_finish_controller_resume(hcd);
 	return 0;
 }
 #endif
diff --git a/drivers/usb/host/ohci-sm501.c b/drivers/usb/host/ohci-sm501.c
index 54b6ac2e3e4a..4a11e1816017 100644
--- a/drivers/usb/host/ohci-sm501.c
+++ b/drivers/usb/host/ohci-sm501.c
@@ -231,14 +231,15 @@ static int ohci_sm501_suspend(struct platform_device *pdev, pm_message_t msg)
 static int ohci_sm501_resume(struct platform_device *pdev)
 {
 	struct device *dev = &amp;pdev-&gt;dev;
-	struct ohci_hcd	*ohci = hcd_to_ohci(platform_get_drvdata(pdev));
+	struct usb_hcd	*hcd = platform_get_drvdata(pdev);
+	struct ohci_hcd	*ohci = hcd_to_ohci(hcd);
 
 	if (time_before(jiffies, ohci-&gt;next_statechange))
 		msleep(5);
 	ohci-&gt;next_statechange = jiffies;
 
 	sm501_unit_power(dev-&gt;parent, SM501_GATE_USB_HOST, 1);
-	usb_hcd_resume_root_hub(platform_get_drvdata(pdev));
+	ohci_finish_controller_resume(hcd);
 	return 0;
 }
 #else
diff --git a/drivers/usb/host/ohci-ssb.c b/drivers/usb/host/ohci-ssb.c
index 7879f2fdad84..7275186db315 100644
--- a/drivers/usb/host/ohci-ssb.c
+++ b/drivers/usb/host/ohci-ssb.c
@@ -189,6 +189,7 @@ static int ssb_ohci_resume(struct ssb_device *dev)
 
 	ssb_device_enable(dev, ohcidev-&gt;enable_flags);
 
+	ohci_finish_controller_resume(hcd);
 	return 0;
 }
 </pre><hr><pre>commit 7be7d7418776a41badce7ca00246e270d408e4b9
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Apr 3 18:03:06 2008 -0400

    USB: clarify usage of hcd-&gt;suspend/resume methods
    
    The .suspend and .resume method pointers in struct usb_hcd have not
    been fully understood by host-controller driver writers.  They are
    meant for use with PCI controllers; other platform-specific drivers
    generally should not refer to them.
    
    To try and clarify matters, this patch (as1065) renames those methods
    to .pci_suspend and .pci_resume.  It eliminates corresponding dead code
    and bogus references in the ohci-ssb and u132-hcd drivers.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd-pci.c b/drivers/usb/core/hcd-pci.c
index 739407bb8492..5b87ae7f0a6a 100644
--- a/drivers/usb/core/hcd-pci.c
+++ b/drivers/usb/core/hcd-pci.c
@@ -215,9 +215,9 @@ int usb_hcd_pci_suspend(struct pci_dev *dev, pm_message_t message)
 			hcd-&gt;state == HC_STATE_HALT))
 		return -EBUSY;
 
-	if (hcd-&gt;driver-&gt;suspend) {
-		retval = hcd-&gt;driver-&gt;suspend(hcd, message);
-		suspend_report_result(hcd-&gt;driver-&gt;suspend, retval);
+	if (hcd-&gt;driver-&gt;pci_suspend) {
+		retval = hcd-&gt;driver-&gt;pci_suspend(hcd, message);
+		suspend_report_result(hcd-&gt;driver-&gt;pci_suspend, retval);
 		if (retval)
 			goto done;
 	}
@@ -405,8 +405,8 @@ int usb_hcd_pci_resume(struct pci_dev *dev)
 
 	clear_bit(HCD_FLAG_SAW_IRQ, &amp;hcd-&gt;flags);
 
-	if (hcd-&gt;driver-&gt;resume) {
-		retval = hcd-&gt;driver-&gt;resume(hcd);
+	if (hcd-&gt;driver-&gt;pci_resume) {
+		retval = hcd-&gt;driver-&gt;pci_resume(hcd);
 		if (retval) {
 			dev_err(hcd-&gt;self.controller,
 				"PCI post-resume error %d!\n", retval);
diff --git a/drivers/usb/core/hcd.h b/drivers/usb/core/hcd.h
index e0e99471c3fc..3ba258eb05de 100644
--- a/drivers/usb/core/hcd.h
+++ b/drivers/usb/core/hcd.h
@@ -178,10 +178,10 @@ struct hc_driver {
 	 * a whole, not just the root hub; they're for PCI bus glue.
 	 */
 	/* called after suspending the hub, before entering D3 etc */
-	int	(*suspend) (struct usb_hcd *hcd, pm_message_t message);
+	int	(*pci_suspend) (struct usb_hcd *hcd, pm_message_t message);
 
 	/* called after entering D0 (etc), before resuming the hub */
-	int	(*resume) (struct usb_hcd *hcd);
+	int	(*pci_resume) (struct usb_hcd *hcd);
 
 	/* cleanly make HCD stop writing memory and doing I/O */
 	void	(*stop) (struct usb_hcd *hcd);
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 7c8a2ccf78f1..a0afc78b273e 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -353,8 +353,8 @@ static const struct hc_driver ehci_pci_hc_driver = {
 	.reset =		ehci_pci_setup,
 	.start =		ehci_run,
 #ifdef	CONFIG_PM
-	.suspend =		ehci_pci_suspend,
-	.resume =		ehci_pci_resume,
+	.pci_suspend =		ehci_pci_suspend,
+	.pci_resume =		ehci_pci_resume,
 #endif
 	.stop =			ehci_stop,
 	.shutdown =		ehci_shutdown,
diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index b0e2275755c8..40b62a35fd3c 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -347,9 +347,8 @@ static const struct hc_driver ohci_pci_hc_driver = {
 	.shutdown =		ohci_shutdown,
 
 #ifdef	CONFIG_PM
-	/* these suspend/resume entries are for upstream PCI glue ONLY */
-	.suspend =		ohci_pci_suspend,
-	.resume =		ohci_pci_resume,
+	.pci_suspend =		ohci_pci_suspend,
+	.pci_resume =		ohci_pci_resume,
 #endif
 
 	/*
diff --git a/drivers/usb/host/ohci-ssb.c b/drivers/usb/host/ohci-ssb.c
index 6e9c2d6db887..7879f2fdad84 100644
--- a/drivers/usb/host/ohci-ssb.c
+++ b/drivers/usb/host/ohci-ssb.c
@@ -60,36 +60,6 @@ static int ssb_ohci_start(struct usb_hcd *hcd)
 	return err;
 }
 
-#ifdef CONFIG_PM
-static int ssb_ohci_hcd_suspend(struct usb_hcd *hcd, pm_message_t message)
-{
-	struct ssb_ohci_device *ohcidev = hcd_to_ssb_ohci(hcd);
-	struct ohci_hcd *ohci = &amp;ohcidev-&gt;ohci;
-	unsigned long flags;
-
-	spin_lock_irqsave(&amp;ohci-&gt;lock, flags);
-
-	ohci_writel(ohci, OHCI_INTR_MIE, &amp;ohci-&gt;regs-&gt;intrdisable);
-	ohci_readl(ohci, &amp;ohci-&gt;regs-&gt;intrdisable); /* commit write */
-
-	/* make sure snapshot being resumed re-enumerates everything */
-	if (message.event == PM_EVENT_PRETHAW)
-		ohci_usb_reset(ohci);
-
-	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
-
-	spin_unlock_irqrestore(&amp;ohci-&gt;lock, flags);
-	return 0;
-}
-
-static int ssb_ohci_hcd_resume(struct usb_hcd *hcd)
-{
-	set_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
-	usb_hcd_resume_root_hub(hcd);
-	return 0;
-}
-#endif /* CONFIG_PM */
-
 static const struct hc_driver ssb_ohci_hc_driver = {
 	.description		= "ssb-usb-ohci",
 	.product_desc		= "SSB OHCI Controller",
@@ -103,11 +73,6 @@ static const struct hc_driver ssb_ohci_hc_driver = {
 	.stop			= ohci_stop,
 	.shutdown		= ohci_shutdown,
 
-#ifdef CONFIG_PM
-	.suspend		= ssb_ohci_hcd_suspend,
-	.resume			= ssb_ohci_hcd_resume,
-#endif
-
 	.urb_enqueue		= ohci_urb_enqueue,
 	.urb_dequeue		= ohci_urb_dequeue,
 	.endpoint_disable	= ohci_endpoint_disable,
diff --git a/drivers/usb/host/u132-hcd.c b/drivers/usb/host/u132-hcd.c
index 4616a880d89c..9b6323f768b2 100644
--- a/drivers/usb/host/u132-hcd.c
+++ b/drivers/usb/host/u132-hcd.c
@@ -2946,34 +2946,6 @@ static void u132_hub_irq_enable(struct usb_hcd *hcd)
 
 
 #ifdef CONFIG_PM
-static int u132_hcd_suspend(struct usb_hcd *hcd, pm_message_t message)
-{
-	struct u132 *u132 = hcd_to_u132(hcd);
-	if (u132-&gt;going &gt; 1) {
-		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device has been removed %d\n"
-			, u132-&gt;going);
-		return -ENODEV;
-	} else if (u132-&gt;going &gt; 0) {
-		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed\n");
-		return -ESHUTDOWN;
-	} else
-		return 0;
-}
-
-static int u132_hcd_resume(struct usb_hcd *hcd)
-{
-	struct u132 *u132 = hcd_to_u132(hcd);
-	if (u132-&gt;going &gt; 1) {
-		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device has been removed %d\n"
-			, u132-&gt;going);
-		return -ENODEV;
-	} else if (u132-&gt;going &gt; 0) {
-		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed\n");
-		return -ESHUTDOWN;
-	} else
-		return 0;
-}
-
 static int u132_bus_suspend(struct usb_hcd *hcd)
 {
 	struct u132 *u132 = hcd_to_u132(hcd);
@@ -3003,8 +2975,6 @@ static int u132_bus_resume(struct usb_hcd *hcd)
 }
 
 #else
-#define u132_hcd_suspend NULL
-#define u132_hcd_resume NULL
 #define u132_bus_suspend NULL
 #define u132_bus_resume NULL
 #endif
@@ -3015,8 +2985,6 @@ static struct hc_driver u132_hc_driver = {
 	.flags = HCD_USB11 | HCD_MEMORY,
 	.reset = u132_hcd_reset,
 	.start = u132_hcd_start,
-	.suspend = u132_hcd_suspend,
-	.resume = u132_hcd_resume,
 	.stop = u132_hcd_stop,
 	.urb_enqueue = u132_urb_enqueue,
 	.urb_dequeue = u132_urb_dequeue,
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index ec987897b8ed..fec9872dd9dc 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -737,7 +737,7 @@ static int uhci_rh_resume(struct usb_hcd *hcd)
 	return rc;
 }
 
-static int uhci_suspend(struct usb_hcd *hcd, pm_message_t message)
+static int uhci_pci_suspend(struct usb_hcd *hcd, pm_message_t message)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 	int rc = 0;
@@ -774,7 +774,7 @@ static int uhci_suspend(struct usb_hcd *hcd, pm_message_t message)
 	return rc;
 }
 
-static int uhci_resume(struct usb_hcd *hcd)
+static int uhci_pci_resume(struct usb_hcd *hcd)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 
@@ -872,8 +872,8 @@ static const struct hc_driver uhci_driver = {
 	.reset =		uhci_init,
 	.start =		uhci_start,
 #ifdef CONFIG_PM
-	.suspend =		uhci_suspend,
-	.resume =		uhci_resume,
+	.pci_suspend =		uhci_pci_suspend,
+	.pci_resume =		uhci_pci_resume,
 	.bus_suspend =		uhci_rh_suspend,
 	.bus_resume =		uhci_rh_resume,
 #endif</pre><hr><pre>commit 7329e211b987a493cbcfca0e98c60eb108ab42df
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Apr 3 18:02:56 2008 -0400

    USB: root hubs don't lie about their number of TTs
    
    Currently EHCI root hubs enumerate with a bDeviceProtocol code
    indicating that they possess a Transaction Translator.  However the
    vast majority of controllers do not; they rely on a companion
    controller to handle full- and low-speed communications.  This patch
    (as1064) changes the root-hub device descriptor to match the actual
    situation.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index f936de75f44e..e68fef5361d2 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -129,7 +129,7 @@ static const u8 usb2_rh_dev_descriptor [18] = {
 
 	0x09,	    /*  __u8  bDeviceClass; HUB_CLASSCODE */
 	0x00,	    /*  __u8  bDeviceSubClass; */
-	0x01,       /*  __u8  bDeviceProtocol; [ usb 2.0 single TT ]*/
+	0x00,       /*  __u8  bDeviceProtocol; [ usb 2.0 no TT ] */
 	0x40,       /*  __u8  bMaxPacketSize0; 64 Bytes */
 
 	0x6b, 0x1d, /*  __le16 idVendor; Linux Foundation */
@@ -354,9 +354,10 @@ static int rh_call_control (struct usb_hcd *hcd, struct urb *urb)
 		__attribute__((aligned(4)));
 	const u8	*bufp = tbuf;
 	int		len = 0;
-	int		patch_wakeup = 0;
 	int		status;
 	int		n;
+	u8		patch_wakeup = 0;
+	u8		patch_protocol = 0;
 
 	might_sleep();
 
@@ -433,6 +434,8 @@ static int rh_call_control (struct usb_hcd *hcd, struct urb *urb)
 			else
 				goto error;
 			len = 18;
+			if (hcd-&gt;has_tt)
+				patch_protocol = 1;
 			break;
 		case USB_DT_CONFIG &lt;&lt; 8:
 			if (hcd-&gt;driver-&gt;flags &amp; HCD_USB2) {
@@ -527,6 +530,13 @@ static int rh_call_control (struct usb_hcd *hcd, struct urb *urb)
 						bmAttributes))
 			((struct usb_config_descriptor *)ubuf)-&gt;bmAttributes
 				|= USB_CONFIG_ATT_WAKEUP;
+
+		/* report whether RH hardware has an integrated TT */
+		if (patch_protocol &amp;&amp;
+				len &gt; offsetof(struct usb_device_descriptor,
+						bDeviceProtocol))
+			((struct usb_device_descriptor *) ubuf)-&gt;
+					bDeviceProtocol = 1;
 	}
 
 	/* any errors get returned through the urb completion */
diff --git a/drivers/usb/core/hcd.h b/drivers/usb/core/hcd.h
index 2c086b8460b1..e0e99471c3fc 100644
--- a/drivers/usb/core/hcd.h
+++ b/drivers/usb/core/hcd.h
@@ -99,6 +99,7 @@ struct usb_hcd {
 	unsigned		poll_pending:1;	/* status has changed? */
 	unsigned		wireless:1;	/* Wireless USB HCD */
 	unsigned		authorized_default:1;
+	unsigned		has_tt:1;	/* Integrated TT in root hub */
 
 	int			irq;		/* irq allocated */
 	void __iomem		*regs;		/* device memory/io */
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 040bd8632eb3..7c8a2ccf78f1 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -130,6 +130,7 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 	case PCI_VENDOR_ID_TDI:
 		if (pdev-&gt;device == PCI_DEVICE_ID_TDI_EHCI) {
 			ehci-&gt;is_tdi_rh_tt = 1;
+			hcd-&gt;has_tt = 1;
 			tdi_reset(ehci);
 		}
 		break;</pre><hr><pre>commit 0d22f65515307c878ddd20b1305cce925ca9516c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Apr 3 11:35:26 2008 -0400

    USB: OHCI: fix bug in controller resume
    
    This patch (as1063) fixes a bug in the way ohci-hcd resumes its
    controllers.  It leaves the Master Interrupt Enable bit turned off.
    
    If the root hub is resumed immediately this won't matter.  But if the
    root hub is suspended (say because no devices are plugged in), it won't
    ever wake up by itself.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index d0360f65ebd9..b0e2275755c8 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -312,11 +312,13 @@ static int ohci_pci_suspend (struct usb_hcd *hcd, pm_message_t message)
 
 static int ohci_pci_resume (struct usb_hcd *hcd)
 {
+	struct ohci_hcd	*ohci = hcd_to_ohci(hcd);
+
 	set_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
 
 	/* FIXME: we should try to detect loss of VBUS power here */
 	prepare_for_handover(hcd);
-
+	ohci_writel(ohci, OHCI_INTR_MIE, &amp;ohci-&gt;regs-&gt;intrenable);
 	return 0;
 }
 </pre><hr><pre>commit 148d9fe4c91a6356dae1b05b76b8133586c26be4
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Mar 27 14:52:57 2008 -0400

    USB: usb-storage: use adaptive DMA mask
    
    This patch (as1060) makes usb-storage set the DMA alignment mask for
    SCSI slaves to match the maxpacket size of the bulk-IN endpoint,
    rather than always setting it to 511.  For full-speed devices that
    mask is too restrictive, and wireless USB devices can have maxpacket
    sizes larger than 512.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 5405ba8cd9d2..521f0297aef9 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -73,6 +73,7 @@ static const char* host_info(struct Scsi_Host *host)
 static int slave_alloc (struct scsi_device *sdev)
 {
 	struct us_data *us = host_to_us(sdev-&gt;host);
+	struct usb_host_endpoint *bulk_in_ep;
 
 	/*
 	 * Set the INQUIRY transfer length to 36.  We don't use any of
@@ -84,12 +85,13 @@ static int slave_alloc (struct scsi_device *sdev)
 	/* Scatter-gather buffers (all but the last) must have a length
 	 * divisible by the bulk maxpacket size.  Otherwise a data packet
 	 * would end up being short, causing a premature end to the data
-	 * transfer.  Since high-speed bulk pipes have a maxpacket size
-	 * of 512, we'll use that as the scsi device queue's DMA alignment
-	 * mask.  Guaranteeing proper alignment of the first buffer will
-	 * have the desired effect because, except at the beginning and
-	 * the end, scatter-gather buffers follow page boundaries. */
-	blk_queue_update_dma_alignment(sdev-&gt;request_queue, (512 - 1));
+	 * transfer.  We'll use the maxpacket value of the bulk-IN pipe
+	 * to set the SCSI device queue's DMA alignment mask.
+	 */
+	bulk_in_ep = us-&gt;pusb_dev-&gt;ep_in[usb_pipeendpoint(us-&gt;recv_bulk_pipe)];
+	blk_queue_update_dma_alignment(sdev-&gt;request_queue,
+			le16_to_cpu(bulk_in_ep-&gt;desc.wMaxPacketSize) - 1);
+			/* wMaxPacketSize must be a power of 2 */
 
 	/*
 	 * The UFI spec treates the Peripheral Qualifier bits in an</pre><hr><pre>commit 70a1c9e086c2e267fbc4533cb870f34999b531d6
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Mar 6 17:00:58 2008 -0500

    USB: remove dev-&gt;power.power_state
    
    power.power_state is scheduled for removal.  This patch (as1053)
    removes all uses of that field from drivers/usb.  Almost all of them
    were write-only, the most significant exceptions being sl811-hcd.c and
    u132-hcd.c.
    
    Part of this patch was written by Pavel Machek.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: David Brownell &lt;david-b@pacbell.net&gt;
    Acked-by: Pavel Machek &lt;pavel@ucw.cz&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index ebccdefcc6f2..2ea333a43d65 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -794,8 +794,6 @@ static int usb_suspend_device(struct usb_device *udev, pm_message_t msg)
 
  done:
 	dev_vdbg(&amp;udev-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
-	if (status == 0)
-		udev-&gt;dev.power.power_state.event = msg.event;
 	return status;
 }
 
@@ -824,10 +822,8 @@ static int usb_resume_device(struct usb_device *udev)
 
  done:
 	dev_vdbg(&amp;udev-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
-	if (status == 0) {
+	if (status == 0)
 		udev-&gt;autoresume_disabled = 0;
-		udev-&gt;dev.power.power_state.event = PM_EVENT_ON;
-	}
 	return status;
 }
 
@@ -1180,8 +1176,7 @@ static int usb_resume_both(struct usb_device *udev)
 		}
 	} else {
 
-		/* Needed for setting udev-&gt;dev.power.power_state.event,
-		 * for possible debugging message, and for reset_resume. */
+		/* Needed for reset-resume */
 		status = usb_resume_device(udev);
 	}
 
@@ -1194,7 +1189,8 @@ static int usb_resume_both(struct usb_device *udev)
 
  done:
 	dev_vdbg(&amp;udev-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
-	udev-&gt;reset_resume = 0;
+	if (!status)
+		udev-&gt;reset_resume = 0;
 	return status;
 }
 
diff --git a/drivers/usb/core/hcd-pci.c b/drivers/usb/core/hcd-pci.c
index 84760ddbc332..739407bb8492 100644
--- a/drivers/usb/core/hcd-pci.c
+++ b/drivers/usb/core/hcd-pci.c
@@ -73,7 +73,6 @@ int usb_hcd_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
 	if (pci_enable_device(dev) &lt; 0)
 		return -ENODEV;
 	dev-&gt;current_state = PCI_D0;
-	dev-&gt;dev.power.power_state = PMSG_ON;
 
 	if (!dev-&gt;irq) {
 		dev_err(&amp;dev-&gt;dev,
@@ -302,8 +301,6 @@ int usb_hcd_pci_suspend(struct pci_dev *dev, pm_message_t message)
 
 done:
 	if (retval == 0) {
-		dev-&gt;dev.power.power_state = PMSG_SUSPEND;
-
 #ifdef CONFIG_PPC_PMAC
 		/* Disable ASIC clocks for USB */
 		if (machine_is(powermac)) {
@@ -406,8 +403,6 @@ int usb_hcd_pci_resume(struct pci_dev *dev)
 	pci_set_master(dev);
 	pci_restore_state(dev);
 
-	dev-&gt;dev.power.power_state = PMSG_ON;
-
 	clear_bit(HCD_FLAG_SAW_IRQ, &amp;hcd-&gt;flags);
 
 	if (hcd-&gt;driver-&gt;resume) {
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 2375194a9d43..1bf8ccb9c58d 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -114,13 +114,11 @@ static inline int is_usb_device_driver(struct device_driver *drv)
 static inline void mark_active(struct usb_interface *f)
 {
 	f-&gt;is_active = 1;
-	f-&gt;dev.power.power_state.event = PM_EVENT_ON;
 }
 
 static inline void mark_quiesced(struct usb_interface *f)
 {
 	f-&gt;is_active = 0;
-	f-&gt;dev.power.power_state.event = PM_EVENT_SUSPEND;
 }
 
 static inline int is_active(const struct usb_interface *f)
diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index cbe44535c0f0..e454775c2ff2 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -900,7 +900,6 @@ static int dummy_udc_suspend (struct platform_device *pdev, pm_message_t state)
 	set_link_state (dum);
 	spin_unlock_irq (&amp;dum-&gt;lock);
 
-	pdev-&gt;dev.power.power_state = state;
 	usb_hcd_poll_rh_status (dummy_to_hcd (dum));
 	return 0;
 }
@@ -915,7 +914,6 @@ static int dummy_udc_resume (struct platform_device *pdev)
 	set_link_state (dum);
 	spin_unlock_irq (&amp;dum-&gt;lock);
 
-	pdev-&gt;dev.power.power_state = PMSG_ON;
 	usb_hcd_poll_rh_status (dummy_to_hcd (dum));
 	return 0;
 }
diff --git a/drivers/usb/gadget/omap_udc.c b/drivers/usb/gadget/omap_udc.c
index ee1e9a314cd1..56277d24f041 100644
--- a/drivers/usb/gadget/omap_udc.c
+++ b/drivers/usb/gadget/omap_udc.c
@@ -1265,8 +1265,6 @@ static int can_pullup(struct omap_udc *udc)
 
 static void pullup_enable(struct omap_udc *udc)
 {
-	udc-&gt;gadget.dev.parent-&gt;power.power_state = PMSG_ON;
-	udc-&gt;gadget.dev.power.power_state = PMSG_ON;
 	UDC_SYSCON1_REG |= UDC_PULLUP_EN;
 	if (!gadget_is_otg(&amp;udc-&gt;gadget) &amp;&amp; !cpu_is_omap15xx())
 		OTG_CTRL_REG |= OTG_BSESSVLD;
@@ -3061,8 +3059,6 @@ static int omap_udc_suspend(struct platform_device *dev, pm_message_t message)
 		omap_pullup(&amp;udc-&gt;gadget, 0);
 	}
 
-	udc-&gt;gadget.dev.power.power_state = PMSG_SUSPEND;
-	udc-&gt;gadget.dev.parent-&gt;power.power_state = PMSG_SUSPEND;
 	return 0;
 }
 
diff --git a/drivers/usb/host/ehci-dbg.c b/drivers/usb/host/ehci-dbg.c
index 38eb92e5dc42..4af90df8e7de 100644
--- a/drivers/usb/host/ehci-dbg.c
+++ b/drivers/usb/host/ehci-dbg.c
@@ -670,7 +670,7 @@ static ssize_t fill_registers_buffer(struct debug_buffer *buf)
 
 	spin_lock_irqsave (&amp;ehci-&gt;lock, flags);
 
-	if (buf-&gt;bus-&gt;controller-&gt;power.power_state.event) {
+	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags)) {
 		size = scnprintf (next, size,
 			"bus %s, device %s (driver " DRIVER_VERSION ")\n"
 			"%s\n"
diff --git a/drivers/usb/host/ehci-ps3.c b/drivers/usb/host/ehci-ps3.c
index bbda58eb8813..69782221bcf3 100644
--- a/drivers/usb/host/ehci-ps3.c
+++ b/drivers/usb/host/ehci-ps3.c
@@ -125,7 +125,6 @@ static int ps3_ehci_probe(struct ps3_system_bus_device *dev)
 		goto fail_irq;
 	}
 
-	dev-&gt;core.power.power_state = PMSG_ON;
 	dev-&gt;core.dma_mask = &amp;dummy_mask; /* FIXME: for improper usb code */
 
 	hcd = usb_create_hcd(&amp;ps3_ehci_hc_driver, &amp;dev-&gt;core, dev-&gt;core.bus_id);
diff --git a/drivers/usb/host/isp116x-hcd.c b/drivers/usb/host/isp116x-hcd.c
index 203a3359a648..66d773c726f6 100644
--- a/drivers/usb/host/isp116x-hcd.c
+++ b/drivers/usb/host/isp116x-hcd.c
@@ -1442,11 +1442,6 @@ static int isp116x_bus_resume(struct usb_hcd *hcd)
 		break;
 	case HCCONTROL_USB_OPER:
 		spin_unlock_irq(&amp;isp116x-&gt;lock);
-		/* Without setting power_state here the
-		   SUSPENDED state won't be removed from
-		   sysfs/usbN/power.state as a response to remote
-		   wakeup. Maybe in the future. */
-		hcd-&gt;self.root_hub-&gt;dev.power.power_state = PMSG_ON;
 		return 0;
 	default:
 		/* HCCONTROL_USB_RESET: this may happen, when during
@@ -1460,7 +1455,6 @@ static int isp116x_bus_resume(struct usb_hcd *hcd)
 		if ((isp116x-&gt;rhdesca &amp; RH_A_NDP) == 2)
 			isp116x_hub_control(hcd, SetPortFeature,
 					    USB_PORT_FEAT_POWER, 2, NULL, 0);
-		hcd-&gt;self.root_hub-&gt;dev.power.power_state = PMSG_ON;
 		return 0;
 	}
 
@@ -1486,8 +1480,6 @@ static int isp116x_bus_resume(struct usb_hcd *hcd)
 	isp116x_write_reg32(isp116x, HCCONTROL,
 			    (val &amp; ~HCCONTROL_HCFS) | HCCONTROL_USB_OPER);
 	spin_unlock_irq(&amp;isp116x-&gt;lock);
-	/* see analogous comment above */
-	hcd-&gt;self.root_hub-&gt;dev.power.power_state = PMSG_ON;
 	hcd-&gt;state = HC_STATE_RUNNING;
 
 	return 0;
@@ -1663,7 +1655,6 @@ static int __devinit isp116x_probe(struct platform_device *pdev)
 static int isp116x_suspend(struct platform_device *dev, pm_message_t state)
 {
 	VDBG("%s: state %x\n", __func__, state.event);
-	dev-&gt;dev.power.power_state = state;
 	return 0;
 }
 
@@ -1672,8 +1663,7 @@ static int isp116x_suspend(struct platform_device *dev, pm_message_t state)
 */
 static int isp116x_resume(struct platform_device *dev)
 {
-	VDBG("%s:  state %x\n", __func__, dev-&gt;power.power_state.event);
-	dev-&gt;dev.power.power_state = PMSG_ON;
+	VDBG("%s\n", __func__);
 	return 0;
 }
 
diff --git a/drivers/usb/host/ohci-dbg.c b/drivers/usb/host/ohci-dbg.c
index a22c30aa745d..e06bfaebec54 100644
--- a/drivers/usb/host/ohci-dbg.c
+++ b/drivers/usb/host/ohci-dbg.c
@@ -655,7 +655,7 @@ static ssize_t fill_registers_buffer(struct debug_buffer *buf)
 		hcd-&gt;product_desc,
 		hcd_name);
 
-	if (bus-&gt;controller-&gt;power.power_state.event) {
+	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags)) {
 		size -= scnprintf (next, size,
 			"SUSPENDED (no register access)\n");
 		goto done;
diff --git a/drivers/usb/host/ohci-ep93xx.c b/drivers/usb/host/ohci-ep93xx.c
index 156e93a9d0df..40c683f8987d 100644
--- a/drivers/usb/host/ohci-ep93xx.c
+++ b/drivers/usb/host/ohci-ep93xx.c
@@ -177,7 +177,6 @@ static int ohci_hcd_ep93xx_drv_suspend(struct platform_device *pdev, pm_message_
 
 	ep93xx_stop_hc(&amp;pdev-&gt;dev);
 	hcd-&gt;state = HC_STATE_SUSPENDED;
-	pdev-&gt;dev.power.power_state = PMSG_SUSPEND;
 
 	return 0;
 }
@@ -193,7 +192,6 @@ static int ohci_hcd_ep93xx_drv_resume(struct platform_device *pdev)
 	ohci-&gt;next_statechange = jiffies;
 
 	ep93xx_start_hc(&amp;pdev-&gt;dev);
-	pdev-&gt;dev.power.power_state = PMSG_ON;
 	usb_hcd_resume_root_hub(hcd);
 
 	return 0;
diff --git a/drivers/usb/host/ohci-omap.c b/drivers/usb/host/ohci-omap.c
index 7bfca1ed1b58..2aafa7b6c81f 100644
--- a/drivers/usb/host/ohci-omap.c
+++ b/drivers/usb/host/ohci-omap.c
@@ -505,7 +505,6 @@ static int ohci_omap_suspend(struct platform_device *dev, pm_message_t message)
 
 	omap_ohci_clock_power(0);
 	ohci_to_hcd(ohci)-&gt;state = HC_STATE_SUSPENDED;
-	dev-&gt;dev.power.power_state = PMSG_SUSPEND;
 	return 0;
 }
 
@@ -518,7 +517,6 @@ static int ohci_omap_resume(struct platform_device *dev)
 	ohci-&gt;next_statechange = jiffies;
 
 	omap_ohci_clock_power(1);
-	dev-&gt;dev.power.power_state = PMSG_ON;
 	usb_hcd_resume_root_hub(platform_get_drvdata(dev));
 	return 0;
 }
diff --git a/drivers/usb/host/ohci-ps3.c b/drivers/usb/host/ohci-ps3.c
index 01a0caeaa6bc..c1935ae537f8 100644
--- a/drivers/usb/host/ohci-ps3.c
+++ b/drivers/usb/host/ohci-ps3.c
@@ -127,7 +127,6 @@ static int ps3_ohci_probe(struct ps3_system_bus_device *dev)
 		goto fail_irq;
 	}
 
-	dev-&gt;core.power.power_state = PMSG_ON;
 	dev-&gt;core.dma_mask = &amp;dummy_mask; /* FIXME: for improper usb code */
 
 	hcd = usb_create_hcd(&amp;ps3_ohci_hc_driver, &amp;dev-&gt;core, dev-&gt;core.bus_id);
diff --git a/drivers/usb/host/ohci-pxa27x.c b/drivers/usb/host/ohci-pxa27x.c
index 8ad9b3b604b5..5d470263eed8 100644
--- a/drivers/usb/host/ohci-pxa27x.c
+++ b/drivers/usb/host/ohci-pxa27x.c
@@ -339,7 +339,6 @@ static int ohci_hcd_pxa27x_drv_suspend(struct platform_device *pdev, pm_message_
 
 	pxa27x_stop_hc(&amp;pdev-&gt;dev);
 	hcd-&gt;state = HC_STATE_SUSPENDED;
-	pdev-&gt;dev.power.power_state = PMSG_SUSPEND;
 
 	return 0;
 }
@@ -357,7 +356,6 @@ static int ohci_hcd_pxa27x_drv_resume(struct platform_device *pdev)
 	if ((status = pxa27x_start_hc(&amp;pdev-&gt;dev)) &lt; 0)
 		return status;
 
-	pdev-&gt;dev.power.power_state = PMSG_ON;
 	usb_hcd_resume_root_hub(hcd);
 
 	return 0;
diff --git a/drivers/usb/host/ohci-sm501.c b/drivers/usb/host/ohci-sm501.c
index 8ffcd3e5f56b..ab1e366d7790 100644
--- a/drivers/usb/host/ohci-sm501.c
+++ b/drivers/usb/host/ohci-sm501.c
@@ -224,7 +224,6 @@ static int ohci_sm501_suspend(struct platform_device *pdev, pm_message_t msg)
 
 	sm501_unit_power(dev-&gt;parent, SM501_GATE_USB_HOST, 0);
 	ohci_to_hcd(ohci)-&gt;state = HC_STATE_SUSPENDED;
-	dev-&gt;power.power_state = PMSG_SUSPEND;
 	return 0;
 }
 
@@ -238,7 +237,6 @@ static int ohci_sm501_resume(struct platform_device *pdev)
 	ohci-&gt;next_statechange = jiffies;
 
 	sm501_unit_power(dev-&gt;parent, SM501_GATE_USB_HOST, 1);
-	dev-&gt;power.power_state = PMSG_ON;
 	usb_hcd_resume_root_hub(platform_get_drvdata(pdev));
 	return 0;
 }
diff --git a/drivers/usb/host/r8a66597-hcd.c b/drivers/usb/host/r8a66597-hcd.c
index afd4fbe7713c..b46ff9a80b66 100644
--- a/drivers/usb/host/r8a66597-hcd.c
+++ b/drivers/usb/host/r8a66597-hcd.c
@@ -2107,13 +2107,11 @@ static struct hc_driver r8a66597_hc_driver = {
 #if defined(CONFIG_PM)
 static int r8a66597_suspend(struct platform_device *pdev, pm_message_t state)
 {
-	pdev-&gt;dev.power.power_state = state;
 	return 0;
 }
 
 static int r8a66597_resume(struct platform_device *pdev)
 {
-	pdev-&gt;dev.power.power_state = PMSG_ON;
 	return 0;
 }
 #else	/* if defined(CONFIG_PM) */
diff --git a/drivers/usb/host/sl811-hcd.c b/drivers/usb/host/sl811-hcd.c
index 629bca0ebe8f..df256d61e2c6 100644
--- a/drivers/usb/host/sl811-hcd.c
+++ b/drivers/usb/host/sl811-hcd.c
@@ -94,12 +94,10 @@ static void port_power(struct sl811 *sl811, int is_on)
 
 		sl811-&gt;port1 = (1 &lt;&lt; USB_PORT_FEAT_POWER);
 		sl811-&gt;irq_enable = SL11H_INTMASK_INSRMV;
-		hcd-&gt;self.controller-&gt;power.power_state = PMSG_ON;
 	} else {
 		sl811-&gt;port1 = 0;
 		sl811-&gt;irq_enable = 0;
 		hcd-&gt;state = HC_STATE_HALT;
-		hcd-&gt;self.controller-&gt;power.power_state = PMSG_SUSPEND;
 	}
 	sl811-&gt;ctrl1 = 0;
 	sl811_write(sl811, SL11H_IRQ_ENABLE, 0);
@@ -1772,8 +1770,6 @@ sl811h_suspend(struct platform_device *dev, pm_message_t state)
 		port_power(sl811, 0);
 		break;
 	}
-	if (retval == 0)
-		dev-&gt;dev.power.power_state = state;
 	return retval;
 }
 
@@ -1786,15 +1782,13 @@ sl811h_resume(struct platform_device *dev)
 	/* with no "check to see if VBUS is still powered" board hook,
 	 * let's assume it'd only be powered to enable remote wakeup.
 	 */
-	if (dev-&gt;dev.power.power_state.event == PM_EVENT_SUSPEND
-			|| !device_can_wakeup(&amp;hcd-&gt;self.root_hub-&gt;dev)) {
+	if (!sl811-&gt;port1 || !device_can_wakeup(&amp;hcd-&gt;self.root_hub-&gt;dev)) {
 		sl811-&gt;port1 = 0;
 		port_power(sl811, 1);
 		usb_root_hub_lost_power(hcd-&gt;self.root_hub);
 		return 0;
 	}
 
-	dev-&gt;dev.power.power_state = PMSG_ON;
 	return sl811h_bus_resume(hcd);
 }
 
diff --git a/drivers/usb/host/u132-hcd.c b/drivers/usb/host/u132-hcd.c
index 8e117a795e93..6e9b7edff528 100644
--- a/drivers/usb/host/u132-hcd.c
+++ b/drivers/usb/host/u132-hcd.c
@@ -1534,11 +1534,9 @@ static void u132_power(struct u132 *u132, int is_on)
                 if (u132-&gt;power)
                         return;
                 u132-&gt;power = 1;
-                hcd-&gt;self.controller-&gt;power.power_state = PMSG_ON;
         } else {
                 u132-&gt;power = 0;
                 hcd-&gt;state = HC_STATE_HALT;
-                hcd-&gt;self.controller-&gt;power.power_state = PMSG_SUSPEND;
         }
 }
 
@@ -3227,8 +3225,6 @@ static int u132_suspend(struct platform_device *pdev, pm_message_t state)
                         }
 			break;
 		}
-                if (retval == 0)
-                        pdev-&gt;dev.power.power_state = state;
                 return retval;
         }
 }
@@ -3246,14 +3242,13 @@ static int u132_resume(struct platform_device *pdev)
                 return -ESHUTDOWN;
         } else {
                 int retval = 0;
-                if (pdev-&gt;dev.power.power_state.event == PM_EVENT_SUSPEND) {
+		if (!u132-&gt;port[0].power) {
                         int ports = MAX_U132_PORTS;
                         while (ports-- &gt; 0) {
                                 port_power(u132, ports, 1);
                         }
                         retval = 0;
                 } else {
-                        pdev-&gt;dev.power.power_state = PMSG_ON;
                         retval = u132_bus_resume(hcd);
                 }
                 return retval;
diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 17100471e461..2c4fd4d6df95 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -1564,7 +1564,8 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 	if (mutex_lock_interruptible(&amp;dev-&gt;lock))
 		return -ERESTARTSYS;
 
-	if (intf-&gt;dev.power.power_state.event != PM_EVENT_ON) {
+	/* FIXME: What if a system sleep starts while a test is running? */
+	if (!intf-&gt;is_active) {
 		mutex_unlock(&amp;dev-&gt;lock);
 		return -EHOSTUNREACH;
 	}</pre><hr><pre>commit 9214d1d80c19016172e685ce7bde0ea757c49097
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Mar 6 11:04:13 2008 -0500

    USB: enable USB-PERSIST by default
    
    This patch (as1052) enables USB-PERSIST for all devices by default.
    The user won't have to remember to enable it explicitly for devices
    containing mounted filesystems.
    
    Eventually userspace tools like hal may be able to set the persist
    attribute automatically when a filesystem is mounted on a USB device.
    When that time comes this patch can be reverted, if people think it
    matters.
    
    This approach has the advantage of giving the user the ability to turn
    off USB-PERSIST for devices with mounted filesystems, rather than
    making the kernel always assume it should be on.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c
index f384edf35b44..2e2019390290 100644
--- a/drivers/usb/core/quirks.c
+++ b/drivers/usb/core/quirks.c
@@ -98,12 +98,14 @@ void usb_detect_quirks(struct usb_device *udev)
 		udev-&gt;autosuspend_disabled = 1;
 #endif
 
-#ifdef	CONFIG_PM
+	/* For the present, all devices default to USB-PERSIST enabled */
+#if 0		/* was: #ifdef CONFIG_PM */
 	/* Hubs are automatically enabled for USB-PERSIST */
 	if (udev-&gt;descriptor.bDeviceClass == USB_CLASS_HUB)
 		udev-&gt;persist_enabled = 1;
+
 #else
-	/* In the absense of PM, we can safely enable USB-PERSIST
+	/* In the absence of PM, we can safely enable USB-PERSIST
 	 * for all devices.  It will affect things like hub resets
 	 * and EMF-related port disables.
 	 */</pre><hr><pre>commit eb764c4be1e5db3ee34df5745e98cf2f148c7320
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Mar 3 15:16:04 2008 -0500

    USB: check serial-number string after device reset
    
    This patch (as1048) extends the descriptor checking after a device is
    reset.  Now the SerialNumber string descriptor is compared to its old
    value, in addition to the device and configuration descriptors.
    
    As a consequence, the kmalloc() call in usb_string() is now on the
    error-handling pathway for usb-storage.  Hence its allocation type is
    changed to GFO_NOIO.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/Documentation/usb/persist.txt b/Documentation/usb/persist.txt
index bea58dbd30fe..d56cb1a11550 100644
--- a/Documentation/usb/persist.txt
+++ b/Documentation/usb/persist.txt
@@ -136,10 +136,10 @@ aren't guaranteed to be 100% accurate.
 
 If you replace one USB device with another of the same type (same
 manufacturer, same IDs, and so on) there's an excellent chance the
-kernel won't detect the change.  Serial numbers and other strings are
-not compared.  In many cases it wouldn't help if they were, because
-manufacturers frequently omit serial numbers entirely in their
-devices.
+kernel won't detect the change.  The serial number string and other
+descriptors are compared with the kernel's stored values, but this
+might not help since manufacturers frequently omit serial numbers
+entirely in their devices.
 
 Furthermore it's quite possible to leave a USB device exactly the same
 while changing its media.  If you replace the flash memory card in a
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 6dc589955d75..9fc5179dfc60 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -3010,16 +3010,36 @@ void usb_hub_cleanup(void)
 	usb_deregister(&amp;hub_driver);
 } /* usb_hub_cleanup() */
 
-static int config_descriptors_changed(struct usb_device *udev)
-{
-	unsigned			index;
-	unsigned			len = 0;
-	struct usb_config_descriptor	*buf;
+static int descriptors_changed(struct usb_device *udev,
+		struct usb_device_descriptor *old_device_descriptor)
+{
+	int		changed = 0;
+	unsigned	index;
+	unsigned	serial_len = 0;
+	unsigned	len;
+	unsigned	old_length;
+	int		length;
+	char		*buf;
+
+	if (memcmp(&amp;udev-&gt;descriptor, old_device_descriptor,
+			sizeof(*old_device_descriptor)) != 0)
+		return 1;
+
+	/* Since the idVendor, idProduct, and bcdDevice values in the
+	 * device descriptor haven't changed, we will assume the
+	 * Manufacturer and Product strings haven't changed either.
+	 * But the SerialNumber string could be different (e.g., a
+	 * different flash card of the same brand).
+	 */
+	if (udev-&gt;serial)
+		serial_len = strlen(udev-&gt;serial) + 1;
 
+	len = serial_len;
 	for (index = 0; index &lt; udev-&gt;descriptor.bNumConfigurations; index++) {
-		if (len &lt; le16_to_cpu(udev-&gt;config[index].desc.wTotalLength))
-			len = le16_to_cpu(udev-&gt;config[index].desc.wTotalLength);
+		old_length = le16_to_cpu(udev-&gt;config[index].desc.wTotalLength);
+		len = max(len, old_length);
 	}
+
 	buf = kmalloc(len, GFP_NOIO);
 	if (buf == NULL) {
 		dev_err(&amp;udev-&gt;dev, "no mem to re-read configs after reset\n");
@@ -3027,25 +3047,41 @@ static int config_descriptors_changed(struct usb_device *udev)
 		return 1;
 	}
 	for (index = 0; index &lt; udev-&gt;descriptor.bNumConfigurations; index++) {
-		int length;
-		int old_length = le16_to_cpu(udev-&gt;config[index].desc.wTotalLength);
-
+		old_length = le16_to_cpu(udev-&gt;config[index].desc.wTotalLength);
 		length = usb_get_descriptor(udev, USB_DT_CONFIG, index, buf,
 				old_length);
-		if (length &lt; old_length) {
+		if (length != old_length) {
 			dev_dbg(&amp;udev-&gt;dev, "config index %d, error %d\n",
 					index, length);
+			changed = 1;
 			break;
 		}
 		if (memcmp (buf, udev-&gt;rawdescriptors[index], old_length)
 				!= 0) {
 			dev_dbg(&amp;udev-&gt;dev, "config index %d changed (#%d)\n",
-				index, buf-&gt;bConfigurationValue);
+				index,
+				((struct usb_config_descriptor *) buf)-&gt;
+					bConfigurationValue);
+			changed = 1;
 			break;
 		}
 	}
+
+	if (!changed &amp;&amp; serial_len) {
+		length = usb_string(udev, udev-&gt;descriptor.iSerialNumber,
+				buf, serial_len);
+		if (length + 1 != serial_len) {
+			dev_dbg(&amp;udev-&gt;dev, "serial string error %d\n",
+					length);
+			changed = 1;
+		} else if (memcmp(buf, udev-&gt;serial, length) != 0) {
+			dev_dbg(&amp;udev-&gt;dev, "serial string changed\n");
+			changed = 1;
+		}
+	}
+
 	kfree(buf);
-	return index != udev-&gt;descriptor.bNumConfigurations;
+	return changed;
 }
 
 /**
@@ -3118,8 +3154,7 @@ int usb_reset_device(struct usb_device *udev)
 		goto re_enumerate;
  
 	/* Device might have changed firmware (DFU or similar) */
-	if (memcmp(&amp;udev-&gt;descriptor, &amp;descriptor, sizeof descriptor)
-			|| config_descriptors_changed (udev)) {
+	if (descriptors_changed(udev, &amp;descriptor)) {
 		dev_info(&amp;udev-&gt;dev, "device firmware changed\n");
 		udev-&gt;descriptor = descriptor;	/* for disconnect() calls */
 		goto re_enumerate;
diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index c311f67b7f08..a3695b5115ff 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -784,7 +784,7 @@ int usb_string(struct usb_device *dev, int index, char *buf, size_t size)
 	if (size &lt;= 0 || !buf || !index)
 		return -EINVAL;
 	buf[0] = 0;
-	tbuf = kmalloc(256, GFP_KERNEL);
+	tbuf = kmalloc(256, GFP_NOIO);
 	if (!tbuf)
 		return -ENOMEM;
 </pre><hr><pre>commit feccc30d90155bcbc937f87643182a43d25873eb
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Mar 3 15:15:59 2008 -0500

    USB: remove CONFIG_USB_PERSIST setting
    
    This patch (as1047) removes the USB_PERSIST Kconfig option, enabling
    it permanently.  It also prevents the power/persist attribute from
    being created for hub devices; there's no point in having it since
    USB-PERSIST is always turned on for hubs.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/Documentation/usb/persist.txt b/Documentation/usb/persist.txt
index df54d645cbb5..bea58dbd30fe 100644
--- a/Documentation/usb/persist.txt
+++ b/Documentation/usb/persist.txt
@@ -2,7 +2,7 @@
 
 		   Alan Stern &lt;stern@rowland.harvard.edu&gt;
 
-		 September 2, 2006 (Updated May 29, 2007)
+		September 2, 2006 (Updated February 25, 2008)
 
 
 	What is the problem?
@@ -65,9 +65,10 @@ much better.)
 
 	What is the solution?
 
-Setting CONFIG_USB_PERSIST will cause the kernel to work around these
-issues.  It enables a mode in which the core USB device data
-structures are allowed to persist across a power-session disruption.
+The kernel includes a feature called USB-persist.  It tries to work
+around these issues by allowing the core USB device data structures to
+persist across a power-session disruption.
+
 It works like this.  If the kernel sees that a USB host controller is
 not in the expected state during resume (i.e., if the controller was
 reset or otherwise had lost power) then it applies a persistence check
@@ -80,28 +81,30 @@ re-enumeration shows that the device now attached to that port has the
 same descriptors as before, including the Vendor and Product IDs, then
 the kernel continues to use the same device structure.  In effect, the
 kernel treats the device as though it had merely been reset instead of
-unplugged.
+unplugged.  The same thing happens if the host controller is in the
+expected state but a USB device was unplugged and then replugged.
 
 If no device is now attached to the port, or if the descriptors are
 different from what the kernel remembers, then the treatment is what
 you would expect.  The kernel destroys the old device structure and
 behaves as though the old device had been unplugged and a new device
-plugged in, just as it would without the CONFIG_USB_PERSIST option.
+plugged in.
 
 The end result is that the USB device remains available and usable.
 Filesystem mounts and memory mappings are unaffected, and the world is
 now a good and happy place.
 
-Note that even when CONFIG_USB_PERSIST is set, the "persist" feature
-will be applied only to those devices for which it is enabled.  You
-can enable the feature by doing (as root):
+Note that the "USB-persist" feature will be applied only to those
+devices for which it is enabled.  You can enable the feature by doing
+(as root):
 
 	echo 1 &gt;/sys/bus/usb/devices/.../power/persist
 
 where the "..." should be filled in the with the device's ID.  Disable
 the feature by writing 0 instead of 1.  For hubs the feature is
-automatically and permanently enabled, so you only have to worry about
-setting it for devices where it really matters.
+automatically and permanently enabled and the power/persist file
+doesn't even exist, so you only have to worry about setting it for
+devices where it really matters.
 
 
 	Is this the best solution?
@@ -112,19 +115,19 @@ centralized Logical Volume Manager.  Such a solution would allow you
 to plug in a USB flash device, create a persistent volume associated
 with it, unplug the flash device, plug it back in later, and still
 have the same persistent volume associated with the device.  As such
-it would be more far-reaching than CONFIG_USB_PERSIST.
+it would be more far-reaching than USB-persist.
 
 On the other hand, writing a persistent volume manager would be a big
 job and using it would require significant input from the user.  This
 solution is much quicker and easier -- and it exists now, a giant
 point in its favor!
 
-Furthermore, the USB_PERSIST option applies to _all_ USB devices, not
+Furthermore, the USB-persist feature applies to _all_ USB devices, not
 just mass-storage devices.  It might turn out to be equally useful for
 other device types, such as network interfaces.
 
 
-	WARNING: Using CONFIG_USB_PERSIST can be dangerous!!
+	WARNING: USB-persist can be dangerous!!
 
 When recovering an interrupted power session the kernel does its best
 to make sure the USB device hasn't been changed; that is, the same
@@ -152,5 +155,5 @@ but yourself.
 YOU HAVE BEEN WARNED!  USE AT YOUR OWN RISK!
 
 That having been said, most of the time there shouldn't be any trouble
-at all.  The "persist" feature can be extremely useful.  Make the most
-of it.
+at all.  The USB-persist feature can be extremely useful.  Make the
+most of it.
diff --git a/drivers/usb/core/Kconfig b/drivers/usb/core/Kconfig
index a2b0aa48b8ea..c15621d64579 100644
--- a/drivers/usb/core/Kconfig
+++ b/drivers/usb/core/Kconfig
@@ -102,31 +102,6 @@ config USB_SUSPEND
 
 	  If you are unsure about this, say N here.
 
-config USB_PERSIST
-	bool "USB device persistence during system suspend (DANGEROUS)"
-	depends on USB &amp;&amp; PM &amp;&amp; EXPERIMENTAL
-	default n
-	help
-
-	  If you say Y here and enable the "power/persist" attribute
-	  for a USB device, the device's data structures will remain
-	  persistent across system suspend, even if the USB bus loses
-	  power.  (This includes hibernation, also known as swsusp or
-	  suspend-to-disk.)  The devices will reappear as if by magic
-	  when the system wakes up, with no need to unmount USB
-	  filesystems, rmmod host-controller drivers, or do anything
-	  else.
-
-	  	WARNING: This option can be dangerous!
-
-	  If a USB device is replaced by another of the same type while
-	  the system is asleep, there's a good chance the kernel won't
-	  detect the change.  Likewise if the media in a USB storage
-	  device is replaced.  When this happens it's almost certain to
-	  cause data corruption and maybe even crash your system.
-
-	  If you are unsure, say N here.
-
 config USB_OTG
 	bool
 	depends on USB &amp;&amp; EXPERIMENTAL
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index df68e2562582..6dc589955d75 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -30,12 +30,6 @@
 #include "hcd.h"
 #include "hub.h"
 
-#ifdef	CONFIG_USB_PERSIST
-#define	USB_PERSIST	1
-#else
-#define	USB_PERSIST	0
-#endif
-
 /* if we are in debug mode, always announce new devices */
 #ifdef DEBUG
 #ifndef CONFIG_USB_ANNOUNCE_NEW_DEVICES
@@ -695,7 +689,7 @@ static void hub_restart(struct usb_hub *hub, int type)
 		 * turn off the various status changes to prevent
 		 * khubd from disconnecting it later.
 		 */
-		if (USB_PERSIST &amp;&amp; udev-&gt;persist_enabled &amp;&amp; status == 0 &amp;&amp;
+		if (udev-&gt;persist_enabled &amp;&amp; status == 0 &amp;&amp;
 				!(portstatus &amp; USB_PORT_STAT_ENABLE)) {
 			if (portchange &amp; USB_PORT_STAT_C_ENABLE)
 				clear_port_feature(hub-&gt;hdev, port1,
@@ -1923,9 +1917,8 @@ static int finish_port_resume(struct usb_device *udev)
  * the host and the device is the same as it was when the device
  * suspended.
  *
- * If CONFIG_USB_PERSIST and @udev-&gt;reset_resume are both set then this
- * routine won't check that the port is still enabled.  Furthermore,
- * if @udev-&gt;reset_resume is set then finish_port_resume() above will
+ * If @udev-&gt;reset_resume is set then this routine won't check that the
+ * port is still enabled.  Furthermore, finish_port_resume() above will
  * reset @udev.  The end result is that a broken power session can be
  * recovered and @udev will appear to persist across a loss of VBUS power.
  *
@@ -1937,8 +1930,8 @@ static int finish_port_resume(struct usb_device *udev)
  * to it will be lost.  Using the USB_PERSIST facility, the device can be
  * made to appear as if it had not disconnected.
  *
- * This facility is inherently dangerous.  Although usb_reset_device()
- * makes every effort to insure that the same device is present after the
+ * This facility can be dangerous.  Although usb_reset_device() makes
+ * every effort to insure that the same device is present after the
  * reset as before, it cannot provide a 100% guarantee.  Furthermore it's
  * quite possible for a device to remain unaltered but its media to be
  * changed.  If the user replaces a flash memory card while the system is
@@ -1983,7 +1976,7 @@ int usb_port_resume(struct usb_device *udev)
 		status = hub_port_status(hub, port1, &amp;portstatus, &amp;portchange);
 
  SuspendCleared:
-		if (USB_PERSIST &amp;&amp; udev-&gt;reset_resume)
+		if (udev-&gt;reset_resume)
 			want_flags = USB_PORT_STAT_POWER
 					| USB_PORT_STAT_CONNECTION;
 		else
@@ -2113,10 +2106,10 @@ static int hub_reset_resume(struct usb_interface *intf)
  *
  * The USB host controller driver calls this function when its root hub
  * is resumed and Vbus power has been interrupted or the controller
- * has been reset.  The routine marks @rhdev as having lost power.  When
- * the hub driver is resumed it will take notice; if CONFIG_USB_PERSIST
- * is enabled then it will carry out power-session recovery, otherwise
- * it will disconnect all the child devices.
+ * has been reset.  The routine marks @rhdev as having lost power.
+ * When the hub driver is resumed it will take notice and carry out
+ * power-session recovery for all the "USB-PERSIST"-enabled child devices;
+ * the others will be disconnected.
  */
 void usb_root_hub_lost_power(struct usb_device *rhdev)
 {
diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c
index dfc5418ea10c..f384edf35b44 100644
--- a/drivers/usb/core/quirks.c
+++ b/drivers/usb/core/quirks.c
@@ -97,4 +97,16 @@ void usb_detect_quirks(struct usb_device *udev)
 	if (udev-&gt;descriptor.bDeviceClass != USB_CLASS_HUB)
 		udev-&gt;autosuspend_disabled = 1;
 #endif
+
+#ifdef	CONFIG_PM
+	/* Hubs are automatically enabled for USB-PERSIST */
+	if (udev-&gt;descriptor.bDeviceClass == USB_CLASS_HUB)
+		udev-&gt;persist_enabled = 1;
+#else
+	/* In the absense of PM, we can safely enable USB-PERSIST
+	 * for all devices.  It will affect things like hub resets
+	 * and EMF-related port disables.
+	 */
+	udev-&gt;persist_enabled = 1;
+#endif	/* CONFIG_PM */
 }
diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c
index a37ccbd1e007..5b20a60de8ba 100644
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -180,11 +180,9 @@ show_urbnum(struct device *dev, struct device_attribute *attr, char *buf)
 static DEVICE_ATTR(urbnum, S_IRUGO, show_urbnum, NULL);
 
 
-#if defined(CONFIG_USB_PERSIST) || defined(CONFIG_USB_SUSPEND)
-static const char power_group[] = "power";
-#endif
+#ifdef	CONFIG_PM
 
-#ifdef	CONFIG_USB_PERSIST
+static const char power_group[] = "power";
 
 static ssize_t
 show_persist(struct device *dev, struct device_attribute *attr, char *buf)
@@ -222,12 +220,13 @@ static int add_persist_attributes(struct device *dev)
 	if (is_usb_device(dev)) {
 		struct usb_device *udev = to_usb_device(dev);
 
-		/* Hubs are automatically enabled for USB_PERSIST */
-		if (udev-&gt;descriptor.bDeviceClass == USB_CLASS_HUB)
-			udev-&gt;persist_enabled = 1;
-		rc = sysfs_add_file_to_group(&amp;dev-&gt;kobj,
-				&amp;dev_attr_persist.attr,
-				power_group);
+		/* Hubs are automatically enabled for USB_PERSIST,
+		 * no point in creating the attribute file.
+		 */
+		if (udev-&gt;descriptor.bDeviceClass != USB_CLASS_HUB)
+			rc = sysfs_add_file_to_group(&amp;dev-&gt;kobj,
+					&amp;dev_attr_persist.attr,
+					power_group);
 	}
 	return rc;
 }
@@ -238,13 +237,12 @@ static void remove_persist_attributes(struct device *dev)
 			&amp;dev_attr_persist.attr,
 			power_group);
 }
-
 #else
 
 #define add_persist_attributes(dev)	0
 #define remove_persist_attributes(dev)	do {} while (0)
 
-#endif	/* CONFIG_USB_PERSIST */
+#endif	/* CONFIG_PM */
 
 #ifdef	CONFIG_USB_SUSPEND
 
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 8d513a15d0cd..fea9e47192db 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -28,7 +28,7 @@
 
 /*-------------------------------------------------------------------------*/
 
-#ifdef	CONFIG_USB_PERSIST
+#ifdef	CONFIG_PM
 
 static int ehci_hub_control(
 	struct usb_hcd	*hcd,
@@ -104,15 +104,6 @@ static void ehci_handover_companion_ports(struct ehci_hcd *ehci)
 	ehci-&gt;owned_ports = 0;
 }
 
-#else	/* CONFIG_USB_PERSIST */
-
-static inline void ehci_handover_companion_ports(struct ehci_hcd *ehci)
-{ }
-
-#endif
-
-#ifdef	CONFIG_PM
-
 static int ehci_bus_suspend (struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 583e0481dfa0..7e31cacfe69c 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -387,6 +387,7 @@ struct usb_device {
 
 	unsigned can_submit:1;		/* URBs may be submitted */
 	unsigned discon_suspended:1;	/* Disconnected while suspended */
+	unsigned persist_enabled:1;	/* USB_PERSIST enabled for this dev */
 	unsigned have_langid:1;		/* whether string_langid is valid */
 	unsigned authorized:1;		/* Policy has said we can use it */
 	unsigned wusb:1;		/* Device is Wireless USB */
@@ -433,7 +434,6 @@ struct usb_device {
 	unsigned auto_pm:1;		/* autosuspend/resume in progress */
 	unsigned do_remote_wakeup:1;	/* remote wakeup should be enabled */
 	unsigned reset_resume:1;	/* needs reset instead of resume */
-	unsigned persist_enabled:1;	/* USB_PERSIST enabled for this dev */
 	unsigned autosuspend_disabled:1; /* autosuspend and autoresume */
 	unsigned autoresume_disabled:1;  /*  disabled by the user */
 	unsigned skip_sys_resume:1;	/* skip the next system resume */</pre>
    <div class="pagination">
        <a href='2_93.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><span>[94]</span><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_95.html'>Next&gt;&gt;</a>
    <div>
</body>
