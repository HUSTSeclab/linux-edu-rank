<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_113.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><span>[114]</span><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_115.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit e6316565e568b3b5733be10cfca3c27259bef499
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jan 16 11:58:00 2007 -0500

    EHCI: local variable for port status register
    
    This patch (as708) introduces a local variable to hold the port
    status-register address in ehci-hub.c.  There's not much improvement
    in the object code, but it sure is a lot easier to read.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: David Brownell &lt;dbrownell@users.sourceforge.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index df00fcbadfbc..12f881ff4b23 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -193,6 +193,7 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 static int check_reset_complete (
 	struct ehci_hcd	*ehci,
 	int		index,
+	u32 __iomem	*status_reg,
 	int		port_status
 ) {
 	if (!(port_status &amp; PORT_CONNECT)) {
@@ -217,8 +218,7 @@ static int check_reset_complete (
 		// what happens if HCS_N_CC(params) == 0 ?
 		port_status |= PORT_OWNER;
 		port_status &amp;= ~PORT_RWC_BITS;
-		ehci_writel(ehci, port_status,
-			    &amp;ehci-&gt;regs-&gt;port_status [index]);
+		ehci_writel(ehci, port_status, status_reg);
 
 	} else
 		ehci_dbg (ehci, "port %d high speed\n", index + 1);
@@ -347,6 +347,7 @@ static int ehci_hub_control (
 ) {
 	struct ehci_hcd	*ehci = hcd_to_ehci (hcd);
 	int		ports = HCS_N_PORTS (ehci-&gt;hcs_params);
+	u32 __iomem	*status_reg = &amp;ehci-&gt;regs-&gt;port_status[wIndex - 1];
 	u32		temp, status;
 	unsigned long	flags;
 	int		retval = 0;
@@ -375,18 +376,17 @@ static int ehci_hub_control (
 		if (!wIndex || wIndex &gt; ports)
 			goto error;
 		wIndex--;
-		temp = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;port_status [wIndex]);
+		temp = ehci_readl(ehci, status_reg);
 		if (temp &amp; PORT_OWNER)
 			break;
 
 		switch (wValue) {
 		case USB_PORT_FEAT_ENABLE:
-			ehci_writel(ehci, temp &amp; ~PORT_PE,
-				    &amp;ehci-&gt;regs-&gt;port_status [wIndex]);
+			ehci_writel(ehci, temp &amp; ~PORT_PE, status_reg);
 			break;
 		case USB_PORT_FEAT_C_ENABLE:
 			ehci_writel(ehci, (temp &amp; ~PORT_RWC_BITS) | PORT_PEC,
-				    &amp;ehci-&gt;regs-&gt;port_status [wIndex]);
+					status_reg);
 			break;
 		case USB_PORT_FEAT_SUSPEND:
 			if (temp &amp; PORT_RESET)
@@ -399,7 +399,7 @@ static int ehci_hub_control (
 				/* resume signaling for 20 msec */
 				temp &amp;= ~(PORT_RWC_BITS | PORT_WAKE_BITS);
 				ehci_writel(ehci, temp | PORT_RESUME,
-					    &amp;ehci-&gt;regs-&gt;port_status [wIndex]);
+						status_reg);
 				ehci-&gt;reset_done [wIndex] = jiffies
 						+ msecs_to_jiffies (20);
 			}
@@ -411,15 +411,15 @@ static int ehci_hub_control (
 			if (HCS_PPC (ehci-&gt;hcs_params))
 				ehci_writel(ehci,
 					  temp &amp; ~(PORT_RWC_BITS | PORT_POWER),
-					  &amp;ehci-&gt;regs-&gt;port_status [wIndex]);
+					  status_reg);
 			break;
 		case USB_PORT_FEAT_C_CONNECTION:
 			ehci_writel(ehci, (temp &amp; ~PORT_RWC_BITS) | PORT_CSC,
-				    &amp;ehci-&gt;regs-&gt;port_status [wIndex]);
+					status_reg);
 			break;
 		case USB_PORT_FEAT_C_OVER_CURRENT:
 			ehci_writel(ehci, (temp &amp; ~PORT_RWC_BITS) | PORT_OCC,
-				    &amp;ehci-&gt;regs-&gt;port_status [wIndex]);
+					status_reg);
 			break;
 		case USB_PORT_FEAT_C_RESET:
 			/* GetPortStatus clears reset */
@@ -443,7 +443,7 @@ static int ehci_hub_control (
 			goto error;
 		wIndex--;
 		status = 0;
-		temp = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;port_status [wIndex]);
+		temp = ehci_readl(ehci, status_reg);
 
 		// wPortChange bits
 		if (temp &amp; PORT_CSC)
@@ -461,13 +461,11 @@ static int ehci_hub_control (
 			ehci-&gt;reset_done [wIndex] = 0;
 
 			/* stop resume signaling */
-			temp = ehci_readl(ehci,
-					  &amp;ehci-&gt;regs-&gt;port_status [wIndex]);
+			temp = ehci_readl(ehci, status_reg);
 			ehci_writel(ehci,
-				    temp &amp; ~(PORT_RWC_BITS | PORT_RESUME),
-				    &amp;ehci-&gt;regs-&gt;port_status [wIndex]);
-			retval = handshake(ehci,
-					   &amp;ehci-&gt;regs-&gt;port_status [wIndex],
+					temp &amp; ~(PORT_RWC_BITS | PORT_RESUME),
+					status_reg);
+			retval = handshake(ehci, status_reg,
 					   PORT_RESUME, 0, 2000 /* 2msec */);
 			if (retval != 0) {
 				ehci_err (ehci, "port %d resume error %d\n",
@@ -486,12 +484,11 @@ static int ehci_hub_control (
 
 			/* force reset to complete */
 			ehci_writel(ehci, temp &amp; ~(PORT_RWC_BITS | PORT_RESET),
-				    &amp;ehci-&gt;regs-&gt;port_status [wIndex]);
+					status_reg);
 			/* REVISIT:  some hardware needs 550+ usec to clear
 			 * this bit; seems too long to spin routinely...
 			 */
-			retval = handshake(ehci,
-					   &amp;ehci-&gt;regs-&gt;port_status [wIndex],
+			retval = handshake(ehci, status_reg,
 					PORT_RESET, 0, 750);
 			if (retval != 0) {
 				ehci_err (ehci, "port %d reset error %d\n",
@@ -500,9 +497,8 @@ static int ehci_hub_control (
 			}
 
 			/* see what we found out */
-			temp = check_reset_complete (ehci, wIndex,
-				ehci_readl(ehci,
-					   &amp;ehci-&gt;regs-&gt;port_status [wIndex]));
+			temp = check_reset_complete (ehci, wIndex, status_reg,
+					ehci_readl(ehci, status_reg));
 		}
 
 		// don't show wPortStatus if it's owned by a companion hc
@@ -547,7 +543,7 @@ static int ehci_hub_control (
 		if (!wIndex || wIndex &gt; ports)
 			goto error;
 		wIndex--;
-		temp = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;port_status [wIndex]);
+		temp = ehci_readl(ehci, status_reg);
 		if (temp &amp; PORT_OWNER)
 			break;
 
@@ -561,13 +557,12 @@ static int ehci_hub_control (
 				goto error;
 			if (device_may_wakeup(&amp;hcd-&gt;self.root_hub-&gt;dev))
 				temp |= PORT_WAKE_BITS;
-			ehci_writel(ehci, temp | PORT_SUSPEND,
-				    &amp;ehci-&gt;regs-&gt;port_status [wIndex]);
+			ehci_writel(ehci, temp | PORT_SUSPEND, status_reg);
 			break;
 		case USB_PORT_FEAT_POWER:
 			if (HCS_PPC (ehci-&gt;hcs_params))
 				ehci_writel(ehci, temp | PORT_POWER,
-					    &amp;ehci-&gt;regs-&gt;port_status [wIndex]);
+						status_reg);
 			break;
 		case USB_PORT_FEAT_RESET:
 			if (temp &amp; PORT_RESUME)
@@ -595,8 +590,7 @@ static int ehci_hub_control (
 				ehci-&gt;reset_done [wIndex] = jiffies
 						+ msecs_to_jiffies (50);
 			}
-			ehci_writel(ehci, temp,
-				    &amp;ehci-&gt;regs-&gt;port_status [wIndex]);
+			ehci_writel(ehci, temp, status_reg);
 			break;
 
 		/* For downstream facing ports (these):  one hub port is put
@@ -611,8 +605,7 @@ static int ehci_hub_control (
 			ehci_quiesce(ehci);
 			ehci_halt(ehci);
 			temp |= selector &lt;&lt; 16;
-			ehci_writel(ehci, temp,
-				    &amp;ehci-&gt;regs-&gt;port_status [wIndex]);
+			ehci_writel(ehci, temp, status_reg);
 			break;
 
 		default:</pre><hr><pre>commit 896fbd7199035958013d106329843d8ae9618753
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jan 16 11:57:13 2007 -0500

    usbcore: remove unused bandwith-related code
    
    This patch (as841) removes from usbcore a couple of support routines
    meant to help with bandwidth allocation.  With the changes to uhci-hcd
    in the previous patch, these routines are no longer used anywhere.
    Also removed is the CONFIG_USB_BANDWIDTH option; it no longer does
    anything and is no longer needed since the HCDs now handle bandwidth
    issues correctly.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: David Brownell &lt;dbrownell@users.sourceforge.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/Kconfig b/drivers/usb/core/Kconfig
index 3e66b2a9974a..2fc0f88a3d86 100644
--- a/drivers/usb/core/Kconfig
+++ b/drivers/usb/core/Kconfig
@@ -33,19 +33,6 @@ config USB_DEVICEFS
 
 	  Most users want to say Y here.
 
-config USB_BANDWIDTH
-	bool "Enforce USB bandwidth allocation (EXPERIMENTAL)"
-	depends on USB &amp;&amp; EXPERIMENTAL
-	help
-	  If you say Y here, the USB subsystem enforces USB bandwidth
-	  allocation and will prevent some device opens from succeeding
-	  if they would cause USB bandwidth usage to go above 90% of
-	  the bus bandwidth.
-
-	  If you say N here, these conditions will cause warning messages
-	  about USB bandwidth usage to be logged and some devices or
-	  drivers may not work correctly.
-
 config USB_DYNAMIC_MINORS
 	bool "Dynamic USB minor allocation (EXPERIMENTAL)"
 	depends on USB &amp;&amp; EXPERIMENTAL
diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 10064af65d17..b26c19e8d19f 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -45,8 +45,6 @@
 #include "hub.h"
 
 
-// #define USB_BANDWIDTH_MESSAGES
-
 /*-------------------------------------------------------------------------*/
 
 /*
@@ -891,136 +889,6 @@ long usb_calc_bus_time (int speed, int is_input, int isoc, int bytecount)
 }
 EXPORT_SYMBOL (usb_calc_bus_time);
 
-/*
- * usb_check_bandwidth():
- *
- * old_alloc is from host_controller-&gt;bandwidth_allocated in microseconds;
- * bustime is from calc_bus_time(), but converted to microseconds.
- *
- * returns &lt;bustime in us&gt; if successful,
- * or -ENOSPC if bandwidth request fails.
- *
- * FIXME:
- * This initial implementation does not use Endpoint.bInterval
- * in managing bandwidth allocation.
- * It probably needs to be expanded to use Endpoint.bInterval.
- * This can be done as a later enhancement (correction).
- *
- * This will also probably require some kind of
- * frame allocation tracking...meaning, for example,
- * that if multiple drivers request interrupts every 10 USB frames,
- * they don't all have to be allocated at
- * frame numbers N, N+10, N+20, etc.  Some of them could be at
- * N+11, N+21, N+31, etc., and others at
- * N+12, N+22, N+32, etc.
- *
- * Similarly for isochronous transfers...
- *
- * Individual HCDs can schedule more directly ... this logic
- * is not correct for high speed transfers.
- */
-int usb_check_bandwidth (struct usb_device *dev, struct urb *urb)
-{
-	unsigned int	pipe = urb-&gt;pipe;
-	long		bustime;
-	int		is_in = usb_pipein (pipe);
-	int		is_iso = usb_pipeisoc (pipe);
-	int		old_alloc = dev-&gt;bus-&gt;bandwidth_allocated;
-	int		new_alloc;
-
-
-	bustime = NS_TO_US (usb_calc_bus_time (dev-&gt;speed, is_in, is_iso,
-			usb_maxpacket (dev, pipe, !is_in)));
-	if (is_iso)
-		bustime /= urb-&gt;number_of_packets;
-
-	new_alloc = old_alloc + (int) bustime;
-	if (new_alloc &gt; FRAME_TIME_MAX_USECS_ALLOC) {
-#ifdef	DEBUG
-		char	*mode = 
-#ifdef CONFIG_USB_BANDWIDTH
-			"";
-#else
-			"would have ";
-#endif
-		dev_dbg (&amp;dev-&gt;dev, "usb_check_bandwidth %sFAILED: %d + %ld = %d usec\n",
-			mode, old_alloc, bustime, new_alloc);
-#endif
-#ifdef CONFIG_USB_BANDWIDTH
-		bustime = -ENOSPC;	/* report error */
-#endif
-	}
-
-	return bustime;
-}
-EXPORT_SYMBOL (usb_check_bandwidth);
-
-
-/**
- * usb_claim_bandwidth - records bandwidth for a periodic transfer
- * @dev: source/target of request
- * @urb: request (urb-&gt;dev == dev)
- * @bustime: bandwidth consumed, in (average) microseconds per frame
- * @isoc: true iff the request is isochronous
- *
- * Bus bandwidth reservations are recorded purely for diagnostic purposes.
- * HCDs are expected not to overcommit periodic bandwidth, and to record such
- * reservations whenever endpoints are added to the periodic schedule.
- *
- * FIXME averaging per-frame is suboptimal.  Better to sum over the HCD's
- * entire periodic schedule ... 32 frames for OHCI, 1024 for UHCI, settable
- * for EHCI (256/512/1024 frames, default 1024) and have the bus expose how
- * large its periodic schedule is.
- */
-void usb_claim_bandwidth (struct usb_device *dev, struct urb *urb, int bustime, int isoc)
-{
-	dev-&gt;bus-&gt;bandwidth_allocated += bustime;
-	if (isoc)
-		dev-&gt;bus-&gt;bandwidth_isoc_reqs++;
-	else
-		dev-&gt;bus-&gt;bandwidth_int_reqs++;
-	urb-&gt;bandwidth = bustime;
-
-#ifdef USB_BANDWIDTH_MESSAGES
-	dev_dbg (&amp;dev-&gt;dev, "bandwidth alloc increased by %d (%s) to %d for %d requesters\n",
-		bustime,
-		isoc ? "ISOC" : "INTR",
-		dev-&gt;bus-&gt;bandwidth_allocated,
-		dev-&gt;bus-&gt;bandwidth_int_reqs + dev-&gt;bus-&gt;bandwidth_isoc_reqs);
-#endif
-}
-EXPORT_SYMBOL (usb_claim_bandwidth);
-
-
-/**
- * usb_release_bandwidth - reverses effect of usb_claim_bandwidth()
- * @dev: source/target of request
- * @urb: request (urb-&gt;dev == dev)
- * @isoc: true iff the request is isochronous
- *
- * This records that previously allocated bandwidth has been released.
- * Bandwidth is released when endpoints are removed from the host controller's
- * periodic schedule.
- */
-void usb_release_bandwidth (struct usb_device *dev, struct urb *urb, int isoc)
-{
-	dev-&gt;bus-&gt;bandwidth_allocated -= urb-&gt;bandwidth;
-	if (isoc)
-		dev-&gt;bus-&gt;bandwidth_isoc_reqs--;
-	else
-		dev-&gt;bus-&gt;bandwidth_int_reqs--;
-
-#ifdef USB_BANDWIDTH_MESSAGES
-	dev_dbg (&amp;dev-&gt;dev, "bandwidth alloc reduced by %d (%s) to %d for %d requesters\n",
-		urb-&gt;bandwidth,
-		isoc ? "ISOC" : "INTR",
-		dev-&gt;bus-&gt;bandwidth_allocated,
-		dev-&gt;bus-&gt;bandwidth_int_reqs + dev-&gt;bus-&gt;bandwidth_isoc_reqs);
-#endif
-	urb-&gt;bandwidth = 0;
-}
-EXPORT_SYMBOL (usb_release_bandwidth);
-
 
 /*-------------------------------------------------------------------------*/
 
@@ -1034,11 +902,6 @@ static void urb_unlink (struct urb *urb)
 {
 	unsigned long		flags;
 
-	/* Release any periodic transfer bandwidth */
-	if (urb-&gt;bandwidth)
-		usb_release_bandwidth (urb-&gt;dev, urb,
-			usb_pipeisoc (urb-&gt;pipe));
-
 	/* clear all state linking urb to this dev (and hcd) */
 
 	spin_lock_irqsave (&amp;hcd_data_lock, flags);
diff --git a/drivers/usb/core/hcd.h b/drivers/usb/core/hcd.h
index 8f8df0d4382e..2a269ca20517 100644
--- a/drivers/usb/core/hcd.h
+++ b/drivers/usb/core/hcd.h
@@ -308,10 +308,6 @@ extern void usb_destroy_configuration(struct usb_device *dev);
 #define NS_TO_US(ns)	((ns + 500L) / 1000L)
 			/* convert &amp; round nanoseconds to microseconds */
 
-extern void usb_claim_bandwidth (struct usb_device *dev, struct urb *urb,
-		int bustime, int isoc);
-extern void usb_release_bandwidth (struct usb_device *dev, struct urb *urb,
-		int isoc);
 
 /*
  * Full/low speed bandwidth allocation constants/support.
@@ -324,8 +320,6 @@ extern void usb_release_bandwidth (struct usb_device *dev, struct urb *urb,
 #define FRAME_TIME_MAX_BITS_ALLOC	(90L * FRAME_TIME_BITS / 100L)
 #define FRAME_TIME_MAX_USECS_ALLOC	(90L * FRAME_TIME_USECS / 100L)
 
-extern int usb_check_bandwidth (struct usb_device *dev, struct urb *urb);
-
 /*
  * Ceiling [nano/micro]seconds (typical) for that many bytes at high speed
  * ISO is a bit less, no ACK ... from USB 2.0 spec, 5.11.3 (and needed
diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 9801d08edacf..a4fa3e66c307 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -235,7 +235,6 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 
 	urb-&gt;status = -EINPROGRESS;
 	urb-&gt;actual_length = 0;
-	urb-&gt;bandwidth = 0;
 
 	/* Lots of sanity checks, so HCDs can rely on clean data
 	 * and don't need to duplicate tests
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 1c56386de709..3b08ab39550f 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1110,7 +1110,6 @@ struct urb
 	struct kref kref;		/* reference count of the URB */
 	spinlock_t lock;		/* lock for the URB */
 	void *hcpriv;			/* private data for host controller */
-	int bandwidth;			/* bandwidth for INT/ISO request */
 	atomic_t use_count;		/* concurrent submissions counter */
 	u8 reject;			/* submissions will fail */
 </pre><hr><pre>commit 3ca2a3211ee5078d49b04fe7149ff2a76473be51
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jan 16 11:56:32 2007 -0500

    UHCI: fix bandwidth allocation
    
    This patch (as840) fixes the bandwidth allocation mechanism in
    uhci-hcd.  It has never worked correctly.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-debug.c b/drivers/usb/host/uhci-debug.c
index 3fbb5ba80249..5d6c06bc4524 100644
--- a/drivers/usb/host/uhci-debug.c
+++ b/drivers/usb/host/uhci-debug.c
@@ -168,9 +168,13 @@ static int uhci_show_qh(struct uhci_qh *qh, char *buf, int len, int space)
 			space, "", qh, qtype,
 			le32_to_cpu(qh-&gt;link), le32_to_cpu(element));
 	if (qh-&gt;type == USB_ENDPOINT_XFER_ISOC)
-		out += sprintf(out, "%*s    period %d frame %x desc [%p]\n",
-				space, "", qh-&gt;period, qh-&gt;iso_frame,
-				qh-&gt;iso_packet_desc);
+		out += sprintf(out, "%*s    period %d phase %d load %d us, "
+				"frame %x desc [%p]\n",
+				space, "", qh-&gt;period, qh-&gt;phase, qh-&gt;load,
+				qh-&gt;iso_frame, qh-&gt;iso_packet_desc);
+	else if (qh-&gt;type == USB_ENDPOINT_XFER_INT)
+		out += sprintf(out, "%*s    period %d phase %d load %d us\n",
+				space, "", qh-&gt;period, qh-&gt;phase, qh-&gt;load);
 
 	if (element &amp; UHCI_PTR_QH)
 		out += sprintf(out, "%*s  Element points to QH (bug?)\n", space, "");
@@ -352,6 +356,17 @@ static int uhci_sprint_schedule(struct uhci_hcd *uhci, char *buf, int len)
 	out += uhci_show_root_hub_state(uhci, out, len - (out - buf));
 	out += sprintf(out, "HC status\n");
 	out += uhci_show_status(uhci, out, len - (out - buf));
+
+	out += sprintf(out, "Periodic load table\n");
+	for (i = 0; i &lt; MAX_PHASE; ++i) {
+		out += sprintf(out, "\t%d", uhci-&gt;load[i]);
+		if (i % 8 == 7)
+			*out++ = '\n';
+	}
+	out += sprintf(out, "Total: %d, #INT: %d, #ISO: %d\n",
+			uhci-&gt;total_load,
+			uhci_to_hcd(uhci)-&gt;self.bandwidth_int_reqs,
+			uhci_to_hcd(uhci)-&gt;self.bandwidth_isoc_reqs);
 	if (debug &lt;= 1)
 		return out - buf;
 
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index 108e3de2dc26..74469b5bcb61 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -83,6 +83,7 @@
 #define UHCI_MAX_SOF_NUMBER	2047	/* in an SOF packet */
 #define CAN_SCHEDULE_FRAMES	1000	/* how far in the future frames
 					 * can be scheduled */
+#define MAX_PHASE		32	/* Periodic scheduling length */
 
 /* When no queues need Full-Speed Bandwidth Reclamation,
  * delay this long before turning FSBR off */
@@ -141,6 +142,8 @@ struct uhci_qh {
 	unsigned long advance_jiffies;	/* Time of last queue advance */
 	unsigned int unlink_frame;	/* When the QH was unlinked */
 	unsigned int period;		/* For Interrupt and Isochronous QHs */
+	short phase;			/* Between 0 and period-1 */
+	short load;			/* Periodic time requirement, in us */
 	unsigned int iso_frame;		/* Frame # for iso_packet_desc */
 	int iso_status;			/* Status for Isochronous URBs */
 
@@ -153,6 +156,8 @@ struct uhci_qh {
 	unsigned int needs_fixup:1;	/* Must fix the TD toggle values */
 	unsigned int is_stopped:1;	/* Queue was stopped by error/unlink */
 	unsigned int wait_expired:1;	/* QH_WAIT_TIMEOUT has expired */
+	unsigned int bandwidth_reserved:1;	/* Periodic bandwidth has
+						 * been allocated */
 } __attribute__((aligned(16)));
 
 /*
@@ -414,6 +419,9 @@ struct uhci_hcd {
 
 	wait_queue_head_t waitqh;		/* endpoint_disable waiters */
 	int num_waiting;			/* Number of waiters */
+
+	int total_load;				/* Sum of array values */
+	short load[MAX_PHASE];			/* Periodic allocations */
 };
 
 /* Convert between a usb_hcd pointer and the corresponding uhci_hcd */
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 5afcc5227284..2cbb239e63f8 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -261,6 +261,14 @@ static struct uhci_qh *uhci_alloc_qh(struct uhci_hcd *uhci,
 		qh-&gt;udev = udev;
 		hep-&gt;hcpriv = qh;
 
+		if (qh-&gt;type == USB_ENDPOINT_XFER_INT ||
+				qh-&gt;type == USB_ENDPOINT_XFER_ISOC)
+			qh-&gt;load = usb_calc_bus_time(udev-&gt;speed,
+					usb_endpoint_dir_in(&amp;hep-&gt;desc),
+					qh-&gt;type == USB_ENDPOINT_XFER_ISOC,
+					le16_to_cpu(hep-&gt;desc.wMaxPacketSize))
+				/ 1000 + 1;
+
 	} else {		/* Skeleton QH */
 		qh-&gt;state = QH_STATE_ACTIVE;
 		qh-&gt;type = -1;
@@ -496,6 +504,121 @@ static void uhci_make_qh_idle(struct uhci_hcd *uhci, struct uhci_qh *qh)
 		wake_up_all(&amp;uhci-&gt;waitqh);
 }
 
+/*
+ * Find the highest existing bandwidth load for a given phase and period.
+ */
+static int uhci_highest_load(struct uhci_hcd *uhci, int phase, int period)
+{
+	int highest_load = uhci-&gt;load[phase];
+
+	for (phase += period; phase &lt; MAX_PHASE; phase += period)
+		highest_load = max_t(int, highest_load, uhci-&gt;load[phase]);
+	return highest_load;
+}
+
+/*
+ * Set qh-&gt;phase to the optimal phase for a periodic transfer and
+ * check whether the bandwidth requirement is acceptable.
+ */
+static int uhci_check_bandwidth(struct uhci_hcd *uhci, struct uhci_qh *qh)
+{
+	int minimax_load;
+
+	/* Find the optimal phase (unless it is already set) and get
+	 * its load value. */
+	if (qh-&gt;phase &gt;= 0)
+		minimax_load = uhci_highest_load(uhci, qh-&gt;phase, qh-&gt;period);
+	else {
+		int phase, load;
+		int max_phase = min_t(int, MAX_PHASE, qh-&gt;period);
+
+		qh-&gt;phase = 0;
+		minimax_load = uhci_highest_load(uhci, qh-&gt;phase, qh-&gt;period);
+		for (phase = 1; phase &lt; max_phase; ++phase) {
+			load = uhci_highest_load(uhci, phase, qh-&gt;period);
+			if (load &lt; minimax_load) {
+				minimax_load = load;
+				qh-&gt;phase = phase;
+			}
+		}
+	}
+
+	/* Maximum allowable periodic bandwidth is 90%, or 900 us per frame */
+	if (minimax_load + qh-&gt;load &gt; 900) {
+		dev_dbg(uhci_dev(uhci), "bandwidth allocation failed: "
+				"period %d, phase %d, %d + %d us\n",
+				qh-&gt;period, qh-&gt;phase, minimax_load, qh-&gt;load);
+		return -ENOSPC;
+	}
+	return 0;
+}
+
+/*
+ * Reserve a periodic QH's bandwidth in the schedule
+ */
+static void uhci_reserve_bandwidth(struct uhci_hcd *uhci, struct uhci_qh *qh)
+{
+	int i;
+	int load = qh-&gt;load;
+	char *p = "??";
+
+	for (i = qh-&gt;phase; i &lt; MAX_PHASE; i += qh-&gt;period) {
+		uhci-&gt;load[i] += load;
+		uhci-&gt;total_load += load;
+	}
+	uhci_to_hcd(uhci)-&gt;self.bandwidth_allocated =
+			uhci-&gt;total_load / MAX_PHASE;
+	switch (qh-&gt;type) {
+	case USB_ENDPOINT_XFER_INT:
+		++uhci_to_hcd(uhci)-&gt;self.bandwidth_int_reqs;
+		p = "INT";
+		break;
+	case USB_ENDPOINT_XFER_ISOC:
+		++uhci_to_hcd(uhci)-&gt;self.bandwidth_isoc_reqs;
+		p = "ISO";
+		break;
+	}
+	qh-&gt;bandwidth_reserved = 1;
+	dev_dbg(uhci_dev(uhci),
+			"%s dev %d ep%02x-%s, period %d, phase %d, %d us\n",
+			"reserve", qh-&gt;udev-&gt;devnum,
+			qh-&gt;hep-&gt;desc.bEndpointAddress, p,
+			qh-&gt;period, qh-&gt;phase, load);
+}
+
+/*
+ * Release a periodic QH's bandwidth reservation
+ */
+static void uhci_release_bandwidth(struct uhci_hcd *uhci, struct uhci_qh *qh)
+{
+	int i;
+	int load = qh-&gt;load;
+	char *p = "??";
+
+	for (i = qh-&gt;phase; i &lt; MAX_PHASE; i += qh-&gt;period) {
+		uhci-&gt;load[i] -= load;
+		uhci-&gt;total_load -= load;
+	}
+	uhci_to_hcd(uhci)-&gt;self.bandwidth_allocated =
+			uhci-&gt;total_load / MAX_PHASE;
+	switch (qh-&gt;type) {
+	case USB_ENDPOINT_XFER_INT:
+		--uhci_to_hcd(uhci)-&gt;self.bandwidth_int_reqs;
+		p = "INT";
+		break;
+	case USB_ENDPOINT_XFER_ISOC:
+		--uhci_to_hcd(uhci)-&gt;self.bandwidth_isoc_reqs;
+		p = "ISO";
+		break;
+	}
+	qh-&gt;bandwidth_reserved = 0;
+	dev_dbg(uhci_dev(uhci),
+			"%s dev %d ep%02x-%s, period %d, phase %d, %d us\n",
+			"release", qh-&gt;udev-&gt;devnum,
+			qh-&gt;hep-&gt;desc.bEndpointAddress, p,
+			qh-&gt;period, qh-&gt;phase, load);
+}
+
 static inline struct urb_priv *uhci_alloc_urb_priv(struct uhci_hcd *uhci,
 		struct urb *urb)
 {
@@ -799,7 +922,6 @@ static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb,
 	wmb();
 	qh-&gt;dummy_td-&gt;status |= __constant_cpu_to_le32(TD_CTRL_ACTIVE);
 	qh-&gt;dummy_td = td;
-	qh-&gt;period = urb-&gt;interval;
 
 	usb_settoggle(urb-&gt;dev, usb_pipeendpoint(urb-&gt;pipe),
 			usb_pipeout(urb-&gt;pipe), toggle);
@@ -830,28 +952,42 @@ static inline int uhci_submit_bulk(struct uhci_hcd *uhci, struct urb *urb,
 static int uhci_submit_interrupt(struct uhci_hcd *uhci, struct urb *urb,
 		struct uhci_qh *qh)
 {
-	int exponent;
+	int ret;
 
 	/* USB 1.1 interrupt transfers only involve one packet per interval.
 	 * Drivers can submit URBs of any length, but longer ones will need
 	 * multiple intervals to complete.
 	 */
 
-	/* Figure out which power-of-two queue to use */
-	for (exponent = 7; exponent &gt;= 0; --exponent) {
-		if ((1 &lt;&lt; exponent) &lt;= urb-&gt;interval)
-			break;
-	}
-	if (exponent &lt; 0)
-		return -EINVAL;
-	urb-&gt;interval = 1 &lt;&lt; exponent;
+	if (!qh-&gt;bandwidth_reserved) {
+		int exponent;
 
-	if (qh-&gt;period == 0)
+		/* Figure out which power-of-two queue to use */
+		for (exponent = 7; exponent &gt;= 0; --exponent) {
+			if ((1 &lt;&lt; exponent) &lt;= urb-&gt;interval)
+				break;
+		}
+		if (exponent &lt; 0)
+			return -EINVAL;
+		qh-&gt;period = 1 &lt;&lt; exponent;
 		qh-&gt;skel = uhci-&gt;skelqh[UHCI_SKEL_INDEX(exponent)];
-	else if (qh-&gt;period != urb-&gt;interval)
-		return -EINVAL;		/* Can't change the period */
 
-	return uhci_submit_common(uhci, urb, qh);
+		/* For now, interrupt phase is fixed by the layout
+		 * of the QH lists. */
+		qh-&gt;phase = (qh-&gt;period / 2) &amp; (MAX_PHASE - 1);
+		ret = uhci_check_bandwidth(uhci, qh);
+		if (ret)
+			return ret;
+	} else if (qh-&gt;period &gt; urb-&gt;interval)
+		return -EINVAL;		/* Can't decrease the period */
+
+	ret = uhci_submit_common(uhci, urb, qh);
+	if (ret == 0) {
+		urb-&gt;interval = qh-&gt;period;
+		if (!qh-&gt;bandwidth_reserved)
+			uhci_reserve_bandwidth(uhci, qh);
+	}
+	return ret;
 }
 
 /*
@@ -998,15 +1134,32 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb,
 		return -EFBIG;
 
 	/* Check the period and figure out the starting frame number */
-	if (qh-&gt;period == 0) {
+	if (!qh-&gt;bandwidth_reserved) {
+		qh-&gt;period = urb-&gt;interval;
 		if (urb-&gt;transfer_flags &amp; URB_ISO_ASAP) {
+			qh-&gt;phase = -1;		/* Find the best phase */
+			i = uhci_check_bandwidth(uhci, qh);
+			if (i)
+				return i;
+
+			/* Allow a little time to allocate the TDs */
 			uhci_get_current_frame_number(uhci);
-			urb-&gt;start_frame = uhci-&gt;frame_number + 10;
+			frame = uhci-&gt;frame_number + 10;
+
+			/* Move forward to the first frame having the
+			 * correct phase */
+			urb-&gt;start_frame = frame + ((qh-&gt;phase - frame) &amp;
+					(qh-&gt;period - 1));
 		} else {
 			i = urb-&gt;start_frame - uhci-&gt;last_iso_frame;
 			if (i &lt;= 0 || i &gt;= UHCI_NUMFRAMES)
 				return -EINVAL;
+			qh-&gt;phase = urb-&gt;start_frame &amp; (qh-&gt;period - 1);
+			i = uhci_check_bandwidth(uhci, qh);
+			if (i)
+				return i;
 		}
+
 	} else if (qh-&gt;period != urb-&gt;interval) {
 		return -EINVAL;		/* Can't change the period */
 
@@ -1052,9 +1205,6 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb,
 	/* Set the interrupt-on-completion flag on the last packet. */
 	td-&gt;status |= __constant_cpu_to_le32(TD_CTRL_IOC);
 
-	qh-&gt;skel = uhci-&gt;skel_iso_qh;
-	qh-&gt;period = urb-&gt;interval;
-
 	/* Add the TDs to the frame list */
 	frame = urb-&gt;start_frame;
 	list_for_each_entry(td, &amp;urbp-&gt;td_list, list) {
@@ -1068,6 +1218,9 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb,
 		qh-&gt;iso_status = 0;
 	}
 
+	qh-&gt;skel = uhci-&gt;skel_iso_qh;
+	if (!qh-&gt;bandwidth_reserved)
+		uhci_reserve_bandwidth(uhci, qh);
 	return 0;
 }
 
@@ -1122,7 +1275,6 @@ static int uhci_urb_enqueue(struct usb_hcd *hcd,
 	unsigned long flags;
 	struct urb_priv *urbp;
 	struct uhci_qh *qh;
-	int bustime;
 
 	spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
 
@@ -1152,35 +1304,11 @@ static int uhci_urb_enqueue(struct usb_hcd *hcd,
 		ret = uhci_submit_bulk(uhci, urb, qh);
 		break;
 	case USB_ENDPOINT_XFER_INT:
-		if (list_empty(&amp;qh-&gt;queue)) {
-			bustime = usb_check_bandwidth(urb-&gt;dev, urb);
-			if (bustime &lt; 0)
-				ret = bustime;
-			else {
-				ret = uhci_submit_interrupt(uhci, urb, qh);
-				if (ret == 0)
-					usb_claim_bandwidth(urb-&gt;dev, urb, bustime, 0);
-			}
-		} else {	/* inherit from parent */
-			struct urb_priv *eurbp;
-
-			eurbp = list_entry(qh-&gt;queue.prev, struct urb_priv,
-					node);
-			urb-&gt;bandwidth = eurbp-&gt;urb-&gt;bandwidth;
-			ret = uhci_submit_interrupt(uhci, urb, qh);
-		}
+		ret = uhci_submit_interrupt(uhci, urb, qh);
 		break;
 	case USB_ENDPOINT_XFER_ISOC:
 		urb-&gt;error_count = 0;
-		bustime = usb_check_bandwidth(urb-&gt;dev, urb);
-		if (bustime &lt; 0) {
-			ret = bustime;
-			break;
-		}
-
 		ret = uhci_submit_isochronous(uhci, urb, qh);
-		if (ret == 0)
-			usb_claim_bandwidth(urb-&gt;dev, urb, bustime, 1);
 		break;
 	}
 	if (ret != 0)
@@ -1277,24 +1405,6 @@ __acquires(uhci-&gt;lock)
 
 	uhci_free_urb_priv(uhci, urbp);
 
-	switch (qh-&gt;type) {
-	case USB_ENDPOINT_XFER_ISOC:
-		/* Release bandwidth for Interrupt or Isoc. transfers */
-		if (urb-&gt;bandwidth)
-			usb_release_bandwidth(urb-&gt;dev, urb, 1);
-		break;
-	case USB_ENDPOINT_XFER_INT:
-		/* Release bandwidth for Interrupt or Isoc. transfers */
-		/* Make sure we don't release if we have a queued URB */
-		if (list_empty(&amp;qh-&gt;queue) &amp;&amp; urb-&gt;bandwidth)
-			usb_release_bandwidth(urb-&gt;dev, urb, 0);
-		else
-			/* bandwidth was passed on to queued URB, */
-			/* so don't let usb_unlink_urb() release it */
-			urb-&gt;bandwidth = 0;
-		break;
-	}
-
 	spin_unlock(&amp;uhci-&gt;lock);
 	usb_hcd_giveback_urb(uhci_to_hcd(uhci), urb);
 	spin_lock(&amp;uhci-&gt;lock);
@@ -1303,9 +1413,8 @@ __acquires(uhci-&gt;lock)
 	 * reserved bandwidth. */
 	if (list_empty(&amp;qh-&gt;queue)) {
 		uhci_unlink_qh(uhci, qh);
-
-		/* Bandwidth stuff not yet implemented */
-		qh-&gt;period = 0;
+		if (qh-&gt;bandwidth_reserved)
+			uhci_release_bandwidth(uhci, qh);
 	}
 }
 </pre><hr><pre>commit f3f4906516a084bbd9aa3da7592e6b029fe78f5b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jan 8 16:18:05 2007 -0500

    usb-storage: SCSI level fixes
    
    This patch (as835) removes from usb-storage the code which sets all
    devices to a SCSI level of at least SCSI-2.  The original reasons for
    doing this no longer apply, and in fact it prevents certain kinds of
    ATA pass-thru commands from being used.
    
    The patch also marks CB and CBI devices that are SCSI-0 (legacy SCSI)
    as being single-LUN, since the combined SCSI-over-USB transport
    protocol has no way to convey LUN information to these devices.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Matthew Dharm &lt;mdharm-usb@one-eyed-alien.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index e1072d52d641..70234f5dbeeb 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -110,23 +110,6 @@ static int slave_configure(struct scsi_device *sdev)
 	 * the end, scatter-gather buffers follow page boundaries. */
 	blk_queue_dma_alignment(sdev-&gt;request_queue, (512 - 1));
 
-	/* Set the SCSI level to at least 2.  We'll leave it at 3 if that's
-	 * what is originally reported.  We need this to avoid confusing
-	 * the SCSI layer with devices that report 0 or 1, but need 10-byte
-	 * commands (ala ATAPI devices behind certain bridges, or devices
-	 * which simply have broken INQUIRY data).
-	 *
-	 * NOTE: This means /dev/sg programs (ala cdrecord) will get the
-	 * actual information.  This seems to be the preference for
-	 * programs like that.
-	 *
-	 * NOTE: This also means that /proc/scsi/scsi and sysfs may report
-	 * the actual value or the modified one, depending on where the
-	 * data comes from.
-	 */
-	if (sdev-&gt;scsi_level &lt; SCSI_2)
-		sdev-&gt;scsi_level = sdev-&gt;sdev_target-&gt;scsi_level = SCSI_2;
-
 	/* Many devices have trouble transfering more than 32KB at a time,
 	 * while others have trouble with more than 64K. At this time we
 	 * are limiting both to 32K (64 sectores).
@@ -176,7 +159,9 @@ static int slave_configure(struct scsi_device *sdev)
 		 * a Get-Max-LUN request, we won't lose much by setting the
 		 * revision level down to 2.  The only devices that would be
 		 * affected are those with sparse LUNs. */
-		sdev-&gt;scsi_level = sdev-&gt;sdev_target-&gt;scsi_level = SCSI_2;
+		if (sdev-&gt;scsi_level &gt; SCSI_2)
+			sdev-&gt;sdev_target-&gt;scsi_level =
+					sdev-&gt;scsi_level = SCSI_2;
 
 		/* USB-IDE bridges tend to report SK = 0x04 (Non-recoverable
 		 * Hardware Error) when any low-level error occurs,
@@ -194,6 +179,16 @@ static int slave_configure(struct scsi_device *sdev)
 		sdev-&gt;use_10_for_ms = 1;
 	}
 
+	/* The CB and CBI transports have no way to pass LUN values
+	 * other than the bits in the second byte of a CDB.  But those
+	 * bits don't get set to the LUN value if the device reports
+	 * scsi_level == 0 (UNKNOWN).  Hence such devices must necessarily
+	 * be single-LUN.
+	 */
+	if ((us-&gt;protocol == US_PR_CB || us-&gt;protocol == US_PR_CBI) &amp;&amp;
+			sdev-&gt;scsi_level == SCSI_UNKNOWN)
+		us-&gt;max_lun = 0;
+
 	/* Some devices choke when they receive a PREVENT-ALLOW MEDIUM
 	 * REMOVAL command, so suppress those commands. */
 	if (us-&gt;flags &amp; US_FL_NOT_LOCKABLE)</pre><hr><pre>commit 85a975d0ce48dfa8dec5bf1bd970f8fd2c48af32
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jan 8 12:01:43 2007 -0500

    UHCI: no dummy TDs for Iso QHs
    
    Isochronous queues don't need a dummy TD because the Queue Header
    isn't managed by the hardware.  This patch (as836) removes the
    unnecessary dummy TDs.
    
    The patch also fixes a long-standing typo in a comment (a "don't" was
    missing -- potentially very confusing!).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-debug.c b/drivers/usb/host/uhci-debug.c
index b40bc1ac9b8c..3fbb5ba80249 100644
--- a/drivers/usb/host/uhci-debug.c
+++ b/drivers/usb/host/uhci-debug.c
@@ -208,7 +208,7 @@ static int uhci_show_qh(struct uhci_qh *qh, char *buf, int len, int space)
 					space, "", nurbs);
 	}
 
-	if (qh-&gt;udev) {
+	if (qh-&gt;dummy_td) {
 		out += sprintf(out, "%*s  Dummy TD\n", space, "");
 		out += uhci_show_td(qh-&gt;dummy_td, out, len - (out - buf), 0);
 	}
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 30b88459ac7d..5afcc5227284 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -248,16 +248,18 @@ static struct uhci_qh *uhci_alloc_qh(struct uhci_hcd *uhci,
 	INIT_LIST_HEAD(&amp;qh-&gt;node);
 
 	if (udev) {		/* Normal QH */
-		qh-&gt;dummy_td = uhci_alloc_td(uhci);
-		if (!qh-&gt;dummy_td) {
-			dma_pool_free(uhci-&gt;qh_pool, qh, dma_handle);
-			return NULL;
+		qh-&gt;type = hep-&gt;desc.bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK;
+		if (qh-&gt;type != USB_ENDPOINT_XFER_ISOC) {
+			qh-&gt;dummy_td = uhci_alloc_td(uhci);
+			if (!qh-&gt;dummy_td) {
+				dma_pool_free(uhci-&gt;qh_pool, qh, dma_handle);
+				return NULL;
+			}
 		}
 		qh-&gt;state = QH_STATE_IDLE;
 		qh-&gt;hep = hep;
 		qh-&gt;udev = udev;
 		hep-&gt;hcpriv = qh;
-		qh-&gt;type = hep-&gt;desc.bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK;
 
 	} else {		/* Skeleton QH */
 		qh-&gt;state = QH_STATE_ACTIVE;
@@ -275,7 +277,8 @@ static void uhci_free_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
 	list_del(&amp;qh-&gt;node);
 	if (qh-&gt;udev) {
 		qh-&gt;hep-&gt;hcpriv = NULL;
-		uhci_free_td(uhci, qh-&gt;dummy_td);
+		if (qh-&gt;dummy_td)
+			uhci_free_td(uhci, qh-&gt;dummy_td);
 	}
 	dma_pool_free(uhci-&gt;qh_pool, qh, qh-&gt;dma_handle);
 }
@@ -327,7 +330,7 @@ static int uhci_cleanup_queue(struct uhci_hcd *uhci, struct uhci_qh *qh,
 		goto done;
 	qh-&gt;element = UHCI_PTR_TERM;
 
-	/* Control pipes have to worry about toggles */
+	/* Control pipes don't have to worry about toggles */
 	if (qh-&gt;type == USB_ENDPOINT_XFER_CONTROL)
 		goto done;
 </pre><hr><pre>commit f3fe239b67424d88104e32076aec902c0642925f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jan 8 12:00:28 2007 -0500

    UHCI: improved debugging checks for the frame list
    
    This patch (as768) improves the debugging checks for the uhci-hcd
    frame list.  The number of entries displayed is limited to 10, and the
    driver now checks for the correct Skeleton QH link value at the end of
    each chain of Isochronous TDs.  The code to compute these link values
    is now used in two spots, so it is moved into its own separate
    subroutine.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-debug.c b/drivers/usb/host/uhci-debug.c
index e345f15b7d87..b40bc1ac9b8c 100644
--- a/drivers/usb/host/uhci-debug.c
+++ b/drivers/usb/host/uhci-debug.c
@@ -347,6 +347,7 @@ static int uhci_sprint_schedule(struct uhci_hcd *uhci, char *buf, int len)
 	struct uhci_qh *qh;
 	struct uhci_td *td;
 	struct list_head *tmp, *head;
+	int nframes, nerrs;
 
 	out += uhci_show_root_hub_state(uhci, out, len - (out - buf));
 	out += sprintf(out, "HC status\n");
@@ -355,23 +356,60 @@ static int uhci_sprint_schedule(struct uhci_hcd *uhci, char *buf, int len)
 		return out - buf;
 
 	out += sprintf(out, "Frame List\n");
+	nframes = 10;
+	nerrs = 0;
 	for (i = 0; i &lt; UHCI_NUMFRAMES; ++i) {
+		__le32 link, qh_dma;
+
+		j = 0;
 		td = uhci-&gt;frame_cpu[i];
+		link = uhci-&gt;frame[i];
 		if (!td)
-			continue;
+			goto check_link;
 
-		out += sprintf(out, "- Frame %d\n", i); \
-		if (td-&gt;dma_handle != (dma_addr_t)uhci-&gt;frame[i])
-			out += sprintf(out, "    frame list does not match td-&gt;dma_handle!\n");
+		if (nframes &gt; 0) {
+			out += sprintf(out, "- Frame %d -&gt; (%08x)\n",
+					i, le32_to_cpu(link));
+			j = 1;
+		}
 
 		head = &amp;td-&gt;fl_list;
 		tmp = head;
 		do {
 			td = list_entry(tmp, struct uhci_td, fl_list);
 			tmp = tmp-&gt;next;
-			out += uhci_show_td(td, out, len - (out - buf), 4);
+			if (cpu_to_le32(td-&gt;dma_handle) != link) {
+				if (nframes &gt; 0)
+					out += sprintf(out, "    link does "
+						"not match list entry!\n");
+				else
+					++nerrs;
+			}
+			if (nframes &gt; 0)
+				out += uhci_show_td(td, out,
+						len - (out - buf), 4);
+			link = td-&gt;link;
 		} while (tmp != head);
+
+check_link:
+		qh_dma = uhci_frame_skel_link(uhci, i);
+		if (link != qh_dma) {
+			if (nframes &gt; 0) {
+				if (!j) {
+					out += sprintf(out,
+						"- Frame %d -&gt; (%08x)\n",
+						i, le32_to_cpu(link));
+					j = 1;
+				}
+				out += sprintf(out, "   link does not match "
+					"QH (%08x)!\n", le32_to_cpu(qh_dma));
+			} else
+				++nerrs;
+		}
+		nframes -= j;
 	}
+	if (nerrs &gt; 0)
+		out += sprintf(out, "Skipped %d bad links\n", nerrs);
 
 	out += sprintf(out, "Skeleton QHs\n");
 
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index e0d4c2358b39..49b9d390b95f 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -92,6 +92,34 @@ static void suspend_rh(struct uhci_hcd *uhci, enum uhci_rh_state new_state);
 static void wakeup_rh(struct uhci_hcd *uhci);
 static void uhci_get_current_frame_number(struct uhci_hcd *uhci);
 
+/*
+ * Calculate the link pointer DMA value for the first Skeleton QH in a frame.
+ */
+static __le32 uhci_frame_skel_link(struct uhci_hcd *uhci, int frame)
+{
+	int skelnum;
+
+	/*
+	 * The interrupt queues will be interleaved as evenly as possible.
+	 * There's not much to be done about period-1 interrupts; they have
+	 * to occur in every frame.  But we can schedule period-2 interrupts
+	 * in odd-numbered frames, period-4 interrupts in frames congruent
+	 * to 2 (mod 4), and so on.  This way each frame only has two
+	 * interrupt QHs, which will help spread out bandwidth utilization.
+	 *
+	 * ffs (Find First bit Set) does exactly what we need:
+	 * 1,3,5,...  =&gt; ffs = 0 =&gt; use skel_int2_qh = skelqh[8],
+	 * 2,6,10,... =&gt; ffs = 1 =&gt; use skel_int4_qh = skelqh[7], etc.
+	 * ffs &gt;= 7 =&gt; not on any high-period queue, so use
+	 *	skel_int1_qh = skelqh[9].
+	 * Add in UHCI_NUMFRAMES to insure at least one bit is set.
+	 */
+	skelnum = 8 - (int) __ffs(frame | UHCI_NUMFRAMES);
+	if (skelnum &lt;= 1)
+		skelnum = 9;
+	return UHCI_PTR_QH | cpu_to_le32(uhci-&gt;skelqh[skelnum]-&gt;dma_handle);
+}
+
 #include "uhci-debug.c"
 #include "uhci-q.c"
 #include "uhci-hub.c"
@@ -631,32 +659,11 @@ static int uhci_start(struct usb_hcd *hcd)
 	/*
 	 * Fill the frame list: make all entries point to the proper
 	 * interrupt queue.
-	 *
-	 * The interrupt queues will be interleaved as evenly as possible.
-	 * There's not much to be done about period-1 interrupts; they have
-	 * to occur in every frame.  But we can schedule period-2 interrupts
-	 * in odd-numbered frames, period-4 interrupts in frames congruent
-	 * to 2 (mod 4), and so on.  This way each frame only has two
-	 * interrupt QHs, which will help spread out bandwidth utilization.
 	 */
 	for (i = 0; i &lt; UHCI_NUMFRAMES; i++) {
-		int irq;
-
-		/*
-		 * ffs (Find First bit Set) does exactly what we need:
-		 * 1,3,5,...  =&gt; ffs = 0 =&gt; use skel_int2_qh = skelqh[8],
-		 * 2,6,10,... =&gt; ffs = 1 =&gt; use skel_int4_qh = skelqh[7], etc.
-		 * ffs &gt;= 7 =&gt; not on any high-period queue, so use
-		 *	skel_int1_qh = skelqh[9].
-		 * Add UHCI_NUMFRAMES to insure at least one bit is set.
-		 */
-		irq = 8 - (int) __ffs(i + UHCI_NUMFRAMES);
-		if (irq &lt;= 1)
-			irq = 9;
 
 		/* Only place we don't use the frame list routines */
-		uhci-&gt;frame[i] = UHCI_PTR_QH |
-				cpu_to_le32(uhci-&gt;skelqh[irq]-&gt;dma_handle);
+		uhci-&gt;frame[i] = uhci_frame_skel_link(uhci, i);
 	}
 
 	/*</pre><hr><pre>commit 1737bf2c5e78e331ad0a30b8c34edd1016d043c0
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Dec 15 16:04:52 2006 -0500

    usbcore: remove unneeded error check
    
    This patch (as830) removes some unnecessary error checking.  According
    to the kerneldoc, schedule_work() can't fail.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 149aa8bfb1fe..8aca3574c2b5 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1545,11 +1545,7 @@ int usb_driver_set_configuration(struct usb_device *udev, int config)
 	INIT_WORK(&amp;req-&gt;work, driver_set_config_work);
 
 	usb_get_dev(udev);
-	if (!schedule_work(&amp;req-&gt;work)) {
-		usb_put_dev(udev);
-		kfree(req);
-		return -EINVAL;
-	}
+	schedule_work(&amp;req-&gt;work);
 	return 0;
 }
 EXPORT_SYMBOL_GPL(usb_driver_set_configuration);</pre><hr><pre>commit 25c77b329467d563ec1fa5c3efab0b13996ce810
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Dec 15 16:08:13 2006 -0500

    UHCI: support device_may_wakeup
    
    This patch (as831) adds device_may_wakeup() support to uhci-hcd; it
    has been lacking for a long time.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index fecc8c971c17..e0d4c2358b39 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -257,7 +257,9 @@ __acquires(uhci-&gt;lock)
 	int_enable = USBINTR_RESUME;
 	if (remote_wakeup_is_broken(uhci))
 		egsm_enable = 0;
-	if (resume_detect_interrupts_are_broken(uhci) || !egsm_enable)
+	if (resume_detect_interrupts_are_broken(uhci) || !egsm_enable ||
+			!device_may_wakeup(
+				&amp;uhci_to_hcd(uhci)-&gt;self.root_hub-&gt;dev))
 		uhci-&gt;working_RD = int_enable = 0;
 
 	outw(int_enable, uhci-&gt;io_addr + USBINTR);</pre><hr><pre>commit c80a70d53fa0ca47ad122cd75fe32b6f41c04eb1
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Dec 15 16:06:25 2006 -0500

    UHCI: make test for ASUS motherboard more specific
    
    Instead of matching all motherboards whose name contains "A7V8X" for a
    remote-wakeup hardware bug, this patch (as829) matches only those
    boards whose name is exactly equal to "A7V8X".  Later motherboards
    don't seem to have the bug.
    
    (In fact, it's possible that only one motherboard in the world has the
    bug.  With only one user reporting problems, it's hard to tell.)
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index acd101caeeeb..fecc8c971c17 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -209,24 +209,16 @@ static int resume_detect_interrupts_are_broken(struct uhci_hcd *uhci)
 
 static int remote_wakeup_is_broken(struct uhci_hcd *uhci)
 {
-	static struct dmi_system_id broken_wakeup_table[] = {
-		{
-			.ident = "Asus A7V8X",
-			.matches = {
-				DMI_MATCH(DMI_BOARD_VENDOR, "ASUSTeK"),
-				DMI_MATCH(DMI_BOARD_NAME, "A7V8X"),
-				DMI_MATCH(DMI_BOARD_VERSION, "REV 1.xx"),
-			}
-		},
-		{ }
-	};
 	int port;
+	char *sys_info;
+	static char bad_Asus_board[] = "A7V8X";
 
 	/* One of Asus's motherboards has a bug which causes it to
 	 * wake up immediately from suspend-to-RAM if any of the ports
 	 * are connected.  In such cases we will not set EGSM.
 	 */
-	if (dmi_check_system(broken_wakeup_table)) {
+	sys_info = dmi_get_system_info(DMI_BOARD_NAME);
+	if (sys_info &amp;&amp; !strcmp(sys_info, bad_Asus_board)) {
 		for (port = 0; port &lt; uhci-&gt;rh_numports; ++port) {
 			if (inw(uhci-&gt;io_addr + USBPORTSC1 + port * 2) &amp;
 					USBPORTSC_CCS)</pre><hr><pre>commit 5f8364b7d63acdc2216ca0f7d0a8557c318479ea
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Dec 5 16:29:55 2006 -0500

    UHCI: module parameter to ignore overcurrent changes
    
    Certain boards seem to like to issue false overcurrent notifications,
    for example on ports that don't have anything connected to them.  This
    looks like a hardware error, at the level of noise to those ports'
    overcurrent input signals (or non-debounced VBUS comparators).  This
    surfaces to users as truly massive amounts of syslog spam from khubd
    (which is appropriate for real hardware problems, except for the
    volume from multiple ports).
    
    Using this new "ignore_oc" flag helps such systems work more sanely,
    by preventing such indications from getting to khubd (and spamming
    syslog).  The downside is of course that true overcurrent errors will
    be masked; they'll appear as spontaneous disconnects, without the
    diagnostics that will let users troubleshoot issues like
    short-circuited cables.  In addition, controllers with no devices
    attached will be forced to poll for new devices rather than relying on
    interrupts, since each overcurrent event would generate a new
    interrupt.
    
    This patch (as826) is essentially a copy of David Brownell's ignore_oc
    patch for ehci-hcd, ported to uhci-hcd.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt
index ef69c75780bf..25d298517104 100644
--- a/Documentation/kernel-parameters.txt
+++ b/Documentation/kernel-parameters.txt
@@ -1714,6 +1714,14 @@ and is between 256 and 4096 characters. It is defined in the file
 	uart6850=	[HW,OSS]
 			Format: &lt;io&gt;,&lt;irq&gt;
 
+	uhci-hcd.ignore_oc=
+			[USB] Ignore overcurrent events (default N).
+			Some badly-designed motherboards generate lots of
+			bogus events, for ports that aren't wired to
+			anything.  Set this parameter to avoid log spamming.
+			Note that genuine overcurrent events won't be
+			reported either.
+
 	usbhid.mousepoll=
 			[USBHID] The interval which mice are to be polled at.
 
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index e87692c31be4..acd101caeeeb 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -60,6 +60,11 @@ Randy Dunlap, Georg Acher, Deti Fliegl, Thomas Sailer, Roman Weissgaerber, \
 Alan Stern"
 #define DRIVER_DESC "USB Universal Host Controller Interface driver"
 
+/* for flakey hardware, ignore overcurrent indicators */
+static int ignore_oc;
+module_param(ignore_oc, bool, S_IRUGO);
+MODULE_PARM_DESC(ignore_oc, "ignore hardware overcurrent indications");
+
 /*
  * debug = 0, no debugging messages
  * debug = 1, dump failed URBs except for stalls
@@ -169,6 +174,11 @@ static int resume_detect_interrupts_are_broken(struct uhci_hcd *uhci)
 {
 	int port;
 
+	/* If we have to ignore overcurrent events then almost by definition
+	 * we can't depend on resume-detect interrupts. */
+	if (ignore_oc)
+		return 1;
+
 	switch (to_pci_dev(uhci_dev(uhci))-&gt;vendor) {
 	    default:
 		break;
@@ -921,7 +931,8 @@ static int __init uhci_hcd_init(void)
 {
 	int retval = -ENOMEM;
 
-	printk(KERN_INFO DRIVER_DESC " " DRIVER_VERSION "\n");
+	printk(KERN_INFO DRIVER_DESC " " DRIVER_VERSION "%s\n",
+			ignore_oc ? ", overcurrent ignored" : "");
 
 	if (usb_disabled())
 		return -ENODEV;
diff --git a/drivers/usb/host/uhci-hub.c b/drivers/usb/host/uhci-hub.c
index f8347f1a10b6..bacc25c53ba3 100644
--- a/drivers/usb/host/uhci-hub.c
+++ b/drivers/usb/host/uhci-hub.c
@@ -52,10 +52,20 @@ static int any_ports_active(struct uhci_hcd *uhci)
 static inline int get_hub_status_data(struct uhci_hcd *uhci, char *buf)
 {
 	int port;
+	int mask = RWC_BITS;
+
+	/* Some boards (both VIA and Intel apparently) report bogus
+	 * overcurrent indications, causing massive log spam unless
+	 * we completely ignore them.  This doesn't seem to be a problem
+	 * with the chipset so much as with the way it is connected on
+	 * the motherboard; if the overcurrent input is left to float
+	 * then it may constantly register false positives. */
+	if (ignore_oc)
+		mask &amp;= ~USBPORTSC_OCC;
 
 	*buf = 0;
 	for (port = 0; port &lt; uhci-&gt;rh_numports; ++port) {
-		if ((inw(uhci-&gt;io_addr + USBPORTSC1 + port * 2) &amp; RWC_BITS) ||
+		if ((inw(uhci-&gt;io_addr + USBPORTSC1 + port * 2) &amp; mask) ||
 				test_bit(port, &amp;uhci-&gt;port_c_suspend))
 			*buf |= (1 &lt;&lt; (port + 1));
 	}
@@ -263,7 +273,7 @@ static int uhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 			wPortChange |= USB_PORT_STAT_C_CONNECTION;
 		if (status &amp; USBPORTSC_PEC)
 			wPortChange |= USB_PORT_STAT_C_ENABLE;
-		if (status &amp; USBPORTSC_OCC)
+		if ((status &amp; USBPORTSC_OCC) &amp;&amp; !ignore_oc)
 			wPortChange |= USB_PORT_STAT_C_OVERCURRENT;
 
 		if (test_bit(port, &amp;uhci-&gt;port_c_suspend)) {</pre>
    <div class="pagination">
        <a href='2_113.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><span>[114]</span><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_115.html'>Next&gt;&gt;</a>
    <div>
</body>
