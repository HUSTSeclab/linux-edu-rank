<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_112.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><span>[113]</span><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_114.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit b544d7499cc47fc26e9dbacd7b9cabc67d2bdf2e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jan 31 10:57:55 2007 -0500

    USB: unusual_devs update for Sony P990i phone
    
    This patch (as846) adds the IGNORE_RESIDUE flag to the unusual_devs
    entry for Sony-Ericsson's P990i phone.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Phil Dibowitz &lt;phil@ipom.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index f6c5f5fa2eeb..bab054b8d94f 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -1311,12 +1311,13 @@ UNUSUAL_DEV(  0x0fce, 0xd008, 0x0000, 0x0000,
 		US_SC_DEVICE, US_PR_DEVICE, NULL,
 		US_FL_NO_WP_DETECT ),
 
-/* Reported by Jan Mate &lt;mate@fiit.stuba.sk&gt; */
+/* Reported by Jan Mate &lt;mate@fiit.stuba.sk&gt;
+ * and by Soeren Sonnenburg &lt;kernel@nn7.de&gt; */
 UNUSUAL_DEV(  0x0fce, 0xe030, 0x0000, 0x0000,
 		"Sony Ericsson",
 		"P990i",
 		US_SC_DEVICE, US_PR_DEVICE, NULL,
-		US_FL_FIX_CAPACITY ),
+		US_FL_FIX_CAPACITY | US_FL_IGNORE_RESIDUE ),
 
 /* Reported by Emmanuel Vasilakis &lt;evas@forthnet.gr&gt; */
 UNUSUAL_DEV(  0x0fce, 0xe031, 0x0000, 0x0000,</pre><hr><pre>commit 8903795a5275e0366acf961190c57074ad27f9bb
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Feb 13 14:55:27 2007 -0500

    EHCI: turn off remote wakeup during shutdown
    
    This patch (as850b) disables remote wakeup (and everything else!) on
    all EHCI ports when the shutdown() method is called.  If remote wakeup
    is left active then some systems will reboot instead of powering off.
    This fixes Bugzilla #7828.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: David Brownell &lt;david-b@pacbell.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 185721dba42b..6bf909e1adf0 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -299,6 +299,19 @@ static void ehci_watchdog (unsigned long param)
 	spin_unlock_irqrestore (&amp;ehci-&gt;lock, flags);
 }
 
+/* On some systems, leaving remote wakeup enabled prevents system shutdown.
+ * The firmware seems to think that powering off is a wakeup event!
+ * This routine turns off remote wakeup and everything else, on all ports.
+ */
+static void ehci_turn_off_all_ports(struct ehci_hcd *ehci)
+{
+	int	port = HCS_N_PORTS(ehci-&gt;hcs_params);
+
+	while (port--)
+		ehci_writel(ehci, PORT_RWC_BITS,
+				&amp;ehci-&gt;regs-&gt;port_status[port]);
+}
+
 /* ehci_shutdown kick in for silicon on any bus (not just pci, etc).
  * This forcibly disables dma and IRQs, helping kexec and other cases
  * where the next system software may expect clean state.
@@ -310,9 +323,13 @@ ehci_shutdown (struct usb_hcd *hcd)
 
 	ehci = hcd_to_ehci (hcd);
 	(void) ehci_halt (ehci);
+	ehci_turn_off_all_ports(ehci);
 
 	/* make BIOS/etc use companion controller during reboot */
 	ehci_writel(ehci, 0, &amp;ehci-&gt;regs-&gt;configured_flag);
+
+	/* unblock posted writes */
+	ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;configured_flag);
 }
 
 static void ehci_port_power (struct ehci_hcd *ehci, int is_on)</pre><hr><pre>commit 7c9d6f16f50d3aeb780e4f103a1ba8b35d9ae803
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jan 8 11:12:32 2007 -0500

    [SCSI] SCSI core: better initialization for sdev-&gt;scsi_level
    
    This patch will affect the CDB in INQUIRY commands sent to LUNs above 0
    when LUN-0 reports a scsi_level of 0; the LUN bits will no longer be set
    in the second byte of the CDB.  This is as it should be.  Nevertheless,
    it's possible that some wacky device might be adversely affected.  I doubt
    anyone will complain...
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c
index 7757e558d523..6905ffd135b3 100644
--- a/drivers/scsi/scsi_scan.c
+++ b/drivers/scsi/scsi_scan.c
@@ -385,6 +385,7 @@ static struct scsi_target *scsi_alloc_target(struct device *parent,
 	INIT_LIST_HEAD(&amp;starget-&gt;siblings);
 	INIT_LIST_HEAD(&amp;starget-&gt;devices);
 	starget-&gt;state = STARGET_RUNNING;
+	starget-&gt;scsi_level = SCSI_2;
  retry:
 	spin_lock_irqsave(shost-&gt;host_lock, flags);
 
diff --git a/drivers/scsi/scsi_sysfs.c b/drivers/scsi/scsi_sysfs.c
index 259c90cfa367..c275dcac3f18 100644
--- a/drivers/scsi/scsi_sysfs.c
+++ b/drivers/scsi/scsi_sysfs.c
@@ -922,7 +922,7 @@ void scsi_sysfs_device_initialize(struct scsi_device *sdev)
 	snprintf(sdev-&gt;sdev_classdev.class_id, BUS_ID_SIZE,
 		 "%d:%d:%d:%d", sdev-&gt;host-&gt;host_no,
 		 sdev-&gt;channel, sdev-&gt;id, sdev-&gt;lun);
-	sdev-&gt;scsi_level = SCSI_2;
+	sdev-&gt;scsi_level = starget-&gt;scsi_level;
 	transport_setup_device(&amp;sdev-&gt;sdev_gendev);
 	spin_lock_irqsave(shost-&gt;host_lock, flags);
 	list_add_tail(&amp;sdev-&gt;same_target_siblings, &amp;starget-&gt;devices);</pre><hr><pre>commit 74feb53e8b5020e790e12c6331cbe885d276cc60
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jan 8 11:07:41 2007 -0500

    [SCSI] scsi_proc.c: display sdev-&gt;scsi_level correctly
    
    This patch (as833) fixes the "SCSI revision" output for
    /proc/scsi/scsi.  If the scsi_level value is 0 (UNKNOWN), we want it
    to show up as "0", not "ffffffff".
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/scsi_proc.c b/drivers/scsi/scsi_proc.c
index 69d6e9b198c4..bb6f051beda8 100644
--- a/drivers/scsi/scsi_proc.c
+++ b/drivers/scsi/scsi_proc.c
@@ -179,9 +179,8 @@ static int proc_print_scsidevice(struct device *dev, void *data)
 	seq_printf(s, "\n");
 
 	seq_printf(s, "  Type:   %s ", scsi_device_type(sdev-&gt;type));
-	seq_printf(s, "               ANSI"
-		     " SCSI revision: %02x", (sdev-&gt;scsi_level - 1) ?
-		     sdev-&gt;scsi_level - 1 : 1);
+	seq_printf(s, "               ANSI  SCSI revision: %02x",
+			sdev-&gt;scsi_level - (sdev-&gt;scsi_level &gt; 1));
 	if (sdev-&gt;scsi_level == 2)
 		seq_printf(s, " CCS\n");
 	else</pre><hr><pre>commit e423ee31db92d4e298c137814a4341e1cd05739e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Feb 16 01:46:38 2007 -0800

    [SCSI] scsi_scan.c: handle bad inquiry responses
    
    A particular USB device has been reporting short inquiry lengths.  The
    SCSI code cannot operate properly unless we get an inquiry length of
    36 or above (because of the way we parse vendor and product), so
    assume at least 36 bytes are valid even if the device reports fewer.
    This is wrong, but it's no worse than what we're doing now (using the
    garbage beyond the last reported valid byte).
    
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c
index a43b9ec3aefd..7757e558d523 100644
--- a/drivers/scsi/scsi_scan.c
+++ b/drivers/scsi/scsi_scan.c
@@ -654,6 +654,19 @@ static int scsi_probe_lun(struct scsi_device *sdev, unsigned char *inq_result,
 	 * short INQUIRY), an abort here prevents any further use of the
 	 * device, including spin up.
 	 *
+	 * On the whole, the best approach seems to be to assume the first
+	 * 36 bytes are valid no matter what the device says.  That's
+	 * better than copying &lt; 36 bytes to the inquiry-result buffer
+	 * and displaying garbage for the Vendor, Product, or Revision
+	 * strings.
+	 */
+	if (sdev-&gt;inquiry_len &lt; 36) {
+		printk(KERN_INFO "scsi scan: INQUIRY result too short (%d),"
+				" using 36\n", sdev-&gt;inquiry_len);
+		sdev-&gt;inquiry_len = 36;
+	}
+
+	/*
 	 * Related to the above issue:
 	 *
 	 * XXX Devices (disk or all?) should be sent a TEST UNIT READY,</pre><hr><pre>commit 1096f780d0b9d6bade2d42bf823e81db3e553abe
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jan 22 11:58:34 2007 -0500

    usb-storage: use first bulk endpoints, not last
    
    According to the Bulk-Only spec, usb-storage is supposed to use the
    _first_ bulk-in and bulk-out endpoints it finds, not the _last_.  And
    while we're at it, we ought to test the direction of the interrupt
    endpoint as well.  This patch (as842) makes both changes.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: Matthew Dharm &lt;mdharm-usb@one-eyed-alien.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/usb.c b/drivers/usb/storage/usb.c
index 70644506651f..7e7ec29782f1 100644
--- a/drivers/usb/storage/usb.c
+++ b/drivers/usb/storage/usb.c
@@ -731,26 +731,27 @@ static int get_pipes(struct us_data *us)
 	struct usb_endpoint_descriptor *ep_int = NULL;
 
 	/*
-	 * Find the endpoints we need.
+	 * Find the first endpoint of each type we need.
 	 * We are expecting a minimum of 2 endpoints - in and out (bulk).
-	 * An optional interrupt is OK (necessary for CBI protocol).
+	 * An optional interrupt-in is OK (necessary for CBI protocol).
 	 * We will ignore any others.
 	 */
 	for (i = 0; i &lt; altsetting-&gt;desc.bNumEndpoints; i++) {
 		ep = &amp;altsetting-&gt;endpoint[i].desc;
 
-		/* Is it a BULK endpoint? */
 		if (usb_endpoint_xfer_bulk(ep)) {
-			/* BULK in or out? */
-			if (usb_endpoint_dir_in(ep))
-				ep_in = ep;
-			else
-				ep_out = ep;
+			if (usb_endpoint_dir_in(ep)) {
+				if (!ep_in)
+					ep_in = ep;
+			} else {
+				if (!ep_out)
+					ep_out = ep;
+			}
 		}
 
-		/* Is it an interrupt endpoint? */
-		else if (usb_endpoint_xfer_int(ep)) {
-			ep_int = ep;
+		else if (usb_endpoint_is_int_in(ep)) {
+			if (!ep_int)
+				ep_int = ep;
 		}
 	}
 </pre><hr><pre>commit 629e4427aa817d5c9f11885420abf54b8f5967dc
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jan 22 16:08:53 2007 -0500

    EHCI: fix interrupt-driven remote wakeup
    
    Now that port status change notifications are interrupt-driven,
    ehci-hcd needs to tell usbcore when a remote-wakeup resume operation
    is finished -- we can no longer rely on the core to poll and find
    out.  This patch (as843) uses the root-hub status timer to force a
    poll after the resume is complete.
    
    The patch also changes the test for detecting when the TDRSMDN resume
    period has expired.  It's necessary to use time_after_eq() instead of
    time_after(), since the polling is triggered precisely by a timer.
    The same change is made for TDRSTR reset expiration, for consistency.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: David Brownell &lt;david-b@pacbell.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 3cfba69e0767..0d83c6df1a3b 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -379,8 +379,8 @@ ehci_hub_status_data (struct usb_hcd *hcd, char *buf)
 			ehci-&gt;reset_done [i] = 0;
 		if ((temp &amp; mask) != 0
 				|| ((temp &amp; PORT_RESUME) != 0
-					&amp;&amp; time_after (jiffies,
-						ehci-&gt;reset_done [i]))) {
+					&amp;&amp; time_after_eq(jiffies,
+						ehci-&gt;reset_done[i]))) {
 			if (i &lt; 7)
 			    buf [0] |= 1 &lt;&lt; (i + 1);
 			else
@@ -554,31 +554,45 @@ static int ehci_hub_control (
 			status |= 1 &lt;&lt; USB_PORT_FEAT_C_OVER_CURRENT;
 
 		/* whoever resumes must GetPortStatus to complete it!! */
-		if ((temp &amp; PORT_RESUME)
-				&amp;&amp; time_after (jiffies,
-					ehci-&gt;reset_done [wIndex])) {
-			status |= 1 &lt;&lt; USB_PORT_FEAT_C_SUSPEND;
-			ehci-&gt;reset_done [wIndex] = 0;
+		if (temp &amp; PORT_RESUME) {
 
-			/* stop resume signaling */
-			temp = ehci_readl(ehci, status_reg);
-			ehci_writel(ehci,
+			/* Remote Wakeup received? */
+			if (!ehci-&gt;reset_done[wIndex]) {
+				/* resume signaling for 20 msec */
+				ehci-&gt;reset_done[wIndex] = jiffies
+						+ msecs_to_jiffies(20);
+				/* check the port again */
+				mod_timer(&amp;ehci_to_hcd(ehci)-&gt;rh_timer,
+						ehci-&gt;reset_done[wIndex]);
+			}
+
+			/* resume completed? */
+			else if (time_after_eq(jiffies,
+					ehci-&gt;reset_done[wIndex])) {
+				status |= 1 &lt;&lt; USB_PORT_FEAT_C_SUSPEND;
+				ehci-&gt;reset_done[wIndex] = 0;
+
+				/* stop resume signaling */
+				temp = ehci_readl(ehci, status_reg);
+				ehci_writel(ehci,
 					temp &amp; ~(PORT_RWC_BITS | PORT_RESUME),
 					status_reg);
-			retval = handshake(ehci, status_reg,
+				retval = handshake(ehci, status_reg,
 					   PORT_RESUME, 0, 2000 /* 2msec */);
-			if (retval != 0) {
-				ehci_err (ehci, "port %d resume error %d\n",
-					wIndex + 1, retval);
-				goto error;
+				if (retval != 0) {
+					ehci_err(ehci,
+						"port %d resume error %d\n",
+						wIndex + 1, retval);
+					goto error;
+				}
+				temp &amp;= ~(PORT_SUSPEND|PORT_RESUME|(3&lt;&lt;10));
 			}
-			temp &amp;= ~(PORT_SUSPEND|PORT_RESUME|(3&lt;&lt;10));
 		}
 
 		/* whoever resets must GetPortStatus to complete it!! */
 		if ((temp &amp; PORT_RESET)
-				&amp;&amp; time_after (jiffies,
-					ehci-&gt;reset_done [wIndex])) {
+				&amp;&amp; time_after_eq(jiffies,
+					ehci-&gt;reset_done[wIndex])) {
 			status |= 1 &lt;&lt; USB_PORT_FEAT_C_RESET;
 			ehci-&gt;reset_done [wIndex] = 0;
 </pre><hr><pre>commit 49631ca7f3e2fd05186028b453fa27f75b830de7
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jan 16 23:28:48 2007 -0800

    USB: gadgetfs AIO tweaks
    
    This patch (as837) fixes several mistakes in the AIO interface of the
    gadgetfs driver:
    
            The ki_retry method is not supposed to do a put on the kiocb.
            The extra call to aio_put_req() causes memory corruption.
            (Note: This call was removed before, by patch as691, and then
            mysteriously re-introduced later.)
    
            Even if a read transfer is cancelled, we can and should send
            to the user all the data that did manage to get transferred.
    
            Testing for AIO cancellation in the I/O completion handler
            is both racy and (now) unnecessary.  aio_complete() does its
            own checking, in a safe manner.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: David Brownell &lt;dbrownell@users.sourceforge.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/inode.c b/drivers/usb/gadget/inode.c
index 1c5e1ee7e36b..34296e79edcf 100644
--- a/drivers/usb/gadget/inode.c
+++ b/drivers/usb/gadget/inode.c
@@ -576,7 +576,6 @@ static ssize_t ep_aio_read_retry(struct kiocb *iocb)
 	}
 	kfree(priv-&gt;buf);
 	kfree(priv);
-	aio_put_req(iocb);
 	return len;
 }
 
@@ -590,18 +589,17 @@ static void ep_aio_complete(struct usb_ep *ep, struct usb_request *req)
 	spin_lock(&amp;epdata-&gt;dev-&gt;lock);
 	priv-&gt;req = NULL;
 	priv-&gt;epdata = NULL;
-	if (priv-&gt;iv == NULL
-			|| unlikely(req-&gt;actual == 0)
-			|| unlikely(kiocbIsCancelled(iocb))) {
+
+	/* if this was a write or a read returning no data then we
+	 * don't need to copy anything to userspace, so we can
+	 * complete the aio request immediately.
+	 */
+	if (priv-&gt;iv == NULL || unlikely(req-&gt;actual == 0)) {
 		kfree(req-&gt;buf);
 		kfree(priv);
 		iocb-&gt;private = NULL;
 		/* aio_complete() reports bytes-transferred _and_ faults */
-		if (unlikely(kiocbIsCancelled(iocb)))
-			aio_put_req(iocb);
-		else
-			aio_complete(iocb,
-				req-&gt;actual ? req-&gt;actual : req-&gt;status,
+		aio_complete(iocb, req-&gt;actual ? req-&gt;actual : req-&gt;status,
 				req-&gt;status);
 	} else {
 		/* retry() won't report both; so we hide some faults */</pre><hr><pre>commit 57e06c11372eccf5acebdd4664eb025fee76c561
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jan 16 11:59:45 2007 -0500

    EHCI: force high-speed devices to run at full speed
    
    This patch (as710) adds a sysfs class-device attribute file named
    "companion" for EHCI controllers.  The file contains a list of port
    numbers that are dedicated to the companion controller; by writing a
    port number to the file the user can force a high-speed device
    attached directly to the computer to run at full speed.  (As far as I
    know it is not possible to do this for a device attached to an
    external hub.)  A port is removed from the file by writing the
    negative of its port number.
    
    Several users have asked for this facility and it seems like a useful
    thing to have.  Every now and then one runs across a device which
    behaves much better at full speed than at high speed.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: David Brownell &lt;dbrownell@users.sourceforge.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 9ec896218feb..92c62911f574 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -388,6 +388,7 @@ static void ehci_stop (struct usb_hcd *hcd)
 	/* let companion controllers work when we aren't */
 	ehci_writel(ehci, 0, &amp;ehci-&gt;regs-&gt;configured_flag);
 
+	remove_companion_file(ehci);
 	remove_debug_files (ehci);
 
 	/* root hub is shut down separately (first, when possible) */
@@ -563,6 +564,7 @@ static int ehci_run (struct usb_hcd *hcd)
 	 * since the class device isn't created that early.
 	 */
 	create_debug_files(ehci);
+	create_companion_file(ehci);
 
 	return 0;
 }
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 076474d95dbf..3cfba69e0767 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -188,6 +188,103 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 
 #endif	/* CONFIG_PM */
 
+/*-------------------------------------------------------------------------*/
+
+/* Display the ports dedicated to the companion controller */
+static ssize_t show_companion(struct class_device *class_dev, char *buf)
+{
+	struct ehci_hcd		*ehci;
+	int			nports, index, n;
+	int			count = PAGE_SIZE;
+	char			*ptr = buf;
+
+	ehci = hcd_to_ehci(bus_to_hcd(class_get_devdata(class_dev)));
+	nports = HCS_N_PORTS(ehci-&gt;hcs_params);
+
+	for (index = 0; index &lt; nports; ++index) {
+		if (test_bit(index, &amp;ehci-&gt;companion_ports)) {
+			n = scnprintf(ptr, count, "%d\n", index + 1);
+			ptr += n;
+			count -= n;
+		}
+	}
+	return ptr - buf;
+}
+
+/*
+ * Dedicate or undedicate a port to the companion controller.
+ * Syntax is "[-]portnum", where a leading '-' sign means
+ * return control of the port to the EHCI controller.
+ */
+static ssize_t store_companion(struct class_device *class_dev,
+		const char *buf, size_t count)
+{
+	struct ehci_hcd		*ehci;
+	int			portnum, new_owner, try;
+	u32 __iomem		*status_reg;
+	u32			port_status;
+
+	ehci = hcd_to_ehci(bus_to_hcd(class_get_devdata(class_dev)));
+	new_owner = PORT_OWNER;		/* Owned by companion */
+	if (sscanf(buf, "%d", &amp;portnum) != 1)
+		return -EINVAL;
+	if (portnum &lt; 0) {
+		portnum = - portnum;
+		new_owner = 0;		/* Owned by EHCI */
+	}
+	if (portnum &lt;= 0 || portnum &gt; HCS_N_PORTS(ehci-&gt;hcs_params))
+		return -ENOENT;
+	status_reg = &amp;ehci-&gt;regs-&gt;port_status[--portnum];
+	if (new_owner)
+		set_bit(portnum, &amp;ehci-&gt;companion_ports);
+	else
+		clear_bit(portnum, &amp;ehci-&gt;companion_ports);
+
+	/*
+	 * The controller won't set the OWNER bit if the port is
+	 * enabled, so this loop will sometimes require at least two
+	 * iterations: one to disable the port and one to set OWNER.
+	 */
+
+	for (try = 4; try &gt; 0; --try) {
+		spin_lock_irq(&amp;ehci-&gt;lock);
+		port_status = ehci_readl(ehci, status_reg);
+		if ((port_status &amp; PORT_OWNER) == new_owner
+				|| (port_status &amp; (PORT_OWNER | PORT_CONNECT))
+					== 0)
+			try = 0;
+		else {
+			port_status ^= PORT_OWNER;
+			port_status &amp;= ~(PORT_PE | PORT_RWC_BITS);
+			ehci_writel(ehci, port_status, status_reg);
+		}
+		spin_unlock_irq(&amp;ehci-&gt;lock);
+		if (try &gt; 1)
+			msleep(5);
+	}
+	return count;
+}
+static CLASS_DEVICE_ATTR(companion, 0644, show_companion, store_companion);
+
+static inline void create_companion_file(struct ehci_hcd *ehci)
+{
+	int	i;
+
+	/* with integrated TT there is no companion! */
+	if (!ehci_is_TDI(ehci))
+		i = class_device_create_file(ehci_to_hcd(ehci)-&gt;self.class_dev,
+				&amp;class_device_attr_companion);
+}
+
+static inline void remove_companion_file(struct ehci_hcd *ehci)
+{
+	/* with integrated TT there is no companion! */
+	if (!ehci_is_TDI(ehci))
+		class_device_remove_file(ehci_to_hcd(ehci)-&gt;self.class_dev,
+				&amp;class_device_attr_companion);
+}
+
+
 /*-------------------------------------------------------------------------*/
 
 static int check_reset_complete (
@@ -504,6 +601,16 @@ static int ehci_hub_control (
 					ehci_readl(ehci, status_reg));
 		}
 
+		/* transfer dedicated ports to the companion hc */
+		if ((temp &amp; PORT_CONNECT) &amp;&amp;
+				test_bit(wIndex, &amp;ehci-&gt;companion_ports)) {
+			temp &amp;= ~PORT_RWC_BITS;
+			temp |= PORT_OWNER;
+			ehci_writel(ehci, temp, status_reg);
+			ehci_dbg(ehci, "port %d --&gt; companion\n", wIndex + 1);
+			temp = ehci_readl(ehci, status_reg);
+		}
+
 		/*
 		 * Even if OWNER is set, there's no harm letting khubd
 		 * see the wPortStatus values (they should all be 0 except
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 3ce7249085d5..ec0da0343be4 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -74,7 +74,11 @@ struct ehci_hcd {			/* one per controller */
 
 	/* per root hub port */
 	unsigned long		reset_done [EHCI_MAX_ROOT_PORTS];
-	unsigned long		bus_suspended;
+	/* bit vectors (one bit per port) */
+	unsigned long		bus_suspended;		/* which ports were
+			already suspended at the start of a bus suspend */
+	unsigned long		companion_ports;	/* which ports are
+			dedicated to the companion controller */
 
 	/* per-HC memory pools (could be per-bus, but ...) */
 	struct dma_pool		*qh_pool;	/* qh per active urb */</pre><hr><pre>commit 625b5c9a0069ef1b61feb3ce599b39f1b04b5666
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jan 16 11:58:47 2007 -0500

    EHCI: don't hide ports owned by the companion
    
    This patch (as709) changes the way ehci-hcd presents port status
    values for ports owned by the companion controller.  It no longer
    hides the information; in particular, it allows the core to see the
    disconnect event that occurs when a full- or low-speed device is
    switched over to the companion.  This is required for the next patch
    in this series.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: David Brownell &lt;dbrownell@users.sourceforge.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 12f881ff4b23..076474d95dbf 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -270,16 +270,14 @@ ehci_hub_status_data (struct usb_hcd *hcd, char *buf)
 	spin_lock_irqsave (&amp;ehci-&gt;lock, flags);
 	for (i = 0; i &lt; ports; i++) {
 		temp = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;port_status [i]);
-		if (temp &amp; PORT_OWNER) {
-			/* don't report this in GetPortStatus */
-			if (temp &amp; PORT_CSC) {
-				temp &amp;= ~PORT_RWC_BITS;
-				temp |= PORT_CSC;
-				ehci_writel(ehci, temp,
-					    &amp;ehci-&gt;regs-&gt;port_status [i]);
-			}
-			continue;
-		}
+
+		/*
+		 * Return status information even for ports with OWNER set.
+		 * Otherwise khubd wouldn't see the disconnect event when a
+		 * high-speed device is switched over to the companion
+		 * controller by the user.
+		 */
+
 		if (!(temp &amp; PORT_CONNECT))
 			ehci-&gt;reset_done [i] = 0;
 		if ((temp &amp; mask) != 0
@@ -377,8 +375,13 @@ static int ehci_hub_control (
 			goto error;
 		wIndex--;
 		temp = ehci_readl(ehci, status_reg);
-		if (temp &amp; PORT_OWNER)
-			break;
+
+		/*
+		 * Even if OWNER is set, so the port is owned by the
+		 * companion controller, khubd needs to be able to clear
+		 * the port-change status bits (especially
+		 * USB_PORT_FEAT_C_CONNECTION).
+		 */
 
 		switch (wValue) {
 		case USB_PORT_FEAT_ENABLE:
@@ -501,24 +504,27 @@ static int ehci_hub_control (
 					ehci_readl(ehci, status_reg));
 		}
 
-		// don't show wPortStatus if it's owned by a companion hc
-		if (!(temp &amp; PORT_OWNER)) {
-			if (temp &amp; PORT_CONNECT) {
-				status |= 1 &lt;&lt; USB_PORT_FEAT_CONNECTION;
-				// status may be from integrated TT
-				status |= ehci_port_speed(ehci, temp);
-			}
-			if (temp &amp; PORT_PE)
-				status |= 1 &lt;&lt; USB_PORT_FEAT_ENABLE;
-			if (temp &amp; (PORT_SUSPEND|PORT_RESUME))
-				status |= 1 &lt;&lt; USB_PORT_FEAT_SUSPEND;
-			if (temp &amp; PORT_OC)
-				status |= 1 &lt;&lt; USB_PORT_FEAT_OVER_CURRENT;
-			if (temp &amp; PORT_RESET)
-				status |= 1 &lt;&lt; USB_PORT_FEAT_RESET;
-			if (temp &amp; PORT_POWER)
-				status |= 1 &lt;&lt; USB_PORT_FEAT_POWER;
+		/*
+		 * Even if OWNER is set, there's no harm letting khubd
+		 * see the wPortStatus values (they should all be 0 except
+		 * for PORT_POWER anyway).
+		 */
+
+		if (temp &amp; PORT_CONNECT) {
+			status |= 1 &lt;&lt; USB_PORT_FEAT_CONNECTION;
+			// status may be from integrated TT
+			status |= ehci_port_speed(ehci, temp);
 		}
+		if (temp &amp; PORT_PE)
+			status |= 1 &lt;&lt; USB_PORT_FEAT_ENABLE;
+		if (temp &amp; (PORT_SUSPEND|PORT_RESUME))
+			status |= 1 &lt;&lt; USB_PORT_FEAT_SUSPEND;
+		if (temp &amp; PORT_OC)
+			status |= 1 &lt;&lt; USB_PORT_FEAT_OVER_CURRENT;
+		if (temp &amp; PORT_RESET)
+			status |= 1 &lt;&lt; USB_PORT_FEAT_RESET;
+		if (temp &amp; PORT_POWER)
+			status |= 1 &lt;&lt; USB_PORT_FEAT_POWER;
 
 #ifndef	EHCI_VERBOSE_DEBUG
 	if (status &amp; ~0xffff)	/* only if wPortChange is interesting */</pre>
    <div class="pagination">
        <a href='2_112.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><span>[113]</span><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_114.html'>Next&gt;&gt;</a>
    <div>
</body>
