<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_111.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><span>[112]</span><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_113.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 19c262391c4741b012a5031fc438fb694e77c385
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Feb 20 15:03:32 2007 -0500

    USB: export autosuspend delay in sysfs
    
    This patch (as861) adds sysfs attributes to expose the autosuspend
    delay value for each USB device.  If the user changes the delay from 0
    (no autosuspend) to a positive value, an autosuspend is attempted.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index a420d72a0254..9e3e943f313c 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -1224,6 +1224,26 @@ void usb_autosuspend_device(struct usb_device *udev)
 	//		__FUNCTION__, udev-&gt;pm_usage_cnt);
 }
 
+/**
+ * usb_try_autosuspend_device - attempt an autosuspend of a USB device and its interfaces
+ * @udev: the usb_device to autosuspend
+ *
+ * This routine should be called when a core subsystem thinks @udev may
+ * be ready to autosuspend.
+ *
+ * @udev's usage counter left unchanged.  If it or any of the usage counters
+ * for an active interface is greater than 0, or autosuspend is not allowed
+ * for any other reason, no autosuspend request will be queued.
+ *
+ * This routine can run only in process context.
+ */
+void usb_try_autosuspend_device(struct usb_device *udev)
+{
+	usb_autopm_do_device(udev, 0);
+	// dev_dbg(&amp;udev-&gt;dev, "%s: cnt %d\n",
+	// 		__FUNCTION__, udev-&gt;pm_usage_cnt);
+}
+
 /**
  * usb_autoresume_device - immediately autoresume a USB device and its interfaces
  * @udev: the usb_device to autoresume
diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c
index cad4fb323f6c..311d5df80386 100644
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -158,6 +158,65 @@ show_quirks(struct device *dev, struct device_attribute *attr, char *buf)
 }
 static DEVICE_ATTR(quirks, S_IRUGO, show_quirks, NULL);
 
+#ifdef	CONFIG_USB_SUSPEND
+
+static ssize_t
+show_autosuspend(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct usb_device *udev = to_usb_device(dev);
+
+	return sprintf(buf, "%u\n", udev-&gt;autosuspend_delay / HZ);
+}
+
+static ssize_t
+set_autosuspend(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct usb_device *udev = to_usb_device(dev);
+	unsigned value, old;
+
+	if (sscanf(buf, "%u", &amp;value) != 1 || value &gt;= INT_MAX/HZ)
+		return -EINVAL;
+	value *= HZ;
+
+	old = udev-&gt;autosuspend_delay;
+	udev-&gt;autosuspend_delay = value;
+	if (value &gt; 0 &amp;&amp; old == 0)
+		usb_try_autosuspend_device(udev);
+
+	return count;
+}
+
+static DEVICE_ATTR(autosuspend, S_IRUGO | S_IWUSR,
+		show_autosuspend, set_autosuspend);
+
+static char power_group[] = "power";
+
+static int add_power_attributes(struct device *dev)
+{
+	int rc = 0;
+
+	if (is_usb_device(dev))
+		rc = sysfs_add_file_to_group(&amp;dev-&gt;kobj,
+				&amp;dev_attr_autosuspend.attr,
+				power_group);
+	return rc;
+}
+
+static void remove_power_attributes(struct device *dev)
+{
+	sysfs_remove_file_from_group(&amp;dev-&gt;kobj,
+			&amp;dev_attr_autosuspend.attr,
+			power_group);
+}
+
+#else
+
+#define add_power_attributes(dev)	0
+#define remove_power_attributes(dev)	do {} while (0)
+
+#endif	/* CONFIG_USB_SUSPEND */
+
 /* Descriptor fields */
 #define usb_descriptor_attr_le16(field, format_string)			\
 static ssize_t								\
@@ -230,6 +289,10 @@ int usb_create_sysfs_dev_files(struct usb_device *udev)
 	if (retval)
 		return retval;
 
+	retval = add_power_attributes(dev);
+	if (retval)
+		goto error;
+
 	if (udev-&gt;manufacturer) {
 		retval = device_create_file(dev, &amp;dev_attr_manufacturer);
 		if (retval)
@@ -262,6 +325,7 @@ void usb_remove_sysfs_dev_files(struct usb_device *udev)
 	device_remove_file(dev, &amp;dev_attr_manufacturer);
 	device_remove_file(dev, &amp;dev_attr_product);
 	device_remove_file(dev, &amp;dev_attr_serial);
+	remove_power_attributes(dev);
 	sysfs_remove_group(&amp;dev-&gt;kobj, &amp;dev_attr_grp);
 }
 
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index b0a35f45b099..08b5a04e3755 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -66,11 +66,13 @@ static inline void usb_pm_unlock(struct usb_device *udev) {}
 #ifdef CONFIG_USB_SUSPEND
 
 extern void usb_autosuspend_device(struct usb_device *udev);
+extern void usb_try_autosuspend_device(struct usb_device *udev);
 extern int usb_autoresume_device(struct usb_device *udev);
 
 #else
 
-#define usb_autosuspend_device(udev)	do {} while (0)
+#define usb_autosuspend_device(udev)		do {} while (0)
+#define usb_try_autosuspend_device(udev)	do {} while (0)
 static inline int usb_autoresume_device(struct usb_device *udev)
 {
 	return 0;</pre><hr><pre>commit dfa87c824a9a5430008acd1ed2e8111ed164fcbe
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Feb 20 15:02:44 2007 -0500

    sysfs: allow attributes to be added to groups
    
    This patch (as860) adds two new sysfs routines:
    sysfs_add_file_to_group() and sysfs_remove_file_from_group().
    A later patch adds code that uses the new routines.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: Maneesh Soni &lt;maneesh@in.ibm.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/fs/sysfs/file.c b/fs/sysfs/file.c
index 98b0910ad80c..8d4d839a9d88 100644
--- a/fs/sysfs/file.c
+++ b/fs/sysfs/file.c
@@ -501,6 +501,30 @@ int sysfs_create_file(struct kobject * kobj, const struct attribute * attr)
 }
 
 
+/**
+ * sysfs_add_file_to_group - add an attribute file to a pre-existing group.
+ * @kobj: object we're acting for.
+ * @attr: attribute descriptor.
+ * @group: group name.
+ */
+int sysfs_add_file_to_group(struct kobject *kobj,
+		const struct attribute *attr, const char *group)
+{
+	struct dentry *dir;
+	int error;
+
+	dir = lookup_one_len(group, kobj-&gt;dentry, strlen(group));
+	if (IS_ERR(dir))
+		error = PTR_ERR(dir);
+	else {
+		error = sysfs_add_file(dir, attr, SYSFS_KOBJ_ATTR);
+		dput(dir);
+	}
+	return error;
+}
+EXPORT_SYMBOL_GPL(sysfs_add_file_to_group);
+
+
 /**
  * sysfs_update_file - update the modified timestamp on an object attribute.
  * @kobj: object we're acting for.
@@ -586,6 +610,26 @@ void sysfs_remove_file(struct kobject * kobj, const struct attribute * attr)
 }
 
 
+/**
+ * sysfs_remove_file_from_group - remove an attribute file from a group.
+ * @kobj: object we're acting for.
+ * @attr: attribute descriptor.
+ * @group: group name.
+ */
+void sysfs_remove_file_from_group(struct kobject *kobj,
+		const struct attribute *attr, const char *group)
+{
+	struct dentry *dir;
+
+	dir = lookup_one_len(group, kobj-&gt;dentry, strlen(group));
+	if (!IS_ERR(dir)) {
+		sysfs_hash_and_remove(dir, attr-&gt;name);
+		dput(dir);
+	}
+}
+EXPORT_SYMBOL_GPL(sysfs_remove_file_from_group);
+
+
 EXPORT_SYMBOL_GPL(sysfs_create_file);
 EXPORT_SYMBOL_GPL(sysfs_remove_file);
 EXPORT_SYMBOL_GPL(sysfs_update_file);
diff --git a/include/linux/sysfs.h b/include/linux/sysfs.h
index 192de3afa96b..f45450b295c0 100644
--- a/include/linux/sysfs.h
+++ b/include/linux/sysfs.h
@@ -126,6 +126,11 @@ void sysfs_remove_bin_file(struct kobject *kobj, struct bin_attribute *attr);
 int __must_check sysfs_create_group(struct kobject *,
 					const struct attribute_group *);
 void sysfs_remove_group(struct kobject *, const struct attribute_group *);
+int sysfs_add_file_to_group(struct kobject *kobj,
+		const struct attribute *attr, const char *group);
+void sysfs_remove_file_from_group(struct kobject *kobj,
+		const struct attribute *attr, const char *group);
+
 void sysfs_notify(struct kobject * k, char *dir, char *attr);
 
 
@@ -210,6 +215,18 @@ static inline void sysfs_remove_group(struct kobject * k, const struct attribute
 	;
 }
 
+static inline int sysfs_add_file_to_group(struct kobject *kobj,
+		const struct attribute *attr, const char *group)
+{
+	return 0;
+}
+
+static inline void sysfs_remove_file_from_group(struct kobject *kobj,
+		const struct attribute *attr, const char *group);
+{
+	;
+}
+
 static inline void sysfs_notify(struct kobject * k, char *dir, char *attr)
 {
 }</pre><hr><pre>commit b5e795f8df42936590ba9c606edc715fe3593284
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Feb 20 15:00:53 2007 -0500

    USB: make autosuspend delay a module parameter
    
    This patch (as859) makes the default USB autosuspend delay a module
    parameter of usbcore.  By setting the delay value at boot time, users
    will be able to prevent the system from autosuspending devices which
    for some reason can't handle it.
    
    The patch also stores the autosuspend delay as a per-device value.  A
    later patch will allow the user to change the value, tailoring the
    delay for each individual device.  A delay value of 0 will prevent
    autosuspend.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt
index c479d30eeaa3..03eb5ed503f7 100644
--- a/Documentation/kernel-parameters.txt
+++ b/Documentation/kernel-parameters.txt
@@ -1758,6 +1758,13 @@ and is between 256 and 4096 characters. It is defined in the file
 			Note that genuine overcurrent events won't be
 			reported either.
 
+	usbcore.autosuspend=
+			[USB] The autosuspend time delay (in seconds) used
+			for newly-detected USB devices (default 2).  This
+			is the time required before an idle device will be
+			autosuspended.  Devices for which the delay is set
+			to 0 won't be autosuspended at all.
+
 	usbhid.mousepoll=
 			[USBHID] The interval which mice are to be polled at.
 
diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index f9196a0a9412..a420d72a0254 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -963,12 +963,16 @@ static int autosuspend_check(struct usb_device *udev)
 	int			i;
 	struct usb_interface	*intf;
 
-	/* For autosuspend, fail fast if anything is in use.
-	 * Also fail if any interfaces require remote wakeup but it
-	 * isn't available. */
+	/* For autosuspend, fail fast if anything is in use or autosuspend
+	 * is disabled.  Also fail if any interfaces require remote wakeup
+	 * but it isn't available.
+	 */
 	udev-&gt;do_remote_wakeup = device_may_wakeup(&amp;udev-&gt;dev);
 	if (udev-&gt;pm_usage_cnt &gt; 0)
 		return -EBUSY;
+	if (!udev-&gt;autosuspend_delay)
+		return -EPERM;
+
 	if (udev-&gt;actconfig) {
 		for (i = 0; i &lt; udev-&gt;actconfig-&gt;desc.bNumInterfaces; i++) {
 			intf = udev-&gt;actconfig-&gt;interface[i];
@@ -991,7 +995,7 @@ static int autosuspend_check(struct usb_device *udev)
 
 #define autosuspend_check(udev)		0
 
-#endif
+#endif	/* CONFIG_USB_SUSPEND */
 
 /**
  * usb_suspend_both - suspend a USB device and its interfaces
@@ -1186,7 +1190,7 @@ static int usb_autopm_do_device(struct usb_device *udev, int inc_usage_cnt)
 			udev-&gt;pm_usage_cnt -= inc_usage_cnt;
 	} else if (inc_usage_cnt &lt;= 0 &amp;&amp; autosuspend_check(udev) == 0)
 		queue_delayed_work(ksuspend_usb_wq, &amp;udev-&gt;autosuspend,
-				USB_AUTOSUSPEND_DELAY);
+				udev-&gt;autosuspend_delay);
 	usb_pm_unlock(udev);
 	return status;
 }
@@ -1270,7 +1274,7 @@ static int usb_autopm_do_interface(struct usb_interface *intf,
 				intf-&gt;pm_usage_cnt -= inc_usage_cnt;
 		} else if (inc_usage_cnt &lt;= 0 &amp;&amp; autosuspend_check(udev) == 0)
 			queue_delayed_work(ksuspend_usb_wq, &amp;udev-&gt;autosuspend,
-					USB_AUTOSUSPEND_DELAY);
+					udev-&gt;autosuspend_delay);
 	}
 	usb_pm_unlock(udev);
 	return status;
diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c
index ea0e48e9f611..0e5c646cb4f6 100644
--- a/drivers/usb/core/quirks.c
+++ b/drivers/usb/core/quirks.c
@@ -39,8 +39,10 @@ static const struct usb_device_id usb_quirk_list[] = {
 
 static void usb_autosuspend_quirk(struct usb_device *udev)
 {
-	/* unbalanced resume to prevent autosuspends */
-	usb_autoresume_device(udev);
+#ifdef	CONFIG_USB_SUSPEND
+	/* disable autosuspend, but allow the user to re-enable it via sysfs */
+	udev-&gt;autosuspend_delay = 0;
+#endif
 }
 
 static const struct usb_device_id *find_id(struct usb_device *udev)
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index 3db721cd557a..54b42ce311c1 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -22,6 +22,7 @@
  */
 
 #include &lt;linux/module.h&gt;
+#include &lt;linux/moduleparam.h&gt;
 #include &lt;linux/string.h&gt;
 #include &lt;linux/bitops.h&gt;
 #include &lt;linux/slab.h&gt;
@@ -50,6 +51,16 @@ static int nousb;	/* Disable USB when built into kernel image */
 
 struct workqueue_struct *ksuspend_usb_wq;	/* For autosuspend */
 
+#ifdef	CONFIG_USB_SUSPEND
+static int usb_autosuspend_delay = 2;		/* Default delay value,
+						 * in seconds */
+module_param_named(autosuspend, usb_autosuspend_delay, uint, 0644);
+MODULE_PARM_DESC(autosuspend, "default autosuspend delay");
+
+#else
+#define usb_autosuspend_delay		0
+#endif
+
 
 /**
  * usb_ifnum_to_if - get the interface object with a given interface number
@@ -306,6 +317,7 @@ usb_alloc_dev(struct usb_device *parent, struct usb_bus *bus, unsigned port1)
 #ifdef	CONFIG_PM
 	mutex_init(&amp;dev-&gt;pm_mutex);
 	INIT_DELAYED_WORK(&amp;dev-&gt;autosuspend, usb_autosuspend_work);
+	dev-&gt;autosuspend_delay = usb_autosuspend_delay * HZ;
 #endif
 	return dev;
 }
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 045cbd111887..b0a35f45b099 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -65,8 +65,6 @@ static inline void usb_pm_unlock(struct usb_device *udev) {}
 
 #ifdef CONFIG_USB_SUSPEND
 
-#define USB_AUTOSUSPEND_DELAY	(HZ*2)
-
 extern void usb_autosuspend_device(struct usb_device *udev);
 extern int usb_autoresume_device(struct usb_device *udev);
 
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 37e522eba47f..87dc75a6cee1 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -389,10 +389,13 @@ struct usb_device {
 
 	int pm_usage_cnt;		/* usage counter for autosuspend */
 	u32 quirks;			/* quirks of the whole device */
+
 #ifdef CONFIG_PM
 	struct delayed_work autosuspend; /* for delayed autosuspends */
 	struct mutex pm_mutex;		/* protects PM operations */
 
+	unsigned autosuspend_delay;	/* in jiffies */
+
 	unsigned auto_pm:1;		/* autosuspend/resume in progress */
 	unsigned do_remote_wakeup:1;	/* remote wakeup should be enabled */
 #endif</pre><hr><pre>commit aa084f3efe5fb7e9c0d5b54ce704f0de69bbf27c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Feb 20 14:59:59 2007 -0500

    USB: minor cleanups for sysfs.c
    
    This patch (as858) makes some minor cleanups to sysfs.c in usbcore.
    Unnecessary tests are removed and a few temp variables are added.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c
index 8f5a764057cd..cad4fb323f6c 100644
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -250,10 +250,7 @@ int usb_create_sysfs_dev_files(struct usb_device *udev)
 		goto error;
 	return 0;
 error:
-	usb_remove_ep_files(&amp;udev-&gt;ep0);
-	device_remove_file(dev, &amp;dev_attr_manufacturer);
-	device_remove_file(dev, &amp;dev_attr_product);
-	device_remove_file(dev, &amp;dev_attr_serial);
+	usb_remove_sysfs_dev_files(udev);
 	return retval;
 }
 
@@ -262,14 +259,10 @@ void usb_remove_sysfs_dev_files(struct usb_device *udev)
 	struct device *dev = &amp;udev-&gt;dev;
 
 	usb_remove_ep_files(&amp;udev-&gt;ep0);
+	device_remove_file(dev, &amp;dev_attr_manufacturer);
+	device_remove_file(dev, &amp;dev_attr_product);
+	device_remove_file(dev, &amp;dev_attr_serial);
 	sysfs_remove_group(&amp;dev-&gt;kobj, &amp;dev_attr_grp);
-
-	if (udev-&gt;manufacturer)
-		device_remove_file(dev, &amp;dev_attr_manufacturer);
-	if (udev-&gt;product)
-		device_remove_file(dev, &amp;dev_attr_product);
-	if (udev-&gt;serial)
-		device_remove_file(dev, &amp;dev_attr_serial);
 }
 
 /* Interface fields */
@@ -373,33 +366,28 @@ static inline void usb_remove_intf_ep_files(struct usb_interface *intf)
 
 int usb_create_sysfs_intf_files(struct usb_interface *intf)
 {
+	struct device *dev = &amp;intf-&gt;dev;
 	struct usb_device *udev = interface_to_usbdev(intf);
 	struct usb_host_interface *alt = intf-&gt;cur_altsetting;
 	int retval;
 
-	retval = sysfs_create_group(&amp;intf-&gt;dev.kobj, &amp;intf_attr_grp);
+	retval = sysfs_create_group(&amp;dev-&gt;kobj, &amp;intf_attr_grp);
 	if (retval)
-		goto error;
+		return retval;
 
 	if (alt-&gt;string == NULL)
 		alt-&gt;string = usb_cache_string(udev, alt-&gt;desc.iInterface);
 	if (alt-&gt;string)
-		retval = device_create_file(&amp;intf-&gt;dev, &amp;dev_attr_interface);
+		retval = device_create_file(dev, &amp;dev_attr_interface);
 	usb_create_intf_ep_files(intf, udev);
 	return 0;
-error:
-	if (alt-&gt;string)
-		device_remove_file(&amp;intf-&gt;dev, &amp;dev_attr_interface);
-	sysfs_remove_group(&amp;intf-&gt;dev.kobj, &amp;intf_attr_grp);
-	usb_remove_intf_ep_files(intf);
-	return retval;
 }
 
 void usb_remove_sysfs_intf_files(struct usb_interface *intf)
 {
-	usb_remove_intf_ep_files(intf);
-	sysfs_remove_group(&amp;intf-&gt;dev.kobj, &amp;intf_attr_grp);
+	struct device *dev = &amp;intf-&gt;dev;
 
-	if (intf-&gt;cur_altsetting-&gt;string)
-		device_remove_file(&amp;intf-&gt;dev, &amp;dev_attr_interface);
+	usb_remove_intf_ep_files(intf);
+	device_remove_file(dev, &amp;dev_attr_interface);
+	sysfs_remove_group(&amp;dev-&gt;kobj, &amp;intf_attr_grp);
 }</pre><hr><pre>commit 17230acdc71137622ca7dfd789b3944c75d39404
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Feb 19 15:52:45 2007 -0500

    UHCI: Eliminate asynchronous skeleton Queue Headers
    
    This patch (as856) attempts to improve the performance of uhci-hcd by
    removing the asynchronous skeleton Queue Headers.  They don't contain
    any useful information but the controller has to read through them at
    least once every millisecond, incurring a non-zero DMA overhead.
    
    Now all the asynchronous queues are combined, along with the period-1
    interrupt queue, into a single list with a single skeleton QH.  The
    start of the low-speed control, full-speed control, and bulk sublists
    is determined by linear search.  Since there should rarely be more
    than a couple of QHs in the list, the searches should incur a much
    smaller total load than keeping the skeleton QHs.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-debug.c b/drivers/usb/host/uhci-debug.c
index a0677133577b..8d24d3dc0a61 100644
--- a/drivers/usb/host/uhci-debug.c
+++ b/drivers/usb/host/uhci-debug.c
@@ -220,16 +220,6 @@ static int uhci_show_qh(struct uhci_qh *qh, char *buf, int len, int space)
 	return out - buf;
 }
 
-static const char * const qh_names[] = {
-  "skel_unlink_qh", "skel_iso_qh",
-  "skel_int128_qh", "skel_int64_qh",
-  "skel_int32_qh", "skel_int16_qh",
-  "skel_int8_qh", "skel_int4_qh",
-  "skel_int2_qh", "skel_int1_qh",
-  "skel_ls_control_qh", "skel_fs_control_qh",
-  "skel_bulk_qh", "skel_term_qh"
-};
-
 static int uhci_show_sc(int port, unsigned short status, char *buf, int len)
 {
 	char *out = buf;
@@ -352,6 +342,12 @@ static int uhci_sprint_schedule(struct uhci_hcd *uhci, char *buf, int len)
 	struct uhci_td *td;
 	struct list_head *tmp, *head;
 	int nframes, nerrs;
+	__le32 link;
+
+	static const char * const qh_names[] = {
+		"unlink", "iso", "int128", "int64", "int32", "int16",
+		"int8", "int4", "int2", "async", "term"
+	};
 
 	out += uhci_show_root_hub_state(uhci, out, len - (out - buf));
 	out += sprintf(out, "HC status\n");
@@ -374,7 +370,7 @@ static int uhci_sprint_schedule(struct uhci_hcd *uhci, char *buf, int len)
 	nframes = 10;
 	nerrs = 0;
 	for (i = 0; i &lt; UHCI_NUMFRAMES; ++i) {
-		__le32 link, qh_dma;
+		__le32 qh_dma;
 
 		j = 0;
 		td = uhci-&gt;frame_cpu[i];
@@ -430,23 +426,21 @@ static int uhci_sprint_schedule(struct uhci_hcd *uhci, char *buf, int len)
 
 	for (i = 0; i &lt; UHCI_NUM_SKELQH; ++i) {
 		int cnt = 0;
+		__le32 fsbr_link = 0;
 
 		qh = uhci-&gt;skelqh[i];
-		out += sprintf(out, "- %s\n", qh_names[i]); \
+		out += sprintf(out, "- skel_%s_qh\n", qh_names[i]); \
 		out += uhci_show_qh(qh, out, len - (out - buf), 4);
 
 		/* Last QH is the Terminating QH, it's different */
-		if (i == UHCI_NUM_SKELQH - 1) {
-			if (qh-&gt;link != UHCI_PTR_TERM)
-				out += sprintf(out, "    bandwidth reclamation on!\n");
-
+		if (i == SKEL_TERM) {
 			if (qh_element(qh) != LINK_TO_TD(uhci-&gt;term_td))
 				out += sprintf(out, "    skel_term_qh element is not set to term_td!\n");
-
+			if (link == LINK_TO_QH(uhci-&gt;skel_term_qh))
+				goto check_qh_link;
 			continue;
 		}
 
-		j = (i &lt; 9) ? 9 : i+1;		/* Next skeleton */
 		head = &amp;qh-&gt;node;
 		tmp = head-&gt;next;
 
@@ -456,14 +450,26 @@ static int uhci_sprint_schedule(struct uhci_hcd *uhci, char *buf, int len)
 			if (++cnt &lt;= 10)
 				out += uhci_show_qh(qh, out,
 						len - (out - buf), 4);
+			if (!fsbr_link &amp;&amp; qh-&gt;skel &gt;= SKEL_FSBR)
+				fsbr_link = LINK_TO_QH(qh);
 		}
 		if ((cnt -= 10) &gt; 0)
 			out += sprintf(out, "    Skipped %d QHs\n", cnt);
 
-		if (i &gt; 1 &amp;&amp; i &lt; UHCI_NUM_SKELQH - 1) {
-			if (qh-&gt;link != LINK_TO_QH(uhci-&gt;skelqh[j]))
-				out += sprintf(out, "    last QH not linked to next skeleton!\n");
-		}
+		link = UHCI_PTR_TERM;
+		if (i &lt;= SKEL_ISO)
+			;
+		else if (i &lt; SKEL_ASYNC)
+			link = LINK_TO_QH(uhci-&gt;skel_async_qh);
+		else if (!uhci-&gt;fsbr_is_on)
+			;
+		else if (fsbr_link)
+			link = fsbr_link;
+		else
+			link = LINK_TO_QH(uhci-&gt;skel_term_qh);
+check_qh_link:
+		if (qh-&gt;link != link)
+			out += sprintf(out, "    last QH not linked to next skeleton!\n");
 	}
 
 	return out - buf;
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 1f0833ab294a..44da4334f1d6 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -13,7 +13,7 @@
  * (C) Copyright 2000 Yggdrasil Computing, Inc. (port of new PCI interface
  *               support from usb-ohci.c by Adam Richter, adam@yggdrasil.com).
  * (C) Copyright 1999 Gregory P. Smith (from usb-ohci.c)
- * (C) Copyright 2004-2006 Alan Stern, stern@rowland.harvard.edu
+ * (C) Copyright 2004-2007 Alan Stern, stern@rowland.harvard.edu
  *
  * Intel documents this fairly well, and as far as I know there
  * are no royalties or anything like that, but even so there are
@@ -107,10 +107,10 @@ static __le32 uhci_frame_skel_link(struct uhci_hcd *uhci, int frame)
 	 * interrupt QHs, which will help spread out bandwidth utilization.
 	 *
 	 * ffs (Find First bit Set) does exactly what we need:
-	 * 1,3,5,...  =&gt; ffs = 0 =&gt; use skel_int2_qh = skelqh[8],
-	 * 2,6,10,... =&gt; ffs = 1 =&gt; use skel_int4_qh = skelqh[7], etc.
+	 * 1,3,5,...  =&gt; ffs = 0 =&gt; use period-2 QH = skelqh[8],
+	 * 2,6,10,... =&gt; ffs = 1 =&gt; use period-4 QH = skelqh[7], etc.
 	 * ffs &gt;= 7 =&gt; not on any high-period queue, so use
-	 *	skel_int1_qh = skelqh[9].
+	 *	period-1 QH = skelqh[9].
 	 * Add in UHCI_NUMFRAMES to insure at least one bit is set.
 	 */
 	skelnum = 8 - (int) __ffs(frame | UHCI_NUMFRAMES);
@@ -540,16 +540,18 @@ static void uhci_shutdown(struct pci_dev *pdev)
  *
  * The hardware doesn't really know any difference
  * in the queues, but the order does matter for the
- * protocols higher up. The order is:
+ * protocols higher up.  The order in which the queues
+ * are encountered by the hardware is:
  *
- *  - any isochronous events handled before any
+ *  - All isochronous events are handled before any
  *    of the queues. We don't do that here, because
  *    we'll create the actual TD entries on demand.
- *  - The first queue is the interrupt queue.
- *  - The second queue is the control queue, split into low- and full-speed
- *  - The third queue is bulk queue.
- *  - The fourth queue is the bandwidth reclamation queue, which loops back
- *    to the full-speed control queue.
+ *  - The first queue is the high-period interrupt queue.
+ *  - The second queue is the period-1 interrupt and async
+ *    (low-speed control, full-speed control, then bulk) queue.
+ *  - The third queue is the terminating bandwidth reclamation queue,
+ *    which contains no members, loops back to itself, and is present
+ *    only when FSBR is on and there are no full-speed control or bulk QHs.
  */
 static int uhci_start(struct usb_hcd *hcd)
 {
@@ -626,30 +628,18 @@ static int uhci_start(struct usb_hcd *hcd)
 	}
 
 	/*
-	 * 8 Interrupt queues; link all higher int queues to int1,
-	 * then link int1 to control and control to bulk
+	 * 8 Interrupt queues; link all higher int queues to int1 = async
 	 */
-	uhci-&gt;skel_int128_qh-&gt;link =
-			uhci-&gt;skel_int64_qh-&gt;link =
-			uhci-&gt;skel_int32_qh-&gt;link =
-			uhci-&gt;skel_int16_qh-&gt;link =
-			uhci-&gt;skel_int8_qh-&gt;link =
-			uhci-&gt;skel_int4_qh-&gt;link =
-			uhci-&gt;skel_int2_qh-&gt;link = LINK_TO_QH(
-				uhci-&gt;skel_int1_qh);
-
-	uhci-&gt;skel_int1_qh-&gt;link = LINK_TO_QH(uhci-&gt;skel_ls_control_qh);
-	uhci-&gt;skel_ls_control_qh-&gt;link = LINK_TO_QH(uhci-&gt;skel_fs_control_qh);
-	uhci-&gt;skel_fs_control_qh-&gt;link = LINK_TO_QH(uhci-&gt;skel_bulk_qh);
-	uhci-&gt;skel_bulk_qh-&gt;link = LINK_TO_QH(uhci-&gt;skel_term_qh);
+	for (i = SKEL_ISO + 1; i &lt; SKEL_ASYNC; ++i)
+		uhci-&gt;skelqh[i]-&gt;link = LINK_TO_QH(uhci-&gt;skel_async_qh);
+	uhci-&gt;skel_async_qh-&gt;link = uhci-&gt;skel_term_qh-&gt;link = UHCI_PTR_TERM;
 
 	/* This dummy TD is to work around a bug in Intel PIIX controllers */
 	uhci_fill_td(uhci-&gt;term_td, 0, uhci_explen(0) |
-		(0x7f &lt;&lt; TD_TOKEN_DEVADDR_SHIFT) | USB_PID_IN, 0);
-	uhci-&gt;term_td-&gt;link = LINK_TO_TD(uhci-&gt;term_td);
-
-	uhci-&gt;skel_term_qh-&gt;link = UHCI_PTR_TERM;
-	uhci-&gt;skel_term_qh-&gt;element = LINK_TO_TD(uhci-&gt;term_td);
+			(0x7f &lt;&lt; TD_TOKEN_DEVADDR_SHIFT) | USB_PID_IN, 0);
+	uhci-&gt;term_td-&gt;link = UHCI_PTR_TERM;
+	uhci-&gt;skel_async_qh-&gt;element = uhci-&gt;skel_term_qh-&gt;element =
+			LINK_TO_TD(uhci-&gt;term_td);
 
 	/*
 	 * Fill the frame list: make all entries point to the proper
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index a8c256b44d8e..1b3d23406ac4 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -135,7 +135,6 @@ struct uhci_qh {
 	struct usb_host_endpoint *hep;	/* Endpoint information */
 	struct usb_device *udev;
 	struct list_head queue;		/* Queue of urbps for this QH */
-	struct uhci_qh *skel;		/* Skeleton for this QH */
 	struct uhci_td *dummy_td;	/* Dummy TD to end the queue */
 	struct uhci_td *post_td;	/* Last TD completed */
 
@@ -151,6 +150,7 @@ struct uhci_qh {
 
 	int state;			/* QH_STATE_xxx; see above */
 	int type;			/* Queue type (control, bulk, etc) */
+	int skel;			/* Skeleton queue number */
 
 	unsigned int initial_toggle:1;	/* Endpoint's current toggle value */
 	unsigned int needs_fixup:1;	/* Must fix the TD toggle values */
@@ -276,12 +276,13 @@ static inline u32 td_status(struct uhci_td *td) {
 /*
  * The UHCI driver uses QHs with Interrupt, Control and Bulk URBs for
  * automatic queuing. To make it easy to insert entries into the schedule,
- * we have a skeleton of QHs for each predefined Interrupt latency,
- * low-speed control, full-speed control, bulk, and terminating QH
- * (see explanation for the terminating QH below).
+ * we have a skeleton of QHs for each predefined Interrupt latency.
+ * Asynchronous QHs (low-speed control, full-speed control, and bulk)
+ * go onto the period-1 interrupt list, since they all get accessed on
+ * every frame.
  *
- * When we want to add a new QH, we add it to the end of the list for the
- * skeleton QH.  For instance, the schedule list can look like this:
+ * When we want to add a new QH, we add it to the list starting from the
+ * appropriate skeleton QH.  For instance, the schedule can look like this:
  *
  * skel int128 QH
  * dev 1 interrupt QH
@@ -289,50 +290,47 @@ static inline u32 td_status(struct uhci_td *td) {
  * skel int64 QH
  * skel int32 QH
  * ...
- * skel int1 QH
- * skel low-speed control QH
- * dev 5 control QH
- * skel full-speed control QH
- * skel bulk QH
+ * skel int1 + async QH
+ * dev 5 low-speed control QH
  * dev 1 bulk QH
  * dev 2 bulk QH
- * skel terminating QH
  *
- * The terminating QH is used for 2 reasons:
- * - To place a terminating TD which is used to workaround a PIIX bug
- *   (see Intel errata for explanation), and
- * - To loop back to the full-speed control queue for full-speed bandwidth
- *   reclamation.
+ * There is a special terminating QH used to keep full-speed bandwidth
+ * reclamation active when no full-speed control or bulk QHs are linked
+ * into the schedule.  It has an inactive TD (to work around a PIIX bug,
+ * see the Intel errata) and it points back to itself.
  *
- * There's a special skeleton QH for Isochronous QHs.  It never appears
- * on the schedule, and Isochronous TDs go on the schedule before the
+ * There's a special skeleton QH for Isochronous QHs which never appears
+ * on the schedule.  Isochronous TDs go on the schedule before the
  * the skeleton QHs.  The hardware accesses them directly rather than
  * through their QH, which is used only for bookkeeping purposes.
  * While the UHCI spec doesn't forbid the use of QHs for Isochronous,
  * it doesn't use them either.  And the spec says that queues never
  * advance on an error completion status, which makes them totally
  * unsuitable for Isochronous transfers.
+ *
+ * There's also a special skeleton QH used for QHs which are in the process
+ * of unlinking and so may still be in use by the hardware.  It too never
+ * appears on the schedule.
  */
 
-#define UHCI_NUM_SKELQH		14
-#define skel_unlink_qh		skelqh[0]
-#define skel_iso_qh		skelqh[1]
-#define skel_int128_qh		skelqh[2]
-#define skel_int64_qh		skelqh[3]
-#define skel_int32_qh		skelqh[4]
-#define skel_int16_qh		skelqh[5]
-#define skel_int8_qh		skelqh[6]
-#define skel_int4_qh		skelqh[7]
-#define skel_int2_qh		skelqh[8]
-#define skel_int1_qh		skelqh[9]
-#define skel_ls_control_qh	skelqh[10]
-#define skel_fs_control_qh	skelqh[11]
-#define skel_bulk_qh		skelqh[12]
-#define skel_term_qh		skelqh[13]
-
-/* Find the skelqh entry corresponding to an interval exponent */
-#define UHCI_SKEL_INDEX(exponent)	(9 - exponent)
-
+#define UHCI_NUM_SKELQH		11
+#define SKEL_UNLINK		0
+#define skel_unlink_qh		skelqh[SKEL_UNLINK]
+#define SKEL_ISO		1
+#define skel_iso_qh		skelqh[SKEL_ISO]
+	/* int128, int64, ..., int1 = 2, 3, ..., 9 */
+#define SKEL_INDEX(exponent)	(9 - exponent)
+#define SKEL_ASYNC		9
+#define skel_async_qh		skelqh[SKEL_ASYNC]
+#define SKEL_TERM		10
+#define skel_term_qh		skelqh[SKEL_TERM]
+
+/* The following entries refer to sublists of skel_async_qh */
+#define SKEL_LS_CONTROL		20
+#define SKEL_FS_CONTROL		21
+#define SKEL_FSBR		SKEL_FS_CONTROL
+#define SKEL_BULK		22
 
 /*
  *	The UHCI controller and root hub
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index a0c6bf6128a3..f4ebdb3e488f 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -13,7 +13,7 @@
  * (C) Copyright 2000 Yggdrasil Computing, Inc. (port of new PCI interface
  *               support from usb-ohci.c by Adam Richter, adam@yggdrasil.com).
  * (C) Copyright 1999 Gregory P. Smith (from usb-ohci.c)
- * (C) Copyright 2004-2006 Alan Stern, stern@rowland.harvard.edu
+ * (C) Copyright 2004-2007 Alan Stern, stern@rowland.harvard.edu
  */
 
 
@@ -45,14 +45,43 @@ static inline void uhci_clear_next_interrupt(struct uhci_hcd *uhci)
  */
 static void uhci_fsbr_on(struct uhci_hcd *uhci)
 {
+	struct uhci_qh *fsbr_qh, *lqh, *tqh;
+
 	uhci-&gt;fsbr_is_on = 1;
-	uhci-&gt;skel_term_qh-&gt;link = LINK_TO_QH(uhci-&gt;skel_fs_control_qh);
+	lqh = list_entry(uhci-&gt;skel_async_qh-&gt;node.prev,
+			struct uhci_qh, node);
+
+	/* Find the first FSBR QH.  Linear search through the list is
+	 * acceptable because normally FSBR gets turned on as soon as
+	 * one QH needs it. */
+	fsbr_qh = NULL;
+	list_for_each_entry_reverse(tqh, &amp;uhci-&gt;skel_async_qh-&gt;node, node) {
+		if (tqh-&gt;skel &lt; SKEL_FSBR)
+			break;
+		fsbr_qh = tqh;
+	}
+
+	/* No FSBR QH means we must insert the terminating skeleton QH */
+	if (!fsbr_qh) {
+		uhci-&gt;skel_term_qh-&gt;link = LINK_TO_QH(uhci-&gt;skel_term_qh);
+		wmb();
+		lqh-&gt;link = uhci-&gt;skel_term_qh-&gt;link;
+
+	/* Otherwise loop the last QH to the first FSBR QH */
+	} else
+		lqh-&gt;link = LINK_TO_QH(fsbr_qh);
 }
 
 static void uhci_fsbr_off(struct uhci_hcd *uhci)
 {
+	struct uhci_qh *lqh;
+
 	uhci-&gt;fsbr_is_on = 0;
-	uhci-&gt;skel_term_qh-&gt;link = UHCI_PTR_TERM;
+	lqh = list_entry(uhci-&gt;skel_async_qh-&gt;node.prev,
+			struct uhci_qh, node);
+
+	/* End the async list normally and unlink the terminating QH */
+	lqh-&gt;link = uhci-&gt;skel_term_qh-&gt;link = UHCI_PTR_TERM;
 }
 
 static void uhci_add_fsbr(struct uhci_hcd *uhci, struct urb *urb)
@@ -404,12 +433,81 @@ static void uhci_fixup_toggles(struct uhci_qh *qh, int skip_first)
 }
 
 /*
- * Put a QH on the schedule in both hardware and software
+ * Link an Isochronous QH into its skeleton's list
  */
-static void uhci_activate_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
+static inline void link_iso(struct uhci_hcd *uhci, struct uhci_qh *qh)
+{
+	list_add_tail(&amp;qh-&gt;node, &amp;uhci-&gt;skel_iso_qh-&gt;node);
+
+	/* Isochronous QHs aren't linked by the hardware */
+}
+
+/*
+ * Link a high-period interrupt QH into the schedule at the end of its
+ * skeleton's list
+ */
+static void link_interrupt(struct uhci_hcd *uhci, struct uhci_qh *qh)
 {
 	struct uhci_qh *pqh;
 
+	list_add_tail(&amp;qh-&gt;node, &amp;uhci-&gt;skelqh[qh-&gt;skel]-&gt;node);
+
+	pqh = list_entry(qh-&gt;node.prev, struct uhci_qh, node);
+	qh-&gt;link = pqh-&gt;link;
+	wmb();
+	pqh-&gt;link = LINK_TO_QH(qh);
+}
+
+/*
+ * Link a period-1 interrupt or async QH into the schedule at the
+ * correct spot in the async skeleton's list, and update the FSBR link
+ */
+static void link_async(struct uhci_hcd *uhci, struct uhci_qh *qh)
+{
+	struct uhci_qh *pqh, *lqh;
+	__le32 link_to_new_qh;
+	__le32 *extra_link = &amp;link_to_new_qh;
+
+	/* Find the predecessor QH for our new one and insert it in the list.
+	 * The list of QHs is expected to be short, so linear search won't
+	 * take too long. */
+	list_for_each_entry_reverse(pqh, &amp;uhci-&gt;skel_async_qh-&gt;node, node) {
+		if (pqh-&gt;skel &lt;= qh-&gt;skel)
+			break;
+	}
+	list_add(&amp;qh-&gt;node, &amp;pqh-&gt;node);
+	qh-&gt;link = pqh-&gt;link;
+
+	link_to_new_qh = LINK_TO_QH(qh);
+
+	/* If this is now the first FSBR QH, take special action */
+	if (uhci-&gt;fsbr_is_on &amp;&amp; pqh-&gt;skel &lt; SKEL_FSBR &amp;&amp;
+			qh-&gt;skel &gt;= SKEL_FSBR) {
+		lqh = list_entry(uhci-&gt;skel_async_qh-&gt;node.prev,
+				struct uhci_qh, node);
+
+		/* If the new QH is also the last one, we must unlink
+		 * the terminating skeleton QH and make the new QH point
+		 * back to itself. */
+		if (qh == lqh) {
+			qh-&gt;link = link_to_new_qh;
+			extra_link = &amp;uhci-&gt;skel_term_qh-&gt;link;
+
+		/* Otherwise the last QH must point to the new QH */
+		} else
+			extra_link = &amp;lqh-&gt;link;
+	}
+
+	/* Link it into the schedule */
+	wmb();
+	*extra_link = pqh-&gt;link = link_to_new_qh;
+}
+
+/*
+ * Put a QH on the schedule in both hardware and software
+ */
+static void uhci_activate_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
+{
 	WARN_ON(list_empty(&amp;qh-&gt;queue));
 
 	/* Set the element pointer if it isn't set already.
@@ -431,18 +529,64 @@ static void uhci_activate_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
 		return;
 	qh-&gt;state = QH_STATE_ACTIVE;
 
-	/* Move the QH from its old list to the end of the appropriate
+	/* Move the QH from its old list to the correct spot in the appropriate
 	 * skeleton's list */
 	if (qh == uhci-&gt;next_qh)
 		uhci-&gt;next_qh = list_entry(qh-&gt;node.next, struct uhci_qh,
 				node);
-	list_move_tail(&amp;qh-&gt;node, &amp;qh-&gt;skel-&gt;node);
+	list_del(&amp;qh-&gt;node);
+
+	if (qh-&gt;skel == SKEL_ISO)
+		link_iso(uhci, qh);
+	else if (qh-&gt;skel &lt; SKEL_ASYNC)
+		link_interrupt(uhci, qh);
+	else
+		link_async(uhci, qh);
+}
+
+/*
+ * Unlink a high-period interrupt QH from the schedule
+ */
+static void unlink_interrupt(struct uhci_hcd *uhci, struct uhci_qh *qh)
+{
+	struct uhci_qh *pqh;
 
-	/* Link it into the schedule */
 	pqh = list_entry(qh-&gt;node.prev, struct uhci_qh, node);
-	qh-&gt;link = pqh-&gt;link;
-	wmb();
-	pqh-&gt;link = LINK_TO_QH(qh);
+	pqh-&gt;link = qh-&gt;link;
+	mb();
+}
+
+/*
+ * Unlink a period-1 interrupt or async QH from the schedule
+ */
+static void unlink_async(struct uhci_hcd *uhci, struct uhci_qh *qh)
+{
+	struct uhci_qh *pqh, *lqh;
+	__le32 link_to_next_qh = qh-&gt;link;
+
+	pqh = list_entry(qh-&gt;node.prev, struct uhci_qh, node);
+
+	/* If this is the first FSBQ QH, take special action */
+	if (uhci-&gt;fsbr_is_on &amp;&amp; pqh-&gt;skel &lt; SKEL_FSBR &amp;&amp;
+			qh-&gt;skel &gt;= SKEL_FSBR) {
+		lqh = list_entry(uhci-&gt;skel_async_qh-&gt;node.prev,
+				struct uhci_qh, node);
+
+		/* If this QH is also the last one, we must link in
+		 * the terminating skeleton QH. */
+		if (qh == lqh) {
+			link_to_next_qh = LINK_TO_QH(uhci-&gt;skel_term_qh);
+			uhci-&gt;skel_term_qh-&gt;link = link_to_next_qh;
+			wmb();
+			qh-&gt;link = link_to_next_qh;
+
+		/* Otherwise the last QH must point to the new first FSBR QH */
+		} else
+			lqh-&gt;link = link_to_next_qh;
+	}
+
+	pqh-&gt;link = link_to_next_qh;
+	mb();
 }
 
 /*
@@ -450,17 +594,18 @@ static void uhci_activate_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
  */
 static void uhci_unlink_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
 {
-	struct uhci_qh *pqh;
-
 	if (qh-&gt;state == QH_STATE_UNLINKING)
 		return;
 	WARN_ON(qh-&gt;state != QH_STATE_ACTIVE || !qh-&gt;udev);
 	qh-&gt;state = QH_STATE_UNLINKING;
 
 	/* Unlink the QH from the schedule and record when we did it */
-	pqh = list_entry(qh-&gt;node.prev, struct uhci_qh, node);
-	pqh-&gt;link = qh-&gt;link;
-	mb();
+	if (qh-&gt;skel == SKEL_ISO)
+		;
+	else if (qh-&gt;skel &lt; SKEL_ASYNC)
+		unlink_interrupt(uhci, qh);
+	else
+		unlink_async(uhci, qh);
 
 	uhci_get_current_frame_number(uhci);
 	qh-&gt;unlink_frame = uhci-&gt;frame_number;
@@ -696,6 +841,7 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb,
 	dma_addr_t data = urb-&gt;transfer_dma;
 	__le32 *plink;
 	struct urb_priv *urbp = urb-&gt;hcpriv;
+	int skel;
 
 	/* The "pipe" thing contains the destination in bits 8--18 */
 	destination = (urb-&gt;pipe &amp; PIPE_DEVEP_MASK) | USB_PID_SETUP;
@@ -796,11 +942,13 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb,
 	 * isn't in the CONFIGURED state. */
 	if (urb-&gt;dev-&gt;speed == USB_SPEED_LOW ||
 			urb-&gt;dev-&gt;state != USB_STATE_CONFIGURED)
-		qh-&gt;skel = uhci-&gt;skel_ls_control_qh;
+		skel = SKEL_LS_CONTROL;
 	else {
-		qh-&gt;skel = uhci-&gt;skel_fs_control_qh;
+		skel = SKEL_FS_CONTROL;
 		uhci_add_fsbr(uhci, urb);
 	}
+	if (qh-&gt;state != QH_STATE_ACTIVE)
+		qh-&gt;skel = skel;
 
 	urb-&gt;actual_length = -8;	/* Account for the SETUP packet */
 	return 0;
@@ -930,7 +1078,7 @@ static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb,
 	return -ENOMEM;
 }
 
-static inline int uhci_submit_bulk(struct uhci_hcd *uhci, struct urb *urb,
+static int uhci_submit_bulk(struct uhci_hcd *uhci, struct urb *urb,
 		struct uhci_qh *qh)
 {
 	int ret;
@@ -939,7 +1087,8 @@ static inline int uhci_submit_bulk(struct uhci_hcd *uhci, struct urb *urb,
 	if (urb-&gt;dev-&gt;speed == USB_SPEED_LOW)
 		return -EINVAL;
 
-	qh-&gt;skel = uhci-&gt;skel_bulk_qh;
+	if (qh-&gt;state != QH_STATE_ACTIVE)
+		qh-&gt;skel = SKEL_BULK;
 	ret = uhci_submit_common(uhci, urb, qh);
 	if (ret == 0)
 		uhci_add_fsbr(uhci, urb);
@@ -967,7 +1116,7 @@ static int uhci_submit_interrupt(struct uhci_hcd *uhci, struct urb *urb,
 		if (exponent &lt; 0)
 			return -EINVAL;
 		qh-&gt;period = 1 &lt;&lt; exponent;
-		qh-&gt;skel = uhci-&gt;skelqh[UHCI_SKEL_INDEX(exponent)];
+		qh-&gt;skel = SKEL_INDEX(exponent);
 
 		/* For now, interrupt phase is fixed by the layout
 		 * of the QH lists. */
@@ -1215,7 +1364,7 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb,
 		qh-&gt;iso_status = 0;
 	}
 
-	qh-&gt;skel = uhci-&gt;skel_iso_qh;
+	qh-&gt;skel = SKEL_ISO;
 	if (!qh-&gt;bandwidth_reserved)
 		uhci_reserve_bandwidth(uhci, qh);
 	return 0;</pre><hr><pre>commit 28b9325e6ae45ffb5e99fedcafe00f25fcaacf06
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Feb 19 15:51:51 2007 -0500

    UHCI: Add macros for computing DMA values
    
    This patch (as855) adds some convenience macros to uhci-hcd, to help
    simplify the code for computing hardware DMA pointers.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-debug.c b/drivers/usb/host/uhci-debug.c
index 5d6c06bc4524..a0677133577b 100644
--- a/drivers/usb/host/uhci-debug.c
+++ b/drivers/usb/host/uhci-debug.c
@@ -196,7 +196,7 @@ static int uhci_show_qh(struct uhci_qh *qh, char *buf, int len, int space)
 		struct uhci_td *td = list_entry(urbp-&gt;td_list.next,
 				struct uhci_td, list);
 
-		if (cpu_to_le32(td-&gt;dma_handle) != (element &amp; ~UHCI_PTR_BITS))
+		if (element != LINK_TO_TD(td))
 			out += sprintf(out, "%*s Element != First TD\n",
 					space, "");
 		i = nurbs = 0;
@@ -393,7 +393,7 @@ static int uhci_sprint_schedule(struct uhci_hcd *uhci, char *buf, int len)
 		do {
 			td = list_entry(tmp, struct uhci_td, fl_list);
 			tmp = tmp-&gt;next;
-			if (cpu_to_le32(td-&gt;dma_handle) != link) {
+			if (link != LINK_TO_TD(td)) {
 				if (nframes &gt; 0)
 					out += sprintf(out, "    link does "
 						"not match list entry!\n");
@@ -440,7 +440,7 @@ static int uhci_sprint_schedule(struct uhci_hcd *uhci, char *buf, int len)
 			if (qh-&gt;link != UHCI_PTR_TERM)
 				out += sprintf(out, "    bandwidth reclamation on!\n");
 
-			if (qh_element(qh) != cpu_to_le32(uhci-&gt;term_td-&gt;dma_handle))
+			if (qh_element(qh) != LINK_TO_TD(uhci-&gt;term_td))
 				out += sprintf(out, "    skel_term_qh element is not set to term_td!\n");
 
 			continue;
@@ -461,8 +461,7 @@ static int uhci_sprint_schedule(struct uhci_hcd *uhci, char *buf, int len)
 			out += sprintf(out, "    Skipped %d QHs\n", cnt);
 
 		if (i &gt; 1 &amp;&amp; i &lt; UHCI_NUM_SKELQH - 1) {
-			if (qh-&gt;link !=
-			    (cpu_to_le32(uhci-&gt;skelqh[j]-&gt;dma_handle) | UHCI_PTR_QH))
+			if (qh-&gt;link != LINK_TO_QH(uhci-&gt;skelqh[j]))
 				out += sprintf(out, "    last QH not linked to next skeleton!\n");
 		}
 	}
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index ded4df30a631..1f0833ab294a 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -116,7 +116,7 @@ static __le32 uhci_frame_skel_link(struct uhci_hcd *uhci, int frame)
 	skelnum = 8 - (int) __ffs(frame | UHCI_NUMFRAMES);
 	if (skelnum &lt;= 1)
 		skelnum = 9;
-	return UHCI_PTR_QH | cpu_to_le32(uhci-&gt;skelqh[skelnum]-&gt;dma_handle);
+	return LINK_TO_QH(uhci-&gt;skelqh[skelnum]);
 }
 
 #include "uhci-debug.c"
@@ -635,25 +635,21 @@ static int uhci_start(struct usb_hcd *hcd)
 			uhci-&gt;skel_int16_qh-&gt;link =
 			uhci-&gt;skel_int8_qh-&gt;link =
 			uhci-&gt;skel_int4_qh-&gt;link =
-			uhci-&gt;skel_int2_qh-&gt;link = UHCI_PTR_QH |
-			cpu_to_le32(uhci-&gt;skel_int1_qh-&gt;dma_handle);
-
-	uhci-&gt;skel_int1_qh-&gt;link = UHCI_PTR_QH |
-			cpu_to_le32(uhci-&gt;skel_ls_control_qh-&gt;dma_handle);
-	uhci-&gt;skel_ls_control_qh-&gt;link = UHCI_PTR_QH |
-			cpu_to_le32(uhci-&gt;skel_fs_control_qh-&gt;dma_handle);
-	uhci-&gt;skel_fs_control_qh-&gt;link = UHCI_PTR_QH |
-			cpu_to_le32(uhci-&gt;skel_bulk_qh-&gt;dma_handle);
-	uhci-&gt;skel_bulk_qh-&gt;link = UHCI_PTR_QH |
-			cpu_to_le32(uhci-&gt;skel_term_qh-&gt;dma_handle);
+			uhci-&gt;skel_int2_qh-&gt;link = LINK_TO_QH(
+				uhci-&gt;skel_int1_qh);
+
+	uhci-&gt;skel_int1_qh-&gt;link = LINK_TO_QH(uhci-&gt;skel_ls_control_qh);
+	uhci-&gt;skel_ls_control_qh-&gt;link = LINK_TO_QH(uhci-&gt;skel_fs_control_qh);
+	uhci-&gt;skel_fs_control_qh-&gt;link = LINK_TO_QH(uhci-&gt;skel_bulk_qh);
+	uhci-&gt;skel_bulk_qh-&gt;link = LINK_TO_QH(uhci-&gt;skel_term_qh);
 
 	/* This dummy TD is to work around a bug in Intel PIIX controllers */
 	uhci_fill_td(uhci-&gt;term_td, 0, uhci_explen(0) |
 		(0x7f &lt;&lt; TD_TOKEN_DEVADDR_SHIFT) | USB_PID_IN, 0);
-	uhci-&gt;term_td-&gt;link = cpu_to_le32(uhci-&gt;term_td-&gt;dma_handle);
+	uhci-&gt;term_td-&gt;link = LINK_TO_TD(uhci-&gt;term_td);
 
 	uhci-&gt;skel_term_qh-&gt;link = UHCI_PTR_TERM;
-	uhci-&gt;skel_term_qh-&gt;element = cpu_to_le32(uhci-&gt;term_td-&gt;dma_handle);
+	uhci-&gt;skel_term_qh-&gt;element = LINK_TO_TD(uhci-&gt;term_td);
 
 	/*
 	 * Fill the frame list: make all entries point to the proper
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index 74469b5bcb61..a8c256b44d8e 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -129,6 +129,8 @@ struct uhci_qh {
 	__le32 element;			/* Queue element (TD) pointer */
 
 	/* Software fields */
+	dma_addr_t dma_handle;
+
 	struct list_head node;		/* Node in the list of QHs */
 	struct usb_host_endpoint *hep;	/* Endpoint information */
 	struct usb_device *udev;
@@ -150,8 +152,6 @@ struct uhci_qh {
 	int state;			/* QH_STATE_xxx; see above */
 	int type;			/* Queue type (control, bulk, etc) */
 
-	dma_addr_t dma_handle;
-
 	unsigned int initial_toggle:1;	/* Endpoint's current toggle value */
 	unsigned int needs_fixup:1;	/* Must fix the TD toggle values */
 	unsigned int is_stopped:1;	/* Queue was stopped by error/unlink */
@@ -171,6 +171,8 @@ static inline __le32 qh_element(struct uhci_qh *qh) {
 	return element;
 }
 
+#define LINK_TO_QH(qh)		(UHCI_PTR_QH | cpu_to_le32((qh)-&gt;dma_handle))
+
 
 /*
  *	Transfer Descriptors
@@ -264,6 +266,8 @@ static inline u32 td_status(struct uhci_td *td) {
 	return le32_to_cpu(status);
 }
 
+#define LINK_TO_TD(td)		(cpu_to_le32((td)-&gt;dma_handle))
+
 
 /*
  *	Skeleton Queue Headers
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 68e66b33e726..a0c6bf6128a3 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -46,8 +46,7 @@ static inline void uhci_clear_next_interrupt(struct uhci_hcd *uhci)
 static void uhci_fsbr_on(struct uhci_hcd *uhci)
 {
 	uhci-&gt;fsbr_is_on = 1;
-	uhci-&gt;skel_term_qh-&gt;link = cpu_to_le32(
-			uhci-&gt;skel_fs_control_qh-&gt;dma_handle) | UHCI_PTR_QH;
+	uhci-&gt;skel_term_qh-&gt;link = LINK_TO_QH(uhci-&gt;skel_fs_control_qh);
 }
 
 static void uhci_fsbr_off(struct uhci_hcd *uhci)
@@ -158,11 +157,11 @@ static inline void uhci_insert_td_in_frame_list(struct uhci_hcd *uhci,
 
 		td-&gt;link = ltd-&gt;link;
 		wmb();
-		ltd-&gt;link = cpu_to_le32(td-&gt;dma_handle);
+		ltd-&gt;link = LINK_TO_TD(td);
 	} else {
 		td-&gt;link = uhci-&gt;frame[framenum];
 		wmb();
-		uhci-&gt;frame[framenum] = cpu_to_le32(td-&gt;dma_handle);
+		uhci-&gt;frame[framenum] = LINK_TO_TD(td);
 		uhci-&gt;frame_cpu[framenum] = td;
 	}
 }
@@ -184,7 +183,7 @@ static inline void uhci_remove_td_from_frame_list(struct uhci_hcd *uhci,
 			struct uhci_td *ntd;
 
 			ntd = list_entry(td-&gt;fl_list.next, struct uhci_td, fl_list);
-			uhci-&gt;frame[td-&gt;frame] = cpu_to_le32(ntd-&gt;dma_handle);
+			uhci-&gt;frame[td-&gt;frame] = LINK_TO_TD(ntd);
 			uhci-&gt;frame_cpu[td-&gt;frame] = ntd;
 		}
 	} else {
@@ -421,7 +420,7 @@ static void uhci_activate_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
 		struct uhci_td *td = list_entry(urbp-&gt;td_list.next,
 				struct uhci_td, list);
 
-		qh-&gt;element = cpu_to_le32(td-&gt;dma_handle);
+		qh-&gt;element = LINK_TO_TD(td);
 	}
 
 	/* Treat the queue as if it has just advanced */
@@ -443,7 +442,7 @@ static void uhci_activate_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
 	pqh = list_entry(qh-&gt;node.prev, struct uhci_qh, node);
 	qh-&gt;link = pqh-&gt;link;
 	wmb();
-	pqh-&gt;link = UHCI_PTR_QH | cpu_to_le32(qh-&gt;dma_handle);
+	pqh-&gt;link = LINK_TO_QH(qh);
 }
 
 /*
@@ -737,7 +736,7 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb,
 		td = uhci_alloc_td(uhci);
 		if (!td)
 			goto nomem;
-		*plink = cpu_to_le32(td-&gt;dma_handle);
+		*plink = LINK_TO_TD(td);
 
 		/* Alternate Data0/1 (start with Data1) */
 		destination ^= TD_TOKEN_TOGGLE;
@@ -757,7 +756,7 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb,
 	td = uhci_alloc_td(uhci);
 	if (!td)
 		goto nomem;
-	*plink = cpu_to_le32(td-&gt;dma_handle);
+	*plink = LINK_TO_TD(td);
 
 	/*
 	 * It's IN if the pipe is an output pipe or we're not expecting
@@ -784,7 +783,7 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb,
 	td = uhci_alloc_td(uhci);
 	if (!td)
 		goto nomem;
-	*plink = cpu_to_le32(td-&gt;dma_handle);
+	*plink = LINK_TO_TD(td);
 
 	uhci_fill_td(td, 0, USB_PID_OUT | uhci_explen(0), 0);
 	wmb();
@@ -860,7 +859,7 @@ static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb,
 			td = uhci_alloc_td(uhci);
 			if (!td)
 				goto nomem;
-			*plink = cpu_to_le32(td-&gt;dma_handle);
+			*plink = LINK_TO_TD(td);
 		}
 		uhci_add_td_to_urbp(td, urbp);
 		uhci_fill_td(td, status,
@@ -888,7 +887,7 @@ static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb,
 		td = uhci_alloc_td(uhci);
 		if (!td)
 			goto nomem;
-		*plink = cpu_to_le32(td-&gt;dma_handle);
+		*plink = LINK_TO_TD(td);
 
 		uhci_add_td_to_urbp(td, urbp);
 		uhci_fill_td(td, status,
@@ -914,7 +913,7 @@ static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb,
 	td = uhci_alloc_td(uhci);
 	if (!td)
 		goto nomem;
-	*plink = cpu_to_le32(td-&gt;dma_handle);
+	*plink = LINK_TO_TD(td);
 
 	uhci_fill_td(td, 0, USB_PID_OUT | uhci_explen(0), 0);
 	wmb();
@@ -1005,7 +1004,7 @@ static int uhci_fixup_short_transfer(struct uhci_hcd *uhci,
 		 * the queue at the status stage transaction, which is
 		 * the last TD. */
 		WARN_ON(list_empty(&amp;urbp-&gt;td_list));
-		qh-&gt;element = cpu_to_le32(td-&gt;dma_handle);
+		qh-&gt;element = LINK_TO_TD(td);
 		tmp = td-&gt;list.prev;
 		ret = -EINPROGRESS;
 
@@ -1566,8 +1565,7 @@ static int uhci_advance_check(struct uhci_hcd *uhci, struct uhci_qh *qh)
 	if (time_after(jiffies, qh-&gt;advance_jiffies + QH_WAIT_TIMEOUT)) {
 
 		/* Detect the Intel bug and work around it */
-		if (qh-&gt;post_td &amp;&amp; qh_element(qh) ==
-				cpu_to_le32(qh-&gt;post_td-&gt;dma_handle)) {
+		if (qh-&gt;post_td &amp;&amp; qh_element(qh) == LINK_TO_TD(qh-&gt;post_td)) {
 			qh-&gt;element = qh-&gt;post_td-&gt;link;
 			qh-&gt;advance_jiffies = jiffies;
 			ret = 1;</pre><hr><pre>commit 3f141e2aed586c41c2666d49c70c1c1bbb6d6abd
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Feb 8 16:40:43 2007 -0500

    USB: unconfigure devices which have config 0
    
    Some USB devices do have a configuration 0, in contravention of the
    USB spec.  Normally 0 is supposed to indicate that a device is
    unconfigured.
    
    While we can't change what the device is doing, we can change usbcore.
    This patch (as852) allows usb_set_configuration() to accept a config
    value of -1 as indicating that the device should be unconfigured.  The
    request actually sent to the device will still contain 0 as the value.
    But even if the device does have a configuration 0, dev-&gt;actconfig
    will be set to NULL and dev-&gt;state will be set to USB_STATE_ADDRESS.
    
    Without some sort of special-case handling like this, there is no way
    to unconfigure these non-compliant devices.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 2087766f9e88..274f14f1633e 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -857,11 +857,11 @@ static int proc_setintf(struct dev_state *ps, void __user *arg)
 
 static int proc_setconfig(struct dev_state *ps, void __user *arg)
 {
-	unsigned int u;
+	int u;
 	int status = 0;
  	struct usb_host_config *actconfig;
 
-	if (get_user(u, (unsigned int __user *)arg))
+	if (get_user(u, (int __user *)arg))
 		return -EFAULT;
 
  	actconfig = ps-&gt;dev-&gt;actconfig;
diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index b531a4fd30c2..9bbcb20e2d94 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -184,7 +184,7 @@ static void generic_disconnect(struct usb_device *udev)
 	/* if this is only an unbind, not a physical disconnect, then
 	 * unconfigure the device */
 	if (udev-&gt;actconfig)
-		usb_set_configuration(udev, 0);
+		usb_set_configuration(udev, -1);
 
 	usb_remove_sysfs_dev_files(udev);
 }
diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 8aca3574c2b5..74edaea5665d 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1316,6 +1316,14 @@ static void release_interface(struct device *dev)
  * use this kind of configurability; many devices only have one
  * configuration.
  *
+ * @configuration is the value of the configuration to be installed.
+ * According to the USB spec (e.g. section 9.1.1.5), configuration values
+ * must be non-zero; a value of zero indicates that the device in
+ * unconfigured.  However some devices erroneously use 0 as one of their
+ * configuration values.  To help manage such devices, this routine will
+ * accept @configuration = -1 as indicating the device should be put in
+ * an unconfigured state.
+ *
  * USB device configurations may affect Linux interoperability,
  * power consumption and the functionality available.  For example,
  * the default configuration is limited to using 100mA of bus power,
@@ -1347,10 +1355,15 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 	struct usb_interface **new_interfaces = NULL;
 	int n, nintf;
 
-	for (i = 0; i &lt; dev-&gt;descriptor.bNumConfigurations; i++) {
-		if (dev-&gt;config[i].desc.bConfigurationValue == configuration) {
-			cp = &amp;dev-&gt;config[i];
-			break;
+	if (configuration == -1)
+		configuration = 0;
+	else {
+		for (i = 0; i &lt; dev-&gt;descriptor.bNumConfigurations; i++) {
+			if (dev-&gt;config[i].desc.bConfigurationValue ==
+					configuration) {
+				cp = &amp;dev-&gt;config[i];
+				break;
+			}
 		}
 	}
 	if ((!cp &amp;&amp; configuration != 0))
@@ -1359,6 +1372,7 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 	/* The USB spec says configuration 0 means unconfigured.
 	 * But if a device includes a configuration numbered 0,
 	 * we will accept it as a correctly configured state.
+	 * Use -1 if you really want to unconfigure the device.
 	 */
 	if (cp &amp;&amp; configuration == 0)
 		dev_warn(&amp;dev-&gt;dev, "config 0 descriptor??\n");
diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c
index 4eaa0ee8e72f..0edfbafd702c 100644
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -63,7 +63,7 @@ set_bConfigurationValue(struct device *dev, struct device_attribute *attr,
 	struct usb_device	*udev = to_usb_device(dev);
 	int			config, value;
 
-	if (sscanf(buf, "%u", &amp;config) != 1 || config &gt; 255)
+	if (sscanf(buf, "%d", &amp;config) != 1 || config &lt; -1 || config &gt; 255)
 		return -EINVAL;
 	usb_lock_device(udev);
 	value = usb_set_configuration(udev, config);</pre><hr><pre>commit db90e7a15cb4a160610b4e58576f25539ca216e7
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Feb 5 09:56:15 2007 -0500

    USB: fix concurrent buffer access in the hub driver
    
    This patch (as849) fixes a bug in the USB hub driver.  A single
    pre-allocated buffer is used for all port status reads, but nothing
    guarantees exclusive use of the buffer.  A mutex is added to provide
    this guarantee.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 7d6006573543..50c0db15304a 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -44,6 +44,7 @@ struct usb_hub {
 		struct usb_hub_status	hub;
 		struct usb_port_status	port;
 	}			*status;	/* buffer for status reports */
+	struct mutex		status_mutex;	/* for the status buffer */
 
 	int			error;		/* last reported error */
 	int			nerrors;	/* track consecutive errors */
@@ -535,6 +536,7 @@ static int hub_hub_status(struct usb_hub *hub,
 {
 	int ret;
 
+	mutex_lock(&amp;hub-&gt;status_mutex);
 	ret = get_hub_status(hub-&gt;hdev, &amp;hub-&gt;status-&gt;hub);
 	if (ret &lt; 0)
 		dev_err (hub-&gt;intfdev,
@@ -544,6 +546,7 @@ static int hub_hub_status(struct usb_hub *hub,
 		*change = le16_to_cpu(hub-&gt;status-&gt;hub.wHubChange); 
 		ret = 0;
 	}
+	mutex_unlock(&amp;hub-&gt;status_mutex);
 	return ret;
 }
 
@@ -617,6 +620,7 @@ static int hub_configure(struct usb_hub *hub,
 		ret = -ENOMEM;
 		goto fail;
 	}
+	mutex_init(&amp;hub-&gt;status_mutex);
 
 	hub-&gt;descriptor = kmalloc(sizeof(*hub-&gt;descriptor), GFP_KERNEL);
 	if (!hub-&gt;descriptor) {
@@ -1396,6 +1400,7 @@ static int hub_port_status(struct usb_hub *hub, int port1,
 {
 	int ret;
 
+	mutex_lock(&amp;hub-&gt;status_mutex);
 	ret = get_port_status(hub-&gt;hdev, port1, &amp;hub-&gt;status-&gt;port);
 	if (ret &lt; 4) {
 		dev_err (hub-&gt;intfdev,
@@ -1407,6 +1412,7 @@ static int hub_port_status(struct usb_hub *hub, int port1,
 		*change = le16_to_cpu(hub-&gt;status-&gt;port.wPortChange); 
 		ret = 0;
 	}
+	mutex_unlock(&amp;hub-&gt;status_mutex);
 	return ret;
 }
 </pre><hr><pre>commit 8c774fe8a0284aff9e4c7ea43f5154fd46da325c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Feb 1 16:09:59 2007 -0500

    EHCI: add debugging message to ehci_bus_suspend
    
    This patch (as848) adds a useful little debugging message to let us
    know when ehci-hcd's bus_suspend method runs.  The other HCDs have
    similar messages; now ehci-hcd doesn't need to feel left out.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 0d83c6df1a3b..9af529d22b3e 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -36,6 +36,8 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 	int			port;
 	int			mask;
 
+	ehci_dbg(ehci, "suspend root hub\n");
+
 	if (time_before (jiffies, ehci-&gt;next_statechange))
 		msleep(5);
 </pre><hr><pre>commit 12f1ff8351e235661beb0314d9ae9417a4871688
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Feb 1 16:08:41 2007 -0500

    usbcore: small changes to hub driver's suspend method
    
    This patch (as847) makes some small changes to the hub driver's
    suspend method:
    
            For root hubs, the status URB should be unlinked and other
            activity stopped _before_ the bus_suspend method is called.
    
            The test for hdev-&gt;bus being NULL has been removed, since
            it can never succeed.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 590ec82d0515..7d6006573543 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1904,6 +1904,7 @@ static int hub_suspend(struct usb_interface *intf, pm_message_t msg)
 	struct usb_hub		*hub = usb_get_intfdata (intf);
 	struct usb_device	*hdev = hub-&gt;hdev;
 	unsigned		port1;
+	int			status = 0;
 
 	/* fail if children aren't already suspended */
 	for (port1 = 1; port1 &lt;= hdev-&gt;maxchild; port1++) {
@@ -1927,24 +1928,18 @@ static int hub_suspend(struct usb_interface *intf, pm_message_t msg)
 
 	dev_dbg(&amp;intf-&gt;dev, "%s\n", __FUNCTION__);
 
+	/* stop khubd and related activity */
+	hub_quiesce(hub);
+
 	/* "global suspend" of the downstream HC-to-USB interface */
 	if (!hdev-&gt;parent) {
-		struct usb_bus	*bus = hdev-&gt;bus;
-		if (bus) {
-			int	status = hcd_bus_suspend (bus);
-
-			if (status != 0) {
-				dev_dbg(&amp;hdev-&gt;dev, "'global' suspend %d\n",
-					status);
-				return status;
-			}
-		} else
-			return -EOPNOTSUPP;
+		status = hcd_bus_suspend(hdev-&gt;bus);
+		if (status != 0) {
+			dev_dbg(&amp;hdev-&gt;dev, "'global' suspend %d\n", status);
+			hub_activate(hub);
+		}
 	}
-
-	/* stop khubd and related activity */
-	hub_quiesce(hub);
-	return 0;
+	return status;
 }
 
 static int hub_resume(struct usb_interface *intf)</pre>
    <div class="pagination">
        <a href='2_111.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><span>[112]</span><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_113.html'>Next&gt;&gt;</a>
    <div>
</body>
