<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_9.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><span>[10]</span><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_11.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit a6cd27e9b594ccf4bf525969c1077f2dbe515476
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Apr 22 16:20:19 2020 -0400

    USB: core: Replace an empty statement with a debug message
    
    This patch adds a dev_dbg() message to usb_create_sysfs_intf_files().
    The message is not expected ever to appear; it's real purpose is to
    satisfy the __must_check attribute on device_create_file() without
    triggering a compiler warning about an empty statement.
    
    In fact we don't really care if the sysfs attribute file doesn't get
    created.  The interface string descriptor is purely informational and
    hardly ever present.
    
    Suggested-by: NeilBrown &lt;neilb@suse.de&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    
    Link: https://lore.kernel.org/r/Pine.LNX.4.44L0.2004221618500.11262-100000@iolanthe.rowland.org
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c
index 9f4320b9d7fc..a2ca38e25e0c 100644
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -1262,8 +1262,10 @@ void usb_create_sysfs_intf_files(struct usb_interface *intf)
 
 	if (!alt-&gt;string &amp;&amp; !(udev-&gt;quirks &amp; USB_QUIRK_CONFIG_INTF_STRINGS))
 		alt-&gt;string = usb_cache_string(udev, alt-&gt;desc.iInterface);
-	if (alt-&gt;string &amp;&amp; device_create_file(&amp;intf-&gt;dev, &amp;dev_attr_interface))
-		;	/* We don't actually care if the function fails. */
+	if (alt-&gt;string &amp;&amp; device_create_file(&amp;intf-&gt;dev, &amp;dev_attr_interface)) {
+		/* This is not a serious error */
+		dev_dbg(&amp;intf-&gt;dev, "interface string descriptor file not created\n");
+	}
 	intf-&gt;sysfs_files_created = 1;
 }
 </pre><hr><pre>commit 94f9c8c3c404ee1f7aaff81ad4f24aec4e34a78b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Apr 22 16:14:57 2020 -0400

    usb-storage: Add unusual_devs entry for JMicron JMS566
    
    Cyril Roelandt reports that his JMicron JMS566 USB-SATA bridge fails
    to handle WRITE commands with the FUA bit set, even though it claims
    to support FUA.  (Oddly enough, a later version of the same bridge,
    version 2.03 as opposed to 1.14, doesn't claim to support FUA.  Also
    oddly, the bridge _does_ support FUA when using the UAS transport
    instead of the Bulk-Only transport -- but this device was blacklisted
    for uas in commit bc3bdb12bbb3 ("usb-storage: Disable UAS on JMicron
    SATA enclosure") for apparently unrelated reasons.)
    
    This patch adds a usb-storage unusual_devs entry with the BROKEN_FUA
    flag.  This allows the bridge to work properly with usb-storage.
    
    Reported-and-tested-by: Cyril Roelandt &lt;tipecaml@gmail.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    
    Link: https://lore.kernel.org/r/Pine.LNX.4.44L0.2004221613110.11262-100000@iolanthe.rowland.org
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index 1880f3e13f57..f6c3681fa2e9 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -2323,6 +2323,13 @@ UNUSUAL_DEV(  0x3340, 0xffff, 0x0000, 0x0000,
 		USB_SC_DEVICE,USB_PR_DEVICE,NULL,
 		US_FL_MAX_SECTORS_64 ),
 
+/* Reported by Cyril Roelandt &lt;tipecaml@gmail.com&gt; */
+UNUSUAL_DEV(  0x357d, 0x7788, 0x0114, 0x0114,
+		"JMicron",
+		"USB to ATA/ATAPI Bridge",
+		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
+		US_FL_BROKEN_FUA ),
+
 /* Reported by Andrey Rahmatullin &lt;wrar@altlinux.org&gt; */
 UNUSUAL_DEV(  0x4102, 0x1020, 0x0100,  0x0100,
 		"iRiver",</pre><hr><pre>commit 3155f4f40811c5d7e3c686215051acf504e05565
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Apr 22 16:13:08 2020 -0400

    USB: hub: Revert commit bd0e6c9614b9 ("usb: hub: try old enumeration scheme first for high speed devices")
    
    Commit bd0e6c9614b9 ("usb: hub: try old enumeration scheme first for
    high speed devices") changed the way the hub driver enumerates
    high-speed devices.  Instead of using the "new" enumeration scheme
    first and switching to the "old" scheme if that doesn't work, we start
    with the "old" scheme.  In theory this is better because the "old"
    scheme is slightly faster -- it involves resetting the device only
    once instead of twice.
    
    However, for a long time Windows used only the "new" scheme.  Zeng Tao
    said that Windows 8 and later use the "old" scheme for high-speed
    devices, but apparently there are some devices that don't like it.
    William Bader reports that the Ricoh webcam built into his Sony Vaio
    laptop not only doesn't enumerate under the "old" scheme, it gets hung
    up so badly that it won't then enumerate under the "new" scheme!  Only
    a cold reset will fix it.
    
    Therefore we will revert the commit and go back to trying the "new"
    scheme first for high-speed devices.
    
    Reported-and-tested-by: William Bader &lt;williambader@hotmail.com&gt;
    Ref: https://bugzilla.kernel.org/show_bug.cgi?id=207219
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Fixes: bd0e6c9614b9 ("usb: hub: try old enumeration scheme first for high speed devices")
    CC: Zeng Tao &lt;prime.zeng@hisilicon.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    
    Link: https://lore.kernel.org/r/Pine.LNX.4.44L0.2004221611230.11262-100000@iolanthe.rowland.org
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/Documentation/admin-guide/kernel-parameters.txt b/Documentation/admin-guide/kernel-parameters.txt
index f2a93c8679e8..7bc83f3d9bdf 100644
--- a/Documentation/admin-guide/kernel-parameters.txt
+++ b/Documentation/admin-guide/kernel-parameters.txt
@@ -5187,8 +5187,7 @@
 
 	usbcore.old_scheme_first=
 			[USB] Start with the old device initialization
-			scheme,  applies only to low and full-speed devices
-			 (default 0 = off).
+			scheme (default 0 = off).
 
 	usbcore.usbfs_memory_mb=
 			[USB] Memory limit (in MB) for buffers allocated by
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 83549f009ced..2b6565c06c23 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2728,13 +2728,11 @@ static bool use_new_scheme(struct usb_device *udev, int retry,
 {
 	int old_scheme_first_port =
 		port_dev-&gt;quirks &amp; USB_PORT_QUIRK_OLD_SCHEME;
-	int quick_enumeration = (udev-&gt;speed == USB_SPEED_HIGH);
 
 	if (udev-&gt;speed &gt;= USB_SPEED_SUPER)
 		return false;
 
-	return USE_NEW_SCHEME(retry, old_scheme_first_port || old_scheme_first
-			      || quick_enumeration);
+	return USE_NEW_SCHEME(retry, old_scheme_first_port || old_scheme_first);
 }
 
 /* Is a USB 3.0 port in the Inactive or Compliance Mode state?</pre><hr><pre>commit 9f952e26295d977dbfc6fedeaf8c4f112c818d37
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Apr 22 16:09:51 2020 -0400

    USB: hub: Fix handling of connect changes during sleep
    
    Commit 8099f58f1ecd ("USB: hub: Don't record a connect-change event
    during reset-resume") wasn't very well conceived.  The problem it
    tried to fix was that if a connect-change event occurred while the
    system was asleep (such as a device disconnecting itself from the bus
    when it is suspended and then reconnecting when it resumes)
    requiring a reset-resume during the system wakeup transition, the hub
    port's change_bit entry would remain set afterward.  This would cause
    the hub driver to believe another connect-change event had occurred
    after the reset-resume, which was wrong and would lead the driver to
    send unnecessary requests to the device (which could interfere with a
    firmware update).
    
    The commit tried to fix this by not setting the change_bit during the
    wakeup.  But this was the wrong thing to do; it means that when a
    device is unplugged while the system is asleep, the hub driver doesn't
    realize anything has happened: The change_bit flag which would tell it
    to handle the disconnect event is clear.
    
    The commit needs to be reverted and the problem fixed in a different
    way.  Fortunately an alternative solution was noted in the commit's
    Changelog: We can continue to set the change_bit entry in
    hub_activate() but then clear it when a reset-resume occurs.  That way
    the the hub driver will see the change_bit when a device is
    disconnected but won't see it when the device is still present.
    
    That's what this patch does.
    
    Reported-and-tested-by: Peter Chen &lt;peter.chen@nxp.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Fixes: 8099f58f1ecd ("USB: hub: Don't record a connect-change event during reset-resume")
    Tested-by: Paul Zimmerman &lt;pauldzim@gmail.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    
    Link: https://lore.kernel.org/r/Pine.LNX.4.44L0.2004221602480.11262-100000@iolanthe.rowland.org
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 54cd8ef795ec..83549f009ced 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1223,6 +1223,11 @@ static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)
 #ifdef CONFIG_PM
 			udev-&gt;reset_resume = 1;
 #endif
+			/* Don't set the change_bits when the device
+			 * was powered off.
+			 */
+			if (test_bit(port1, hub-&gt;power_bits))
+				set_bit(port1, hub-&gt;change_bits);
 
 		} else {
 			/* The power session is gone; tell hub_wq */
@@ -3088,6 +3093,15 @@ static int check_port_resume_type(struct usb_device *udev,
 		if (portchange &amp; USB_PORT_STAT_C_ENABLE)
 			usb_clear_port_feature(hub-&gt;hdev, port1,
 					USB_PORT_FEAT_C_ENABLE);
+
+		/*
+		 * Whatever made this reset-resume necessary may have
+		 * turned on the port1 bit in hub-&gt;change_bits.  But after
+		 * a successful reset-resume we want the bit to be clear;
+		 * if it was on it would indicate that something happened
+		 * following the reset-resume.
+		 */
+		clear_bit(port1, hub-&gt;change_bits);
 	}
 
 	return status;</pre><hr><pre>commit 056ad39ee9253873522f6469c3364964a322912b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Mar 28 16:18:11 2020 -0400

    USB: core: Fix free-while-in-use bug in the USB S-Glibrary
    
    FuzzUSB (a variant of syzkaller) found a free-while-still-in-use bug
    in the USB scatter-gather library:
    
    BUG: KASAN: use-after-free in atomic_read
    include/asm-generic/atomic-instrumented.h:26 [inline]
    BUG: KASAN: use-after-free in usb_hcd_unlink_urb+0x5f/0x170
    drivers/usb/core/hcd.c:1607
    Read of size 4 at addr ffff888065379610 by task kworker/u4:1/27
    
    CPU: 1 PID: 27 Comm: kworker/u4:1 Not tainted 5.5.11 #2
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS
    1.10.2-1ubuntu1 04/01/2014
    Workqueue: scsi_tmf_2 scmd_eh_abort_handler
    Call Trace:
     __dump_stack lib/dump_stack.c:77 [inline]
     dump_stack+0xce/0x128 lib/dump_stack.c:118
     print_address_description.constprop.4+0x21/0x3c0 mm/kasan/report.c:374
     __kasan_report+0x153/0x1cb mm/kasan/report.c:506
     kasan_report+0x12/0x20 mm/kasan/common.c:639
     check_memory_region_inline mm/kasan/generic.c:185 [inline]
     check_memory_region+0x152/0x1b0 mm/kasan/generic.c:192
     __kasan_check_read+0x11/0x20 mm/kasan/common.c:95
     atomic_read include/asm-generic/atomic-instrumented.h:26 [inline]
     usb_hcd_unlink_urb+0x5f/0x170 drivers/usb/core/hcd.c:1607
     usb_unlink_urb+0x72/0xb0 drivers/usb/core/urb.c:657
     usb_sg_cancel+0x14e/0x290 drivers/usb/core/message.c:602
     usb_stor_stop_transport+0x5e/0xa0 drivers/usb/storage/transport.c:937
    
    This bug occurs when cancellation of the S-G transfer races with
    transfer completion.  When that happens, usb_sg_cancel() may continue
    to access the transfer's URBs after usb_sg_wait() has freed them.
    
    The bug is caused by the fact that usb_sg_cancel() does not take any
    sort of reference to the transfer, and so there is nothing to prevent
    the URBs from being deallocated while the routine is trying to use
    them.  The fix is to take such a reference by incrementing the
    transfer's io-&gt;count field while the cancellation is in progres and
    decrementing it afterward.  The transfer's URBs are not deallocated
    until io-&gt;complete is triggered, which happens when io-&gt;count reaches
    zero.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Kyungtae Kim &lt;kt0755@gmail.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    
    Link: https://lore.kernel.org/r/Pine.LNX.4.44L0.2003281615140.14837-100000@netrider.rowland.org
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index d5f834f16993..a48678a0c83a 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -589,12 +589,13 @@ void usb_sg_cancel(struct usb_sg_request *io)
 	int i, retval;
 
 	spin_lock_irqsave(&amp;io-&gt;lock, flags);
-	if (io-&gt;status) {
+	if (io-&gt;status || io-&gt;count == 0) {
 		spin_unlock_irqrestore(&amp;io-&gt;lock, flags);
 		return;
 	}
 	/* shut everything down */
 	io-&gt;status = -ECONNRESET;
+	io-&gt;count++;		/* Keep the request alive until we're done */
 	spin_unlock_irqrestore(&amp;io-&gt;lock, flags);
 
 	for (i = io-&gt;entries - 1; i &gt;= 0; --i) {
@@ -608,6 +609,12 @@ void usb_sg_cancel(struct usb_sg_request *io)
 			dev_warn(&amp;io-&gt;dev-&gt;dev, "%s, unlink --&gt; %d\n",
 				 __func__, retval);
 	}
+
+	spin_lock_irqsave(&amp;io-&gt;lock, flags);
+	io-&gt;count--;
+	if (!io-&gt;count)
+		complete(&amp;io-&gt;complete);
+	spin_unlock_irqrestore(&amp;io-&gt;lock, flags);
 }
 EXPORT_SYMBOL_GPL(usb_sg_cancel);
 </pre><hr><pre>commit 8099f58f1ecddf4f374f4828a3dff8397c7cbd74
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jan 31 10:39:26 2020 -0500

    USB: hub: Don't record a connect-change event during reset-resume
    
    Paul Zimmerman reports that his USB Bluetooth adapter sometimes
    crashes following system resume, when it receives a
    Get-Device-Descriptor request while it is busy doing something else.
    
    Such a request was added by commit a4f55d8b8c14 ("usb: hub: Check
    device descriptor before resusciation").  It gets sent when the hub
    driver's work thread checks whether a connect-change event on an
    enabled port really indicates a new device has been connected, as
    opposed to an old device momentarily disconnecting and then
    reconnecting (which can happen with xHCI host controllers, since they
    automatically enable connected ports).
    
    The same kind of thing occurs when a port's power session is lost
    during system suspend.  When the system wakes up it sees a
    connect-change event on the port, and if the child device's
    persist_enabled flag was set then hub_activate() sets the device's
    reset_resume flag as well as the port's bit in hub-&gt;change_bits.  The
    reset-resume code then takes responsibility for checking that the same
    device is still attached to the port, and it does this as part of the
    device's resume pathway.  By the time the hub driver's work thread
    starts up again, the device has already been fully reinitialized and
    is busy doing its own thing.  There's no need for the work thread to
    do the same check a second time, and in fact this unnecessary check is
    what caused the problem that Paul observed.
    
    Note that performing the unnecessary check is not actually a bug.
    Devices are supposed to be able to send descriptors back to the host
    even when they are busy doing something else.  The underlying cause of
    Paul's problem lies in his Bluetooth adapter.  Nevertheless, we
    shouldn't perform the same check twice in a row -- and as a nice side
    benefit, removing the extra check allows the Bluetooth adapter to work
    more reliably.
    
    The work thread performs its check when it sees that the port's bit is
    set in hub-&gt;change_bits.  In this situation that bit is interpreted as
    though a connect-change event had occurred on the port _after_ the
    reset-resume, which is not what actually happened.
    
    One possible fix would be to make the reset-resume code clear the
    port's bit in hub-&gt;change_bits.  But it seems simpler to just avoid
    setting the bit during hub_activate() in the first place.  That's what
    this patch does.
    
    (Proving that the patch is correct when CONFIG_PM is disabled requires
    a little thought.  In that setting hub_activate() will be called only
    for initialization and resets, since there won't be any resumes or
    reset-resumes.  During initialization and hub resets the hub doesn't
    have any child devices, and so this code path never gets executed.)
    
    Reported-and-tested-by: Paul Zimmerman &lt;pauldzim@gmail.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://marc.info/?t=157949360700001&amp;r=1&amp;w=2
    CC: David Heinzelmann &lt;heinzelmann.david@gmail.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Link: https://lore.kernel.org/r/Pine.LNX.4.44L0.2001311037460.1577-100000@iolanthe.rowland.org
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index de94fa4a4ca7..1d212f82c69b 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1219,11 +1219,6 @@ static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)
 #ifdef CONFIG_PM
 			udev-&gt;reset_resume = 1;
 #endif
-			/* Don't set the change_bits when the device
-			 * was powered off.
-			 */
-			if (test_bit(port1, hub-&gt;power_bits))
-				set_bit(port1, hub-&gt;change_bits);
 
 		} else {
 			/* The power session is gone; tell hub_wq */</pre><hr><pre>commit fdd64df7b9d1e20dbe28c9c205682b66ad821e6c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jan 17 10:47:13 2020 -0500

    USB: usbfs: Always unlink URBs in reverse order
    
    When the kernel unlinks a bunch of URBs for a single endpoint, it
    should always unlink them in reverse order.  This eliminates any
    possibility that some URB x will be unlinked before it can execute but
    the following URB x+1 will execute before it can be unlinked.  Such an
    event would be bad, for obvious reasons.
    
    Chris Dickens pointed out that usbfs doesn't behave this way when it
    is unbound from an interface.  All pending URBs are cancelled, but in
    the order of submission.  This patch changes the behavior to make the
    unlinks occur in reverse order.  It similarly changes the behavior
    when usbfs cancels the continuation URBs for a BULK endpoint.
    
    Suggested-by: Chris Dickens &lt;christopher.a.dickens@gmail.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    
    Link: https://lore.kernel.org/r/Pine.LNX.4.44L0.2001171045380.1571-100000@iolanthe.rowland.org
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 12bb5722b420..6833c918abce 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -574,7 +574,7 @@ __acquires(ps-&gt;lock)
 
 	/* Now carefully unlink all the marked pending URBs */
  rescan:
-	list_for_each_entry(as, &amp;ps-&gt;async_pending, asynclist) {
+	list_for_each_entry_reverse(as, &amp;ps-&gt;async_pending, asynclist) {
 		if (as-&gt;bulk_status == AS_UNLINK) {
 			as-&gt;bulk_status = 0;		/* Only once */
 			urb = as-&gt;urb;
@@ -636,7 +636,7 @@ static void destroy_async(struct usb_dev_state *ps, struct list_head *list)
 
 	spin_lock_irqsave(&amp;ps-&gt;lock, flags);
 	while (!list_empty(list)) {
-		as = list_entry(list-&gt;next, struct async, asynclist);
+		as = list_last_entry(list, struct async, asynclist);
 		list_del_init(&amp;as-&gt;asynclist);
 		urb = as-&gt;urb;
 		usb_get_urb(urb);</pre><hr><pre>commit 2548288b4fb059b2da9ceada172ef763077e8a59
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jan 6 10:43:42 2020 -0500

    USB: Fix: Don't skip endpoint descriptors with maxpacket=0
    
    It turns out that even though endpoints with a maxpacket length of 0
    aren't useful for data transfer, the descriptors do serve other
    purposes.  In particular, skipping them will also skip over other
    class-specific descriptors for classes such as UVC.  This unexpected
    side effect has caused some UVC cameras to stop working.
    
    In addition, the USB spec requires that when isochronous endpoint
    descriptors are present in an interface's altsetting 0 (which is true
    on some devices), the maxpacket size _must_ be set to 0.  Warning
    about such things seems like a bad idea.
    
    This patch updates an earlier commit which would log a warning and
    skip these endpoint descriptors.  Now we only log a warning, and we
    don't even do that for isochronous endpoints in altsetting 0.
    
    We don't need to worry about preventing endpoints with maxpacket = 0
    from ever being used for data transfers; usb_submit_urb() already
    checks for this.
    
    Reported-and-tested-by: Roger Whittaker &lt;Roger.Whittaker@suse.com&gt;
    Fixes: d482c7bb0541 ("USB: Skip endpoints with 0 maxpacket length")
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Laurent Pinchart &lt;laurent.pinchart@ideasonboard.com&gt;
    Link: https://marc.info/?l=linux-usb&amp;m=157790377329882&amp;w=2
    Link: https://lore.kernel.org/r/Pine.LNX.4.44L0.2001061040270.1514-100000@iolanthe.rowland.org
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c
index 21291950cc97..26bc05e48d8a 100644
--- a/drivers/usb/core/config.c
+++ b/drivers/usb/core/config.c
@@ -392,12 +392,16 @@ static int usb_parse_endpoint(struct device *ddev, int cfgno,
 			endpoint-&gt;desc.wMaxPacketSize = cpu_to_le16(8);
 	}
 
-	/* Validate the wMaxPacketSize field */
+	/*
+	 * Validate the wMaxPacketSize field.
+	 * Some devices have isochronous endpoints in altsetting 0;
+	 * the USB-2 spec requires such endpoints to have wMaxPacketSize = 0
+	 * (see the end of section 5.6.3), so don't warn about them.
+	 */
 	maxp = usb_endpoint_maxp(&amp;endpoint-&gt;desc);
-	if (maxp == 0) {
-		dev_warn(ddev, "config %d interface %d altsetting %d endpoint 0x%X has wMaxPacketSize 0, skipping\n",
+	if (maxp == 0 &amp;&amp; !(usb_endpoint_xfer_isoc(d) &amp;&amp; asnum == 0)) {
+		dev_warn(ddev, "config %d interface %d altsetting %d endpoint 0x%X has invalid wMaxPacketSize 0\n",
 		    cfgno, inum, asnum, d-&gt;bEndpointAddress);
-		goto skip_to_next_endpoint_or_interface_descriptor;
 	}
 
 	/* Find the highest legal maxpacket size for this endpoint */</pre><hr><pre>commit 8ec321e96e056de84022c032ffea253431a83c3c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Dec 10 16:26:11 2019 -0500

    HID: Fix slab-out-of-bounds read in hid_field_extract
    
    The syzbot fuzzer found a slab-out-of-bounds bug in the HID report
    handler.  The bug was caused by a report descriptor which included a
    field with size 12 bits and count 4899, for a total size of 7349
    bytes.
    
    The usbhid driver uses at most a single-page 4-KB buffer for reports.
    In the test there wasn't any problem about overflowing the buffer,
    since only one byte was received from the device.  Rather, the bug
    occurred when the HID core tried to extract the data from the report
    fields, which caused it to try reading data beyond the end of the
    allocated buffer.
    
    This patch fixes the problem by rejecting any report whose total
    length exceeds the HID_MAX_BUFFER_SIZE limit (minus one byte to allow
    for a possible report index).  In theory a device could have a report
    longer than that, but if there was such a thing we wouldn't handle it
    correctly anyway.
    
    Reported-and-tested-by: syzbot+09ef48aa58261464b621@syzkaller.appspotmail.com
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/hid-core.c b/drivers/hid/hid-core.c
index e0b241bd3070..851fe54ea59e 100644
--- a/drivers/hid/hid-core.c
+++ b/drivers/hid/hid-core.c
@@ -288,6 +288,12 @@ static int hid_add_field(struct hid_parser *parser, unsigned report_type, unsign
 	offset = report-&gt;size;
 	report-&gt;size += parser-&gt;global.report_size * parser-&gt;global.report_count;
 
+	/* Total size check: Allow for possible report index byte */
+	if (report-&gt;size &gt; (HID_MAX_BUFFER_SIZE - 1) &lt;&lt; 3) {
+		hid_err(parser-&gt;device, "report is too long\n");
+		return -1;
+	}
+
 	if (!parser-&gt;local.usage_index) /* Ignore padding fields */
 		return 0;
 </pre><hr><pre>commit 54f83b8c8ea9b22082a496deadf90447a326954e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Oct 28 10:54:26 2019 -0400

    USB: gadget: Reject endpoints with 0 maxpacket value
    
    Endpoints with a maxpacket length of 0 are probably useless.  They
    can't transfer any data, and it's not at all unlikely that a UDC will
    crash or hang when trying to handle a non-zero-length usb_request for
    such an endpoint.  Indeed, dummy-hcd gets a divide error when trying
    to calculate the remainder of a transfer length by the maxpacket
    value, as discovered by the syzbot fuzzer.
    
    Currently the gadget core does not check for endpoints having a
    maxpacket value of 0.  This patch adds a check to usb_ep_enable(),
    preventing such endpoints from being used.
    
    As far as I know, none of the gadget drivers in the kernel tries to
    create an endpoint with maxpacket = 0, but until now there has been
    nothing to prevent userspace programs under gadgetfs or configfs from
    doing it.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: syzbot+8ab8bf161038a8768553@syzkaller.appspotmail.com
    CC: &lt;stable@vger.kernel.org&gt;
    Acked-by: Felipe Balbi &lt;balbi@kernel.org&gt;
    
    Link: https://lore.kernel.org/r/Pine.LNX.4.44L0.1910281052370.1485-100000@iolanthe.rowland.org
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/gadget/udc/core.c b/drivers/usb/gadget/udc/core.c
index 92af8dc98c3d..51fa614b4079 100644
--- a/drivers/usb/gadget/udc/core.c
+++ b/drivers/usb/gadget/udc/core.c
@@ -98,6 +98,17 @@ int usb_ep_enable(struct usb_ep *ep)
 	if (ep-&gt;enabled)
 		goto out;
 
+	/* UDC drivers can't handle endpoints with maxpacket size 0 */
+	if (usb_endpoint_maxp(ep-&gt;desc) == 0) {
+		/*
+		 * We should log an error message here, but we can't call
+		 * dev_err() because there's no way to find the gadget
+		 * given only ep.
+		 */
+		ret = -EINVAL;
+		goto out;
+	}
+
 	ret = ep-&gt;ops-&gt;enable(ep, ep-&gt;desc);
 	if (ret)
 		goto out;</pre>
    <div class="pagination">
        <a href='2_9.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><span>[10]</span><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_11.html'>Next&gt;&gt;</a>
    <div>
</body>
