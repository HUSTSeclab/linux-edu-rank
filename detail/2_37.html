<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_36.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><span>[37]</span><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_38.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 0aa2832dd0d9d8609fd8f15139bc7572541a1215
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Mar 27 16:14:19 2013 -0400

    USB: use "global suspend" for system sleep on USB-2 buses
    
    This patch (as1674) speeds up system sleep transitions by not
    suspending each individual device on a USB-1.1 or USB-2 bus.  The
    devices will automatically go into suspend when their root hubs are
    suspended (i.e., stop sending out Start-Of-Frame packets) -- this is
    what the USB spec calls "global suspend".
    
    Since this is what we do already when CONFIG_USB_SUSPEND isn't
    enabled, it shouldn't cause any problems.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Peter Chen &lt;peter.chen@freescale.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 669da9ef714d..443d5cc9330b 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2886,9 +2886,11 @@ static int usb_disable_function_remotewakeup(struct usb_device *udev)
  * Linux (2.6) currently has NO mechanisms to initiate that:  no khubd
  * timer, no SRP, no requests through sysfs.
  *
- * If CONFIG_USB_SUSPEND isn't enabled, devices only really suspend when
- * the root hub for their bus goes into global suspend ... so we don't
- * (falsely) update the device power state to say it suspended.
+ * If CONFIG_USB_SUSPEND isn't enabled, non-SuperSpeed devices really get
+ * suspended only when their bus goes into global suspend (i.e., the root
+ * hub is suspended).  Nevertheless, we change @udev-&gt;state to
+ * USB_STATE_SUSPENDED as this is the device's "logical" state.  The actual
+ * upstream port setting is stored in @udev-&gt;port_is_suspended.
  *
  * Returns 0 on success, else negative errno.
  */
@@ -2899,6 +2901,7 @@ int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
 	enum pm_qos_flags_status pm_qos_stat;
 	int		port1 = udev-&gt;portnum;
 	int		status;
+	bool		really_suspend = true;
 
 	/* enable remote wakeup when appropriate; this lets the device
 	 * wake up the upstream hub (including maybe the root hub).
@@ -2955,9 +2958,19 @@ int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
 	/* see 7.1.7.6 */
 	if (hub_is_superspeed(hub-&gt;hdev))
 		status = hub_set_port_link_state(hub, port1, USB_SS_PORT_LS_U3);
-	else
+	else if (PMSG_IS_AUTO(msg))
 		status = set_port_feature(hub-&gt;hdev, port1,
 						USB_PORT_FEAT_SUSPEND);
+	/*
+	 * For system suspend, we do not need to enable the suspend feature
+	 * on individual USB-2 ports.  The devices will automatically go
+	 * into suspend a few ms after the root hub stops sending packets.
+	 * The USB 2.0 spec calls this "global suspend".
+	 */
+	else {
+		really_suspend = false;
+		status = 0;
+	}
 	if (status) {
 		dev_dbg(hub-&gt;intfdev, "can't suspend port %d, status %d\n",
 				port1, status);
@@ -2993,8 +3006,10 @@ int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
 				(PMSG_IS_AUTO(msg) ? "auto-" : ""),
 				udev-&gt;do_remote_wakeup);
 		usb_set_device_state(udev, USB_STATE_SUSPENDED);
-		udev-&gt;port_is_suspended = 1;
-		msleep(10);
+		if (really_suspend) {
+			udev-&gt;port_is_suspended = 1;
+			msleep(10);
+		}
 	}
 
 	/*</pre><hr><pre>commit e9e88fb7bca9f527ccdf4166a240a9023ba6ee73
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Mar 27 16:14:01 2013 -0400

    USB: avoid error messages when a device is disconnected
    
    This patch (as1673) reduces the amount of log spew from the hub driver
    by removing a bunch of error messages in the case where the device in
    question is already known to have been disconnected.  Since the
    disconnect event itself appears in the log, there's no need for other
    error messages.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Jenya Y &lt;jy.gerstmaier@gmail.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index 271e761f563e..acbfeb0a0119 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -169,7 +169,7 @@ static int generic_probe(struct usb_device *udev)
 		c = usb_choose_configuration(udev);
 		if (c &gt;= 0) {
 			err = usb_set_configuration(udev, c);
-			if (err) {
+			if (err &amp;&amp; err != -ENODEV) {
 				dev_err(&amp;udev-&gt;dev, "can't set config #%d, error %d\n",
 					c, err);
 				/* This need not be fatal.  The user can try to
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 781546269d26..669da9ef714d 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -555,8 +555,9 @@ static int hub_port_status(struct usb_hub *hub, int port1,
 	mutex_lock(&amp;hub-&gt;status_mutex);
 	ret = get_port_status(hub-&gt;hdev, port1, &amp;hub-&gt;status-&gt;port);
 	if (ret &lt; 4) {
-		dev_err(hub-&gt;intfdev,
-			"%s failed (err = %d)\n", __func__, ret);
+		if (ret != -ENODEV)
+			dev_err(hub-&gt;intfdev,
+				"%s failed (err = %d)\n", __func__, ret);
 		if (ret &gt;= 0)
 			ret = -EIO;
 	} else {
@@ -699,7 +700,7 @@ static void hub_tt_work(struct work_struct *work)
 		/* drop lock so HCD can concurrently report other TT errors */
 		spin_unlock_irqrestore (&amp;hub-&gt;tt.lock, flags);
 		status = hub_clear_tt_buffer (hdev, clear-&gt;devinfo, clear-&gt;tt);
-		if (status)
+		if (status &amp;&amp; status != -ENODEV)
 			dev_err (&amp;hdev-&gt;dev,
 				"clear tt %d (%04x) error %d\n",
 				clear-&gt;tt, clear-&gt;devinfo, status);
@@ -837,10 +838,11 @@ static int hub_hub_status(struct usb_hub *hub,
 
 	mutex_lock(&amp;hub-&gt;status_mutex);
 	ret = get_hub_status(hub-&gt;hdev, &amp;hub-&gt;status-&gt;hub);
-	if (ret &lt; 0)
-		dev_err (hub-&gt;intfdev,
-			"%s failed (err = %d)\n", __func__, ret);
-	else {
+	if (ret &lt; 0) {
+		if (ret != -ENODEV)
+			dev_err(hub-&gt;intfdev,
+				"%s failed (err = %d)\n", __func__, ret);
+	} else {
 		*status = le16_to_cpu(hub-&gt;status-&gt;hub.wHubStatus);
 		*change = le16_to_cpu(hub-&gt;status-&gt;hub.wHubChange); 
 		ret = 0;
@@ -877,11 +879,8 @@ static int hub_usb3_port_disable(struct usb_hub *hub, int port1)
 		return -EINVAL;
 
 	ret = hub_set_port_link_state(hub, port1, USB_SS_PORT_LS_SS_DISABLED);
-	if (ret) {
-		dev_err(hub-&gt;intfdev, "cannot disable port %d (err = %d)\n",
-				port1, ret);
+	if (ret)
 		return ret;
-	}
 
 	/* Wait for the link to enter the disabled state. */
 	for (total_time = 0; ; total_time += HUB_DEBOUNCE_STEP) {
@@ -918,7 +917,7 @@ static int hub_port_disable(struct usb_hub *hub, int port1, int set_state)
 			ret = usb_clear_port_feature(hdev, port1,
 					USB_PORT_FEAT_ENABLE);
 	}
-	if (ret)
+	if (ret &amp;&amp; ret != -ENODEV)
 		dev_err(hub-&gt;intfdev, "cannot disable port %d (err = %d)\n",
 				port1, ret);
 	return ret;
@@ -2196,8 +2195,9 @@ static int usb_enumerate_device(struct usb_device *udev)
 	if (udev-&gt;config == NULL) {
 		err = usb_get_configuration(udev);
 		if (err &lt; 0) {
-			dev_err(&amp;udev-&gt;dev, "can't read configurations, error %d\n",
-				err);
+			if (err != -ENODEV)
+				dev_err(&amp;udev-&gt;dev, "can't read configurations, error %d\n",
+						err);
 			return err;
 		}
 	}
@@ -2644,14 +2644,16 @@ static int hub_port_reset(struct usb_hub *hub, int port1,
 		status = set_port_feature(hub-&gt;hdev, port1, (warm ?
 					USB_PORT_FEAT_BH_PORT_RESET :
 					USB_PORT_FEAT_RESET));
-		if (status) {
+		if (status == -ENODEV) {
+			;	/* The hub is gone */
+		} else if (status) {
 			dev_err(hub-&gt;intfdev,
 					"cannot %sreset port %d (err = %d)\n",
 					warm ? "warm " : "", port1, status);
 		} else {
 			status = hub_port_wait_reset(hub, port1, udev, delay,
 								warm);
-			if (status &amp;&amp; status != -ENOTCONN)
+			if (status &amp;&amp; status != -ENOTCONN &amp;&amp; status != -ENODEV)
 				dev_dbg(hub-&gt;intfdev,
 						"port_wait_reset: err = %d\n",
 						status);
@@ -4094,9 +4096,9 @@ hub_port_init (struct usb_hub *hub, struct usb_device *udev, int port1,
 				goto fail;
 			}
 			if (r) {
-				dev_err(&amp;udev-&gt;dev,
-					"device descriptor read/64, error %d\n",
-					r);
+				if (r != -ENODEV)
+					dev_err(&amp;udev-&gt;dev, "device descriptor read/64, error %d\n",
+							r);
 				retval = -EMSGSIZE;
 				continue;
 			}
@@ -4116,9 +4118,9 @@ hub_port_init (struct usb_hub *hub, struct usb_device *udev, int port1,
 				msleep(200);
 			}
 			if (retval &lt; 0) {
-				dev_err(&amp;udev-&gt;dev,
-					"device not accepting address %d, error %d\n",
-					devnum, retval);
+				if (retval != -ENODEV)
+					dev_err(&amp;udev-&gt;dev, "device not accepting address %d, error %d\n",
+							devnum, retval);
 				goto fail;
 			}
 			if (udev-&gt;speed == USB_SPEED_SUPER) {
@@ -4140,7 +4142,8 @@ hub_port_init (struct usb_hub *hub, struct usb_device *udev, int port1,
 
 		retval = usb_get_device_descriptor(udev, 8);
 		if (retval &lt; 8) {
-			dev_err(&amp;udev-&gt;dev,
+			if (retval != -ENODEV)
+				dev_err(&amp;udev-&gt;dev,
 					"device descriptor read/8, error %d\n",
 					retval);
 			if (retval &gt;= 0)
@@ -4194,8 +4197,9 @@ hub_port_init (struct usb_hub *hub, struct usb_device *udev, int port1,
   
 	retval = usb_get_device_descriptor(udev, USB_DT_DEVICE_SIZE);
 	if (retval &lt; (signed)sizeof(udev-&gt;descriptor)) {
-		dev_err(&amp;udev-&gt;dev, "device descriptor read/all, error %d\n",
-			retval);
+		if (retval != -ENODEV)
+			dev_err(&amp;udev-&gt;dev, "device descriptor read/all, error %d\n",
+					retval);
 		if (retval &gt;= 0)
 			retval = -ENOMSG;
 		goto fail;
@@ -4377,7 +4381,7 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 				USB_PORT_STAT_C_ENABLE)) {
 		status = hub_port_debounce_be_stable(hub, port1);
 		if (status &lt; 0) {
-			if (printk_ratelimit())
+			if (status != -ENODEV &amp;&amp; printk_ratelimit())
 				dev_err(hub_dev, "connect-debounce failed, "
 						"port %d disabled\n", port1);
 			portstatus &amp;= ~USB_PORT_STAT_CONNECTION;
@@ -4406,6 +4410,7 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 	else
 		unit_load = 100;
 
+	status = 0;
 	for (i = 0; i &lt; SET_CONFIG_TRIES; i++) {
 
 		/* reallocate for each attempt, since references
@@ -4530,9 +4535,11 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 	}
 	if (hub-&gt;hdev-&gt;parent ||
 			!hcd-&gt;driver-&gt;port_handed_over ||
-			!(hcd-&gt;driver-&gt;port_handed_over)(hcd, port1))
-		dev_err(hub_dev, "unable to enumerate USB device on port %d\n",
-				port1);
+			!(hcd-&gt;driver-&gt;port_handed_over)(hcd, port1)) {
+		if (status != -ENOTCONN &amp;&amp; status != -ENODEV)
+			dev_err(hub_dev, "unable to enumerate USB device on port %d\n",
+					port1);
+	}
  
 done:
 	hub_port_disable(hub, port1, 1);</pre><hr><pre>commit afc2c9a2c359c850cea097c60a5f2b596efbbd88
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Mar 22 13:32:10 2013 -0400

    USB: EHCI: remove unused variable in unlink_empty_async()
    
    This patch (as1669) removes the check_unlinks_later flag in ehci-hcd's
    unlink_empty_async().  It wasn't being used for anything and should
    have been removed in an earlier patch, but I forgot about it.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 820583bfb5ee..50787a389fa8 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -1268,7 +1268,6 @@ static void unlink_empty_async(struct ehci_hcd *ehci)
 {
 	struct ehci_qh		*qh;
 	struct ehci_qh		*qh_to_unlink = NULL;
-	bool			check_unlinks_later = false;
 	int			count = 0;
 
 	/* Find the last async QH which has been empty for a timer cycle */
@@ -1276,9 +1275,7 @@ static void unlink_empty_async(struct ehci_hcd *ehci)
 		if (list_empty(&amp;qh-&gt;qtd_list) &amp;&amp;
 				qh-&gt;qh_state == QH_STATE_LINKED) {
 			++count;
-			if (qh-&gt;unlink_cycle == ehci-&gt;async_unlink_cycle)
-				check_unlinks_later = true;
-			else
+			if (qh-&gt;unlink_cycle != ehci-&gt;async_unlink_cycle)
 				qh_to_unlink = qh;
 		}
 	}</pre><hr><pre>commit 214ac7a0771d95d2f66d01bca5afeb2c9e8ac3c8
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Mar 22 13:31:58 2013 -0400

    USB: EHCI: improve end_unlink_async()
    
    This patch (as1665) changes the way ehci-hcd's end_unlink_async()
    routine works in order to avoid recursive execution and to be more
    efficient:
    
            Now when an IAA cycle ends, a new one gets started up right
            away (if it is needed) instead of waiting until the
            just-unlinked QH has been processed.
    
            The async_iaa list is renamed to async_idle, which better
            expresses its new purpose: It is now the list of QHs which are
            now completely idle and are waiting to be processed by
            end_unlink_async().
    
            A new flag is added to track whether an IAA cycle is in
            progress, because the list formerly known as async_iaa no
            longer stores the QHs waiting for the IAA to finish.
    
            The decision about how many QHs to process when an IAA cycle
            ends is now made at the end of the cycle, when we know the
            current state of the hardware, rather than at the beginning.
            This means a bunch of logic got moved from start_iaa_cycle()
            to end_unlink_async().
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index b32323ca07d3..037a4729d549 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -483,7 +483,7 @@ static int ehci_init(struct usb_hcd *hcd)
 	 */
 	ehci-&gt;periodic_size = DEFAULT_I_TDPS;
 	INIT_LIST_HEAD(&amp;ehci-&gt;async_unlink);
-	INIT_LIST_HEAD(&amp;ehci-&gt;async_iaa);
+	INIT_LIST_HEAD(&amp;ehci-&gt;async_idle);
 	INIT_LIST_HEAD(&amp;ehci-&gt;intr_unlink);
 	INIT_LIST_HEAD(&amp;ehci-&gt;intr_qh_list);
 	INIT_LIST_HEAD(&amp;ehci-&gt;cached_itd_list);
@@ -752,7 +752,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 		/* guard against (alleged) silicon errata */
 		if (cmd &amp; CMD_IAAD)
 			ehci_dbg(ehci, "IAA with IAAD still set?\n");
-		if (!list_empty(&amp;ehci-&gt;async_iaa))
+		if (ehci-&gt;iaa_in_progress)
 			COUNT(ehci-&gt;stats.iaa);
 		end_unlink_async(ehci);
 	}
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 4a01367bb2a0..820583bfb5ee 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -960,7 +960,7 @@ static void disable_async(struct ehci_hcd *ehci)
 
 	/* The async schedule and unlink lists are supposed to be empty */
 	WARN_ON(ehci-&gt;async-&gt;qh_next.qh || !list_empty(&amp;ehci-&gt;async_unlink) ||
-			!list_empty(&amp;ehci-&gt;async_iaa));
+			!list_empty(&amp;ehci-&gt;async_idle));
 
 	/* Don't turn off the schedule until ASS is 1 */
 	ehci_poll_ASS(ehci);
@@ -1164,41 +1164,19 @@ static void single_unlink_async(struct ehci_hcd *ehci, struct ehci_qh *qh)
 		ehci-&gt;qh_scan_next = qh-&gt;qh_next.qh;
 }
 
-static void start_iaa_cycle(struct ehci_hcd *ehci, bool nested)
+static void start_iaa_cycle(struct ehci_hcd *ehci)
 {
-	/*
-	 * Do nothing if an IAA cycle is already running or
-	 * if one will be started shortly.
-	 */
-	if (!list_empty(&amp;ehci-&gt;async_iaa) || ehci-&gt;async_unlinking)
+	/* Do nothing if an IAA cycle is already running */
+	if (ehci-&gt;iaa_in_progress)
 		return;
+	ehci-&gt;iaa_in_progress = true;
 
 	/* If the controller isn't running, we don't have to wait for it */
 	if (unlikely(ehci-&gt;rh_state &lt; EHCI_RH_RUNNING)) {
-
-		/* Do all the waiting QHs */
-		list_splice_tail_init(&amp;ehci-&gt;async_unlink, &amp;ehci-&gt;async_iaa);
-
-		if (!nested)		/* Avoid recursion */
-			end_unlink_async(ehci);
+		end_unlink_async(ehci);
 
 	/* Otherwise start a new IAA cycle */
 	} else if (likely(ehci-&gt;rh_state == EHCI_RH_RUNNING)) {
-		struct ehci_qh		*qh;
-
-		/* Do only the first waiting QH (nVidia bug?) */
-		qh = list_first_entry(&amp;ehci-&gt;async_unlink, struct ehci_qh,
-				unlink_node);
-
-		/*
-		 * Intel (?) bug: The HC can write back the overlay region
-		 * even after the IAA interrupt occurs.  In self-defense,
-		 * always go through two IAA cycles for each QH.
-		 */
-		if (qh-&gt;qh_state == QH_STATE_UNLINK_WAIT)
-			qh-&gt;qh_state = QH_STATE_UNLINK;
-		else
-			list_move_tail(&amp;qh-&gt;unlink_node, &amp;ehci-&gt;async_iaa);
 
 		/* Make sure the unlinks are all visible to the hardware */
 		wmb();
@@ -1215,16 +1193,59 @@ static void start_iaa_cycle(struct ehci_hcd *ehci, bool nested)
 static void end_unlink_async(struct ehci_hcd *ehci)
 {
 	struct ehci_qh		*qh;
+	bool			early_exit;
 
 	if (ehci-&gt;has_synopsys_hc_bug)
 		ehci_writel(ehci, (u32) ehci-&gt;async-&gt;qh_dma,
 			    &amp;ehci-&gt;regs-&gt;async_next);
 
+	/* The current IAA cycle has ended */
+	ehci-&gt;iaa_in_progress = false;
+
+	if (list_empty(&amp;ehci-&gt;async_unlink))
+		return;
+	qh = list_first_entry(&amp;ehci-&gt;async_unlink, struct ehci_qh,
+			unlink_node);	/* QH whose IAA cycle just ended */
+
+	/*
+	 * If async_unlinking is set then this routine is already running,
+	 * either on the stack or on another CPU.
+	 */
+	early_exit = ehci-&gt;async_unlinking;
+
+	/* If the controller isn't running, process all the waiting QHs */
+	if (ehci-&gt;rh_state &lt; EHCI_RH_RUNNING)
+		list_splice_tail_init(&amp;ehci-&gt;async_unlink, &amp;ehci-&gt;async_idle);
+
+	/*
+	 * Intel (?) bug: The HC can write back the overlay region even
+	 * after the IAA interrupt occurs.  In self-defense, always go
+	 * through two IAA cycles for each QH.
+	 */
+	else if (qh-&gt;qh_state == QH_STATE_UNLINK_WAIT) {
+		qh-&gt;qh_state = QH_STATE_UNLINK;
+		early_exit = true;
+	}
+
+	/* Otherwise process only the first waiting QH (NVIDIA bug?) */
+	else
+		list_move_tail(&amp;qh-&gt;unlink_node, &amp;ehci-&gt;async_idle);
+
+	/* Start a new IAA cycle if any QHs are waiting for it */
+	if (!list_empty(&amp;ehci-&gt;async_unlink))
+		start_iaa_cycle(ehci);
+
+	/*
+	 * Don't allow nesting or concurrent calls,
+	 * or wait for the second IAA cycle for the next QH.
+	 */
+	if (early_exit)
+		return;
+
 	/* Process the idle QHs */
- restart:
 	ehci-&gt;async_unlinking = true;
-	while (!list_empty(&amp;ehci-&gt;async_iaa)) {
-		qh = list_first_entry(&amp;ehci-&gt;async_iaa, struct ehci_qh,
+	while (!list_empty(&amp;ehci-&gt;async_idle)) {
+		qh = list_first_entry(&amp;ehci-&gt;async_idle, struct ehci_qh,
 				unlink_node);
 		list_del(&amp;qh-&gt;unlink_node);
 
@@ -1239,13 +1260,6 @@ static void end_unlink_async(struct ehci_hcd *ehci)
 		disable_async(ehci);
 	}
 	ehci-&gt;async_unlinking = false;
-
-	/* Start a new IAA cycle if any QHs are waiting for it */
-	if (!list_empty(&amp;ehci-&gt;async_unlink)) {
-		start_iaa_cycle(ehci, true);
-		if (unlikely(ehci-&gt;rh_state &lt; EHCI_RH_RUNNING))
-			goto restart;
-	}
 }
 
 static void start_unlink_async(struct ehci_hcd *ehci, struct ehci_qh *qh);
@@ -1270,8 +1284,7 @@ static void unlink_empty_async(struct ehci_hcd *ehci)
 	}
 
 	/* If nothing else is being unlinked, unlink the last empty QH */
-	if (list_empty(&amp;ehci-&gt;async_iaa) &amp;&amp; list_empty(&amp;ehci-&gt;async_unlink) &amp;&amp;
-			qh_to_unlink) {
+	if (list_empty(&amp;ehci-&gt;async_unlink) &amp;&amp; qh_to_unlink) {
 		start_unlink_async(ehci, qh_to_unlink);
 		--count;
 	}
@@ -1293,7 +1306,7 @@ static void unlink_empty_async_suspended(struct ehci_hcd *ehci)
 		WARN_ON(!list_empty(&amp;qh-&gt;qtd_list));
 		single_unlink_async(ehci, qh);
 	}
-	start_iaa_cycle(ehci, false);
+	start_iaa_cycle(ehci);
 }
 
 /* makes sure the async qh will become idle */
@@ -1306,7 +1319,7 @@ static void start_unlink_async(struct ehci_hcd *ehci, struct ehci_qh *qh)
 		return;
 
 	single_unlink_async(ehci, qh);
-	start_iaa_cycle(ehci, false);
+	start_iaa_cycle(ehci);
 }
 
 /*-------------------------------------------------------------------------*/
diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index f63a98353efd..11e5b32f73e9 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -304,7 +304,7 @@ static void ehci_iaa_watchdog(struct ehci_hcd *ehci)
 	 * (a) SMP races against real IAA firing and retriggering, and
 	 * (b) clean HC shutdown, when IAA watchdog was pending.
 	 */
-	if (ehci-&gt;rh_state != EHCI_RH_RUNNING)
+	if (!ehci-&gt;iaa_in_progress || ehci-&gt;rh_state != EHCI_RH_RUNNING)
 		return;
 
 	/* If we get here, IAA is *REALLY* late.  It's barely
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 13f67041502e..e66699950997 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -121,6 +121,7 @@ struct ehci_hcd {			/* one per controller */
 	bool			scanning:1;
 	bool			need_rescan:1;
 	bool			intr_unlinking:1;
+	bool			iaa_in_progress:1;
 	bool			async_unlinking:1;
 	bool			shutdown:1;
 	struct ehci_qh		*qh_scan_next;
@@ -129,7 +130,7 @@ struct ehci_hcd {			/* one per controller */
 	struct ehci_qh		*async;
 	struct ehci_qh		*dummy;		/* For AMD quirk use */
 	struct list_head	async_unlink;
-	struct list_head	async_iaa;
+	struct list_head	async_idle;
 	unsigned		async_unlink_cycle;
 	unsigned		async_count;	/* async activity count */
 </pre><hr><pre>commit 6e018751a35f6ef7ad04eb8006b5886b6a7c47f5
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Mar 22 13:31:45 2013 -0400

    USB: EHCI: convert singly-linked lists to list_heads
    
    This patch (as1664) converts ehci-hcd's async_unlink, async_iaa, and
    intr_unlink from singly-linked lists to standard doubly-linked
    list_heads.  Originally it didn't seem necessary to use list_heads,
    because items are always added to and removed from these lists in FIFO
    order.  But now with more list processing going on, it's easier to use
    the standard routines than continue with a roll-your-own approach.
    
    I don't know if the code ends up being notably shorter, but the
    patterns will be more familiar to any kernel hacker.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-dbg.c b/drivers/usb/host/ehci-dbg.c
index 70b496dc18a0..5429d2645bbc 100644
--- a/drivers/usb/host/ehci-dbg.c
+++ b/drivers/usb/host/ehci-dbg.c
@@ -510,14 +510,16 @@ static ssize_t fill_async_buffer(struct debug_buffer *buf)
 	spin_lock_irqsave (&amp;ehci-&gt;lock, flags);
 	for (qh = ehci-&gt;async-&gt;qh_next.qh; size &gt; 0 &amp;&amp; qh; qh = qh-&gt;qh_next.qh)
 		qh_lines (ehci, qh, &amp;next, &amp;size);
-	if (ehci-&gt;async_unlink &amp;&amp; size &gt; 0) {
+	if (!list_empty(&amp;ehci-&gt;async_unlink) &amp;&amp; size &gt; 0) {
 		temp = scnprintf(next, size, "\nunlink =\n");
 		size -= temp;
 		next += temp;
 
-		for (qh = ehci-&gt;async_unlink; size &gt; 0 &amp;&amp; qh;
-				qh = qh-&gt;unlink_next)
-			qh_lines (ehci, qh, &amp;next, &amp;size);
+		list_for_each_entry(qh, &amp;ehci-&gt;async_unlink, unlink_node) {
+			if (size &lt;= 0)
+				break;
+			qh_lines(ehci, qh, &amp;next, &amp;size);
+		}
 	}
 	spin_unlock_irqrestore (&amp;ehci-&gt;lock, flags);
 
@@ -814,9 +816,10 @@ static ssize_t fill_registers_buffer(struct debug_buffer *buf)
 		}
 	}
 
-	if (ehci-&gt;async_unlink) {
+	if (!list_empty(&amp;ehci-&gt;async_unlink)) {
 		temp = scnprintf(next, size, "async unlink qh %p\n",
-				ehci-&gt;async_unlink);
+				list_first_entry(&amp;ehci-&gt;async_unlink,
+						struct ehci_qh, unlink_node));
 		size -= temp;
 		next += temp;
 	}
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 87fe3daaa092..b32323ca07d3 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -482,6 +482,9 @@ static int ehci_init(struct usb_hcd *hcd)
 	 * periodic_size can shrink by USBCMD update if hcc_params allows.
 	 */
 	ehci-&gt;periodic_size = DEFAULT_I_TDPS;
+	INIT_LIST_HEAD(&amp;ehci-&gt;async_unlink);
+	INIT_LIST_HEAD(&amp;ehci-&gt;async_iaa);
+	INIT_LIST_HEAD(&amp;ehci-&gt;intr_unlink);
 	INIT_LIST_HEAD(&amp;ehci-&gt;intr_qh_list);
 	INIT_LIST_HEAD(&amp;ehci-&gt;cached_itd_list);
 	INIT_LIST_HEAD(&amp;ehci-&gt;cached_sitd_list);
@@ -749,7 +752,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 		/* guard against (alleged) silicon errata */
 		if (cmd &amp; CMD_IAAD)
 			ehci_dbg(ehci, "IAA with IAAD still set?\n");
-		if (ehci-&gt;async_iaa)
+		if (!list_empty(&amp;ehci-&gt;async_iaa))
 			COUNT(ehci-&gt;stats.iaa);
 		end_unlink_async(ehci);
 	}
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index fca741dbf9df..4a01367bb2a0 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -958,8 +958,9 @@ static void disable_async(struct ehci_hcd *ehci)
 	if (--ehci-&gt;async_count)
 		return;
 
-	/* The async schedule and async_unlink list are supposed to be empty */
-	WARN_ON(ehci-&gt;async-&gt;qh_next.qh || ehci-&gt;async_unlink);
+	/* The async schedule and unlink lists are supposed to be empty */
+	WARN_ON(ehci-&gt;async-&gt;qh_next.qh || !list_empty(&amp;ehci-&gt;async_unlink) ||
+			!list_empty(&amp;ehci-&gt;async_iaa));
 
 	/* Don't turn off the schedule until ASS is 1 */
 	ehci_poll_ASS(ehci);
@@ -1150,11 +1151,7 @@ static void single_unlink_async(struct ehci_hcd *ehci, struct ehci_qh *qh)
 
 	/* Add to the end of the list of QHs waiting for the next IAAD */
 	qh-&gt;qh_state = QH_STATE_UNLINK_WAIT;
-	if (ehci-&gt;async_unlink)
-		ehci-&gt;async_unlink_last-&gt;unlink_next = qh;
-	else
-		ehci-&gt;async_unlink = qh;
-	ehci-&gt;async_unlink_last = qh;
+	list_add_tail(&amp;qh-&gt;unlink_node, &amp;ehci-&gt;async_unlink);
 
 	/* Unlink it from the schedule */
 	prev = ehci-&gt;async;
@@ -1173,15 +1170,14 @@ static void start_iaa_cycle(struct ehci_hcd *ehci, bool nested)
 	 * Do nothing if an IAA cycle is already running or
 	 * if one will be started shortly.
 	 */
-	if (ehci-&gt;async_iaa || ehci-&gt;async_unlinking)
+	if (!list_empty(&amp;ehci-&gt;async_iaa) || ehci-&gt;async_unlinking)
 		return;
 
 	/* If the controller isn't running, we don't have to wait for it */
 	if (unlikely(ehci-&gt;rh_state &lt; EHCI_RH_RUNNING)) {
 
 		/* Do all the waiting QHs */
-		ehci-&gt;async_iaa = ehci-&gt;async_unlink;
-		ehci-&gt;async_unlink = NULL;
+		list_splice_tail_init(&amp;ehci-&gt;async_unlink, &amp;ehci-&gt;async_iaa);
 
 		if (!nested)		/* Avoid recursion */
 			end_unlink_async(ehci);
@@ -1191,20 +1187,18 @@ static void start_iaa_cycle(struct ehci_hcd *ehci, bool nested)
 		struct ehci_qh		*qh;
 
 		/* Do only the first waiting QH (nVidia bug?) */
-		qh = ehci-&gt;async_unlink;
+		qh = list_first_entry(&amp;ehci-&gt;async_unlink, struct ehci_qh,
+				unlink_node);
 
 		/*
 		 * Intel (?) bug: The HC can write back the overlay region
 		 * even after the IAA interrupt occurs.  In self-defense,
 		 * always go through two IAA cycles for each QH.
 		 */
-		if (qh-&gt;qh_state == QH_STATE_UNLINK_WAIT) {
+		if (qh-&gt;qh_state == QH_STATE_UNLINK_WAIT)
 			qh-&gt;qh_state = QH_STATE_UNLINK;
-		} else {
-			ehci-&gt;async_iaa = qh;
-			ehci-&gt;async_unlink = qh-&gt;unlink_next;
-			qh-&gt;unlink_next = NULL;
-		}
+		else
+			list_move_tail(&amp;qh-&gt;unlink_node, &amp;ehci-&gt;async_iaa);
 
 		/* Make sure the unlinks are all visible to the hardware */
 		wmb();
@@ -1229,10 +1223,10 @@ static void end_unlink_async(struct ehci_hcd *ehci)
 	/* Process the idle QHs */
  restart:
 	ehci-&gt;async_unlinking = true;
-	while (ehci-&gt;async_iaa) {
-		qh = ehci-&gt;async_iaa;
-		ehci-&gt;async_iaa = qh-&gt;unlink_next;
-		qh-&gt;unlink_next = NULL;
+	while (!list_empty(&amp;ehci-&gt;async_iaa)) {
+		qh = list_first_entry(&amp;ehci-&gt;async_iaa, struct ehci_qh,
+				unlink_node);
+		list_del(&amp;qh-&gt;unlink_node);
 
 		qh-&gt;qh_state = QH_STATE_IDLE;
 		qh-&gt;qh_next.qh = NULL;
@@ -1247,7 +1241,7 @@ static void end_unlink_async(struct ehci_hcd *ehci)
 	ehci-&gt;async_unlinking = false;
 
 	/* Start a new IAA cycle if any QHs are waiting for it */
-	if (ehci-&gt;async_unlink) {
+	if (!list_empty(&amp;ehci-&gt;async_unlink)) {
 		start_iaa_cycle(ehci, true);
 		if (unlikely(ehci-&gt;rh_state &lt; EHCI_RH_RUNNING))
 			goto restart;
@@ -1276,7 +1270,8 @@ static void unlink_empty_async(struct ehci_hcd *ehci)
 	}
 
 	/* If nothing else is being unlinked, unlink the last empty QH */
-	if (!ehci-&gt;async_iaa &amp;&amp; !ehci-&gt;async_unlink &amp;&amp; qh_to_unlink) {
+	if (list_empty(&amp;ehci-&gt;async_iaa) &amp;&amp; list_empty(&amp;ehci-&gt;async_unlink) &amp;&amp;
+			qh_to_unlink) {
 		start_unlink_async(ehci, qh_to_unlink);
 		--count;
 	}
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index e7a2dbd27b1e..c833febf8df0 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -620,17 +620,13 @@ static void start_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh)
 	qh-&gt;unlink_cycle = ehci-&gt;intr_unlink_cycle;
 
 	/* New entries go at the end of the intr_unlink list */
-	if (ehci-&gt;intr_unlink)
-		ehci-&gt;intr_unlink_last-&gt;unlink_next = qh;
-	else
-		ehci-&gt;intr_unlink = qh;
-	ehci-&gt;intr_unlink_last = qh;
+	list_add_tail(&amp;qh-&gt;unlink_node, &amp;ehci-&gt;intr_unlink);
 
 	if (ehci-&gt;intr_unlinking)
 		;	/* Avoid recursive calls */
 	else if (ehci-&gt;rh_state &lt; EHCI_RH_RUNNING)
 		ehci_handle_intr_unlinks(ehci);
-	else if (ehci-&gt;intr_unlink == qh) {
+	else if (ehci-&gt;intr_unlink.next == &amp;qh-&gt;unlink_node) {
 		ehci_enable_event(ehci, EHCI_HRTIMER_UNLINK_INTR, true);
 		++ehci-&gt;intr_unlink_cycle;
 	}
diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index e7363332887e..f63a98353efd 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -229,18 +229,19 @@ static void ehci_handle_intr_unlinks(struct ehci_hcd *ehci)
 	 * process all the QHs on the list.
 	 */
 	ehci-&gt;intr_unlinking = true;
-	while (ehci-&gt;intr_unlink) {
-		struct ehci_qh	*qh = ehci-&gt;intr_unlink;
+	while (!list_empty(&amp;ehci-&gt;intr_unlink)) {
+		struct ehci_qh	*qh;
 
+		qh = list_first_entry(&amp;ehci-&gt;intr_unlink, struct ehci_qh,
+				unlink_node);
 		if (!stopped &amp;&amp; qh-&gt;unlink_cycle == ehci-&gt;intr_unlink_cycle)
 			break;
-		ehci-&gt;intr_unlink = qh-&gt;unlink_next;
-		qh-&gt;unlink_next = NULL;
+		list_del(&amp;qh-&gt;unlink_node);
 		end_unlink_intr(ehci, qh);
 	}
 
 	/* Handle remaining entries later */
-	if (ehci-&gt;intr_unlink) {
+	if (!list_empty(&amp;ehci-&gt;intr_unlink)) {
 		ehci_enable_event(ehci, EHCI_HRTIMER_UNLINK_INTR, true);
 		++ehci-&gt;intr_unlink_cycle;
 	}
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 6815209511aa..13f67041502e 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -128,9 +128,8 @@ struct ehci_hcd {			/* one per controller */
 	/* async schedule support */
 	struct ehci_qh		*async;
 	struct ehci_qh		*dummy;		/* For AMD quirk use */
-	struct ehci_qh		*async_unlink;
-	struct ehci_qh		*async_unlink_last;
-	struct ehci_qh		*async_iaa;
+	struct list_head	async_unlink;
+	struct list_head	async_iaa;
 	unsigned		async_unlink_cycle;
 	unsigned		async_count;	/* async activity count */
 
@@ -143,8 +142,7 @@ struct ehci_hcd {			/* one per controller */
 	unsigned		i_thresh;	/* uframes HC might cache */
 
 	union ehci_shadow	*pshadow;	/* mirror hw periodic table */
-	struct ehci_qh		*intr_unlink;
-	struct ehci_qh		*intr_unlink_last;
+	struct list_head	intr_unlink;
 	unsigned		intr_unlink_cycle;
 	unsigned		now_frame;	/* frame from HC hardware */
 	unsigned		last_iso_frame;	/* last frame scanned for iso */
@@ -380,7 +378,7 @@ struct ehci_qh {
 	struct list_head	qtd_list;	/* sw qtd list */
 	struct list_head	intr_node;	/* list of intr QHs */
 	struct ehci_qtd		*dummy;
-	struct ehci_qh		*unlink_next;	/* next on unlink list */
+	struct list_head	unlink_node;
 
 	unsigned		unlink_cycle;
 </pre><hr><pre>commit 7655e3160c78a18c2ecf7bf4dee0bbfe58575c7f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Mar 22 13:31:29 2013 -0400

    USB: EHCI: consolidate code in ehci_urb_dequeue()
    
    This patch (as1668) consolidates two nearly identical code paths in
    ehci_urb_dequeue().  The test for !qh can be removed because it will
    never succeed; the fact that usb_hcd_check_unlink_urb() returned 0
    means that urb must be queued and therefore urb-&gt;hcpriv must point to
    a QH.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 93f4cd75845e..87fe3daaa092 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -896,17 +896,21 @@ static int ehci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 	if (rc)
 		goto done;
 
-	switch (usb_pipetype (urb-&gt;pipe)) {
-	// case PIPE_CONTROL:
-	// case PIPE_BULK:
-	default:
+	if (usb_pipetype(urb-&gt;pipe) == PIPE_ISOCHRONOUS) {
+		/*
+		 * We don't expedite dequeue for isochronous URBs.
+		 * Just wait until they complete normally or their
+		 * time slot expires.
+		 */
+	} else {
 		qh = (struct ehci_qh *) urb-&gt;hcpriv;
-		if (!qh)
-			break;
 		qh-&gt;exception = 1;
 		switch (qh-&gt;qh_state) {
 		case QH_STATE_LINKED:
-			start_unlink_async(ehci, qh);
+			if (usb_pipetype(urb-&gt;pipe) == PIPE_INTERRUPT)
+				start_unlink_intr(ehci, qh);
+			else
+				start_unlink_async(ehci, qh);
 			break;
 		case QH_STATE_COMPLETING:
 			qh-&gt;dequeue_during_giveback = 1;
@@ -920,36 +924,6 @@ static int ehci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 			qh_completions(ehci, qh);
 			break;
 		}
-		break;
-
-	case PIPE_INTERRUPT:
-		qh = (struct ehci_qh *) urb-&gt;hcpriv;
-		if (!qh)
-			break;
-		qh-&gt;exception = 1;
-		switch (qh-&gt;qh_state) {
-		case QH_STATE_LINKED:
-			start_unlink_intr(ehci, qh);
-			break;
-		case QH_STATE_COMPLETING:
-			qh-&gt;dequeue_during_giveback = 1;
-			break;
-		case QH_STATE_IDLE:
-			qh_completions (ehci, qh);
-			break;
-		default:
-			ehci_dbg (ehci, "bogus qh %p state %d\n",
-					qh, qh-&gt;qh_state);
-			goto done;
-		}
-		break;
-
-	case PIPE_ISOCHRONOUS:
-		// itd or sitd ...
-
-		// wait till next completion, do it then.
-		// completion irqs can wait up to 1024 msec,
-		break;
 	}
 done:
 	spin_unlock_irqrestore (&amp;ehci-&gt;lock, flags);</pre><hr><pre>commit 7bc782d73c7db042ecc965866b8c1c2b7d6e93d6
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Mar 22 13:31:11 2013 -0400

    USB: EHCI: split needs_rescan into two flags
    
    This patch (as1662) does some more QH-related cleanup in ehci-hcd.
    The qh-&gt;needs_rescan flag is currently used for two different
    purposes; the patch replaces it with two separate flags for greater
    clarity: qh-&gt;dequeue_during_giveback indicates that a completion
    handler dequeued an URB (implying that a rescan is needed), and
    qh-&gt;exception indicates that the QH is in an exceptional state
    requiring an unlink (either it encountered an I/O error or an unlink
    was requested).
    
    The new flags get set where the dequeue, exception, or unlink request
    occurred, rather than where the unlink is started.  This is so that in
    the future, if we need to, we will be able to tell apart unlinks that
    truly were required from those that were carried out merely because
    the QH wasn't being used.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 0c3314c41363..93f4cd75845e 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -903,11 +903,14 @@ static int ehci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 		qh = (struct ehci_qh *) urb-&gt;hcpriv;
 		if (!qh)
 			break;
+		qh-&gt;exception = 1;
 		switch (qh-&gt;qh_state) {
 		case QH_STATE_LINKED:
-		case QH_STATE_COMPLETING:
 			start_unlink_async(ehci, qh);
 			break;
+		case QH_STATE_COMPLETING:
+			qh-&gt;dequeue_during_giveback = 1;
+			break;
 		case QH_STATE_UNLINK:
 		case QH_STATE_UNLINK_WAIT:
 			/* already started */
@@ -923,11 +926,14 @@ static int ehci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 		qh = (struct ehci_qh *) urb-&gt;hcpriv;
 		if (!qh)
 			break;
+		qh-&gt;exception = 1;
 		switch (qh-&gt;qh_state) {
 		case QH_STATE_LINKED:
-		case QH_STATE_COMPLETING:
 			start_unlink_intr(ehci, qh);
 			break;
+		case QH_STATE_COMPLETING:
+			qh-&gt;dequeue_during_giveback = 1;
+			break;
 		case QH_STATE_IDLE:
 			qh_completions (ehci, qh);
 			break;
@@ -984,6 +990,7 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 		goto done;
 	}
 
+	qh-&gt;exception = 1;
 	if (ehci-&gt;rh_state &lt; EHCI_RH_RUNNING)
 		qh-&gt;qh_state = QH_STATE_IDLE;
 	switch (qh-&gt;qh_state) {
@@ -1052,13 +1059,12 @@ ehci_endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 		usb_settoggle(qh-&gt;dev, epnum, is_out, 0);
 		if (!list_empty(&amp;qh-&gt;qtd_list)) {
 			WARN_ONCE(1, "clear_halt for a busy endpoint\n");
-		} else if (qh-&gt;qh_state == QH_STATE_LINKED ||
-				qh-&gt;qh_state == QH_STATE_COMPLETING) {
-
+		} else {
 			/* The toggle value in the QH can't be updated
 			 * while the QH is active.  Unlink it now;
 			 * re-linking will call qh_refresh().
 			 */
+			qh-&gt;exception = 1;
 			if (eptype == USB_ENDPOINT_XFER_BULK)
 				start_unlink_async(ehci, qh);
 			else
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index c95f60d43b1a..fca741dbf9df 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -322,7 +322,7 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
  rescan:
 	last = NULL;
 	last_status = -EINPROGRESS;
-	qh-&gt;needs_rescan = 0;
+	qh-&gt;dequeue_during_giveback = 0;
 
 	/* remove de-activated QTDs from front of queue.
 	 * after faults (including short reads), cleanup this urb
@@ -518,18 +518,12 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	}
 
 	/* Do we need to rescan for URBs dequeued during a giveback? */
-	if (unlikely(qh-&gt;needs_rescan)) {
+	if (unlikely(qh-&gt;dequeue_during_giveback)) {
 		/* If the QH is already unlinked, do the rescan now. */
 		if (state == QH_STATE_IDLE)
 			goto rescan;
 
-		/* Otherwise we have to wait until the QH is fully unlinked.
-		 * Our caller will start an unlink if qh-&gt;needs_rescan is
-		 * set.  But if an unlink has already started, nothing needs
-		 * to be done.
-		 */
-		if (state != QH_STATE_LINKED)
-			qh-&gt;needs_rescan = 0;
+		/* Otherwise the caller must unlink the QH. */
 	}
 
 	/* restore original state; caller must unlink or relink */
@@ -538,29 +532,23 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	/* be sure the hardware's done with the qh before refreshing
 	 * it after fault cleanup, or recovering from silicon wrongly
 	 * overlaying the dummy qtd (which reduces DMA chatter).
+	 *
+	 * We won't refresh a QH that's linked (after the HC
+	 * stopped the queue).  That avoids a race:
+	 *  - HC reads first part of QH;
+	 *  - CPU updates that first part and the token;
+	 *  - HC reads rest of that QH, including token
+	 * Result:  HC gets an inconsistent image, and then
+	 * DMAs to/from the wrong memory (corrupting it).
+	 *
+	 * That should be rare for interrupt transfers,
+	 * except maybe high bandwidth ...
 	 */
-	if (stopped != 0 || hw-&gt;hw_qtd_next == EHCI_LIST_END(ehci)) {
-		if (state == QH_STATE_LINKED) {
-			/*
-			 * We won't refresh a QH that's linked (after the HC
-			 * stopped the queue).  That avoids a race:
-			 *  - HC reads first part of QH;
-			 *  - CPU updates that first part and the token;
-			 *  - HC reads rest of that QH, including token
-			 * Result:  HC gets an inconsistent image, and then
-			 * DMAs to/from the wrong memory (corrupting it).
-			 *
-			 * That should be rare for interrupt transfers,
-			 * except maybe high bandwidth ...
-			 *
-			 * Therefore tell the caller to start an unlink.
-			 */
-			qh-&gt;needs_rescan = 1;
-		}
-		/* otherwise, unlink already started */
-	}
+	if (stopped != 0 || hw-&gt;hw_qtd_next == EHCI_LIST_END(ehci))
+		qh-&gt;exception = 1;
 
-	return qh-&gt;needs_rescan;
+	/* Let the caller know if the QH needs to be unlinked. */
+	return qh-&gt;exception;
 }
 
 /*-------------------------------------------------------------------------*/
@@ -1002,8 +990,9 @@ static void qh_link_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	head-&gt;qh_next.qh = qh;
 	head-&gt;hw-&gt;hw_next = dma;
 
-	qh-&gt;xacterrs = 0;
 	qh-&gt;qh_state = QH_STATE_LINKED;
+	qh-&gt;xacterrs = 0;
+	qh-&gt;exception = 0;
 	/* qtd completions reported later by interrupt */
 
 	enable_async(ehci);
@@ -1317,16 +1306,9 @@ static void unlink_empty_async_suspended(struct ehci_hcd *ehci)
 
 static void start_unlink_async(struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
-	/*
-	 * If the QH isn't linked then there's nothing we can do
-	 * unless we were called during a giveback, in which case
-	 * qh_completions() has to deal with it.
-	 */
-	if (qh-&gt;qh_state != QH_STATE_LINKED) {
-		if (qh-&gt;qh_state == QH_STATE_COMPLETING)
-			qh-&gt;needs_rescan = 1;
+	/* If the QH isn't linked then there's nothing we can do. */
+	if (qh-&gt;qh_state != QH_STATE_LINKED)
 		return;
-	}
 
 	single_unlink_async(ehci, qh);
 	start_iaa_cycle(ehci, false);
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 5c82bbab9a48..e7a2dbd27b1e 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -539,6 +539,7 @@ static void qh_link_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)
 	}
 	qh-&gt;qh_state = QH_STATE_LINKED;
 	qh-&gt;xacterrs = 0;
+	qh-&gt;exception = 0;
 
 	/* update per-qh bandwidth for usbfs */
 	ehci_to_hcd(ehci)-&gt;self.bandwidth_allocated += qh-&gt;period
@@ -602,15 +603,9 @@ static void qh_unlink_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)
 
 static void start_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
-	/* If the QH isn't linked then there's nothing we can do
-	 * unless we were called during a giveback, in which case
-	 * qh_completions() has to deal with it.
-	 */
-	if (qh-&gt;qh_state != QH_STATE_LINKED) {
-		if (qh-&gt;qh_state == QH_STATE_COMPLETING)
-			qh-&gt;needs_rescan = 1;
+	/* If the QH isn't linked then there's nothing we can do. */
+	if (qh-&gt;qh_state != QH_STATE_LINKED)
 		return;
-	}
 
 	qh_unlink_periodic (ehci, qh);
 
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 36c3a8210595..6815209511aa 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -384,7 +384,6 @@ struct ehci_qh {
 
 	unsigned		unlink_cycle;
 
-	u8			needs_rescan;	/* Dequeue during giveback */
 	u8			qh_state;
 #define	QH_STATE_LINKED		1		/* HC sees this */
 #define	QH_STATE_UNLINK		2		/* HC may still see this */
@@ -407,6 +406,9 @@ struct ehci_qh {
 	struct usb_device	*dev;		/* access to TT */
 	unsigned		is_out:1;	/* bulk or intr OUT */
 	unsigned		clearing_tt:1;	/* Clear-TT-Buf in progress */
+	unsigned		dequeue_during_giveback:1;
+	unsigned		exception:1;	/* got a fault, or an unlink
+						   was requested */
 };
 
 /*-------------------------------------------------------------------------*/</pre><hr><pre>commit 79bcf7b02ba3d45bafe81a2753cedb8ef49548e3
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Mar 22 13:30:56 2013 -0400

    USB: EHCI: change return value of qh_completions()
    
    This patch (as1658) cleans up the usage of qh_completions() in
    ehci-hcd.  Currently the function's return value indicates whether any
    URBs were given back; the idea was that the caller can scan the QH
    over again to handle any URBs that were dequeued by a completion
    handler.  This is not necessary; when qh_completions() is ready to
    give back dequeued URBs, it does its own rescanning.
    
    Therefore the new return value will be a flag indicating whether the
    caller needs to unlink the QH.  This is more convenient than forcing
    the caller to check qh-&gt;needs_rescan, and it makes a lot more sense --
    why should "needs_rescan" imply that an unlink is needed?  The callers
    are also changed to remove the unneeded rescans.
    
    Lastly, the check for whether qh-&gt;qtd_list is non-empty is removed
    from the start of qh_completions().  Two of the callers have to make
    this test anyway, so the same test can simply be added to the other
    two callers.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index b824cb674898..c95f60d43b1a 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -292,8 +292,8 @@ static int qh_schedule (struct ehci_hcd *ehci, struct ehci_qh *qh);
 
 /*
  * Process and free completed qtds for a qh, returning URBs to drivers.
- * Chases up to qh-&gt;hw_current.  Returns number of completions called,
- * indicating how much "real" work we did.
+ * Chases up to qh-&gt;hw_current.  Returns nonzero if the caller should
+ * unlink qh.
  */
 static unsigned
 qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
@@ -302,13 +302,9 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	struct list_head	*entry, *tmp;
 	int			last_status;
 	int			stopped;
-	unsigned		count = 0;
 	u8			state;
 	struct ehci_qh_hw	*hw = qh-&gt;hw;
 
-	if (unlikely (list_empty (&amp;qh-&gt;qtd_list)))
-		return count;
-
 	/* completions (or tasks on other cpus) must never clobber HALT
 	 * till we've gone through and cleaned everything up, even when
 	 * they add urbs to this qh's queue or mark them for unlinking.
@@ -345,7 +341,6 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 		if (last) {
 			if (likely (last-&gt;urb != urb)) {
 				ehci_urb_done(ehci, last-&gt;urb, last_status);
-				count++;
 				last_status = -EINPROGRESS;
 			}
 			ehci_qtd_free (ehci, last);
@@ -519,7 +514,6 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	/* last urb's completion might still need calling */
 	if (likely (last != NULL)) {
 		ehci_urb_done(ehci, last-&gt;urb, last_status);
-		count++;
 		ehci_qtd_free (ehci, last);
 	}
 
@@ -566,7 +560,7 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 		/* otherwise, unlink already started */
 	}
 
-	return count;
+	return qh-&gt;needs_rescan;
 }
 
 /*-------------------------------------------------------------------------*/
@@ -1254,7 +1248,8 @@ static void end_unlink_async(struct ehci_hcd *ehci)
 		qh-&gt;qh_state = QH_STATE_IDLE;
 		qh-&gt;qh_next.qh = NULL;
 
-		qh_completions(ehci, qh);
+		if (!list_empty(&amp;qh-&gt;qtd_list))
+			qh_completions(ehci, qh);
 		if (!list_empty(&amp;qh-&gt;qtd_list) &amp;&amp;
 				ehci-&gt;rh_state == EHCI_RH_RUNNING)
 			qh_link_async(ehci, qh);
@@ -1348,7 +1343,7 @@ static void scan_async (struct ehci_hcd *ehci)
 	while (ehci-&gt;qh_scan_next) {
 		qh = ehci-&gt;qh_scan_next;
 		ehci-&gt;qh_scan_next = qh-&gt;qh_next.qh;
- rescan:
+
 		/* clean any finished work for this qh */
 		if (!list_empty(&amp;qh-&gt;qtd_list)) {
 			int temp;
@@ -1361,14 +1356,13 @@ static void scan_async (struct ehci_hcd *ehci)
 			 * in single_unlink_async().
 			 */
 			temp = qh_completions(ehci, qh);
-			if (qh-&gt;needs_rescan) {
+			if (unlikely(temp)) {
 				start_unlink_async(ehci, qh);
 			} else if (list_empty(&amp;qh-&gt;qtd_list)
 					&amp;&amp; qh-&gt;qh_state == QH_STATE_LINKED) {
 				qh-&gt;unlink_cycle = ehci-&gt;async_unlink_cycle;
 				check_unlinks_later = true;
-			} else if (temp != 0)
-				goto rescan;
+			}
 		}
 	}
 
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 66259dc7822e..5c82bbab9a48 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -649,7 +649,8 @@ static void end_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh)
 	qh-&gt;qh_state = QH_STATE_IDLE;
 	hw-&gt;hw_next = EHCI_LIST_END(ehci);
 
-	qh_completions(ehci, qh);
+	if (!list_empty(&amp;qh-&gt;qtd_list))
+		qh_completions(ehci, qh);
 
 	/* reschedule QH iff another request is queued */
 	if (!list_empty(&amp;qh-&gt;qtd_list) &amp;&amp; ehci-&gt;rh_state == EHCI_RH_RUNNING) {
@@ -914,7 +915,7 @@ static void scan_intr(struct ehci_hcd *ehci)
 
 	list_for_each_entry_safe(qh, ehci-&gt;qh_scan_next, &amp;ehci-&gt;intr_qh_list,
 			intr_node) {
- rescan:
+
 		/* clean any finished work for this qh */
 		if (!list_empty(&amp;qh-&gt;qtd_list)) {
 			int temp;
@@ -927,12 +928,9 @@ static void scan_intr(struct ehci_hcd *ehci)
 			 * in qh_unlink_periodic().
 			 */
 			temp = qh_completions(ehci, qh);
-			if (unlikely(qh-&gt;needs_rescan ||
-					(list_empty(&amp;qh-&gt;qtd_list) &amp;&amp;
-						qh-&gt;qh_state == QH_STATE_LINKED)))
+			if (unlikely(temp || (list_empty(&amp;qh-&gt;qtd_list) &amp;&amp;
+					qh-&gt;qh_state == QH_STATE_LINKED)))
 				start_unlink_intr(ehci, qh);
-			else if (temp != 0)
-				goto rescan;
 		}
 	}
 }</pre><hr><pre>commit c1fdb68e3d73741630ca16695cf9176c233be7ed
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Mar 22 13:30:43 2013 -0400

    USB: EHCI: changes related to qh_refresh()
    
    This patch (as1638) makes several changes to the ehci-hcd driver, all
    related to the qh_refresh() function.  This function must be called
    whenever an idle QH gets linked back into either the async or the
    periodic schedule.
    
            Change a BUG_ON() in the qh_update routine to a WARN_ON().
            Since this code runs in atomic context, a BUG_ON() would
            immediately freeze the whole system.
    
            Remove two unneeded calls to qh_refresh(), one when a QH is
            initialized and one when a QH becomes idle.  Adjust the
            adjacent comments accordingly.
    
            Move the qh_refresh() and qh_link_periodic() calls for new
            interrupt URBs to after the new TDs have been added.
    
            As a result of the previous two changes, qh_refresh() is never
            called when the qtd_list is empty.  The corresponding check in
            qh_refresh() can be removed, along with an indentation level.
    
    These changes should not cause any alteration of behavior.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 23d136904285..b824cb674898 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -90,7 +90,7 @@ qh_update (struct ehci_hcd *ehci, struct ehci_qh *qh, struct ehci_qtd *qtd)
 	struct ehci_qh_hw *hw = qh-&gt;hw;
 
 	/* writes to an active overlay are unsafe */
-	BUG_ON(qh-&gt;qh_state != QH_STATE_IDLE);
+	WARN_ON(qh-&gt;qh_state != QH_STATE_IDLE);
 
 	hw-&gt;hw_qtd_next = QTD_NEXT(ehci, qtd-&gt;qtd_dma);
 	hw-&gt;hw_alt_next = EHCI_LIST_END(ehci);
@@ -123,26 +123,19 @@ qh_refresh (struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
 	struct ehci_qtd *qtd;
 
-	if (list_empty (&amp;qh-&gt;qtd_list))
-		qtd = qh-&gt;dummy;
-	else {
-		qtd = list_entry (qh-&gt;qtd_list.next,
-				struct ehci_qtd, qtd_list);
-		/*
-		 * first qtd may already be partially processed.
-		 * If we come here during unlink, the QH overlay region
-		 * might have reference to the just unlinked qtd. The
-		 * qtd is updated in qh_completions(). Update the QH
-		 * overlay here.
-		 */
-		if (qh-&gt;hw-&gt;hw_token &amp; ACTIVE_BIT(ehci)) {
-			qh-&gt;hw-&gt;hw_qtd_next = qtd-&gt;hw_next;
-			qtd = NULL;
-		}
-	}
+	qtd = list_entry(qh-&gt;qtd_list.next, struct ehci_qtd, qtd_list);
 
-	if (qtd)
-		qh_update (ehci, qh, qtd);
+	/*
+	 * first qtd may already be partially processed.
+	 * If we come here during unlink, the QH overlay region
+	 * might have reference to the just unlinked qtd. The
+	 * qtd is updated in qh_completions(). Update the QH
+	 * overlay here.
+	 */
+	if (qh-&gt;hw-&gt;hw_token &amp; ACTIVE_BIT(ehci))
+		qh-&gt;hw-&gt;hw_qtd_next = qtd-&gt;hw_next;
+	else
+		qh_update(ehci, qh, qtd);
 }
 
 /*-------------------------------------------------------------------------*/
@@ -553,12 +546,9 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	 * overlaying the dummy qtd (which reduces DMA chatter).
 	 */
 	if (stopped != 0 || hw-&gt;hw_qtd_next == EHCI_LIST_END(ehci)) {
-		switch (state) {
-		case QH_STATE_IDLE:
-			qh_refresh(ehci, qh);
-			break;
-		case QH_STATE_LINKED:
-			/* We won't refresh a QH that's linked (after the HC
+		if (state == QH_STATE_LINKED) {
+			/*
+			 * We won't refresh a QH that's linked (after the HC
 			 * stopped the queue).  That avoids a race:
 			 *  - HC reads first part of QH;
 			 *  - CPU updates that first part and the token;
@@ -568,13 +558,12 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 			 *
 			 * That should be rare for interrupt transfers,
 			 * except maybe high bandwidth ...
+			 *
+			 * Therefore tell the caller to start an unlink.
 			 */
-
-			/* Tell the caller to start an unlink */
 			qh-&gt;needs_rescan = 1;
-			break;
-		/* otherwise, unlink already started */
 		}
+		/* otherwise, unlink already started */
 	}
 
 	return count;
@@ -957,14 +946,13 @@ qh_make (
 
 	/* NOTE:  if (PIPE_INTERRUPT) { scheduler sets s-mask } */
 
-	/* init as live, toggle clear, advance to dummy */
+	/* init as live, toggle clear */
 	qh-&gt;qh_state = QH_STATE_IDLE;
 	hw = qh-&gt;hw;
 	hw-&gt;hw_info1 = cpu_to_hc32(ehci, info1);
 	hw-&gt;hw_info2 = cpu_to_hc32(ehci, info2);
 	qh-&gt;is_out = !is_input;
 	usb_settoggle (urb-&gt;dev, usb_pipeendpoint (urb-&gt;pipe), !is_input, 1);
-	qh_refresh (ehci, qh);
 	return qh;
 }
 
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index b476daf49f6f..66259dc7822e 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -792,7 +792,6 @@ static int qh_schedule(struct ehci_hcd *ehci, struct ehci_qh *qh)
 	unsigned	frame;		/* 0..(qh-&gt;period - 1), or NO_FRAME */
 	struct ehci_qh_hw	*hw = qh-&gt;hw;
 
-	qh_refresh(ehci, qh);
 	hw-&gt;hw_next = EHCI_LIST_END(ehci);
 	frame = qh-&gt;start;
 
@@ -844,8 +843,6 @@ static int qh_schedule(struct ehci_hcd *ehci, struct ehci_qh *qh)
 	} else
 		ehci_dbg (ehci, "reused qh %p schedule\n", qh);
 
-	/* stuff into the periodic schedule */
-	qh_link_periodic(ehci, qh);
 done:
 	return status;
 }
@@ -891,6 +888,12 @@ static int intr_submit (
 	qh = qh_append_tds(ehci, urb, qtd_list, epnum, &amp;urb-&gt;ep-&gt;hcpriv);
 	BUG_ON (qh == NULL);
 
+	/* stuff into the periodic schedule */
+	if (qh-&gt;qh_state == QH_STATE_IDLE) {
+		qh_refresh(ehci, qh);
+		qh_link_periodic(ehci, qh);
+	}
+
 	/* ... update usbfs periodic stats */
 	ehci_to_hcd(ehci)-&gt;self.bandwidth_int_reqs++;
 </pre><hr><pre>commit 417c765af914106f5e76c4e0181dd555fe6a89a0
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Mar 21 12:48:42 2013 -0400

    USB: EHCI: fix up incorrect merge resolution
    
    This patch (as1671) fixes up an incorrect resolution of a merge
    conflict between Greg KH's usb-linus branch and his usb-next branch.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index dca8fc42b8d7..e7363332887e 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -297,6 +297,15 @@ static void ehci_iaa_watchdog(struct ehci_hcd *ehci)
 {
 	u32 cmd, status;
 
+	/*
+	 * Lost IAA irqs wedge things badly; seen first with a vt8235.
+	 * So we need this watchdog, but must protect it against both
+	 * (a) SMP races against real IAA firing and retriggering, and
+	 * (b) clean HC shutdown, when IAA watchdog was pending.
+	 */
+	if (ehci-&gt;rh_state != EHCI_RH_RUNNING)
+		return;
+
 	/* If we get here, IAA is *REALLY* late.  It's barely
 	 * conceivable that the system is so busy that CMD_IAAD
 	 * is still legitimately set, so let's be sure it's</pre>
    <div class="pagination">
        <a href='2_36.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><span>[37]</span><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_38.html'>Next&gt;&gt;</a>
    <div>
</body>
