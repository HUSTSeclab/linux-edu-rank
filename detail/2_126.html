<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_125.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><span>[126]</span><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_127.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 84afddd7ac58adad00cb0e50d0af25fcf825668b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 12 11:35:45 2006 -0400

    [PATCH] UHCI: Reimplement FSBR
    
    This patch (as683) re-implements Full-Speed Bandwidth Reclamation (FSBR)
    properly.  It keeps track of which endpoint queues have advanced, and
    when none have advanced for a sufficiently long time, FSBR is turned
    off.  The next TD on each of the non-moving queues is modified to
    generate an interrupt on completion, so that FSBR can be re-enabled as
    soon as the hardware starts to make some progress.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-debug.c b/drivers/usb/host/uhci-debug.c
index 6bbd33db9358..081c592fe8b1 100644
--- a/drivers/usb/host/uhci-debug.c
+++ b/drivers/usb/host/uhci-debug.c
@@ -274,7 +274,8 @@ static int uhci_show_root_hub_state(struct uhci_hcd *uhci, char *buf, int len)
 	    default:
 		rh_state = "?";			break;
 	}
-	out += sprintf(out, "Root-hub state: %s\n", rh_state);
+	out += sprintf(out, "Root-hub state: %s   FSBR: %d\n",
+			rh_state, uhci-&gt;fsbr_is_on);
 	return out - buf;
 }
 
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index fb4c1a8cadf4..395402eec5ef 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -88,15 +88,6 @@ static void suspend_rh(struct uhci_hcd *uhci, enum uhci_rh_state new_state);
 static void wakeup_rh(struct uhci_hcd *uhci);
 static void uhci_get_current_frame_number(struct uhci_hcd *uhci);
 
-/* If a transfer is still active after this much time, turn off FSBR */
-#define IDLE_TIMEOUT	msecs_to_jiffies(50)
-#define FSBR_DELAY	msecs_to_jiffies(50)
-
-/* When we timeout an idle transfer for FSBR, we'll switch it over to */
-/* depth first traversal. We'll do it in groups of this number of TDs */
-/* to make sure it doesn't hog all of the bandwidth */
-#define DEPTH_INTERVAL 5
-
 #include "uhci-debug.c"
 #include "uhci-q.c"
 #include "uhci-hub.c"
@@ -255,6 +246,7 @@ __acquires(uhci-&gt;lock)
 	uhci_to_hcd(uhci)-&gt;poll_rh = !int_enable;
 
 	uhci_scan_schedule(uhci, NULL);
+	uhci_fsbr_off(uhci);
 }
 
 static void start_rh(struct uhci_hcd *uhci)
@@ -487,9 +479,6 @@ static int uhci_start(struct usb_hcd *hcd)
 
 	hcd-&gt;uses_new_polling = 1;
 
-	uhci-&gt;fsbr = 0;
-	uhci-&gt;fsbrtimeout = 0;
-
 	spin_lock_init(&amp;uhci-&gt;lock);
 
 	INIT_LIST_HEAD(&amp;uhci-&gt;idle_qh_list);
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index 90ef7fbbf2fb..04938e64799f 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -84,6 +84,13 @@
 #define CAN_SCHEDULE_FRAMES	1000	/* how far in the future frames
 					 * can be scheduled */
 
+/* When no queues need Full-Speed Bandwidth Reclamation,
+ * delay this long before turning FSBR off */
+#define FSBR_OFF_DELAY		msecs_to_jiffies(400)
+
+/* If a queue hasn't advanced after this much time, assume it is stuck */
+#define QH_WAIT_TIMEOUT		msecs_to_jiffies(200)
+
 
 /*
  *	Queue Headers
@@ -131,6 +138,7 @@ struct uhci_qh {
 	struct uhci_td *dummy_td;	/* Dummy TD to end the queue */
 	struct uhci_td *post_td;	/* Last TD completed */
 
+	unsigned long advance_jiffies;	/* Time of last queue advance */
 	unsigned int unlink_frame;	/* When the QH was unlinked */
 	int state;			/* QH_STATE_xxx; see above */
 	int type;			/* Queue type (control, bulk, etc) */
@@ -138,6 +146,7 @@ struct uhci_qh {
 	unsigned int initial_toggle:1;	/* Endpoint's current toggle value */
 	unsigned int needs_fixup:1;	/* Must fix the TD toggle values */
 	unsigned int is_stopped:1;	/* Queue was stopped by error/unlink */
+	unsigned int wait_expired:1;	/* QH_WAIT_TIMEOUT has expired */
 } __attribute__((aligned(16)));
 
 /*
@@ -397,8 +406,7 @@ struct uhci_hcd {
 	__le32 *frame;
 	void **frame_cpu;		/* CPU's frame list */
 
-	int fsbr;			/* Full-speed bandwidth reclamation */
-	unsigned long fsbrtimeout;	/* FSBR delay */
+	unsigned long fsbr_jiffies;	/* Time when FSBR was last wanted */
 
 	enum uhci_rh_state rh_state;
 	unsigned long auto_stop_time;		/* When to AUTO_STOP */
@@ -413,6 +421,7 @@ struct uhci_hcd {
 	unsigned int working_RD:1;		/* Suspended root hub doesn't
 						   need to be polled */
 	unsigned int is_initialized:1;		/* Data structure is usable */
+	unsigned int fsbr_is_on:1;		/* FSBR is turned on */
 
 	/* Support for port suspend/resume/reset */
 	unsigned long port_c_suspend;		/* Bit-arrays of ports */
@@ -451,7 +460,7 @@ struct urb_priv {
 	struct uhci_qh *qh;		/* QH for this URB */
 	struct list_head td_list;
 
-	unsigned fsbr : 1;		/* URB turned on FSBR */
+	unsigned fsbr:1;		/* URB wants FSBR */
 };
 
 
diff --git a/drivers/usb/host/uhci-hub.c b/drivers/usb/host/uhci-hub.c
index c8451d9578f1..f53c116e0dfd 100644
--- a/drivers/usb/host/uhci-hub.c
+++ b/drivers/usb/host/uhci-hub.c
@@ -173,7 +173,6 @@ static int uhci_hub_status_data(struct usb_hcd *hcd, char *buf)
 	uhci_scan_schedule(uhci, NULL);
 	if (uhci-&gt;hc_inaccessible)
 		goto done;
-	check_fsbr(uhci);
 	uhci_check_ports(uhci);
 
 	status = get_hub_status_data(uhci, buf);
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 12af6fb05a30..2be84b3b40fe 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -37,6 +37,46 @@ static inline void uhci_clear_next_interrupt(struct uhci_hcd *uhci)
 	uhci-&gt;term_td-&gt;status &amp;= ~cpu_to_le32(TD_CTRL_IOC);
 }
 
+
+/*
+ * Full-Speed Bandwidth Reclamation (FSBR).
+ * We turn on FSBR whenever a queue that wants it is advancing,
+ * and leave it on for a short time thereafter.
+ */
+static void uhci_fsbr_on(struct uhci_hcd *uhci)
+{
+	uhci-&gt;fsbr_is_on = 1;
+	uhci-&gt;skel_term_qh-&gt;link = cpu_to_le32(
+			uhci-&gt;skel_fs_control_qh-&gt;dma_handle) | UHCI_PTR_QH;
+}
+
+static void uhci_fsbr_off(struct uhci_hcd *uhci)
+{
+	uhci-&gt;fsbr_is_on = 0;
+	uhci-&gt;skel_term_qh-&gt;link = UHCI_PTR_TERM;
+}
+
+static void uhci_add_fsbr(struct uhci_hcd *uhci, struct urb *urb)
+{
+	struct urb_priv *urbp = urb-&gt;hcpriv;
+
+	if (!(urb-&gt;transfer_flags &amp; URB_NO_FSBR))
+		urbp-&gt;fsbr = 1;
+}
+
+static void uhci_qh_wants_fsbr(struct uhci_hcd *uhci, struct uhci_qh *qh)
+{
+	struct urb_priv *urbp =
+			list_entry(qh-&gt;queue.next, struct urb_priv, node);
+
+	if (urbp-&gt;fsbr) {
+		uhci-&gt;fsbr_jiffies = jiffies;
+		if (!uhci-&gt;fsbr_is_on)
+			uhci_fsbr_on(uhci);
+	}
+}
+
+
 static struct uhci_td *uhci_alloc_td(struct uhci_hcd *uhci)
 {
 	dma_addr_t dma_handle;
@@ -331,6 +371,10 @@ static void uhci_activate_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
 		qh-&gt;element = cpu_to_le32(td-&gt;dma_handle);
 	}
 
+	/* Treat the queue as if it has just advanced */
+	qh-&gt;wait_expired = 0;
+	qh-&gt;advance_jiffies = jiffies;
+
 	if (qh-&gt;state == QH_STATE_ACTIVE)
 		return;
 	qh-&gt;state = QH_STATE_ACTIVE;
@@ -445,28 +489,6 @@ static void uhci_free_urb_priv(struct uhci_hcd *uhci,
 	kmem_cache_free(uhci_up_cachep, urbp);
 }
 
-static void uhci_inc_fsbr(struct uhci_hcd *uhci, struct urb *urb)
-{
-	struct urb_priv *urbp = (struct urb_priv *)urb-&gt;hcpriv;
-
-	if ((!(urb-&gt;transfer_flags &amp; URB_NO_FSBR)) &amp;&amp; !urbp-&gt;fsbr) {
-		urbp-&gt;fsbr = 1;
-		if (!uhci-&gt;fsbr++ &amp;&amp; !uhci-&gt;fsbrtimeout)
-			uhci-&gt;skel_term_qh-&gt;link = cpu_to_le32(uhci-&gt;skel_fs_control_qh-&gt;dma_handle) | UHCI_PTR_QH;
-	}
-}
-
-static void uhci_dec_fsbr(struct uhci_hcd *uhci, struct urb *urb)
-{
-	struct urb_priv *urbp = (struct urb_priv *)urb-&gt;hcpriv;
-
-	if ((!(urb-&gt;transfer_flags &amp; URB_NO_FSBR)) &amp;&amp; urbp-&gt;fsbr) {
-		urbp-&gt;fsbr = 0;
-		if (!--uhci-&gt;fsbr)
-			uhci-&gt;fsbrtimeout = jiffies + FSBR_DELAY;
-	}
-}
-
 /*
  * Map status to standard result codes
  *
@@ -613,7 +635,7 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb,
 		qh-&gt;skel = uhci-&gt;skel_ls_control_qh;
 	else {
 		qh-&gt;skel = uhci-&gt;skel_fs_control_qh;
-		uhci_inc_fsbr(uhci, urb);
+		uhci_add_fsbr(uhci, urb);
 	}
 
 	urb-&gt;actual_length = -8;	/* Account for the SETUP packet */
@@ -756,7 +778,7 @@ static inline int uhci_submit_bulk(struct uhci_hcd *uhci, struct urb *urb,
 	qh-&gt;skel = uhci-&gt;skel_bulk_qh;
 	ret = uhci_submit_common(uhci, urb, qh);
 	if (ret == 0)
-		uhci_inc_fsbr(uhci, urb);
+		uhci_add_fsbr(uhci, urb);
 	return ret;
 }
 
@@ -1075,8 +1097,10 @@ static int uhci_urb_enqueue(struct usb_hcd *hcd,
 	 * the QH is new and idle or else it's unlinked and waiting to
 	 * become idle, so we can activate it right away.  But only if the
 	 * queue isn't stopped. */
-	if (qh-&gt;queue.next == &amp;urbp-&gt;node &amp;&amp; !qh-&gt;is_stopped)
+	if (qh-&gt;queue.next == &amp;urbp-&gt;node &amp;&amp; !qh-&gt;is_stopped) {
 		uhci_activate_qh(uhci, qh);
+		uhci_qh_wants_fsbr(uhci, qh);
+	}
 	goto done;
 
 err_submit_failed:
@@ -1135,7 +1159,6 @@ __acquires(uhci-&gt;lock)
 		qh-&gt;needs_fixup = 0;
 	}
 
-	uhci_dec_fsbr(uhci, urb);	/* Safe since it checks */
 	uhci_free_urb_priv(uhci, urbp);
 
 	switch (qh-&gt;type) {
@@ -1239,6 +1262,18 @@ static void uhci_scan_qh(struct uhci_hcd *uhci, struct uhci_qh *qh,
 	if (!list_empty(&amp;qh-&gt;queue)) {
 		if (qh-&gt;needs_fixup)
 			uhci_fixup_toggles(qh, 0);
+
+		/* If the first URB on the queue wants FSBR but its time
+		 * limit has expired, set the next TD to interrupt on
+		 * completion before reactivating the QH. */
+		urbp = list_entry(qh-&gt;queue.next, struct urb_priv, node);
+		if (urbp-&gt;fsbr &amp;&amp; qh-&gt;wait_expired) {
+			struct uhci_td *td = list_entry(urbp-&gt;td_list.next,
+					struct uhci_td, list);
+
+			td-&gt;status |= __cpu_to_le32(TD_CTRL_IOC);
+		}
+
 		uhci_activate_qh(uhci, qh);
 	}
 
@@ -1248,6 +1283,62 @@ static void uhci_scan_qh(struct uhci_hcd *uhci, struct uhci_qh *qh,
 		uhci_make_qh_idle(uhci, qh);
 }
 
+/*
+ * Check for queues that have made some forward progress.
+ * Returns 0 if the queue is not Isochronous, is ACTIVE, and
+ * has not advanced since last examined; 1 otherwise.
+ */
+static int uhci_advance_check(struct uhci_hcd *uhci, struct uhci_qh *qh)
+{
+	struct urb_priv *urbp = NULL;
+	struct uhci_td *td;
+	int ret = 1;
+	unsigned status;
+
+	if (qh-&gt;type == USB_ENDPOINT_XFER_ISOC)
+		return ret;
+
+	/* Treat an UNLINKING queue as though it hasn't advanced.
+	 * This is okay because reactivation will treat it as though
+	 * it has advanced, and if it is going to become IDLE then
+	 * this doesn't matter anyway.  Furthermore it's possible
+	 * for an UNLINKING queue not to have any URBs at all, or
+	 * for its first URB not to have any TDs (if it was dequeued
+	 * just as it completed).  So it's not easy in any case to
+	 * test whether such queues have advanced. */
+	if (qh-&gt;state != QH_STATE_ACTIVE) {
+		urbp = NULL;
+		status = 0;
+
+	} else {
+		urbp = list_entry(qh-&gt;queue.next, struct urb_priv, node);
+		td = list_entry(urbp-&gt;td_list.next, struct uhci_td, list);
+		status = td_status(td);
+		if (!(status &amp; TD_CTRL_ACTIVE)) {
+
+			/* We're okay, the queue has advanced */
+			qh-&gt;wait_expired = 0;
+			qh-&gt;advance_jiffies = jiffies;
+			return ret;
+		}
+		ret = 0;
+	}
+
+	/* The queue hasn't advanced; check for timeout */
+	if (!qh-&gt;wait_expired &amp;&amp; time_after(jiffies,
+			qh-&gt;advance_jiffies + QH_WAIT_TIMEOUT)) {
+		qh-&gt;wait_expired = 1;
+
+		/* If the current URB wants FSBR, unlink it temporarily
+		 * so that we can safely set the next TD to interrupt on
+		 * completion.  That way we'll know as soon as the queue
+		 * starts moving again. */
+		if (urbp &amp;&amp; urbp-&gt;fsbr &amp;&amp; !(status &amp; TD_CTRL_IOC))
+			uhci_unlink_qh(uhci, qh);
+	}
+	return ret;
+}
+
 /*
  * Process events in the schedule, but only in one thread at a time
  */
@@ -1262,7 +1353,7 @@ static void uhci_scan_schedule(struct uhci_hcd *uhci, struct pt_regs *regs)
 		return;
 	}
 	uhci-&gt;scan_in_progress = 1;
- rescan:
+rescan:
 	uhci-&gt;need_rescan = 0;
 
 	uhci_clear_next_interrupt(uhci);
@@ -1275,7 +1366,12 @@ static void uhci_scan_schedule(struct uhci_hcd *uhci, struct pt_regs *regs)
 		while ((qh = uhci-&gt;next_qh) != uhci-&gt;skelqh[i]) {
 			uhci-&gt;next_qh = list_entry(qh-&gt;node.next,
 					struct uhci_qh, node);
-			uhci_scan_qh(uhci, qh, regs);
+
+			if (uhci_advance_check(uhci, qh)) {
+				uhci_scan_qh(uhci, qh, regs);
+				if (qh-&gt;state == QH_STATE_ACTIVE)
+					uhci_qh_wants_fsbr(uhci, qh);
+			}
 		}
 	}
 
@@ -1283,20 +1379,12 @@ static void uhci_scan_schedule(struct uhci_hcd *uhci, struct pt_regs *regs)
 		goto rescan;
 	uhci-&gt;scan_in_progress = 0;
 
+	if (uhci-&gt;fsbr_is_on &amp;&amp; time_after(jiffies,
+			uhci-&gt;fsbr_jiffies + FSBR_OFF_DELAY))
+		uhci_fsbr_off(uhci);
+
 	if (list_empty(&amp;uhci-&gt;skel_unlink_qh-&gt;node))
 		uhci_clear_next_interrupt(uhci);
 	else
 		uhci_set_next_interrupt(uhci);
 }
-
-static void check_fsbr(struct uhci_hcd *uhci)
-{
-	/* For now, don't scan URBs for FSBR timeouts.
-	 * Add it back in later... */
-
-	/* Really disable FSBR */
-	if (!uhci-&gt;fsbr &amp;&amp; uhci-&gt;fsbrtimeout &amp;&amp; time_after_eq(jiffies, uhci-&gt;fsbrtimeout)) {
-		uhci-&gt;fsbrtimeout = 0;
-		uhci-&gt;skel_term_qh-&gt;link = UHCI_PTR_TERM;
-	}
-}</pre><hr><pre>commit 04538a255ac8b404c20cbf15867c9829254c470f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 12 11:29:04 2006 -0400

    [PATCH] UHCI: Eliminate the TD-removal list
    
    This patch (as682) gets rid of the TD-removal list in uhci-hcd.  It is
    no longer needed because now TDs are not freed until we know the
    hardware isn't using them.  It also simplifies the code for adding and
    removing TDs to/from URBs.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index d225e11f4055..fb4c1a8cadf4 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -492,7 +492,6 @@ static int uhci_start(struct usb_hcd *hcd)
 
 	spin_lock_init(&amp;uhci-&gt;lock);
 
-	INIT_LIST_HEAD(&amp;uhci-&gt;td_remove_list);
 	INIT_LIST_HEAD(&amp;uhci-&gt;idle_qh_list);
 
 	init_waitqueue_head(&amp;uhci-&gt;waitqh);
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index 3093ca250942..90ef7fbbf2fb 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -228,7 +228,6 @@ struct uhci_td {
 	dma_addr_t dma_handle;
 
 	struct list_head list;
-	struct list_head remove_list;
 
 	int frame;			/* for iso: what frame? */
 	struct list_head fl_list;
@@ -420,10 +419,6 @@ struct uhci_hcd {
 	unsigned long resuming_ports;
 	unsigned long ports_timeout;		/* Time to stop signalling */
 
-	/* List of TDs that are done, but waiting to be freed (race) */
-	struct list_head td_remove_list;
-	unsigned int td_remove_age;		/* Age in frames */
-
 	struct list_head idle_qh_list;		/* Where the idle QHs live */
 
 	int rh_numports;			/* Number of root-hub ports */
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 64b6c74789fd..12af6fb05a30 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -16,7 +16,6 @@
  * (C) Copyright 2004-2005 Alan Stern, stern@rowland.harvard.edu
  */
 
-static void uhci_free_pending_tds(struct uhci_hcd *uhci);
 
 /*
  * Technically, updating td-&gt;status here is a race, but it's not really a
@@ -51,7 +50,6 @@ static struct uhci_td *uhci_alloc_td(struct uhci_hcd *uhci)
 	td-&gt;frame = -1;
 
 	INIT_LIST_HEAD(&amp;td-&gt;list);
-	INIT_LIST_HEAD(&amp;td-&gt;remove_list);
 	INIT_LIST_HEAD(&amp;td-&gt;fl_list);
 
 	return td;
@@ -61,8 +59,6 @@ static void uhci_free_td(struct uhci_hcd *uhci, struct uhci_td *td)
 {
 	if (!list_empty(&amp;td-&gt;list))
 		dev_warn(uhci_dev(uhci), "td %p still in list!\n", td);
-	if (!list_empty(&amp;td-&gt;remove_list))
-		dev_warn(uhci_dev(uhci), "td %p still in remove_list!\n", td);
 	if (!list_empty(&amp;td-&gt;fl_list))
 		dev_warn(uhci_dev(uhci), "td %p still in fl_list!\n", td);
 
@@ -77,6 +73,16 @@ static inline void uhci_fill_td(struct uhci_td *td, u32 status,
 	td-&gt;buffer = cpu_to_le32(buffer);
 }
 
+static void uhci_add_td_to_urbp(struct uhci_td *td, struct urb_priv *urbp)
+{
+	list_add_tail(&amp;td-&gt;list, &amp;urbp-&gt;td_list);
+}
+
+static void uhci_remove_td_from_urbp(struct uhci_td *td)
+{
+	list_del_init(&amp;td-&gt;list);
+}
+
 /*
  * We insert Isochronous URBs directly into the frame list at the beginning
  */
@@ -421,21 +427,6 @@ static inline struct urb_priv *uhci_alloc_urb_priv(struct uhci_hcd *uhci,
 	return urbp;
 }
 
-static void uhci_add_td_to_urb(struct urb *urb, struct uhci_td *td)
-{
-	struct urb_priv *urbp = (struct urb_priv *)urb-&gt;hcpriv;
-
-	list_add_tail(&amp;td-&gt;list, &amp;urbp-&gt;td_list);
-}
-
-static void uhci_remove_td_from_urb(struct uhci_td *td)
-{
-	if (list_empty(&amp;td-&gt;list))
-		return;
-
-	list_del_init(&amp;td-&gt;list);
-}
-
 static void uhci_free_urb_priv(struct uhci_hcd *uhci,
 		struct urb_priv *urbp)
 {
@@ -445,20 +436,9 @@ static void uhci_free_urb_priv(struct uhci_hcd *uhci,
 		dev_warn(uhci_dev(uhci), "urb %p still on QH's list!\n",
 				urbp-&gt;urb);
 
-	uhci_get_current_frame_number(uhci);
-	if (uhci-&gt;frame_number + uhci-&gt;is_stopped != uhci-&gt;td_remove_age) {
-		uhci_free_pending_tds(uhci);
-		uhci-&gt;td_remove_age = uhci-&gt;frame_number;
-	}
-
-	/* Check to see if the remove list is empty. Set the IOC bit */
-	/* to force an interrupt so we can remove the TDs. */
-	if (list_empty(&amp;uhci-&gt;td_remove_list))
-		uhci_set_next_interrupt(uhci);
-
 	list_for_each_entry_safe(td, tmp, &amp;urbp-&gt;td_list, list) {
-		uhci_remove_td_from_urb(td);
-		list_add(&amp;td-&gt;remove_list, &amp;uhci-&gt;td_remove_list);
+		uhci_remove_td_from_urbp(td);
+		uhci_free_td(uhci, td);
 	}
 
 	urbp-&gt;urb-&gt;hcpriv = NULL;
@@ -529,6 +509,7 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb,
 	int len = urb-&gt;transfer_buffer_length;
 	dma_addr_t data = urb-&gt;transfer_dma;
 	__le32 *plink;
+	struct urb_priv *urbp = urb-&gt;hcpriv;
 
 	/* The "pipe" thing contains the destination in bits 8--18 */
 	destination = (urb-&gt;pipe &amp; PIPE_DEVEP_MASK) | USB_PID_SETUP;
@@ -542,7 +523,7 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb,
 	 * Build the TD for the control request setup packet
 	 */
 	td = qh-&gt;dummy_td;
-	uhci_add_td_to_urb(urb, td);
+	uhci_add_td_to_urbp(td, urbp);
 	uhci_fill_td(td, status, destination | uhci_explen(8),
 			urb-&gt;setup_dma);
 	plink = &amp;td-&gt;link;
@@ -574,7 +555,7 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb,
 		/* Alternate Data0/1 (start with Data1) */
 		destination ^= TD_TOKEN_TOGGLE;
 	
-		uhci_add_td_to_urb(urb, td);
+		uhci_add_td_to_urbp(td, urbp);
 		uhci_fill_td(td, status, destination | uhci_explen(pktsze),
 				data);
 		plink = &amp;td-&gt;link;
@@ -605,7 +586,7 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb,
 
 	status &amp;= ~TD_CTRL_SPD;
 
-	uhci_add_td_to_urb(urb, td);
+	uhci_add_td_to_urbp(td, urbp);
 	uhci_fill_td(td, status | TD_CTRL_IOC,
 			destination | uhci_explen(0), 0);
 	plink = &amp;td-&gt;link;
@@ -640,7 +621,7 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb,
 
 nomem:
 	/* Remove the dummy TD from the td_list so it doesn't get freed */
-	uhci_remove_td_from_urb(qh-&gt;dummy_td);
+	uhci_remove_td_from_urbp(qh-&gt;dummy_td);
 	return -ENOMEM;
 }
 
@@ -656,6 +637,7 @@ static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb,
 	int len = urb-&gt;transfer_buffer_length;
 	dma_addr_t data = urb-&gt;transfer_dma;
 	__le32 *plink;
+	struct urb_priv *urbp = urb-&gt;hcpriv;
 	unsigned int toggle;
 
 	if (len &lt; 0)
@@ -693,7 +675,7 @@ static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb,
 				goto nomem;
 			*plink = cpu_to_le32(td-&gt;dma_handle);
 		}
-		uhci_add_td_to_urb(urb, td);
+		uhci_add_td_to_urbp(td, urbp);
 		uhci_fill_td(td, status,
 				destination | uhci_explen(pktsze) |
 					(toggle &lt;&lt; TD_TOKEN_TOGGLE_SHIFT),
@@ -721,7 +703,7 @@ static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb,
 			goto nomem;
 		*plink = cpu_to_le32(td-&gt;dma_handle);
 
-		uhci_add_td_to_urb(urb, td);
+		uhci_add_td_to_urbp(td, urbp);
 		uhci_fill_td(td, status,
 				destination | uhci_explen(0) |
 					(toggle &lt;&lt; TD_TOKEN_TOGGLE_SHIFT),
@@ -758,7 +740,7 @@ static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb,
 
 nomem:
 	/* Remove the dummy TD from the td_list so it doesn't get freed */
-	uhci_remove_td_from_urb(qh-&gt;dummy_td);
+	uhci_remove_td_from_urbp(qh-&gt;dummy_td);
 	return -ENOMEM;
 }
 
@@ -830,8 +812,8 @@ static int uhci_fixup_short_transfer(struct uhci_hcd *uhci,
 		td = list_entry(tmp, struct uhci_td, list);
 		tmp = tmp-&gt;prev;
 
-		uhci_remove_td_from_urb(td);
-		list_add(&amp;td-&gt;remove_list, &amp;uhci-&gt;td_remove_list);
+		uhci_remove_td_from_urbp(td);
+		uhci_free_td(uhci, td);
 	}
 	return ret;
 }
@@ -885,10 +867,9 @@ static int uhci_result_common(struct uhci_hcd *uhci, struct urb *urb)
 				ret = 1;
 		}
 
-		uhci_remove_td_from_urb(td);
+		uhci_remove_td_from_urbp(td);
 		if (qh-&gt;post_td)
-			list_add(&amp;qh-&gt;post_td-&gt;remove_list,
-					&amp;uhci-&gt;td_remove_list);
+			uhci_free_td(uhci, qh-&gt;post_td);
 		qh-&gt;post_td = td;
 
 		if (ret != 0)
@@ -957,7 +938,7 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb,
 		if (!td)
 			return -ENOMEM;
 
-		uhci_add_td_to_urb(urb, td);
+		uhci_add_td_to_urbp(td, urbp);
 		uhci_fill_td(td, status, destination |
 				uhci_explen(urb-&gt;iso_frame_desc[i].length),
 				urb-&gt;transfer_dma +
@@ -1267,17 +1248,6 @@ static void uhci_scan_qh(struct uhci_hcd *uhci, struct uhci_qh *qh,
 		uhci_make_qh_idle(uhci, qh);
 }
 
-static void uhci_free_pending_tds(struct uhci_hcd *uhci)
-{
-	struct uhci_td *td, *tmp;
-
-	list_for_each_entry_safe(td, tmp, &amp;uhci-&gt;td_remove_list, remove_list) {
-		list_del_init(&amp;td-&gt;remove_list);
-
-		uhci_free_td(uhci, td);
-	}
-}
-
 /*
  * Process events in the schedule, but only in one thread at a time
  */
@@ -1298,9 +1268,6 @@ static void uhci_scan_schedule(struct uhci_hcd *uhci, struct pt_regs *regs)
 	uhci_clear_next_interrupt(uhci);
 	uhci_get_current_frame_number(uhci);
 
-	if (uhci-&gt;frame_number + uhci-&gt;is_stopped != uhci-&gt;td_remove_age)
-		uhci_free_pending_tds(uhci);
-
 	/* Go through all the QH queues and process the URBs in each one */
 	for (i = 0; i &lt; UHCI_NUM_SKELQH - 1; ++i) {
 		uhci-&gt;next_qh = list_entry(uhci-&gt;skelqh[i]-&gt;node.next,
@@ -1316,12 +1283,7 @@ static void uhci_scan_schedule(struct uhci_hcd *uhci, struct pt_regs *regs)
 		goto rescan;
 	uhci-&gt;scan_in_progress = 0;
 
-	/* If the controller is stopped, we can finish these off right now */
-	if (uhci-&gt;is_stopped)
-		uhci_free_pending_tds(uhci);
-
-	if (list_empty(&amp;uhci-&gt;td_remove_list) &amp;&amp;
-			list_empty(&amp;uhci-&gt;skel_unlink_qh-&gt;node))
+	if (list_empty(&amp;uhci-&gt;skel_unlink_qh-&gt;node))
 		uhci_clear_next_interrupt(uhci);
 	else
 		uhci_set_next_interrupt(uhci);</pre><hr><pre>commit a0b458b64b2a3a4cb806dd5cd889bbf6c7e9d686
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 12 11:23:19 2006 -0400

    [PATCH] UHCI: Move code for cleaning up unlinked URBs
    
    This patch (as681) moves some code for cleaning up after unlinked URBs
    out of the general completion pathway into the unlinking pathway.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 888938d78230..64b6c74789fd 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -204,25 +204,49 @@ static void uhci_free_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
 }
 
 /*
- * When the currently executing URB is dequeued, save its current toggle value
+ * When a queue is stopped and a dequeued URB is given back, adjust
+ * the previous TD link (if the URB isn't first on the queue) or
+ * save its toggle value (if it is first and is currently executing).
  */
-static void uhci_save_toggle(struct uhci_qh *qh, struct urb *urb)
+static void uhci_cleanup_queue(struct uhci_qh *qh,
+		struct urb *urb)
 {
-	struct urb_priv *urbp = (struct urb_priv *) urb-&gt;hcpriv;
+	struct urb_priv *urbp = urb-&gt;hcpriv;
 	struct uhci_td *td;
 
+	/* Isochronous pipes don't use toggles and their TD link pointers
+	 * get adjusted during uhci_urb_dequeue(). */
+	if (qh-&gt;type == USB_ENDPOINT_XFER_ISOC)
+		return;
+
+	/* If the URB isn't first on its queue, adjust the link pointer
+	 * of the last TD in the previous URB.  The toggle doesn't need
+	 * to be saved since this URB can't be executing yet. */
+	if (qh-&gt;queue.next != &amp;urbp-&gt;node) {
+		struct urb_priv *purbp;
+		struct uhci_td *ptd;
+
+		purbp = list_entry(urbp-&gt;node.prev, struct urb_priv, node);
+		WARN_ON(list_empty(&amp;purbp-&gt;td_list));
+		ptd = list_entry(purbp-&gt;td_list.prev, struct uhci_td,
+				list);
+		td = list_entry(urbp-&gt;td_list.prev, struct uhci_td,
+				list);
+		ptd-&gt;link = td-&gt;link;
+		return;
+	}
+
 	/* If the QH element pointer is UHCI_PTR_TERM then then currently
 	 * executing URB has already been unlinked, so this one isn't it. */
-	if (qh_element(qh) == UHCI_PTR_TERM ||
-				qh-&gt;queue.next != &amp;urbp-&gt;node)
+	if (qh_element(qh) == UHCI_PTR_TERM)
 		return;
 	qh-&gt;element = UHCI_PTR_TERM;
 
-	/* Only bulk and interrupt pipes have to worry about toggles */
-	if (!(qh-&gt;type == USB_ENDPOINT_XFER_BULK ||
-			qh-&gt;type == USB_ENDPOINT_XFER_INT))
+	/* Control pipes have to worry about toggles */
+	if (qh-&gt;type == USB_ENDPOINT_XFER_CONTROL)
 		return;
 
+	/* Save the next toggle value */
 	WARN_ON(list_empty(&amp;urbp-&gt;td_list));
 	td = list_entry(urbp-&gt;td_list.next, struct uhci_td, list);
 	qh-&gt;needs_fixup = 1;
@@ -1121,21 +1145,6 @@ __acquires(uhci-&gt;lock)
 	if (qh-&gt;type == USB_ENDPOINT_XFER_ISOC)
 		uhci_unlink_isochronous_tds(uhci, urb);
 
-	/* If the URB isn't first on its queue, adjust the link pointer
-	 * of the last TD in the previous URB. */
-	else if (qh-&gt;queue.next != &amp;urbp-&gt;node) {
-		struct urb_priv *purbp;
-		struct uhci_td *ptd, *ltd;
-
-		purbp = list_entry(urbp-&gt;node.prev, struct urb_priv, node);
-		WARN_ON(list_empty(&amp;purbp-&gt;td_list));
-		ptd = list_entry(purbp-&gt;td_list.prev, struct uhci_td,
-				list);
-		ltd = list_entry(urbp-&gt;td_list.prev, struct uhci_td,
-				list);
-		ptd-&gt;link = ltd-&gt;link;
-	}
-
 	/* Take the URB off the QH's queue.  If the queue is now empty,
 	 * this is a perfect time for a toggle fixup. */
 	list_del_init(&amp;urbp-&gt;node);
@@ -1237,7 +1246,7 @@ static void uhci_scan_qh(struct uhci_hcd *uhci, struct uhci_qh *qh,
 	list_for_each_entry(urbp, &amp;qh-&gt;queue, node) {
 		urb = urbp-&gt;urb;
 		if (urb-&gt;status != -EINPROGRESS) {
-			uhci_save_toggle(qh, urb);
+			uhci_cleanup_queue(qh, urb);
 			uhci_giveback_urb(uhci, qh, urb, regs);
 			goto restart;
 		}</pre><hr><pre>commit 59e29ed91cff90b27d393c7a3d3ac9c3fcaea7dd
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 12 11:19:19 2006 -0400

    [PATCH] UHCI: Remove non-iso TDs as they are used
    
    This patch (as680) frees non-isochronous TDs as they are used, rather
    than all at once when an URB is complete.  Although not a terribly
    important change in itself, it opens the door to a later enhancement
    that will reduce storage requirements by allocating only a limited
    number of TDs at any time for each endpoint queue.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-debug.c b/drivers/usb/host/uhci-debug.c
index 28c1c51ec475..6bbd33db9358 100644
--- a/drivers/usb/host/uhci-debug.c
+++ b/drivers/usb/host/uhci-debug.c
@@ -119,6 +119,7 @@ static int uhci_show_urbp(struct urb_priv *urbp, char *buf, int len, int space)
 	}
 
 	out += sprintf(out, "%s%s", ptype, (urbp-&gt;fsbr ? " FSBR" : ""));
+	out += sprintf(out, " Actlen=%d", urbp-&gt;urb-&gt;actual_length);
 
 	if (urbp-&gt;urb-&gt;status != -EINPROGRESS)
 		out += sprintf(out, " Status=%d", urbp-&gt;urb-&gt;status);
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index 8e5778650493..3093ca250942 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -129,6 +129,7 @@ struct uhci_qh {
 	struct list_head queue;		/* Queue of urbps for this QH */
 	struct uhci_qh *skel;		/* Skeleton for this QH */
 	struct uhci_td *dummy_td;	/* Dummy TD to end the queue */
+	struct uhci_td *post_td;	/* Last TD completed */
 
 	unsigned int unlink_frame;	/* When the QH was unlinked */
 	int state;			/* QH_STATE_xxx; see above */
@@ -136,7 +137,7 @@ struct uhci_qh {
 
 	unsigned int initial_toggle:1;	/* Endpoint's current toggle value */
 	unsigned int needs_fixup:1;	/* Must fix the TD toggle values */
-	unsigned int is_stopped:1;	/* Queue was stopped by an error */
+	unsigned int is_stopped:1;	/* Queue was stopped by error/unlink */
 } __attribute__((aligned(16)));
 
 /*
@@ -456,8 +457,6 @@ struct urb_priv {
 	struct list_head td_list;
 
 	unsigned fsbr : 1;		/* URB turned on FSBR */
-	unsigned short_transfer : 1;	/* URB got a short transfer, no
-					 * need to rescan */
 };
 
 
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 30e36031fe21..888938d78230 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -161,6 +161,7 @@ static struct uhci_qh *uhci_alloc_qh(struct uhci_hcd *uhci,
 	if (!qh)
 		return NULL;
 
+	memset(qh, 0, sizeof(*qh));
 	qh-&gt;dma_handle = dma_handle;
 
 	qh-&gt;element = UHCI_PTR_TERM;
@@ -183,7 +184,6 @@ static struct uhci_qh *uhci_alloc_qh(struct uhci_hcd *uhci,
 
 	} else {		/* Skeleton QH */
 		qh-&gt;state = QH_STATE_ACTIVE;
-		qh-&gt;udev = NULL;
 		qh-&gt;type = -1;
 	}
 	return qh;
@@ -223,16 +223,10 @@ static void uhci_save_toggle(struct uhci_qh *qh, struct urb *urb)
 			qh-&gt;type == USB_ENDPOINT_XFER_INT))
 		return;
 
-	/* Find the first active TD; that's the device's toggle state */
-	list_for_each_entry(td, &amp;urbp-&gt;td_list, list) {
-		if (td_status(td) &amp; TD_CTRL_ACTIVE) {
-			qh-&gt;needs_fixup = 1;
-			qh-&gt;initial_toggle = uhci_toggle(td_token(td));
-			return;
-		}
-	}
-
-	WARN_ON(1);
+	WARN_ON(list_empty(&amp;urbp-&gt;td_list));
+	td = list_entry(urbp-&gt;td_list.next, struct uhci_td, list);
+	qh-&gt;needs_fixup = 1;
+	qh-&gt;initial_toggle = uhci_toggle(td_token(td));
 }
 
 /*
@@ -372,6 +366,12 @@ static void uhci_make_qh_idle(struct uhci_hcd *uhci, struct uhci_qh *qh)
 	list_move(&amp;qh-&gt;node, &amp;uhci-&gt;idle_qh_list);
 	qh-&gt;state = QH_STATE_IDLE;
 
+	/* Now that the QH is idle, its post_td isn't being used */
+	if (qh-&gt;post_td) {
+		uhci_free_td(uhci, qh-&gt;post_td);
+		qh-&gt;post_td = NULL;
+	}
+
 	/* If anyone is waiting for a QH to become idle, wake them up */
 	if (uhci-&gt;num_waiting)
 		wake_up_all(&amp;uhci-&gt;waitqh);
@@ -610,6 +610,8 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb,
 		qh-&gt;skel = uhci-&gt;skel_fs_control_qh;
 		uhci_inc_fsbr(uhci, urb);
 	}
+
+	urb-&gt;actual_length = -8;	/* Account for the SETUP packet */
 	return 0;
 
 nomem:
@@ -767,34 +769,46 @@ static inline int uhci_submit_interrupt(struct uhci_hcd *uhci, struct urb *urb,
  * Fix up the data structures following a short transfer
  */
 static int uhci_fixup_short_transfer(struct uhci_hcd *uhci,
-		struct uhci_qh *qh, struct urb_priv *urbp,
-		struct uhci_td *short_td)
+		struct uhci_qh *qh, struct urb_priv *urbp)
 {
 	struct uhci_td *td;
-	int ret = 0;
+	struct list_head *tmp;
+	int ret;
 
 	td = list_entry(urbp-&gt;td_list.prev, struct uhci_td, list);
 	if (qh-&gt;type == USB_ENDPOINT_XFER_CONTROL) {
-		urbp-&gt;short_transfer = 1;
 
 		/* When a control transfer is short, we have to restart
 		 * the queue at the status stage transaction, which is
 		 * the last TD. */
+		WARN_ON(list_empty(&amp;urbp-&gt;td_list));
 		qh-&gt;element = cpu_to_le32(td-&gt;dma_handle);
+		tmp = td-&gt;list.prev;
 		ret = -EINPROGRESS;
 
-	} else if (!urbp-&gt;short_transfer) {
-		urbp-&gt;short_transfer = 1;
+	} else {
 
 		/* When a bulk/interrupt transfer is short, we have to
 		 * fix up the toggles of the following URBs on the queue
 		 * before restarting the queue at the next URB. */
-		qh-&gt;initial_toggle = uhci_toggle(td_token(short_td)) ^ 1;
+		qh-&gt;initial_toggle = uhci_toggle(td_token(qh-&gt;post_td)) ^ 1;
 		uhci_fixup_toggles(qh, 1);
 
+		if (list_empty(&amp;urbp-&gt;td_list))
+			td = qh-&gt;post_td;
 		qh-&gt;element = td-&gt;link;
+		tmp = urbp-&gt;td_list.prev;
+		ret = 0;
 	}
 
+	/* Remove all the TDs we skipped over, from tmp back to the start */
+	while (tmp != &amp;urbp-&gt;td_list) {
+		td = list_entry(tmp, struct uhci_td, list);
+		tmp = tmp-&gt;prev;
+
+		uhci_remove_td_from_urb(td);
+		list_add(&amp;td-&gt;remove_list, &amp;uhci-&gt;td_remove_list);
+	}
 	return ret;
 }
 
@@ -805,29 +819,14 @@ static int uhci_result_common(struct uhci_hcd *uhci, struct urb *urb)
 {
 	struct urb_priv *urbp = urb-&gt;hcpriv;
 	struct uhci_qh *qh = urbp-&gt;qh;
-	struct uhci_td *td;
-	struct list_head *tmp;
+	struct uhci_td *td, *tmp;
 	unsigned status;
 	int ret = 0;
 
-	tmp = urbp-&gt;td_list.next;
-
-	if (qh-&gt;type == USB_ENDPOINT_XFER_CONTROL) {
-		if (urbp-&gt;short_transfer)
-			tmp = urbp-&gt;td_list.prev;
-		else
-			urb-&gt;actual_length = -8;	/* SETUP packet */
-	} else
-		urb-&gt;actual_length = 0;
-
-
-	while (tmp != &amp;urbp-&gt;td_list) {
+	list_for_each_entry_safe(td, tmp, &amp;urbp-&gt;td_list, list) {
 		unsigned int ctrlstat;
 		int len;
 
-		td = list_entry(tmp, struct uhci_td, list);
-		tmp = tmp-&gt;next;
-
 		ctrlstat = td_status(td);
 		status = uhci_status_bits(ctrlstat);
 		if (status &amp; TD_CTRL_ACTIVE)
@@ -862,6 +861,12 @@ static int uhci_result_common(struct uhci_hcd *uhci, struct urb *urb)
 				ret = 1;
 		}
 
+		uhci_remove_td_from_urb(td);
+		if (qh-&gt;post_td)
+			list_add(&amp;qh-&gt;post_td-&gt;remove_list,
+					&amp;uhci-&gt;td_remove_list);
+		qh-&gt;post_td = td;
+
 		if (ret != 0)
 			goto err;
 	}
@@ -882,7 +887,7 @@ static int uhci_result_common(struct uhci_hcd *uhci, struct urb *urb)
 				(ret == -EREMOTEIO);
 
 	} else		/* Short packet received */
-		ret = uhci_fixup_short_transfer(uhci, qh, urbp, td);
+		ret = uhci_fixup_short_transfer(uhci, qh, urbp);
 	return ret;
 }
 
@@ -1123,6 +1128,7 @@ __acquires(uhci-&gt;lock)
 		struct uhci_td *ptd, *ltd;
 
 		purbp = list_entry(urbp-&gt;node.prev, struct urb_priv, node);
+		WARN_ON(list_empty(&amp;purbp-&gt;td_list));
 		ptd = list_entry(purbp-&gt;td_list.prev, struct uhci_td,
 				list);
 		ltd = list_entry(urbp-&gt;td_list.prev, struct uhci_td,</pre><hr><pre>commit b1869000a60b0c72022811f24110a52d3e300b1e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 12 11:14:25 2006 -0400

    [PATCH] UHCI: Common result routine for Control/Bulk/Interrupt
    
    This patch (as679) combines the result routine for Control URBs with the
    routine for Bulk/Interrupt URBs.  Along the way I eliminated the
    debugging printouts for Control transfers unless the debugging level is
    set higher than 1.  I also eliminated a long-unused (#ifdef'ed-out)
    section that works around some buggy old APC BackUPS devices.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 693e92c1bd9e..30e36031fe21 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -618,134 +618,6 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb,
 	return -ENOMEM;
 }
 
-/*
- * If control-IN transfer was short, the status packet wasn't sent.
- * This routine changes the element pointer in the QH to point at the
- * status TD.  It's safe to do this even while the QH is live, because
- * the hardware only updates the element pointer following a successful
- * transfer.  The inactive TD for the short packet won't cause an update,
- * so the pointer won't get overwritten.  The next time the controller
- * sees this QH, it will send the status packet.
- */
-static int usb_control_retrigger_status(struct uhci_hcd *uhci, struct urb *urb)
-{
-	struct urb_priv *urbp = (struct urb_priv *)urb-&gt;hcpriv;
-	struct uhci_td *td;
-
-	urbp-&gt;short_transfer = 1;
-
-	td = list_entry(urbp-&gt;td_list.prev, struct uhci_td, list);
-	urbp-&gt;qh-&gt;element = cpu_to_le32(td-&gt;dma_handle);
-
-	return -EINPROGRESS;
-}
-
-
-static int uhci_result_control(struct uhci_hcd *uhci, struct urb *urb)
-{
-	struct list_head *tmp, *head;
-	struct urb_priv *urbp = urb-&gt;hcpriv;
-	struct uhci_td *td;
-	unsigned int status;
-	int ret = 0;
-
-	head = &amp;urbp-&gt;td_list;
-	if (urbp-&gt;short_transfer) {
-		tmp = head-&gt;prev;
-		goto status_stage;
-	}
-
-	urb-&gt;actual_length = 0;
-
-	tmp = head-&gt;next;
-	td = list_entry(tmp, struct uhci_td, list);
-
-	/* The first TD is the SETUP stage, check the status, but skip */
-	/*  the count */
-	status = uhci_status_bits(td_status(td));
-	if (status &amp; TD_CTRL_ACTIVE)
-		return -EINPROGRESS;
-
-	if (status)
-		goto td_error;
-
-	/* The rest of the TDs (but the last) are data */
-	tmp = tmp-&gt;next;
-	while (tmp != head &amp;&amp; tmp-&gt;next != head) {
-		unsigned int ctrlstat;
-
-		td = list_entry(tmp, struct uhci_td, list);
-		tmp = tmp-&gt;next;
-
-		ctrlstat = td_status(td);
-		status = uhci_status_bits(ctrlstat);
-		if (status &amp; TD_CTRL_ACTIVE)
-			return -EINPROGRESS;
-
-		urb-&gt;actual_length += uhci_actual_length(ctrlstat);
-
-		if (status)
-			goto td_error;
-
-		/* Check to see if we received a short packet */
-		if (uhci_actual_length(ctrlstat) &lt;
-				uhci_expected_length(td_token(td))) {
-			if (urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK) {
-				ret = -EREMOTEIO;
-				goto err;
-			}
-
-			return usb_control_retrigger_status(uhci, urb);
-		}
-	}
-
-status_stage:
-	td = list_entry(tmp, struct uhci_td, list);
-
-	/* Control status stage */
-	status = td_status(td);
-
-#ifdef I_HAVE_BUGGY_APC_BACKUPS
-	/* APC BackUPS Pro kludge */
-	/* It tries to send all of the descriptor instead of the amount */
-	/*  we requested */
-	if (status &amp; TD_CTRL_IOC &amp;&amp;	/* IOC is masked out by uhci_status_bits */
-	    status &amp; TD_CTRL_ACTIVE &amp;&amp;
-	    status &amp; TD_CTRL_NAK)
-		return 0;
-#endif
-
-	status = uhci_status_bits(status);
-	if (status &amp; TD_CTRL_ACTIVE)
-		return -EINPROGRESS;
-
-	if (status)
-		goto td_error;
-
-	return 0;
-
-td_error:
-	ret = uhci_map_status(status, uhci_packetout(td_token(td)));
-
-err:
-	if ((debug == 1 &amp;&amp; ret != -EPIPE) || debug &gt; 1) {
-		/* Some debugging code */
-		dev_dbg(uhci_dev(uhci), "%s: failed with status %x\n",
-				__FUNCTION__, status);
-
-		if (errbuf) {
-			/* Print the chain for debugging purposes */
-			uhci_show_qh(urbp-&gt;qh, errbuf, ERRBUF_LEN, 0);
-			lprintk(errbuf);
-		}
-	}
-
-	/* Note that the queue has stopped */
-	urbp-&gt;qh-&gt;element = UHCI_PTR_TERM;
-	urbp-&gt;qh-&gt;is_stopped = 1;
-	return ret;
-}
-
 /*
  * Common submit for bulk and interrupt
  */
@@ -864,86 +736,6 @@ static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb,
 	return -ENOMEM;
 }
 
-/*
- * Common result for bulk and interrupt
- */
-static int uhci_result_common(struct uhci_hcd *uhci, struct urb *urb)
-{
-	struct urb_priv *urbp = urb-&gt;hcpriv;
-	struct uhci_td *td;
-	unsigned int status = 0;
-	int ret = 0;
-
-	urb-&gt;actual_length = 0;
-
-	list_for_each_entry(td, &amp;urbp-&gt;td_list, list) {
-		unsigned int ctrlstat = td_status(td);
-
-		status = uhci_status_bits(ctrlstat);
-		if (status &amp; TD_CTRL_ACTIVE)
-			return -EINPROGRESS;
-
-		urb-&gt;actual_length += uhci_actual_length(ctrlstat);
-
-		if (status)
-			goto td_error;
-
-		if (uhci_actual_length(ctrlstat) &lt;
-				uhci_expected_length(td_token(td))) {
-			if (urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK) {
-				ret = -EREMOTEIO;
-				goto err;
-			}
-
-			/*
-			 * This URB stopped short of its end.  We have to
-			 * fix up the toggles of the following URBs on the
-			 * queue and restart the queue.
-			 *
-			 * Do this only the first time we encounter the
-			 * short URB.
-			 */
-			if (!urbp-&gt;short_transfer) {
-				urbp-&gt;short_transfer = 1;
-				urbp-&gt;qh-&gt;initial_toggle =
-						uhci_toggle(td_token(td)) ^ 1;
-				uhci_fixup_toggles(urbp-&gt;qh, 1);
-
-				td = list_entry(urbp-&gt;td_list.prev,
-						struct uhci_td, list);
-				urbp-&gt;qh-&gt;element = td-&gt;link;
-			}
-			break;
-		}
-	}
-
-	return 0;
-
-td_error:
-	ret = uhci_map_status(status, uhci_packetout(td_token(td)));
-
-	if ((debug == 1 &amp;&amp; ret != -EPIPE) || debug &gt; 1) {
-		/* Some debugging code */
-		dev_dbg(uhci_dev(uhci), "%s: failed with status %x\n",
-				__FUNCTION__, status);
-
-		if (debug &gt; 1 &amp;&amp; errbuf) {
-			/* Print the chain for debugging purposes */
-			uhci_show_qh(urbp-&gt;qh, errbuf, ERRBUF_LEN, 0);
-			lprintk(errbuf);
-		}
-	}
-err:
-
-	/* Note that the queue has stopped and save the next toggle value */
-	urbp-&gt;qh-&gt;element = UHCI_PTR_TERM;
-	urbp-&gt;qh-&gt;is_stopped = 1;
-	urbp-&gt;qh-&gt;needs_fixup = 1;
-	urbp-&gt;qh-&gt;initial_toggle = uhci_toggle(td_token(td)) ^
-			(ret == -EREMOTEIO);
-	return ret;
-}
-
 static inline int uhci_submit_bulk(struct uhci_hcd *uhci, struct urb *urb,
 		struct uhci_qh *qh)
 {
@@ -971,6 +763,129 @@ static inline int uhci_submit_interrupt(struct uhci_hcd *uhci, struct urb *urb,
 	return uhci_submit_common(uhci, urb, qh);
 }
 
+/*
+ * Fix up the data structures following a short transfer
+ */
+static int uhci_fixup_short_transfer(struct uhci_hcd *uhci,
+		struct uhci_qh *qh, struct urb_priv *urbp,
+		struct uhci_td *short_td)
+{
+	struct uhci_td *td;
+	int ret = 0;
+
+	td = list_entry(urbp-&gt;td_list.prev, struct uhci_td, list);
+	if (qh-&gt;type == USB_ENDPOINT_XFER_CONTROL) {
+		urbp-&gt;short_transfer = 1;
+
+		/* When a control transfer is short, we have to restart
+		 * the queue at the status stage transaction, which is
+		 * the last TD. */
+		qh-&gt;element = cpu_to_le32(td-&gt;dma_handle);
+		ret = -EINPROGRESS;
+
+	} else if (!urbp-&gt;short_transfer) {
+		urbp-&gt;short_transfer = 1;
+
+		/* When a bulk/interrupt transfer is short, we have to
+		 * fix up the toggles of the following URBs on the queue
+		 * before restarting the queue at the next URB. */
+		qh-&gt;initial_toggle = uhci_toggle(td_token(short_td)) ^ 1;
+		uhci_fixup_toggles(qh, 1);
+
+		qh-&gt;element = td-&gt;link;
+	}
+
+	return ret;
+}
+
+/*
+ * Common result for control, bulk, and interrupt
+ */
+static int uhci_result_common(struct uhci_hcd *uhci, struct urb *urb)
+{
+	struct urb_priv *urbp = urb-&gt;hcpriv;
+	struct uhci_qh *qh = urbp-&gt;qh;
+	struct uhci_td *td;
+	struct list_head *tmp;
+	unsigned status;
+	int ret = 0;
+
+	tmp = urbp-&gt;td_list.next;
+
+	if (qh-&gt;type == USB_ENDPOINT_XFER_CONTROL) {
+		if (urbp-&gt;short_transfer)
+			tmp = urbp-&gt;td_list.prev;
+		else
+			urb-&gt;actual_length = -8;	/* SETUP packet */
+	} else
+		urb-&gt;actual_length = 0;
+
+
+	while (tmp != &amp;urbp-&gt;td_list) {
+		unsigned int ctrlstat;
+		int len;
+
+		td = list_entry(tmp, struct uhci_td, list);
+		tmp = tmp-&gt;next;
+
+		ctrlstat = td_status(td);
+		status = uhci_status_bits(ctrlstat);
+		if (status &amp; TD_CTRL_ACTIVE)
+			return -EINPROGRESS;
+
+		len = uhci_actual_length(ctrlstat);
+		urb-&gt;actual_length += len;
+
+		if (status) {
+			ret = uhci_map_status(status,
+					uhci_packetout(td_token(td)));
+			if ((debug == 1 &amp;&amp; ret != -EPIPE) || debug &gt; 1) {
+				/* Some debugging code */
+				dev_dbg(uhci_dev(uhci),
+						"%s: failed with status %x\n",
+						__FUNCTION__, status);
+
+				if (debug &gt; 1 &amp;&amp; errbuf) {
+					/* Print the chain for debugging */
+					uhci_show_qh(urbp-&gt;qh, errbuf,
+							ERRBUF_LEN, 0);
+					lprintk(errbuf);
+				}
+			}
+
+		} else if (len &lt; uhci_expected_length(td_token(td))) {
+
+			/* We received a short packet */
+			if (urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK)
+				ret = -EREMOTEIO;
+			else if (ctrlstat &amp; TD_CTRL_SPD)
+				ret = 1;
+		}
+
+		if (ret != 0)
+			goto err;
+	}
+	return ret;
+
+err:
+	if (ret &lt; 0) {
+		/* In case a control transfer gets an error
+		 * during the setup stage */
+		urb-&gt;actual_length = max(urb-&gt;actual_length, 0);
+
+		/* Note that the queue has stopped and save
+		 * the next toggle value */
+		qh-&gt;element = UHCI_PTR_TERM;
+		qh-&gt;is_stopped = 1;
+		qh-&gt;needs_fixup = (qh-&gt;type != USB_ENDPOINT_XFER_CONTROL);
+		qh-&gt;initial_toggle = uhci_toggle(td_token(td)) ^
+				(ret == -EREMOTEIO);
+
+	} else		/* Short packet received */
+		ret = uhci_fixup_short_transfer(uhci, qh, urbp, td);
+	return ret;
+}
+
 /*
  * Isochronous transfers
  */
@@ -1276,17 +1191,10 @@ static void uhci_scan_qh(struct uhci_hcd *uhci, struct uhci_qh *qh,
 		urbp = list_entry(qh-&gt;queue.next, struct urb_priv, node);
 		urb = urbp-&gt;urb;
 
-		switch (qh-&gt;type) {
-		case USB_ENDPOINT_XFER_CONTROL:
-			status = uhci_result_control(uhci, urb);
-			break;
-		case USB_ENDPOINT_XFER_ISOC:
+		if (qh-&gt;type == USB_ENDPOINT_XFER_ISOC)
 			status = uhci_result_isochronous(uhci, urb);
-			break;
-		default:	/* USB_ENDPOINT_XFER_BULK or _INT */
+		else
 			status = uhci_result_common(uhci, urb);
-			break;
-		}
 		if (status == -EINPROGRESS)
 			break;
 </pre><hr><pre>commit 0f28b55db543001d360e4319bfc3f2c4e28ba05f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon May 15 14:49:04 2006 -0400

    [PATCH] usbhid: automatically set HID_QUIRK_NOGET for keyboards and mice
    
    It seems to be relatively common for USB keyboards and mice to dislike
    being polled for reports.  Since there's no need to poll a keyboard or
    a mouse, this patch (as685) automatically sets the HID_QUIRK_NOGET flag
    for devices that advertise themselves as either sort of device with boot
    protocol support.
    
    This won't cure all the problems since some devices don't support the
    boot protocol, but it's simple and easy and it should fix quite a few
    problems.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/input/hid-core.c b/drivers/usb/input/hid-core.c
index bb1f5211ff9d..061002fc66fc 100644
--- a/drivers/usb/input/hid-core.c
+++ b/drivers/usb/input/hid-core.c
@@ -1797,6 +1797,14 @@ static struct hid_device *usb_hid_configure(struct usb_interface *intf)
 			(hid_blacklist[n].idProduct == le16_to_cpu(dev-&gt;descriptor.idProduct)))
 				quirks = hid_blacklist[n].quirks;
 
+	/* Many keyboards and mice don't like to be polled for reports,
+	 * so we will always set the HID_QUIRK_NOGET flag for them. */
+	if (interface-&gt;desc.bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT) {
+		if (interface-&gt;desc.bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD ||
+			interface-&gt;desc.bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE)
+				quirks |= HID_QUIRK_NOGET;
+	}
+
 	if (quirks &amp; HID_QUIRK_IGNORE)
 		return NULL;
 
diff --git a/drivers/usb/input/hid.h b/drivers/usb/input/hid.h
index 7efbfff8adde..778e575de352 100644
--- a/drivers/usb/input/hid.h
+++ b/drivers/usb/input/hid.h
@@ -40,6 +40,14 @@
 
 #define USB_INTERFACE_CLASS_HID		3
 
+/*
+ * USB HID interface subclass and protocol codes
+ */
+
+#define USB_INTERFACE_SUBCLASS_BOOT	1
+#define USB_INTERFACE_PROTOCOL_KEYBOARD	1
+#define USB_INTERFACE_PROTOCOL_MOUSE	2
+
 /*
  * HID class requests
  */</pre><hr><pre>commit 2775562ad2af2fc131ef7987166db6e42217528f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 5 16:32:02 2006 -0400

    [PATCH] USB: UHCI: fix obscure bug in enqueue()
    
    This patch (as676) fixes a small bug in uhci-hcd's enqueue routine.  When
    an URB is unlinked or gets an error and the completion handler queues
    another URB for the same endpoint, the queue shouldn't be allowed to start
    up again until the handler returns.  Not even if the new URB is the only
    one on its queue.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 8639e9035931..693e92c1bd9e 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -1148,8 +1148,9 @@ static int uhci_urb_enqueue(struct usb_hcd *hcd,
 
 	/* If the new URB is the first and only one on this QH then either
 	 * the QH is new and idle or else it's unlinked and waiting to
-	 * become idle, so we can activate it right away. */
-	if (qh-&gt;queue.next == &amp;urbp-&gt;node)
+	 * become idle, so we can activate it right away.  But only if the
+	 * queue isn't stopped. */
+	if (qh-&gt;queue.next == &amp;urbp-&gt;node &amp;&amp; !qh-&gt;is_stopped)
 		uhci_activate_qh(uhci, qh);
 	goto done;
 
@@ -1293,27 +1294,32 @@ static void uhci_scan_qh(struct uhci_hcd *uhci, struct uhci_qh *qh,
 		if (urb-&gt;status == -EINPROGRESS)	/* Not dequeued */
 			urb-&gt;status = status;
 		else
-			status = -ECONNRESET;
+			status = ECONNRESET;		/* Not -ECONNRESET */
 		spin_unlock(&amp;urb-&gt;lock);
 
 		/* Dequeued but completed URBs can't be given back unless
 		 * the QH is stopped or has finished unlinking. */
-		if (status == -ECONNRESET &amp;&amp;
-				!(qh-&gt;is_stopped || QH_FINISHED_UNLINKING(qh)))
-			return;
+		if (status == ECONNRESET) {
+			if (QH_FINISHED_UNLINKING(qh))
+				qh-&gt;is_stopped = 1;
+			else if (!qh-&gt;is_stopped)
+				return;
+		}
 
 		uhci_giveback_urb(uhci, qh, urb, regs);
-		if (qh-&gt;is_stopped)
+		if (status &lt; 0)
 			break;
 	}
 
 	/* If the QH is neither stopped nor finished unlinking (normal case),
 	 * our work here is done. */
- restart:
-	if (!(qh-&gt;is_stopped || QH_FINISHED_UNLINKING(qh)))
+	if (QH_FINISHED_UNLINKING(qh))
+		qh-&gt;is_stopped = 1;
+	else if (!qh-&gt;is_stopped)
 		return;
 
 	/* Otherwise give back each of the dequeued URBs */
+restart:
 	list_for_each_entry(urbp, &amp;qh-&gt;queue, node) {
 		urb = urbp-&gt;urb;
 		if (urb-&gt;status != -EINPROGRESS) {</pre><hr><pre>commit 4de7d2c231a8624a47417977be0768c5b5257c4f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 5 16:26:58 2006 -0400

    [PATCH] USB: UHCI: store the endpoint type in the QH structure
    
    This patch (as675) simplifies uhci-hcd slightly by storing each endpoint's
    type in the corresponding Queue Header structure.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-debug.c b/drivers/usb/host/uhci-debug.c
index e1239319655c..28c1c51ec475 100644
--- a/drivers/usb/host/uhci-debug.c
+++ b/drivers/usb/host/uhci-debug.c
@@ -98,6 +98,7 @@ static int uhci_show_urbp(struct urb_priv *urbp, char *buf, int len, int space)
 	char *out = buf;
 	struct uhci_td *td;
 	int i, nactive, ninactive;
+	char *ptype;
 
 	if (len &lt; 200)
 		return 0;
@@ -110,13 +111,14 @@ static int uhci_show_urbp(struct urb_priv *urbp, char *buf, int len, int space)
 			(usb_pipein(urbp-&gt;urb-&gt;pipe) ? "IN" : "OUT"));
 
 	switch (usb_pipetype(urbp-&gt;urb-&gt;pipe)) {
-	case PIPE_ISOCHRONOUS: out += sprintf(out, "ISO"); break;
-	case PIPE_INTERRUPT: out += sprintf(out, "INT"); break;
-	case PIPE_BULK: out += sprintf(out, "BLK"); break;
-	case PIPE_CONTROL: out += sprintf(out, "CTL"); break;
+	case PIPE_ISOCHRONOUS: ptype = "ISO"; break;
+	case PIPE_INTERRUPT: ptype = "INT"; break;
+	case PIPE_BULK: ptype = "BLK"; break;
+	default:
+	case PIPE_CONTROL: ptype = "CTL"; break;
 	}
 
-	out += sprintf(out, "%s", (urbp-&gt;fsbr ? " FSBR" : ""));
+	out += sprintf(out, "%s%s", ptype, (urbp-&gt;fsbr ? " FSBR" : ""));
 
 	if (urbp-&gt;urb-&gt;status != -EINPROGRESS)
 		out += sprintf(out, " Status=%d", urbp-&gt;urb-&gt;status);
@@ -147,13 +149,23 @@ static int uhci_show_qh(struct uhci_qh *qh, char *buf, int len, int space)
 	char *out = buf;
 	int i, nurbs;
 	__le32 element = qh_element(qh);
+	char *qtype;
 
 	/* Try to make sure there's enough memory */
 	if (len &lt; 80 * 6)
 		return 0;
 
-	out += sprintf(out, "%*s[%p] link (%08x) element (%08x)\n", space, "",
-			qh, le32_to_cpu(qh-&gt;link), le32_to_cpu(element));
+	switch (qh-&gt;type) {
+	case USB_ENDPOINT_XFER_ISOC: qtype = "ISO"; break;
+	case USB_ENDPOINT_XFER_INT: qtype = "INT"; break;
+	case USB_ENDPOINT_XFER_BULK: qtype = "BLK"; break;
+	case USB_ENDPOINT_XFER_CONTROL: qtype = "CTL"; break;
+	default: qtype = "Skel" ; break;
+	}
+
+	out += sprintf(out, "%*s[%p] %s QH link (%08x) element (%08x)\n",
+			space, "", qh, qtype,
+			le32_to_cpu(qh-&gt;link), le32_to_cpu(element));
 
 	if (element &amp; UHCI_PTR_QH)
 		out += sprintf(out, "%*s  Element points to QH (bug?)\n", space, "");
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index d5c8f4d92823..8e5778650493 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -132,6 +132,7 @@ struct uhci_qh {
 
 	unsigned int unlink_frame;	/* When the QH was unlinked */
 	int state;			/* QH_STATE_xxx; see above */
+	int type;			/* Queue type (control, bulk, etc) */
 
 	unsigned int initial_toggle:1;	/* Endpoint's current toggle value */
 	unsigned int needs_fixup:1;	/* Must fix the TD toggle values */
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index a06d84c19e13..8639e9035931 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -179,10 +179,12 @@ static struct uhci_qh *uhci_alloc_qh(struct uhci_hcd *uhci,
 		qh-&gt;hep = hep;
 		qh-&gt;udev = udev;
 		hep-&gt;hcpriv = qh;
+		qh-&gt;type = hep-&gt;desc.bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK;
 
 	} else {		/* Skeleton QH */
 		qh-&gt;state = QH_STATE_ACTIVE;
 		qh-&gt;udev = NULL;
+		qh-&gt;type = -1;
 	}
 	return qh;
 }
@@ -217,8 +219,8 @@ static void uhci_save_toggle(struct uhci_qh *qh, struct urb *urb)
 	qh-&gt;element = UHCI_PTR_TERM;
 
 	/* Only bulk and interrupt pipes have to worry about toggles */
-	if (!(usb_pipetype(urb-&gt;pipe) == PIPE_BULK ||
-			usb_pipetype(urb-&gt;pipe) == PIPE_INTERRUPT))
+	if (!(qh-&gt;type == USB_ENDPOINT_XFER_BULK ||
+			qh-&gt;type == USB_ENDPOINT_XFER_INT))
 		return;
 
 	/* Find the first active TD; that's the device's toggle state */
@@ -1099,14 +1101,14 @@ static int uhci_urb_enqueue(struct usb_hcd *hcd,
 	}
 	urbp-&gt;qh = qh;
 
-	switch (usb_pipetype(urb-&gt;pipe)) {
-	case PIPE_CONTROL:
+	switch (qh-&gt;type) {
+	case USB_ENDPOINT_XFER_CONTROL:
 		ret = uhci_submit_control(uhci, urb, qh);
 		break;
-	case PIPE_BULK:
+	case USB_ENDPOINT_XFER_BULK:
 		ret = uhci_submit_bulk(uhci, urb, qh);
 		break;
-	case PIPE_INTERRUPT:
+	case USB_ENDPOINT_XFER_INT:
 		if (list_empty(&amp;qh-&gt;queue)) {
 			bustime = usb_check_bandwidth(urb-&gt;dev, urb);
 			if (bustime &lt; 0)
@@ -1125,7 +1127,7 @@ static int uhci_urb_enqueue(struct usb_hcd *hcd,
 			ret = uhci_submit_interrupt(uhci, urb, qh);
 		}
 		break;
-	case PIPE_ISOCHRONOUS:
+	case USB_ENDPOINT_XFER_ISOC:
 		bustime = usb_check_bandwidth(urb-&gt;dev, urb);
 		if (bustime &lt; 0) {
 			ret = bustime;
@@ -1175,7 +1177,7 @@ static int uhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb)
 		goto done;
 
 	/* Remove Isochronous TDs from the frame list ASAP */
-	if (usb_pipetype(urb-&gt;pipe) == PIPE_ISOCHRONOUS)
+	if (urbp-&gt;qh-&gt;type == USB_ENDPOINT_XFER_ISOC)
 		uhci_unlink_isochronous_tds(uhci, urb);
 	uhci_unlink_qh(uhci, urbp-&gt;qh);
 
@@ -1195,7 +1197,7 @@ __acquires(uhci-&gt;lock)
 	struct urb_priv *urbp = (struct urb_priv *) urb-&gt;hcpriv;
 
 	/* Isochronous TDs get unlinked directly from the frame list */
-	if (usb_pipetype(urb-&gt;pipe) == PIPE_ISOCHRONOUS)
+	if (qh-&gt;type == USB_ENDPOINT_XFER_ISOC)
 		uhci_unlink_isochronous_tds(uhci, urb);
 
 	/* If the URB isn't first on its queue, adjust the link pointer
@@ -1224,13 +1226,13 @@ __acquires(uhci-&gt;lock)
 	uhci_dec_fsbr(uhci, urb);	/* Safe since it checks */
 	uhci_free_urb_priv(uhci, urbp);
 
-	switch (usb_pipetype(urb-&gt;pipe)) {
-	case PIPE_ISOCHRONOUS:
+	switch (qh-&gt;type) {
+	case USB_ENDPOINT_XFER_ISOC:
 		/* Release bandwidth for Interrupt or Isoc. transfers */
 		if (urb-&gt;bandwidth)
 			usb_release_bandwidth(urb-&gt;dev, urb, 1);
 		break;
-	case PIPE_INTERRUPT:
+	case USB_ENDPOINT_XFER_INT:
 		/* Release bandwidth for Interrupt or Isoc. transfers */
 		/* Make sure we don't release if we have a queued URB */
 		if (list_empty(&amp;qh-&gt;queue) &amp;&amp; urb-&gt;bandwidth)
@@ -1273,14 +1275,14 @@ static void uhci_scan_qh(struct uhci_hcd *uhci, struct uhci_qh *qh,
 		urbp = list_entry(qh-&gt;queue.next, struct urb_priv, node);
 		urb = urbp-&gt;urb;
 
-		switch (usb_pipetype(urb-&gt;pipe)) {
-		case PIPE_CONTROL:
+		switch (qh-&gt;type) {
+		case USB_ENDPOINT_XFER_CONTROL:
 			status = uhci_result_control(uhci, urb);
 			break;
-		case PIPE_ISOCHRONOUS:
+		case USB_ENDPOINT_XFER_ISOC:
 			status = uhci_result_isochronous(uhci, urb);
 			break;
-		default:	/* PIPE_BULK or PIPE_INTERRUPT */
+		default:	/* USB_ENDPOINT_XFER_BULK or _INT */
 			status = uhci_result_common(uhci, urb);
 			break;
 		}</pre><hr><pre>commit 2d61bde7a0e630e1906e6478b6b2a7aeaaa8f8da
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 5 16:23:42 2006 -0400

    [PATCH] USB: net2280: add a shutdown routine
    
    The net2280 board has an annoying habit of surviving soft reboots with
    interrupts enabled.  This patch (as674) adds a shutdown routine to the
    driver so that the board can be put in a quiescent state.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/net2280.c b/drivers/usb/gadget/net2280.c
index 020d3c42b1af..1facdea56a8a 100644
--- a/drivers/usb/gadget/net2280.c
+++ b/drivers/usb/gadget/net2280.c
@@ -2966,6 +2966,22 @@ static int net2280_probe (struct pci_dev *pdev, const struct pci_device_id *id)
 	return retval;
 }
 
+/* make sure the board is quiescent; otherwise it will continue
+ * generating IRQs across the upcoming reboot.
+ */
+
+static void net2280_shutdown (struct pci_dev *pdev)
+{
+	struct net2280		*dev = pci_get_drvdata (pdev);
+
+	/* disable IRQs */
+	writel (0, &amp;dev-&gt;regs-&gt;pciirqenb0);
+	writel (0, &amp;dev-&gt;regs-&gt;pciirqenb1);
+
+	/* disable the pullup so the host will think we're gone */
+	writel (0, &amp;dev-&gt;usb-&gt;usbctl);
+}
+
 
 /*-------------------------------------------------------------------------*/
 
@@ -2995,6 +3011,7 @@ static struct pci_driver net2280_pci_driver = {
 
 	.probe =	net2280_probe,
 	.remove =	net2280_remove,
+	.shutdown =	net2280_shutdown,
 
 	/* FIXME add power management support */
 };</pre><hr><pre>commit 4489a5712b086621a6c3f669057d2996245cd3fb
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Apr 27 15:54:22 2006 -0400

    [PATCH] USB: usbcore: always turn on hub port power
    
    Some hubs claim not to support port-power switching, and right now the
    hub driver believes them and does not enable power to their ports.
    However it turns out that even though they don't actually switch power,
    they do ignore all events on a port until told to turn on the power!
    This problem has been reported by several users.
    
    This revised patch (as672b) makes the hub driver always try to turn on
    port power to all hubs, regardless of what the hub descriptor says.  It
    also adds a comment explaining the need for this.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 90b8d43c6b33..1b1846e6473b 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -432,15 +432,22 @@ static void hub_power_on(struct usb_hub *hub)
 {
 	int port1;
 	unsigned pgood_delay = hub-&gt;descriptor-&gt;bPwrOn2PwrGood * 2;
-	u16 wHubCharacteristics = le16_to_cpu(hub-&gt;descriptor-&gt;wHubCharacteristics);
-
-	/* if hub supports power switching, enable power on each port */
-	if ((wHubCharacteristics &amp; HUB_CHAR_LPSM) &lt; 2) {
+	u16 wHubCharacteristics =
+			le16_to_cpu(hub-&gt;descriptor-&gt;wHubCharacteristics);
+
+	/* Enable power on each port.  Some hubs have reserved values
+	 * of LPSM (&gt; 2) in their descriptors, even though they are
+	 * USB 2.0 hubs.  Some hubs do not implement port-power switching
+	 * but only emulate it.  In all cases, the ports won't work
+	 * unless we send these messages to the hub.
+	 */
+	if ((wHubCharacteristics &amp; HUB_CHAR_LPSM) &lt; 2)
 		dev_dbg(hub-&gt;intfdev, "enabling power on all ports\n");
-		for (port1 = 1; port1 &lt;= hub-&gt;descriptor-&gt;bNbrPorts; port1++)
-			set_port_feature(hub-&gt;hdev, port1,
-					USB_PORT_FEAT_POWER);
-	}
+	else
+		dev_dbg(hub-&gt;intfdev, "trying to enable port power on "
+				"non-switchable hub\n");
+	for (port1 = 1; port1 &lt;= hub-&gt;descriptor-&gt;bNbrPorts; port1++)
+		set_port_feature(hub-&gt;hdev, port1, USB_PORT_FEAT_POWER);
 
 	/* Wait at least 100 msec for power to become stable */
 	msleep(max(pgood_delay, (unsigned) 100));</pre>
    <div class="pagination">
        <a href='2_125.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><span>[126]</span><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_127.html'>Next&gt;&gt;</a>
    <div>
</body>
