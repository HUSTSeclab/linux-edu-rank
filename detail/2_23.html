<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_22.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><span>[23]</span><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_24.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 6c73358c83ce870c0cf32413e5cadb3b9a39c606
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Aug 22 16:58:53 2016 -0400

    USB: fix typo in wMaxPacketSize validation
    
    The maximum value allowed for wMaxPacketSize of a high-speed interrupt
    endpoint is 1024 bytes, not 1023.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Fixes: aed9d65ac327 ("USB: validate wMaxPacketValue entries in endpoint descriptors")
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c
index 051163189810..15ce4ab11688 100644
--- a/drivers/usb/core/config.c
+++ b/drivers/usb/core/config.c
@@ -187,7 +187,7 @@ static const unsigned short high_speed_maxpacket_maxes[4] = {
 	[USB_ENDPOINT_XFER_CONTROL] = 64,
 	[USB_ENDPOINT_XFER_ISOC] = 1024,
 	[USB_ENDPOINT_XFER_BULK] = 512,
-	[USB_ENDPOINT_XFER_INT] = 1023,
+	[USB_ENDPOINT_XFER_INT] = 1024,
 };
 static const unsigned short super_speed_maxpacket_maxes[4] = {
 	[USB_ENDPOINT_XFER_CONTROL] = 512,</pre><hr><pre>commit 5cce438298a0d2a7a857a4a3c3e26aeb8f77b941
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jun 10 14:42:55 2016 -0400

    USB: remove race condition in usbfs/libusb when using reap-after-disconnect
    
    Hans de Goede has reported a difficulty in the Linux port of libusb.
    When a device is removed, the poll() system call in usbfs starts
    returning POLLERR as soon as udev-&gt;state is set to
    USB_STATE_NOTATTACHED, but the outstanding URBs are not available for
    reaping until some time later (after usbdev_remove() has been called).
    This is awkward for libusb or other usbfs clients, although not an
    insuperable problem.
    
    At any rate, it's easy to change usbfs so that it returns POLLHUP as
    soon as the state becomes USB_STATE_NOTATTACHED but it doesn't return
    POLLERR until after the outstanding URBs have completed.  That's what
    this patch does; it uses the fact that ps-&gt;list is always on the
    dev-&gt;filelist list until usbdev_remove() takes it off, which happens
    after all the outstanding URBs have been cancelled.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Hans de Goede &lt;hdegoede@redhat.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 472cbcdf7456..e6a6d67c8705 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -2583,7 +2583,9 @@ static unsigned int usbdev_poll(struct file *file,
 	if (file-&gt;f_mode &amp; FMODE_WRITE &amp;&amp; !list_empty(&amp;ps-&gt;async_completed))
 		mask |= POLLOUT | POLLWRNORM;
 	if (!connected(ps))
-		mask |= POLLERR | POLLHUP;
+		mask |= POLLHUP;
+	if (list_empty(&amp;ps-&gt;list))
+		mask |= POLLERR;
 	return mask;
 }
 </pre><hr><pre>commit aed9d65ac3278d4febd8665bd7db59ef53e825fe
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Aug 1 15:25:56 2016 -0400

    USB: validate wMaxPacketValue entries in endpoint descriptors
    
    Erroneous or malicious endpoint descriptors may have non-zero bits in
    reserved positions, or out-of-bounds values.  This patch helps prevent
    these from causing problems by bounds-checking the wMaxPacketValue
    entries in endpoint descriptors and capping the values at the maximum
    allowed.
    
    This issue was first discovered and tests were conducted by Jake Lamberson
    &lt;jake.lamberson1@gmail.com&gt;, an intern working for Rosie Hall.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: roswest &lt;roswest@cisco.com&gt;
    Tested-by: roswest &lt;roswest@cisco.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c
index 31ccdccd7a04..051163189810 100644
--- a/drivers/usb/core/config.c
+++ b/drivers/usb/core/config.c
@@ -171,6 +171,31 @@ static void usb_parse_ss_endpoint_companion(struct device *ddev, int cfgno,
 							ep, buffer, size);
 }
 
+static const unsigned short low_speed_maxpacket_maxes[4] = {
+	[USB_ENDPOINT_XFER_CONTROL] = 8,
+	[USB_ENDPOINT_XFER_ISOC] = 0,
+	[USB_ENDPOINT_XFER_BULK] = 0,
+	[USB_ENDPOINT_XFER_INT] = 8,
+};
+static const unsigned short full_speed_maxpacket_maxes[4] = {
+	[USB_ENDPOINT_XFER_CONTROL] = 64,
+	[USB_ENDPOINT_XFER_ISOC] = 1023,
+	[USB_ENDPOINT_XFER_BULK] = 64,
+	[USB_ENDPOINT_XFER_INT] = 64,
+};
+static const unsigned short high_speed_maxpacket_maxes[4] = {
+	[USB_ENDPOINT_XFER_CONTROL] = 64,
+	[USB_ENDPOINT_XFER_ISOC] = 1024,
+	[USB_ENDPOINT_XFER_BULK] = 512,
+	[USB_ENDPOINT_XFER_INT] = 1023,
+};
+static const unsigned short super_speed_maxpacket_maxes[4] = {
+	[USB_ENDPOINT_XFER_CONTROL] = 512,
+	[USB_ENDPOINT_XFER_ISOC] = 1024,
+	[USB_ENDPOINT_XFER_BULK] = 1024,
+	[USB_ENDPOINT_XFER_INT] = 1024,
+};
+
 static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,
     int asnum, struct usb_host_interface *ifp, int num_ep,
     unsigned char *buffer, int size)
@@ -179,6 +204,8 @@ static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,
 	struct usb_endpoint_descriptor *d;
 	struct usb_host_endpoint *endpoint;
 	int n, i, j, retval;
+	unsigned int maxp;
+	const unsigned short *maxpacket_maxes;
 
 	d = (struct usb_endpoint_descriptor *) buffer;
 	buffer += d-&gt;bLength;
@@ -286,6 +313,42 @@ static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,
 			endpoint-&gt;desc.wMaxPacketSize = cpu_to_le16(8);
 	}
 
+	/* Validate the wMaxPacketSize field */
+	maxp = usb_endpoint_maxp(&amp;endpoint-&gt;desc);
+
+	/* Find the highest legal maxpacket size for this endpoint */
+	i = 0;		/* additional transactions per microframe */
+	switch (to_usb_device(ddev)-&gt;speed) {
+	case USB_SPEED_LOW:
+		maxpacket_maxes = low_speed_maxpacket_maxes;
+		break;
+	case USB_SPEED_FULL:
+		maxpacket_maxes = full_speed_maxpacket_maxes;
+		break;
+	case USB_SPEED_HIGH:
+		/* Bits 12..11 are allowed only for HS periodic endpoints */
+		if (usb_endpoint_xfer_int(d) || usb_endpoint_xfer_isoc(d)) {
+			i = maxp &amp; (BIT(12) | BIT(11));
+			maxp &amp;= ~i;
+		}
+		/* fallthrough */
+	default:
+		maxpacket_maxes = high_speed_maxpacket_maxes;
+		break;
+	case USB_SPEED_SUPER:
+	case USB_SPEED_SUPER_PLUS:
+		maxpacket_maxes = super_speed_maxpacket_maxes;
+		break;
+	}
+	j = maxpacket_maxes[usb_endpoint_type(&amp;endpoint-&gt;desc)];
+
+	if (maxp &gt; j) {
+		dev_warn(ddev, "config %d interface %d altsetting %d endpoint 0x%X has invalid maxpacket %d, setting to %d\n",
+		    cfgno, inum, asnum, d-&gt;bEndpointAddress, maxp, j);
+		maxp = j;
+		endpoint-&gt;desc.wMaxPacketSize = cpu_to_le16(i | maxp);
+	}
+
 	/*
 	 * Some buggy high speed devices have bulk endpoints using
 	 * maxpacket sizes other than 512.  High speed HCDs may not
@@ -293,9 +356,6 @@ static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,
 	 */
 	if (to_usb_device(ddev)-&gt;speed == USB_SPEED_HIGH
 			&amp;&amp; usb_endpoint_xfer_bulk(d)) {
-		unsigned maxp;
-
-		maxp = usb_endpoint_maxp(&amp;endpoint-&gt;desc) &amp; 0x07ff;
 		if (maxp != 512)
 			dev_warn(ddev, "config %d interface %d altsetting %d "
 				"bulk endpoint 0x%X has invalid maxpacket %d\n",</pre><hr><pre>commit 07d316a22e119fa301fd7dba7f1e1adfd4f72c05
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 5 11:51:30 2016 -0400

    USB: hub: change the locking in hub_activate
    
    The locking in hub_activate() is not adequate to provide full mutual
    exclusion with hub_quiesce().  The subroutine locks the hub's
    usb_interface, but the callers of hub_quiesce() (such as
    hub_pre_reset() and hub_event()) hold the lock to the hub's
    usb_device.
    
    This patch changes hub_activate() to make it acquire the same lock as
    those other routines.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@vger.kernel.org&gt; #4.4+
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index bb69d262b6f9..1d5fc32d06d0 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1052,7 +1052,7 @@ static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)
 
 	/* Continue a partial initialization */
 	if (type == HUB_INIT2 || type == HUB_INIT3) {
-		device_lock(hub-&gt;intfdev);
+		device_lock(&amp;hdev-&gt;dev);
 
 		/* Was the hub disconnected while we were waiting? */
 		if (hub-&gt;disconnected)
@@ -1259,7 +1259,7 @@ static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)
 			queue_delayed_work(system_power_efficient_wq,
 					&amp;hub-&gt;init_work,
 					msecs_to_jiffies(delay));
-			device_unlock(hub-&gt;intfdev);
+			device_unlock(&amp;hdev-&gt;dev);
 			return;		/* Continues at init3: below */
 		} else {
 			msleep(delay);
@@ -1282,7 +1282,7 @@ static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)
 		/* Allow autosuspend if it was suppressed */
  disconnected:
 		usb_autopm_put_interface_async(to_usb_interface(hub-&gt;intfdev));
-		device_unlock(hub-&gt;intfdev);
+		device_unlock(&amp;hdev-&gt;dev);
 	}
 
 	kref_put(&amp;hub-&gt;kref, hub_release);</pre><hr><pre>commit ca5cbc8b02f9b21cc8cd1ab36668763ec34f9ee8
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 5 11:49:45 2016 -0400

    USB: hub: fix up early-exit pathway in hub_activate
    
    The early-exit pathway in hub_activate, added by commit e50293ef9775
    ("USB: fix invalid memory access in hub_activate()") needs
    improvement.  It duplicates code that is already present at the end of
    the subroutine, and it neglects to undo the effect of a
    usb_autopm_get_interface_no_resume() call.
    
    This patch fixes both problems by making the early-exit pathway jump
    directly to the end of the subroutine.  It simplifies the code at the
    end by merging two conditionals that actually test the same condition
    although they appear different: If type &lt; HUB_INIT3 then type must be
    either HUB_INIT2 or HUB_INIT, and it can't be HUB_INIT because in that
    case the subroutine would have exited earlier.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@vger.kernel.org&gt; #4.4+
    Reviewed-by: Viresh Kumar &lt;viresh.kumar@linaro.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 3ccffac0f647..bb69d262b6f9 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1055,11 +1055,8 @@ static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)
 		device_lock(hub-&gt;intfdev);
 
 		/* Was the hub disconnected while we were waiting? */
-		if (hub-&gt;disconnected) {
-			device_unlock(hub-&gt;intfdev);
-			kref_put(&amp;hub-&gt;kref, hub_release);
-			return;
-		}
+		if (hub-&gt;disconnected)
+			goto disconnected;
 		if (type == HUB_INIT2)
 			goto init2;
 		goto init3;
@@ -1281,12 +1278,12 @@ static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)
 	/* Scan all ports that need attention */
 	kick_hub_wq(hub);
 
-	/* Allow autosuspend if it was suppressed */
-	if (type &lt;= HUB_INIT3)
+	if (type == HUB_INIT2 || type == HUB_INIT3) {
+		/* Allow autosuspend if it was suppressed */
+ disconnected:
 		usb_autopm_put_interface_async(to_usb_interface(hub-&gt;intfdev));
-
-	if (type == HUB_INIT2 || type == HUB_INIT3)
 		device_unlock(hub-&gt;intfdev);
+	}
 
 	kref_put(&amp;hub-&gt;kref, hub_release);
 }</pre><hr><pre>commit 5e7ff2ca7f2da55fe777167849d0c93403bd0dc8
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jun 23 15:05:26 2016 -0400

    SCSI: fix new bug in scsi_dev_info_list string matching
    
    Commit b704f70ce200 ("SCSI: fix bug in scsi_dev_info_list matching")
    changed the way vendor- and model-string matching was carried out in the
    routine that looks up entries in a SCSI devinfo list.  The new matching
    code failed to take into account the case of a maximum-length string; in
    such cases it could end up testing for a terminating '\0' byte beyond
    the end of the memory allocated to the string.  This out-of-bounds bug
    was detected by UBSAN.
    
    I don't know if anybody has actually encountered this bug.  The symptom
    would be that a device entry in the blacklist might not be matched
    properly if it contained an 8-character vendor name or a 16-character
    model name.  Such entries certainly exist in scsi_static_device_list.
    
    This patch fixes the problem by adding a check for a maximum-length
    string before the '\0' test.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Fixes: b704f70ce200 ("SCSI: fix bug in scsi_dev_info_list matching")
    Tested-by: Wilfried Klaebe &lt;linux-kernel@lebenslange-mailadresse.de&gt;
    CC: &lt;stable@vger.kernel.org&gt; # v4.4+
    Signed-off-by: Martin K. Petersen &lt;martin.petersen@oracle.com&gt;

diff --git a/drivers/scsi/scsi_devinfo.c b/drivers/scsi/scsi_devinfo.c
index ff41c310c900..eaccd651ccda 100644
--- a/drivers/scsi/scsi_devinfo.c
+++ b/drivers/scsi/scsi_devinfo.c
@@ -429,7 +429,7 @@ static struct scsi_dev_info_list *scsi_dev_info_list_find(const char *vendor,
 	 * here, and we don't know what device it is
 	 * trying to work with, leave it as-is.
 	 */
-	vmax = 8;	/* max length of vendor */
+	vmax = sizeof(devinfo-&gt;vendor);
 	vskip = vendor;
 	while (vmax &gt; 0 &amp;&amp; *vskip == ' ') {
 		vmax--;
@@ -439,7 +439,7 @@ static struct scsi_dev_info_list *scsi_dev_info_list_find(const char *vendor,
 	while (vmax &gt; 0 &amp;&amp; vskip[vmax - 1] == ' ')
 		--vmax;
 
-	mmax = 16;	/* max length of model */
+	mmax = sizeof(devinfo-&gt;model);
 	mskip = model;
 	while (mmax &gt; 0 &amp;&amp; *mskip == ' ') {
 		mmax--;
@@ -455,10 +455,12 @@ static struct scsi_dev_info_list *scsi_dev_info_list_find(const char *vendor,
 			 * Behave like the older version of get_device_flags.
 			 */
 			if (memcmp(devinfo-&gt;vendor, vskip, vmax) ||
-					devinfo-&gt;vendor[vmax])
+					(vmax &lt; sizeof(devinfo-&gt;vendor) &amp;&amp;
+						devinfo-&gt;vendor[vmax]))
 				continue;
 			if (memcmp(devinfo-&gt;model, mskip, mmax) ||
-					devinfo-&gt;model[mmax])
+					(mmax &lt; sizeof(devinfo-&gt;model) &amp;&amp;
+						devinfo-&gt;model[mmax]))
 				continue;
 			return devinfo;
 		} else {</pre><hr><pre>commit ab2a4bf83902c170d29ba130a8abb5f9d90559e1
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jun 27 10:23:10 2016 -0400

    USB: don't free bandwidth_mutex too early
    
    The USB core contains a bug that can show up when a USB-3 host
    controller is removed.  If the primary (USB-2) hcd structure is
    released before the shared (USB-3) hcd, the core will try to do a
    double-free of the common bandwidth_mutex.
    
    The problem was described in graphical form by Chung-Geol Kim, who
    first reported it:
    
    =================================================
         At *remove USB(3.0) Storage
         sequence &lt;1&gt; --&gt; &lt;5&gt; ((Problem Case))
    =================================================
                                      VOLD
    ------------------------------------|------------
                                     (uevent)
                                ________|_________
                               |&lt;1&gt;               |
                               |dwc3_otg_sm_work  |
                               |usb_put_hcd       |
                               |peer_hcd(kref=2)|
                               |__________________|
                                ________|_________
                               |&lt;2&gt;               |
                               |New USB BUS #2    |
                               |                  |
                               |peer_hcd(kref=1)  |
                               |                  |
                             --(Link)-bandXX_mutex|
                             | |__________________|
                             |
        ___________________  |
       |&lt;3&gt;                | |
       |dwc3_otg_sm_work   | |
       |usb_put_hcd        | |
       |primary_hcd(kref=1)| |
       |___________________| |
        _________|_________  |
       |&lt;4&gt;                | |
       |New USB BUS #1     | |
       |hcd_release        | |
       |primary_hcd(kref=0)| |
       |                   | |
       |bandXX_mutex(free) |&lt;-
       |___________________|
                                   (( VOLD ))
                                ______|___________
                               |&lt;5&gt;               |
                               |      SCSI        |
                               |usb_put_hcd       |
                               |peer_hcd(kref=0)  |
                               |*hcd_release      |
                               |bandXX_mutex(free*)|&lt;- double free
                               |__________________|
    
    =================================================
    
    This happens because hcd_release() frees the bandwidth_mutex whenever
    it sees a primary hcd being released (which is not a very good idea
    in any case), but in the course of releasing the primary hcd, it
    changes the pointers in the shared hcd in such a way that the shared
    hcd will appear to be primary when it gets released.
    
    This patch fixes the problem by changing hcd_release() so that it
    deallocates the bandwidth_mutex only when the _last_ hcd structure
    referencing it is released.  The patch also removes an unnecessary
    test, so that when an hcd is released, both the shared_hcd and
    primary_hcd pointers in the hcd's peer will be cleared.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Chung-Geol Kim &lt;chunggeol.kim@samsung.com&gt;
    Tested-by: Chung-Geol Kim &lt;chunggeol.kim@samsung.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 34b837ae1ed7..d2e3f655c26f 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -2598,26 +2598,23 @@ EXPORT_SYMBOL_GPL(usb_create_hcd);
  * Don't deallocate the bandwidth_mutex until the last shared usb_hcd is
  * deallocated.
  *
- * Make sure to only deallocate the bandwidth_mutex when the primary HCD is
- * freed.  When hcd_release() is called for either hcd in a peer set
- * invalidate the peer's -&gt;shared_hcd and -&gt;primary_hcd pointers to
- * block new peering attempts
+ * Make sure to deallocate the bandwidth_mutex only when the last HCD is
+ * freed.  When hcd_release() is called for either hcd in a peer set,
+ * invalidate the peer's -&gt;shared_hcd and -&gt;primary_hcd pointers.
  */
 static void hcd_release(struct kref *kref)
 {
 	struct usb_hcd *hcd = container_of (kref, struct usb_hcd, kref);
 
 	mutex_lock(&amp;usb_port_peer_mutex);
-	if (usb_hcd_is_primary_hcd(hcd)) {
-		kfree(hcd-&gt;address0_mutex);
-		kfree(hcd-&gt;bandwidth_mutex);
-	}
 	if (hcd-&gt;shared_hcd) {
 		struct usb_hcd *peer = hcd-&gt;shared_hcd;
 
 		peer-&gt;shared_hcd = NULL;
-		if (peer-&gt;primary_hcd == hcd)
-			peer-&gt;primary_hcd = NULL;
+		peer-&gt;primary_hcd = NULL;
+	} else {
+		kfree(hcd-&gt;address0_mutex);
+		kfree(hcd-&gt;bandwidth_mutex);
 	}
 	mutex_unlock(&amp;usb_port_peer_mutex);
 	kfree(hcd);</pre><hr><pre>commit 7e8b3dfef16375dbfeb1f36a83eb9f27117c51fd
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jun 23 14:54:37 2016 -0400

    USB: EHCI: declare hostpc register as zero-length array
    
    The HOSTPC extension registers found in some EHCI implementations form
    a variable-length array, with one element for each port.  Therefore
    the hostpc field in struct ehci_regs should be declared as a
    zero-length array, not a single-element array.
    
    This fixes a problem reported by UBSAN.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Wilfried Klaebe &lt;linux-kernel@lebenslange-mailadresse.de&gt;
    Tested-by: Wilfried Klaebe &lt;linux-kernel@lebenslange-mailadresse.de&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/include/linux/usb/ehci_def.h b/include/linux/usb/ehci_def.h
index 966889a20ea3..e479033bd782 100644
--- a/include/linux/usb/ehci_def.h
+++ b/include/linux/usb/ehci_def.h
@@ -180,11 +180,11 @@ struct ehci_regs {
  * PORTSCx
  */
 	/* HOSTPC: offset 0x84 */
-	u32		hostpc[1];	/* HOSTPC extension */
+	u32		hostpc[0];	/* HOSTPC extension */
 #define HOSTPC_PHCD	(1&lt;&lt;22)		/* Phy clock disable */
 #define HOSTPC_PSPD	(3&lt;&lt;25)		/* Port speed detection */
 
-	u32		reserved5[16];
+	u32		reserved5[17];
 
 	/* USBMODE_EX: offset 0xc8 */
 	u32		usbmode_ex;	/* USB Device mode extension */</pre><hr><pre>commit 85e3990bea49a50cb389015fea564b58899ab7c1
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu May 19 16:29:50 2016 -0400

    USB: EHCI: avoid undefined pointer arithmetic and placate UBSAN
    
    Several people have reported that UBSAN doesn't like the pointer
    arithmetic in ehci_hub_control():
    
            u32 __iomem     *status_reg = &amp;ehci-&gt;regs-&gt;port_status[
                                    (wIndex &amp; 0xff) - 1];
            u32 __iomem     *hostpc_reg = &amp;ehci-&gt;regs-&gt;hostpc[(wIndex &amp; 0xff) - 1];
    
    If wIndex is 0 (and it often is), these calculations underflow and
    UBSAN complains.
    
    According to the C standard, pointer computations leading to locations
    outside the bounds of an array object (other than 1 position past the
    end) are undefined.  In this case, the compiler would be justified in
    concluding the wIndex can never be 0 and then optimizing away the
    tests for !wIndex that occur later in the subroutine.  (Although,
    since ehci-&gt;regs-&gt;port_status and ehci-&gt;regs-&gt;hostpc are both 0-length
    arrays and are thus GCC extensions to the C standard, it's not clear
    what the compiler is really allowed to do.)
    
    At any rate, we can avoid all these difficulties, at the cost of
    making the code slightly longer, by not decrementing the index when it
    is equal to 0.  The runtime effect is minimal, and anyway
    ehci_hub_control() is not on a hot path.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Valdis Kletnieks &lt;Valdis.Kletnieks@vt.edu&gt;
    Reported-by: Meelis Roos &lt;mroos@linux.ee&gt;
    Reported-by: Martin_MOKREJÅ &lt;mmokrejs@gmail.com&gt;
    Reported-by: "Navin P.S" &lt;navinp1912@gmail.com&gt;
    CC: Andrey Ryabinin &lt;ryabinin.a.a@gmail.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index ffc90295a95f..74f62d68f013 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -872,14 +872,22 @@ int ehci_hub_control(
 ) {
 	struct ehci_hcd	*ehci = hcd_to_ehci (hcd);
 	int		ports = HCS_N_PORTS (ehci-&gt;hcs_params);
-	u32 __iomem	*status_reg = &amp;ehci-&gt;regs-&gt;port_status[
-				(wIndex &amp; 0xff) - 1];
-	u32 __iomem	*hostpc_reg = &amp;ehci-&gt;regs-&gt;hostpc[(wIndex &amp; 0xff) - 1];
+	u32 __iomem	*status_reg, *hostpc_reg;
 	u32		temp, temp1, status;
 	unsigned long	flags;
 	int		retval = 0;
 	unsigned	selector;
 
+	/*
+	 * Avoid underflow while calculating (wIndex &amp; 0xff) - 1.
+	 * The compiler might deduce that wIndex can never be 0 and then
+	 * optimize away the tests for !wIndex below.
+	 */
+	temp = wIndex &amp; 0xff;
+	temp -= (temp &gt; 0);
+	status_reg = &amp;ehci-&gt;regs-&gt;port_status[temp];
+	hostpc_reg = &amp;ehci-&gt;regs-&gt;hostpc[temp];
+
 	/*
 	 * FIXME:  support SetPortFeatures USB_PORT_FEAT_INDICATOR.
 	 * HCS_INDICATOR may say we can change LEDs to off/amber/green.</pre><hr><pre>commit 6fb650d43da3e7054984dc548eaa88765a94d49f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Apr 29 15:25:17 2016 -0400

    USB: leave LPM alone if possible when binding/unbinding interface drivers
    
    When a USB driver is bound to an interface (either through probing or
    by claiming it) or is unbound from an interface, the USB core always
    disables Link Power Management during the transition and then
    re-enables it afterward.  The reason is because the driver might want
    to prevent hub-initiated link power transitions, in which case the HCD
    would have to recalculate the various LPM parameters.  This
    recalculation takes place when LPM is re-enabled and the new
    parameters are sent to the device and its parent hub.
    
    However, if the driver does not want to prevent hub-initiated link
    power transitions then none of this work is necessary.  The parameters
    don't need to be recalculated, and LPM doesn't need to be disabled and
    re-enabled.
    
    It turns out that disabling and enabling LPM can be time-consuming,
    enough so that it interferes with user programs that want to claim and
    release interfaces rapidly via usbfs.  Since the usbfs kernel driver
    doesn't set the disable_hub_initiated_lpm flag, we can speed things up
    and get the user programs to work by leaving LPM alone whenever the
    flag isn't set.
    
    And while we're improving the way disable_hub_initiated_lpm gets used,
    let's also fix its kerneldoc.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Matthew Giassa &lt;matthew@giassa.net&gt;
    CC: Mathias Nyman &lt;mathias.nyman@intel.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 2057d91d8336..dadd1e8dfe09 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -284,7 +284,7 @@ static int usb_probe_interface(struct device *dev)
 	struct usb_device *udev = interface_to_usbdev(intf);
 	const struct usb_device_id *id;
 	int error = -ENODEV;
-	int lpm_disable_error;
+	int lpm_disable_error = -ENODEV;
 
 	dev_dbg(dev, "%s\n", __func__);
 
@@ -336,12 +336,14 @@ static int usb_probe_interface(struct device *dev)
 	 * setting during probe, that should also be fine.  usb_set_interface()
 	 * will attempt to disable LPM, and fail if it can't disable it.
 	 */
-	lpm_disable_error = usb_unlocked_disable_lpm(udev);
-	if (lpm_disable_error &amp;&amp; driver-&gt;disable_hub_initiated_lpm) {
-		dev_err(&amp;intf-&gt;dev, "%s Failed to disable LPM for driver %s\n.",
-				__func__, driver-&gt;name);
-		error = lpm_disable_error;
-		goto err;
+	if (driver-&gt;disable_hub_initiated_lpm) {
+		lpm_disable_error = usb_unlocked_disable_lpm(udev);
+		if (lpm_disable_error) {
+			dev_err(&amp;intf-&gt;dev, "%s Failed to disable LPM for driver %s\n.",
+					__func__, driver-&gt;name);
+			error = lpm_disable_error;
+			goto err;
+		}
 	}
 
 	/* Carry out a deferred switch to altsetting 0 */
@@ -391,7 +393,8 @@ static int usb_unbind_interface(struct device *dev)
 	struct usb_interface *intf = to_usb_interface(dev);
 	struct usb_host_endpoint *ep, **eps = NULL;
 	struct usb_device *udev;
-	int i, j, error, r, lpm_disable_error;
+	int i, j, error, r;
+	int lpm_disable_error = -ENODEV;
 
 	intf-&gt;condition = USB_INTERFACE_UNBINDING;
 
@@ -399,12 +402,13 @@ static int usb_unbind_interface(struct device *dev)
 	udev = interface_to_usbdev(intf);
 	error = usb_autoresume_device(udev);
 
-	/* Hub-initiated LPM policy may change, so attempt to disable LPM until
+	/* If hub-initiated LPM policy may change, attempt to disable LPM until
 	 * the driver is unbound.  If LPM isn't disabled, that's fine because it
 	 * wouldn't be enabled unless all the bound interfaces supported
 	 * hub-initiated LPM.
 	 */
-	lpm_disable_error = usb_unlocked_disable_lpm(udev);
+	if (driver-&gt;disable_hub_initiated_lpm)
+		lpm_disable_error = usb_unlocked_disable_lpm(udev);
 
 	/*
 	 * Terminate all URBs for this interface unless the driver
@@ -505,7 +509,7 @@ int usb_driver_claim_interface(struct usb_driver *driver,
 	struct device *dev;
 	struct usb_device *udev;
 	int retval = 0;
-	int lpm_disable_error;
+	int lpm_disable_error = -ENODEV;
 
 	if (!iface)
 		return -ENODEV;
@@ -526,12 +530,14 @@ int usb_driver_claim_interface(struct usb_driver *driver,
 
 	iface-&gt;condition = USB_INTERFACE_BOUND;
 
-	/* Disable LPM until this driver is bound. */
-	lpm_disable_error = usb_unlocked_disable_lpm(udev);
-	if (lpm_disable_error &amp;&amp; driver-&gt;disable_hub_initiated_lpm) {
-		dev_err(&amp;iface-&gt;dev, "%s Failed to disable LPM for driver %s\n.",
-				__func__, driver-&gt;name);
-		return -ENOMEM;
+	/* See the comment about disabling LPM in usb_probe_interface(). */
+	if (driver-&gt;disable_hub_initiated_lpm) {
+		lpm_disable_error = usb_unlocked_disable_lpm(udev);
+		if (lpm_disable_error) {
+			dev_err(&amp;iface-&gt;dev, "%s Failed to disable LPM for driver %s\n.",
+					__func__, driver-&gt;name);
+			return -ENOMEM;
+		}
 	}
 
 	/* Claimed interfaces are initially inactive (suspended) and
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 01b6c61cf9bb..eba1f10e8cfd 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1068,7 +1068,7 @@ struct usbdrv_wrap {
  *	for interfaces bound to this driver.
  * @soft_unbind: if set to 1, the USB core will not kill URBs and disable
  *	endpoints before calling the driver's disconnect method.
- * @disable_hub_initiated_lpm: if set to 0, the USB core will not allow hubs
+ * @disable_hub_initiated_lpm: if set to 1, the USB core will not allow hubs
  *	to initiate lower power link state transitions when an idle timeout
  *	occurs.  Device-initiated USB 3.0 link PM will still be allowed.
  *</pre>
    <div class="pagination">
        <a href='2_22.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><span>[23]</span><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_24.html'>Next&gt;&gt;</a>
    <div>
</body>
