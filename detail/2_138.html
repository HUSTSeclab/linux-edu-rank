<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_137.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><span>[138]</span><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_139.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit d9b762510c186584a6be0d3ece03e8a4b2ac13a8
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 3 16:15:43 2005 -0400

    [PATCH] USB dummy_hcd: Use separate pdevs for HC and UDC
    
    This patch makes the dummy_hcd driver create separate platform devices for
    the emulated host controller and emulated device controller.  This gives a
    more accurate simulation and will permit testing of situations where only
    one of the two devices is suspended.
    
    This also changes the name of the host controller platform device to match
    the name of the driver.  That way the normal platform bus probe mechanism
    will handle binding the driver to the device.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index ffedf4d1b747..dc0e3233b0e9 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -141,6 +141,8 @@ static const char *const ep_name [] = {
 };
 #define DUMMY_ENDPOINTS	(sizeof(ep_name)/sizeof(char *))
 
+/*-------------------------------------------------------------------------*/
+
 #define FIFO_SIZE		64
 
 struct urbp {
@@ -189,6 +191,11 @@ static inline struct device *dummy_dev (struct dummy *dum)
 	return dummy_to_hcd(dum)-&gt;self.controller;
 }
 
+static inline struct device *udc_dev (struct dummy *dum)
+{
+	return dum-&gt;gadget.dev.parent;
+}
+
 static inline struct dummy *ep_to_dummy (struct dummy_ep *ep)
 {
 	return container_of (ep-&gt;gadget, struct dummy, gadget);
@@ -208,19 +215,6 @@ static struct dummy			*the_controller;
 
 /*-------------------------------------------------------------------------*/
 
-/*
- * This "hardware" may look a bit odd in diagnostics since it's got both
- * host and device sides; and it binds different drivers to each side.
- */
-static struct platform_device		the_pdev;
-
-static struct device_driver dummy_driver = {
-	.name		= (char *) driver_name,
-	.bus		= &amp;platform_bus_type,
-};
-
-/*-------------------------------------------------------------------------*/
-
 /* SLAVE/GADGET SIDE DRIVER
  *
  * This only tracks gadget state.  All the work is done when the host
@@ -324,7 +318,7 @@ dummy_enable (struct usb_ep *_ep, const struct usb_endpoint_descriptor *desc)
 	_ep-&gt;maxpacket = max;
 	ep-&gt;desc = desc;
 
-	dev_dbg (dummy_dev(dum), "enabled %s (ep%d%s-%s) maxpacket %d\n",
+	dev_dbg (udc_dev(dum), "enabled %s (ep%d%s-%s) maxpacket %d\n",
 		_ep-&gt;name,
 		desc-&gt;bEndpointAddress &amp; 0x0f,
 		(desc-&gt;bEndpointAddress &amp; USB_DIR_IN) ? "in" : "out",
@@ -379,7 +373,7 @@ static int dummy_disable (struct usb_ep *_ep)
 	nuke (dum, ep);
 	spin_unlock_irqrestore (&amp;dum-&gt;lock, flags);
 
-	dev_dbg (dummy_dev(dum), "disabled %s\n", _ep-&gt;name);
+	dev_dbg (udc_dev(dum), "disabled %s\n", _ep-&gt;name);
 	return retval;
 }
 
@@ -474,7 +468,7 @@ dummy_queue (struct usb_ep *_ep, struct usb_request *_req, int mem_flags)
 		return -ESHUTDOWN;
 
 #if 0
-	dev_dbg (dummy_dev(dum), "ep %p queue req %p to %s, len %d buf %p\n",
+	dev_dbg (udc_dev(dum), "ep %p queue req %p to %s, len %d buf %p\n",
 			ep, _req, _ep-&gt;name, _req-&gt;length, _req-&gt;buf);
 #endif
 
@@ -537,7 +531,7 @@ static int dummy_dequeue (struct usb_ep *_ep, struct usb_request *_req)
 	spin_unlock_irqrestore (&amp;dum-&gt;lock, flags);
 
 	if (retval == 0) {
-		dev_dbg (dummy_dev(dum),
+		dev_dbg (udc_dev(dum),
 				"dequeued req %p from %s, len %d buf %p\n",
 				req, _ep-&gt;name, _req-&gt;length, _req-&gt;buf);
 		_req-&gt;complete (_ep, _req);
@@ -661,38 +655,6 @@ DEVICE_ATTR (function, S_IRUGO, show_function, NULL);
  * for each driver that registers:  just add to a big root hub.
  */
 
-/* This doesn't need to do anything because the udc device structure is
- * stored inside the hcd and will be deallocated along with it. */
-static void
-dummy_udc_release (struct device *dev) {}
-
-/* This doesn't need to do anything because the pdev structure is
- * statically allocated. */
-static void
-dummy_pdev_release (struct device *dev) {}
-
-static int
-dummy_register_udc (struct dummy *dum)
-{
-	int		rc;
-
-	strcpy (dum-&gt;gadget.dev.bus_id, "udc");
-	dum-&gt;gadget.dev.parent = dummy_dev(dum);
-	dum-&gt;gadget.dev.release = dummy_udc_release;
-
-	rc = device_register (&amp;dum-&gt;gadget.dev);
-	if (rc == 0)
-		device_create_file (&amp;dum-&gt;gadget.dev, &amp;dev_attr_function);
-	return rc;
-}
-
-static void
-dummy_unregister_udc (struct dummy *dum)
-{
-	device_remove_file (&amp;dum-&gt;gadget.dev, &amp;dev_attr_function);
-	device_unregister (&amp;dum-&gt;gadget.dev);
-}
-
 int
 usb_gadget_register_driver (struct usb_gadget_driver *driver)
 {
@@ -711,12 +673,6 @@ usb_gadget_register_driver (struct usb_gadget_driver *driver)
 	 * SLAVE side init ... the layer above hardware, which
 	 * can't enumerate without help from the driver we're binding.
 	 */
-	dum-&gt;gadget.name = gadget_name;
-	dum-&gt;gadget.ops = &amp;dummy_ops;
-	dum-&gt;gadget.is_dualspeed = 1;
-
-	/* maybe claim OTG support, though we won't complete HNP */
-	dum-&gt;gadget.is_otg = (dummy_to_hcd(dum)-&gt;self.otg_port != 0);
 
 	dum-&gt;devstatus = 0;
 	dum-&gt;resuming = 0;
@@ -745,7 +701,7 @@ usb_gadget_register_driver (struct usb_gadget_driver *driver)
 
 	dum-&gt;driver = driver;
 	dum-&gt;gadget.dev.driver = &amp;driver-&gt;driver;
-	dev_dbg (dummy_dev(dum), "binding gadget driver '%s'\n",
+	dev_dbg (udc_dev(dum), "binding gadget driver '%s'\n",
 			driver-&gt;driver.name);
 	if ((retval = driver-&gt;bind (&amp;dum-&gt;gadget)) != 0) {
 		dum-&gt;driver = NULL;
@@ -798,7 +754,7 @@ usb_gadget_unregister_driver (struct usb_gadget_driver *driver)
 	if (!driver || driver != dum-&gt;driver)
 		return -EINVAL;
 
-	dev_dbg (dummy_dev(dum), "unregister gadget driver '%s'\n",
+	dev_dbg (udc_dev(dum), "unregister gadget driver '%s'\n",
 			driver-&gt;driver.name);
 
 	spin_lock_irqsave (&amp;dum-&gt;lock, flags);
@@ -826,6 +782,64 @@ int net2280_set_fifo_mode (struct usb_gadget *gadget, int mode)
 }
 EXPORT_SYMBOL (net2280_set_fifo_mode);
 
+
+/* The gadget structure is stored inside the hcd structure and will be
+ * released along with it. */
+static void
+dummy_gadget_release (struct device *dev)
+{
+#if 0		/* usb_bus_put isn't EXPORTed! */
+	struct dummy	*dum = gadget_dev_to_dummy (dev);
+
+	usb_bus_put (&amp;dummy_to_hcd (dum)-&gt;self);
+#endif
+}
+
+static int dummy_udc_probe (struct device *dev)
+{
+	struct dummy	*dum = the_controller;
+	int		rc;
+
+	dum-&gt;gadget.name = gadget_name;
+	dum-&gt;gadget.ops = &amp;dummy_ops;
+	dum-&gt;gadget.is_dualspeed = 1;
+
+	/* maybe claim OTG support, though we won't complete HNP */
+	dum-&gt;gadget.is_otg = (dummy_to_hcd(dum)-&gt;self.otg_port != 0);
+
+	strcpy (dum-&gt;gadget.dev.bus_id, "gadget");
+	dum-&gt;gadget.dev.parent = dev;
+	dum-&gt;gadget.dev.release = dummy_gadget_release;
+	rc = device_register (&amp;dum-&gt;gadget.dev);
+	if (rc &lt; 0)
+		return rc;
+
+#if 0		/* usb_bus_get isn't EXPORTed! */
+	usb_bus_get (&amp;dummy_to_hcd (dum)-&gt;self);
+#endif
+
+	dev_set_drvdata (dev, dum);
+	device_create_file (&amp;dum-&gt;gadget.dev, &amp;dev_attr_function);
+	return rc;
+}
+
+static int dummy_udc_remove (struct device *dev)
+{
+	struct dummy	*dum = dev_get_drvdata (dev);
+
+	dev_set_drvdata (dev, NULL);
+	device_remove_file (&amp;dum-&gt;gadget.dev, &amp;dev_attr_function);
+	device_unregister (&amp;dum-&gt;gadget.dev);
+	return 0;
+}
+
+static struct device_driver dummy_udc_driver = {
+	.name		= (char *) gadget_name,
+	.bus		= &amp;platform_bus_type,
+	.probe		= dummy_udc_probe,
+	.remove		= dummy_udc_remove,
+};
+
 /*-------------------------------------------------------------------------*/
 
 /* MASTER/HOST SIDE DRIVER
@@ -1184,7 +1198,7 @@ static void dummy_timer (unsigned long _dum)
 			list_for_each_entry (req, &amp;ep-&gt;queue, queue) {
 				list_del_init (&amp;req-&gt;queue);
 				req-&gt;req.status = -EOVERFLOW;
-				dev_dbg (dummy_dev(dum), "stale req = %p\n",
+				dev_dbg (udc_dev(dum), "stale req = %p\n",
 						req);
 
 				spin_unlock (&amp;dum-&gt;lock);
@@ -1207,7 +1221,7 @@ static void dummy_timer (unsigned long _dum)
 					break;
 				dum-&gt;address = setup.wValue;
 				maybe_set_status (urb, 0);
-				dev_dbg (dummy_dev(dum), "set_address = %d\n",
+				dev_dbg (udc_dev(dum), "set_address = %d\n",
 						setup.wValue);
 				value = 0;
 				break;
@@ -1333,7 +1347,7 @@ static void dummy_timer (unsigned long _dum)
 
 			if (value &lt; 0) {
 				if (value != -EOPNOTSUPP)
-					dev_dbg (dummy_dev(dum),
+					dev_dbg (udc_dev(dum),
 						"setup --&gt; %d\n",
 						value);
 				maybe_set_status (urb, -EPIPE);
@@ -1561,7 +1575,7 @@ static int dummy_hub_control (
 						| USB_PORT_STAT_LOW_SPEED
 						| USB_PORT_STAT_HIGH_SPEED);
 				if (dum-&gt;driver) {
-					dev_dbg (dummy_dev(dum),
+					dev_dbg (udc_dev(dum),
 							"disconnect\n");
 					stop_activity (dum, dum-&gt;driver);
 				}
@@ -1643,7 +1657,6 @@ static DEVICE_ATTR (urbs, S_IRUGO, show_urbs, NULL);
 static int dummy_start (struct usb_hcd *hcd)
 {
 	struct dummy		*dum;
-	int			retval;
 
 	dum = hcd_to_dummy (hcd);
 
@@ -1659,9 +1672,6 @@ static int dummy_start (struct usb_hcd *hcd)
 
 	INIT_LIST_HEAD (&amp;dum-&gt;urbp_list);
 
-	if ((retval = dummy_register_udc (dum)) != 0)
-		return retval;
-
 	/* only show a low-power port: just 8mA */
 	hcd-&gt;power_budget = 8;
 	hcd-&gt;state = HC_STATE_RUNNING;
@@ -1682,10 +1692,7 @@ static void dummy_stop (struct usb_hcd *hcd)
 	dum = hcd_to_dummy (hcd);
 
 	device_remove_file (dummy_dev(dum), &amp;dev_attr_urbs);
-
 	usb_gadget_unregister_driver (dum-&gt;driver);
-	dummy_unregister_udc (dum);
-
 	dev_info (dummy_dev(dum), "stopped\n");
 }
 
@@ -1715,7 +1722,7 @@ static const struct hc_driver dummy_hcd = {
 	.hub_control = 		dummy_hub_control,
 };
 
-static int dummy_probe (struct device *dev)
+static int dummy_hcd_probe (struct device *dev)
 {
 	struct usb_hcd		*hcd;
 	int			retval;
@@ -1735,7 +1742,7 @@ static int dummy_probe (struct device *dev)
 	return retval;
 }
 
-static void dummy_remove (struct device *dev)
+static int dummy_hcd_remove (struct device *dev)
 {
 	struct usb_hcd		*hcd;
 
@@ -1743,35 +1750,41 @@ static void dummy_remove (struct device *dev)
 	usb_remove_hcd (hcd);
 	usb_put_hcd (hcd);
 	the_controller = NULL;
+	return 0;
 }
 
-/*-------------------------------------------------------------------------*/
-
-static int dummy_pdev_detect (void)
-{
-	int			retval;
-
-	retval = driver_register (&amp;dummy_driver);
-	if (retval &lt; 0)
-		return retval;
+static struct device_driver dummy_hcd_driver = {
+	.name		= (char *) driver_name,
+	.bus		= &amp;platform_bus_type,
+	.probe		= dummy_hcd_probe,
+	.remove		= dummy_hcd_remove,
+};
 
-	the_pdev.name = "hc";
-	the_pdev.dev.driver = &amp;dummy_driver;
-	the_pdev.dev.release = dummy_pdev_release;
+/*-------------------------------------------------------------------------*/
 
-	retval = platform_device_register (&amp;the_pdev);
-	if (retval &lt; 0)
-		driver_unregister (&amp;dummy_driver);
-	return retval;
-}
+/* These don't need to do anything because the pdev structures are
+ * statically allocated. */
+static void
+dummy_udc_release (struct device *dev) {}
 
-static void dummy_pdev_remove (void)
-{
-	platform_device_unregister (&amp;the_pdev);
-	driver_unregister (&amp;dummy_driver);
-}
+static void
+dummy_hcd_release (struct device *dev) {}
+
+static struct platform_device		the_udc_pdev = {
+	.name		= (char *) gadget_name,
+	.id		= -1,
+	.dev		= {
+		.release	= dummy_udc_release,
+	},
+};
 
-/*-------------------------------------------------------------------------*/
+static struct platform_device		the_hcd_pdev = {
+	.name		= (char *) driver_name,
+	.id		= -1,
+	.dev		= {
+		.release	= dummy_hcd_release,
+	},
+};
 
 static int __init init (void)
 {
@@ -1779,17 +1792,39 @@ static int __init init (void)
 
 	if (usb_disabled ())
 		return -ENODEV;
-	if ((retval = dummy_pdev_detect ()) != 0)
+
+	retval = driver_register (&amp;dummy_hcd_driver);
+	if (retval &lt; 0)
 		return retval;
-	if ((retval = dummy_probe (&amp;the_pdev.dev)) != 0)
-		dummy_pdev_remove ();
+
+	retval = driver_register (&amp;dummy_udc_driver);
+	if (retval &lt; 0)
+		goto err_register_udc_driver;
+
+	retval = platform_device_register (&amp;the_hcd_pdev);
+	if (retval &lt; 0)
+		goto err_register_hcd;
+
+	retval = platform_device_register (&amp;the_udc_pdev);
+	if (retval &lt; 0)
+		goto err_register_udc;
+	return retval;
+
+err_register_udc:
+	platform_device_unregister (&amp;the_hcd_pdev);
+err_register_hcd:
+	driver_unregister (&amp;dummy_udc_driver);
+err_register_udc_driver:
+	driver_unregister (&amp;dummy_hcd_driver);
 	return retval;
 }
 module_init (init);
 
 static void __exit cleanup (void)
 {
-	dummy_remove (&amp;the_pdev.dev);
-	dummy_pdev_remove ();
+	platform_device_unregister (&amp;the_udc_pdev);
+	platform_device_unregister (&amp;the_hcd_pdev);
+	driver_unregister (&amp;dummy_udc_driver);
+	driver_unregister (&amp;dummy_hcd_driver);
 }
 module_exit (cleanup);</pre><hr><pre>commit c2db8b5e5692a6f35913a829607ee6efde3c7cbd
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Apr 29 16:30:48 2005 -0400

    [PATCH] USB: dummy_hcd: USB_PORT_FEAT changed to USB_PORT_STAT
    
    This patch makes some cosmetic changes to dummy_hcd:
    
            Minor alterations of comments and whitespace.
    
            Replace USB_PORT_FEAT_xxx with USB_PORT_STAT_xxx.  This is
            appropriate as the values are stored in a status variable
            and they aren't feature indices.  Also it allows the
            elimination of a bunch of awkward bit shift operations.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index e9b95df5b23d..ffedf4d1b747 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -601,7 +601,7 @@ static int dummy_wakeup (struct usb_gadget *_gadget)
 	struct dummy	*dum;
 
 	dum = gadget_to_dummy (_gadget);
-	if (!(dum-&gt;port_status &amp; (1 &lt;&lt; USB_PORT_FEAT_SUSPEND))
+	if (!(dum-&gt;port_status &amp; USB_PORT_STAT_SUSPEND)
 			|| !(dum-&gt;devstatus &amp;
 				( (1 &lt;&lt; USB_DEVICE_B_HNP_ENABLE)
 				| (1 &lt;&lt; USB_DEVICE_REMOTE_WAKEUP))))
@@ -609,7 +609,7 @@ static int dummy_wakeup (struct usb_gadget *_gadget)
 
 	/* hub notices our request, issues downstream resume, etc */
 	dum-&gt;resuming = 1;
-	dum-&gt;port_status |= (1 &lt;&lt; USB_PORT_FEAT_C_SUSPEND);
+	dum-&gt;port_status |= (USB_PORT_STAT_C_SUSPEND &lt;&lt; 16);
 	return 0;
 }
 
@@ -661,15 +661,15 @@ DEVICE_ATTR (function, S_IRUGO, show_function, NULL);
  * for each driver that registers:  just add to a big root hub.
  */
 
+/* This doesn't need to do anything because the udc device structure is
+ * stored inside the hcd and will be deallocated along with it. */
 static void
-dummy_udc_release (struct device *dev)
-{
-}
+dummy_udc_release (struct device *dev) {}
 
+/* This doesn't need to do anything because the pdev structure is
+ * statically allocated. */
 static void
-dummy_pdev_release (struct device *dev)
-{
-}
+dummy_pdev_release (struct device *dev) {}
 
 static int
 dummy_register_udc (struct dummy *dum)
@@ -753,15 +753,13 @@ usb_gadget_register_driver (struct usb_gadget_driver *driver)
 		return retval;
 	}
 
-	// FIXME: Check these calls for errors and re-order
 	driver-&gt;driver.bus = dum-&gt;gadget.dev.parent-&gt;bus;
 	driver_register (&amp;driver-&gt;driver);
-
 	device_bind_driver (&amp;dum-&gt;gadget.dev);
 
 	/* khubd will enumerate this in a while */
 	dum-&gt;port_status |= USB_PORT_STAT_CONNECTION
-		| (1 &lt;&lt; USB_PORT_FEAT_C_CONNECTION);
+		| (USB_PORT_STAT_C_CONNECTION &lt;&lt; 16);
 	return 0;
 }
 EXPORT_SYMBOL (usb_gadget_register_driver);
@@ -807,14 +805,13 @@ usb_gadget_unregister_driver (struct usb_gadget_driver *driver)
 	stop_activity (dum, driver);
 	dum-&gt;port_status &amp;= ~(USB_PORT_STAT_CONNECTION | USB_PORT_STAT_ENABLE |
 			USB_PORT_STAT_LOW_SPEED | USB_PORT_STAT_HIGH_SPEED);
-	dum-&gt;port_status |= (1 &lt;&lt; USB_PORT_FEAT_C_CONNECTION);
+	dum-&gt;port_status |= (USB_PORT_STAT_C_CONNECTION &lt;&lt; 16);
 	spin_unlock_irqrestore (&amp;dum-&gt;lock, flags);
 
 	driver-&gt;unbind (&amp;dum-&gt;gadget);
 	dum-&gt;driver = NULL;
 
 	device_release_driver (&amp;dum-&gt;gadget.dev);
-
 	driver_unregister (&amp;driver-&gt;driver);
 
 	return 0;
@@ -1406,11 +1403,11 @@ static void dummy_timer (unsigned long _dum)
 /*-------------------------------------------------------------------------*/
 
 #define PORT_C_MASK \
-	 ((1 &lt;&lt; USB_PORT_FEAT_C_CONNECTION) \
-	| (1 &lt;&lt; USB_PORT_FEAT_C_ENABLE) \
-	| (1 &lt;&lt; USB_PORT_FEAT_C_SUSPEND) \
-	| (1 &lt;&lt; USB_PORT_FEAT_C_OVER_CURRENT) \
-	| (1 &lt;&lt; USB_PORT_FEAT_C_RESET))
+	((USB_PORT_STAT_C_CONNECTION \
+	| USB_PORT_STAT_C_ENABLE \
+	| USB_PORT_STAT_C_SUSPEND \
+	| USB_PORT_STAT_C_OVERCURRENT \
+	| USB_PORT_STAT_C_RESET) &lt;&lt; 16)
 
 static int dummy_hub_status (struct usb_hcd *hcd, char *buf)
 {
@@ -1465,7 +1462,7 @@ static int dummy_hub_control (
 	case ClearPortFeature:
 		switch (wValue) {
 		case USB_PORT_FEAT_SUSPEND:
-			if (dum-&gt;port_status &amp; (1 &lt;&lt; USB_PORT_FEAT_SUSPEND)) {
+			if (dum-&gt;port_status &amp; USB_PORT_STAT_SUSPEND) {
 				/* 20msec resume signaling */
 				dum-&gt;resuming = 1;
 				dum-&gt;re_timeout = jiffies +
@@ -1495,8 +1492,8 @@ static int dummy_hub_control (
 		 * complete it!!
 		 */
 		if (dum-&gt;resuming &amp;&amp; time_after (jiffies, dum-&gt;re_timeout)) {
-			dum-&gt;port_status |= (1 &lt;&lt; USB_PORT_FEAT_C_SUSPEND);
-			dum-&gt;port_status &amp;= ~(1 &lt;&lt; USB_PORT_FEAT_SUSPEND);
+			dum-&gt;port_status |= (USB_PORT_STAT_C_SUSPEND &lt;&lt; 16);
+			dum-&gt;port_status &amp;= ~USB_PORT_STAT_SUSPEND;
 			dum-&gt;resuming = 0;
 			dum-&gt;re_timeout = 0;
 			if (dum-&gt;driver &amp;&amp; dum-&gt;driver-&gt;resume) {
@@ -1505,10 +1502,10 @@ static int dummy_hub_control (
 				spin_lock (&amp;dum-&gt;lock);
 			}
 		}
-		if ((dum-&gt;port_status &amp; (1 &lt;&lt; USB_PORT_FEAT_RESET)) != 0
+		if ((dum-&gt;port_status &amp; USB_PORT_STAT_RESET) != 0
 				&amp;&amp; time_after (jiffies, dum-&gt;re_timeout)) {
-			dum-&gt;port_status |= (1 &lt;&lt; USB_PORT_FEAT_C_RESET);
-			dum-&gt;port_status &amp;= ~(1 &lt;&lt; USB_PORT_FEAT_RESET);
+			dum-&gt;port_status |= (USB_PORT_STAT_C_RESET &lt;&lt; 16);
+			dum-&gt;port_status &amp;= ~USB_PORT_STAT_RESET;
 			dum-&gt;re_timeout = 0;
 			if (dum-&gt;driver) {
 				dum-&gt;port_status |= USB_PORT_STAT_ENABLE;
@@ -1540,10 +1537,9 @@ static int dummy_hub_control (
 	case SetPortFeature:
 		switch (wValue) {
 		case USB_PORT_FEAT_SUSPEND:
-			if ((dum-&gt;port_status &amp; (1 &lt;&lt; USB_PORT_FEAT_SUSPEND))
+			if ((dum-&gt;port_status &amp; USB_PORT_STAT_SUSPEND)
 					== 0) {
-				dum-&gt;port_status |=
-						(1 &lt;&lt; USB_PORT_FEAT_SUSPEND);
+				dum-&gt;port_status |= USB_PORT_STAT_SUSPEND;
 				if (dum-&gt;driver &amp;&amp; dum-&gt;driver-&gt;suspend) {
 					spin_unlock (&amp;dum-&gt;lock);
 					dum-&gt;driver-&gt;suspend (&amp;dum-&gt;gadget);</pre><hr><pre>commit 5742b0c95026c817d9c266174ca39a909e8d38ca
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon May 2 11:25:17 2005 -0400

    [PATCH] USB dummy_hcd: Partial OTG emulation
    
    Partial OTG support for dummy_hcd, mostly as a framework for further work.
    It emulates the new OTG flags in the host and peripheral frameworks, if
    that option is configured.  But it's incomplete:
    
      - Resetting the peripheral needs to clear the OTG state bits;
        a second enumeration won't work correctly.
    
      - This stops modeling HNP right when roles should switch the first time.
        It should probably disconnect, then set the usb_bus.is_b_host and
        usb_gadget.is_a_peripheral flags; then it'd enumerate almost normally,
        except for the role reversal.  Roles could then switch a second time,
        back to "normal" (with those flags cleared).
    
      - SRP should be modeled as "resume from port-unpowered", which is
        a state that usbcore doesn't yet use.
    
    HNP can be triggered by enabling the OTG whitelist and configuring a
    gadget driver that's not in that list; or by configuring Gadget Zero
    to identify itself as the HNP test device.
    
    Sent-by: David Brownell &lt;david-b@pacbell.net&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index 1918d10f7569..e9b95df5b23d 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -601,8 +601,10 @@ static int dummy_wakeup (struct usb_gadget *_gadget)
 	struct dummy	*dum;
 
 	dum = gadget_to_dummy (_gadget);
-	if ((dum-&gt;devstatus &amp; (1 &lt;&lt; USB_DEVICE_REMOTE_WAKEUP)) == 0
-			|| !(dum-&gt;port_status &amp; (1 &lt;&lt; USB_PORT_FEAT_SUSPEND)))
+	if (!(dum-&gt;port_status &amp; (1 &lt;&lt; USB_PORT_FEAT_SUSPEND))
+			|| !(dum-&gt;devstatus &amp;
+				( (1 &lt;&lt; USB_DEVICE_B_HNP_ENABLE)
+				| (1 &lt;&lt; USB_DEVICE_REMOTE_WAKEUP))))
 		return -EINVAL;
 
 	/* hub notices our request, issues downstream resume, etc */
@@ -713,6 +715,9 @@ usb_gadget_register_driver (struct usb_gadget_driver *driver)
 	dum-&gt;gadget.ops = &amp;dummy_ops;
 	dum-&gt;gadget.is_dualspeed = 1;
 
+	/* maybe claim OTG support, though we won't complete HNP */
+	dum-&gt;gadget.is_otg = (dummy_to_hcd(dum)-&gt;self.otg_port != 0);
+
 	dum-&gt;devstatus = 0;
 	dum-&gt;resuming = 0;
 
@@ -1215,6 +1220,16 @@ static void dummy_timer (unsigned long _dum)
 					switch (setup.wValue) {
 					case USB_DEVICE_REMOTE_WAKEUP:
 						break;
+					case USB_DEVICE_B_HNP_ENABLE:
+						dum-&gt;gadget.b_hnp_enable = 1;
+						break;
+					case USB_DEVICE_A_HNP_SUPPORT:
+						dum-&gt;gadget.a_hnp_support = 1;
+						break;
+					case USB_DEVICE_A_ALT_HNP_SUPPORT:
+						dum-&gt;gadget.a_alt_hnp_support
+							= 1;
+						break;
 					default:
 						value = -EOPNOTSUPP;
 					}
@@ -1533,6 +1548,13 @@ static int dummy_hub_control (
 					spin_unlock (&amp;dum-&gt;lock);
 					dum-&gt;driver-&gt;suspend (&amp;dum-&gt;gadget);
 					spin_lock (&amp;dum-&gt;lock);
+					/* HNP would happen here; for now we
+					 * assume b_bus_req is always true.
+					 */
+					if (((1 &lt;&lt; USB_DEVICE_B_HNP_ENABLE)
+							&amp; dum-&gt;devstatus) != 0)
+						dev_dbg (dummy_dev(dum),
+							"no HNP yet!\n");
 				}
 			}
 			break;
@@ -1648,6 +1670,10 @@ static int dummy_start (struct usb_hcd *hcd)
 	hcd-&gt;power_budget = 8;
 	hcd-&gt;state = HC_STATE_RUNNING;
 
+#ifdef CONFIG_USB_OTG
+	hcd-&gt;self.otg_port = 1;
+#endif
+
 	/* FIXME 'urbs' should be a per-device thing, maybe in usbcore */
 	device_create_file (dummy_dev(dum), &amp;dev_attr_urbs);
 	return 0;</pre><hr><pre>commit 247f3105636caa9d1d8a4c3dfb755de42633bc80
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Apr 25 11:28:04 2005 -0400

    [PATCH] USB HCDs: no longer need to register root hub
    
    This patch changes the host controller drivers; they no longer need to
    register their root hubs because usbcore will take care of it for them.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index 9d37fc771b27..1918d10f7569 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -1625,7 +1625,6 @@ static DEVICE_ATTR (urbs, S_IRUGO, show_urbs, NULL);
 static int dummy_start (struct usb_hcd *hcd)
 {
 	struct dummy		*dum;
-	struct usb_device	*root;
 	int			retval;
 
 	dum = hcd_to_dummy (hcd);
@@ -1642,35 +1641,16 @@ static int dummy_start (struct usb_hcd *hcd)
 
 	INIT_LIST_HEAD (&amp;dum-&gt;urbp_list);
 
-	root = usb_alloc_dev (NULL, &amp;hcd-&gt;self, 0);
-	if (!root)
-		return -ENOMEM;
+	if ((retval = dummy_register_udc (dum)) != 0)
+		return retval;
 
 	/* only show a low-power port: just 8mA */
 	hcd-&gt;power_budget = 8;
-
-	/* root hub enters addressed state... */
 	hcd-&gt;state = HC_STATE_RUNNING;
-	root-&gt;speed = USB_SPEED_HIGH;
-
-	/* ...then configured, so khubd sees us. */
-	if ((retval = usb_hcd_register_root_hub (root, hcd)) != 0) {
-		goto err1;
-	}
-
-	if ((retval = dummy_register_udc (dum)) != 0)
-		goto err2;
 
 	/* FIXME 'urbs' should be a per-device thing, maybe in usbcore */
 	device_create_file (dummy_dev(dum), &amp;dev_attr_urbs);
 	return 0;
-
- err2:
-	usb_disconnect (&amp;hcd-&gt;self.root_hub);
- err1:
-	usb_put_dev (root);
-	hcd-&gt;state = HC_STATE_QUIESCING;
-	return retval;
 }
 
 static void dummy_stop (struct usb_hcd *hcd)
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index bc69bd7acebe..527abc693b17 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -492,8 +492,6 @@ static int ehci_start (struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
 	u32			temp;
-	struct usb_device	*udev;
-	struct usb_bus		*bus;
 	int			retval;
 	u32			hcc_params;
 	u8                      sbrn = 0;
@@ -631,17 +629,6 @@ static int ehci_start (struct usb_hcd *hcd)
 
 	/* set async sleep time = 10 us ... ? */
 
-	/* wire up the root hub */
-	bus = hcd_to_bus (hcd);
-	udev = first ? usb_alloc_dev (NULL, bus, 0) : bus-&gt;root_hub;
-	if (!udev) {
-done2:
-		ehci_mem_cleanup (ehci);
-		return -ENOMEM;
-	}
-	udev-&gt;speed = USB_SPEED_HIGH;
-	udev-&gt;state = first ? USB_STATE_ATTACHED : USB_STATE_CONFIGURED;
-
 	/*
 	 * Start, enabling full USB 2.0 functionality ... usb 1.1 devices
 	 * are explicitly handed to companion controller(s), so no TT is
@@ -664,24 +651,6 @@ static int ehci_start (struct usb_hcd *hcd)
 		first ? "initialized" : "restarted",
 		temp &gt;&gt; 8, temp &amp; 0xff, DRIVER_VERSION);
 
-	/*
-	 * From here on, khubd concurrently accesses the root
-	 * hub; drivers will be talking to enumerated devices.
-	 * (On restart paths, khubd already knows about the root
-	 * hub and could find work as soon as we wrote FLAG_CF.)
-	 *
-	 * Before this point the HC was idle/ready.  After, khubd
-	 * and device drivers may start it running.
-	 */
-	if (first &amp;&amp; usb_hcd_register_root_hub (udev, hcd) != 0) {
-		if (hcd-&gt;state == HC_STATE_RUNNING)
-			ehci_quiesce (ehci);
-		ehci_reset (ehci);
-		usb_put_dev (udev); 
-		retval = -ENODEV;
-		goto done2;
-	}
-
 	writel (INTR_MASK, &amp;ehci-&gt;regs-&gt;intr_enable); /* Turn On Interrupts */
 
 	if (first)
diff --git a/drivers/usb/host/isp116x-hcd.c b/drivers/usb/host/isp116x-hcd.c
index 1183988fdf54..ff0a168e8eed 100644
--- a/drivers/usb/host/isp116x-hcd.c
+++ b/drivers/usb/host/isp116x-hcd.c
@@ -1547,7 +1547,6 @@ static int isp116x_start(struct usb_hcd *hcd)
 {
 	struct isp116x *isp116x = hcd_to_isp116x(hcd);
 	struct isp116x_platform_data *board = isp116x-&gt;board;
-	struct usb_device *udev;
 	u32 val;
 	unsigned long flags;
 
@@ -1609,24 +1608,9 @@ static int isp116x_start(struct usb_hcd *hcd)
 	isp116x-&gt;rhstatus = isp116x_read_reg32(isp116x, HCRHSTATUS);
 
 	isp116x_write_reg32(isp116x, HCFMINTVL, 0x27782edf);
-	spin_unlock_irqrestore(&amp;isp116x-&gt;lock, flags);
-
-	udev = usb_alloc_dev(NULL, &amp;hcd-&gt;self, 0);
-	if (!udev) {
-		isp116x_stop(hcd);
-		return -ENOMEM;
-	}
 
-	udev-&gt;speed = USB_SPEED_FULL;
 	hcd-&gt;state = HC_STATE_RUNNING;
 
-	if (usb_hcd_register_root_hub(udev, hcd) != 0) {
-		isp116x_stop(hcd);
-		usb_put_dev(udev);
-		return -ENODEV;
-	}
-
-	spin_lock_irqsave(&amp;isp116x-&gt;lock, flags);
 	/* Set up interrupts */
 	isp116x-&gt;intenb = HCINT_MIE | HCINT_RHSC | HCINT_UE;
 	if (board-&gt;remote_wakeup_enable)
diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index 0da996191251..13cd2177b557 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -505,13 +505,10 @@ static int ohci_init (struct ohci_hcd *ohci)
 /* Start an OHCI controller, set the BUS operational
  * resets USB and controller
  * enable interrupts 
- * connect the virtual root hub
  */
 static int ohci_run (struct ohci_hcd *ohci)
 {
   	u32			mask, temp;
-  	struct usb_device	*udev;
-  	struct usb_bus		*bus;
 	int			first = ohci-&gt;fminterval == 0;
 
 	disable (ohci);
@@ -672,36 +669,13 @@ static int ohci_run (struct ohci_hcd *ohci)
 
 	// POTPGT delay is bits 24-31, in 2 ms units.
 	mdelay ((temp &gt;&gt; 23) &amp; 0x1fe);
-	bus = &amp;ohci_to_hcd(ohci)-&gt;self;
 	ohci_to_hcd(ohci)-&gt;state = HC_STATE_RUNNING;
 
 	ohci_dump (ohci, 1);
 
-	udev = bus-&gt;root_hub;
-	if (udev) {
-		return 0;
-	}
- 
-	/* connect the virtual root hub */
-	udev = usb_alloc_dev (NULL, bus, 0);
-	if (!udev) {
-		disable (ohci);
-		ohci-&gt;hc_control &amp;= ~OHCI_CTRL_HCFS;
-		ohci_writel (ohci, ohci-&gt;hc_control, &amp;ohci-&gt;regs-&gt;control);
-		return -ENOMEM;
-	}
-
-	udev-&gt;speed = USB_SPEED_FULL;
-	if (usb_hcd_register_root_hub (udev, ohci_to_hcd(ohci)) != 0) {
-		usb_put_dev (udev);
-		disable (ohci);
-		ohci-&gt;hc_control &amp;= ~OHCI_CTRL_HCFS;
-		ohci_writel (ohci, ohci-&gt;hc_control, &amp;ohci-&gt;regs-&gt;control);
-		return -ENODEV;
-	}
+	if (ohci_to_hcd(ohci)-&gt;self.root_hub == NULL)
+		create_debug_files (ohci);
 
-	register_reboot_notifier (&amp;ohci-&gt;reboot_notifier);
-	create_debug_files (ohci);
 	return 0;
 }
 
diff --git a/drivers/usb/host/sl811-hcd.c b/drivers/usb/host/sl811-hcd.c
index 1f2d00fe983a..6c3f910bc307 100644
--- a/drivers/usb/host/sl811-hcd.c
+++ b/drivers/usb/host/sl811-hcd.c
@@ -1563,15 +1563,8 @@ static int
 sl811h_start(struct usb_hcd *hcd)
 {
 	struct sl811		*sl811 = hcd_to_sl811(hcd);
-	struct usb_device	*udev;
 
 	/* chip has been reset, VBUS power is off */
-
-	udev = usb_alloc_dev(NULL, &amp;hcd-&gt;self, 0);
-	if (!udev)
-		return -ENOMEM;
-
-	udev-&gt;speed = USB_SPEED_FULL;
 	hcd-&gt;state = HC_STATE_RUNNING;
 
 	if (sl811-&gt;board) {
@@ -1579,12 +1572,6 @@ sl811h_start(struct usb_hcd *hcd)
 		hcd-&gt;power_budget = sl811-&gt;board-&gt;power * 2;
 	}
 
-	if (usb_hcd_register_root_hub(udev, hcd) != 0) {
-		usb_put_dev(udev);
-		sl811h_stop(hcd);
-		return -ENODEV;
-	}
-
 	/* enable power and interupts */
 	port_power(sl811, 1);
 
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 6b87bd74b046..fdf54295da73 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -562,7 +562,6 @@ static int uhci_start(struct usb_hcd *hcd)
 	int retval = -EBUSY;
 	int i;
 	dma_addr_t dma_handle;
-	struct usb_device *udev;
 	struct dentry *dentry;
 
 	hcd-&gt;uses_new_polling = 1;
@@ -626,14 +625,6 @@ static int uhci_start(struct usb_hcd *hcd)
 		goto err_create_qh_pool;
 	}
 
-	/* Initialize the root hub */
-
-	udev = usb_alloc_dev(NULL, &amp;hcd-&gt;self, 0);
-	if (!udev) {
-		dev_err(uhci_dev(uhci), "unable to allocate root hub\n");
-		goto err_alloc_root_hub;
-	}
-
 	uhci-&gt;term_td = uhci_alloc_td(uhci);
 	if (!uhci-&gt;term_td) {
 		dev_err(uhci_dev(uhci), "unable to allocate terminating TD\n");
@@ -713,24 +704,11 @@ static int uhci_start(struct usb_hcd *hcd)
 
 	configure_hc(uhci);
 	start_rh(uhci);
-
-	udev-&gt;speed = USB_SPEED_FULL;
-
-	if (usb_hcd_register_root_hub(udev, hcd) != 0) {
-		dev_err(uhci_dev(uhci), "unable to start root hub\n");
-		retval = -ENOMEM;
-		goto err_start_root_hub;
-	}
-
 	return 0;
 
 /*
  * error exits:
  */
-err_start_root_hub:
-	reset_hc(uhci);
-	del_timer_sync(&amp;uhci-&gt;stall_timer);
-
 err_alloc_skelqh:
 	for (i = 0; i &lt; UHCI_NUM_SKELQH; i++)
 		if (uhci-&gt;skelqh[i]) {
@@ -742,9 +720,6 @@ static int uhci_start(struct usb_hcd *hcd)
 	uhci-&gt;term_td = NULL;
 
 err_alloc_term_td:
-	usb_put_dev(udev);
-
-err_alloc_root_hub:
 	dma_pool_destroy(uhci-&gt;qh_pool);
 	uhci-&gt;qh_pool = NULL;
 </pre><hr><pre>commit 8ec8d20b21f00a36343ca0ebd6c6be9421724a1e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Apr 25 11:25:17 2005 -0400

    [PATCH] usbcore: register root hub in usb_add_hcd
    
    This patch makes usbcore automatically allocate and register the root hub
    device for a new host controller when the controller is registered.  This
    way the HCDs don't all have to include the same boilerplate code.  As a
    pleasant side benefit, the register_root_hub routine can now be made
    static and not EXPORTed.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 1180c157b717..83e732a0d64a 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -832,30 +832,22 @@ static void usb_deregister_bus (struct usb_bus *bus)
 }
 
 /**
- * usb_hcd_register_root_hub - called by HCD to register its root hub 
+ * register_root_hub - called by usb_add_hcd() to register a root hub
  * @usb_dev: the usb root hub device to be registered.
  * @hcd: host controller for this root hub
  *
- * The USB host controller calls this function to register the root hub
- * properly with the USB subsystem.  It sets up the device properly in
- * the device tree and stores the root_hub pointer in the bus structure,
- * then calls usb_new_device() to register the usb device.  It also
- * assigns the root hub's USB address (always 1).
+ * This function registers the root hub with the USB subsystem.  It sets up
+ * the device properly in the device tree and stores the root_hub pointer
+ * in the bus structure, then calls usb_new_device() to register the usb
+ * device.  It also assigns the root hub's USB address (always 1).
  */
-int usb_hcd_register_root_hub (struct usb_device *usb_dev, struct usb_hcd *hcd)
+static int register_root_hub (struct usb_device *usb_dev,
+		struct usb_hcd *hcd)
 {
 	struct device *parent_dev = hcd-&gt;self.controller;
 	const int devnum = 1;
 	int retval;
 
-	/* hcd-&gt;driver-&gt;start() reported can_wakeup, probably with
-	 * assistance from board's boot firmware.
-	 * NOTE:  normal devices won't enable wakeup by default.
-	 */
-	if (hcd-&gt;can_wakeup)
-		dev_dbg (parent_dev, "supports USB remote wakeup\n");
-	hcd-&gt;remote_wakeup = hcd-&gt;can_wakeup;
-
 	usb_dev-&gt;devnum = devnum;
 	usb_dev-&gt;bus-&gt;devnum_next = devnum + 1;
 	memset (&amp;usb_dev-&gt;bus-&gt;devmap.devicemap, 0,
@@ -898,7 +890,6 @@ int usb_hcd_register_root_hub (struct usb_device *usb_dev, struct usb_hcd *hcd)
 
 	return retval;
 }
-EXPORT_SYMBOL_GPL(usb_hcd_register_root_hub);
 
 void usb_enable_root_hub_irq (struct usb_bus *bus)
 {
@@ -1724,7 +1715,8 @@ EXPORT_SYMBOL (usb_put_hcd);
 int usb_add_hcd(struct usb_hcd *hcd,
 		unsigned int irqnum, unsigned long irqflags)
 {
-	int	retval;
+	int retval;
+	struct usb_device *rhdev;
 
 	dev_info(hcd-&gt;self.controller, "%s\n", hcd-&gt;product_desc);
 
@@ -1740,7 +1732,7 @@ int usb_add_hcd(struct usb_hcd *hcd,
 	}
 
 	if ((retval = usb_register_bus(&amp;hcd-&gt;self)) &lt; 0)
-		goto err1;
+		goto err_register_bus;
 
 	if (hcd-&gt;driver-&gt;irq) {
 		char	buf[8], *bufp = buf;
@@ -1757,7 +1749,7 @@ int usb_add_hcd(struct usb_hcd *hcd,
 				hcd-&gt;irq_descr, hcd)) != 0) {
 			dev_err(hcd-&gt;self.controller,
 					"request interrupt %s failed\n", bufp);
-			goto err2;
+			goto err_request_irq;
 		}
 		hcd-&gt;irq = irqnum;
 		dev_info(hcd-&gt;self.controller, "irq %s, %s 0x%08llx\n", bufp,
@@ -1773,21 +1765,55 @@ int usb_add_hcd(struct usb_hcd *hcd,
 					(unsigned long long)hcd-&gt;rsrc_start);
 	}
 
+	/* Allocate the root hub before calling hcd-&gt;driver-&gt;start(),
+	 * but don't register it until afterward so that the hardware
+	 * is running.
+	 */
+	if ((rhdev = usb_alloc_dev(NULL, &amp;hcd-&gt;self, 0)) == NULL) {
+		dev_err(hcd-&gt;self.controller, "unable to allocate root hub\n");
+		retval = -ENOMEM;
+		goto err_allocate_root_hub;
+	}
+	rhdev-&gt;speed = (hcd-&gt;driver-&gt;flags &amp; HCD_USB2) ? USB_SPEED_HIGH :
+			USB_SPEED_FULL;
+
+	/* Although in principle hcd-&gt;driver-&gt;start() might need to use rhdev,
+	 * none of the current drivers do.
+	 */
 	if ((retval = hcd-&gt;driver-&gt;start(hcd)) &lt; 0) {
 		dev_err(hcd-&gt;self.controller, "startup error %d\n", retval);
-		goto err3;
+		goto err_hcd_driver_start;
 	}
 
+	/* hcd-&gt;driver-&gt;start() reported can_wakeup, probably with
+	 * assistance from board's boot firmware.
+	 * NOTE:  normal devices won't enable wakeup by default.
+	 */
+	if (hcd-&gt;can_wakeup)
+		dev_dbg(hcd-&gt;self.controller, "supports USB remote wakeup\n");
+	hcd-&gt;remote_wakeup = hcd-&gt;can_wakeup;
+
+	if ((retval = register_root_hub(rhdev, hcd)) != 0)
+		goto err_register_root_hub;
+
 	if (hcd-&gt;uses_new_polling &amp;&amp; hcd-&gt;poll_rh)
 		usb_hcd_poll_rh_status(hcd);
 	return retval;
 
- err3:
+ err_register_root_hub:
+	hcd-&gt;driver-&gt;stop(hcd);
+
+ err_hcd_driver_start:
+	usb_put_dev(rhdev);
+
+ err_allocate_root_hub:
 	if (hcd-&gt;irq &gt;= 0)
 		free_irq(irqnum, hcd);
- err2:
+
+ err_request_irq:
 	usb_deregister_bus(&amp;hcd-&gt;self);
- err1:
+
+ err_register_bus:
 	hcd_buffer_destroy(hcd);
 	return retval;
 } 
diff --git a/drivers/usb/core/hcd.h b/drivers/usb/core/hcd.h
index 3837f68bb7b3..8dc13cde2f73 100644
--- a/drivers/usb/core/hcd.h
+++ b/drivers/usb/core/hcd.h
@@ -353,9 +353,6 @@ extern long usb_calc_bus_time (int speed, int is_input,
 
 extern struct usb_bus *usb_alloc_bus (struct usb_operations *);
 
-extern int usb_hcd_register_root_hub (struct usb_device *usb_dev,
-		struct usb_hcd *hcd);
-
 extern void usb_hcd_resume_root_hub (struct usb_hcd *hcd);
 
 extern void usb_set_device_state(struct usb_device *udev,</pre><hr><pre>commit bc96c0ad1ed0c938fefc0423aa99f086c5a2a1ea
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Apr 25 11:21:31 2005 -0400

    [PATCH] ohci-omap, sl811, dummy: remove hub_set_power_budget
    
    This patch changes the HCDs that used the old hub_set_power_budget call,
    making them use the new hcd-&gt;power_budget field instead.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: David Brownell &lt;dbrownell@users.sourceforge.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index c039d2fbe7ab..9d37fc771b27 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -1646,6 +1646,9 @@ static int dummy_start (struct usb_hcd *hcd)
 	if (!root)
 		return -ENOMEM;
 
+	/* only show a low-power port: just 8mA */
+	hcd-&gt;power_budget = 8;
+
 	/* root hub enters addressed state... */
 	hcd-&gt;state = HC_STATE_RUNNING;
 	root-&gt;speed = USB_SPEED_HIGH;
@@ -1655,9 +1658,6 @@ static int dummy_start (struct usb_hcd *hcd)
 		goto err1;
 	}
 
-	/* only show a low-power port: just 8mA */
-	hub_set_power_budget (root, 8);
-
 	if ((retval = dummy_register_udc (dum)) != 0)
 		goto err2;
 
diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index 32120042ab65..0da996191251 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -699,8 +699,6 @@ static int ohci_run (struct ohci_hcd *ohci)
 		ohci_writel (ohci, ohci-&gt;hc_control, &amp;ohci-&gt;regs-&gt;control);
 		return -ENODEV;
 	}
-	if (ohci-&gt;power_budget)
-		hub_set_power_budget(udev, ohci-&gt;power_budget);
 
 	register_reboot_notifier (&amp;ohci-&gt;reboot_notifier);
 	create_debug_files (ohci);
diff --git a/drivers/usb/host/ohci-omap.c b/drivers/usb/host/ohci-omap.c
index 8aab5907afe9..b62d69937694 100644
--- a/drivers/usb/host/ohci-omap.c
+++ b/drivers/usb/host/ohci-omap.c
@@ -181,7 +181,7 @@ static int omap_start_hc(struct ohci_hcd *ohci, struct platform_device *pdev)
 	if (config-&gt;otg) {
 		ohci_to_hcd(ohci)-&gt;self.otg_port = config-&gt;otg;
 		/* default/minimum OTG power budget:  8 mA */
-		ohci-&gt;power_budget = 8;
+		ohci_to_hcd(ohci)-&gt;power_budget = 8;
 	}
 
 	/* boards can use OTG transceivers in non-OTG modes */
@@ -230,7 +230,7 @@ static int omap_start_hc(struct ohci_hcd *ohci, struct platform_device *pdev)
 
 		/* TPS2045 switch for internal transceiver (port 1) */
 		if (machine_is_omap_osk()) {
-			ohci-&gt;power_budget = 250;
+			ohci_to_hcd(ohci)-&gt;power_budget = 250;
 
 			rh &amp;= ~RH_A_NOCP;
 
diff --git a/drivers/usb/host/ohci.h b/drivers/usb/host/ohci.h
index 3dbc7c0eed43..71cdd2262860 100644
--- a/drivers/usb/host/ohci.h
+++ b/drivers/usb/host/ohci.h
@@ -371,7 +371,6 @@ struct ohci_hcd {
 	 * other external transceivers should be software-transparent 
 	 */
 	struct otg_transceiver	*transceiver;
-	unsigned		power_budget;
 
 	/*
 	 * memory management for queue data structures
diff --git a/drivers/usb/host/sl811-hcd.c b/drivers/usb/host/sl811-hcd.c
index 99d43f758ad0..1f2d00fe983a 100644
--- a/drivers/usb/host/sl811-hcd.c
+++ b/drivers/usb/host/sl811-hcd.c
@@ -1574,8 +1574,10 @@ sl811h_start(struct usb_hcd *hcd)
 	udev-&gt;speed = USB_SPEED_FULL;
 	hcd-&gt;state = HC_STATE_RUNNING;
 
-	if (sl811-&gt;board)
+	if (sl811-&gt;board) {
 		hcd-&gt;can_wakeup = sl811-&gt;board-&gt;can_wakeup;
+		hcd-&gt;power_budget = sl811-&gt;board-&gt;power * 2;
+	}
 
 	if (usb_hcd_register_root_hub(udev, hcd) != 0) {
 		usb_put_dev(udev);
@@ -1583,9 +1585,6 @@ sl811h_start(struct usb_hcd *hcd)
 		return -ENODEV;
 	}
 
-	if (sl811-&gt;board &amp;&amp; sl811-&gt;board-&gt;power)
-		hub_set_power_budget(udev, sl811-&gt;board-&gt;power * 2);
-
 	/* enable power and interupts */
 	port_power(sl811, 1);
 </pre><hr><pre>commit 2532178a68b5ce4e421d50ea1b1dcc0a1359f19d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Apr 25 11:14:31 2005 -0400

    [PATCH] UHCI: Don't store device pointer in QH or TD
    
    This patch simplifies the uhci-hcd driver by removing the device pointer
    currently stored in the QH and TD structures.  Those pointers weren't
    being used for anything other than to increment the device's reference
    count, which is unnecessary since the device is used only when an URB
    completes, and outstanding URBs take their own reference to the device.
    As a useful side effect, this change means that uhci-hcd no longer needs
    to have the root-hub device available in the start routine.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 53ba8a56592e..6b87bd74b046 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -634,14 +634,14 @@ static int uhci_start(struct usb_hcd *hcd)
 		goto err_alloc_root_hub;
 	}
 
-	uhci-&gt;term_td = uhci_alloc_td(uhci, udev);
+	uhci-&gt;term_td = uhci_alloc_td(uhci);
 	if (!uhci-&gt;term_td) {
 		dev_err(uhci_dev(uhci), "unable to allocate terminating TD\n");
 		goto err_alloc_term_td;
 	}
 
 	for (i = 0; i &lt; UHCI_NUM_SKELQH; i++) {
-		uhci-&gt;skelqh[i] = uhci_alloc_qh(uhci, udev);
+		uhci-&gt;skelqh[i] = uhci_alloc_qh(uhci);
 		if (!uhci-&gt;skelqh[i]) {
 			dev_err(uhci_dev(uhci), "unable to allocate QH\n");
 			goto err_alloc_skelqh;
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index d7c67b73eb7a..bf9c5f9b508b 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -114,7 +114,6 @@ struct uhci_qh {
 	/* Software fields */
 	dma_addr_t dma_handle;
 
-	struct usb_device *dev;
 	struct urb_priv *urbp;
 
 	struct list_head list;		/* P: uhci-&gt;frame_list_lock */
@@ -206,7 +205,6 @@ struct uhci_td {
 	/* Software fields */
 	dma_addr_t dma_handle;
 
-	struct usb_device *dev;
 	struct urb *urb;
 
 	struct list_head list;		/* P: urb-&gt;lock */
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 77f264851e98..5f18084a116d 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -48,7 +48,7 @@ static inline void uhci_moveto_complete(struct uhci_hcd *uhci,
 	list_move_tail(&amp;urbp-&gt;urb_list, &amp;uhci-&gt;complete_list);
 }
 
-static struct uhci_td *uhci_alloc_td(struct uhci_hcd *uhci, struct usb_device *dev)
+static struct uhci_td *uhci_alloc_td(struct uhci_hcd *uhci)
 {
 	dma_addr_t dma_handle;
 	struct uhci_td *td;
@@ -63,14 +63,11 @@ static struct uhci_td *uhci_alloc_td(struct uhci_hcd *uhci, struct usb_device *d
 	td-&gt;buffer = 0;
 
 	td-&gt;frame = -1;
-	td-&gt;dev = dev;
 
 	INIT_LIST_HEAD(&amp;td-&gt;list);
 	INIT_LIST_HEAD(&amp;td-&gt;remove_list);
 	INIT_LIST_HEAD(&amp;td-&gt;fl_list);
 
-	usb_get_dev(dev);
-
 	return td;
 }
 
@@ -170,13 +167,10 @@ static void uhci_free_td(struct uhci_hcd *uhci, struct uhci_td *td)
 	if (!list_empty(&amp;td-&gt;fl_list))
 		dev_warn(uhci_dev(uhci), "td %p still in fl_list!\n", td);
 
-	if (td-&gt;dev)
-		usb_put_dev(td-&gt;dev);
-
 	dma_pool_free(uhci-&gt;td_pool, td, td-&gt;dma_handle);
 }
 
-static struct uhci_qh *uhci_alloc_qh(struct uhci_hcd *uhci, struct usb_device *dev)
+static struct uhci_qh *uhci_alloc_qh(struct uhci_hcd *uhci)
 {
 	dma_addr_t dma_handle;
 	struct uhci_qh *qh;
@@ -190,14 +184,11 @@ static struct uhci_qh *uhci_alloc_qh(struct uhci_hcd *uhci, struct usb_device *d
 	qh-&gt;element = UHCI_PTR_TERM;
 	qh-&gt;link = UHCI_PTR_TERM;
 
-	qh-&gt;dev = dev;
 	qh-&gt;urbp = NULL;
 
 	INIT_LIST_HEAD(&amp;qh-&gt;list);
 	INIT_LIST_HEAD(&amp;qh-&gt;remove_list);
 
-	usb_get_dev(dev);
-
 	return qh;
 }
 
@@ -208,9 +199,6 @@ static void uhci_free_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
 	if (!list_empty(&amp;qh-&gt;remove_list))
 		dev_warn(uhci_dev(uhci), "qh %p still in remove_list!\n", qh);
 
-	if (qh-&gt;dev)
-		usb_put_dev(qh-&gt;dev);
-
 	dma_pool_free(uhci-&gt;qh_pool, qh, qh-&gt;dma_handle);
 }
 
@@ -599,7 +587,7 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb, struct ur
 	/*
 	 * Build the TD for the control request setup packet
 	 */
-	td = uhci_alloc_td(uhci, urb-&gt;dev);
+	td = uhci_alloc_td(uhci);
 	if (!td)
 		return -ENOMEM;
 
@@ -628,7 +616,7 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb, struct ur
 		if (pktsze &gt; maxsze)
 			pktsze = maxsze;
 
-		td = uhci_alloc_td(uhci, urb-&gt;dev);
+		td = uhci_alloc_td(uhci);
 		if (!td)
 			return -ENOMEM;
 
@@ -646,7 +634,7 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb, struct ur
 	/*
 	 * Build the final TD for control status 
 	 */
-	td = uhci_alloc_td(uhci, urb-&gt;dev);
+	td = uhci_alloc_td(uhci);
 	if (!td)
 		return -ENOMEM;
 
@@ -668,7 +656,7 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb, struct ur
 	uhci_fill_td(td, status | TD_CTRL_IOC,
 		destination | uhci_explen(UHCI_NULL_DATA_SIZE), 0);
 
-	qh = uhci_alloc_qh(uhci, urb-&gt;dev);
+	qh = uhci_alloc_qh(uhci);
 	if (!qh)
 		return -ENOMEM;
 
@@ -867,7 +855,7 @@ static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb, struct urb
 				status &amp;= ~TD_CTRL_SPD;
 		}
 
-		td = uhci_alloc_td(uhci, urb-&gt;dev);
+		td = uhci_alloc_td(uhci);
 		if (!td)
 			return -ENOMEM;
 
@@ -893,7 +881,7 @@ static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb, struct urb
 	 */
 	if (usb_pipeout(urb-&gt;pipe) &amp;&amp; (urb-&gt;transfer_flags &amp; URB_ZERO_PACKET) &amp;&amp;
 	    !len &amp;&amp; urb-&gt;transfer_buffer_length) {
-		td = uhci_alloc_td(uhci, urb-&gt;dev);
+		td = uhci_alloc_td(uhci);
 		if (!td)
 			return -ENOMEM;
 
@@ -915,7 +903,7 @@ static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb, struct urb
 	 * flag setting. */
 	td-&gt;status |= cpu_to_le32(TD_CTRL_IOC);
 
-	qh = uhci_alloc_qh(uhci, urb-&gt;dev);
+	qh = uhci_alloc_qh(uhci);
 	if (!qh)
 		return -ENOMEM;
 
@@ -1098,7 +1086,7 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb)
 		if (!urb-&gt;iso_frame_desc[i].length)
 			continue;
 
-		td = uhci_alloc_td(uhci, urb-&gt;dev);
+		td = uhci_alloc_td(uhci);
 		if (!td)
 			return -ENOMEM;
 </pre><hr><pre>commit 7d35b9298539d2818c51fe9070b08cf9876016f4
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Apr 25 11:18:32 2005 -0400

    [PATCH] usbcore: Remove hub_set_power_budget
    
    This patch removes the hub_set_power_budget routine, which was used by a
    couple of HCDs to indicate that the root hub was running on battery power.
    In its place is a new field added to struct usb_hcd, which HCDs can set
    before the root hub is registered.  Special-case code in the hub driver
    knows to look at this field when configuring a root hub.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: David Brownell &lt;dbrownell@users.sourceforge.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.h b/drivers/usb/core/hcd.h
index ac5752778e39..3837f68bb7b3 100644
--- a/drivers/usb/core/hcd.h
+++ b/drivers/usb/core/hcd.h
@@ -87,6 +87,7 @@ struct usb_hcd {	/* usb_bus.hcpriv points to this */
 	void __iomem		*regs;		/* device memory/io */
 	u64			rsrc_start;	/* memory/io resource start */
 	u64			rsrc_len;	/* memory/io resource length */
+	unsigned		power_budget;	/* in mA, 0 = no limit */
 
 #define HCD_BUFFER_POOLS	4
 	struct dma_pool		*pool [HCD_BUFFER_POOLS];
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 6d1a330d577b..63ee3d97b6a9 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -643,15 +643,21 @@ static int hub_configure(struct usb_hub *hub,
 		message = "can't get hub status";
 		goto fail;
 	}
-	cpu_to_le16s(&amp;hubstatus);
-	if ((hubstatus &amp; (1 &lt;&lt; USB_DEVICE_SELF_POWERED)) == 0) {
+	le16_to_cpus(&amp;hubstatus);
+	if (hdev == hdev-&gt;bus-&gt;root_hub) {
+		struct usb_hcd *hcd =
+				container_of(hdev-&gt;bus, struct usb_hcd, self);
+
+		hub-&gt;power_budget = min(500u, hcd-&gt;power_budget) / 2;
+	} else if ((hubstatus &amp; (1 &lt;&lt; USB_DEVICE_SELF_POWERED)) == 0) {
 		dev_dbg(hub_dev, "hub controller current requirement: %dmA\n",
 			hub-&gt;descriptor-&gt;bHubContrCurrent);
 		hub-&gt;power_budget = (501 - hub-&gt;descriptor-&gt;bHubContrCurrent)
 					/ 2;
+	}
+	if (hub-&gt;power_budget)
 		dev_dbg(hub_dev, "%dmA bus power budget for children\n",
 			hub-&gt;power_budget * 2);
-	}
 
 
 	ret = hub_hub_status(hub, &amp;hubstatus, &amp;hubchange);
diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index d114b847d56f..53bf5649621e 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -224,15 +224,4 @@ struct usb_hub {
 	struct work_struct	leds;
 };
 
-/* use this for low-powered root hubs */
-static inline void
-hub_set_power_budget (struct usb_device *hubdev, unsigned mA)
-{
-	struct usb_hub	*hub;
-
-	hub = (struct usb_hub *)
-		usb_get_intfdata (hubdev-&gt;actconfig-&gt;interface[0]);
-	hub-&gt;power_budget = min(mA,(unsigned)500)/2;
-}
-
 #endif /* __LINUX_HUB_H */</pre><hr><pre>commit d5926ae7a827bdd06b588ffbc56fd4525cd9214a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Apr 21 15:56:37 2005 -0400

    [PATCH] usbcore support for root-hub IRQ instead of polling
    
    This is a revised version of an earlier patch to add support to usbcore
    for driving root hubs by interrupts rather than polling.
    
    There's a temporary flag added to struct usb_hcd, marking devices whose
    drivers are aware of the new mechanism.  By default that flag doesn't get
    set so drivers will continue to see the same polling behavior as before.
    This way we can convert the HCDs one by one to use interrupt-based event
    reporting, and the temporary flag can be removed when they're all done.
    
    Also included is a small change to the hcd_disable_endpoint routine.
    Although endpoints normally shouldn't be disabled while a controller is
    suspended, it's legal to do so when the controller's driver is being
    rmmod'ed.
    
    Lastly the patch adds a new callback, .hub_irq_enable, for use by HCDs
    where the root hub's port-change interrupts are level-triggered rather
    than edge-triggered.  The callback is invoked each time khubd has finished
    processing a root hub, to let the HCD know that the interrupt can safely
    be re-enabled.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 0da23732e807..1180c157b717 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -519,119 +519,120 @@ static int rh_call_control (struct usb_hcd *hcd, struct urb *urb)
 /*-------------------------------------------------------------------------*/
 
 /*
- * Root Hub interrupt transfers are synthesized with a timer.
- * Completions are called in_interrupt() but not in_irq().
+ * Root Hub interrupt transfers are polled using a timer if the
+ * driver requests it; otherwise the driver is responsible for
+ * calling usb_hcd_poll_rh_status() when an event occurs.
  *
- * Note: some root hubs (including common UHCI based designs) can't
- * correctly issue port change IRQs.  They're the ones that _need_ a
- * timer; most other root hubs don't.  Some systems could save a
- * lot of battery power by eliminating these root hub timer IRQs.
+ * Completions are called in_interrupt(), but they may or may not
+ * be in_irq().
  */
+void usb_hcd_poll_rh_status(struct usb_hcd *hcd)
+{
+	struct urb	*urb;
+	int		length;
+	unsigned long	flags;
+	char		buffer[4];	/* Any root hubs with &gt; 31 ports? */
 
-static void rh_report_status (unsigned long ptr);
+	if (!hcd-&gt;uses_new_polling &amp;&amp; !hcd-&gt;status_urb)
+		return;
 
-static int rh_status_urb (struct usb_hcd *hcd, struct urb *urb) 
-{
-	int	len = 1 + (urb-&gt;dev-&gt;maxchild / 8);
+	length = hcd-&gt;driver-&gt;hub_status_data(hcd, buffer);
+	if (length &gt; 0) {
 
-	/* rh_timer protected by hcd_data_lock */
-	if (hcd-&gt;rh_timer.data || urb-&gt;transfer_buffer_length &lt; len) {
-		dev_dbg (hcd-&gt;self.controller,
-				"not queuing rh status urb, stat %d\n",
-				urb-&gt;status);
-		return -EINVAL;
+		/* try to complete the status urb */
+		local_irq_save (flags);
+		spin_lock(&amp;hcd_root_hub_lock);
+		urb = hcd-&gt;status_urb;
+		if (urb) {
+			spin_lock(&amp;urb-&gt;lock);
+			if (urb-&gt;status == -EINPROGRESS) {
+				hcd-&gt;poll_pending = 0;
+				hcd-&gt;status_urb = NULL;
+				urb-&gt;status = 0;
+				urb-&gt;hcpriv = NULL;
+				urb-&gt;actual_length = length;
+				memcpy(urb-&gt;transfer_buffer, buffer, length);
+			} else		/* urb has been unlinked */
+				length = 0;
+			spin_unlock(&amp;urb-&gt;lock);
+		} else
+			length = 0;
+		spin_unlock(&amp;hcd_root_hub_lock);
+
+		/* local irqs are always blocked in completions */
+		if (length &gt; 0)
+			usb_hcd_giveback_urb (hcd, urb, NULL);
+		else
+			hcd-&gt;poll_pending = 1;
+		local_irq_restore (flags);
 	}
 
-	init_timer (&amp;hcd-&gt;rh_timer);
-	hcd-&gt;rh_timer.function = rh_report_status;
-	hcd-&gt;rh_timer.data = (unsigned long) urb;
-	/* USB 2.0 spec says 256msec; this is close enough */
-	hcd-&gt;rh_timer.expires = jiffies + HZ/4;
-	add_timer (&amp;hcd-&gt;rh_timer);
-	urb-&gt;hcpriv = hcd;	/* nonzero to indicate it's queued */
-	return 0;
+	/* The USB 2.0 spec says 256 ms.  This is close enough and won't
+	 * exceed that limit if HZ is 100. */
+	if (hcd-&gt;uses_new_polling ? hcd-&gt;poll_rh :
+			(length == 0 &amp;&amp; hcd-&gt;status_urb != NULL))
+		mod_timer (&amp;hcd-&gt;rh_timer, jiffies + msecs_to_jiffies(250));
 }
+EXPORT_SYMBOL_GPL(usb_hcd_poll_rh_status);
 
 /* timer callback */
+static void rh_timer_func (unsigned long _hcd)
+{
+	usb_hcd_poll_rh_status((struct usb_hcd *) _hcd);
+}
+
+/*-------------------------------------------------------------------------*/
 
-static void rh_report_status (unsigned long ptr)
+static int rh_queue_status (struct usb_hcd *hcd, struct urb *urb)
 {
-	struct urb	*urb;
-	struct usb_hcd	*hcd;
-	int		length = 0;
+	int		retval;
 	unsigned long	flags;
+	int		len = 1 + (urb-&gt;dev-&gt;maxchild / 8);
 
-	urb = (struct urb *) ptr;
-	local_irq_save (flags);
-	spin_lock (&amp;urb-&gt;lock);
+	spin_lock_irqsave (&amp;hcd_root_hub_lock, flags);
+	if (urb-&gt;status != -EINPROGRESS)	/* already unlinked */
+		retval = urb-&gt;status;
+	else if (hcd-&gt;status_urb || urb-&gt;transfer_buffer_length &lt; len) {
+		dev_dbg (hcd-&gt;self.controller, "not queuing rh status urb\n");
+		retval = -EINVAL;
+	} else {
+		hcd-&gt;status_urb = urb;
+		urb-&gt;hcpriv = hcd;	/* indicate it's queued */
 
-	/* do nothing if the urb's been unlinked */
-	if (!urb-&gt;dev
-			|| urb-&gt;status != -EINPROGRESS
-			|| (hcd = urb-&gt;dev-&gt;bus-&gt;hcpriv) == NULL) {
-		spin_unlock (&amp;urb-&gt;lock);
-		local_irq_restore (flags);
-		return;
-	}
+		if (!hcd-&gt;uses_new_polling)
+			mod_timer (&amp;hcd-&gt;rh_timer, jiffies +
+					msecs_to_jiffies(250));
 
-	/* complete the status urb, or retrigger the timer */
-	spin_lock (&amp;hcd_data_lock);
-	if (urb-&gt;dev-&gt;state == USB_STATE_CONFIGURED) {
-		length = hcd-&gt;driver-&gt;hub_status_data (
-					hcd, urb-&gt;transfer_buffer);
-		if (length &gt; 0) {
-			hcd-&gt;rh_timer.data = 0;
-			urb-&gt;actual_length = length;
-			urb-&gt;status = 0;
-			urb-&gt;hcpriv = NULL;
-		} else
-			mod_timer (&amp;hcd-&gt;rh_timer, jiffies + HZ/4);
+		/* If a status change has already occurred, report it ASAP */
+		else if (hcd-&gt;poll_pending)
+			mod_timer (&amp;hcd-&gt;rh_timer, jiffies);
+		retval = 0;
 	}
-	spin_unlock (&amp;hcd_data_lock);
-	spin_unlock (&amp;urb-&gt;lock);
-
-	/* local irqs are always blocked in completions */
-	if (length &gt; 0)
-		usb_hcd_giveback_urb (hcd, urb, NULL);
-	local_irq_restore (flags);
+	spin_unlock_irqrestore (&amp;hcd_root_hub_lock, flags);
+	return retval;
 }
 
-/*-------------------------------------------------------------------------*/
-
 static int rh_urb_enqueue (struct usb_hcd *hcd, struct urb *urb)
 {
-	if (usb_pipeint (urb-&gt;pipe)) {
-		int		retval;
-		unsigned long	flags;
-
-		spin_lock_irqsave (&amp;hcd_data_lock, flags);
-		retval = rh_status_urb (hcd, urb);
-		spin_unlock_irqrestore (&amp;hcd_data_lock, flags);
-		return retval;
-	}
+	if (usb_pipeint (urb-&gt;pipe))
+		return rh_queue_status (hcd, urb);
 	if (usb_pipecontrol (urb-&gt;pipe))
 		return rh_call_control (hcd, urb);
-	else
-		return -EINVAL;
+	return -EINVAL;
 }
 
 /*-------------------------------------------------------------------------*/
 
+/* Asynchronous unlinks of root-hub control URBs are legal, but they
+ * don't do anything.  Status URB unlinks must be made in process context
+ * with interrupts enabled.
+ */
 static int usb_rh_urb_dequeue (struct usb_hcd *hcd, struct urb *urb)
 {
-	unsigned long	flags;
-
-	/* note:  always a synchronous unlink */
-	if ((unsigned long) urb == hcd-&gt;rh_timer.data) {
-		del_timer_sync (&amp;hcd-&gt;rh_timer);
-		hcd-&gt;rh_timer.data = 0;
-
-		local_irq_save (flags);
-		urb-&gt;hcpriv = NULL;
-		usb_hcd_giveback_urb (hcd, urb, NULL);
-		local_irq_restore (flags);
+	if (usb_pipeendpoint(urb-&gt;pipe) == 0) {	/* Control URB */
+		if (in_interrupt())
+			return 0;		/* nothing to do */
 
-	} else if (usb_pipeendpoint(urb-&gt;pipe) == 0) {
 		spin_lock_irq(&amp;urb-&gt;lock);	/* from usb_kill_urb */
 		++urb-&gt;reject;
 		spin_unlock_irq(&amp;urb-&gt;lock);
@@ -642,8 +643,22 @@ static int usb_rh_urb_dequeue (struct usb_hcd *hcd, struct urb *urb)
 		spin_lock_irq(&amp;urb-&gt;lock);
 		--urb-&gt;reject;
 		spin_unlock_irq(&amp;urb-&gt;lock);
-	} else
-		return -EINVAL;
+
+	} else {				/* Status URB */
+		if (!hcd-&gt;uses_new_polling)
+			del_timer_sync (&amp;hcd-&gt;rh_timer);
+		local_irq_disable ();
+		spin_lock (&amp;hcd_root_hub_lock);
+		if (urb == hcd-&gt;status_urb) {
+			hcd-&gt;status_urb = NULL;
+			urb-&gt;hcpriv = NULL;
+		} else
+			urb = NULL;		/* wasn't fully queued */
+		spin_unlock (&amp;hcd_root_hub_lock);
+		if (urb)
+			usb_hcd_giveback_urb (hcd, urb, NULL);
+		local_irq_enable ();
+	}
 
 	return 0;
 }
@@ -885,6 +900,16 @@ int usb_hcd_register_root_hub (struct usb_device *usb_dev, struct usb_hcd *hcd)
 }
 EXPORT_SYMBOL_GPL(usb_hcd_register_root_hub);
 
+void usb_enable_root_hub_irq (struct usb_bus *bus)
+{
+	struct usb_hcd *hcd;
+
+	hcd = container_of (bus, struct usb_hcd, self);
+	if (hcd-&gt;driver-&gt;hub_irq_enable &amp;&amp; !hcd-&gt;poll_rh &amp;&amp;
+			hcd-&gt;state != HC_STATE_HALT)
+		hcd-&gt;driver-&gt;hub_irq_enable (hcd);
+}
+
 
 /*-------------------------------------------------------------------------*/
 
@@ -1348,7 +1373,8 @@ hcd_endpoint_disable (struct usb_device *udev, struct usb_host_endpoint *ep)
 
 	hcd = udev-&gt;bus-&gt;hcpriv;
 
-	WARN_ON (!HC_IS_RUNNING (hcd-&gt;state) &amp;&amp; hcd-&gt;state != HC_STATE_HALT);
+	WARN_ON (!HC_IS_RUNNING (hcd-&gt;state) &amp;&amp; hcd-&gt;state != HC_STATE_HALT &amp;&amp;
+			udev-&gt;state != USB_STATE_NOTATTACHED);
 
 	local_irq_disable ();
 
@@ -1612,6 +1638,8 @@ void usb_hc_died (struct usb_hcd *hcd)
 
 	spin_lock_irqsave (&amp;hcd_root_hub_lock, flags);
 	if (hcd-&gt;rh_registered) {
+		hcd-&gt;poll_rh = 0;
+		del_timer(&amp;hcd-&gt;rh_timer);
 
 		/* make khubd clean up old urbs and devices */
 		usb_set_device_state (hcd-&gt;self.root_hub,
@@ -1665,6 +1693,8 @@ struct usb_hcd *usb_create_hcd (const struct hc_driver *driver,
 	hcd-&gt;self.bus_name = bus_name;
 
 	init_timer(&amp;hcd-&gt;rh_timer);
+	hcd-&gt;rh_timer.function = rh_timer_func;
+	hcd-&gt;rh_timer.data = (unsigned long) hcd;
 
 	hcd-&gt;driver = driver;
 	hcd-&gt;product_desc = (driver-&gt;product_desc) ? driver-&gt;product_desc :
@@ -1748,6 +1778,8 @@ int usb_add_hcd(struct usb_hcd *hcd,
 		goto err3;
 	}
 
+	if (hcd-&gt;uses_new_polling &amp;&amp; hcd-&gt;poll_rh)
+		usb_hcd_poll_rh_status(hcd);
 	return retval;
 
  err3:
@@ -1782,6 +1814,9 @@ void usb_remove_hcd(struct usb_hcd *hcd)
 	spin_unlock_irq (&amp;hcd_root_hub_lock);
 	usb_disconnect(&amp;hcd-&gt;self.root_hub);
 
+	hcd-&gt;poll_rh = 0;
+	del_timer_sync(&amp;hcd-&gt;rh_timer);
+
 	hcd-&gt;driver-&gt;stop(hcd);
 	hcd-&gt;state = HC_STATE_HALT;
 
diff --git a/drivers/usb/core/hcd.h b/drivers/usb/core/hcd.h
index 325a51656c3f..ac5752778e39 100644
--- a/drivers/usb/core/hcd.h
+++ b/drivers/usb/core/hcd.h
@@ -65,7 +65,8 @@ struct usb_hcd {	/* usb_bus.hcpriv points to this */
 	const char		*product_desc;	/* product/vendor string */
 	char			irq_descr[24];	/* driver + bus # */
 
-	struct timer_list	rh_timer;	/* drives root hub */
+	struct timer_list	rh_timer;	/* drives root-hub polling */
+	struct urb		*status_urb;	/* the current status urb */
 
 	/*
 	 * hardware info/state
@@ -76,6 +77,12 @@ struct usb_hcd {	/* usb_bus.hcpriv points to this */
 	unsigned		remote_wakeup:1;/* sw should use wakeup? */
 	unsigned		rh_registered:1;/* is root hub registered? */
 
+	/* The next flag is a stopgap, to be removed when all the HCDs
+	 * support the new root-hub polling mechanism. */
+	unsigned		uses_new_polling:1;
+	unsigned		poll_rh:1;	/* poll for rh status? */
+	unsigned		poll_pending:1;	/* status has changed? */
+
 	int			irq;		/* irq allocated */
 	void __iomem		*regs;		/* device memory/io */
 	u64			rsrc_start;	/* memory/io resource start */
@@ -207,6 +214,8 @@ struct hc_driver {
 	int		(*hub_suspend)(struct usb_hcd *);
 	int		(*hub_resume)(struct usb_hcd *);
 	int		(*start_port_reset)(struct usb_hcd *, unsigned port_num);
+	void		(*hub_irq_enable)(struct usb_hcd *);
+		/* Needed only if port-change IRQs are level-triggered */
 };
 
 extern void usb_hcd_giveback_urb (struct usb_hcd *hcd, struct urb *urb, struct pt_regs *regs);
@@ -243,7 +252,9 @@ void hcd_buffer_free (struct usb_bus *bus, size_t size,
 
 /* generic bus glue, needed for host controllers that don't use PCI */
 extern irqreturn_t usb_hcd_irq (int irq, void *__hcd, struct pt_regs *r);
+
 extern void usb_hc_died (struct usb_hcd *hcd);
+extern void usb_hcd_poll_rh_status(struct usb_hcd *hcd);
 
 /* -------------------------------------------------------------------------- */
 
@@ -360,6 +371,8 @@ extern wait_queue_head_t usb_kill_urb_queue;
 extern struct usb_bus *usb_bus_get (struct usb_bus *bus);
 extern void usb_bus_put (struct usb_bus *bus);
 
+extern void usb_enable_root_hub_irq (struct usb_bus *bus);
+
 extern int usb_find_interface_driver (struct usb_device *dev,
 	struct usb_interface *interface);
 
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index a8d879a85d04..6d1a330d577b 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2787,6 +2787,11 @@ static void hub_events(void)
 
 		hub-&gt;activating = 0;
 
+		/* If this is a root hub, tell the HCD it's okay to
+		 * re-enable port-change interrupts now. */
+		if (!hdev-&gt;parent)
+			usb_enable_root_hub_irq(hdev-&gt;bus);
+
 loop:
 		usb_unlock_device(hdev);
 		usb_put_intf(intf);</pre><hr><pre>commit 02597d2deec2a3de0e2b52c1f83904b65626a0d5
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Apr 28 14:51:27 2005 -0400

    [PATCH] USB UHCI: Add shutdown method
    
    After all the discussion you might not be interested in this still, but
    nevertheless here it is.  This patch adds a shutdown method to the
    uhci-hcd driver.  Its prerequisite is the patch you wrote adding shutdown
    support for PCI.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index cec070fa8c83..53ba8a56592e 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -154,6 +154,7 @@ static void reset_hc(struct uhci_hcd *uhci)
 
 /*
  * Last rites for a defunct/nonfunctional controller
+ * or one we don't want to use any more.
  */
 static void hc_died(struct uhci_hcd *uhci)
 {
@@ -525,6 +526,20 @@ static int uhci_reset(struct usb_hcd *hcd)
 	return 0;
 }
 
+/* Make sure the controller is quiescent and that we're not using it
+ * any more.  This is mainly for the benefit of programs which, like kexec,
+ * expect the hardware to be idle: not doing DMA or generating IRQs.
+ *
+ * This routine may be called in a damaged or failing kernel.  Hence we
+ * do not acquire the spinlock before shutting down the controller.
+ */
+static void uhci_shutdown(struct pci_dev *pdev)
+{
+	struct usb_hcd *hcd = (struct usb_hcd *) pci_get_drvdata(pdev);
+
+	hc_died(hcd_to_uhci(hcd));
+}
+
 /*
  * Allocate a frame list, and then setup the skeleton
  *
@@ -939,6 +954,7 @@ static struct pci_driver uhci_pci_driver = {
 
 	.probe =	usb_hcd_pci_probe,
 	.remove =	usb_hcd_pci_remove,
+	.shutdown =	uhci_shutdown,
 
 #ifdef	CONFIG_PM
 	.suspend =	usb_hcd_pci_suspend,</pre>
    <div class="pagination">
        <a href='2_137.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><span>[138]</span><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_139.html'>Next&gt;&gt;</a>
    <div>
</body>
