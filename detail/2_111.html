<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_110.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><span>[111]</span><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_112.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 523ded71de0c5e66973335bf99a80edfda9f401b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Apr 26 00:12:04 2007 -0700

    device_schedule_callback() needs a module reference
    
    This patch (as896b) fixes an oversight in the design of
    device_schedule_callback().  It is necessary to acquire a reference to the
    module owning the callback routine, to prevent the module from being
    unloaded before the callback can run.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: Satyam Sharma &lt;satyam.sharma@gmail.com&gt;
    Cc: Neil Brown &lt;neilb@suse.de&gt;
    Cc: Cornelia Huck &lt;cornelia.huck@de.ibm.com&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/base/core.c b/drivers/base/core.c
index f69305c7269d..8aa090da1cd7 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -480,9 +480,10 @@ void device_remove_bin_file(struct device *dev, struct bin_attribute *attr)
 EXPORT_SYMBOL_GPL(device_remove_bin_file);
 
 /**
- * device_schedule_callback - helper to schedule a callback for a device
+ * device_schedule_callback_owner - helper to schedule a callback for a device
  * @dev: device.
  * @func: callback function to invoke later.
+ * @owner: module owning the callback routine
  *
  * Attribute methods must not unregister themselves or their parent device
  * (which would amount to the same thing).  Attempts to do so will deadlock,
@@ -493,20 +494,23 @@ EXPORT_SYMBOL_GPL(device_remove_bin_file);
  * argument in the workqueue's process context.  @dev will be pinned until
  * @func returns.
  *
+ * This routine is usually called via the inline device_schedule_callback(),
+ * which automatically sets @owner to THIS_MODULE.
+ *
  * Returns 0 if the request was submitted, -ENOMEM if storage could not
- * be allocated.
+ * be allocated, -ENODEV if a reference to @owner isn't available.
  *
  * NOTE: This routine won't work if CONFIG_SYSFS isn't set!  It uses an
  * underlying sysfs routine (since it is intended for use by attribute
  * methods), and if sysfs isn't available you'll get nothing but -ENOSYS.
  */
-int device_schedule_callback(struct device *dev,
-		void (*func)(struct device *))
+int device_schedule_callback_owner(struct device *dev,
+		void (*func)(struct device *), struct module *owner)
 {
 	return sysfs_schedule_callback(&amp;dev-&gt;kobj,
-			(void (*)(void *)) func, dev);
+			(void (*)(void *)) func, dev, owner);
 }
-EXPORT_SYMBOL_GPL(device_schedule_callback);
+EXPORT_SYMBOL_GPL(device_schedule_callback_owner);
 
 static void klist_children_get(struct klist_node *n)
 {
diff --git a/fs/sysfs/file.c b/fs/sysfs/file.c
index fc4633378dc0..db0413a411d6 100644
--- a/fs/sysfs/file.c
+++ b/fs/sysfs/file.c
@@ -633,6 +633,7 @@ struct sysfs_schedule_callback_struct {
 	struct kobject 		*kobj;
 	void			(*func)(void *);
 	void			*data;
+	struct module		*owner;
 	struct work_struct	work;
 };
 
@@ -643,6 +644,7 @@ static void sysfs_schedule_callback_work(struct work_struct *work)
 
 	(ss-&gt;func)(ss-&gt;data);
 	kobject_put(ss-&gt;kobj);
+	module_put(ss-&gt;owner);
 	kfree(ss);
 }
 
@@ -651,6 +653,7 @@ static void sysfs_schedule_callback_work(struct work_struct *work)
  * @kobj: object we're acting for.
  * @func: callback function to invoke later.
  * @data: argument to pass to @func.
+ * @owner: module owning the callback code
  *
  * sysfs attribute methods must not unregister themselves or their parent
  * kobject (which would amount to the same thing).  Attempts to do so will
@@ -663,20 +666,25 @@ static void sysfs_schedule_callback_work(struct work_struct *work)
  * until @func returns.
  *
  * Returns 0 if the request was submitted, -ENOMEM if storage could not
- * be allocated.
+ * be allocated, -ENODEV if a reference to @owner isn't available.
  */
 int sysfs_schedule_callback(struct kobject *kobj, void (*func)(void *),
-		void *data)
+		void *data, struct module *owner)
 {
 	struct sysfs_schedule_callback_struct *ss;
 
+	if (!try_module_get(owner))
+		return -ENODEV;
 	ss = kmalloc(sizeof(*ss), GFP_KERNEL);
-	if (!ss)
+	if (!ss) {
+		module_put(owner);
 		return -ENOMEM;
+	}
 	kobject_get(kobj);
 	ss-&gt;kobj = kobj;
 	ss-&gt;func = func;
 	ss-&gt;data = data;
+	ss-&gt;owner = owner;
 	INIT_WORK(&amp;ss-&gt;work, sysfs_schedule_callback_work);
 	schedule_work(&amp;ss-&gt;work);
 	return 0;
diff --git a/include/linux/device.h b/include/linux/device.h
index af603a137690..8511d14071b3 100644
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@ -367,8 +367,12 @@ extern int __must_check device_create_bin_file(struct device *dev,
 					       struct bin_attribute *attr);
 extern void device_remove_bin_file(struct device *dev,
 				   struct bin_attribute *attr);
-extern int device_schedule_callback(struct device *dev,
-		void (*func)(struct device *));
+extern int device_schedule_callback_owner(struct device *dev,
+		void (*func)(struct device *), struct module *owner);
+
+/* This is a macro to avoid include problems with THIS_MODULE */
+#define device_schedule_callback(dev, func)			\
+	device_schedule_callback_owner(dev, func, THIS_MODULE)
 
 /* device resource management */
 typedef void (*dr_release_t)(struct device *dev, void *res);
diff --git a/include/linux/sysfs.h b/include/linux/sysfs.h
index fea9a6b3fb7b..7d5d1ec95c2e 100644
--- a/include/linux/sysfs.h
+++ b/include/linux/sysfs.h
@@ -80,7 +80,7 @@ struct sysfs_ops {
 #ifdef CONFIG_SYSFS
 
 extern int sysfs_schedule_callback(struct kobject *kobj,
-		void (*func)(void *), void *data);
+		void (*func)(void *), void *data, struct module *owner);
 
 extern int __must_check
 sysfs_create_dir(struct kobject *, struct dentry *);
@@ -137,7 +137,7 @@ extern int __must_check sysfs_init(void);
 #else /* CONFIG_SYSFS */
 
 static inline int sysfs_schedule_callback(struct kobject *kobj,
-		void (*func)(void *), void *data)
+		void (*func)(void *), void *data, struct module *owner)
 {
 	return -ENOSYS;
 }</pre><hr><pre>commit 44ec95425c1d9dce6e4638c29e4362cfb44814e7
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Feb 20 11:01:57 2007 -0500

    [SCSI] sg: cap reserved_size values at max_sectors
    
    This patch (as857) modifies the SG_GET_RESERVED_SIZE and
    SG_SET_RESERVED_SIZE ioctls in the sg driver, capping the values at
    the device's request_queue's max_sectors value.  This will permit
    cdrecord to obtain a legal value for the maximum transfer length,
    fixing Bugzilla #7026.
    
    The patch also caps the initial reserved_size value.  There's no
    reason to have a reserved buffer larger than max_sectors, since it
    would be impossible to use the extra space.
    
    The corresponding ioctls in the block layer are modified similarly,
    and the initial value for the reserved_size is set as large as
    possible.  This will effectively make it default to max_sectors.
    Note that the actual value is meaningless anyway, since block devices
    don't have a reserved buffer.
    
    Finally, the BLKSECTGET ioctl is added to sg, so that there will be a
    uniform way for users to determine the actual max_sectors value for
    any raw SCSI transport.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Jens Axboe &lt;jens.axboe@oracle.com&gt;
    Acked-by: Douglas Gilbert &lt;dougg@torque.net&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/block/ll_rw_blk.c b/block/ll_rw_blk.c
index 38c293b987b7..cf8752abd61a 100644
--- a/block/ll_rw_blk.c
+++ b/block/ll_rw_blk.c
@@ -1925,6 +1925,8 @@ blk_init_queue_node(request_fn_proc *rfn, spinlock_t *lock, int node_id)
 	blk_queue_max_hw_segments(q, MAX_HW_SEGMENTS);
 	blk_queue_max_phys_segments(q, MAX_PHYS_SEGMENTS);
 
+	q-&gt;sg_reserved_size = INT_MAX;
+
 	/*
 	 * all done
 	 */
diff --git a/block/scsi_ioctl.c b/block/scsi_ioctl.c
index 65c6a3cba6d6..e83f1dbf7c29 100644
--- a/block/scsi_ioctl.c
+++ b/block/scsi_ioctl.c
@@ -78,7 +78,9 @@ static int sg_set_timeout(request_queue_t *q, int __user *p)
 
 static int sg_get_reserved_size(request_queue_t *q, int __user *p)
 {
-	return put_user(q-&gt;sg_reserved_size, p);
+	unsigned val = min(q-&gt;sg_reserved_size, q-&gt;max_sectors &lt;&lt; 9);
+
+	return put_user(val, p);
 }
 
 static int sg_set_reserved_size(request_queue_t *q, int __user *p)
diff --git a/drivers/scsi/sg.c b/drivers/scsi/sg.c
index 81e3bc7b02a1..570977cf9efb 100644
--- a/drivers/scsi/sg.c
+++ b/drivers/scsi/sg.c
@@ -917,6 +917,8 @@ sg_ioctl(struct inode *inode, struct file *filp,
 			return result;
                 if (val &lt; 0)
                         return -EINVAL;
+		val = min_t(int, val,
+				sdp-&gt;device-&gt;request_queue-&gt;max_sectors * 512);
 		if (val != sfp-&gt;reserve.bufflen) {
 			if (sg_res_in_use(sfp) || sfp-&gt;mmap_called)
 				return -EBUSY;
@@ -925,7 +927,8 @@ sg_ioctl(struct inode *inode, struct file *filp,
 		}
 		return 0;
 	case SG_GET_RESERVED_SIZE:
-		val = (int) sfp-&gt;reserve.bufflen;
+		val = min_t(int, sfp-&gt;reserve.bufflen,
+				sdp-&gt;device-&gt;request_queue-&gt;max_sectors * 512);
 		return put_user(val, ip);
 	case SG_SET_COMMAND_Q:
 		result = get_user(val, ip);
@@ -1061,6 +1064,9 @@ sg_ioctl(struct inode *inode, struct file *filp,
 		if (sdp-&gt;detached)
 			return -ENODEV;
 		return scsi_ioctl(sdp-&gt;device, cmd_in, p);
+	case BLKSECTGET:
+		return put_user(sdp-&gt;device-&gt;request_queue-&gt;max_sectors * 512,
+				ip);
 	default:
 		if (read_only)
 			return -EPERM;	/* don't know so take safe approach */
@@ -2339,6 +2345,7 @@ sg_add_sfp(Sg_device * sdp, int dev)
 {
 	Sg_fd *sfp;
 	unsigned long iflags;
+	int bufflen;
 
 	sfp = kzalloc(sizeof(*sfp), GFP_ATOMIC | __GFP_NOWARN);
 	if (!sfp)
@@ -2369,7 +2376,9 @@ sg_add_sfp(Sg_device * sdp, int dev)
 	if (unlikely(sg_big_buff != def_reserved_size))
 		sg_big_buff = def_reserved_size;
 
-	sg_build_reserve(sfp, sg_big_buff);
+	bufflen = min_t(int, sg_big_buff,
+			sdp-&gt;device-&gt;request_queue-&gt;max_sectors * 512);
+	sg_build_reserve(sfp, bufflen);
 	SCSI_LOG_TIMEOUT(3, printk("sg_add_sfp:   bufflen=%d, k_use_sg=%d\n",
 			   sfp-&gt;reserve.bufflen, sfp-&gt;reserve.k_use_sg));
 	return sfp;</pre><hr><pre>commit 61e8b858abe38c1042135065c59f7d339194b50b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Apr 9 11:52:31 2007 -0400

    EHCI: fix remote wakeup regression in 2.6.21-rc
    
    There is one significant difference between the behavior of root hubs
    (as embodied in host controller hardware) and external hubs: When a
    remote-wakeup signal is received, an external hub sends an interrupt
    message at the _end_ of the resume sequence but a root hub generates
    and interrupt at the _beginning_ of the resume sequence.  The host
    system must poll for the end of the sequence.
    
    When ehci-hcd was converted to interrupt-driven operation instead of
    using polling, the remaining need for this particular poll was
    overlooked.  This patch (as894) fixes the problem.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index a74056488234..c7458f7e56cc 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -669,6 +669,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 			 */
 			ehci-&gt;reset_done [i] = jiffies + msecs_to_jiffies (20);
 			ehci_dbg (ehci, "port %d remote wakeup\n", i + 1);
+			mod_timer(&amp;hcd-&gt;rh_timer, ehci-&gt;reset_done[i]);
 		}
 	}
 </pre><hr><pre>commit 5e2a55f25d255a356bdaf2cb04c71b8d76c307a8
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Mar 20 19:03:31 2007 +0100

    USB HID: fix retry &amp; reset logic
    
    The USB HID driver fails to reset its error-retry timeout when there
    has been a long time interval between I/O errors with no successful URB
    completions in the meantime.  As a result, the very next error would
    trigger an immediate reset, even if it was a chance event occurring
    long after the previous error.
    
    More USB keyboards and mice than one might expect end up getting I/O
    errors. Almost always this results from hardware problems of one sort of
    another. For example, people attach the device to a USB extension cable,
    which degrades the signal.  Or they simply have poor quality cables to
    begin with. Or they use a KVM switch which doesn't handle USB messages
    correctly. Etc...
    
    There have been reports from several users in which these I/O
    errors would occur more or less randomly, at intervals ranging from
    seconds to minutes.  The error-handling code in hid-core.c was originally
    meant for situations where a single outage would persist for a few hundred
    ms (electromagnetic interference, for example).  It didn't work right when
    these more sporadic errors occurred, because of a flaw in the logic
    which this patch fixes.
    
    This patch (as873) fixes that oversight.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c
index 7c0fc11e972a..35a41e60f541 100644
--- a/drivers/hid/usbhid/hid-core.c
+++ b/drivers/hid/usbhid/hid-core.c
@@ -554,6 +554,11 @@ static void hid_io_error(struct hid_device *hid)
 	if (usb_get_intfdata(usbhid-&gt;intf) == NULL)
 		goto done;
 
+	/* If it has been a while since the last error, we'll assume
+	 * this a brand new error and reset the retry timeout. */
+	if (time_after(jiffies, usbhid-&gt;stop_retry + HZ/2))
+		usbhid-&gt;retry_delay = 0;
+
 	/* When an error occurs, retry at increasing intervals */
 	if (usbhid-&gt;retry_delay == 0) {
 		usbhid-&gt;retry_delay = 13;	/* Then 26, 52, 104, 104, ... */</pre><hr><pre>commit e009f1b202219c62ea7e277adbb953d703dac983
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Mar 19 15:31:42 2007 -0400

    UHCI: Fix problem caused by lack of terminating QH
    
    This patch (as871) fixes a problem introduced by an earlier change.
    It turns out that some systems really do need to have a terminating
    skeleton QH present whenever FSBR is on.  I don't know any way to tell
    which systems do need it and which don't; the easiest answer is to
    have it there always.
    
    This fixes the NumLock-hang bug reported by Jiri Slaby.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-debug.c b/drivers/usb/host/uhci-debug.c
index 8d24d3dc0a61..1497371583b9 100644
--- a/drivers/usb/host/uhci-debug.c
+++ b/drivers/usb/host/uhci-debug.c
@@ -145,7 +145,8 @@ static int uhci_show_urbp(struct urb_priv *urbp, char *buf, int len, int space)
 	return out - buf;
 }
 
-static int uhci_show_qh(struct uhci_qh *qh, char *buf, int len, int space)
+static int uhci_show_qh(struct uhci_hcd *uhci,
+		struct uhci_qh *qh, char *buf, int len, int space)
 {
 	char *out = buf;
 	int i, nurbs;
@@ -190,6 +191,9 @@ static int uhci_show_qh(struct uhci_qh *qh, char *buf, int len, int space)
 
 	if (list_empty(&amp;qh-&gt;queue)) {
 		out += sprintf(out, "%*s  queue is empty\n", space, "");
+		if (qh == uhci-&gt;skel_async_qh)
+			out += uhci_show_td(uhci-&gt;term_td, out,
+					len - (out - buf), 0);
 	} else {
 		struct urb_priv *urbp = list_entry(qh-&gt;queue.next,
 				struct urb_priv, node);
@@ -343,6 +347,7 @@ static int uhci_sprint_schedule(struct uhci_hcd *uhci, char *buf, int len)
 	struct list_head *tmp, *head;
 	int nframes, nerrs;
 	__le32 link;
+	__le32 fsbr_link;
 
 	static const char * const qh_names[] = {
 		"unlink", "iso", "int128", "int64", "int32", "int16",
@@ -424,21 +429,22 @@ static int uhci_sprint_schedule(struct uhci_hcd *uhci, char *buf, int len)
 
 	out += sprintf(out, "Skeleton QHs\n");
 
+	fsbr_link = 0;
 	for (i = 0; i &lt; UHCI_NUM_SKELQH; ++i) {
 		int cnt = 0;
-		__le32 fsbr_link = 0;
 
 		qh = uhci-&gt;skelqh[i];
 		out += sprintf(out, "- skel_%s_qh\n", qh_names[i]); \
-		out += uhci_show_qh(qh, out, len - (out - buf), 4);
+		out += uhci_show_qh(uhci, qh, out, len - (out - buf), 4);
 
 		/* Last QH is the Terminating QH, it's different */
 		if (i == SKEL_TERM) {
 			if (qh_element(qh) != LINK_TO_TD(uhci-&gt;term_td))
 				out += sprintf(out, "    skel_term_qh element is not set to term_td!\n");
-			if (link == LINK_TO_QH(uhci-&gt;skel_term_qh))
-				goto check_qh_link;
-			continue;
+			link = fsbr_link;
+			if (!link)
+				link = LINK_TO_QH(uhci-&gt;skel_term_qh);
+			goto check_qh_link;
 		}
 
 		head = &amp;qh-&gt;node;
@@ -448,7 +454,7 @@ static int uhci_sprint_schedule(struct uhci_hcd *uhci, char *buf, int len)
 			qh = list_entry(tmp, struct uhci_qh, node);
 			tmp = tmp-&gt;next;
 			if (++cnt &lt;= 10)
-				out += uhci_show_qh(qh, out,
+				out += uhci_show_qh(uhci, qh, out,
 						len - (out - buf), 4);
 			if (!fsbr_link &amp;&amp; qh-&gt;skel &gt;= SKEL_FSBR)
 				fsbr_link = LINK_TO_QH(qh);
@@ -463,8 +469,6 @@ static int uhci_sprint_schedule(struct uhci_hcd *uhci, char *buf, int len)
 			link = LINK_TO_QH(uhci-&gt;skel_async_qh);
 		else if (!uhci-&gt;fsbr_is_on)
 			;
-		else if (fsbr_link)
-			link = fsbr_link;
 		else
 			link = LINK_TO_QH(uhci-&gt;skel_term_qh);
 check_qh_link:
@@ -573,8 +577,8 @@ static const struct file_operations uhci_debug_operations = {
 static inline void lprintk(char *buf)
 {}
 
-static inline int uhci_show_qh(struct uhci_qh *qh, char *buf,
-		int len, int space)
+static inline int uhci_show_qh(struct uhci_hcd *uhci,
+		struct uhci_qh *qh, char *buf, int len, int space)
 {
 	return 0;
 }
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 44da4334f1d6..d22da26ff167 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -632,7 +632,8 @@ static int uhci_start(struct usb_hcd *hcd)
 	 */
 	for (i = SKEL_ISO + 1; i &lt; SKEL_ASYNC; ++i)
 		uhci-&gt;skelqh[i]-&gt;link = LINK_TO_QH(uhci-&gt;skel_async_qh);
-	uhci-&gt;skel_async_qh-&gt;link = uhci-&gt;skel_term_qh-&gt;link = UHCI_PTR_TERM;
+	uhci-&gt;skel_async_qh-&gt;link = UHCI_PTR_TERM;
+	uhci-&gt;skel_term_qh-&gt;link = LINK_TO_QH(uhci-&gt;skel_term_qh);
 
 	/* This dummy TD is to work around a bug in Intel PIIX controllers */
 	uhci_fill_td(uhci-&gt;term_td, 0, uhci_explen(0) |
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index f4ebdb3e488f..19a0cc02b9a2 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -45,43 +45,27 @@ static inline void uhci_clear_next_interrupt(struct uhci_hcd *uhci)
  */
 static void uhci_fsbr_on(struct uhci_hcd *uhci)
 {
-	struct uhci_qh *fsbr_qh, *lqh, *tqh;
+	struct uhci_qh *lqh;
 
+	/* The terminating skeleton QH always points back to the first
+	 * FSBR QH.  Make the last async QH point to the terminating
+	 * skeleton QH. */
 	uhci-&gt;fsbr_is_on = 1;
 	lqh = list_entry(uhci-&gt;skel_async_qh-&gt;node.prev,
 			struct uhci_qh, node);
-
-	/* Find the first FSBR QH.  Linear search through the list is
-	 * acceptable because normally FSBR gets turned on as soon as
-	 * one QH needs it. */
-	fsbr_qh = NULL;
-	list_for_each_entry_reverse(tqh, &amp;uhci-&gt;skel_async_qh-&gt;node, node) {
-		if (tqh-&gt;skel &lt; SKEL_FSBR)
-			break;
-		fsbr_qh = tqh;
-	}
-
-	/* No FSBR QH means we must insert the terminating skeleton QH */
-	if (!fsbr_qh) {
-		uhci-&gt;skel_term_qh-&gt;link = LINK_TO_QH(uhci-&gt;skel_term_qh);
-		wmb();
-		lqh-&gt;link = uhci-&gt;skel_term_qh-&gt;link;
-
-	/* Otherwise loop the last QH to the first FSBR QH */
-	} else
-		lqh-&gt;link = LINK_TO_QH(fsbr_qh);
+	lqh-&gt;link = LINK_TO_QH(uhci-&gt;skel_term_qh);
 }
 
 static void uhci_fsbr_off(struct uhci_hcd *uhci)
 {
 	struct uhci_qh *lqh;
 
+	/* Remove the link from the last async QH to the terminating
+	 * skeleton QH. */
 	uhci-&gt;fsbr_is_on = 0;
 	lqh = list_entry(uhci-&gt;skel_async_qh-&gt;node.prev,
 			struct uhci_qh, node);
-
-	/* End the async list normally and unlink the terminating QH */
-	lqh-&gt;link = uhci-&gt;skel_term_qh-&gt;link = UHCI_PTR_TERM;
+	lqh-&gt;link = UHCI_PTR_TERM;
 }
 
 static void uhci_add_fsbr(struct uhci_hcd *uhci, struct urb *urb)
@@ -464,9 +448,8 @@ static void link_interrupt(struct uhci_hcd *uhci, struct uhci_qh *qh)
  */
 static void link_async(struct uhci_hcd *uhci, struct uhci_qh *qh)
 {
-	struct uhci_qh *pqh, *lqh;
+	struct uhci_qh *pqh;
 	__le32 link_to_new_qh;
-	__le32 *extra_link = &amp;link_to_new_qh;
 
 	/* Find the predecessor QH for our new one and insert it in the list.
 	 * The list of QHs is expected to be short, so linear search won't
@@ -476,31 +459,17 @@ static void link_async(struct uhci_hcd *uhci, struct uhci_qh *qh)
 			break;
 	}
 	list_add(&amp;qh-&gt;node, &amp;pqh-&gt;node);
-	qh-&gt;link = pqh-&gt;link;
-
-	link_to_new_qh = LINK_TO_QH(qh);
-
-	/* If this is now the first FSBR QH, take special action */
-	if (uhci-&gt;fsbr_is_on &amp;&amp; pqh-&gt;skel &lt; SKEL_FSBR &amp;&amp;
-			qh-&gt;skel &gt;= SKEL_FSBR) {
-		lqh = list_entry(uhci-&gt;skel_async_qh-&gt;node.prev,
-				struct uhci_qh, node);
-
-		/* If the new QH is also the last one, we must unlink
-		 * the terminating skeleton QH and make the new QH point
-		 * back to itself. */
-		if (qh == lqh) {
-			qh-&gt;link = link_to_new_qh;
-			extra_link = &amp;uhci-&gt;skel_term_qh-&gt;link;
-
-		/* Otherwise the last QH must point to the new QH */
-		} else
-			extra_link = &amp;lqh-&gt;link;
-	}
 
 	/* Link it into the schedule */
+	qh-&gt;link = pqh-&gt;link;
 	wmb();
-	*extra_link = pqh-&gt;link = link_to_new_qh;
+	link_to_new_qh = LINK_TO_QH(qh);
+	pqh-&gt;link = link_to_new_qh;
+
+	/* If this is now the first FSBR QH, link the terminating skeleton
+	 * QH to it. */
+	if (pqh-&gt;skel &lt; SKEL_FSBR &amp;&amp; qh-&gt;skel &gt;= SKEL_FSBR)
+		uhci-&gt;skel_term_qh-&gt;link = link_to_new_qh;
 }
 
 /*
@@ -561,31 +530,16 @@ static void unlink_interrupt(struct uhci_hcd *uhci, struct uhci_qh *qh)
  */
 static void unlink_async(struct uhci_hcd *uhci, struct uhci_qh *qh)
 {
-	struct uhci_qh *pqh, *lqh;
+	struct uhci_qh *pqh;
 	__le32 link_to_next_qh = qh-&gt;link;
 
 	pqh = list_entry(qh-&gt;node.prev, struct uhci_qh, node);
-
-	/* If this is the first FSBQ QH, take special action */
-	if (uhci-&gt;fsbr_is_on &amp;&amp; pqh-&gt;skel &lt; SKEL_FSBR &amp;&amp;
-			qh-&gt;skel &gt;= SKEL_FSBR) {
-		lqh = list_entry(uhci-&gt;skel_async_qh-&gt;node.prev,
-				struct uhci_qh, node);
-
-		/* If this QH is also the last one, we must link in
-		 * the terminating skeleton QH. */
-		if (qh == lqh) {
-			link_to_next_qh = LINK_TO_QH(uhci-&gt;skel_term_qh);
-			uhci-&gt;skel_term_qh-&gt;link = link_to_next_qh;
-			wmb();
-			qh-&gt;link = link_to_next_qh;
-
-		/* Otherwise the last QH must point to the new first FSBR QH */
-		} else
-			lqh-&gt;link = link_to_next_qh;
-	}
-
 	pqh-&gt;link = link_to_next_qh;
+
+	/* If this was the old first FSBR QH, link the terminating skeleton
+	 * QH to the next (new first FSBR) QH. */
+	if (pqh-&gt;skel &lt; SKEL_FSBR &amp;&amp; qh-&gt;skel &gt;= SKEL_FSBR)
+		uhci-&gt;skel_term_qh-&gt;link = link_to_next_qh;
 	mb();
 }
 
@@ -1217,7 +1171,7 @@ static int uhci_result_common(struct uhci_hcd *uhci, struct urb *urb)
 
 				if (debug &gt; 1 &amp;&amp; errbuf) {
 					/* Print the chain for debugging */
-					uhci_show_qh(urbp-&gt;qh, errbuf,
+					uhci_show_qh(uhci, urbp-&gt;qh, errbuf,
 							ERRBUF_LEN, 0);
 					lprintk(errbuf);
 				}</pre><hr><pre>commit 5ec71db59ac07eeac89a54b35a90c181bbd3c445
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Mar 16 15:53:07 2007 -0400

    usblp: quirk flag and device entry for Seiko Epson M129C printer
    
    This patch (as872) adds a device table entry and a new quirk flag to
    the usblp driver for the Seiko Epson Receipt printer.  This printer
    returns Vendor-Specific values for bInterfaceClass and
    bInterfaceSubClass, but the bInterfaceProtocol value is valid and it
    works with usblp.  The new quirks flag tells the driver to ignore the
    Class and SubClass values in the interface descriptor.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: Vojtech Pavlik &lt;vojtech@suse.cz&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/class/usblp.c b/drivers/usb/class/usblp.c
index 63e50a1f1396..6584cf00f7f3 100644
--- a/drivers/usb/class/usblp.c
+++ b/drivers/usb/class/usblp.c
@@ -202,6 +202,7 @@ struct quirk_printer_struct {
 
 #define USBLP_QUIRK_BIDIR	0x1	/* reports bidir but requires unidirectional mode (no INs/reads) */
 #define USBLP_QUIRK_USB_INIT	0x2	/* needs vendor USB init string */
+#define USBLP_QUIRK_BAD_CLASS	0x4	/* descriptor uses vendor-specific Class or SubClass */
 
 static const struct quirk_printer_struct quirk_printers[] = {
 	{ 0x03f0, 0x0004, USBLP_QUIRK_BIDIR }, /* HP DeskJet 895C */
@@ -218,6 +219,7 @@ static const struct quirk_printer_struct quirk_printers[] = {
 	{ 0x0409, 0xf0be, USBLP_QUIRK_BIDIR }, /* NEC Picty920 (HP OEM) */
 	{ 0x0409, 0xf1be, USBLP_QUIRK_BIDIR }, /* NEC Picty800 (HP OEM) */
 	{ 0x0482, 0x0010, USBLP_QUIRK_BIDIR }, /* Kyocera Mita FS 820, by zut &lt;kernel@zut.de&gt; */
+	{ 0x04b8, 0x0202, USBLP_QUIRK_BAD_CLASS }, /* Seiko Epson Receipt Printer M129C */
 	{ 0, 0 }
 };
 
@@ -1048,7 +1050,8 @@ static int usblp_select_alts(struct usblp *usblp)
 		ifd = &amp;if_alt-&gt;altsetting[i];
 
 		if (ifd-&gt;desc.bInterfaceClass != 7 || ifd-&gt;desc.bInterfaceSubClass != 1)
-			continue;
+			if (!(usblp-&gt;quirks &amp; USBLP_QUIRK_BAD_CLASS))
+				continue;
 
 		if (ifd-&gt;desc.bInterfaceProtocol &lt; USBLP_FIRST_PROTOCOL ||
 		    ifd-&gt;desc.bInterfaceProtocol &gt; USBLP_LAST_PROTOCOL)
@@ -1232,6 +1235,7 @@ static struct usb_device_id usblp_ids [] = {
 	{ USB_INTERFACE_INFO(7, 1, 1) },
 	{ USB_INTERFACE_INFO(7, 1, 2) },
 	{ USB_INTERFACE_INFO(7, 1, 3) },
+	{ USB_DEVICE(0x04b8, 0x0202) },	/* Seiko Epson Receipt Printer M129C */
 	{ }						/* Terminating entry */
 };
 </pre><hr><pre>commit e7b0d26a86943370c04d6833c6edba2a72a6e240
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Mar 15 15:51:28 2007 -0400

    [PATCH] sysfs: reinstate exclusion between method calls and attribute unregistration
    
    This patch (as869) reinstates the mutual exclusion between sysfs
    attribute method calls and attribute unregistration.  The
    previously-reported deadlocks have been fixed, and this exclusion is
    by far the simplest way to avoid races during driver unbinding.
    
    The check for orphaned read-buffers has been moved down slightly, so
    that the remainder of a partially-read buffer will still be available
    to userspace even after the attribute has been unregistered.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: Hugh Dickins &lt;hugh@veritas.com&gt;
    Cc: Cornelia Huck &lt;cornelia.huck@de.ibm.com&gt;
    Cc: Oliver Neukum &lt;oneukum@suse.de&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;

diff --git a/fs/sysfs/file.c b/fs/sysfs/file.c
index 1bafdf6e171c..fc4633378dc0 100644
--- a/fs/sysfs/file.c
+++ b/fs/sysfs/file.c
@@ -168,12 +168,12 @@ sysfs_read_file(struct file *file, char __user *buf, size_t count, loff_t *ppos)
 	ssize_t retval = 0;
 
 	down(&amp;buffer-&gt;sem);
-	if (buffer-&gt;orphaned) {
-		retval = -ENODEV;
-		goto out;
-	}
 	if (buffer-&gt;needs_read_fill) {
-		if ((retval = fill_read_buffer(file-&gt;f_path.dentry,buffer)))
+		if (buffer-&gt;orphaned)
+			retval = -ENODEV;
+		else
+			retval = fill_read_buffer(file-&gt;f_path.dentry,buffer);
+		if (retval)
 			goto out;
 	}
 	pr_debug("%s: count = %zd, ppos = %lld, buf = %s\n",
diff --git a/fs/sysfs/inode.c b/fs/sysfs/inode.c
index ccb7d722c558..4de5c6b89918 100644
--- a/fs/sysfs/inode.c
+++ b/fs/sysfs/inode.c
@@ -222,13 +222,17 @@ const unsigned char * sysfs_get_name(struct sysfs_dirent *sd)
 
 static inline void orphan_all_buffers(struct inode *node)
 {
-	struct sysfs_buffer_collection *set = node-&gt;i_private;
+	struct sysfs_buffer_collection *set;
 	struct sysfs_buffer *buf;
 
 	mutex_lock_nested(&amp;node-&gt;i_mutex, I_MUTEX_CHILD);
-	if (node-&gt;i_private) {
-		list_for_each_entry(buf, &amp;set-&gt;associates, associates)
+	set = node-&gt;i_private;
+	if (set) {
+		list_for_each_entry(buf, &amp;set-&gt;associates, associates) {
+			down(&amp;buf-&gt;sem);
 			buf-&gt;orphaned = 1;
+			up(&amp;buf-&gt;sem);
+		}
 	}
 	mutex_unlock(&amp;node-&gt;i_mutex);
 }</pre><hr><pre>commit d9a9cdfb078d755e648d53ec25b7370f84ee5729
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Mar 15 15:50:34 2007 -0400

    [PATCH] sysfs and driver core: add callback helper, used by SCSI and S390
    
    This patch (as868) adds a helper routine for device drivers that need
    to set up a callback to perform some action in a different process's
    context.  This is intended for use by attribute methods that want to
    unregister themselves or their parent device.  Attribute method calls
    are mutually exclusive with unregistration, so such actions cannot be
    taken directly.
    
    Two attribute methods are converted to use the new helper routine: one
    for SCSI device deletion and one for System/390 ccwgroup devices.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: Hugh Dickins &lt;hugh@veritas.com&gt;
    Cc: Cornelia Huck &lt;cornelia.huck@de.ibm.com&gt;
    Cc: Oliver Neukum &lt;oneukum@suse.de&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;

diff --git a/drivers/base/core.c b/drivers/base/core.c
index f191afe62b4d..ad0f4a2f25c4 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -407,6 +407,35 @@ void device_remove_bin_file(struct device *dev, struct bin_attribute *attr)
 }
 EXPORT_SYMBOL_GPL(device_remove_bin_file);
 
+/**
+ * device_schedule_callback - helper to schedule a callback for a device
+ * @dev: device.
+ * @func: callback function to invoke later.
+ *
+ * Attribute methods must not unregister themselves or their parent device
+ * (which would amount to the same thing).  Attempts to do so will deadlock,
+ * since unregistration is mutually exclusive with driver callbacks.
+ *
+ * Instead methods can call this routine, which will attempt to allocate
+ * and schedule a workqueue request to call back @func with @dev as its
+ * argument in the workqueue's process context.  @dev will be pinned until
+ * @func returns.
+ *
+ * Returns 0 if the request was submitted, -ENOMEM if storage could not
+ * be allocated.
+ *
+ * NOTE: This routine won't work if CONFIG_SYSFS isn't set!  It uses an
+ * underlying sysfs routine (since it is intended for use by attribute
+ * methods), and if sysfs isn't available you'll get nothing but -ENOSYS.
+ */
+int device_schedule_callback(struct device *dev,
+		void (*func)(struct device *))
+{
+	return sysfs_schedule_callback(&amp;dev-&gt;kobj,
+			(void (*)(void *)) func, dev);
+}
+EXPORT_SYMBOL_GPL(device_schedule_callback);
+
 static void klist_children_get(struct klist_node *n)
 {
 	struct device *dev = container_of(n, struct device, knode_parent);
diff --git a/drivers/s390/cio/ccwgroup.c b/drivers/s390/cio/ccwgroup.c
index d48e3ca4752c..5aeb68e732b0 100644
--- a/drivers/s390/cio/ccwgroup.c
+++ b/drivers/s390/cio/ccwgroup.c
@@ -71,19 +71,31 @@ __ccwgroup_remove_symlinks(struct ccwgroup_device *gdev)
  * Provide an 'ungroup' attribute so the user can remove group devices no
  * longer needed or accidentially created. Saves memory :)
  */
+static void ccwgroup_ungroup_callback(struct device *dev)
+{
+	struct ccwgroup_device *gdev = to_ccwgroupdev(dev);
+
+	__ccwgroup_remove_symlinks(gdev);
+	device_unregister(dev);
+}
+
 static ssize_t
 ccwgroup_ungroup_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
 	struct ccwgroup_device *gdev;
+	int rc;
 
 	gdev = to_ccwgroupdev(dev);
 
 	if (gdev-&gt;state != CCWGROUP_OFFLINE)
 		return -EINVAL;
 
-	__ccwgroup_remove_symlinks(gdev);
-	device_unregister(dev);
-
+	/* Note that we cannot unregister the device from one of its
+	 * attribute methods, so we have to use this roundabout approach.
+	 */
+	rc = device_schedule_callback(dev, ccwgroup_ungroup_callback);
+	if (rc)
+		count = rc;
 	return count;
 }
 
diff --git a/drivers/scsi/scsi_sysfs.c b/drivers/scsi/scsi_sysfs.c
index c275dcac3f18..939de0de18bc 100644
--- a/drivers/scsi/scsi_sysfs.c
+++ b/drivers/scsi/scsi_sysfs.c
@@ -452,10 +452,22 @@ store_rescan_field (struct device *dev, struct device_attribute *attr, const cha
 }
 static DEVICE_ATTR(rescan, S_IWUSR, NULL, store_rescan_field);
 
+static void sdev_store_delete_callback(struct device *dev)
+{
+	scsi_remove_device(to_scsi_device(dev));
+}
+
 static ssize_t sdev_store_delete(struct device *dev, struct device_attribute *attr, const char *buf,
 				 size_t count)
 {
-	scsi_remove_device(to_scsi_device(dev));
+	int rc;
+
+	/* An attribute cannot be unregistered by one of its own methods,
+	 * so we have to use this roundabout approach.
+	 */
+	rc = device_schedule_callback(dev, sdev_store_delete_callback);
+	if (rc)
+		count = rc;
 	return count;
 };
 static DEVICE_ATTR(delete, S_IWUSR, NULL, sdev_store_delete);
diff --git a/fs/sysfs/file.c b/fs/sysfs/file.c
index 8d4d839a9d88..1bafdf6e171c 100644
--- a/fs/sysfs/file.c
+++ b/fs/sysfs/file.c
@@ -629,6 +629,60 @@ void sysfs_remove_file_from_group(struct kobject *kobj,
 }
 EXPORT_SYMBOL_GPL(sysfs_remove_file_from_group);
 
+struct sysfs_schedule_callback_struct {
+	struct kobject 		*kobj;
+	void			(*func)(void *);
+	void			*data;
+	struct work_struct	work;
+};
+
+static void sysfs_schedule_callback_work(struct work_struct *work)
+{
+	struct sysfs_schedule_callback_struct *ss = container_of(work,
+			struct sysfs_schedule_callback_struct, work);
+
+	(ss-&gt;func)(ss-&gt;data);
+	kobject_put(ss-&gt;kobj);
+	kfree(ss);
+}
+
+/**
+ * sysfs_schedule_callback - helper to schedule a callback for a kobject
+ * @kobj: object we're acting for.
+ * @func: callback function to invoke later.
+ * @data: argument to pass to @func.
+ *
+ * sysfs attribute methods must not unregister themselves or their parent
+ * kobject (which would amount to the same thing).  Attempts to do so will
+ * deadlock, since unregistration is mutually exclusive with driver
+ * callbacks.
+ *
+ * Instead methods can call this routine, which will attempt to allocate
+ * and schedule a workqueue request to call back @func with @data as its
+ * argument in the workqueue's process context.  @kobj will be pinned
+ * until @func returns.
+ *
+ * Returns 0 if the request was submitted, -ENOMEM if storage could not
+ * be allocated.
+ */
+int sysfs_schedule_callback(struct kobject *kobj, void (*func)(void *),
+		void *data)
+{
+	struct sysfs_schedule_callback_struct *ss;
+
+	ss = kmalloc(sizeof(*ss), GFP_KERNEL);
+	if (!ss)
+		return -ENOMEM;
+	kobject_get(kobj);
+	ss-&gt;kobj = kobj;
+	ss-&gt;func = func;
+	ss-&gt;data = data;
+	INIT_WORK(&amp;ss-&gt;work, sysfs_schedule_callback_work);
+	schedule_work(&amp;ss-&gt;work);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sysfs_schedule_callback);
+
 
 EXPORT_SYMBOL_GPL(sysfs_create_file);
 EXPORT_SYMBOL_GPL(sysfs_remove_file);
diff --git a/include/linux/device.h b/include/linux/device.h
index 39a3199a826d..caad9bba9652 100644
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@ -353,6 +353,8 @@ extern int __must_check device_create_bin_file(struct device *dev,
 					       struct bin_attribute *attr);
 extern void device_remove_bin_file(struct device *dev,
 				   struct bin_attribute *attr);
+extern int device_schedule_callback(struct device *dev,
+		void (*func)(struct device *));
 
 /* device resource management */
 typedef void (*dr_release_t)(struct device *dev, void *res);
diff --git a/include/linux/sysfs.h b/include/linux/sysfs.h
index 523405e1e1f6..0544edda7168 100644
--- a/include/linux/sysfs.h
+++ b/include/linux/sysfs.h
@@ -78,6 +78,9 @@ struct sysfs_ops {
 
 #ifdef CONFIG_SYSFS
 
+extern int sysfs_schedule_callback(struct kobject *kobj,
+		void (*func)(void *), void *data);
+
 extern int __must_check
 sysfs_create_dir(struct kobject *, struct dentry *);
 
@@ -132,6 +135,12 @@ extern int __must_check sysfs_init(void);
 
 #else /* CONFIG_SYSFS */
 
+static inline int sysfs_schedule_callback(struct kobject *kobj,
+		void (*func)(void *), void *data)
+{
+	return -ENOSYS;
+}
+
 static inline int sysfs_create_dir(struct kobject * k, struct dentry *shadow)
 {
 	return 0;</pre><hr><pre>commit 88018158d1253ab4868a2f9204cc390c711fd9b9
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Feb 26 17:16:06 2007 -0500

    UHCI: fix port resume problem
    
    This patch (as863) fixes a problem encountered sometimes when resuming
    a port on a UHCI controller.  The hardware may turn off the
    Resume-Detect bit before turning off the Suspend bit, leading usbcore
    to think that the port is still suspended and the resume has failed.
    The patch makes uhci_finish_suspend() wait until both bits are safely
    off.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hub.c b/drivers/usb/host/uhci-hub.c
index bacc25c53ba3..8e4427aebb14 100644
--- a/drivers/usb/host/uhci-hub.c
+++ b/drivers/usb/host/uhci-hub.c
@@ -33,6 +33,9 @@ static __u8 root_hub_hub_des[] =
 /* status change bits:  nonzero writes will clear */
 #define RWC_BITS	(USBPORTSC_OCC | USBPORTSC_PEC | USBPORTSC_CSC)
 
+/* suspend/resume bits: port suspended or port resuming */
+#define SUSPEND_BITS	(USBPORTSC_SUSP | USBPORTSC_RD)
+
 /* A port that either is connected or has a changed-bit set will prevent
  * us from AUTO_STOPPING.
  */
@@ -96,8 +99,8 @@ static void uhci_finish_suspend(struct uhci_hcd *uhci, int port,
 	int status;
 	int i;
 
-	if (inw(port_addr) &amp; (USBPORTSC_SUSP | USBPORTSC_RD)) {
-		CLR_RH_PORTSTAT(USBPORTSC_SUSP | USBPORTSC_RD);
+	if (inw(port_addr) &amp; SUSPEND_BITS) {
+		CLR_RH_PORTSTAT(SUSPEND_BITS);
 		if (test_bit(port, &amp;uhci-&gt;resuming_ports))
 			set_bit(port, &amp;uhci-&gt;port_c_suspend);
 
@@ -107,7 +110,7 @@ static void uhci_finish_suspend(struct uhci_hcd *uhci, int port,
 		 * Experiments show that some controllers take longer, so
 		 * we'll poll for completion. */
 		for (i = 0; i &lt; 10; ++i) {
-			if (!(inw(port_addr) &amp; USBPORTSC_RD))
+			if (!(inw(port_addr) &amp; SUSPEND_BITS))
 				break;
 			udelay(1);
 		}
@@ -289,7 +292,7 @@ static int uhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 			wPortStatus |= USB_PORT_STAT_CONNECTION;
 		if (status &amp; USBPORTSC_PE) {
 			wPortStatus |= USB_PORT_STAT_ENABLE;
-			if (status &amp; (USBPORTSC_SUSP | USBPORTSC_RD))
+			if (status &amp; SUSPEND_BITS)
 				wPortStatus |= USB_PORT_STAT_SUSPEND;
 		}
 		if (status &amp; USBPORTSC_OC)</pre><hr><pre>commit 97b9eb91dc131a10342da1f604e5bd8b1316abdb
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Feb 26 14:56:14 2007 -0500

    USB: set the correct interval for interrupt URBs
    
    This patch (as862) fixes a couple of bugs in the way usbcore handles
    intervals for interrupt URBs.  usb_interrupt_msg (and usb_bulk_msg for
    backward compatibility) don't set the interval correctly for
    high-speed devices.  proc_do_submiturb() doesn't set it correctly when
    a bulk URB is submitted to an interrupt endpoint.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 274f14f1633e..36e7a843bf91 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -912,7 +912,7 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 	struct async *as;
 	struct usb_ctrlrequest *dr = NULL;
 	unsigned int u, totlen, isofrmlen;
-	int ret, interval = 0, ifnum = -1;
+	int ret, ifnum = -1;
 
 	if (uurb-&gt;flags &amp; ~(USBDEVFS_URB_ISO_ASAP|USBDEVFS_URB_SHORT_NOT_OK|
 			   URB_NO_FSBR|URB_ZERO_PACKET))
@@ -992,7 +992,6 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 		if ((ep-&gt;desc.bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK)
 				!= USB_ENDPOINT_XFER_ISOC)
 			return -EINVAL;
-		interval = 1 &lt;&lt; min (15, ep-&gt;desc.bInterval - 1);
 		isofrmlen = sizeof(struct usbdevfs_iso_packet_desc) * uurb-&gt;number_of_packets;
 		if (!(isopkt = kmalloc(isofrmlen, GFP_KERNEL)))
 			return -ENOMEM;
@@ -1021,10 +1020,6 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 		if ((ep-&gt;desc.bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK)
 				!= USB_ENDPOINT_XFER_INT)
 			return -EINVAL;
-		if (ps-&gt;dev-&gt;speed == USB_SPEED_HIGH)
-			interval = 1 &lt;&lt; min (15, ep-&gt;desc.bInterval - 1);
-		else
-			interval = ep-&gt;desc.bInterval;
 		if (uurb-&gt;buffer_length &gt; MAX_USBFS_BUFFER_SIZE)
 			return -EINVAL;
 		if (!access_ok((uurb-&gt;endpoint &amp; USB_DIR_IN) ? VERIFY_WRITE : VERIFY_READ, uurb-&gt;buffer, uurb-&gt;buffer_length))
@@ -1053,7 +1048,11 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 	as-&gt;urb-&gt;setup_packet = (unsigned char*)dr;
 	as-&gt;urb-&gt;start_frame = uurb-&gt;start_frame;
 	as-&gt;urb-&gt;number_of_packets = uurb-&gt;number_of_packets;
-	as-&gt;urb-&gt;interval = interval;
+	if (uurb-&gt;type == USBDEVFS_URB_TYPE_ISO ||
+			ps-&gt;dev-&gt;speed == USB_SPEED_HIGH)
+		as-&gt;urb-&gt;interval = 1 &lt;&lt; min(15, ep-&gt;desc.bInterval - 1);
+	else
+		as-&gt;urb-&gt;interval = ep-&gt;desc.bInterval;
         as-&gt;urb-&gt;context = as;
         as-&gt;urb-&gt;complete = async_completed;
 	for (totlen = u = 0; u &lt; uurb-&gt;number_of_packets; u++) {
diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 2f17468b5c1e..217a3d6d0a06 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -221,10 +221,15 @@ int usb_bulk_msg(struct usb_device *usb_dev, unsigned int pipe,
 
 	if ((ep-&gt;desc.bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK) ==
 			USB_ENDPOINT_XFER_INT) {
+		int interval;
+
+		if (usb_dev-&gt;speed == USB_SPEED_HIGH)
+			interval = 1 &lt;&lt; min(15, ep-&gt;desc.bInterval - 1);
+		else
+			interval = ep-&gt;desc.bInterval;
 		pipe = (pipe &amp; ~(3 &lt;&lt; 30)) | (PIPE_INTERRUPT &lt;&lt; 30);
 		usb_fill_int_urb(urb, usb_dev, pipe, data, len,
-				usb_api_blocking_completion, NULL,
-				ep-&gt;desc.bInterval);
+				usb_api_blocking_completion, NULL, interval);
 	} else
 		usb_fill_bulk_urb(urb, usb_dev, pipe, data, len,
 				usb_api_blocking_completion, NULL);</pre>
    <div class="pagination">
        <a href='2_110.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><span>[111]</span><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_112.html'>Next&gt;&gt;</a>
    <div>
</body>
