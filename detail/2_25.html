<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_24.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><span>[25]</span><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_26.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit fc0855f2747a0e21d86b7e63c50bf234fa766184
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Nov 20 13:53:58 2015 -0500

    USB: EHCI: warn on unexpectedly active QH
    
    This patch adds a new warning message to ehci-hcd.  The warning is
    triggered whenever the driver finds that the hardware has set the
    Active bit in a QH at a time when the driver expects the QH to be
    completely idle.  Such bugs have been observed by users in the past,
    and since they can lead to serious problems (such as inability to
    unlink an URB that never completes), it would be good to know about
    them when they occur.
    
    This won't fix these bugs; that's a bigger job for a later patch.  But
    success isn't guaranteed, since this depends on aspects of the
    hardware which are not documented in the EHCI spec or for which the
    spec's recommendations are clearly unworkable.  It therefore seems
    worthwhile to check for these bugs proactively.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Michael Reutman &lt;mreutman@epiqsolutions.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 54f5332f814d..aad0777240d3 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -132,10 +132,14 @@ qh_refresh (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	 * qtd is updated in qh_completions(). Update the QH
 	 * overlay here.
 	 */
-	if (qh-&gt;hw-&gt;hw_token &amp; ACTIVE_BIT(ehci))
+	if (qh-&gt;hw-&gt;hw_token &amp; ACTIVE_BIT(ehci)) {
 		qh-&gt;hw-&gt;hw_qtd_next = qtd-&gt;hw_next;
-	else
+		if (qh-&gt;should_be_inactive)
+			ehci_warn(ehci, "qh %p should be inactive!\n", qh);
+	} else {
 		qh_update(ehci, qh, qtd);
+	}
+	qh-&gt;should_be_inactive = 0;
 }
 
 /*-------------------------------------------------------------------------*/
@@ -438,6 +442,7 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 					(hw-&gt;hw_token &amp; ACTIVE_BIT(ehci))) {
 				token = hc32_to_cpu(ehci, hw-&gt;hw_token);
 				hw-&gt;hw_token &amp;= ~ACTIVE_BIT(ehci);
+				qh-&gt;should_be_inactive = 1;
 
 				/* An unlink may leave an incomplete
 				 * async transaction in the TT buffer.
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 46f62e41bcde..ec61aedb0067 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -439,6 +439,7 @@ struct ehci_qh {
 	unsigned		dequeue_during_giveback:1;
 	unsigned		exception:1;	/* got a fault, or an unlink
 						   was requested */
+	unsigned		should_be_inactive:1;
 };
 
 /*-------------------------------------------------------------------------*/</pre><hr><pre>commit 8ee10d6292cab0e425f93dbfa1f0e805c449dfc2
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Nov 20 13:53:45 2015 -0500

    USB: EHCI: enhance "async" debugfs output
    
    This patch enhances the "async" debugfs file in ehci-hcd by printing
    out several additional fields in the hardware-accessible data
    structures.  These fields are important for determining the hardware's
    view of the async schedule, in particular, the addresses of the
    current and next qTDs for each QH along with the start address of each
    qTD's data buffer.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-dbg.c b/drivers/usb/host/ehci-dbg.c
index b26b96e25a13..b7d623f1523c 100644
--- a/drivers/usb/host/ehci-dbg.c
+++ b/drivers/usb/host/ehci-dbg.c
@@ -436,7 +436,8 @@ static void qh_lines (
 	scratch = hc32_to_cpup(ehci, &amp;hw-&gt;hw_info1);
 	hw_curr = (mark == '*') ? hc32_to_cpup(ehci, &amp;hw-&gt;hw_current) : 0;
 	temp = scnprintf (next, size,
-			"qh/%p dev%d %cs ep%d %08x %08x (%08x%c %s nak%d)",
+			"qh/%p dev%d %cs ep%d %08x %08x (%08x%c %s nak%d)"
+			" [cur %08x next %08x buf[0] %08x]",
 			qh, scratch &amp; 0x007f,
 			speed_char (scratch),
 			(scratch &gt;&gt; 8) &amp; 0x000f,
@@ -444,7 +445,10 @@ static void qh_lines (
 			hc32_to_cpup(ehci, &amp;hw-&gt;hw_token), mark,
 			(cpu_to_hc32(ehci, QTD_TOGGLE) &amp; hw-&gt;hw_token)
 				? "data1" : "data0",
-			(hc32_to_cpup(ehci, &amp;hw-&gt;hw_alt_next) &gt;&gt; 1) &amp; 0x0f);
+			(hc32_to_cpup(ehci, &amp;hw-&gt;hw_alt_next) &gt;&gt; 1) &amp; 0x0f,
+			hc32_to_cpup(ehci, &amp;hw-&gt;hw_current),
+			hc32_to_cpup(ehci, &amp;hw-&gt;hw_qtd_next),
+			hc32_to_cpup(ehci, &amp;hw-&gt;hw_buf[0]));
 	size -= temp;
 	next += temp;
 
@@ -464,7 +468,8 @@ static void qh_lines (
 				mark = '/';
 		}
 		temp = snprintf (next, size,
-				"\n\t%p%c%s len=%d %08x urb %p",
+				"\n\t%p%c%s len=%d %08x urb %p"
+				" [td %08x buf[0] %08x]",
 				td, mark, ({ char *tmp;
 				 switch ((scratch&gt;&gt;8)&amp;0x03) {
 				 case 0: tmp = "out"; break;
@@ -474,7 +479,9 @@ static void qh_lines (
 				 } tmp;}),
 				(scratch &gt;&gt; 16) &amp; 0x7fff,
 				scratch,
-				td-&gt;urb);
+				td-&gt;urb,
+				(u32) td-&gt;qtd_dma,
+				hc32_to_cpup(ehci, &amp;td-&gt;hw_buf[0]));
 		if (size &lt; temp)
 			temp = size;
 		size -= temp;</pre><hr><pre>commit a016a816bb96088ce4cd0ec890e256e4a63dfb47
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Nov 20 13:53:35 2015 -0500

    USB: add usbfs snooping for REAP and DISCARD
    
    This patch improves the usbfs_snoop debugging facility by adding
    messages for a couple of significant events which, up to now, have not
    been logged.  The events are reaping and discarding (i.e.,
    cancelling) an URB.  The debugging messages include the userspace
    address of the URB being reaped or discarded.
    
    The reaping messages have to be added in four places, in order to
    handle blocking and non-blocking reaps in both normal and 32-bit
    compatibility mode.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 3d41faf6e607..e9f0de3e06db 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -1716,8 +1716,12 @@ static struct async *reap_as(struct usb_dev_state *ps)
 static int proc_reapurb(struct usb_dev_state *ps, void __user *arg)
 {
 	struct async *as = reap_as(ps);
+
 	if (as) {
-		int retval = processcompl(as, (void __user * __user *)arg);
+		int retval;
+
+		snoop(&amp;ps-&gt;dev-&gt;dev, "reap %p\n", as-&gt;userurb);
+		retval = processcompl(as, (void __user * __user *)arg);
 		free_async(as);
 		return retval;
 	}
@@ -1733,6 +1737,7 @@ static int proc_reapurbnonblock(struct usb_dev_state *ps, void __user *arg)
 
 	as = async_getcompleted(ps);
 	if (as) {
+		snoop(&amp;ps-&gt;dev-&gt;dev, "reap %p\n", as-&gt;userurb);
 		retval = processcompl(as, (void __user * __user *)arg);
 		free_async(as);
 	} else {
@@ -1859,8 +1864,12 @@ static int processcompl_compat(struct async *as, void __user * __user *arg)
 static int proc_reapurb_compat(struct usb_dev_state *ps, void __user *arg)
 {
 	struct async *as = reap_as(ps);
+
 	if (as) {
-		int retval = processcompl_compat(as, (void __user * __user *)arg);
+		int retval;
+
+		snoop(&amp;ps-&gt;dev-&gt;dev, "reap %p\n", as-&gt;userurb);
+		retval = processcompl_compat(as, (void __user * __user *)arg);
 		free_async(as);
 		return retval;
 	}
@@ -1876,6 +1885,7 @@ static int proc_reapurbnonblock_compat(struct usb_dev_state *ps, void __user *ar
 
 	as = async_getcompleted(ps);
 	if (as) {
+		snoop(&amp;ps-&gt;dev-&gt;dev, "reap %p\n", as-&gt;userurb);
 		retval = processcompl_compat(as, (void __user * __user *)arg);
 		free_async(as);
 	} else {
@@ -2280,7 +2290,7 @@ static long usbdev_do_ioctl(struct file *file, unsigned int cmd,
 #endif
 
 	case USBDEVFS_DISCARDURB:
-		snoop(&amp;dev-&gt;dev, "%s: DISCARDURB\n", __func__);
+		snoop(&amp;dev-&gt;dev, "%s: DISCARDURB %p\n", __func__, p);
 		ret = proc_unlinkurb(ps, p);
 		break;
 </pre><hr><pre>commit 0290cc9f044a4d24d9a64e81761ac84498dc9d73
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Nov 20 13:53:22 2015 -0500

    USB: limit usbfs snooping of URB contents
    
    The usbfs_snoop facility can be very useful for debugging problems
    involving usbfs.  However, it always prints out the entire contents of
    every URB.  When dealing with large quantities of data, this can be
    less than helpful.
    
    This patch ameliorates the situation by adding a module parameter to
    usbcore for controlling the maximum number of bytes to print when
    snooping an URB.  This makes debugging much easier.  For backward
    compatibility, the default value is set unreasonably high.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt
index 742f69d18fc8..e6b6e056cc11 100644
--- a/Documentation/kernel-parameters.txt
+++ b/Documentation/kernel-parameters.txt
@@ -3874,6 +3874,10 @@ bytes respectively. Such letter suffixes can also be entirely omitted.
 	usbcore.usbfs_snoop=
 			[USB] Set to log all usbfs traffic (default 0 = off).
 
+	usbcore.usbfs_snoop_max=
+			[USB] Maximum number of bytes to snoop in each URB
+			(default = 65536).
+
 	usbcore.blinkenlights=
 			[USB] Set to cycle leds on hubs (default 0 = off).
 
diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 38ae877c46e3..3d41faf6e607 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -100,6 +100,11 @@ static bool usbfs_snoop;
 module_param(usbfs_snoop, bool, S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(usbfs_snoop, "true to log all usbfs traffic");
 
+static unsigned usbfs_snoop_max = 65536;
+module_param(usbfs_snoop_max, uint, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(usbfs_snoop_max,
+		"maximum number of bytes to print while snooping");
+
 #define snoop(dev, format, arg...)				\
 	do {							\
 		if (usbfs_snoop)				\
@@ -392,6 +397,7 @@ static void snoop_urb(struct usb_device *udev,
 					ep, t, d, length, timeout_or_status);
 	}
 
+	data_len = min(data_len, usbfs_snoop_max);
 	if (data &amp;&amp; data_len &gt; 0) {
 		print_hex_dump(KERN_DEBUG, "data: ", DUMP_PREFIX_NONE, 32, 1,
 			data, data_len, 1);
@@ -402,7 +408,8 @@ static void snoop_urb_data(struct urb *urb, unsigned len)
 {
 	int i, size;
 
-	if (!usbfs_snoop)
+	len = min(len, usbfs_snoop_max);
+	if (!usbfs_snoop || len == 0)
 		return;
 
 	if (urb-&gt;num_sgs == 0) {</pre><hr><pre>commit b704f70ce2003c8046d5c0128303aeeb0d93d890
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Aug 3 11:57:29 2015 -0400

    SCSI: fix bug in scsi_dev_info_list matching
    
    The "compatible" matching algorithm used for looking up old-style
    blacklist entries in a scsi_dev_info_list is buggy.  The core of the
    algorithm looks like this:
    
                    if (memcmp(devinfo-&gt;vendor, vendor,
                                min(max, strlen(devinfo-&gt;vendor))))
                            /* not a match */
    
    where max is the length of the device's vendor string after leading
    spaces have been removed but trailing spaces have not.  Because of the
    min() computation, either entry could be a proper substring of the
    other and the code would still think that they match.
    
    In the case originally reported, the device's vendor and product
    strings were "Inateck " and "                ".  These matched against
    the following entry in the global device list:
    
            {"", "Scanner", "1.80", BLIST_NOLUN}
    
    because "" is a substring of "Inateck " and "" (the result of removing
    leading spaces from the device's product string) is a substring of
    "Scanner".  The mistaken match prevented the system from scanning and
    finding the device's second Logical Unit.
    
    This patch fixes the problem by making two changes.  First, the code
    for leading-space removal is hoisted out of the loop.  (This means it
    will sometimes run unnecessarily, but since a large percentage of all
    lookups involve the "compatible" entries in global device list, this
    should be an overall improvement.)  Second and more importantly, the
    patch removes trailing spaces and adds a check to verify that the two
    resulting strings are exactly the same length.  This prevents matches
    where one entry is a proper substring of the other.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Giulio Bernardi &lt;ugilio@gmail.com&gt;
    Tested-by: Giulio Bernardi &lt;ugilio@gmail.com&gt;
    Signed-off-by: James Bottomley &lt;JBottomley@Odin.com&gt;

diff --git a/drivers/scsi/scsi_devinfo.c b/drivers/scsi/scsi_devinfo.c
index 2f49a224462d..2c1160c7ec92 100644
--- a/drivers/scsi/scsi_devinfo.c
+++ b/drivers/scsi/scsi_devinfo.c
@@ -407,51 +407,52 @@ static struct scsi_dev_info_list *scsi_dev_info_list_find(const char *vendor,
 	struct scsi_dev_info_list *devinfo;
 	struct scsi_dev_info_list_table *devinfo_table =
 		scsi_devinfo_lookup_by_key(key);
+	size_t vmax, mmax;
+	const char *vskip, *mskip;
 
 	if (IS_ERR(devinfo_table))
 		return (struct scsi_dev_info_list *) devinfo_table;
 
+	/* Prepare for "compatible" matches */
+
+	/*
+	 * XXX why skip leading spaces? If an odd INQUIRY
+	 * value, that should have been part of the
+	 * scsi_static_device_list[] entry, such as "  FOO"
+	 * rather than "FOO". Since this code is already
+	 * here, and we don't know what device it is
+	 * trying to work with, leave it as-is.
+	 */
+	vmax = 8;	/* max length of vendor */
+	vskip = vendor;
+	while (vmax &gt; 0 &amp;&amp; *vskip == ' ') {
+		vmax--;
+		vskip++;
+	}
+	/* Also skip trailing spaces */
+	while (vmax &gt; 0 &amp;&amp; vskip[vmax - 1] == ' ')
+		--vmax;
+
+	mmax = 16;	/* max length of model */
+	mskip = model;
+	while (mmax &gt; 0 &amp;&amp; *mskip == ' ') {
+		mmax--;
+		mskip++;
+	}
+	while (mmax &gt; 0 &amp;&amp; mskip[mmax - 1] == ' ')
+		--mmax;
+
 	list_for_each_entry(devinfo, &amp;devinfo_table-&gt;scsi_dev_info_list,
 			    dev_info_list) {
 		if (devinfo-&gt;compatible) {
 			/*
 			 * Behave like the older version of get_device_flags.
 			 */
-			size_t max;
-			/*
-			 * XXX why skip leading spaces? If an odd INQUIRY
-			 * value, that should have been part of the
-			 * scsi_static_device_list[] entry, such as "  FOO"
-			 * rather than "FOO". Since this code is already
-			 * here, and we don't know what device it is
-			 * trying to work with, leave it as-is.
-			 */
-			max = 8;	/* max length of vendor */
-			while ((max &gt; 0) &amp;&amp; *vendor == ' ') {
-				max--;
-				vendor++;
-			}
-			/*
-			 * XXX removing the following strlen() would be
-			 * good, using it means that for a an entry not in
-			 * the list, we scan every byte of every vendor
-			 * listed in scsi_static_device_list[], and never match
-			 * a single one (and still have to compare at
-			 * least the first byte of each vendor).
-			 */
-			if (memcmp(devinfo-&gt;vendor, vendor,
-				    min(max, strlen(devinfo-&gt;vendor))))
+			if (memcmp(devinfo-&gt;vendor, vskip, vmax) ||
+					devinfo-&gt;vendor[vmax])
 				continue;
-			/*
-			 * Skip spaces again.
-			 */
-			max = 16;	/* max length of model */
-			while ((max &gt; 0) &amp;&amp; *model == ' ') {
-				max--;
-				model++;
-			}
-			if (memcmp(devinfo-&gt;model, model,
-				   min(max, strlen(devinfo-&gt;model))))
+			if (memcmp(devinfo-&gt;model, mskip, mmax) ||
+					devinfo-&gt;model[mmax])
 				continue;
 			return devinfo;
 		} else {</pre><hr><pre>commit c42b3654f48bc06189a2d99629c9cf7bb79e8fe3
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Aug 3 11:57:21 2015 -0400

    SCSI: refactor device-matching code in scsi_devinfo.c
    
    In drivers/scsi/scsi_devinfo.c, the scsi_dev_info_list_del_keyed() and
    scsi_get_device_flags_keyed() routines contain a large amount of
    duplicate code for finding vendor/product matches in a
    scsi_dev_info_list.  This patch factors out the duplicate code and
    puts it in a separate function, scsi_dev_info_list_find().
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Suggested-by: Giulio Bernardi &lt;ugilio@gmail.com&gt;
    Signed-off-by: James Bottomley &lt;JBottomley@Odin.com&gt;

diff --git a/drivers/scsi/scsi_devinfo.c b/drivers/scsi/scsi_devinfo.c
index 9f77d23239a2..2f49a224462d 100644
--- a/drivers/scsi/scsi_devinfo.c
+++ b/drivers/scsi/scsi_devinfo.c
@@ -390,25 +390,26 @@ int scsi_dev_info_list_add_keyed(int compatible, char *vendor, char *model,
 EXPORT_SYMBOL(scsi_dev_info_list_add_keyed);
 
 /**
- * scsi_dev_info_list_del_keyed - remove one dev_info list entry.
+ * scsi_dev_info_list_find - find a matching dev_info list entry.
  * @vendor:	vendor string
  * @model:	model (product) string
  * @key:	specify list to use
  *
  * Description:
- * 	Remove and destroy one dev_info entry for @vendor, @model
+ *	Finds the first dev_info entry matching @vendor, @model
  * 	in list specified by @key.
  *
- * Returns: 0 OK, -error on failure.
+ * Returns: pointer to matching entry, or ERR_PTR on failure.
  **/
-int scsi_dev_info_list_del_keyed(char *vendor, char *model, int key)
+static struct scsi_dev_info_list *scsi_dev_info_list_find(const char *vendor,
+		const char *model, int key)
 {
-	struct scsi_dev_info_list *devinfo, *found = NULL;
+	struct scsi_dev_info_list *devinfo;
 	struct scsi_dev_info_list_table *devinfo_table =
 		scsi_devinfo_lookup_by_key(key);
 
 	if (IS_ERR(devinfo_table))
-		return PTR_ERR(devinfo_table);
+		return (struct scsi_dev_info_list *) devinfo_table;
 
 	list_for_each_entry(devinfo, &amp;devinfo_table-&gt;scsi_dev_info_list,
 			    dev_info_list) {
@@ -452,25 +453,42 @@ int scsi_dev_info_list_del_keyed(char *vendor, char *model, int key)
 			if (memcmp(devinfo-&gt;model, model,
 				   min(max, strlen(devinfo-&gt;model))))
 				continue;
-			found = devinfo;
+			return devinfo;
 		} else {
 			if (!memcmp(devinfo-&gt;vendor, vendor,
 				     sizeof(devinfo-&gt;vendor)) &amp;&amp;
 			     !memcmp(devinfo-&gt;model, model,
 				      sizeof(devinfo-&gt;model)))
-				found = devinfo;
+				return devinfo;
 		}
-		if (found)
-			break;
 	}
 
-	if (found) {
-		list_del(&amp;found-&gt;dev_info_list);
-		kfree(found);
-		return 0;
-	}
+	return ERR_PTR(-ENOENT);
+}
+
+/**
+ * scsi_dev_info_list_del_keyed - remove one dev_info list entry.
+ * @vendor:	vendor string
+ * @model:	model (product) string
+ * @key:	specify list to use
+ *
+ * Description:
+ *	Remove and destroy one dev_info entry for @vendor, @model
+ *	in list specified by @key.
+ *
+ * Returns: 0 OK, -error on failure.
+ **/
+int scsi_dev_info_list_del_keyed(char *vendor, char *model, int key)
+{
+	struct scsi_dev_info_list *found;
 
-	return -ENOENT;
+	found = scsi_dev_info_list_find(vendor, model, key);
+	if (IS_ERR(found))
+		return PTR_ERR(found);
+
+	list_del(&amp;found-&gt;dev_info_list);
+	kfree(found);
+	return 0;
 }
 EXPORT_SYMBOL(scsi_dev_info_list_del_keyed);
 
@@ -565,64 +583,16 @@ int scsi_get_device_flags_keyed(struct scsi_device *sdev,
 				int key)
 {
 	struct scsi_dev_info_list *devinfo;
-	struct scsi_dev_info_list_table *devinfo_table;
+	int err;
 
-	devinfo_table = scsi_devinfo_lookup_by_key(key);
+	devinfo = scsi_dev_info_list_find(vendor, model, key);
+	if (!IS_ERR(devinfo))
+		return devinfo-&gt;flags;
 
-	if (IS_ERR(devinfo_table))
-		return PTR_ERR(devinfo_table);
+	err = PTR_ERR(devinfo);
+	if (err != -ENOENT)
+		return err;
 
-	list_for_each_entry(devinfo, &amp;devinfo_table-&gt;scsi_dev_info_list,
-			    dev_info_list) {
-		if (devinfo-&gt;compatible) {
-			/*
-			 * Behave like the older version of get_device_flags.
-			 */
-			size_t max;
-			/*
-			 * XXX why skip leading spaces? If an odd INQUIRY
-			 * value, that should have been part of the
-			 * scsi_static_device_list[] entry, such as "  FOO"
-			 * rather than "FOO". Since this code is already
-			 * here, and we don't know what device it is
-			 * trying to work with, leave it as-is.
-			 */
-			max = 8;	/* max length of vendor */
-			while ((max &gt; 0) &amp;&amp; *vendor == ' ') {
-				max--;
-				vendor++;
-			}
-			/*
-			 * XXX removing the following strlen() would be
-			 * good, using it means that for a an entry not in
-			 * the list, we scan every byte of every vendor
-			 * listed in scsi_static_device_list[], and never match
-			 * a single one (and still have to compare at
-			 * least the first byte of each vendor).
-			 */
-			if (memcmp(devinfo-&gt;vendor, vendor,
-				    min(max, strlen(devinfo-&gt;vendor))))
-				continue;
-			/*
-			 * Skip spaces again.
-			 */
-			max = 16;	/* max length of model */
-			while ((max &gt; 0) &amp;&amp; *model == ' ') {
-				max--;
-				model++;
-			}
-			if (memcmp(devinfo-&gt;model, model,
-				   min(max, strlen(devinfo-&gt;model))))
-				continue;
-			return devinfo-&gt;flags;
-		} else {
-			if (!memcmp(devinfo-&gt;vendor, vendor,
-				     sizeof(devinfo-&gt;vendor)) &amp;&amp;
-			     !memcmp(devinfo-&gt;model, model,
-				      sizeof(devinfo-&gt;model)))
-				return devinfo-&gt;flags;
-		}
-	}
 	/* nothing found, return nothing */
 	if (key != SCSI_DEVINFO_GLOBAL)
 		return 0;</pre><hr><pre>commit b9a6e8e1001e28fecbd74c073f5503dac2790563
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 1 09:48:01 2015 +0800

    usb: misc: usbtest: format the data pattern according to max packet size
    
    With this change, the host and gadget doesn't need to agree with transfer
    length for comparing the data, since they doesn't know each other's
    transfer size, but know max packet size.
    
    Signed-off-by: Peter Chen &lt;peter.chen@freescale.com&gt;
    Acked-by: Michal Nazarewicz &lt;mina86@mina86.com&gt;
    (Fixed the 'line over 80 characters warning' by Peter Chen)
    Tested-by: Peter Chen &lt;peter.chen@freescale.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Felipe Balbi &lt;balbi@ti.com&gt;

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index cac93b77f9a7..ad6dd4a1de6c 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -304,11 +304,20 @@ static unsigned mod_pattern;
 module_param_named(pattern, mod_pattern, uint, S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(mod_pattern, "i/o pattern (0 == zeroes)");
 
-static inline void simple_fill_buf(struct urb *urb)
+static unsigned get_maxpacket(struct usb_device *udev, int pipe)
+{
+	struct usb_host_endpoint	*ep;
+
+	ep = usb_pipe_endpoint(udev, pipe);
+	return le16_to_cpup(&amp;ep-&gt;desc.wMaxPacketSize);
+}
+
+static void simple_fill_buf(struct urb *urb)
 {
 	unsigned	i;
 	u8		*buf = urb-&gt;transfer_buffer;
 	unsigned	len = urb-&gt;transfer_buffer_length;
+	unsigned	maxpacket;
 
 	switch (pattern) {
 	default:
@@ -317,8 +326,9 @@ static inline void simple_fill_buf(struct urb *urb)
 		memset(buf, 0, len);
 		break;
 	case 1:			/* mod63 */
+		maxpacket = get_maxpacket(urb-&gt;dev, urb-&gt;pipe);
 		for (i = 0; i &lt; len; i++)
-			*buf++ = (u8) (i % 63);
+			*buf++ = (u8) ((i % maxpacket) % 63);
 		break;
 	}
 }
@@ -350,6 +360,7 @@ static int simple_check_buf(struct usbtest_dev *tdev, struct urb *urb)
 	u8		expected;
 	u8		*buf = urb-&gt;transfer_buffer;
 	unsigned	len = urb-&gt;actual_length;
+	unsigned	maxpacket = get_maxpacket(urb-&gt;dev, urb-&gt;pipe);
 
 	int ret = check_guard_bytes(tdev, urb);
 	if (ret)
@@ -367,7 +378,7 @@ static int simple_check_buf(struct usbtest_dev *tdev, struct urb *urb)
 		 * with set_interface or set_config.
 		 */
 		case 1:			/* mod63 */
-			expected = i % 63;
+			expected = (i % maxpacket) % 63;
 			break;
 		/* always fail unsupported patterns */
 		default:
@@ -479,11 +490,13 @@ static void free_sglist(struct scatterlist *sg, int nents)
 }
 
 static struct scatterlist *
-alloc_sglist(int nents, int max, int vary)
+alloc_sglist(int nents, int max, int vary, struct usbtest_dev *dev, int pipe)
 {
 	struct scatterlist	*sg;
 	unsigned		i;
 	unsigned		size = max;
+	unsigned		maxpacket =
+		get_maxpacket(interface_to_usbdev(dev-&gt;intf), pipe);
 
 	if (max == 0)
 		return NULL;
@@ -512,7 +525,7 @@ alloc_sglist(int nents, int max, int vary)
 			break;
 		case 1:
 			for (j = 0; j &lt; size; j++)
-				*buf++ = (u8) (j % 63);
+				*buf++ = (u8) ((j % maxpacket) % 63);
 			break;
 		}
 
@@ -2176,7 +2189,8 @@ usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)
 			"TEST 5:  write %d sglists %d entries of %d bytes\n",
 				param-&gt;iterations,
 				param-&gt;sglen, param-&gt;length);
-		sg = alloc_sglist(param-&gt;sglen, param-&gt;length, 0);
+		sg = alloc_sglist(param-&gt;sglen, param-&gt;length,
+				0, dev, dev-&gt;out_pipe);
 		if (!sg) {
 			retval = -ENOMEM;
 			break;
@@ -2194,7 +2208,8 @@ usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)
 			"TEST 6:  read %d sglists %d entries of %d bytes\n",
 				param-&gt;iterations,
 				param-&gt;sglen, param-&gt;length);
-		sg = alloc_sglist(param-&gt;sglen, param-&gt;length, 0);
+		sg = alloc_sglist(param-&gt;sglen, param-&gt;length,
+				0, dev, dev-&gt;in_pipe);
 		if (!sg) {
 			retval = -ENOMEM;
 			break;
@@ -2211,7 +2226,8 @@ usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)
 			"TEST 7:  write/%d %d sglists %d entries 0..%d bytes\n",
 				param-&gt;vary, param-&gt;iterations,
 				param-&gt;sglen, param-&gt;length);
-		sg = alloc_sglist(param-&gt;sglen, param-&gt;length, param-&gt;vary);
+		sg = alloc_sglist(param-&gt;sglen, param-&gt;length,
+				param-&gt;vary, dev, dev-&gt;out_pipe);
 		if (!sg) {
 			retval = -ENOMEM;
 			break;
@@ -2228,7 +2244,8 @@ usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)
 			"TEST 8:  read/%d %d sglists %d entries 0..%d bytes\n",
 				param-&gt;vary, param-&gt;iterations,
 				param-&gt;sglen, param-&gt;length);
-		sg = alloc_sglist(param-&gt;sglen, param-&gt;length, param-&gt;vary);
+		sg = alloc_sglist(param-&gt;sglen, param-&gt;length,
+				param-&gt;vary, dev, dev-&gt;in_pipe);
 		if (!sg) {
 			retval = -ENOMEM;
 			break;</pre><hr><pre>commit 49718f0fb8c9af192b33d8af3a2826db04025371
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Aug 17 11:02:42 2015 -0400

    SCSI: Fix NULL pointer dereference in runtime PM
    
    The routines in scsi_rpm.c assume that if a runtime-PM callback is
    invoked for a SCSI device, it can only mean that the device's driver
    has asked the block layer to handle the runtime power management (by
    calling blk_pm_runtime_init(), which among other things sets q-&gt;dev).
    
    However, this assumption turns out to be wrong for things like the ses
    driver.  Normally ses devices are not allowed to do runtime PM, but
    userspace can override this setting.  If this happens, the kernel gets
    a NULL pointer dereference when blk_post_runtime_resume() tries to use
    the uninitialized q-&gt;dev pointer.
    
    This patch fixes the problem by calling the block layer's runtime-PM
    routines only if the device's driver really does have a runtime-PM
    callback routine.  Since ses doesn't define any such callbacks, the
    crash won't occur.
    
    This fixes Bugzilla #101371.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Stanisław Pitucha &lt;viraptor@gmail.com&gt;
    Reported-by: Ilan Cohen &lt;ilanco@gmail.com&gt;
    Tested-by: Ilan Cohen &lt;ilanco@gmail.com&gt;
    Reviewed-by: Johannes Thumshirn &lt;jthumshirn@suse.de&gt;
    Cc: stable@vger.kernel.org
    Signed-off-by: James Bottomley &lt;JBottomley@Odin.com&gt;

diff --git a/drivers/scsi/scsi_pm.c b/drivers/scsi/scsi_pm.c
index 9e43ae1d2163..e4b799837948 100644
--- a/drivers/scsi/scsi_pm.c
+++ b/drivers/scsi/scsi_pm.c
@@ -217,15 +217,15 @@ static int sdev_runtime_suspend(struct device *dev)
 {
 	const struct dev_pm_ops *pm = dev-&gt;driver ? dev-&gt;driver-&gt;pm : NULL;
 	struct scsi_device *sdev = to_scsi_device(dev);
-	int err;
+	int err = 0;
 
-	err = blk_pre_runtime_suspend(sdev-&gt;request_queue);
-	if (err)
-		return err;
-	if (pm &amp;&amp; pm-&gt;runtime_suspend)
+	if (pm &amp;&amp; pm-&gt;runtime_suspend) {
+		err = blk_pre_runtime_suspend(sdev-&gt;request_queue);
+		if (err)
+			return err;
 		err = pm-&gt;runtime_suspend(dev);
-	blk_post_runtime_suspend(sdev-&gt;request_queue, err);
-
+		blk_post_runtime_suspend(sdev-&gt;request_queue, err);
+	}
 	return err;
 }
 
@@ -248,11 +248,11 @@ static int sdev_runtime_resume(struct device *dev)
 	const struct dev_pm_ops *pm = dev-&gt;driver ? dev-&gt;driver-&gt;pm : NULL;
 	int err = 0;
 
-	blk_pre_runtime_resume(sdev-&gt;request_queue);
-	if (pm &amp;&amp; pm-&gt;runtime_resume)
+	if (pm &amp;&amp; pm-&gt;runtime_resume) {
+		blk_pre_runtime_resume(sdev-&gt;request_queue);
 		err = pm-&gt;runtime_resume(dev);
-	blk_post_runtime_resume(sdev-&gt;request_queue, err);
-
+		blk_post_runtime_resume(sdev-&gt;request_queue, err);
+	}
 	return err;
 }
 </pre><hr><pre>commit c93e64e91248becd0edb8f01723dff9da890e2ab
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jan 16 11:32:51 2015 -0500

    usb: udc: core: add device_del() call to error pathway
    
    This patch fixes a bug in the error pathway of
    usb_add_gadget_udc_release() in udc-core.c.  If the udc registration
    fails, the gadget registration is not fully undone; there's a
    put_device(&amp;gadget-&gt;dev) call but no device_del().
    
    CC: &lt;stable@vger.kernel.org&gt;
    Acked-by: Peter Chen &lt;peter.chen@freescale.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Felipe Balbi &lt;balbi@ti.com&gt;

diff --git a/drivers/usb/gadget/udc/udc-core.c b/drivers/usb/gadget/udc/udc-core.c
index 362ee8af5fce..89ed5e71a199 100644
--- a/drivers/usb/gadget/udc/udc-core.c
+++ b/drivers/usb/gadget/udc/udc-core.c
@@ -323,6 +323,7 @@ int usb_add_gadget_udc_release(struct device *parent, struct usb_gadget *gadget,
 
 err3:
 	put_device(&amp;udc-&gt;dev);
+	device_del(&amp;gadget-&gt;dev);
 
 err2:
 	put_device(&amp;gadget-&gt;dev);</pre><hr><pre>commit 1209544d8a2a6084f58625ca66f5cd77580df53f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 8 12:14:56 2015 -0400

    USB: OHCI: fix bad #define in ohci-tmio.c
    
    An incorrect definition of CCR_PM_USBPW3 in ohci-tmio.c is a perennial
    source of invalid diagnoses from static scanners, such as in
    &lt;http://marc.info/?l=linux-usb&amp;m=143634574527641&amp;w=2&gt;.  This patch
    fixes the definition.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: David Binderman &lt;dcb314@hotmail.com&gt;
    CC: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ohci-tmio.c b/drivers/usb/host/ohci-tmio.c
index e9a6eec39142..cfcfadfc94fc 100644
--- a/drivers/usb/host/ohci-tmio.c
+++ b/drivers/usb/host/ohci-tmio.c
@@ -58,7 +58,7 @@
 #define CCR_PM_CKRNEN    0x0002
 #define CCR_PM_USBPW1    0x0004
 #define CCR_PM_USBPW2    0x0008
-#define CCR_PM_USBPW3    0x0008
+#define CCR_PM_USBPW3    0x0010
 #define CCR_PM_PMEE      0x0100
 #define CCR_PM_PMES      0x8000
 </pre>
    <div class="pagination">
        <a href='2_24.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><span>[25]</span><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_26.html'>Next&gt;&gt;</a>
    <div>
</body>
