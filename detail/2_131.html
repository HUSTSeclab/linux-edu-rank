<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_130.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><span>[131]</span><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_132.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 12c3da346eb81b6a281031f62eda3bca993dff5a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Nov 23 12:09:52 2005 -0500

    [PATCH] USB: Store port number in usb_device
    
    This patch (as610) adds a field to struct usb_device to store the device's
    port number.  This allows us to remove several loops in the hub driver
    (searching for a particular device among all the entries in the parent's
    array of children).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index b311005ff1a6..a523c8f20b5d 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -946,24 +946,21 @@ static int locktree(struct usb_device *udev)
 	t = locktree(hdev);
 	if (t &lt; 0)
 		return t;
-	for (t = 0; t &lt; hdev-&gt;maxchild; t++) {
-		if (hdev-&gt;children[t] == udev) {
-			/* everything is fail-fast once disconnect
-			 * processing starts
-			 */
-			if (udev-&gt;state == USB_STATE_NOTATTACHED)
-				break;
 
-			/* when everyone grabs locks top-&gt;bottom,
-			 * non-overlapping work may be concurrent
-			 */
-			usb_lock_device(udev);
-			usb_unlock_device(hdev);
-			return t + 1;
-		}
+	/* everything is fail-fast once disconnect
+	 * processing starts
+	 */
+	if (udev-&gt;state == USB_STATE_NOTATTACHED) {
+		usb_unlock_device(hdev);
+		return -ENODEV;
 	}
+
+	/* when everyone grabs locks top-&gt;bottom,
+	 * non-overlapping work may be concurrent
+	 */
+	usb_lock_device(udev);
 	usb_unlock_device(hdev);
-	return -ENODEV;
+	return udev-&gt;portnum;
 }
 
 static void recursively_mark_NOTATTACHED(struct usb_device *udev)
@@ -1335,15 +1332,9 @@ int usb_new_device(struct usb_device *udev)
 					le16_to_cpu(udev-&gt;config[0].desc.wTotalLength),
 					USB_DT_OTG, (void **) &amp;desc) == 0) {
 			if (desc-&gt;bmAttributes &amp; USB_OTG_HNP) {
-				unsigned		port1;
+				unsigned		port1 = udev-&gt;portnum;
 				struct usb_device	*root = udev-&gt;parent;
 				
-				for (port1 = 1; port1 &lt;= root-&gt;maxchild;
-						port1++) {
-					if (root-&gt;children[port1-1] == udev)
-						break;
-				}
-
 				dev_info(&amp;udev-&gt;dev,
 					"Dual-Role OTG device on %sHNP port\n",
 					(port1 == bus-&gt;otg_port)
@@ -1720,22 +1711,9 @@ static int __usb_suspend_device (struct usb_device *udev, int port1)
 int usb_suspend_device(struct usb_device *udev)
 {
 #ifdef	CONFIG_USB_SUSPEND
-	int	port1;
-
 	if (udev-&gt;state == USB_STATE_NOTATTACHED)
 		return -ENODEV;
-	if (!udev-&gt;parent)
-		port1 = 0;
-	else {
-		for (port1 = udev-&gt;parent-&gt;maxchild; port1 &gt; 0; --port1) {
-			if (udev-&gt;parent-&gt;children[port1-1] == udev)
-				break;
-		}
-		if (port1 == 0)
-			return -ENODEV;
-	}
-
-	return __usb_suspend_device(udev, port1);
+	return __usb_suspend_device(udev, udev-&gt;portnum);
 #else
 	/* NOTE:  udev-&gt;state unchanged, it's not lying ... */
 	udev-&gt;dev.power.power_state = PMSG_SUSPEND;
@@ -1893,20 +1871,10 @@ hub_port_resume(struct usb_hub *hub, int port1, struct usb_device *udev)
  */
 int usb_resume_device(struct usb_device *udev)
 {
-	int	port1, status;
+	int	status;
 
 	if (udev-&gt;state == USB_STATE_NOTATTACHED)
 		return -ENODEV;
-	if (!udev-&gt;parent)
-		port1 = 0;
-	else {
-		for (port1 = udev-&gt;parent-&gt;maxchild; port1 &gt; 0; --port1) {
-			if (udev-&gt;parent-&gt;children[port1-1] == udev)
-				break;
-		}
-		if (port1 == 0)
-			return -ENODEV;
-	}
 
 #ifdef	CONFIG_USB_SUSPEND
 	/* selective resume of one downstream hub-to-device port */
@@ -1915,7 +1883,7 @@ int usb_resume_device(struct usb_device *udev)
 			// NOTE swsusp may bork us, device state being wrong...
 			// NOTE this fails if parent is also suspended...
 			status = hub_port_resume(hdev_to_hub(udev-&gt;parent),
-					port1, udev);
+					udev-&gt;portnum, udev);
 		} else
 			status = 0;
 	} else
@@ -3029,7 +2997,8 @@ int usb_reset_device(struct usb_device *udev)
 	struct usb_hub			*parent_hub;
 	struct usb_device_descriptor	descriptor = udev-&gt;descriptor;
 	struct usb_hub			*hub = NULL;
-	int 				i, ret = 0, port1 = -1;
+	int 				i, ret = 0;
+	int				port1 = udev-&gt;portnum;
 
 	if (udev-&gt;state == USB_STATE_NOTATTACHED ||
 			udev-&gt;state == USB_STATE_SUSPENDED) {
@@ -3043,18 +3012,6 @@ int usb_reset_device(struct usb_device *udev)
 		dev_dbg(&amp;udev-&gt;dev, "%s for root hub!\n", __FUNCTION__);
 		return -EISDIR;
 	}
-
-	for (i = 0; i &lt; parent_hdev-&gt;maxchild; i++)
-		if (parent_hdev-&gt;children[i] == udev) {
-			port1 = i + 1;
-			break;
-		}
-
-	if (port1 &lt; 0) {
-		/* If this ever happens, it's very bad */
-		dev_err(&amp;udev-&gt;dev, "Can't locate device's port!\n");
-		return -ENOENT;
-	}
 	parent_hub = hdev_to_hub(parent_hdev);
 
 	/* If we're resetting an active hub, take some special actions */
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index fcfda21be499..39e6b61b898a 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -439,6 +439,7 @@ usb_alloc_dev(struct usb_device *parent, struct usb_bus *bus, unsigned port1)
 		/* hub driver sets up TT records */
 	}
 
+	dev-&gt;portnum = port1;
 	dev-&gt;bus = bus;
 	dev-&gt;parent = parent;
 	INIT_LIST_HEAD(&amp;dev-&gt;filelist);
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 27575e678a7c..e59d1bd52d4f 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -348,6 +348,7 @@ struct usb_device {
 	char **rawdescriptors;		/* Raw descriptors for each config */
 
 	unsigned short bus_mA;		/* Current available from the bus */
+	u8 portnum;			/* Parent port number (origin 1) */
 
 	int have_langid;		/* whether string_langid is valid */
 	int string_langid;		/* language ID for strings */</pre><hr><pre>commit 55c527187c9d78f840b284d596a0b298bc1493af
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Nov 23 12:03:12 2005 -0500

    [PATCH] USB: Consider power budget when choosing configuration
    
    This patch (as609) changes the way we keep track of power budgeting for
    USB hubs and devices, and it updates the choose_configuration routine to
    take this information into account.  (This is something we should have
    been doing all along.)  A new field in struct usb_device holds the amount
    of bus current available from the upstream port, and the usb_hub structure
    keeps track of the current available for each downstream port.
    
    Two new rules for configuration selection are added:
    
            Don't select a self-powered configuration when only bus power
            is available.
    
            Don't select a configuration requiring more bus power than is
            available.
    
    However the first rule is #if-ed out, because I found that the internal
    hub in my HP USB keyboard claims that its only configuration is
    self-powered.  The rule would prevent the configuration from being chosen,
    leaving the hub &amp; keyboard unconfigured.  Since similar descriptor errors
    may turn out to be fairly common, it seemed wise not to include a rule
    that would break automatic configuration unnecessarily for such devices.
    
    The second rule may also trigger unnecessarily, although this should be
    less common.  More likely it will annoy people by sometimes failing to
    accept configurations that should never have been chosen in the first
    place.
    
    The patch also changes usbcore's reaction when no configuration is
    suitable.  Instead of raising an error and rejecting the device, now
    the core will simply leave the device unconfigured.  People can always
    work around such problems by installing configurations manually through
    sysfs.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index d16a0e8a7d72..0018bbc4de34 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1825,8 +1825,6 @@ int usb_add_hcd(struct usb_hcd *hcd,
 		retval = -ENOMEM;
 		goto err_allocate_root_hub;
 	}
-	rhdev-&gt;speed = (hcd-&gt;driver-&gt;flags &amp; HCD_USB2) ? USB_SPEED_HIGH :
-			USB_SPEED_FULL;
 
 	/* Although in principle hcd-&gt;driver-&gt;start() might need to use rhdev,
 	 * none of the current drivers do.
@@ -1844,6 +1842,9 @@ int usb_add_hcd(struct usb_hcd *hcd,
 		dev_dbg(hcd-&gt;self.controller, "supports USB remote wakeup\n");
 	hcd-&gt;remote_wakeup = hcd-&gt;can_wakeup;
 
+	rhdev-&gt;speed = (hcd-&gt;driver-&gt;flags &amp; HCD_USB2) ? USB_SPEED_HIGH :
+			USB_SPEED_FULL;
+	rhdev-&gt;bus_mA = min(500u, hcd-&gt;power_budget);
 	if ((retval = register_root_hub(rhdev, hcd)) != 0)
 		goto err_register_root_hub;
 
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 895ac829b9cf..b311005ff1a6 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -702,26 +702,40 @@ static int hub_configure(struct usb_hub *hub,
 	 * and battery-powered root hubs (may provide just 8 mA).
 	 */
 	ret = usb_get_status(hdev, USB_RECIP_DEVICE, 0, &amp;hubstatus);
-	if (ret &lt; 0) {
+	if (ret &lt; 2) {
 		message = "can't get hub status";
 		goto fail;
 	}
 	le16_to_cpus(&amp;hubstatus);
 	if (hdev == hdev-&gt;bus-&gt;root_hub) {
-		struct usb_hcd *hcd =
-				container_of(hdev-&gt;bus, struct usb_hcd, self);
-
-		hub-&gt;power_budget = min(500u, hcd-&gt;power_budget) / 2;
+		if (hdev-&gt;bus_mA == 0 || hdev-&gt;bus_mA &gt;= 500)
+			hub-&gt;mA_per_port = 500;
+		else {
+			hub-&gt;mA_per_port = hdev-&gt;bus_mA;
+			hub-&gt;limited_power = 1;
+		}
 	} else if ((hubstatus &amp; (1 &lt;&lt; USB_DEVICE_SELF_POWERED)) == 0) {
 		dev_dbg(hub_dev, "hub controller current requirement: %dmA\n",
 			hub-&gt;descriptor-&gt;bHubContrCurrent);
-		hub-&gt;power_budget = (501 - hub-&gt;descriptor-&gt;bHubContrCurrent)
-					/ 2;
+		hub-&gt;limited_power = 1;
+		if (hdev-&gt;maxchild &gt; 0) {
+			int remaining = hdev-&gt;bus_mA -
+					hub-&gt;descriptor-&gt;bHubContrCurrent;
+
+			if (remaining &lt; hdev-&gt;maxchild * 100)
+				dev_warn(hub_dev,
+					"insufficient power available "
+					"to use all downstream ports\n");
+			hub-&gt;mA_per_port = 100;		/* 7.2.1.1 */
+		}
+	} else {	/* Self-powered external hub */
+		/* FIXME: What about battery-powered external hubs that
+		 * provide less current per port? */
+		hub-&gt;mA_per_port = 500;
 	}
-	if (hub-&gt;power_budget)
-		dev_dbg(hub_dev, "%dmA bus power budget for children\n",
-			hub-&gt;power_budget * 2);
-
+	if (hub-&gt;mA_per_port &lt; 500)
+		dev_dbg(hub_dev, "%umA bus power budget for each child\n",
+				hub-&gt;mA_per_port);
 
 	ret = hub_hub_status(hub, &amp;hubstatus, &amp;hubchange);
 	if (ret &lt; 0) {
@@ -1136,45 +1150,107 @@ void usb_disconnect(struct usb_device **pdev)
 	device_unregister(&amp;udev-&gt;dev);
 }
 
+static inline const char *plural(int n)
+{
+	return (n == 1 ? "" : "s");
+}
+
 static int choose_configuration(struct usb_device *udev)
 {
-	int c, i;
+	int i;
+	u16 devstatus;
+	int bus_powered;
+	int num_configs;
+	struct usb_host_config *c, *best;
+
+	/* If this fails, assume the device is bus-powered */
+	devstatus = 0;
+	usb_get_status(udev, USB_RECIP_DEVICE, 0, &amp;devstatus);
+	le16_to_cpus(&amp;devstatus);
+	bus_powered = ((devstatus &amp; (1 &lt;&lt; USB_DEVICE_SELF_POWERED)) == 0);
+	dev_dbg(&amp;udev-&gt;dev, "device is %s-powered\n",
+			bus_powered ? "bus" : "self");
+
+	best = NULL;
+	c = udev-&gt;config;
+	num_configs = udev-&gt;descriptor.bNumConfigurations;
+	for (i = 0; i &lt; num_configs; (i++, c++)) {
+		struct usb_interface_descriptor	*desc =
+				&amp;c-&gt;intf_cache[0]-&gt;altsetting-&gt;desc;
+
+		/*
+		 * HP's USB bus-powered keyboard has only one configuration
+		 * and it claims to be self-powered; other devices may have
+		 * similar errors in their descriptors.  If the next test
+		 * were allowed to execute, such configurations would always
+		 * be rejected and the devices would not work as expected.
+		 */
+#if 0
+		/* Rule out self-powered configs for a bus-powered device */
+		if (bus_powered &amp;&amp; (c-&gt;desc.bmAttributes &amp;
+					USB_CONFIG_ATT_SELFPOWER))
+			continue;
+#endif
 
-	/* NOTE: this should interact with hub power budgeting */
+		/*
+		 * The next test may not be as effective as it should be.
+		 * Some hubs have errors in their descriptor, claiming
+		 * to be self-powered when they are really bus-powered.
+		 * We will overestimate the amount of current such hubs
+		 * make available for each port.
+		 *
+		 * This is a fairly benign sort of failure.  It won't
+		 * cause us to reject configurations that we should have
+		 * accepted.
+		 */
 
-	c = udev-&gt;config[0].desc.bConfigurationValue;
-	if (udev-&gt;descriptor.bNumConfigurations != 1) {
-		for (i = 0; i &lt; udev-&gt;descriptor.bNumConfigurations; i++) {
-			struct usb_interface_descriptor	*desc;
+		/* Rule out configs that draw too much bus current */
+		if (c-&gt;desc.bMaxPower * 2 &gt; udev-&gt;bus_mA)
+			continue;
 
-			/* heuristic:  Linux is more likely to have class
-			 * drivers, so avoid vendor-specific interfaces.
-			 */
-			desc = &amp;udev-&gt;config[i].intf_cache[0]
-					-&gt;altsetting-&gt;desc;
-			if (desc-&gt;bInterfaceClass == USB_CLASS_VENDOR_SPEC)
-				continue;
-			/* COMM/2/all is CDC ACM, except 0xff is MSFT RNDIS.
-			 * MSFT needs this to be the first config; never use
-			 * it as the default unless Linux has host-side RNDIS.
-			 * A second config would ideally be CDC-Ethernet, but
-			 * may instead be the "vendor specific" CDC subset
-			 * long used by ARM Linux for sa1100 or pxa255.
-			 */
-			if (desc-&gt;bInterfaceClass == USB_CLASS_COMM
-					&amp;&amp; desc-&gt;bInterfaceSubClass == 2
-					&amp;&amp; desc-&gt;bInterfaceProtocol == 0xff) {
-				c = udev-&gt;config[1].desc.bConfigurationValue;
-				continue;
-			}
-			c = udev-&gt;config[i].desc.bConfigurationValue;
+		/* If the first config's first interface is COMM/2/0xff
+		 * (MSFT RNDIS), rule it out unless Linux has host-side
+		 * RNDIS support. */
+		if (i == 0 &amp;&amp; desc-&gt;bInterfaceClass == USB_CLASS_COMM
+				&amp;&amp; desc-&gt;bInterfaceSubClass == 2
+				&amp;&amp; desc-&gt;bInterfaceProtocol == 0xff) {
+#ifndef CONFIG_USB_NET_RNDIS
+			continue;
+#else
+			best = c;
+#endif
+		}
+
+		/* From the remaining configs, choose the first one whose
+		 * first interface is for a non-vendor-specific class.
+		 * Reason: Linux is more likely to have a class driver
+		 * than a vendor-specific driver. */
+		else if (udev-&gt;descriptor.bDeviceClass !=
+						USB_CLASS_VENDOR_SPEC &amp;&amp;
+				desc-&gt;bInterfaceClass !=
+						USB_CLASS_VENDOR_SPEC) {
+			best = c;
 			break;
 		}
+
+		/* If all the remaining configs are vendor-specific,
+		 * choose the first one. */
+		else if (!best)
+			best = c;
+	}
+
+	if (best) {
+		i = best-&gt;desc.bConfigurationValue;
 		dev_info(&amp;udev-&gt;dev,
-			"configuration #%d chosen from %d choices\n",
-			c, udev-&gt;descriptor.bNumConfigurations);
+			"configuration #%d chosen from %d choice%s\n",
+			i, num_configs, plural(num_configs));
+	} else {
+		i = -1;
+		dev_warn(&amp;udev-&gt;dev,
+			"no configuration chosen from %d choice%s\n",
+			num_configs, plural(num_configs));
 	}
-	return c;
+	return i;
 }
 
 #ifdef DEBUG
@@ -1327,17 +1403,13 @@ int usb_new_device(struct usb_device *udev)
 	 * with the driver core, and lets usb device drivers bind to them.
 	 */
 	c = choose_configuration(udev);
-	if (c &lt; 0)
-		dev_warn(&amp;udev-&gt;dev,
-				"can't choose an initial configuration\n");
-	else {
+	if (c &gt;= 0) {
 		err = usb_set_configuration(udev, c);
 		if (err) {
 			dev_err(&amp;udev-&gt;dev, "can't set config #%d, error %d\n",
 					c, err);
-			usb_remove_sysfs_dev_files(udev);
-			device_del(&amp;udev-&gt;dev);
-			goto fail;
+			/* This need not be fatal.  The user can try to
+			 * set other configurations. */
 		}
 	}
 
@@ -1702,7 +1774,7 @@ static int finish_device_resume(struct usb_device *udev)
 	 * and device drivers will know about any resume quirks.
 	 */
 	status = usb_get_status(udev, USB_RECIP_DEVICE, 0, &amp;devstatus);
-	if (status &lt; 0)
+	if (status &lt; 2)
 		dev_dbg(&amp;udev-&gt;dev,
 			"gone after usb resume? status %d\n",
 			status);
@@ -1711,7 +1783,7 @@ static int finish_device_resume(struct usb_device *udev)
 		int		(*resume)(struct device *);
 
 		le16_to_cpus(&amp;devstatus);
-		if (devstatus &amp; (1 &lt;&lt; USB_DEVICE_REMOTE_WAKEUP)
+		if ((devstatus &amp; (1 &lt;&lt; USB_DEVICE_REMOTE_WAKEUP))
 				&amp;&amp; udev-&gt;parent) {
 			status = usb_control_msg(udev,
 					usb_sndctrlpipe(udev, 0),
@@ -2374,39 +2446,36 @@ hub_power_remaining (struct usb_hub *hub)
 {
 	struct usb_device *hdev = hub-&gt;hdev;
 	int remaining;
-	unsigned i;
+	int port1;
 
-	remaining = hub-&gt;power_budget;
-	if (!remaining)		/* self-powered */
+	if (!hub-&gt;limited_power)
 		return 0;
 
-	for (i = 0; i &lt; hdev-&gt;maxchild; i++) {
-		struct usb_device	*udev = hdev-&gt;children[i];
-		int			delta, ceiling;
+	remaining = hdev-&gt;bus_mA - hub-&gt;descriptor-&gt;bHubContrCurrent;
+	for (port1 = 1; port1 &lt;= hdev-&gt;maxchild; ++port1) {
+		struct usb_device	*udev = hdev-&gt;children[port1 - 1];
+		int			delta;
 
 		if (!udev)
 			continue;
 
-		/* 100mA per-port ceiling, or 8mA for OTG ports */
-		if (i != (udev-&gt;bus-&gt;otg_port - 1) || hdev-&gt;parent)
-			ceiling = 50;
-		else
-			ceiling = 4;
-
+		/* Unconfigured devices may not use more than 100mA,
+		 * or 8mA for OTG ports */
 		if (udev-&gt;actconfig)
-			delta = udev-&gt;actconfig-&gt;desc.bMaxPower;
+			delta = udev-&gt;actconfig-&gt;desc.bMaxPower * 2;
+		else if (port1 != udev-&gt;bus-&gt;otg_port || hdev-&gt;parent)
+			delta = 100;
 		else
-			delta = ceiling;
-		// dev_dbg(&amp;udev-&gt;dev, "budgeted %dmA\n", 2 * delta);
-		if (delta &gt; ceiling)
-			dev_warn(&amp;udev-&gt;dev, "%dmA over %dmA budget!\n",
-				2 * (delta - ceiling), 2 * ceiling);
+			delta = 8;
+		if (delta &gt; hub-&gt;mA_per_port)
+			dev_warn(&amp;udev-&gt;dev, "%dmA is over %umA budget "
+					"for port %d!\n",
+					delta, hub-&gt;mA_per_port, port1);
 		remaining -= delta;
 	}
 	if (remaining &lt; 0) {
-		dev_warn(hub-&gt;intfdev,
-			"%dmA over power budget!\n",
-			-2 * remaining);
+		dev_warn(hub-&gt;intfdev, "%dmA over power budget!\n",
+			- remaining);
 		remaining = 0;
 	}
 	return remaining;
@@ -2501,7 +2570,8 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 
 		usb_set_device_state(udev, USB_STATE_POWERED);
 		udev-&gt;speed = USB_SPEED_UNKNOWN;
- 
+ 		udev-&gt;bus_mA = hub-&gt;mA_per_port;
+
 		/* set the address */
 		choose_address(udev);
 		if (udev-&gt;devnum &lt;= 0) {
@@ -2521,16 +2591,16 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 		 * on the parent.
 		 */
 		if (udev-&gt;descriptor.bDeviceClass == USB_CLASS_HUB
-				&amp;&amp; hub-&gt;power_budget) {
+				&amp;&amp; udev-&gt;bus_mA &lt;= 100) {
 			u16	devstat;
 
 			status = usb_get_status(udev, USB_RECIP_DEVICE, 0,
 					&amp;devstat);
-			if (status &lt; 0) {
+			if (status &lt; 2) {
 				dev_dbg(&amp;udev-&gt;dev, "get status %d ?\n", status);
 				goto loop_disable;
 			}
-			cpu_to_le16s(&amp;devstat);
+			le16_to_cpus(&amp;devstat);
 			if ((devstat &amp; (1 &lt;&lt; USB_DEVICE_SELF_POWERED)) == 0) {
 				dev_err(&amp;udev-&gt;dev,
 					"can't connect bus-powered hub "
@@ -2583,9 +2653,7 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 
 		status = hub_power_remaining(hub);
 		if (status)
-			dev_dbg(hub_dev,
-				"%dmA power budget left\n",
-				2 * status);
+			dev_dbg(hub_dev, "%dmA power budget left\n", status);
 
 		return;
 
@@ -2797,6 +2865,11 @@ static void hub_events(void)
 			if (hubchange &amp; HUB_CHANGE_LOCAL_POWER) {
 				dev_dbg (hub_dev, "power change\n");
 				clear_hub_feature(hdev, C_HUB_LOCAL_POWER);
+				if (hubstatus &amp; HUB_STATUS_LOCAL_POWER)
+					/* FIXME: Is this always true? */
+					hub-&gt;limited_power = 0;
+				else
+					hub-&gt;limited_power = 1;
 			}
 			if (hubchange &amp; HUB_CHANGE_OVERCURRENT) {
 				dev_dbg (hub_dev, "overcurrent change\n");
diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index bf23f8978024..29d5f45a8456 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -220,8 +220,9 @@ struct usb_hub {
 	struct usb_hub_descriptor *descriptor;	/* class descriptor */
 	struct usb_tt		tt;		/* Transaction Translator */
 
-	u8			power_budget;	/* in 2mA units; or zero */
+	unsigned		mA_per_port;	/* current for each child */
 
+	unsigned		limited_power:1;
 	unsigned		quiescing:1;
 	unsigned		activating:1;
 	unsigned		resume_root_hub:1;
diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index fe74f99ca5f4..99ab774d4fdb 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1387,6 +1387,12 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 	if (dev-&gt;state != USB_STATE_ADDRESS)
 		usb_disable_device (dev, 1);	// Skip ep0
 
+	n = dev-&gt;bus_mA - cp-&gt;desc.bMaxPower * 2;
+	if (n &lt; 0)
+		dev_warn(&amp;dev-&gt;dev, "new config #%d exceeds power "
+				"limit by %dmA\n",
+				configuration, -n);
+
 	if ((ret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
 			USB_REQ_SET_CONFIGURATION, 0, configuration, 0,
 			NULL, 0, USB_CTRL_SET_TIMEOUT)) &lt; 0)
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 46dc0421d19e..27575e678a7c 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -347,6 +347,8 @@ struct usb_device {
 
 	char **rawdescriptors;		/* Raw descriptors for each config */
 
+	unsigned short bus_mA;		/* Current available from the bus */
+
 	int have_langid;		/* whether string_langid is valid */
 	int string_langid;		/* language ID for strings */
 </pre><hr><pre>commit 4bf0ba861442d289eebfad8ea9ce365ab04fd582
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Nov 21 11:58:07 2005 -0500

    [PATCH] USB: Fix locking for USB suspend/resume
    
    The earlier USB locking updates didn't touch the suspend/resume
    routines.  They need updating as well, since now the caller holds the
    device semaphore.  This patch (as608) makes the necessary changes.  It
    also adds a line to store the correct power state when a device is
    resumed, something which was unaccountably missing.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 02601f412f9d..895ac829b9cf 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1648,15 +1648,22 @@ static int __usb_suspend_device (struct usb_device *udev, int port1)
 int usb_suspend_device(struct usb_device *udev)
 {
 #ifdef	CONFIG_USB_SUSPEND
-	int	port1, status;
+	int	port1;
 
-	port1 = locktree(udev);
-	if (port1 &lt; 0)
-		return port1;
+	if (udev-&gt;state == USB_STATE_NOTATTACHED)
+		return -ENODEV;
+	if (!udev-&gt;parent)
+		port1 = 0;
+	else {
+		for (port1 = udev-&gt;parent-&gt;maxchild; port1 &gt; 0; --port1) {
+			if (udev-&gt;parent-&gt;children[port1-1] == udev)
+				break;
+		}
+		if (port1 == 0)
+			return -ENODEV;
+	}
 
-	status = __usb_suspend_device(udev, port1);
-	usb_unlock_device(udev);
-	return status;
+	return __usb_suspend_device(udev, port1);
 #else
 	/* NOTE:  udev-&gt;state unchanged, it's not lying ... */
 	udev-&gt;dev.power.power_state = PMSG_SUSPEND;
@@ -1688,6 +1695,7 @@ static int finish_device_resume(struct usb_device *udev)
 	usb_set_device_state(udev, udev-&gt;actconfig
 			? USB_STATE_CONFIGURED
 			: USB_STATE_ADDRESS);
+	udev-&gt;dev.power.power_state = PMSG_ON;
 
  	/* 10.5.4.5 says be sure devices in the tree are still there.
  	 * For now let's assume the device didn't go crazy on resume,
@@ -1723,8 +1731,14 @@ static int finish_device_resume(struct usb_device *udev)
 		 * may have a child resume event to deal with soon
 		 */
 		resume = udev-&gt;dev.bus-&gt;resume;
-		for (i = 0; i &lt; udev-&gt;actconfig-&gt;desc.bNumInterfaces; i++)
-			(void) resume(&amp;udev-&gt;actconfig-&gt;interface[i]-&gt;dev);
+		for (i = 0; i &lt; udev-&gt;actconfig-&gt;desc.bNumInterfaces; i++) {
+			struct device *dev =
+					&amp;udev-&gt;actconfig-&gt;interface[i]-&gt;dev;
+
+			down(&amp;dev-&gt;sem);
+			(void) resume(dev);
+			up(&amp;dev-&gt;sem);
+		}
 		status = 0;
 
 	} else if (udev-&gt;devnum &lt;= 0) {
@@ -1809,9 +1823,18 @@ int usb_resume_device(struct usb_device *udev)
 {
 	int	port1, status;
 
-	port1 = locktree(udev);
-	if (port1 &lt; 0)
-		return port1;
+	if (udev-&gt;state == USB_STATE_NOTATTACHED)
+		return -ENODEV;
+	if (!udev-&gt;parent)
+		port1 = 0;
+	else {
+		for (port1 = udev-&gt;parent-&gt;maxchild; port1 &gt; 0; --port1) {
+			if (udev-&gt;parent-&gt;children[port1-1] == udev)
+				break;
+		}
+		if (port1 == 0)
+			return -ENODEV;
+	}
 
 #ifdef	CONFIG_USB_SUSPEND
 	/* selective resume of one downstream hub-to-device port */
@@ -1830,11 +1853,12 @@ int usb_resume_device(struct usb_device *udev)
 		dev_dbg(&amp;udev-&gt;dev, "can't resume, status %d\n",
 			status);
 
-	usb_unlock_device(udev);
-
 	/* rebind drivers that had no suspend() */
-	if (status == 0)
+	if (status == 0) {
+		usb_unlock_device(udev);
 		bus_rescan_devices(&amp;usb_bus_type);
+		usb_lock_device(udev);
+	}
 	return status;
 }
 </pre><hr><pre>commit 7d069b7d80933004282c48edbe62526e4cb0aecc
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Nov 18 12:06:34 2005 -0500

    [PATCH] USB: Disconnect children during hub unbind
    
    This patch (as606b) is an updated version of my earlier patch to
    disconnect children from a hub device when the hub driver is unbound.
    Thanks to the changes in the driver core locking, we now know that the
    entire hub device (and not just the interface) is locked whenever the
    hub driver's disconnect method runs.  Hence it is safe to disconnect the
    child device structures immediately instead of deferring the job.
    
    The earlier version of the patch neglected to disable the hub's ports.
    We don't want to forget that; otherwise we'd end up with live devices
    using addresses that have been recycled.  This update adds the necessary
    code.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index dd3bcfb2bcb6..02601f412f9d 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -515,6 +515,31 @@ static int hub_port_disable(struct usb_hub *hub, int port1, int set_state)
 	return ret;
 }
 
+
+/* caller has locked the hub device */
+static void hub_pre_reset(struct usb_hub *hub, int disable_ports)
+{
+	struct usb_device *hdev = hub-&gt;hdev;
+	int port1;
+
+	for (port1 = 1; port1 &lt;= hdev-&gt;maxchild; ++port1) {
+		if (hdev-&gt;children[port1 - 1]) {
+			usb_disconnect(&amp;hdev-&gt;children[port1 - 1]);
+			if (disable_ports)
+				hub_port_disable(hub, port1, 0);
+		}
+	}
+	hub_quiesce(hub);
+}
+
+/* caller has locked the hub device */
+static void hub_post_reset(struct usb_hub *hub)
+{
+	hub_activate(hub);
+	hub_power_on(hub);
+}
+
+
 static int hub_configure(struct usb_hub *hub,
 	struct usb_endpoint_descriptor *endpoint)
 {
@@ -750,29 +775,10 @@ static int hub_configure(struct usb_hub *hub,
 
 static unsigned highspeed_hubs;
 
-/* Called after the hub driver is unbound from a hub with children */
-static void hub_remove_children_work(void *__hub)
-{
-	struct usb_hub		*hub = __hub;
-	struct usb_device	*hdev = hub-&gt;hdev;
-	int			i;
-
-	kfree(hub);
-
-	usb_lock_device(hdev);
-	for (i = 0; i &lt; hdev-&gt;maxchild; ++i) {
-		if (hdev-&gt;children[i])
-			usb_disconnect(&amp;hdev-&gt;children[i]);
-	}
-	usb_unlock_device(hdev);
-	usb_put_dev(hdev);
-}
-
 static void hub_disconnect(struct usb_interface *intf)
 {
 	struct usb_hub *hub = usb_get_intfdata (intf);
 	struct usb_device *hdev;
-	int n, port1;
 
 	usb_set_intfdata (intf, NULL);
 	hdev = hub-&gt;hdev;
@@ -780,7 +786,9 @@ static void hub_disconnect(struct usb_interface *intf)
 	if (hdev-&gt;speed == USB_SPEED_HIGH)
 		highspeed_hubs--;
 
-	hub_quiesce(hub);
+	/* Disconnect all children and quiesce the hub */
+	hub_pre_reset(hub, 1);
+
 	usb_free_urb(hub-&gt;urb);
 	hub-&gt;urb = NULL;
 
@@ -800,27 +808,7 @@ static void hub_disconnect(struct usb_interface *intf)
 		hub-&gt;buffer = NULL;
 	}
 
-	/* If there are any children then this is an unbind only, not a
-	 * physical disconnection.  The active ports must be disabled
-	 * and later on we must call usb_disconnect().  We can't call
-	 * it now because we may not hold the hub's device lock.
-	 */
-	n = 0;
-	for (port1 = 1; port1 &lt;= hdev-&gt;maxchild; ++port1) {
-		if (hdev-&gt;children[port1 - 1]) {
-			++n;
-			hub_port_disable(hub, port1, 1);
-		}
-	}
-
-	if (n == 0)
-		kfree(hub);
-	else {
-		/* Reuse the hub-&gt;leds work_struct for our own purposes */
-		INIT_WORK(&amp;hub-&gt;leds, hub_remove_children_work, hub);
-		schedule_work(&amp;hub-&gt;leds);
-		usb_get_dev(hdev);
-	}
+	kfree(hub);
 }
 
 static int hub_probe(struct usb_interface *intf, const struct usb_device_id *id)
@@ -917,26 +905,6 @@ hub_ioctl(struct usb_interface *intf, unsigned int code, void *user_data)
 	}
 }
 
-/* caller has locked the hub device */
-static void hub_pre_reset(struct usb_hub *hub)
-{
-	struct usb_device *hdev = hub-&gt;hdev;
-	int i;
-
-	for (i = 0; i &lt; hdev-&gt;maxchild; ++i) {
-		if (hdev-&gt;children[i])
-			usb_disconnect(&amp;hdev-&gt;children[i]);
-	}
-	hub_quiesce(hub);
-}
-
-/* caller has locked the hub device */
-static void hub_post_reset(struct usb_hub *hub)
-{
-	hub_activate(hub);
-	hub_power_on(hub);
-}
-
 
 /* grab device/port lock, returning index of that port (zero based).
  * protects the upstream link used by this device from concurrent
@@ -2682,7 +2650,7 @@ static void hub_events(void)
 
 		/* If the hub has died, clean up after it */
 		if (hdev-&gt;state == USB_STATE_NOTATTACHED) {
-			hub_pre_reset(hub);
+			hub_pre_reset(hub, 0);
 			goto loop;
 		}
 
@@ -2997,7 +2965,7 @@ int usb_reset_device(struct usb_device *udev)
 			udev-&gt;actconfig-&gt;interface[0]-&gt;dev.driver ==
 				&amp;hub_driver.driver &amp;&amp;
 			(hub = hdev_to_hub(udev)) != NULL) {
-		hub_pre_reset(hub);
+		hub_pre_reset(hub, 0);
 	}
 
 	set_bit(port1, parent_hub-&gt;busy_bits);</pre><hr><pre>commit 9ad3d6ccf5eee285e233dbaf186369b8d477a666
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Nov 17 17:10:32 2005 -0500

    [PATCH] USB: Remove USB private semaphore
    
    This patch (as605) removes the private udev-&gt;serialize semaphore,
    relying instead on the locking provided by the embedded struct device's
    semaphore.  The changes are confined to the core, except that the
    usb_trylock_device routine now uses the return convention of
    down_trylock rather than down_read_trylock (they return opposite values
    for no good reason).
    
    A couple of other associated changes are included as well:
    
            Now that we aren't concerned about HCDs that avoid using the
            hcd glue layer, usb_disconnect no longer needs to acquire the
            usb_bus_lock -- that can be done by usb_remove_hcd where it
            belongs.
    
            Devices aren't locked over the same scope of code in
            usb_new_device and hub_port_connect_change as they used to be.
            This shouldn't cause any trouble.
    
    Along with the preceding driver core patch, this needs a lot of testing.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/devices.c b/drivers/usb/core/devices.c
index 83e815d3cd52..55bc563a3256 100644
--- a/drivers/usb/core/devices.c
+++ b/drivers/usb/core/devices.c
@@ -545,10 +545,10 @@ static ssize_t usb_device_dump(char __user **buffer, size_t *nbytes, loff_t *ski
 		struct usb_device *childdev = usbdev-&gt;children[chix];
 
 		if (childdev) {
-			down(&amp;childdev-&gt;serialize);
+			usb_lock_device(childdev);
 			ret = usb_device_dump(buffer, nbytes, skip_bytes, file_offset, childdev,
 					bus, level + 1, chix, ++cnt);
-			up(&amp;childdev-&gt;serialize);
+			usb_unlock_device(childdev);
 			if (ret == -EFAULT)
 				return total_written;
 			total_written += ret;
diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 3a73170e95dd..2b68998fe4b3 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -1349,9 +1349,7 @@ static int proc_ioctl(struct dev_state *ps, struct usbdevfs_ioctl *ctl)
 	/* let kernel drivers try to (re)bind to the interface */
 	case USBDEVFS_CONNECT:
 		usb_unlock_device(ps-&gt;dev);
-		usb_lock_all_devices();
 		bus_rescan_devices(intf-&gt;dev.bus);
-		usb_unlock_all_devices();
 		usb_lock_device(ps-&gt;dev);
 		break;
 
diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index bb139f06bcd6..076462c8ba2a 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -432,9 +432,7 @@ int usb_register_driver(struct usb_driver *new_driver, struct module *owner)
 	spin_lock_init(&amp;new_driver-&gt;dynids.lock);
 	INIT_LIST_HEAD(&amp;new_driver-&gt;dynids.list);
 
-	usb_lock_all_devices();
 	retval = driver_register(&amp;new_driver-&gt;driver);
-	usb_unlock_all_devices();
 
 	if (!retval) {
 		pr_info("%s: registered new driver %s\n",
@@ -465,11 +463,9 @@ void usb_deregister(struct usb_driver *driver)
 {
 	pr_info("%s: deregistering driver %s\n", usbcore_name, driver-&gt;name);
 
-	usb_lock_all_devices();
 	usb_remove_newid_file(driver);
 	usb_free_dynids(driver);
 	driver_unregister(&amp;driver-&gt;driver);
-	usb_unlock_all_devices();
 
 	usbfs_update_special();
 }
diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index da24c31ee00d..d16a0e8a7d72 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -857,9 +857,7 @@ static int register_root_hub (struct usb_device *usb_dev,
 		return (retval &lt; 0) ? retval : -EMSGSIZE;
 	}
 
-	usb_lock_device (usb_dev);
 	retval = usb_new_device (usb_dev);
-	usb_unlock_device (usb_dev);
 	if (retval) {
 		usb_dev-&gt;bus-&gt;root_hub = NULL;
 		dev_err (parent_dev, "can't register root hub for %s, %d\n",
@@ -1891,7 +1889,10 @@ void usb_remove_hcd(struct usb_hcd *hcd)
 	spin_lock_irq (&amp;hcd_root_hub_lock);
 	hcd-&gt;rh_registered = 0;
 	spin_unlock_irq (&amp;hcd_root_hub_lock);
+
+	down(&amp;usb_bus_list_lock);
 	usb_disconnect(&amp;hcd-&gt;self.root_hub);
+	up(&amp;usb_bus_list_lock);
 
 	hcd-&gt;poll_rh = 0;
 	del_timer_sync(&amp;hcd-&gt;rh_timer);
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 40c6c50c6bd9..dd3bcfb2bcb6 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -32,7 +32,7 @@
 #include "hub.h"
 
 /* Protect struct usb_device-&gt;state and -&gt;children members
- * Note: Both are also protected by -&gt;serialize, except that -&gt;state can
+ * Note: Both are also protected by -&gt;dev.sem, except that -&gt;state can
  * change to USB_STATE_NOTATTACHED even when the semaphore isn't held. */
 static DEFINE_SPINLOCK(device_state_lock);
 
@@ -975,8 +975,8 @@ static int locktree(struct usb_device *udev)
 			/* when everyone grabs locks top-&gt;bottom,
 			 * non-overlapping work may be concurrent
 			 */
-			down(&amp;udev-&gt;serialize);
-			up(&amp;hdev-&gt;serialize);
+			usb_lock_device(udev);
+			usb_unlock_device(hdev);
 			return t + 1;
 		}
 	}
@@ -1132,16 +1132,10 @@ void usb_disconnect(struct usb_device **pdev)
 	 * this quiesces everyting except pending urbs.
 	 */
 	usb_set_device_state(udev, USB_STATE_NOTATTACHED);
-
-	/* lock the bus list on behalf of HCDs unregistering their root hubs */
-	if (!udev-&gt;parent) {
-		down(&amp;usb_bus_list_lock);
-		usb_lock_device(udev);
-	} else
-		down(&amp;udev-&gt;serialize);
-
 	dev_info (&amp;udev-&gt;dev, "USB disconnect, address %d\n", udev-&gt;devnum);
 
+	usb_lock_device(udev);
+
 	/* Free up all the children before we remove this device */
 	for (i = 0; i &lt; USB_MAXCHILDREN; i++) {
 		if (udev-&gt;children[i])
@@ -1169,11 +1163,7 @@ void usb_disconnect(struct usb_device **pdev)
 	*pdev = NULL;
 	spin_unlock_irq(&amp;device_state_lock);
 
-	if (!udev-&gt;parent) {
-		usb_unlock_device(udev);
-		up(&amp;usb_bus_list_lock);
-	} else
-		up(&amp;udev-&gt;serialize);
+	usb_unlock_device(udev);
 
 	device_unregister(&amp;udev-&gt;dev);
 }
@@ -1243,8 +1233,8 @@ static inline void show_string(struct usb_device *udev, char *id, char *string)
  *
  * This is called with devices which have been enumerated, but not yet
  * configured.  The device descriptor is available, but not descriptors
- * for any device configuration.  The caller must have locked udev and
- * either the parent hub (if udev is a normal device) or else the
+ * for any device configuration.  The caller must have locked either
+ * the parent hub (if udev is a normal device) or else the
  * usb_bus_list_lock (if udev is a root hub).  The parent's pointer to
  * udev has already been installed, but udev is not yet visible through
  * sysfs or other filesystem code.
@@ -1254,8 +1244,7 @@ static inline void show_string(struct usb_device *udev, char *id, char *string)
  *
  * This call is synchronous, and may not be used in an interrupt context.
  *
- * Only the hub driver should ever call this; root hub registration
- * uses it indirectly.
+ * Only the hub driver or root-hub registrar should ever call this.
  */
 int usb_new_device(struct usb_device *udev)
 {
@@ -1364,6 +1353,8 @@ int usb_new_device(struct usb_device *udev)
 	}
 	usb_create_sysfs_dev_files (udev);
 
+	usb_lock_device(udev);
+
 	/* choose and set the configuration. that registers the interfaces
 	 * with the driver core, and lets usb device drivers bind to them.
 	 */
@@ -1385,6 +1376,8 @@ int usb_new_device(struct usb_device *udev)
 	/* USB device state == configured ... usable */
 	usb_notify_add_device(udev);
 
+	usb_unlock_device(udev);
+
 	return 0;
 
 fail:
@@ -1872,11 +1865,8 @@ int usb_resume_device(struct usb_device *udev)
 	usb_unlock_device(udev);
 
 	/* rebind drivers that had no suspend() */
-	if (status == 0) {
-		usb_lock_all_devices();
+	if (status == 0)
 		bus_rescan_devices(&amp;usb_bus_type);
-		usb_unlock_all_devices();
-	}
 	return status;
 }
 
@@ -1889,14 +1879,14 @@ static int remote_wakeup(struct usb_device *udev)
 	/* don't repeat RESUME sequence if this device
 	 * was already woken up by some other task
 	 */
-	down(&amp;udev-&gt;serialize);
+	usb_lock_device(udev);
 	if (udev-&gt;state == USB_STATE_SUSPENDED) {
 		dev_dbg(&amp;udev-&gt;dev, "RESUME (wakeup)\n");
 		/* TRSMRCY = 10 msec */
 		msleep(10);
 		status = finish_device_resume(udev);
 	}
-	up(&amp;udev-&gt;serialize);
+	usb_unlock_device(udev);
 #endif
 	return status;
 }
@@ -1997,7 +1987,7 @@ static int hub_resume(struct usb_interface *intf)
 
 		if (!udev || status &lt; 0)
 			continue;
-		down (&amp;udev-&gt;serialize);
+		usb_lock_device(udev);
 		if (portstat &amp; USB_PORT_STAT_SUSPEND)
 			status = hub_port_resume(hub, port1, udev);
 		else {
@@ -2008,7 +1998,7 @@ static int hub_resume(struct usb_interface *intf)
 				hub_port_logical_disconnect(hub, port1);
 			}
 		}
-		up(&amp;udev-&gt;serialize);
+		usb_unlock_device(udev);
 	}
 	}
 #endif
@@ -2573,7 +2563,6 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 		 * udev becomes globally accessible, although presumably
 		 * no one will look at it until hdev is unlocked.
 		 */
-		down (&amp;udev-&gt;serialize);
 		status = 0;
 
 		/* We mustn't add new devices if the parent hub has
@@ -2597,7 +2586,6 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 			}
 		}
 
-		up (&amp;udev-&gt;serialize);
 		if (status)
 			goto loop_disable;
 
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index 294e9f127477..fcfda21be499 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -32,7 +32,6 @@
 #include &lt;linux/spinlock.h&gt;
 #include &lt;linux/errno.h&gt;
 #include &lt;linux/smp_lock.h&gt;
-#include &lt;linux/rwsem.h&gt;
 #include &lt;linux/usb.h&gt;
 
 #include &lt;asm/io.h&gt;
@@ -49,8 +48,6 @@ const char *usbcore_name = "usbcore";
 static int nousb;	/* Disable USB when built into kernel image */
 			/* Not honored on modular build */
 
-static DECLARE_RWSEM(usb_all_devices_rwsem);
-
 
 /**
  * usb_ifnum_to_if - get the interface object with a given interface number
@@ -446,8 +443,6 @@ usb_alloc_dev(struct usb_device *parent, struct usb_bus *bus, unsigned port1)
 	dev-&gt;parent = parent;
 	INIT_LIST_HEAD(&amp;dev-&gt;filelist);
 
-	init_MUTEX(&amp;dev-&gt;serialize);
-
 	return dev;
 }
 
@@ -520,75 +515,20 @@ void usb_put_intf(struct usb_interface *intf)
 
 /*			USB device locking
  *
- * Although locking USB devices should be straightforward, it is
- * complicated by the way the driver-model core works.  When a new USB
- * driver is registered or unregistered, the core will automatically
- * probe or disconnect all matching interfaces on all USB devices while
- * holding the USB subsystem writelock.  There's no good way for us to
- * tell which devices will be used or to lock them beforehand; our only
- * option is to effectively lock all the USB devices.
- *
- * We do that by using a private rw-semaphore, usb_all_devices_rwsem.
- * When locking an individual device you must first acquire the rwsem's
- * readlock.  When a driver is registered or unregistered the writelock
- * must be held.  These actions are encapsulated in the subroutines
- * below, so all a driver needs to do is call usb_lock_device() and
- * usb_unlock_device().
+ * USB devices and interfaces are locked using the semaphore in their
+ * embedded struct device.  The hub driver guarantees that whenever a
+ * device is connected or disconnected, drivers are called with the
+ * USB device locked as well as their particular interface.
  *
  * Complications arise when several devices are to be locked at the same
  * time.  Only hub-aware drivers that are part of usbcore ever have to
- * do this; nobody else needs to worry about it.  The problem is that
- * usb_lock_device() must not be called to lock a second device since it
- * would acquire the rwsem's readlock reentrantly, leading to deadlock if
- * another thread was waiting for the writelock.  The solution is simple:
- *
- *	When locking more than one device, call usb_lock_device()
- *	to lock the first one.  Lock the others by calling
- *	down(&amp;udev-&gt;serialize) directly.
- *
- *	When unlocking multiple devices, use up(&amp;udev-&gt;serialize)
- *	to unlock all but the last one.  Unlock the last one by
- *	calling usb_unlock_device().
+ * do this; nobody else needs to worry about it.  The rule for locking
+ * is simple:
  *
  *	When locking both a device and its parent, always lock the
  *	the parent first.
  */
 
-/**
- * usb_lock_device - acquire the lock for a usb device structure
- * @udev: device that's being locked
- *
- * Use this routine when you don't hold any other device locks;
- * to acquire nested inner locks call down(&amp;udev-&gt;serialize) directly.
- * This is necessary for proper interaction with usb_lock_all_devices().
- */
-void usb_lock_device(struct usb_device *udev)
-{
-	down_read(&amp;usb_all_devices_rwsem);
-	down(&amp;udev-&gt;serialize);
-}
-
-/**
- * usb_trylock_device - attempt to acquire the lock for a usb device structure
- * @udev: device that's being locked
- *
- * Don't use this routine if you already hold a device lock;
- * use down_trylock(&amp;udev-&gt;serialize) instead.
- * This is necessary for proper interaction with usb_lock_all_devices().
- *
- * Returns 1 if successful, 0 if contention.
- */
-int usb_trylock_device(struct usb_device *udev)
-{
-	if (!down_read_trylock(&amp;usb_all_devices_rwsem))
-		return 0;
-	if (down_trylock(&amp;udev-&gt;serialize)) {
-		up_read(&amp;usb_all_devices_rwsem);
-		return 0;
-	}
-	return 1;
-}
-
 /**
  * usb_lock_device_for_reset - cautiously acquire the lock for a
  *	usb device structure
@@ -627,7 +567,7 @@ int usb_lock_device_for_reset(struct usb_device *udev,
 		}
 	}
 
-	while (!usb_trylock_device(udev)) {
+	while (usb_trylock_device(udev) != 0) {
 
 		/* If we can't acquire the lock after waiting one second,
 		 * we're probably deadlocked */
@@ -645,39 +585,6 @@ int usb_lock_device_for_reset(struct usb_device *udev,
 	return 1;
 }
 
-/**
- * usb_unlock_device - release the lock for a usb device structure
- * @udev: device that's being unlocked
- *
- * Use this routine when releasing the only device lock you hold;
- * to release inner nested locks call up(&amp;udev-&gt;serialize) directly.
- * This is necessary for proper interaction with usb_lock_all_devices().
- */
-void usb_unlock_device(struct usb_device *udev)
-{
-	up(&amp;udev-&gt;serialize);
-	up_read(&amp;usb_all_devices_rwsem);
-}
-
-/**
- * usb_lock_all_devices - acquire the lock for all usb device structures
- *
- * This is necessary when registering a new driver or probing a bus,
- * since the driver-model core may try to use any usb_device.
- */
-void usb_lock_all_devices(void)
-{
-	down_write(&amp;usb_all_devices_rwsem);
-}
-
-/**
- * usb_unlock_all_devices - release the lock for all usb device structures
- */
-void usb_unlock_all_devices(void)
-{
-	up_write(&amp;usb_all_devices_rwsem);
-}
-
 
 static struct usb_device *match_device(struct usb_device *dev,
 				       u16 vendor_id, u16 product_id)
@@ -700,10 +607,10 @@ static struct usb_device *match_device(struct usb_device *dev,
 	/* look through all of the children of this device */
 	for (child = 0; child &lt; dev-&gt;maxchild; ++child) {
 		if (dev-&gt;children[child]) {
-			down(&amp;dev-&gt;children[child]-&gt;serialize);
+			usb_lock_device(dev-&gt;children[child]);
 			ret_dev = match_device(dev-&gt;children[child],
 					       vendor_id, product_id);
-			up(&amp;dev-&gt;children[child]-&gt;serialize);
+			usb_unlock_device(dev-&gt;children[child]);
 			if (ret_dev)
 				goto exit;
 		}
@@ -1300,10 +1207,7 @@ EXPORT_SYMBOL(usb_put_dev);
 EXPORT_SYMBOL(usb_get_dev);
 EXPORT_SYMBOL(usb_hub_tt_clear_buffer);
 
-EXPORT_SYMBOL(usb_lock_device);
-EXPORT_SYMBOL(usb_trylock_device);
 EXPORT_SYMBOL(usb_lock_device_for_reset);
-EXPORT_SYMBOL(usb_unlock_device);
 
 EXPORT_SYMBOL(usb_driver_claim_interface);
 EXPORT_SYMBOL(usb_driver_release_interface);
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 98e85fb4d3b7..4647e1ebc68d 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -16,9 +16,6 @@ extern int usb_get_device_descriptor(struct usb_device *dev,
 extern char *usb_cache_string(struct usb_device *udev, int index);
 extern int usb_set_configuration(struct usb_device *dev, int configuration);
 
-extern void usb_lock_all_devices(void);
-extern void usb_unlock_all_devices(void);
-
 extern void usb_kick_khubd(struct usb_device *dev);
 extern void usb_suspend_root_hub(struct usb_device *hdev);
 extern void usb_resume_root_hub(struct usb_device *dev);
diff --git a/drivers/usb/host/ohci-hub.c b/drivers/usb/host/ohci-hub.c
index 72e3b12a1926..4b2226d77b34 100644
--- a/drivers/usb/host/ohci-hub.c
+++ b/drivers/usb/host/ohci-hub.c
@@ -372,7 +372,7 @@ ohci_hub_status_data (struct usb_hcd *hcd, char *buf)
 					&amp; ohci-&gt;hc_control)
 				== OHCI_USB_OPER
 			&amp;&amp; time_after (jiffies, ohci-&gt;next_statechange)
-			&amp;&amp; usb_trylock_device (hcd-&gt;self.root_hub)
+			&amp;&amp; usb_trylock_device (hcd-&gt;self.root_hub) == 0
 			) {
 		ohci_vdbg (ohci, "autosuspend\n");
 		(void) ohci_bus_suspend (hcd);
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 2714814ab66c..46dc0421d19e 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -329,8 +329,6 @@ struct usb_device {
 	struct usb_tt	*tt; 		/* low/full speed dev, highspeed hub */
 	int		ttport;		/* device port on that tt hub */
 
-	struct semaphore serialize;
-
 	unsigned int toggle[2];		/* one bit for each endpoint
 					 * ([0] = IN, [1] = OUT) */
 
@@ -377,11 +375,12 @@ struct usb_device {
 extern struct usb_device *usb_get_dev(struct usb_device *dev);
 extern void usb_put_dev(struct usb_device *dev);
 
-extern void usb_lock_device(struct usb_device *udev);
-extern int usb_trylock_device(struct usb_device *udev);
+/* USB device locking */
+#define usb_lock_device(udev)		down(&amp;(udev)-&gt;dev.sem)
+#define usb_unlock_device(udev)		up(&amp;(udev)-&gt;dev.sem)
+#define usb_trylock_device(udev)	down_trylock(&amp;(udev)-&gt;dev.sem)
 extern int usb_lock_device_for_reset(struct usb_device *udev,
 		struct usb_interface *iface);
-extern void usb_unlock_device(struct usb_device *udev);
 
 /* USB port reset for device reinitialization */
 extern int usb_reset_device(struct usb_device *dev);</pre><hr><pre>commit 1c50c317e2e7f15427149cbc216a63366468710e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Nov 14 11:45:38 2005 -0500

    [PATCH] USB: central handling for host controllers that were reset during suspend/resume
    
    This patch (as515b) adds a routine to usbcore to simplify handling of
    host controllers that lost power or were reset during suspend/resume.
    The new core routine marks all the child devices of the root hub as
    NOTATTACHED and tells khubd to disconnect the device structures as soon
    as possible.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.h b/drivers/usb/core/hcd.h
index c8a1b350e2cf..591b5aad1a18 100644
--- a/drivers/usb/core/hcd.h
+++ b/drivers/usb/core/hcd.h
@@ -380,6 +380,7 @@ extern int usb_find_interface_driver (struct usb_device *dev,
 #ifdef CONFIG_PM
 extern void usb_hcd_suspend_root_hub (struct usb_hcd *hcd);
 extern void usb_hcd_resume_root_hub (struct usb_hcd *hcd);
+extern void usb_root_hub_lost_power (struct usb_device *rhdev);
 extern int hcd_bus_suspend (struct usb_bus *bus);
 extern int hcd_bus_resume (struct usb_bus *bus);
 #else
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index f78bd124d290..5faf7edd73cb 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1039,6 +1039,39 @@ void usb_set_device_state(struct usb_device *udev,
 EXPORT_SYMBOL(usb_set_device_state);
 
 
+#ifdef CONFIG_PM
+
+/**
+ * usb_root_hub_lost_power - called by HCD if the root hub lost Vbus power
+ * @rhdev: struct usb_device for the root hub
+ *
+ * The USB host controller driver calls this function when its root hub
+ * is resumed and Vbus power has been interrupted or the controller
+ * has been reset.  The routine marks all the children of the root hub
+ * as NOTATTACHED and marks logical connect-change events on their ports.
+ */
+void usb_root_hub_lost_power(struct usb_device *rhdev)
+{
+	struct usb_hub *hub;
+	int port1;
+	unsigned long flags;
+
+	dev_warn(&amp;rhdev-&gt;dev, "root hub lost power or was reset\n");
+	spin_lock_irqsave(&amp;device_state_lock, flags);
+	hub = hdev_to_hub(rhdev);
+	for (port1 = 1; port1 &lt;= rhdev-&gt;maxchild; ++port1) {
+		if (rhdev-&gt;children[port1 - 1]) {
+			recursively_mark_NOTATTACHED(
+					rhdev-&gt;children[port1 - 1]);
+			set_bit(port1, hub-&gt;change_bits);
+		}
+	}
+	spin_unlock_irqrestore(&amp;device_state_lock, flags);
+}
+EXPORT_SYMBOL_GPL(usb_root_hub_lost_power);
+
+#endif
+
 static void choose_address(struct usb_device *udev)
 {
 	int		devnum;
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index ac088bc72f1c..08ca0f849dab 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -278,7 +278,6 @@ static int ehci_pci_resume(struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
 	unsigned		port;
-	struct usb_device	*root = hcd-&gt;self.root_hub;
 	struct pci_dev		*pdev = to_pci_dev(hcd-&gt;self.controller);
 	int			retval = -EINVAL;
 
@@ -312,13 +311,7 @@ static int ehci_pci_resume(struct usb_hcd *hcd)
 
 restart:
 	ehci_dbg(ehci, "lost power, restarting\n");
-	for (port = HCS_N_PORTS(ehci-&gt;hcs_params); port &gt; 0; ) {
-		port--;
-		if (!root-&gt;children [port])
-			continue;
-		usb_set_device_state(root-&gt;children[port],
-					USB_STATE_NOTATTACHED);
-	}
+	usb_root_hub_lost_power(hcd-&gt;self.root_hub);
 
 	/* Else reset, to cope with power loss or flush-to-storage
 	 * style "resume" having let BIOS kick in during reboot.
diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index e3af3ac4416a..a4b12404ae08 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -795,7 +795,6 @@ static int ohci_restart (struct ohci_hcd *ohci)
 	int temp;
 	int i;
 	struct urb_priv *priv;
-	struct usb_device *root = ohci_to_hcd(ohci)-&gt;self.root_hub;
 
 	/* mark any devices gone, so they do nothing till khubd disconnects.
 	 * recycle any "live" eds/tds (and urbs) right away.
@@ -804,11 +803,7 @@ static int ohci_restart (struct ohci_hcd *ohci)
 	 */ 
 	spin_lock_irq(&amp;ohci-&gt;lock);
 	disable (ohci);
-	for (i = 0; i &lt; root-&gt;maxchild; i++) {
-		if (root-&gt;children [i])
-			usb_set_device_state (root-&gt;children[i],
-				USB_STATE_NOTATTACHED);
-	}
+	usb_root_hub_lost_power(ohci_to_hcd(ohci)-&gt;self.root_hub);
 	if (!list_empty (&amp;ohci-&gt;pending))
 		ohci_dbg(ohci, "abort schedule...\n");
 	list_for_each_entry (priv, &amp;ohci-&gt;pending, pending) {
diff --git a/drivers/usb/host/sl811-hcd.c b/drivers/usb/host/sl811-hcd.c
index 3a9cd4607962..517360b77d8e 100644
--- a/drivers/usb/host/sl811-hcd.c
+++ b/drivers/usb/host/sl811-hcd.c
@@ -1803,6 +1803,7 @@ sl811h_resume(struct platform_device *dev)
 			|| !device_can_wakeup(&amp;hcd-&gt;self.root_hub-&gt;dev)) {
 		sl811-&gt;port1 = 0;
 		port_power(sl811, 1);
+		usb_root_hub_lost_power(hcd-&gt;self.root_hub);
 		return 0;
 	}
 
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 1c0394cb3c89..071fab6b6475 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -748,8 +748,12 @@ static int uhci_resume(struct usb_hcd *hcd)
 	check_and_reset_hc(uhci);
 	configure_hc(uhci);
 
-	if (uhci-&gt;rh_state == UHCI_RH_RESET)
+	if (uhci-&gt;rh_state == UHCI_RH_RESET) {
+
+		/* The controller had to be reset */
+		usb_root_hub_lost_power(hcd-&gt;self.root_hub);
 		suspend_rh(uhci, UHCI_RH_SUSPENDED);
+	}
 
 	spin_unlock_irq(&amp;uhci-&gt;lock);
 </pre><hr><pre>commit 8364d6b0be2dbbf162c6aea79615b5025a0d67c2
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Nov 14 12:16:30 2005 -0500

    [PATCH] USB: dummy_hcd: rename variables
    
    The recent platform_device update has reintroduced into dummy_hcd.c the
    dreaded dev-&gt;dev syndrome.  This harkens back to when an earlier version
    of that driver included the unforgettable line:
    
            dev-&gt;dev.dev.driver_data = dev;
    
    This patch (as602) renames the platform_device variables to "pdev", in
    the hope of reducing confusion.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index c655d46c8aed..4932b07b316d 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -896,7 +896,7 @@ dummy_gadget_release (struct device *dev)
 #endif
 }
 
-static int dummy_udc_probe (struct platform_device *dev)
+static int dummy_udc_probe (struct platform_device *pdev)
 {
 	struct dummy	*dum = the_controller;
 	int		rc;
@@ -909,7 +909,7 @@ static int dummy_udc_probe (struct platform_device *dev)
 	dum-&gt;gadget.is_otg = (dummy_to_hcd(dum)-&gt;self.otg_port != 0);
 
 	strcpy (dum-&gt;gadget.dev.bus_id, "gadget");
-	dum-&gt;gadget.dev.parent = &amp;dev-&gt;dev;
+	dum-&gt;gadget.dev.parent = &amp;pdev-&gt;dev;
 	dum-&gt;gadget.dev.release = dummy_gadget_release;
 	rc = device_register (&amp;dum-&gt;gadget.dev);
 	if (rc &lt; 0)
@@ -919,47 +919,47 @@ static int dummy_udc_probe (struct platform_device *dev)
 	usb_bus_get (&amp;dummy_to_hcd (dum)-&gt;self);
 #endif
 
-	platform_set_drvdata (dev, dum);
+	platform_set_drvdata (pdev, dum);
 	device_create_file (&amp;dum-&gt;gadget.dev, &amp;dev_attr_function);
 	return rc;
 }
 
-static int dummy_udc_remove (struct platform_device *dev)
+static int dummy_udc_remove (struct platform_device *pdev)
 {
-	struct dummy	*dum = platform_get_drvdata (dev);
+	struct dummy	*dum = platform_get_drvdata (pdev);
 
-	platform_set_drvdata (dev, NULL);
+	platform_set_drvdata (pdev, NULL);
 	device_remove_file (&amp;dum-&gt;gadget.dev, &amp;dev_attr_function);
 	device_unregister (&amp;dum-&gt;gadget.dev);
 	return 0;
 }
 
-static int dummy_udc_suspend (struct platform_device *dev, pm_message_t state)
+static int dummy_udc_suspend (struct platform_device *pdev, pm_message_t state)
 {
-	struct dummy	*dum = platform_get_drvdata(dev);
+	struct dummy	*dum = platform_get_drvdata(pdev);
 
-	dev_dbg (&amp;dev-&gt;dev, "%s\n", __FUNCTION__);
+	dev_dbg (&amp;pdev-&gt;dev, "%s\n", __FUNCTION__);
 	spin_lock_irq (&amp;dum-&gt;lock);
 	dum-&gt;udc_suspended = 1;
 	set_link_state (dum);
 	spin_unlock_irq (&amp;dum-&gt;lock);
 
-	dev-&gt;dev.power.power_state = state;
+	pdev-&gt;dev.power.power_state = state;
 	usb_hcd_poll_rh_status (dummy_to_hcd (dum));
 	return 0;
 }
 
-static int dummy_udc_resume (struct platform_device *dev)
+static int dummy_udc_resume (struct platform_device *pdev)
 {
-	struct dummy	*dum = platform_get_drvdata(dev);
+	struct dummy	*dum = platform_get_drvdata(pdev);
 
-	dev_dbg (&amp;dev-&gt;dev, "%s\n", __FUNCTION__);
+	dev_dbg (&amp;pdev-&gt;dev, "%s\n", __FUNCTION__);
 	spin_lock_irq (&amp;dum-&gt;lock);
 	dum-&gt;udc_suspended = 0;
 	set_link_state (dum);
 	spin_unlock_irq (&amp;dum-&gt;lock);
 
-	dev-&gt;dev.power.power_state = PMSG_ON;
+	pdev-&gt;dev.power.power_state = PMSG_ON;
 	usb_hcd_poll_rh_status (dummy_to_hcd (dum));
 	return 0;
 }
@@ -1899,14 +1899,14 @@ static const struct hc_driver dummy_hcd = {
 	.bus_resume =		dummy_bus_resume,
 };
 
-static int dummy_hcd_probe (struct platform_device *dev)
+static int dummy_hcd_probe(struct platform_device *pdev)
 {
 	struct usb_hcd		*hcd;
 	int			retval;
 
-	dev_info(&amp;dev-&gt;dev, "%s, driver " DRIVER_VERSION "\n", driver_desc);
+	dev_info(&amp;pdev-&gt;dev, "%s, driver " DRIVER_VERSION "\n", driver_desc);
 
-	hcd = usb_create_hcd (&amp;dummy_hcd, &amp;dev-&gt;dev, dev-&gt;dev.bus_id);
+	hcd = usb_create_hcd(&amp;dummy_hcd, &amp;pdev-&gt;dev, pdev-&gt;dev.bus_id);
 	if (!hcd)
 		return -ENOMEM;
 	the_controller = hcd_to_dummy (hcd);
@@ -1919,34 +1919,34 @@ static int dummy_hcd_probe (struct platform_device *dev)
 	return retval;
 }
 
-static int dummy_hcd_remove (struct platform_device *dev)
+static int dummy_hcd_remove (struct platform_device *pdev)
 {
 	struct usb_hcd		*hcd;
 
-	hcd = platform_get_drvdata (dev);
+	hcd = platform_get_drvdata (pdev);
 	usb_remove_hcd (hcd);
 	usb_put_hcd (hcd);
 	the_controller = NULL;
 	return 0;
 }
 
-static int dummy_hcd_suspend (struct platform_device *dev, pm_message_t state)
+static int dummy_hcd_suspend (struct platform_device *pdev, pm_message_t state)
 {
 	struct usb_hcd		*hcd;
 
-	dev_dbg (&amp;dev-&gt;dev, "%s\n", __FUNCTION__);
-	hcd = platform_get_drvdata (dev);
+	dev_dbg (&amp;pdev-&gt;dev, "%s\n", __FUNCTION__);
+	hcd = platform_get_drvdata (pdev);
 
 	hcd-&gt;state = HC_STATE_SUSPENDED;
 	return 0;
 }
 
-static int dummy_hcd_resume (struct platform_device *dev)
+static int dummy_hcd_resume (struct platform_device *pdev)
 {
 	struct usb_hcd		*hcd;
 
-	dev_dbg (&amp;dev-&gt;dev, "%s\n", __FUNCTION__);
-	hcd = platform_get_drvdata (dev);
+	dev_dbg (&amp;pdev-&gt;dev, "%s\n", __FUNCTION__);
+	hcd = platform_get_drvdata (pdev);
 	hcd-&gt;state = HC_STATE_RUNNING;
 
 	usb_hcd_poll_rh_status (hcd);</pre><hr><pre>commit 87c4252a35310fdbb2aabb880a39b83f83cadf62
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Nov 9 16:59:56 2005 -0500

    [PATCH] USB: file-storage gadget: Add reference count for children
    
    This patch (as601) adds a proper reference count to the file-storage
    gadget's main data structure, to keep track of references held by child
    devices (LUNs in this case).  Before this, the driver would wait for
    each child to be released before unbinding.
    
    While there's nothing really wrong with that (you can't create a hang by
    doing "rmmod g_file_storage &lt;/sys/.../lun0/ro" since the open file will
    prevent rmmod from running), the code might as well follow the standard
    procedures.  Besides, this shrinks the size of the structure by a few
    words...  :-)
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/file_storage.c b/drivers/usb/gadget/file_storage.c
index ea09aaa3cab6..f6f0b2aa1145 100644
--- a/drivers/usb/gadget/file_storage.c
+++ b/drivers/usb/gadget/file_storage.c
@@ -224,6 +224,7 @@
 #include &lt;linux/fs.h&gt;
 #include &lt;linux/init.h&gt;
 #include &lt;linux/kernel.h&gt;
+#include &lt;linux/kref.h&gt;
 #include &lt;linux/kthread.h&gt;
 #include &lt;linux/limits.h&gt;
 #include &lt;linux/list.h&gt;
@@ -631,6 +632,9 @@ struct fsg_dev {
 	/* filesem protects: backing files in use */
 	struct rw_semaphore	filesem;
 
+	/* reference counting: wait until all LUNs are released */
+	struct kref		ref;
+
 	struct usb_ep		*ep0;		// Handy copy of gadget-&gt;ep0
 	struct usb_request	*ep0req;	// For control responses
 	volatile unsigned int	ep0_req_tag;
@@ -694,7 +698,6 @@ struct fsg_dev {
 	unsigned int		nluns;
 	struct lun		*luns;
 	struct lun		*curlun;
-	struct completion	lun_released;
 };
 
 typedef void (*fsg_routine_t)(struct fsg_dev *);
@@ -3642,11 +3645,19 @@ static DEVICE_ATTR(file, 0444, show_file, NULL);
 
 /*-------------------------------------------------------------------------*/
 
+static void fsg_release(struct kref *ref)
+{
+	struct fsg_dev	*fsg = container_of(ref, struct fsg_dev, ref);
+
+	kfree(fsg-&gt;luns);
+	kfree(fsg);
+}
+
 static void lun_release(struct device *dev)
 {
 	struct fsg_dev	*fsg = (struct fsg_dev *) dev_get_drvdata(dev);
 
-	complete(&amp;fsg-&gt;lun_released);
+	kref_put(&amp;fsg-&gt;ref, fsg_release);
 }
 
 static void fsg_unbind(struct usb_gadget *gadget)
@@ -3660,14 +3671,12 @@ static void fsg_unbind(struct usb_gadget *gadget)
 	clear_bit(REGISTERED, &amp;fsg-&gt;atomic_bitflags);
 
 	/* Unregister the sysfs attribute files and the LUNs */
-	init_completion(&amp;fsg-&gt;lun_released);
 	for (i = 0; i &lt; fsg-&gt;nluns; ++i) {
 		curlun = &amp;fsg-&gt;luns[i];
 		if (curlun-&gt;registered) {
 			device_remove_file(&amp;curlun-&gt;dev, &amp;dev_attr_ro);
 			device_remove_file(&amp;curlun-&gt;dev, &amp;dev_attr_file);
 			device_unregister(&amp;curlun-&gt;dev);
-			wait_for_completion(&amp;fsg-&gt;lun_released);
 			curlun-&gt;registered = 0;
 		}
 	}
@@ -3846,6 +3855,7 @@ static int __init fsg_bind(struct usb_gadget *gadget)
 			curlun-&gt;dev.release = lun_release;
 			device_create_file(&amp;curlun-&gt;dev, &amp;dev_attr_ro);
 			device_create_file(&amp;curlun-&gt;dev, &amp;dev_attr_file);
+			kref_get(&amp;fsg-&gt;ref);
 		}
 
 		if (file[i] &amp;&amp; *file[i]) {
@@ -4061,6 +4071,7 @@ static int __init fsg_alloc(void)
 		return -ENOMEM;
 	spin_lock_init(&amp;fsg-&gt;lock);
 	init_rwsem(&amp;fsg-&gt;filesem);
+	kref_init(&amp;fsg-&gt;ref);
 	init_waitqueue_head(&amp;fsg-&gt;thread_wqh);
 	init_completion(&amp;fsg-&gt;thread_notifier);
 
@@ -4069,13 +4080,6 @@ static int __init fsg_alloc(void)
 }
 
 
-static void fsg_free(struct fsg_dev *fsg)
-{
-	kfree(fsg-&gt;luns);
-	kfree(fsg);
-}
-
-
 static int __init fsg_init(void)
 {
 	int		rc;
@@ -4085,7 +4089,7 @@ static int __init fsg_init(void)
 		return rc;
 	fsg = the_fsg;
 	if ((rc = usb_gadget_register_driver(&amp;fsg_driver)) != 0)
-		fsg_free(fsg);
+		kref_put(&amp;fsg-&gt;ref, fsg_release);
 	return rc;
 }
 module_init(fsg_init);
@@ -4103,6 +4107,6 @@ static void __exit fsg_cleanup(void)
 	wait_for_completion(&amp;fsg-&gt;thread_notifier);
 
 	close_all_backing_files(fsg);
-	fsg_free(fsg);
+	kref_put(&amp;fsg-&gt;ref, fsg_release);
 }
 module_exit(fsg_cleanup);</pre><hr><pre>commit 6912354a895fcd234155273fe8838a0d83259a9b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Nov 3 11:44:49 2005 -0500

    [PATCH] USB: EHCI: fix conflation of buf == 0 with len == 0
    
    When the ehci-hcd driver prepares a control URB, it tests for a
    zero-length data stage by looking at the transfer_dma value instead of
    the transfer_buffer_length.  (In fact it does this even for non-control
    URBs, which is an additional aspect of the same bug.)
    
    However, under certain circumstances it's possible for transfer_dma to
    be 0 while transfer_buffer_length is non-zero.  This can happen when a
    freshly allocated page (mapped to address 0 and marked Copy-On-Write,
    but never written to) is used as the source buffer for an OUT transfer.
    This patch (as598) fixes the problem.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: David Brownell &lt;dbrownell@users.sourceforge.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index bf03ec0d8ee2..9b13bf2fa98d 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -514,18 +514,18 @@ qh_urb_transaction (
 		qtd-&gt;urb = urb;
 		qtd_prev-&gt;hw_next = QTD_NEXT (qtd-&gt;qtd_dma);
 		list_add_tail (&amp;qtd-&gt;qtd_list, head);
+
+		/* for zero length DATA stages, STATUS is always IN */
+		if (len == 0)
+			token |= (1 /* "in" */ &lt;&lt; 8);
 	} 
 
 	/*
 	 * data transfer stage:  buffer setup
 	 */
-	if (likely (len &gt; 0))
-		buf = urb-&gt;transfer_dma;
-	else
-		buf = 0;
+	buf = urb-&gt;transfer_dma;
 
-	/* for zero length DATA stages, STATUS is always IN */
-	if (!buf || is_input)
+	if (is_input)
 		token |= (1 /* "in" */ &lt;&lt; 8);
 	/* else it's already initted to "out" pid (0 &lt;&lt; 8) */
 
@@ -572,7 +572,7 @@ qh_urb_transaction (
 	 * control requests may need a terminating data "status" ack;
 	 * bulk ones may need a terminating short packet (zero length).
 	 */
-	if (likely (buf != 0)) {
+	if (likely (urb-&gt;transfer_buffer_length != 0)) {
 		int	one_more = 0;
 
 		if (usb_pipecontrol (urb-&gt;pipe)) {</pre><hr><pre>commit 5a9191ff683ce4ebfd2c6a15e2989f5b1f420321
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Dec 21 14:28:11 2005 -0800

    [PATCH] usbcore: allow suspend/resume even if drivers don't support it
    
    This patch (as618) changes usbcore to prevent derailing the
    suspend/resume sequence when a USB driver doesn't include support for
    it.  This is a workaround rather than a true fix; the core needs to be
    changed so that URB submissions from suspended drivers can be refused
    and outstanding URBs cancelled.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index e197ce9353de..e80ef9467825 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -1432,7 +1432,8 @@ static int usb_generic_suspend(struct device *dev, pm_message_t message)
 			mark_quiesced(intf);
 	} else {
 		// FIXME else if there's no suspend method, disconnect...
-		dev_warn(dev, "no %s?\n", "suspend");
+		dev_warn(dev, "no suspend for driver %s?\n", driver-&gt;name);
+		mark_quiesced(intf);
 		status = 0;
 	}
 	return status;
@@ -1460,8 +1461,10 @@ static int usb_generic_resume(struct device *dev)
 	}
 
 	if ((dev-&gt;driver == NULL) ||
-	    (dev-&gt;driver_data == &amp;usb_generic_driver_data))
+	    (dev-&gt;driver_data == &amp;usb_generic_driver_data)) {
+		dev-&gt;power.power_state.event = PM_EVENT_FREEZE;
 		return 0;
+	}
 
 	intf = to_usb_interface(dev);
 	driver = to_usb_driver(dev-&gt;driver);
@@ -1481,7 +1484,7 @@ static int usb_generic_resume(struct device *dev)
 			mark_quiesced(intf);
 		}
 	} else
-		dev_warn(dev, "no %s?\n", "resume");
+		dev_warn(dev, "no resume for driver %s?\n", driver-&gt;name);
 	return 0;
 }
 </pre>
    <div class="pagination">
        <a href='2_130.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><span>[131]</span><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_132.html'>Next&gt;&gt;</a>
    <div>
</body>
