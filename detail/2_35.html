<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_34.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><span>[35]</span><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_36.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 15b7336e02d998720c5ace47036f7e539365bb05
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jul 30 15:35:40 2013 -0400

    USB: simplify the interface of usb_get_status()
    
    This patch simplifies the interface presented by usb_get_status().
    Instead of forcing callers to check for the proper data length and
    convert the status value to host byte order, the function will now
    do these things itself.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index c881830af55f..11a92198bfc7 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1464,11 +1464,10 @@ static int hub_configure(struct usb_hub *hub,
 	 * and battery-powered root hubs (may provide just 8 mA).
 	 */
 	ret = usb_get_status(hdev, USB_RECIP_DEVICE, 0, &amp;hubstatus);
-	if (ret &lt; 2) {
+	if (ret) {
 		message = "can't get hub status";
 		goto fail;
 	}
-	le16_to_cpus(&amp;hubstatus);
 	hcd = bus_to_hcd(hdev-&gt;bus);
 	if (hdev == hdev-&gt;bus-&gt;root_hub) {
 		if (hcd-&gt;power_budget &gt; 0)
@@ -3101,8 +3100,6 @@ static int finish_port_resume(struct usb_device *udev)
 	if (status == 0) {
 		devstatus = 0;
 		status = usb_get_status(udev, USB_RECIP_DEVICE, 0, &amp;devstatus);
-		if (status &gt;= 0)
-			status = (status &gt; 0 ? 0 : -ENODEV);
 
 		/* If a normal resume failed, try doing a reset-resume */
 		if (status &amp;&amp; !udev-&gt;reset_resume &amp;&amp; udev-&gt;persist_enabled) {
@@ -3123,7 +3120,6 @@ static int finish_port_resume(struct usb_device *udev)
 	 */
 	} else if (udev-&gt;actconfig &amp;&amp; !udev-&gt;reset_resume) {
 		if (!hub_is_superspeed(udev-&gt;parent)) {
-			le16_to_cpus(&amp;devstatus);
 			if (devstatus &amp; (1 &lt;&lt; USB_DEVICE_REMOTE_WAKEUP))
 				status = usb_control_msg(udev,
 						usb_sndctrlpipe(udev, 0),
@@ -3135,7 +3131,6 @@ static int finish_port_resume(struct usb_device *udev)
 		} else {
 			status = usb_get_status(udev, USB_RECIP_INTERFACE, 0,
 					&amp;devstatus);
-			le16_to_cpus(&amp;devstatus);
 			if (!status &amp;&amp; devstatus &amp; (USB_INTRF_STAT_FUNC_RW_CAP
 					| USB_INTRF_STAT_FUNC_RW))
 				status =
@@ -4481,11 +4476,10 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 
 			status = usb_get_status(udev, USB_RECIP_DEVICE, 0,
 					&amp;devstat);
-			if (status &lt; 2) {
+			if (status) {
 				dev_dbg(&amp;udev-&gt;dev, "get status %d ?\n", status);
 				goto loop_disable;
 			}
-			le16_to_cpus(&amp;devstat);
 			if ((devstat &amp; (1 &lt;&lt; USB_DEVICE_SELF_POWERED)) == 0) {
 				dev_err(&amp;udev-&gt;dev,
 					"can't connect bus-powered hub "
diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index e7ee1e451660..6549a975b0c5 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -934,13 +934,13 @@ int usb_get_device_descriptor(struct usb_device *dev, unsigned int size)
  *
  * This call is synchronous, and may not be used in an interrupt context.
  *
- * Returns the number of bytes received on success, or else the status code
- * returned by the underlying usb_control_msg() call.
+ * Returns 0 and the status value in *@data (in host byte order) on success,
+ * or else the status code from the underlying usb_control_msg() call.
  */
 int usb_get_status(struct usb_device *dev, int type, int target, void *data)
 {
 	int ret;
-	u16 *status = kmalloc(sizeof(*status), GFP_KERNEL);
+	__le16 *status = kmalloc(sizeof(*status), GFP_KERNEL);
 
 	if (!status)
 		return -ENOMEM;
@@ -949,7 +949,12 @@ int usb_get_status(struct usb_device *dev, int type, int target, void *data)
 		USB_REQ_GET_STATUS, USB_DIR_IN | type, 0, target, status,
 		sizeof(*status), USB_CTRL_GET_TIMEOUT);
 
-	*(u16 *)data = *status;
+	if (ret == 2) {
+		*(u16 *) data = le16_to_cpu(*status);
+		ret = 0;
+	} else if (ret &gt;= 0) {
+		ret = -EIO;
+	}
 	kfree(status);
 	return ret;
 }
diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 8b4ca1cb450a..aa28ac8c7607 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -747,9 +747,9 @@ static int ch9_postconfig(struct usbtest_dev *dev)
 
 	/* [9.4.5] get_status always works */
 	retval = usb_get_status(udev, USB_RECIP_DEVICE, 0, dev-&gt;buf);
-	if (retval != 2) {
+	if (retval) {
 		dev_err(&amp;iface-&gt;dev, "get dev status --&gt; %d\n", retval);
-		return (retval &lt; 0) ? retval : -EDOM;
+		return retval;
 	}
 
 	/* FIXME configuration.bmAttributes says if we could try to set/clear
@@ -758,9 +758,9 @@ static int ch9_postconfig(struct usbtest_dev *dev)
 
 	retval = usb_get_status(udev, USB_RECIP_INTERFACE,
 			iface-&gt;altsetting[0].desc.bInterfaceNumber, dev-&gt;buf);
-	if (retval != 2) {
+	if (retval) {
 		dev_err(&amp;iface-&gt;dev, "get interface status --&gt; %d\n", retval);
-		return (retval &lt; 0) ? retval : -EDOM;
+		return retval;
 	}
 	/* FIXME get status for each endpoint in the interface */
 
@@ -1351,7 +1351,6 @@ static int verify_halted(struct usbtest_dev *tdev, int ep, struct urb *urb)
 				ep, retval);
 		return retval;
 	}
-	le16_to_cpus(&amp;status);
 	if (status != 1) {
 		ERROR(tdev, "ep %02x bogus status: %04x != 1\n", ep, status);
 		return -EINVAL;</pre><hr><pre>commit c4b51a431561f0bacc1740aa27f080bf95c4d6c7
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jul 11 14:58:23 2013 -0400

    USB: remove redundant "#if"
    
    This patch removes a redundant nested "#ifdef CONFIG_PM" from the hub
    driver.  It also adds a label to the "#endif" line corresponding to
    the outer "#ifdef CONFIG_PM".
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 4191db32f12c..f735f6bc929c 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2829,7 +2829,6 @@ void usb_enable_ltm(struct usb_device *udev)
 }
 EXPORT_SYMBOL_GPL(usb_enable_ltm);
 
-#ifdef	CONFIG_PM
 /*
  * usb_disable_function_remotewakeup - disable usb3.0
  * device's function remote wakeup
@@ -3249,8 +3248,6 @@ int usb_port_resume(struct usb_device *udev, pm_message_t msg)
 	return status;
 }
 
-#endif	/* CONFIG_PM */
-
 #ifdef	CONFIG_PM_RUNTIME
 
 /* caller has locked udev */
@@ -3811,7 +3808,8 @@ EXPORT_SYMBOL_GPL(usb_disable_ltm);
 
 void usb_enable_ltm(struct usb_device *udev) { }
 EXPORT_SYMBOL_GPL(usb_enable_ltm);
-#endif
+
+#endif	/* CONFIG_PM */
 
 
 /* USB 2.0 spec, 7.1.7.3 / fig 7-29:</pre><hr><pre>commit e583d9db9960cf40e0bc8afee4946baa9d71596e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jul 11 14:58:04 2013 -0400

    USB: global suspend and remote wakeup don't mix
    
    The hub driver was recently changed to use "global" suspend for system
    suspend transitions on non-SuperSpeed buses.  This means that we don't
    suspend devices individually by setting the suspend feature on the
    upstream hub port; instead devices all go into suspend automatically
    when the root hub stops transmitting packets.  The idea was to save
    time and to avoid certain kinds of wakeup races.
    
    Now it turns out that many hubs are buggy; they don't relay wakeup
    requests from a downstream port to their upstream port if the
    downstream port's suspend feature is not set (depending on the speed
    of the downstream port, whether or not the hub is enabled for remote
    wakeup, and possibly other factors).
    
    We can't have hubs dropping wakeup requests.  Therefore this patch
    goes partway back to the old policy: It sets the suspend feature for a
    port if the device attached to that port or any of its descendants is
    enabled for wakeup.  People will still be able to benefit from the
    time savings if they don't care about wakeup and leave it disabled on
    all their devices.
    
    In order to accomplish this, the patch adds a new field to the usb_hub
    structure: wakeup_enabled_descendants is a count of how many devices
    below a suspended hub are enabled for remote wakeup.  A corresponding
    new subroutine determines the number of wakeup-enabled devices at or
    below an arbitrary suspended USB device.
    
    This should be applied to the 3.10 stable kernel.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Toralf Förster &lt;toralf.foerster@gmx.de&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 4191db32f12c..c857471519e3 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2848,6 +2848,15 @@ static int usb_disable_function_remotewakeup(struct usb_device *udev)
 				USB_CTRL_SET_TIMEOUT);
 }
 
+/* Count of wakeup-enabled devices at or below udev */
+static unsigned wakeup_enabled_descendants(struct usb_device *udev)
+{
+	struct usb_hub *hub = usb_hub_to_struct_hub(udev);
+
+	return udev-&gt;do_remote_wakeup +
+			(hub ? hub-&gt;wakeup_enabled_descendants : 0);
+}
+
 /*
  * usb_port_suspend - suspend a usb device's upstream port
  * @udev: device that's no longer in active use, not a root hub
@@ -2888,8 +2897,8 @@ static int usb_disable_function_remotewakeup(struct usb_device *udev)
  * Linux (2.6) currently has NO mechanisms to initiate that:  no khubd
  * timer, no SRP, no requests through sysfs.
  *
- * If Runtime PM isn't enabled or used, non-SuperSpeed devices really get
- * suspended only when their bus goes into global suspend (i.e., the root
+ * If Runtime PM isn't enabled or used, non-SuperSpeed devices may not get
+ * suspended until their bus goes into global suspend (i.e., the root
  * hub is suspended).  Nevertheless, we change @udev-&gt;state to
  * USB_STATE_SUSPENDED as this is the device's "logical" state.  The actual
  * upstream port setting is stored in @udev-&gt;port_is_suspended.
@@ -2960,15 +2969,21 @@ int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
 	/* see 7.1.7.6 */
 	if (hub_is_superspeed(hub-&gt;hdev))
 		status = hub_set_port_link_state(hub, port1, USB_SS_PORT_LS_U3);
-	else if (PMSG_IS_AUTO(msg))
-		status = set_port_feature(hub-&gt;hdev, port1,
-						USB_PORT_FEAT_SUSPEND);
+
 	/*
 	 * For system suspend, we do not need to enable the suspend feature
 	 * on individual USB-2 ports.  The devices will automatically go
 	 * into suspend a few ms after the root hub stops sending packets.
 	 * The USB 2.0 spec calls this "global suspend".
+	 *
+	 * However, many USB hubs have a bug: They don't relay wakeup requests
+	 * from a downstream port if the port's suspend feature isn't on.
+	 * Therefore we will turn on the suspend feature if udev or any of its
+	 * descendants is enabled for remote wakeup.
 	 */
+	else if (PMSG_IS_AUTO(msg) || wakeup_enabled_descendants(udev) &gt; 0)
+		status = set_port_feature(hub-&gt;hdev, port1,
+				USB_PORT_FEAT_SUSPEND);
 	else {
 		really_suspend = false;
 		status = 0;
@@ -3003,15 +3018,16 @@ int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
 		if (!PMSG_IS_AUTO(msg))
 			status = 0;
 	} else {
-		/* device has up to 10 msec to fully suspend */
 		dev_dbg(&amp;udev-&gt;dev, "usb %ssuspend, wakeup %d\n",
 				(PMSG_IS_AUTO(msg) ? "auto-" : ""),
 				udev-&gt;do_remote_wakeup);
-		usb_set_device_state(udev, USB_STATE_SUSPENDED);
 		if (really_suspend) {
 			udev-&gt;port_is_suspended = 1;
+
+			/* device has up to 10 msec to fully suspend */
 			msleep(10);
 		}
+		usb_set_device_state(udev, USB_STATE_SUSPENDED);
 	}
 
 	/*
@@ -3293,7 +3309,11 @@ static int hub_suspend(struct usb_interface *intf, pm_message_t msg)
 	unsigned		port1;
 	int			status;
 
-	/* Warn if children aren't already suspended */
+	/*
+	 * Warn if children aren't already suspended.
+	 * Also, add up the number of wakeup-enabled descendants.
+	 */
+	hub-&gt;wakeup_enabled_descendants = 0;
 	for (port1 = 1; port1 &lt;= hdev-&gt;maxchild; port1++) {
 		struct usb_device	*udev;
 
@@ -3303,6 +3323,9 @@ static int hub_suspend(struct usb_interface *intf, pm_message_t msg)
 			if (PMSG_IS_AUTO(msg))
 				return -EBUSY;
 		}
+		if (udev)
+			hub-&gt;wakeup_enabled_descendants +=
+					wakeup_enabled_descendants(udev);
 	}
 
 	if (hdev-&gt;do_remote_wakeup &amp;&amp; hub-&gt;quirk_check_port_auto_suspend) {
diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index 6508e02b3dac..4e4790dea343 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -59,6 +59,9 @@ struct usb_hub {
 	struct usb_tt		tt;		/* Transaction Translator */
 
 	unsigned		mA_per_port;	/* current for each child */
+#ifdef	CONFIG_PM
+	unsigned		wakeup_enabled_descendants;
+#endif
 
 	unsigned		limited_power:1;
 	unsigned		quiescing:1;</pre><hr><pre>commit 36ff66db3fb5642906e46e73ca9cf92f1c5974ff
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jun 27 15:27:07 2013 -0400

    USB: move the definition of USB_MAXCHILDREN
    
    The USB_MAXCHILDREN symbol is used in include/uapi/linux/usb/ch11.h, a
    user-mode header, even though it is defined in include/linux/usb.h,
    which is kernel-only.  This causes compile-time errors when user
    programs try to #include linux/usb/ch11.h.
    
    This patch fixes the problem by moving the definition of USB_MAXCHILDREN
    into ch11.h.  It also gets rid of unneeded parentheses.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/include/linux/usb.h b/include/linux/usb.h
index a232b7ece1f6..0eec2689b955 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -367,17 +367,6 @@ struct usb_bus {
 
 /* ----------------------------------------------------------------------- */
 
-/* This is arbitrary.
- * From USB 2.0 spec Table 11-13, offset 7, a hub can
- * have up to 255 ports. The most yet reported is 10.
- *
- * Current Wireless USB host hardware (Intel i1480 for example) allows
- * up to 22 devices to connect. Upcoming hardware might raise that
- * limit. Because the arrays need to add a bit for hub status data, we
- * do 31, so plus one evens out to four bytes.
- */
-#define USB_MAXCHILDREN		(31)
-
 struct usb_tt;
 
 enum usb_device_removable {
diff --git a/include/uapi/linux/usb/ch11.h b/include/uapi/linux/usb/ch11.h
index 7692dc69ccf7..331499d597fa 100644
--- a/include/uapi/linux/usb/ch11.h
+++ b/include/uapi/linux/usb/ch11.h
@@ -11,6 +11,17 @@
 
 #include &lt;linux/types.h&gt;	/* __u8 etc */
 
+/* This is arbitrary.
+ * From USB 2.0 spec Table 11-13, offset 7, a hub can
+ * have up to 255 ports. The most yet reported is 10.
+ *
+ * Current Wireless USB host hardware (Intel i1480 for example) allows
+ * up to 22 devices to connect. Upcoming hardware might raise that
+ * limit. Because the arrays need to add a bit for hub status data, we
+ * use 31, so plus one evens out to four bytes.
+ */
+#define USB_MAXCHILDREN		31
+
 /*
  * Hub request types
  */</pre><hr><pre>commit 908b961326b2ecfbf494c9b2f206847d925f269d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jul 12 11:06:21 2013 -0400

    usb: gadget: don't fail when DMA isn't present
    
    When CONFIG_HAS_DMA isn't enabled, the UDC core gets build errors:
    
    drivers/built-in.o: In function `dma_set_coherent_mask':
    include/linux/dma-mapping.h:93: undefined reference to `dma_supported'
    include/linux/dma-mapping.h:93: undefined reference to `dma_supported'
    drivers/built-in.o: In function `usb_gadget_unmap_request':
    drivers/usb/gadget/udc-core.c:91: undefined reference to `dma_unmap_sg'
    drivers/usb/gadget/udc-core.c:96: undefined reference to `dma_unmap_single'
    drivers/built-in.o: In function `usb_gadget_map_request':
    drivers/usb/gadget/udc-core.c:62: undefined reference to `dma_map_sg'
    drivers/usb/gadget/udc-core.c:71: undefined reference to `dma_map_single'
    drivers/usb/gadget/udc-core.c:74: undefined reference to `dma_mapping_error'
    
    Prevent this by protecting the DMA API routines with preprocessor tests.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Geert Uytterhoeven &lt;geert@linux-m68k.org&gt;
    Acked-by: Alexander Shishkin &lt;alexander.shishkin@linux.intel.com&gt;
    Signed-off-by: Felipe Balbi &lt;balbi@ti.com&gt;

diff --git a/drivers/usb/gadget/udc-core.c b/drivers/usb/gadget/udc-core.c
index ffd8fa541101..c28ac9872030 100644
--- a/drivers/usb/gadget/udc-core.c
+++ b/drivers/usb/gadget/udc-core.c
@@ -50,6 +50,8 @@ static DEFINE_MUTEX(udc_lock);
 
 /* ------------------------------------------------------------------------- */
 
+#ifdef	CONFIG_HAS_DMA
+
 int usb_gadget_map_request(struct usb_gadget *gadget,
 		struct usb_request *req, int is_in)
 {
@@ -99,6 +101,8 @@ void usb_gadget_unmap_request(struct usb_gadget *gadget,
 }
 EXPORT_SYMBOL_GPL(usb_gadget_unmap_request);
 
+#endif	/* CONFIG_HAS_DMA */
+
 /* ------------------------------------------------------------------------- */
 
 void usb_gadget_set_state(struct usb_gadget *gadget,
@@ -194,9 +198,11 @@ int usb_add_gadget_udc_release(struct device *parent, struct usb_gadget *gadget,
 	dev_set_name(&amp;gadget-&gt;dev, "gadget");
 	gadget-&gt;dev.parent = parent;
 
+#ifdef	CONFIG_HAS_DMA
 	dma_set_coherent_mask(&amp;gadget-&gt;dev, parent-&gt;coherent_dma_mask);
 	gadget-&gt;dev.dma_parms = parent-&gt;dma_parms;
 	gadget-&gt;dev.dma_mask = parent-&gt;dma_mask;
+#endif
 
 	if (release)
 		gadget-&gt;dev.release = release;</pre><hr><pre>commit 43d51af489126305dbacc1b8ebd1ce4797d277ea
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jun 3 21:49:59 2013 +0200

    PM / Runtime: Update .runtime_idle() callback documentation
    
    Runtime PM documentation needs to be updated after the previous
    change of the rpm_idle() behavior, so modify it as appropriate.
    
    [rjw: Subject and changelog]
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Rafael J. Wysocki &lt;rafael.j.wysocki@intel.com&gt;

diff --git a/Documentation/power/runtime_pm.txt b/Documentation/power/runtime_pm.txt
index 6c470c71ba27..71d8fe4e75d3 100644
--- a/Documentation/power/runtime_pm.txt
+++ b/Documentation/power/runtime_pm.txt
@@ -144,8 +144,12 @@ The action performed by the idle callback is totally dependent on the subsystem
 (or driver) in question, but the expected and recommended action is to check
 if the device can be suspended (i.e. if all of the conditions necessary for
 suspending the device are satisfied) and to queue up a suspend request for the
-device in that case.  The value returned by this callback is ignored by the PM
-core.
+device in that case.  If there is no idle callback, or if the callback returns
+0, then the PM core will attempt to carry out a runtime suspend of the device;
+in essence, it will call pm_runtime_suspend() directly.  To prevent this (for
+example, if the callback routine has started a delayed suspend), the routine
+should return a non-zero value.  Negative error return codes are ignored by the
+PM core.
 
 The helper functions provided by the PM core, described in Section 4, guarantee
 that the following constraints are met with respect to runtime PM callbacks for
@@ -301,9 +305,10 @@ drivers/base/power/runtime.c and include/linux/pm_runtime.h:
       removing the device from device hierarchy
 
   int pm_runtime_idle(struct device *dev);
-    - execute the subsystem-level idle callback for the device; returns 0 on
-      success or error code on failure, where -EINPROGRESS means that
-      -&gt;runtime_idle() is already being executed
+    - execute the subsystem-level idle callback for the device; returns an
+      error code on failure, where -EINPROGRESS means that -&gt;runtime_idle() is
+      already being executed; if there is no callback or the callback returns 0
+      then run pm_runtime_suspend(dev) and return its result
 
   int pm_runtime_suspend(struct device *dev);
     - execute the subsystem-level suspend callback for the device; returns 0 on</pre><hr><pre>commit f467ff4c7dd736b4a3c7e715efed763c0b021838
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed May 29 13:19:10 2013 -0400

    USB: FHCI: upgrade the isochronous API
    
    This patch attempts to fix the isochronous API in the fhci-hcd
    driver.  There are two problems with the current code:
    
            ed-&gt;last_iso is used but not set anywhere.  The patch changes
            its name to ed-&gt;next_iso and uses it to store the frame number
            of the next available slot in the isochronous stream.
    
            urb-&gt;start_frame isn't set when the URB_ISO_ASAP flag is off.
            The patch sets it to the next available slot if the stream is
            in use, or the current frame otherwise.
    
    This won't give the right behavior when an underrun occurs, but I
    don't know enough about the driver to handle that case.
    
    Unfortunately, I don't have any way to test these changes.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Anton Vorontsov &lt;avorontsov@ru.mvista.com&gt;
    CC: Li Yang &lt;leoli@freescale.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/fhci-sched.c b/drivers/usb/host/fhci-sched.c
index 8f18538e0ff7..95ca5986e672 100644
--- a/drivers/usb/host/fhci-sched.c
+++ b/drivers/usb/host/fhci-sched.c
@@ -739,9 +739,13 @@ void fhci_queue_urb(struct fhci_hcd *fhci, struct urb *urb)
 	}
 
 	/* for ISO transfer calculate start frame index */
-	if (ed-&gt;mode == FHCI_TF_ISO &amp;&amp; urb-&gt;transfer_flags &amp; URB_ISO_ASAP)
-		urb-&gt;start_frame = ed-&gt;td_head ? ed-&gt;last_iso + 1 :
+	if (ed-&gt;mode == FHCI_TF_ISO) {
+		/* Ignore the possibility of underruns */
+		urb-&gt;start_frame = ed-&gt;td_head ? ed-&gt;next_iso :
 						 get_frame_num(fhci);
+		ed-&gt;next_iso = (urb-&gt;start_frame + urb-&gt;interval *
+				urb-&gt;number_of_packets) &amp; 0x07ff;
+	}
 
 	/*
 	 * OHCI handles the DATA toggle itself,we just use the USB
diff --git a/drivers/usb/host/fhci.h b/drivers/usb/host/fhci.h
index 7cc1c32dc36c..154e6a007727 100644
--- a/drivers/usb/host/fhci.h
+++ b/drivers/usb/host/fhci.h
@@ -338,7 +338,7 @@ struct ed {
 
 	/* read only parameters, should be cleared upon initialization */
 	u8 toggle_carry;	/* toggle carry from the last TD submitted */
-	u32 last_iso;		/* time stamp of last queued ISO transfer */
+	u16 next_iso;		/* time stamp of next queued ISO transfer */
 	struct td *td_head;	/* a pointer to the current TD handled */
 };
 </pre><hr><pre>commit 9db33f317432d1a9e22116092c6455ae71bf73fc
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed May 29 13:20:00 2013 -0400

    USB: IMX21: upgrade the isochronous API
    
    This patch attempts to update the imx21-hcd driver to the current
    standard for the isochronous API.  Firstly, urb-&gt;start_frame should
    always be set by the driver; it is not an input parameter.  Secondly,
    the URB_ISO_ASAP flag matters only when an URB is submitted to a
    stream that has gotten an underrun.  It causes the URB to be scheduled
    for the next available slot in the future, rather than the earliest
    unused (and expired) slot.
    
    Unfortunately, I don't have any way to test these changes.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Sascha Hauer &lt;kernel@pengutronix.de&gt;
    CC: Martin Fuzzey &lt;mfuzzey@gmail.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/imx21-hcd.c b/drivers/usb/host/imx21-hcd.c
index f0ebe8e7c58b..03dc4d9cbeca 100644
--- a/drivers/usb/host/imx21-hcd.c
+++ b/drivers/usb/host/imx21-hcd.c
@@ -809,26 +809,36 @@ static int imx21_hc_urb_enqueue_isoc(struct usb_hcd *hcd,
 
 	/* calculate frame */
 	cur_frame = imx21_hc_get_frame(hcd);
-	if (urb-&gt;transfer_flags &amp; URB_ISO_ASAP) {
-		if (list_empty(&amp;ep_priv-&gt;td_list))
-			urb-&gt;start_frame = cur_frame + 5;
-		else
-			urb-&gt;start_frame = list_entry(
-				ep_priv-&gt;td_list.prev,
-				struct td, list)-&gt;frame + urb-&gt;interval;
-	}
-	urb-&gt;start_frame = wrap_frame(urb-&gt;start_frame);
-	if (frame_after(cur_frame, urb-&gt;start_frame)) {
-		dev_dbg(imx21-&gt;dev,
-			"enqueue: adjusting iso start %d (cur=%d) asap=%d\n",
-			urb-&gt;start_frame, cur_frame,
-			(urb-&gt;transfer_flags &amp; URB_ISO_ASAP) != 0);
-		urb-&gt;start_frame = wrap_frame(cur_frame + 1);
+	i = 0;
+	if (list_empty(&amp;ep_priv-&gt;td_list)) {
+		urb-&gt;start_frame = wrap_frame(cur_frame + 5);
+	} else {
+		urb-&gt;start_frame = wrap_frame(list_entry(ep_priv-&gt;td_list.prev,
+				struct td, list)-&gt;frame + urb-&gt;interval);
+
+		if (frame_after(cur_frame, urb-&gt;start_frame)) {
+			dev_dbg(imx21-&gt;dev,
+				"enqueue: adjusting iso start %d (cur=%d) asap=%d\n",
+				urb-&gt;start_frame, cur_frame,
+				(urb-&gt;transfer_flags &amp; URB_ISO_ASAP) != 0);
+			i = DIV_ROUND_UP(wrap_frame(
+					cur_frame - urb-&gt;start_frame),
+					urb-&gt;interval);
+			if (urb-&gt;transfer_flags &amp; URB_ISO_ASAP) {
+				urb-&gt;start_frame = wrap_frame(urb-&gt;start_frame
+						+ i * urb-&gt;interval);
+				i = 0;
+			} else if (i &gt;= urb-&gt;number_of_packets) {
+				ret = -EXDEV;
+				goto alloc_dmem_failed;
+			}
+		}
 	}
 
 	/* set up transfers */
+	urb_priv-&gt;isoc_remaining = urb-&gt;number_of_packets - i;
 	td = urb_priv-&gt;isoc_td;
-	for (i = 0; i &lt; urb-&gt;number_of_packets; i++, td++) {
+	for (; i &lt; urb-&gt;number_of_packets; i++, td++) {
 		unsigned int offset = urb-&gt;iso_frame_desc[i].offset;
 		td-&gt;ep = ep;
 		td-&gt;urb = urb;
@@ -840,7 +850,6 @@ static int imx21_hc_urb_enqueue_isoc(struct usb_hcd *hcd,
 		list_add_tail(&amp;td-&gt;list, &amp;ep_priv-&gt;td_list);
 	}
 
-	urb_priv-&gt;isoc_remaining = urb-&gt;number_of_packets;
 	dev_vdbg(imx21-&gt;dev, "setup %d packets for iso frame %d-&gt;%d\n",
 		urb-&gt;number_of_packets, urb-&gt;start_frame, td-&gt;frame);
 </pre><hr><pre>commit 8a1ea51f87a6149c3263a63e9c60d852bedbecd7
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed May 29 13:21:01 2013 -0400

    USB: MUSB: upgrade the isochronous API
    
    This patch attempts to fix the isochonour API in the musb host
    driver.  In particular, the urb-&gt;start_frame field should always be
    set by the driver; it isn't an input parameter.
    
    The simplest way to accomplish this is to treat all URBs as though the
    URB_ISO_ASAP flag was set.  This won't give the right behavior when an
    underrun occurs, but I don't know enough about the musb driver to
    handle that case.
    
    Unfortunately, I have no way to test this change.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/musb/musb_host.c b/drivers/usb/musb/musb_host.c
index 8914dec49f01..85ed11e04f35 100644
--- a/drivers/usb/musb/musb_host.c
+++ b/drivers/usb/musb/musb_host.c
@@ -269,8 +269,7 @@ musb_start_urb(struct musb *musb, int is_in, struct musb_qh *qh)
 		/* FIXME this doesn't implement that scheduling policy ...
 		 * or handle framecounter wrapping
 		 */
-		if ((urb-&gt;transfer_flags &amp; URB_ISO_ASAP)
-				|| (frame &gt;= urb-&gt;start_frame)) {
+		if (1) {	/* Always assume URB_ISO_ASAP */
 			/* REVISIT the SOF irq handler shouldn't duplicate
 			 * this code; and we don't init urb-&gt;start_frame...
 			 */</pre><hr><pre>commit 077f5f1c23b3cf1134c031677497dfb6077e6bdd
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed May 29 11:33:52 2013 -0400

    USB: EHCI: fix regression related to qh_refresh()
    
    This patch adds some code that inadvertently got left out of commit
    c1fdb68e3d73741630ca16695cf9176c233be7ed (USB: EHCI: changes related
    to qh_refresh()).  The calls to qh_refresh() and qh_link_periodic()
    were taken out of qh_schedule(); therefore it is necessary to call
    these routines manually after calling qh_schedule().
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Oleksij Rempel &lt;linux@rempel-privat.de&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index f3c1028a54fc..f80d0330d548 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -646,6 +646,10 @@ static void end_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh)
 	/* reschedule QH iff another request is queued */
 	if (!list_empty(&amp;qh-&gt;qtd_list) &amp;&amp; ehci-&gt;rh_state == EHCI_RH_RUNNING) {
 		rc = qh_schedule(ehci, qh);
+		if (rc == 0) {
+			qh_refresh(ehci, qh);
+			qh_link_periodic(ehci, qh);
+		}
 
 		/* An error here likely indicates handshake failure
 		 * or no space left in the schedule.  Neither fault
@@ -653,9 +657,10 @@ static void end_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh)
 		 *
 		 * FIXME kill the now-dysfunctional queued urbs
 		 */
-		if (rc != 0)
+		else {
 			ehci_err(ehci, "can't reschedule qh %p, err %d\n",
 					qh, rc);
+		}
 	}
 
 	/* maybe turn off periodic schedule */</pre>
    <div class="pagination">
        <a href='2_34.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><span>[35]</span><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_36.html'>Next&gt;&gt;</a>
    <div>
</body>
