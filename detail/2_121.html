<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_120.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><span>[121]</span><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_122.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 114b368c07964caa3f4e1fa575b16e87fa11936c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Jul 1 22:13:04 2006 -0400

    usbcore: fix up device and power state tests
    
    This patch (as734) rationalizes the various tests of device state and
    power states.  There are duplications and mistaken tests in several
    places.
    
    Perhaps the most interesting challenge is where the hub driver tests to
    see that all the child devices are suspended before allowing itself to
    be suspended.  When CONFIG_USB_SUSPEND is set the test is
    straightforward, since we expect that the children _will_ be suspended.
    But when CONFIG_USB_SUSPEND isn't set, it's not so clear what should be
    done.  The code compromises by checking the child's
    power.power_state.event field.
    
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 92ecc4eb1e88..affbfb53eb5e 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -757,11 +757,13 @@ static int suspend_device(struct usb_device *udev, pm_message_t msg)
 	struct usb_device_driver	*udriver;
 	int				status = 0;
 
+	if (udev-&gt;state == USB_STATE_NOTATTACHED ||
+			udev-&gt;state == USB_STATE_SUSPENDED)
+		goto done;
+
 	if (udev-&gt;dev.driver == NULL)
 		goto done;
 	udriver = to_usb_device_driver(udev-&gt;dev.driver);
-	if (udev-&gt;dev.power.power_state.event == msg.event)
-		goto done;
 	status = udriver-&gt;suspend(udev, msg);
 
 done:
@@ -776,14 +778,13 @@ static int resume_device(struct usb_device *udev)
 	struct usb_device_driver	*udriver;
 	int				status = 0;
 
-	if (udev-&gt;dev.power.power_state.event == PM_EVENT_ON)
+	if (udev-&gt;state == USB_STATE_NOTATTACHED ||
+			udev-&gt;state != USB_STATE_SUSPENDED)
 		goto done;
 
 	if (udev-&gt;dev.driver == NULL)
 		goto done;
 	udriver = to_usb_device_driver(udev-&gt;dev.driver);
-	if (udev-&gt;state == USB_STATE_NOTATTACHED)
-		goto done;
 	status = udriver-&gt;resume(udev);
 
 done:
@@ -798,14 +799,14 @@ static int suspend_interface(struct usb_interface *intf, pm_message_t msg)
 	struct usb_driver	*driver;
 	int			status = 0;
 
-	if (intf-&gt;dev.driver == NULL)
+	/* with no hardware, USB interfaces only use FREEZE and ON states */
+	if (interface_to_usbdev(intf)-&gt;state == USB_STATE_NOTATTACHED ||
+			!is_active(intf))
 		goto done;
 
-	driver = to_usb_driver(intf-&gt;dev.driver);
-
-	/* with no hardware, USB interfaces only use FREEZE and ON states */
-	if (!is_active(intf))
+	if (intf-&gt;dev.driver == NULL)
 		goto done;
+	driver = to_usb_driver(intf-&gt;dev.driver);
 
 	if (driver-&gt;suspend &amp;&amp; driver-&gt;resume) {
 		status = driver-&gt;suspend(intf, msg);
@@ -831,25 +832,16 @@ static int suspend_interface(struct usb_interface *intf, pm_message_t msg)
 static int resume_interface(struct usb_interface *intf)
 {
 	struct usb_driver	*driver;
-	struct usb_device	*udev;
 	int			status = 0;
 
-	if (intf-&gt;dev.power.power_state.event == PM_EVENT_ON)
+	if (interface_to_usbdev(intf)-&gt;state == USB_STATE_NOTATTACHED ||
+			is_active(intf))
 		goto done;
 
 	if (intf-&gt;dev.driver == NULL)
 		goto done;
-
 	driver = to_usb_driver(intf-&gt;dev.driver);
 
-	udev = interface_to_usbdev(intf);
-	if (udev-&gt;state == USB_STATE_NOTATTACHED)
-		goto done;
-
-	/* if driver was suspended, it has a resume method;
-	 * however, sysfs can wrongly mark things as suspended
-	 * (on the "no suspend method" FIXME path above)
-	 */
 	if (driver-&gt;resume) {
 		status = driver-&gt;resume(intf);
 		if (status)
@@ -904,6 +896,12 @@ int usb_resume_both(struct usb_device *udev)
 	int			i;
 	struct usb_interface	*intf;
 
+	/* Can't resume if the parent is suspended */
+	if (udev-&gt;parent &amp;&amp; udev-&gt;parent-&gt;state == USB_STATE_SUSPENDED) {
+		dev_warn(&amp;udev-&gt;dev, "can't resume; parent is suspended\n");
+		return -EHOSTUNREACH;
+	}
+
 	status = resume_device(udev);
 	if (status == 0 &amp;&amp; udev-&gt;actconfig) {
 		for (i = 0; i &lt; udev-&gt;actconfig-&gt;desc.bNumInterfaces; i++) {
diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index b6dacd7551d2..5358e656477c 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -195,9 +195,6 @@ static int generic_suspend(struct usb_device *udev, pm_message_t msg)
 
 static int generic_resume(struct usb_device *udev)
 {
-	if (udev-&gt;state == USB_STATE_NOTATTACHED)
-		return 0;
-
 	return usb_port_resume(udev);
 }
 
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 7af53db4d76f..a310c7cede99 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1556,26 +1556,6 @@ static int __usb_port_suspend (struct usb_device *udev, int port1)
 	if (port1 &lt; 0)
 		return port1;
 
-	if (udev-&gt;state == USB_STATE_SUSPENDED
-			|| udev-&gt;state == USB_STATE_NOTATTACHED) {
-		return 0;
-	}
-
-	/* all interfaces must already be suspended */
-	if (udev-&gt;actconfig) {
-		int	i;
-
-		for (i = 0; i &lt; udev-&gt;actconfig-&gt;desc.bNumInterfaces; i++) {
-			struct usb_interface	*intf;
-
-			intf = udev-&gt;actconfig-&gt;interface[i];
-			if (is_active(intf)) {
-				dev_dbg(&amp;intf-&gt;dev, "nyet suspended\n");
-				return -EBUSY;
-			}
-		}
-	}
-
 	/* we change the device's upstream USB link,
 	 * but root hubs have no upstream USB link.
 	 */
@@ -1614,8 +1594,6 @@ static int __usb_port_suspend (struct usb_device *udev, int port1)
 int usb_port_suspend(struct usb_device *udev)
 {
 #ifdef	CONFIG_USB_SUSPEND
-	if (udev-&gt;state == USB_STATE_NOTATTACHED)
-		return -ENODEV;
 	return __usb_port_suspend(udev, udev-&gt;portnum);
 #else
 	return 0;
@@ -1761,24 +1739,17 @@ hub_port_resume(struct usb_hub *hub, int port1, struct usb_device *udev)
  */
 int usb_port_resume(struct usb_device *udev)
 {
-	int	status;
-
-	if (udev-&gt;state == USB_STATE_NOTATTACHED)
-		return -ENODEV;
+	int	status = 0;
 
 	/* we change the device's upstream USB link,
 	 * but root hubs have no upstream USB link.
 	 */
 	if (udev-&gt;parent) {
 #ifdef	CONFIG_USB_SUSPEND
-		if (udev-&gt;state == USB_STATE_SUSPENDED) {
-			// NOTE swsusp may bork us, device state being wrong...
-			// NOTE this fails if parent is also suspended...
-			status = hub_port_resume(hdev_to_hub(udev-&gt;parent),
-					udev-&gt;portnum, udev);
-		} else
+		// NOTE this fails if parent is also suspended...
+		status = hub_port_resume(hdev_to_hub(udev-&gt;parent),
+				udev-&gt;portnum, udev);
 #endif
-			status = 0;
 	} else
 		status = finish_port_resume(udev);
 	if (status &lt; 0)
@@ -1821,12 +1792,14 @@ static int hub_suspend(struct usb_interface *intf, pm_message_t msg)
 		struct usb_device	*udev;
 
 		udev = hdev-&gt;children [port1-1];
-		if (udev &amp;&amp; (udev-&gt;dev.power.power_state.event
-					== PM_EVENT_ON
+		if (udev &amp;&amp; msg.event == PM_EVENT_SUSPEND &amp;&amp;
 #ifdef	CONFIG_USB_SUSPEND
-				|| udev-&gt;state != USB_STATE_SUSPENDED
+				udev-&gt;state != USB_STATE_SUSPENDED
+#else
+				udev-&gt;dev.power.power_state.event
+					== PM_EVENT_ON
 #endif
-				)) {
+				) {
 			dev_dbg(&amp;intf-&gt;dev, "port %d nyet suspended\n", port1);
 			return -EBUSY;
 		}</pre><hr><pre>commit 2bf4086d7a7722b470aa24e1be725cc58619c6fe
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Jul 1 22:12:19 2006 -0400

    usbcore: set device and power states properly
    
    This patch (as733) fixes up the places where device states and power
    states are set in usbcore.  Right now things are duplicated or missing;
    this should straighten things out.
    
    The idea is that udev-&gt;state is USB_STATE_SUSPENDED exactly when the
    device's upstream port has been suspended, whereas
    udev-&gt;dev.power.power_state.event reflects the result of the last call
    to the suspend/resume routines (which might not actually change the
    device state, especially if CONFIG_USB_SUSPEND isn't set).
    
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index eefc98584eac..92ecc4eb1e88 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -755,48 +755,57 @@ EXPORT_SYMBOL_GPL_FUTURE(usb_deregister);
 static int suspend_device(struct usb_device *udev, pm_message_t msg)
 {
 	struct usb_device_driver	*udriver;
+	int				status = 0;
 
 	if (udev-&gt;dev.driver == NULL)
-		return 0;
+		goto done;
 	udriver = to_usb_device_driver(udev-&gt;dev.driver);
 	if (udev-&gt;dev.power.power_state.event == msg.event)
-		return 0;
-	return udriver-&gt;suspend(udev, msg);
+		goto done;
+	status = udriver-&gt;suspend(udev, msg);
+
+done:
+	if (status == 0)
+		udev-&gt;dev.power.power_state.event = msg.event;
+	return status;
 }
 
 /* Caller has locked udev */
 static int resume_device(struct usb_device *udev)
 {
 	struct usb_device_driver	*udriver;
+	int				status = 0;
 
 	if (udev-&gt;dev.power.power_state.event == PM_EVENT_ON)
-		return 0;
-
-	/* mark things as "on" immediately, no matter what errors crop up */
-	udev-&gt;dev.power.power_state.event = PM_EVENT_ON;
+		goto done;
 
 	if (udev-&gt;dev.driver == NULL)
-		return 0;
+		goto done;
 	udriver = to_usb_device_driver(udev-&gt;dev.driver);
 	if (udev-&gt;state == USB_STATE_NOTATTACHED)
-		return 0;
-	return udriver-&gt;resume(udev);
+		goto done;
+	status = udriver-&gt;resume(udev);
+
+done:
+	if (status == 0)
+		udev-&gt;dev.power.power_state.event = PM_EVENT_ON;
+	return status;
 }
 
 /* Caller has locked intf's usb_device */
 static int suspend_interface(struct usb_interface *intf, pm_message_t msg)
 {
 	struct usb_driver	*driver;
-	int			status;
+	int			status = 0;
 
 	if (intf-&gt;dev.driver == NULL)
-		return 0;
+		goto done;
 
 	driver = to_usb_driver(intf-&gt;dev.driver);
 
 	/* with no hardware, USB interfaces only use FREEZE and ON states */
 	if (!is_active(intf))
-		return 0;
+		goto done;
 
 	if (driver-&gt;suspend &amp;&amp; driver-&gt;resume) {
 		status = driver-&gt;suspend(intf, msg);
@@ -810,8 +819,11 @@ static int suspend_interface(struct usb_interface *intf, pm_message_t msg)
 		dev_warn(&amp;intf-&gt;dev, "no suspend for driver %s?\n",
 				driver-&gt;name);
 		mark_quiesced(intf);
-		status = 0;
 	}
+
+done:
+	if (status == 0)
+		intf-&gt;dev.power.power_state.event = msg.event;
 	return status;
 }
 
@@ -820,24 +832,19 @@ static int resume_interface(struct usb_interface *intf)
 {
 	struct usb_driver	*driver;
 	struct usb_device	*udev;
-	int			status;
+	int			status = 0;
 
 	if (intf-&gt;dev.power.power_state.event == PM_EVENT_ON)
-		return 0;
-
-	/* mark things as "on" immediately, no matter what errors crop up */
-	intf-&gt;dev.power.power_state.event = PM_EVENT_ON;
+		goto done;
 
-	if (intf-&gt;dev.driver == NULL) {
-		intf-&gt;dev.power.power_state.event = PM_EVENT_FREEZE;
-		return 0;
-	}
+	if (intf-&gt;dev.driver == NULL)
+		goto done;
 
 	driver = to_usb_driver(intf-&gt;dev.driver);
 
 	udev = interface_to_usbdev(intf);
 	if (udev-&gt;state == USB_STATE_NOTATTACHED)
-		return 0;
+		goto done;
 
 	/* if driver was suspended, it has a resume method;
 	 * however, sysfs can wrongly mark things as suspended
@@ -845,15 +852,21 @@ static int resume_interface(struct usb_interface *intf)
 	 */
 	if (driver-&gt;resume) {
 		status = driver-&gt;resume(intf);
-		if (status) {
+		if (status)
 			dev_err(&amp;intf-&gt;dev, "%s error %d\n",
 					"resume", status);
-			mark_quiesced(intf);
-		}
-	} else
+		else
+			mark_active(intf);
+	} else {
 		dev_warn(&amp;intf-&gt;dev, "no resume for driver %s?\n",
 				driver-&gt;name);
-	return 0;
+		mark_active(intf);
+	}
+
+done:
+	if (status == 0)
+		intf-&gt;dev.power.power_state.event = PM_EVENT_ON;
+	return status;
 }
 
 /* Caller has locked udev */
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index a39112041e69..7af53db4d76f 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1582,9 +1582,10 @@ static int __usb_port_suspend (struct usb_device *udev, int port1)
 	if (udev-&gt;parent)
 		status = hub_port_suspend(hdev_to_hub(udev-&gt;parent), port1,
 				udev);
-
-	if (status == 0)
-		udev-&gt;dev.power.power_state = PMSG_SUSPEND;
+	else {
+		dev_dbg(&amp;udev-&gt;dev, "usb suspend\n");
+		usb_set_device_state(udev, USB_STATE_SUSPENDED);
+	}
 	return status;
 }
 
@@ -1617,8 +1618,6 @@ int usb_port_suspend(struct usb_device *udev)
 		return -ENODEV;
 	return __usb_port_suspend(udev, udev-&gt;portnum);
 #else
-	/* NOTE:  udev-&gt;state unchanged, it's not lying ... */
-	udev-&gt;dev.power.power_state = PMSG_SUSPEND;
 	return 0;
 #endif
 }
@@ -1647,7 +1646,6 @@ static int finish_port_resume(struct usb_device *udev)
 	usb_set_device_state(udev, udev-&gt;actconfig
 			? USB_STATE_CONFIGURED
 			: USB_STATE_ADDRESS);
-	udev-&gt;dev.power.power_state = PMSG_ON;
 
  	/* 10.5.4.5 says be sure devices in the tree are still there.
  	 * For now let's assume the device didn't go crazy on resume,</pre><hr><pre>commit 4d064c080265a41324d108fccc26b72106d43db3
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Jul 1 22:11:44 2006 -0400

    usbcore: track whether interfaces are suspended
    
    Currently we rely on intf-&gt;dev.power.power_state.event for tracking
    whether intf is suspended.  This is not a reliable technique because
    that value is owned by the PM core, not by usbcore.  This patch (as718b)
    adds a new flag so that we can accurately tell which interfaces are
    suspended and which aren't.
    
    At first one might think these flags aren't needed, since interfaces
    will be suspended along with their devices.  It turns out there are a
    couple of intermediate situations where that's not quite true, such as
    while processing a remote-wakeup request.
    
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index cc42972b6bb0..74df0db954c9 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -59,17 +59,17 @@ static inline int is_usb_device_driver(struct device_driver *drv)
 
 static inline void mark_active(struct usb_interface *f)
 {
-	f-&gt;dev.power.power_state.event = PM_EVENT_ON;
+	f-&gt;is_active = 1;
 }
 
 static inline void mark_quiesced(struct usb_interface *f)
 {
-	f-&gt;dev.power.power_state.event = PM_EVENT_FREEZE;
+	f-&gt;is_active = 0;
 }
 
 static inline int is_active(struct usb_interface *f)
 {
-	return f-&gt;dev.power.power_state.event == PM_EVENT_ON;
+	return f-&gt;is_active;
 }
 
 
diff --git a/include/linux/usb.h b/include/linux/usb.h
index b4ccce6d0982..e22f4b386605 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -102,6 +102,7 @@ enum usb_interface_condition {
  *	number from the USB core by calling usb_register_dev().
  * @condition: binding state of the interface: not bound, binding
  *	(in probe()), bound to a driver, or unbinding (in disconnect())
+ * @is_active: flag set when the interface is bound and not suspended.
  * @dev: driver model's view of this device
  * @class_dev: driver model's class view of this device.
  *
@@ -142,6 +143,8 @@ struct usb_interface {
 	int minor;			/* minor number this interface is
 					 * bound to */
 	enum usb_interface_condition condition;		/* state of binding */
+	unsigned is_active:1;		/* the interface is not suspended */
+
 	struct device dev;		/* interface specific device info */
 	struct class_device *class_dev;
 };</pre><hr><pre>commit a8e7c5653562f88c0f5f53eac0a890c012655789
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Jul 1 22:11:02 2006 -0400

    usbcore: resume device resume recursion
    
    This patch (as717b) removes the existing recursion in hub resume code:
    Resuming a hub will no longer automatically resume the devices attached
    to the hub.
    
    At the same time, it adds one level of recursion: Suspending a USB
    device will automatically suspend all the device's interfaces.  Failure
    at an intermediate stage will cause all the already-suspended interfaces
    to be resumed. Attempts to suspend or resume an interface by itself will
    do nothing, although they won't return an error.  Thus the regular
    system-suspend and system-resume procedures should continue to work as
    before; only runtime PM will be affected.
    
    The patch also removes the code that tests state of the interfaces
    before suspending a device.  It's no longer needed, since everything
    gets suspended together.
    
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index b0db1583c522..eefc98584eac 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -783,7 +783,7 @@ static int resume_device(struct usb_device *udev)
 	return udriver-&gt;resume(udev);
 }
 
-/* Caller has locked intf */
+/* Caller has locked intf's usb_device */
 static int suspend_interface(struct usb_interface *intf, pm_message_t msg)
 {
 	struct usb_driver	*driver;
@@ -815,7 +815,7 @@ static int suspend_interface(struct usb_interface *intf, pm_message_t msg)
 	return status;
 }
 
-/* Caller has locked intf */
+/* Caller has locked intf's usb_device */
 static int resume_interface(struct usb_interface *intf)
 {
 	struct usb_driver	*driver;
@@ -856,14 +856,59 @@ static int resume_interface(struct usb_interface *intf)
 	return 0;
 }
 
+/* Caller has locked udev */
+int usb_suspend_both(struct usb_device *udev, pm_message_t msg)
+{
+	int			status = 0;
+	int			i = 0;
+	struct usb_interface	*intf;
+
+	if (udev-&gt;actconfig) {
+		for (; i &lt; udev-&gt;actconfig-&gt;desc.bNumInterfaces; i++) {
+			intf = udev-&gt;actconfig-&gt;interface[i];
+			status = suspend_interface(intf, msg);
+			if (status != 0)
+				break;
+		}
+	}
+	if (status == 0)
+		status = suspend_device(udev, msg);
+
+	/* If the suspend failed, resume interfaces that did get suspended */
+	if (status != 0) {
+		while (--i &gt;= 0) {
+			intf = udev-&gt;actconfig-&gt;interface[i];
+			resume_interface(intf);
+		}
+	}
+	return status;
+}
+
+/* Caller has locked udev */
+int usb_resume_both(struct usb_device *udev)
+{
+	int			status;
+	int			i;
+	struct usb_interface	*intf;
+
+	status = resume_device(udev);
+	if (status == 0 &amp;&amp; udev-&gt;actconfig) {
+		for (i = 0; i &lt; udev-&gt;actconfig-&gt;desc.bNumInterfaces; i++) {
+			intf = udev-&gt;actconfig-&gt;interface[i];
+			resume_interface(intf);
+		}
+	}
+	return status;
+}
+
 static int usb_suspend(struct device *dev, pm_message_t message)
 {
 	int	status;
 
 	if (is_usb_device(dev))
-		status = suspend_device(to_usb_device(dev), message);
+		status = usb_suspend_both(to_usb_device(dev), message);
 	else
-		status = suspend_interface(to_usb_interface(dev), message);
+		status = 0;
 	return status;
 }
 
@@ -871,10 +916,12 @@ static int usb_resume(struct device *dev)
 {
 	int	status;
 
-	if (is_usb_device(dev))
-		status = resume_device(to_usb_device(dev));
-	else
-		status = resume_interface(to_usb_interface(dev));
+	if (is_usb_device(dev)) {
+		status = usb_resume_both(to_usb_device(dev));
+
+		/* Rebind drivers that had no suspend method? */
+	} else
+		status = 0;
 	return status;
 }
 
diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index 1522195de715..b6dacd7551d2 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -184,22 +184,8 @@ static void generic_disconnect(struct usb_device *udev)
 
 #ifdef	CONFIG_PM
 
-static int verify_suspended(struct device *dev, void *unused)
-{
-	if (dev-&gt;driver == NULL)
-		return 0;
-	return (dev-&gt;power.power_state.event == PM_EVENT_ON) ? -EBUSY : 0;
-}
-
 static int generic_suspend(struct usb_device *udev, pm_message_t msg)
 {
-	int	status;
-
-	/* rule out bogus requests through sysfs */
-	status = device_for_each_child(&amp;udev-&gt;dev, NULL, verify_suspended);
-	if (status)
-		return status;
-
 	/* USB devices enter SUSPEND state through their hubs, but can be
 	 * marked for FREEZE as soon as their children are already idled.
 	 * But those semantics are useless, so we equate the two (sigh).
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index a372332440b2..a39112041e69 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1662,9 +1662,6 @@ static int finish_port_resume(struct usb_device *udev)
 			"gone after usb resume? status %d\n",
 			status);
 	else if (udev-&gt;actconfig) {
-		unsigned	i;
-		int		(*resume)(struct device *);
-
 		le16_to_cpus(&amp;devstatus);
 		if ((devstatus &amp; (1 &lt;&lt; USB_DEVICE_REMOTE_WAKEUP))
 				&amp;&amp; udev-&gt;parent) {
@@ -1675,24 +1672,9 @@ static int finish_port_resume(struct usb_device *udev)
 					USB_DEVICE_REMOTE_WAKEUP, 0,
 					NULL, 0,
 					USB_CTRL_SET_TIMEOUT);
-			if (status) {
+			if (status)
 				dev_dbg(&amp;udev-&gt;dev, "disable remote "
 					"wakeup, status %d\n", status);
-				status = 0;
-			}
-		}
-
-		/* resume interface drivers; if this is a hub, it
-		 * may have a child resume event to deal with soon
-		 */
-		resume = udev-&gt;dev.bus-&gt;resume;
-		for (i = 0; i &lt; udev-&gt;actconfig-&gt;desc.bNumInterfaces; i++) {
-			struct device *dev =
-					&amp;udev-&gt;actconfig-&gt;interface[i]-&gt;dev;
-
-			down(&amp;dev-&gt;sem);
-			(void) resume(dev);
-			up(&amp;dev-&gt;sem);
 		}
 		status = 0;
 
@@ -1802,15 +1784,7 @@ int usb_port_resume(struct usb_device *udev)
 	} else
 		status = finish_port_resume(udev);
 	if (status &lt; 0)
-		dev_dbg(&amp;udev-&gt;dev, "can't resume, status %d\n",
-			status);
-
-	/* rebind drivers that had no suspend() */
-	if (status == 0) {
-		usb_unlock_device(udev);
-		bus_rescan_devices(&amp;usb_bus_type);
-		usb_lock_device(udev);
-	}
+		dev_dbg(&amp;udev-&gt;dev, "can't resume, status %d\n", status);
 	return status;
 }
 
@@ -1830,6 +1804,9 @@ static int remote_wakeup(struct usb_device *udev)
 		msleep(10);
 		status = finish_port_resume(udev);
 	}
+
+	if (status == 0)
+		usb_resume_both(udev);
 	usb_unlock_device(udev);
 #endif
 	return status;
@@ -1901,51 +1878,8 @@ static int hub_resume(struct usb_interface *intf)
 		}
 	}
 
+	/* tell khubd to look for changes on this hub */
 	hub_activate(hub);
-
-	/* REVISIT:  this recursion probably shouldn't exist.  Remove
-	 * this code sometime, after retesting with different root and
-	 * external hubs.
-	 */
-#ifdef	CONFIG_USB_SUSPEND
-	{
-	unsigned		port1;
-
-	for (port1 = 1; port1 &lt;= hdev-&gt;maxchild; port1++) {
-		struct usb_device	*udev;
-		u16			portstat, portchange;
-
-		udev = hdev-&gt;children [port1-1];
-		status = hub_port_status(hub, port1, &amp;portstat, &amp;portchange);
-		if (status == 0) {
-			if (portchange &amp; USB_PORT_STAT_C_SUSPEND) {
-				clear_port_feature(hdev, port1,
-					USB_PORT_FEAT_C_SUSPEND);
-				portchange &amp;= ~USB_PORT_STAT_C_SUSPEND;
-			}
-
-			/* let khubd handle disconnects etc */
-			if (portchange)
-				continue;
-		}
-
-		if (!udev || status &lt; 0)
-			continue;
-		usb_lock_device(udev);
-		if (portstat &amp; USB_PORT_STAT_SUSPEND)
-			status = hub_port_resume(hub, port1, udev);
-		else {
-			status = finish_port_resume(udev);
-			if (status &lt; 0) {
-				dev_dbg(&amp;intf-&gt;dev, "resume port %d --&gt; %d\n",
-					port1, status);
-				hub_port_logical_disconnect(hub, port1);
-			}
-		}
-		usb_unlock_device(udev);
-	}
-	}
-#endif
 	return 0;
 }
 
@@ -2602,17 +2536,6 @@ static void hub_events(void)
 		usb_get_intf(intf);
 		spin_unlock_irq(&amp;hub_event_lock);
 
-		/* Is this is a root hub wanting to reactivate the downstream
-		 * ports?  If so, be sure the interface resumes even if its
-		 * stub "device" node was never suspended.
-		 */
-		if (i) {
-			dpm_runtime_resume(&amp;hdev-&gt;dev);
-			dpm_runtime_resume(&amp;intf-&gt;dev);
-			usb_put_intf(intf);
-			continue;
-		}
-
 		/* Lock the device, then check to see if we were
 		 * disconnected while waiting for the lock to succeed. */
 		if (locktree(hdev) &lt; 0) {
@@ -2629,6 +2552,13 @@ static void hub_events(void)
 			goto loop;
 		}
 
+		/* Is this is a root hub wanting to reactivate the downstream
+		 * ports?  If so, be sure the interface resumes even if its
+		 * stub "device" node was never suspended.
+		 */
+		if (i)
+			usb_resume_both(hdev);
+
 		/* If this is an inactive or suspended hub, do nothing */
 		if (hub-&gt;quiescing)
 			goto loop;
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 1d25ccac7832..cc42972b6bb0 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -30,6 +30,8 @@ extern void usb_major_cleanup(void);
 extern int usb_host_init(void);
 extern void usb_host_cleanup(void);
 
+extern int usb_suspend_both(struct usb_device *udev, pm_message_t msg);
+extern int usb_resume_both(struct usb_device *udev);
 extern int usb_port_suspend(struct usb_device *dev);
 extern int usb_port_resume(struct usb_device *dev);
 </pre><hr><pre>commit 1cc8a25d5b680ff656927ffa9b66fae6b415b1d3
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Jul 1 22:10:15 2006 -0400

    usbcore: split suspend/resume for device and interfaces
    
    This patch (as716b) splits up the core suspend and resume routines into
    two parts each: one for handling devices and one for handling
    interfaces.  The behavior of the parts should be the same as in the old
    unified code.
    
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index a62de0a85406..b0db1583c522 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -751,81 +751,89 @@ EXPORT_SYMBOL_GPL_FUTURE(usb_deregister);
 
 #ifdef CONFIG_PM
 
-static int usb_suspend(struct device *dev, pm_message_t message)
+/* Caller has locked udev */
+static int suspend_device(struct usb_device *udev, pm_message_t msg)
 {
-	struct usb_device		*udev;
 	struct usb_device_driver	*udriver;
-	struct usb_interface		*intf;
-	struct usb_driver		*driver;
-	int				status;
 
-	if (is_usb_device(dev)) {
-		if (dev-&gt;driver == NULL)
-			return 0;
-		udev = to_usb_device(dev);
-		udriver = to_usb_device_driver(dev-&gt;driver);
-		if (dev-&gt;power.power_state.event == message.event)
-			return 0;
-		return udriver-&gt;suspend(udev, message);
-	}
+	if (udev-&gt;dev.driver == NULL)
+		return 0;
+	udriver = to_usb_device_driver(udev-&gt;dev.driver);
+	if (udev-&gt;dev.power.power_state.event == msg.event)
+		return 0;
+	return udriver-&gt;suspend(udev, msg);
+}
+
+/* Caller has locked udev */
+static int resume_device(struct usb_device *udev)
+{
+	struct usb_device_driver	*udriver;
 
-	if (dev-&gt;driver == NULL)
+	if (udev-&gt;dev.power.power_state.event == PM_EVENT_ON)
 		return 0;
 
-	intf = to_usb_interface(dev);
-	driver = to_usb_driver(dev-&gt;driver);
+	/* mark things as "on" immediately, no matter what errors crop up */
+	udev-&gt;dev.power.power_state.event = PM_EVENT_ON;
+
+	if (udev-&gt;dev.driver == NULL)
+		return 0;
+	udriver = to_usb_device_driver(udev-&gt;dev.driver);
+	if (udev-&gt;state == USB_STATE_NOTATTACHED)
+		return 0;
+	return udriver-&gt;resume(udev);
+}
+
+/* Caller has locked intf */
+static int suspend_interface(struct usb_interface *intf, pm_message_t msg)
+{
+	struct usb_driver	*driver;
+	int			status;
+
+	if (intf-&gt;dev.driver == NULL)
+		return 0;
+
+	driver = to_usb_driver(intf-&gt;dev.driver);
 
 	/* with no hardware, USB interfaces only use FREEZE and ON states */
 	if (!is_active(intf))
 		return 0;
 
 	if (driver-&gt;suspend &amp;&amp; driver-&gt;resume) {
-		status = driver-&gt;suspend(intf, message);
+		status = driver-&gt;suspend(intf, msg);
 		if (status)
-			dev_err(dev, "%s error %d\n", "suspend", status);
+			dev_err(&amp;intf-&gt;dev, "%s error %d\n",
+					"suspend", status);
 		else
 			mark_quiesced(intf);
 	} else {
 		// FIXME else if there's no suspend method, disconnect...
-		dev_warn(dev, "no suspend for driver %s?\n", driver-&gt;name);
+		dev_warn(&amp;intf-&gt;dev, "no suspend for driver %s?\n",
+				driver-&gt;name);
 		mark_quiesced(intf);
 		status = 0;
 	}
 	return status;
 }
 
-static int usb_resume(struct device *dev)
+/* Caller has locked intf */
+static int resume_interface(struct usb_interface *intf)
 {
-	struct usb_device		*udev;
-	struct usb_device_driver	*udriver;
-	struct usb_interface		*intf;
-	struct usb_driver		*driver;
-	int				status;
+	struct usb_driver	*driver;
+	struct usb_device	*udev;
+	int			status;
 
-	if (dev-&gt;power.power_state.event == PM_EVENT_ON)
+	if (intf-&gt;dev.power.power_state.event == PM_EVENT_ON)
 		return 0;
 
 	/* mark things as "on" immediately, no matter what errors crop up */
-	dev-&gt;power.power_state.event = PM_EVENT_ON;
+	intf-&gt;dev.power.power_state.event = PM_EVENT_ON;
 
-	/* devices resume through their hubs */
-	if (is_usb_device(dev)) {
-		if (dev-&gt;driver == NULL)
-			return 0;
-		udev = to_usb_device(dev);
-		udriver = to_usb_device_driver(dev-&gt;driver);
-		if (udev-&gt;state == USB_STATE_NOTATTACHED)
-			return 0;
-		return udriver-&gt;resume(udev);
-	}
-
-	if (dev-&gt;driver == NULL) {
-		dev-&gt;power.power_state.event = PM_EVENT_FREEZE;
+	if (intf-&gt;dev.driver == NULL) {
+		intf-&gt;dev.power.power_state.event = PM_EVENT_FREEZE;
 		return 0;
 	}
 
-	intf = to_usb_interface(dev);
-	driver = to_usb_driver(dev-&gt;driver);
+	driver = to_usb_driver(intf-&gt;dev.driver);
 
 	udev = interface_to_usbdev(intf);
 	if (udev-&gt;state == USB_STATE_NOTATTACHED)
@@ -838,14 +846,38 @@ static int usb_resume(struct device *dev)
 	if (driver-&gt;resume) {
 		status = driver-&gt;resume(intf);
 		if (status) {
-			dev_err(dev, "%s error %d\n", "resume", status);
+			dev_err(&amp;intf-&gt;dev, "%s error %d\n",
+					"resume", status);
 			mark_quiesced(intf);
 		}
 	} else
-		dev_warn(dev, "no resume for driver %s?\n", driver-&gt;name);
+		dev_warn(&amp;intf-&gt;dev, "no resume for driver %s?\n",
+				driver-&gt;name);
 	return 0;
 }
 
+static int usb_suspend(struct device *dev, pm_message_t message)
+{
+	int	status;
+
+	if (is_usb_device(dev))
+		status = suspend_device(to_usb_device(dev), message);
+	else
+		status = suspend_interface(to_usb_interface(dev), message);
+	return status;
+}
+
+static int usb_resume(struct device *dev)
+{
+	int	status;
+
+	if (is_usb_device(dev))
+		status = resume_device(to_usb_device(dev));
+	else
+		status = resume_interface(to_usb_interface(dev));
+	return status;
+}
+
 #endif /* CONFIG_PM */
 
 struct bus_type usb_bus_type = {</pre><hr><pre>commit 782da727b0d59e93c84a627948b1535a3db90392
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Jul 1 22:09:35 2006 -0400

    usbcore: make usb_generic a usb_device_driver
    
    This patch (as714b) makes usb_generic into a usb_device_driver capable
    of being probed and unbound, just like other drivers.  A fair amount of
    the work that used to get done during discovery or removal of a USB
    device have been moved to the probe and disconnect methods of
    usb_generic: creating the sysfs attributes and selecting an initial
    configuration.  However the normal behavior should continue to be the
    same as before.
    
    We will now have the possibility of creating other USB device drivers,
    They will assist with exporting devices to remote systems
    (USB-over-TCPIP) or to paravirtual guest operating systems.
    
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 0d4b5dcee3ab..a62de0a85406 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -530,9 +530,10 @@ static int usb_uevent(struct device *dev, char **envp, int num_envp,
 	/* driver is often null here; dev_dbg() would oops */
 	pr_debug ("usb %s: uevent\n", dev-&gt;bus_id);
 
-	if (is_usb_device(dev))
-		return 0;
-	else {
+	if (is_usb_device(dev)) {
+		usb_dev = to_usb_device(dev);
+		alt = NULL;
+	} else {
 		intf = to_usb_interface(dev);
 		usb_dev = interface_to_usbdev(intf);
 		alt = intf-&gt;cur_altsetting;
@@ -579,15 +580,17 @@ static int usb_uevent(struct device *dev, char **envp, int num_envp,
 			   usb_dev-&gt;descriptor.bDeviceProtocol))
 		return -ENOMEM;
 
-	if (add_uevent_var(envp, num_envp, &amp;i,
+	if (!is_usb_device(dev)) {
+
+		if (add_uevent_var(envp, num_envp, &amp;i,
 			   buffer, buffer_size, &amp;length,
 			   "INTERFACE=%d/%d/%d",
 			   alt-&gt;desc.bInterfaceClass,
 			   alt-&gt;desc.bInterfaceSubClass,
 			   alt-&gt;desc.bInterfaceProtocol))
-		return -ENOMEM;
+			return -ENOMEM;
 
-	if (add_uevent_var(envp, num_envp, &amp;i,
+		if (add_uevent_var(envp, num_envp, &amp;i,
 			   buffer, buffer_size, &amp;length,
 			   "MODALIAS=usb:v%04Xp%04Xd%04Xdc%02Xdsc%02Xdp%02Xic%02Xisc%02Xip%02X",
 			   le16_to_cpu(usb_dev-&gt;descriptor.idVendor),
@@ -599,7 +602,8 @@ static int usb_uevent(struct device *dev, char **envp, int num_envp,
 			   alt-&gt;desc.bInterfaceClass,
 			   alt-&gt;desc.bInterfaceSubClass,
 			   alt-&gt;desc.bInterfaceProtocol))
-		return -ENOMEM;
+			return -ENOMEM;
+	}
 
 	envp[i] = NULL;
 
@@ -747,31 +751,22 @@ EXPORT_SYMBOL_GPL_FUTURE(usb_deregister);
 
 #ifdef CONFIG_PM
 
-static int verify_suspended(struct device *dev, void *unused)
+static int usb_suspend(struct device *dev, pm_message_t message)
 {
-	if (dev-&gt;driver == NULL)
-		return 0;
-	return (dev-&gt;power.power_state.event == PM_EVENT_ON) ? -EBUSY : 0;
-}
+	struct usb_device		*udev;
+	struct usb_device_driver	*udriver;
+	struct usb_interface		*intf;
+	struct usb_driver		*driver;
+	int				status;
 
-static int usb_generic_suspend(struct device *dev, pm_message_t message)
-{
-	struct usb_interface	*intf;
-	struct usb_driver	*driver;
-	int			status;
-
-	/* USB devices enter SUSPEND state through their hubs, but can be
-	 * marked for FREEZE as soon as their children are already idled.
-	 * But those semantics are useless, so we equate the two (sigh).
-	 */
 	if (is_usb_device(dev)) {
+		if (dev-&gt;driver == NULL)
+			return 0;
+		udev = to_usb_device(dev);
+		udriver = to_usb_device_driver(dev-&gt;driver);
 		if (dev-&gt;power.power_state.event == message.event)
 			return 0;
-		/* we need to rule out bogus requests through sysfs */
-		status = device_for_each_child(dev, NULL, verify_suspended);
-		if (status)
-			return status;
- 		return usb_port_suspend(to_usb_device(dev));
+		return udriver-&gt;suspend(udev, message);
 	}
 
 	if (dev-&gt;driver == NULL)
@@ -799,12 +794,13 @@ static int usb_generic_suspend(struct device *dev, pm_message_t message)
 	return status;
 }
 
-static int usb_generic_resume(struct device *dev)
+static int usb_resume(struct device *dev)
 {
-	struct usb_interface	*intf;
-	struct usb_driver	*driver;
-	struct usb_device	*udev;
-	int			status;
+	struct usb_device		*udev;
+	struct usb_device_driver	*udriver;
+	struct usb_interface		*intf;
+	struct usb_driver		*driver;
+	int				status;
 
 	if (dev-&gt;power.power_state.event == PM_EVENT_ON)
 		return 0;
@@ -814,10 +810,13 @@ static int usb_generic_resume(struct device *dev)
 
 	/* devices resume through their hubs */
 	if (is_usb_device(dev)) {
+		if (dev-&gt;driver == NULL)
+			return 0;
 		udev = to_usb_device(dev);
+		udriver = to_usb_device_driver(dev-&gt;driver);
 		if (udev-&gt;state == USB_STATE_NOTATTACHED)
 			return 0;
-		return usb_port_resume(udev);
+		return udriver-&gt;resume(udev);
 	}
 
 	if (dev-&gt;driver == NULL) {
@@ -854,7 +853,7 @@ struct bus_type usb_bus_type = {
 	.match =	usb_device_match,
 	.uevent =	usb_uevent,
 #ifdef CONFIG_PM
-	.suspend =	usb_generic_suspend,
-	.resume =	usb_generic_resume,
+	.suspend =	usb_suspend,
+	.resume =	usb_resume,
 #endif
 };
diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index fa6f34a12b4b..1522195de715 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -21,24 +21,208 @@
 #include &lt;linux/usb.h&gt;
 #include "usb.h"
 
+static inline const char *plural(int n)
+{
+	return (n == 1 ? "" : "s");
+}
+
+static int choose_configuration(struct usb_device *udev)
+{
+	int i;
+	int num_configs;
+	int insufficient_power = 0;
+	struct usb_host_config *c, *best;
+
+	best = NULL;
+	c = udev-&gt;config;
+	num_configs = udev-&gt;descriptor.bNumConfigurations;
+	for (i = 0; i &lt; num_configs; (i++, c++)) {
+		struct usb_interface_descriptor	*desc = NULL;
+
+		/* It's possible that a config has no interfaces! */
+		if (c-&gt;desc.bNumInterfaces &gt; 0)
+			desc = &amp;c-&gt;intf_cache[0]-&gt;altsetting-&gt;desc;
+
+		/*
+		 * HP's USB bus-powered keyboard has only one configuration
+		 * and it claims to be self-powered; other devices may have
+		 * similar errors in their descriptors.  If the next test
+		 * were allowed to execute, such configurations would always
+		 * be rejected and the devices would not work as expected.
+		 * In the meantime, we run the risk of selecting a config
+		 * that requires external power at a time when that power
+		 * isn't available.  It seems to be the lesser of two evils.
+		 *
+		 * Bugzilla #6448 reports a device that appears to crash
+		 * when it receives a GET_DEVICE_STATUS request!  We don't
+		 * have any other way to tell whether a device is self-powered,
+		 * but since we don't use that information anywhere but here,
+		 * the call has been removed.
+		 *
+		 * Maybe the GET_DEVICE_STATUS call and the test below can
+		 * be reinstated when device firmwares become more reliable.
+		 * Don't hold your breath.
+		 */
+#if 0
+		/* Rule out self-powered configs for a bus-powered device */
+		if (bus_powered &amp;&amp; (c-&gt;desc.bmAttributes &amp;
+					USB_CONFIG_ATT_SELFPOWER))
+			continue;
+#endif
+
+		/*
+		 * The next test may not be as effective as it should be.
+		 * Some hubs have errors in their descriptor, claiming
+		 * to be self-powered when they are really bus-powered.
+		 * We will overestimate the amount of current such hubs
+		 * make available for each port.
+		 *
+		 * This is a fairly benign sort of failure.  It won't
+		 * cause us to reject configurations that we should have
+		 * accepted.
+		 */
+
+		/* Rule out configs that draw too much bus current */
+		if (c-&gt;desc.bMaxPower * 2 &gt; udev-&gt;bus_mA) {
+			insufficient_power++;
+			continue;
+		}
+
+		/* If the first config's first interface is COMM/2/0xff
+		 * (MSFT RNDIS), rule it out unless Linux has host-side
+		 * RNDIS support. */
+		if (i == 0 &amp;&amp; desc
+				&amp;&amp; desc-&gt;bInterfaceClass == USB_CLASS_COMM
+				&amp;&amp; desc-&gt;bInterfaceSubClass == 2
+				&amp;&amp; desc-&gt;bInterfaceProtocol == 0xff) {
+#ifndef CONFIG_USB_NET_RNDIS_HOST
+			continue;
+#else
+			best = c;
+#endif
+		}
+
+		/* From the remaining configs, choose the first one whose
+		 * first interface is for a non-vendor-specific class.
+		 * Reason: Linux is more likely to have a class driver
+		 * than a vendor-specific driver. */
+		else if (udev-&gt;descriptor.bDeviceClass !=
+						USB_CLASS_VENDOR_SPEC &amp;&amp;
+				(!desc || desc-&gt;bInterfaceClass !=
+						USB_CLASS_VENDOR_SPEC)) {
+			best = c;
+			break;
+		}
+
+		/* If all the remaining configs are vendor-specific,
+		 * choose the first one. */
+		else if (!best)
+			best = c;
+	}
+
+	if (insufficient_power &gt; 0)
+		dev_info(&amp;udev-&gt;dev, "rejected %d configuration%s "
+			"due to insufficient available bus power\n",
+			insufficient_power, plural(insufficient_power));
+
+	if (best) {
+		i = best-&gt;desc.bConfigurationValue;
+		dev_info(&amp;udev-&gt;dev,
+			"configuration #%d chosen from %d choice%s\n",
+			i, num_configs, plural(num_configs));
+	} else {
+		i = -1;
+		dev_warn(&amp;udev-&gt;dev,
+			"no configuration chosen from %d choice%s\n",
+			num_configs, plural(num_configs));
+	}
+	return i;
+}
+
 static int generic_probe(struct usb_device *udev)
 {
+	int err, c;
+
+	/* put device-specific files into sysfs */
+	usb_create_sysfs_dev_files(udev);
+
+	/* Choose and set the configuration.  This registers the interfaces
+	 * with the driver core and lets interface drivers bind to them.
+	 */
+	c = choose_configuration(udev);
+	if (c &gt;= 0) {
+		err = usb_set_configuration(udev, c);
+		if (err) {
+			dev_err(&amp;udev-&gt;dev, "can't set config #%d, error %d\n",
+					c, err);
+			/* This need not be fatal.  The user can try to
+			 * set other configurations. */
+		}
+	}
+
+	/* USB device state == configured ... usable */
+	usb_notify_add_device(udev);
+
 	return 0;
 }
+
 static void generic_disconnect(struct usb_device *udev)
 {
+	usb_notify_remove_device(udev);
+
 	/* if this is only an unbind, not a physical disconnect, then
 	 * unconfigure the device */
 	if (udev-&gt;state == USB_STATE_CONFIGURED)
 		usb_set_configuration(udev, 0);
 
+	usb_remove_sysfs_dev_files(udev);
+
 	/* in case the call failed or the device was suspended */
 	if (udev-&gt;state &gt;= USB_STATE_CONFIGURED)
 		usb_disable_device(udev, 0);
 }
 
+#ifdef	CONFIG_PM
+
+static int verify_suspended(struct device *dev, void *unused)
+{
+	if (dev-&gt;driver == NULL)
+		return 0;
+	return (dev-&gt;power.power_state.event == PM_EVENT_ON) ? -EBUSY : 0;
+}
+
+static int generic_suspend(struct usb_device *udev, pm_message_t msg)
+{
+	int	status;
+
+	/* rule out bogus requests through sysfs */
+	status = device_for_each_child(&amp;udev-&gt;dev, NULL, verify_suspended);
+	if (status)
+		return status;
+
+	/* USB devices enter SUSPEND state through their hubs, but can be
+	 * marked for FREEZE as soon as their children are already idled.
+	 * But those semantics are useless, so we equate the two (sigh).
+	 */
+	return usb_port_suspend(udev);
+}
+
+static int generic_resume(struct usb_device *udev)
+{
+	if (udev-&gt;state == USB_STATE_NOTATTACHED)
+		return 0;
+
+	return usb_port_resume(udev);
+}
+
+#endif	/* CONFIG_PM */
+
 struct usb_device_driver usb_generic_driver = {
 	.name =	"usb",
 	.probe = generic_probe,
 	.disconnect = generic_disconnect,
+#ifdef	CONFIG_PM
+	.suspend = generic_suspend,
+	.resume = generic_resume,
+#endif
 };
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index b00514d9a605..a372332440b2 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1148,144 +1148,28 @@ void usb_disconnect(struct usb_device **pdev)
 	 * cleaning up all state associated with the current configuration
 	 * so that the hardware is now fully quiesced.
 	 */
+	dev_dbg (&amp;udev-&gt;dev, "unregistering device\n");
 	usb_disable_device(udev, 0);
 
-	usb_notify_remove_device(udev);
+	usb_unlock_device(udev);
+
+	/* Unregister the device.  The device driver is responsible
+	 * for removing the device files from usbfs and sysfs and for
+	 * de-configuring the device.
+	 */
+	device_del(&amp;udev-&gt;dev);
 
-	/* Free the device number, remove the /proc/bus/usb entry and
-	 * the sysfs attributes, and delete the parent's children[]
+	/* Free the device number and delete the parent's children[]
 	 * (or root_hub) pointer.
 	 */
-	dev_dbg (&amp;udev-&gt;dev, "unregistering device\n");
 	release_address(udev);
-	usb_remove_sysfs_dev_files(udev);
 
 	/* Avoid races with recursively_mark_NOTATTACHED() */
 	spin_lock_irq(&amp;device_state_lock);
 	*pdev = NULL;
 	spin_unlock_irq(&amp;device_state_lock);
 
-	usb_unlock_device(udev);
-
-	device_unregister(&amp;udev-&gt;dev);
-}
-
-static inline const char *plural(int n)
-{
-	return (n == 1 ? "" : "s");
-}
-
-static int choose_configuration(struct usb_device *udev)
-{
-	int i;
-	int num_configs;
-	int insufficient_power = 0;
-	struct usb_host_config *c, *best;
-
-	best = NULL;
-	c = udev-&gt;config;
-	num_configs = udev-&gt;descriptor.bNumConfigurations;
-	for (i = 0; i &lt; num_configs; (i++, c++)) {
-		struct usb_interface_descriptor	*desc = NULL;
-
-		/* It's possible that a config has no interfaces! */
-		if (c-&gt;desc.bNumInterfaces &gt; 0)
-			desc = &amp;c-&gt;intf_cache[0]-&gt;altsetting-&gt;desc;
-
-		/*
-		 * HP's USB bus-powered keyboard has only one configuration
-		 * and it claims to be self-powered; other devices may have
-		 * similar errors in their descriptors.  If the next test
-		 * were allowed to execute, such configurations would always
-		 * be rejected and the devices would not work as expected.
-		 * In the meantime, we run the risk of selecting a config
-		 * that requires external power at a time when that power
-		 * isn't available.  It seems to be the lesser of two evils.
-		 *
-		 * Bugzilla #6448 reports a device that appears to crash
-		 * when it receives a GET_DEVICE_STATUS request!  We don't
-		 * have any other way to tell whether a device is self-powered,
-		 * but since we don't use that information anywhere but here,
-		 * the call has been removed.
-		 *
-		 * Maybe the GET_DEVICE_STATUS call and the test below can
-		 * be reinstated when device firmwares become more reliable.
-		 * Don't hold your breath.
-		 */
-#if 0
-		/* Rule out self-powered configs for a bus-powered device */
-		if (bus_powered &amp;&amp; (c-&gt;desc.bmAttributes &amp;
-					USB_CONFIG_ATT_SELFPOWER))
-			continue;
-#endif
-
-		/*
-		 * The next test may not be as effective as it should be.
-		 * Some hubs have errors in their descriptor, claiming
-		 * to be self-powered when they are really bus-powered.
-		 * We will overestimate the amount of current such hubs
-		 * make available for each port.
-		 *
-		 * This is a fairly benign sort of failure.  It won't
-		 * cause us to reject configurations that we should have
-		 * accepted.
-		 */
-
-		/* Rule out configs that draw too much bus current */
-		if (c-&gt;desc.bMaxPower * 2 &gt; udev-&gt;bus_mA) {
-			insufficient_power++;
-			continue;
-		}
-
-		/* If the first config's first interface is COMM/2/0xff
-		 * (MSFT RNDIS), rule it out unless Linux has host-side
-		 * RNDIS support. */
-		if (i == 0 &amp;&amp; desc
-				&amp;&amp; desc-&gt;bInterfaceClass == USB_CLASS_COMM
-				&amp;&amp; desc-&gt;bInterfaceSubClass == 2
-				&amp;&amp; desc-&gt;bInterfaceProtocol == 0xff) {
-#ifndef CONFIG_USB_NET_RNDIS_HOST
-			continue;
-#else
-			best = c;
-#endif
-		}
-
-		/* From the remaining configs, choose the first one whose
-		 * first interface is for a non-vendor-specific class.
-		 * Reason: Linux is more likely to have a class driver
-		 * than a vendor-specific driver. */
-		else if (udev-&gt;descriptor.bDeviceClass !=
-						USB_CLASS_VENDOR_SPEC &amp;&amp;
-				(!desc || desc-&gt;bInterfaceClass !=
-						USB_CLASS_VENDOR_SPEC)) {
-			best = c;
-			break;
-		}
-
-		/* If all the remaining configs are vendor-specific,
-		 * choose the first one. */
-		else if (!best)
-			best = c;
-	}
-
-	if (insufficient_power &gt; 0)
-		dev_info(&amp;udev-&gt;dev, "rejected %d configuration%s "
-			"due to insufficient available bus power\n",
-			insufficient_power, plural(insufficient_power));
-
-	if (best) {
-		i = best-&gt;desc.bConfigurationValue;
-		dev_info(&amp;udev-&gt;dev,
-			"configuration #%d chosen from %d choice%s\n",
-			i, num_configs, plural(num_configs));
-	} else {
-		i = -1;
-		dev_warn(&amp;udev-&gt;dev,
-			"no configuration chosen from %d choice%s\n",
-			num_configs, plural(num_configs));
-	}
-	return i;
+	put_device(&amp;udev-&gt;dev);
 }
 
 #ifdef DEBUG
@@ -1328,7 +1212,6 @@ static inline void show_string(struct usb_device *udev, char *id, char *string)
 int usb_new_device(struct usb_device *udev)
 {
 	int err;
-	int c;
 
 	err = usb_get_configuration(udev);
 	if (err &lt; 0) {
@@ -1418,34 +1301,15 @@ int usb_new_device(struct usb_device *udev)
 	}
 #endif
 
-	/* put device-specific files into sysfs */
+	/* Register the device.  The device driver is responsible
+	 * for adding the device files to usbfs and sysfs and for
+	 * configuring the device.
+	 */
 	err = device_add (&amp;udev-&gt;dev);
 	if (err) {
 		dev_err(&amp;udev-&gt;dev, "can't device_add, error %d\n", err);
 		goto fail;
 	}
-	usb_create_sysfs_dev_files (udev);
-
-	usb_lock_device(udev);
-
-	/* choose and set the configuration. that registers the interfaces
-	 * with the driver core, and lets usb device drivers bind to them.
-	 */
-	c = choose_configuration(udev);
-	if (c &gt;= 0) {
-		err = usb_set_configuration(udev, c);
-		if (err) {
-			dev_err(&amp;udev-&gt;dev, "can't set config #%d, error %d\n",
-					c, err);
-			/* This need not be fatal.  The user can try to
-			 * set other configurations. */
-		}
-	}
-
-	/* USB device state == configured ... usable */
-	usb_notify_add_device(udev);
-
-	usb_unlock_device(udev);
 
 	return 0;
 
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index 6dfbc284369b..9ebfc0fe819d 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -205,7 +205,6 @@ usb_alloc_dev(struct usb_device *parent, struct usb_bus *bus, unsigned port1)
 	device_initialize(&amp;dev-&gt;dev);
 	dev-&gt;dev.bus = &amp;usb_bus_type;
 	dev-&gt;dev.dma_mask = bus-&gt;controller-&gt;dma_mask;
-	dev-&gt;dev.driver = &amp;usb_generic_driver.drvwrap.driver;
 	dev-&gt;dev.release = usb_release_dev;
 	dev-&gt;state = USB_STATE_ATTACHED;
 </pre><hr><pre>commit 8bb54ab573ecd1b4fe2ed66416a8d99a86e65316
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Jul 1 22:08:49 2006 -0400

    usbcore: add usb_device_driver definition
    
    This patch (as732) adds a usb_device_driver structure, for representing
    drivers that manage an entire USB device as opposed to just an
    interface.  Support routines like usb_register_device_driver,
    usb_deregister_device_driver, usb_probe_device, and usb_unbind_device
    are also added.
    
    Unlike an earlier version of this patch, the new code is type-safe.  To
    accomplish this, the existing struct driver embedded in struct
    usb_driver had to be wrapped in an intermediate wrapper.  This enables
    the core to tell at runtime whether a particular struct driver belongs
    to a device driver or to an interface driver.
    
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 8dcf2cd0c569..0d4b5dcee3ab 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -84,7 +84,7 @@ static int usb_create_newid_file(struct usb_driver *usb_drv)
 		goto exit;
 
 	if (usb_drv-&gt;probe != NULL)
-		error = sysfs_create_file(&amp;usb_drv-&gt;driver.kobj,
+		error = sysfs_create_file(&amp;usb_drv-&gt;drvwrap.driver.kobj,
 					  &amp;driver_attr_new_id.attr);
 exit:
 	return error;
@@ -96,7 +96,7 @@ static void usb_remove_newid_file(struct usb_driver *usb_drv)
 		return;
 
 	if (usb_drv-&gt;probe != NULL)
-		sysfs_remove_file(&amp;usb_drv-&gt;driver.kobj,
+		sysfs_remove_file(&amp;usb_drv-&gt;drvwrap.driver.kobj,
 				  &amp;driver_attr_new_id.attr);
 }
 
@@ -143,18 +143,55 @@ static const struct usb_device_id *usb_match_dynamic_id(struct usb_interface *in
 }
 
 
-/* called from driver core with usb_bus_type.subsys writelock */
+/* called from driver core with dev locked */
+static int usb_probe_device(struct device *dev)
+{
+	struct usb_device_driver *udriver = to_usb_device_driver(dev-&gt;driver);
+	struct usb_device *udev;
+	int error = -ENODEV;
+
+	dev_dbg(dev, "%s\n", __FUNCTION__);
+
+	if (!is_usb_device(dev))	/* Sanity check */
+		return error;
+
+	udev = to_usb_device(dev);
+
+	/* FIXME: resume a suspended device */
+	if (udev-&gt;state == USB_STATE_SUSPENDED)
+		return -EHOSTUNREACH;
+
+	/* TODO: Add real matching code */
+
+	error = udriver-&gt;probe(udev);
+	return error;
+}
+
+/* called from driver core with dev locked */
+static int usb_unbind_device(struct device *dev)
+{
+	struct usb_device_driver *udriver = to_usb_device_driver(dev-&gt;driver);
+
+	udriver-&gt;disconnect(to_usb_device(dev));
+	return 0;
+}
+
+
+/* called from driver core with dev locked */
 static int usb_probe_interface(struct device *dev)
 {
-	struct usb_interface * intf = to_usb_interface(dev);
-	struct usb_driver * driver = to_usb_driver(dev-&gt;driver);
+	struct usb_driver *driver = to_usb_driver(dev-&gt;driver);
+	struct usb_interface *intf;
 	const struct usb_device_id *id;
 	int error = -ENODEV;
 
 	dev_dbg(dev, "%s\n", __FUNCTION__);
 
-	if (!driver-&gt;probe)
+	if (is_usb_device(dev))		/* Sanity check */
 		return error;
+
+	intf = to_usb_interface(dev);
+
 	/* FIXME we'd much prefer to just resume it ... */
 	if (interface_to_usbdev(intf)-&gt;state == USB_STATE_SUSPENDED)
 		return -EHOSTUNREACH;
@@ -182,19 +219,18 @@ static int usb_probe_interface(struct device *dev)
 	return error;
 }
 
-/* called from driver core with usb_bus_type.subsys writelock */
+/* called from driver core with dev locked */
 static int usb_unbind_interface(struct device *dev)
 {
+	struct usb_driver *driver = to_usb_driver(dev-&gt;driver);
 	struct usb_interface *intf = to_usb_interface(dev);
-	struct usb_driver *driver = to_usb_driver(intf-&gt;dev.driver);
 
 	intf-&gt;condition = USB_INTERFACE_UNBINDING;
 
 	/* release all urbs for this interface */
 	usb_disable_interface(interface_to_usbdev(intf), intf);
 
-	if (driver &amp;&amp; driver-&gt;disconnect)
-		driver-&gt;disconnect(intf);
+	driver-&gt;disconnect(intf);
 
 	/* reset other interface state */
 	usb_set_interface(interface_to_usbdev(intf),
@@ -235,7 +271,7 @@ int usb_driver_claim_interface(struct usb_driver *driver,
 	if (dev-&gt;driver)
 		return -EBUSY;
 
-	dev-&gt;driver = &amp;driver-&gt;driver;
+	dev-&gt;driver = &amp;driver-&gt;drvwrap.driver;
 	usb_set_intfdata(iface, priv);
 	iface-&gt;condition = USB_INTERFACE_BOUND;
 	mark_active(iface);
@@ -270,7 +306,7 @@ void usb_driver_release_interface(struct usb_driver *driver,
 	struct device *dev = &amp;iface-&gt;dev;
 
 	/* this should never happen, don't release something that's not ours */
-	if (!dev-&gt;driver || dev-&gt;driver != &amp;driver-&gt;driver)
+	if (!dev-&gt;driver || dev-&gt;driver != &amp;driver-&gt;drvwrap.driver)
 		return;
 
 	/* don't release from within disconnect() */
@@ -433,24 +469,37 @@ EXPORT_SYMBOL_GPL_FUTURE(usb_match_id);
 
 int usb_device_match(struct device *dev, struct device_driver *drv)
 {
-	struct usb_interface *intf;
-	struct usb_driver *usb_drv;
-	const struct usb_device_id *id;
-
-	/* check for generic driver, which we don't match any device with */
-	if (drv == &amp;usb_generic_driver)
-		return 0;
+	/* devices and interfaces are handled separately */
+	if (is_usb_device(dev)) {
 
-	intf = to_usb_interface(dev);
-	usb_drv = to_usb_driver(drv);
+		/* interface drivers never match devices */
+		if (!is_usb_device_driver(drv))
+			return 0;
 
-	id = usb_match_id(intf, usb_drv-&gt;id_table);
-	if (id)
+		/* TODO: Add real matching code */
 		return 1;
 
-	id = usb_match_dynamic_id(intf, usb_drv);
-	if (id)
-		return 1;
+	} else {
+		struct usb_interface *intf;
+		struct usb_driver *usb_drv;
+		const struct usb_device_id *id;
+
+		/* device drivers never match interfaces */
+		if (is_usb_device_driver(drv))
+			return 0;
+
+		intf = to_usb_interface(dev);
+		usb_drv = to_usb_driver(drv);
+
+		id = usb_match_id(intf, usb_drv-&gt;id_table);
+		if (id)
+			return 1;
+
+		id = usb_match_dynamic_id(intf, usb_drv);
+		if (id)
+			return 1;
+	}
+
 	return 0;
 }
 
@@ -481,14 +530,13 @@ static int usb_uevent(struct device *dev, char **envp, int num_envp,
 	/* driver is often null here; dev_dbg() would oops */
 	pr_debug ("usb %s: uevent\n", dev-&gt;bus_id);
 
-	/* Must check driver_data here, as on remove driver is always NULL */
-	if ((dev-&gt;driver == &amp;usb_generic_driver) ||
-	    (dev-&gt;driver_data == &amp;usb_generic_driver_data))
+	if (is_usb_device(dev))
 		return 0;
-
-	intf = to_usb_interface(dev);
-	usb_dev = interface_to_usbdev (intf);
-	alt = intf-&gt;cur_altsetting;
+	else {
+		intf = to_usb_interface(dev);
+		usb_dev = interface_to_usbdev(intf);
+		alt = intf-&gt;cur_altsetting;
+	}
 
 	if (usb_dev-&gt;devnum &lt; 0) {
 		pr_debug ("usb %s: already deleted?\n", dev-&gt;bus_id);
@@ -569,13 +617,71 @@ static int usb_uevent(struct device *dev, char **envp,
 #endif	/* CONFIG_HOTPLUG */
 
 /**
- * usb_register_driver - register a USB driver
- * @new_driver: USB operations for the driver
+ * usb_register_device_driver - register a USB device (not interface) driver
+ * @new_udriver: USB operations for the device driver
  * @owner: module owner of this driver.
  *
- * Registers a USB driver with the USB core.  The list of unattached
- * interfaces will be rescanned whenever a new driver is added, allowing
- * the new driver to attach to any recognized devices.
+ * Registers a USB device driver with the USB core.  The list of
+ * unattached devices will be rescanned whenever a new driver is
+ * added, allowing the new driver to attach to any recognized devices.
+ * Returns a negative error code on failure and 0 on success.
+ */
+int usb_register_device_driver(struct usb_device_driver *new_udriver,
+		struct module *owner)
+{
+	int retval = 0;
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	new_udriver-&gt;drvwrap.for_devices = 1;
+	new_udriver-&gt;drvwrap.driver.name = (char *) new_udriver-&gt;name;
+	new_udriver-&gt;drvwrap.driver.bus = &amp;usb_bus_type;
+	new_udriver-&gt;drvwrap.driver.probe = usb_probe_device;
+	new_udriver-&gt;drvwrap.driver.remove = usb_unbind_device;
+	new_udriver-&gt;drvwrap.driver.owner = owner;
+
+	retval = driver_register(&amp;new_udriver-&gt;drvwrap.driver);
+
+	if (!retval) {
+		pr_info("%s: registered new device driver %s\n",
+			usbcore_name, new_udriver-&gt;name);
+		usbfs_update_special();
+	} else {
+		printk(KERN_ERR "%s: error %d registering device "
+			"	driver %s\n",
+			usbcore_name, retval, new_udriver-&gt;name);
+	}
+
+	return retval;
+}
+EXPORT_SYMBOL_GPL(usb_register_device_driver);
+
+/**
+ * usb_deregister_device_driver - unregister a USB device (not interface) driver
+ * @udriver: USB operations of the device driver to unregister
+ * Context: must be able to sleep
+ *
+ * Unlinks the specified driver from the internal USB driver list.
+ */
+void usb_deregister_device_driver(struct usb_device_driver *udriver)
+{
+	pr_info("%s: deregistering device driver %s\n",
+			usbcore_name, udriver-&gt;name);
+
+	driver_unregister(&amp;udriver-&gt;drvwrap.driver);
+	usbfs_update_special();
+}
+EXPORT_SYMBOL_GPL(usb_deregister_device_driver);
+
+/**
+ * usb_register_driver - register a USB interface driver
+ * @new_driver: USB operations for the interface driver
+ * @owner: module owner of this driver.
+ *
+ * Registers a USB interface driver with the USB core.  The list of
+ * unattached interfaces will be rescanned whenever a new driver is
+ * added, allowing the new driver to attach to any recognized interfaces.
  * Returns a negative error code on failure and 0 on success.
  *
  * NOTE: if you want your driver to use the USB major number, you must call
@@ -589,23 +695,25 @@ int usb_register_driver(struct usb_driver *new_driver, struct module *owner)
 	if (usb_disabled())
 		return -ENODEV;
 
-	new_driver-&gt;driver.name = (char *)new_driver-&gt;name;
-	new_driver-&gt;driver.bus = &amp;usb_bus_type;
-	new_driver-&gt;driver.probe = usb_probe_interface;
-	new_driver-&gt;driver.remove = usb_unbind_interface;
-	new_driver-&gt;driver.owner = owner;
+	new_driver-&gt;drvwrap.for_devices = 0;
+	new_driver-&gt;drvwrap.driver.name = (char *) new_driver-&gt;name;
+	new_driver-&gt;drvwrap.driver.bus = &amp;usb_bus_type;
+	new_driver-&gt;drvwrap.driver.probe = usb_probe_interface;
+	new_driver-&gt;drvwrap.driver.remove = usb_unbind_interface;
+	new_driver-&gt;drvwrap.driver.owner = owner;
 	spin_lock_init(&amp;new_driver-&gt;dynids.lock);
 	INIT_LIST_HEAD(&amp;new_driver-&gt;dynids.list);
 
-	retval = driver_register(&amp;new_driver-&gt;driver);
+	retval = driver_register(&amp;new_driver-&gt;drvwrap.driver);
 
 	if (!retval) {
-		pr_info("%s: registered new driver %s\n",
+		pr_info("%s: registered new interface driver %s\n",
 			usbcore_name, new_driver-&gt;name);
 		usbfs_update_special();
 		usb_create_newid_file(new_driver);
 	} else {
-		printk(KERN_ERR "%s: error %d registering driver %s\n",
+		printk(KERN_ERR "%s: error %d registering interface "
+			"	driver %s\n",
 			usbcore_name, retval, new_driver-&gt;name);
 	}
 
@@ -614,8 +722,8 @@ int usb_register_driver(struct usb_driver *new_driver, struct module *owner)
 EXPORT_SYMBOL_GPL_FUTURE(usb_register_driver);
 
 /**
- * usb_deregister - unregister a USB driver
- * @driver: USB operations of the driver to unregister
+ * usb_deregister - unregister a USB interface driver
+ * @driver: USB operations of the interface driver to unregister
  * Context: must be able to sleep
  *
  * Unlinks the specified driver from the internal USB driver list.
@@ -626,11 +734,12 @@ EXPORT_SYMBOL_GPL_FUTURE(usb_register_driver);
  */
 void usb_deregister(struct usb_driver *driver)
 {
-	pr_info("%s: deregistering driver %s\n", usbcore_name, driver-&gt;name);
+	pr_info("%s: deregistering interface driver %s\n",
+			usbcore_name, driver-&gt;name);
 
 	usb_remove_newid_file(driver);
 	usb_free_dynids(driver);
-	driver_unregister(&amp;driver-&gt;driver);
+	driver_unregister(&amp;driver-&gt;drvwrap.driver);
 
 	usbfs_update_special();
 }
@@ -655,7 +764,7 @@ static int usb_generic_suspend(struct device *dev, pm_message_t message)
 	 * marked for FREEZE as soon as their children are already idled.
 	 * But those semantics are useless, so we equate the two (sigh).
 	 */
-	if (dev-&gt;driver == &amp;usb_generic_driver) {
+	if (is_usb_device(dev)) {
 		if (dev-&gt;power.power_state.event == message.event)
 			return 0;
 		/* we need to rule out bogus requests through sysfs */
@@ -665,8 +774,7 @@ static int usb_generic_suspend(struct device *dev, pm_message_t message)
  		return usb_port_suspend(to_usb_device(dev));
 	}
 
-	if ((dev-&gt;driver == NULL) ||
-	    (dev-&gt;driver_data == &amp;usb_generic_driver_data))
+	if (dev-&gt;driver == NULL)
 		return 0;
 
 	intf = to_usb_interface(dev);
@@ -705,15 +813,14 @@ static int usb_generic_resume(struct device *dev)
 	dev-&gt;power.power_state.event = PM_EVENT_ON;
 
 	/* devices resume through their hubs */
-	if (dev-&gt;driver == &amp;usb_generic_driver) {
+	if (is_usb_device(dev)) {
 		udev = to_usb_device(dev);
 		if (udev-&gt;state == USB_STATE_NOTATTACHED)
 			return 0;
 		return usb_port_resume(udev);
 	}
 
-	if ((dev-&gt;driver == NULL) ||
-	    (dev-&gt;driver_data == &amp;usb_generic_driver_data)) {
+	if (dev-&gt;driver == NULL) {
 		dev-&gt;power.power_state.event = PM_EVENT_FREEZE;
 		return 0;
 	}
diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index 7bab9769b34f..fa6f34a12b4b 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -21,14 +21,12 @@
 #include &lt;linux/usb.h&gt;
 #include "usb.h"
 
-static int generic_probe(struct device *dev)
+static int generic_probe(struct usb_device *udev)
 {
 	return 0;
 }
-static int generic_remove(struct device *dev)
+static void generic_disconnect(struct usb_device *udev)
 {
-	struct usb_device *udev = to_usb_device(dev);
-
 	/* if this is only an unbind, not a physical disconnect, then
 	 * unconfigure the device */
 	if (udev-&gt;state == USB_STATE_CONFIGURED)
@@ -37,17 +35,10 @@ static int generic_remove(struct device *dev)
 	/* in case the call failed or the device was suspended */
 	if (udev-&gt;state &gt;= USB_STATE_CONFIGURED)
 		usb_disable_device(udev, 0);
-	return 0;
 }
 
-struct device_driver usb_generic_driver = {
-	.owner = THIS_MODULE,
+struct usb_device_driver usb_generic_driver = {
 	.name =	"usb",
-	.bus = &amp;usb_bus_type,
 	.probe = generic_probe,
-	.remove = generic_remove,
+	.disconnect = generic_disconnect,
 };
-
-/* Fun hack to determine if the struct device is a
- * usb device or a usb interface. */
-int usb_generic_driver_data;
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index 0b8c67bcde60..6dfbc284369b 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -123,7 +123,7 @@ static int __find_interface(struct device * dev, void * data)
 	struct usb_interface *intf;
 
 	/* can't look at usb devices, only interfaces */
-	if (dev-&gt;driver == &amp;usb_generic_driver)
+	if (is_usb_device(dev))
 		return 0;
 
 	intf = to_usb_interface(dev);
@@ -149,7 +149,8 @@ struct usb_interface *usb_find_interface(struct usb_driver *drv, int minor)
 
 	argb.minor = minor;
 	argb.interface = NULL;
-	driver_for_each_device(&amp;drv-&gt;driver, NULL, &amp;argb, __find_interface);
+	driver_for_each_device(&amp;drv-&gt;drvwrap.driver, NULL, &amp;argb,
+			__find_interface);
 	return argb.interface;
 }
 
@@ -204,11 +205,13 @@ usb_alloc_dev(struct usb_device *parent, struct usb_bus *bus, unsigned port1)
 	device_initialize(&amp;dev-&gt;dev);
 	dev-&gt;dev.bus = &amp;usb_bus_type;
 	dev-&gt;dev.dma_mask = bus-&gt;controller-&gt;dma_mask;
-	dev-&gt;dev.driver_data = &amp;usb_generic_driver_data;
-	dev-&gt;dev.driver = &amp;usb_generic_driver;
+	dev-&gt;dev.driver = &amp;usb_generic_driver.drvwrap.driver;
 	dev-&gt;dev.release = usb_release_dev;
 	dev-&gt;state = USB_STATE_ATTACHED;
 
+	/* This magic assignment distinguishes devices from interfaces */
+	dev-&gt;dev.platform_data = &amp;usb_generic_driver;
+
 	INIT_LIST_HEAD(&amp;dev-&gt;ep0.urb_list);
 	dev-&gt;ep0.desc.bLength = USB_DT_ENDPOINT_SIZE;
 	dev-&gt;ep0.desc.bDescriptorType = USB_DT_ENDPOINT;
@@ -838,7 +841,7 @@ static int __init usb_init(void)
 	retval = usb_hub_init();
 	if (retval)
 		goto hub_init_failed;
-	retval = driver_register(&amp;usb_generic_driver);
+	retval = usb_register_device_driver(&amp;usb_generic_driver, THIS_MODULE);
 	if (!retval)
 		goto out;
 
@@ -868,7 +871,7 @@ static void __exit usb_exit(void)
 	if (nousb)
 		return;
 
-	driver_unregister(&amp;usb_generic_driver);
+	usb_deregister_device_driver(&amp;usb_generic_driver);
 	usb_major_cleanup();
 	usbfs_cleanup();
 	usb_deregister(&amp;usbfs_driver);
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 82d397a6f773..1d25ccac7832 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -34,8 +34,24 @@ extern int usb_port_suspend(struct usb_device *dev);
 extern int usb_port_resume(struct usb_device *dev);
 
 extern struct bus_type usb_bus_type;
-extern struct device_driver usb_generic_driver;
-extern int usb_generic_driver_data;
+extern struct usb_device_driver usb_generic_driver;
+
+/* Here's how we tell apart devices and interfaces.  Luckily there's
+ * no such thing as a platform USB device, so we can steal the use
+ * of the platform_data field. */
+
+static inline int is_usb_device(struct device *dev)
+{
+	return dev-&gt;platform_data == &amp;usb_generic_driver;
+}
+
+/* Do the same for device drivers and interface drivers. */
+
+static inline int is_usb_device_driver(struct device_driver *drv)
+{
+	return container_of(drv, struct usbdrv_wrap, driver)-&gt;
+			for_devices;
+}
 
 /* Interfaces and their "power state" are owned by usbcore */
 
diff --git a/include/linux/usb.h b/include/linux/usb.h
index d2bd0c8e0154..b4ccce6d0982 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -540,7 +540,17 @@ struct usb_dynids {
 };
 
 /**
- * struct usb_driver - identifies USB driver to usbcore
+ * struct usbdrv_wrap - wrapper for driver-model structure
+ * @driver: The driver-model core driver structure.
+ * @for_devices: Non-zero for device drivers, 0 for interface drivers.
+ */
+struct usbdrv_wrap {
+	struct device_driver driver;
+	int for_devices;
+};
+
+/**
+ * struct usb_driver - identifies USB interface driver to usbcore
  * @name: The driver name should be unique among USB drivers,
  *	and should normally be the same as the module name.
  * @probe: Called to see if the driver is willing to manage a particular
@@ -567,12 +577,12 @@ struct usb_dynids {
  *	or your driver's probe function will never get called.
  * @dynids: used internally to hold the list of dynamically added device
  *	ids for this driver.
- * @driver: the driver model core driver structure.
+ * @drvwrap: Driver-model core structure wrapper.
  * @no_dynamic_id: if set to 1, the USB core will not allow dynamic ids to be
  *	added to this driver by preventing the sysfs file from being created.
  *
- * USB drivers must provide a name, probe() and disconnect() methods,
- * and an id_table.  Other driver fields are optional.
+ * USB interface drivers must provide a name, probe() and disconnect()
+ * methods, and an id_table.  Other driver fields are optional.
  *
  * The id_table is used in hotplugging.  It holds a set of descriptors,
  * and specialized data may be associated with each entry.  That table
@@ -606,10 +616,40 @@ struct usb_driver {
 	const struct usb_device_id *id_table;
 
 	struct usb_dynids dynids;
-	struct device_driver driver;
+	struct usbdrv_wrap drvwrap;
 	unsigned int no_dynamic_id:1;
 };
-#define	to_usb_driver(d) container_of(d, struct usb_driver, driver)
+#define	to_usb_driver(d) container_of(d, struct usb_driver, drvwrap.driver)
+
+/**
+ * struct usb_device_driver - identifies USB device driver to usbcore
+ * @name: The driver name should be unique among USB drivers,
+ *	and should normally be the same as the module name.
+ * @probe: Called to see if the driver is willing to manage a particular
+ *	device.  If it is, probe returns zero and uses dev_set_drvdata()
+ *	to associate driver-specific data with the device.  If unwilling
+ *	to manage the device, return a negative errno value.
+ * @disconnect: Called when the device is no longer accessible, usually
+ *	because it has been (or is being) disconnected or the driver's
+ *	module is being unloaded.
+ * @suspend: Called when the device is going to be suspended by the system.
+ * @resume: Called when the device is being resumed by the system.
+ * @drvwrap: Driver-model core structure wrapper.
+ *
+ * USB drivers must provide all the fields listed above except drvwrap.
+ */
+struct usb_device_driver {
+	const char *name;
+
+	int (*probe) (struct usb_device *udev);
+	void (*disconnect) (struct usb_device *udev);
+
+	int (*suspend) (struct usb_device *udev, pm_message_t message);
+	int (*resume) (struct usb_device *udev);
+	struct usbdrv_wrap drvwrap;
+};
+#define	to_usb_device_driver(d) container_of(d, struct usb_device_driver, \
+		drvwrap.driver)
 
 extern struct bus_type usb_bus_type;
 
@@ -633,13 +673,17 @@ struct usb_class_driver {
  * use these in module_init()/module_exit()
  * and don't forget MODULE_DEVICE_TABLE(usb, ...)
  */
-int usb_register_driver(struct usb_driver *, struct module *);
+extern int usb_register_driver(struct usb_driver *, struct module *);
 static inline int usb_register(struct usb_driver *driver)
 {
 	return usb_register_driver(driver, THIS_MODULE);
 }
 extern void usb_deregister(struct usb_driver *);
 
+extern int usb_register_device_driver(struct usb_device_driver *,
+			struct module *);
+extern void usb_deregister_device_driver(struct usb_device_driver *);
+
 extern int usb_register_dev(struct usb_interface *intf,
 			    struct usb_class_driver *class_driver);
 extern void usb_deregister_dev(struct usb_interface *intf,</pre><hr><pre>commit 36e56a34586783c7986ce09d39db80b27c95ce24
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Jul 1 22:08:06 2006 -0400

    usbcore: move code among source files
    
    This revised patch (as713b) moves a few routines among source files in
    usbcore.  Some driver-related code in usb.c (claiming interfaces and
    matching IDs) is moved to driver.c, where it belongs.  Also the
    usb_generic stuff in driver.c is moved to a new source file: generic.c.
    (That's the reason for revising the patch.)  Although not very big now,
    it will get bigger in a later patch.
    
    None of the code has been changed; it has only been re-arranged.
    
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/Makefile b/drivers/usb/core/Makefile
index ec510922af63..34e9bac319b4 100644
--- a/drivers/usb/core/Makefile
+++ b/drivers/usb/core/Makefile
@@ -4,7 +4,7 @@
 
 usbcore-objs	:= usb.o hub.o hcd.o urb.o message.o driver.o \
 			config.o file.o buffer.o sysfs.o endpoint.o \
-			devio.o notify.o
+			devio.o notify.o generic.o
 
 ifeq ($(CONFIG_PCI),y)
 	usbcore-objs	+= hcd-pci.o
diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index ec8906501415..8dcf2cd0c569 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -17,7 +17,8 @@
  *
  * NOTE! This is not actually a driver at all, rather this is
  * just a collection of helper routines that implement the
- * generic USB things that the real drivers can use..
+ * matching, probing, releasing, suspending and resuming for
+ * real drivers.
  *
  */
 
@@ -34,38 +35,6 @@ struct usb_dynid {
 	struct usb_device_id id;
 };
 
-
-static int generic_probe(struct device *dev)
-{
-	return 0;
-}
-static int generic_remove(struct device *dev)
-{
-	struct usb_device *udev = to_usb_device(dev);
-
-	/* if this is only an unbind, not a physical disconnect, then
-	 * unconfigure the device */
-	if (udev-&gt;state == USB_STATE_CONFIGURED)
-		usb_set_configuration(udev, 0);
-
-	/* in case the call failed or the device was suspended */
-	if (udev-&gt;state &gt;= USB_STATE_CONFIGURED)
-		usb_disable_device(udev, 0);
-	return 0;
-}
-
-struct device_driver usb_generic_driver = {
-	.owner = THIS_MODULE,
-	.name =	"usb",
-	.bus = &amp;usb_bus_type,
-	.probe = generic_probe,
-	.remove = generic_remove,
-};
-
-/* Fun hack to determine if the struct device is a
- * usb device or a usb interface. */
-int usb_generic_driver_data;
-
 #ifdef CONFIG_HOTPLUG
 
 /*
@@ -238,6 +207,89 @@ static int usb_unbind_interface(struct device *dev)
 	return 0;
 }
 
+/**
+ * usb_driver_claim_interface - bind a driver to an interface
+ * @driver: the driver to be bound
+ * @iface: the interface to which it will be bound; must be in the
+ *	usb device's active configuration
+ * @priv: driver data associated with that interface
+ *
+ * This is used by usb device drivers that need to claim more than one
+ * interface on a device when probing (audio and acm are current examples).
+ * No device driver should directly modify internal usb_interface or
+ * usb_device structure members.
+ *
+ * Few drivers should need to use this routine, since the most natural
+ * way to bind to an interface is to return the private data from
+ * the driver's probe() method.
+ *
+ * Callers must own the device lock and the driver model's usb_bus_type.subsys
+ * writelock.  So driver probe() entries don't need extra locking,
+ * but other call contexts may need to explicitly claim those locks.
+ */
+int usb_driver_claim_interface(struct usb_driver *driver,
+				struct usb_interface *iface, void* priv)
+{
+	struct device *dev = &amp;iface-&gt;dev;
+
+	if (dev-&gt;driver)
+		return -EBUSY;
+
+	dev-&gt;driver = &amp;driver-&gt;driver;
+	usb_set_intfdata(iface, priv);
+	iface-&gt;condition = USB_INTERFACE_BOUND;
+	mark_active(iface);
+
+	/* if interface was already added, bind now; else let
+	 * the future device_add() bind it, bypassing probe()
+	 */
+	if (device_is_registered(dev))
+		device_bind_driver(dev);
+
+	return 0;
+}
+EXPORT_SYMBOL(usb_driver_claim_interface);
+
+/**
+ * usb_driver_release_interface - unbind a driver from an interface
+ * @driver: the driver to be unbound
+ * @iface: the interface from which it will be unbound
+ *
+ * This can be used by drivers to release an interface without waiting
+ * for their disconnect() methods to be called.  In typical cases this
+ * also causes the driver disconnect() method to be called.
+ *
+ * This call is synchronous, and may not be used in an interrupt context.
+ * Callers must own the device lock and the driver model's usb_bus_type.subsys
+ * writelock.  So driver disconnect() entries don't need extra locking,
+ * but other call contexts may need to explicitly claim those locks.
+ */
+void usb_driver_release_interface(struct usb_driver *driver,
+					struct usb_interface *iface)
+{
+	struct device *dev = &amp;iface-&gt;dev;
+
+	/* this should never happen, don't release something that's not ours */
+	if (!dev-&gt;driver || dev-&gt;driver != &amp;driver-&gt;driver)
+		return;
+
+	/* don't release from within disconnect() */
+	if (iface-&gt;condition != USB_INTERFACE_BOUND)
+		return;
+
+	/* don't release if the interface hasn't been added yet */
+	if (device_is_registered(dev)) {
+		iface-&gt;condition = USB_INTERFACE_UNBINDING;
+		device_release_driver(dev);
+	}
+
+	dev-&gt;driver = NULL;
+	usb_set_intfdata(iface, NULL);
+	iface-&gt;condition = USB_INTERFACE_UNBOUND;
+	mark_quiesced(iface);
+}
+EXPORT_SYMBOL(usb_driver_release_interface);
+
 /* returns 0 if no match, 1 if match */
 static int usb_match_one_id(struct usb_interface *interface,
 			    const struct usb_device_id *id)
@@ -402,6 +454,120 @@ int usb_device_match(struct device *dev, struct device_driver *drv)
 	return 0;
 }
 
+#ifdef	CONFIG_HOTPLUG
+
+/*
+ * This sends an uevent to userspace, typically helping to load driver
+ * or other modules, configure the device, and more.  Drivers can provide
+ * a MODULE_DEVICE_TABLE to help with module loading subtasks.
+ *
+ * We're called either from khubd (the typical case) or from root hub
+ * (init, kapmd, modprobe, rmmod, etc), but the agents need to handle
+ * delays in event delivery.  Use sysfs (and DEVPATH) to make sure the
+ * device (and this configuration!) are still present.
+ */
+static int usb_uevent(struct device *dev, char **envp, int num_envp,
+		      char *buffer, int buffer_size)
+{
+	struct usb_interface *intf;
+	struct usb_device *usb_dev;
+	struct usb_host_interface *alt;
+	int i = 0;
+	int length = 0;
+
+	if (!dev)
+		return -ENODEV;
+
+	/* driver is often null here; dev_dbg() would oops */
+	pr_debug ("usb %s: uevent\n", dev-&gt;bus_id);
+
+	/* Must check driver_data here, as on remove driver is always NULL */
+	if ((dev-&gt;driver == &amp;usb_generic_driver) ||
+	    (dev-&gt;driver_data == &amp;usb_generic_driver_data))
+		return 0;
+
+	intf = to_usb_interface(dev);
+	usb_dev = interface_to_usbdev (intf);
+	alt = intf-&gt;cur_altsetting;
+
+	if (usb_dev-&gt;devnum &lt; 0) {
+		pr_debug ("usb %s: already deleted?\n", dev-&gt;bus_id);
+		return -ENODEV;
+	}
+	if (!usb_dev-&gt;bus) {
+		pr_debug ("usb %s: bus removed?\n", dev-&gt;bus_id);
+		return -ENODEV;
+	}
+
+#ifdef	CONFIG_USB_DEVICEFS
+	/* If this is available, userspace programs can directly read
+	 * all the device descriptors we don't tell them about.  Or
+	 * even act as usermode drivers.
+	 *
+	 * FIXME reduce hardwired intelligence here
+	 */
+	if (add_uevent_var(envp, num_envp, &amp;i,
+			   buffer, buffer_size, &amp;length,
+			   "DEVICE=/proc/bus/usb/%03d/%03d",
+			   usb_dev-&gt;bus-&gt;busnum, usb_dev-&gt;devnum))
+		return -ENOMEM;
+#endif
+
+	/* per-device configurations are common */
+	if (add_uevent_var(envp, num_envp, &amp;i,
+			   buffer, buffer_size, &amp;length,
+			   "PRODUCT=%x/%x/%x",
+			   le16_to_cpu(usb_dev-&gt;descriptor.idVendor),
+			   le16_to_cpu(usb_dev-&gt;descriptor.idProduct),
+			   le16_to_cpu(usb_dev-&gt;descriptor.bcdDevice)))
+		return -ENOMEM;
+
+	/* class-based driver binding models */
+	if (add_uevent_var(envp, num_envp, &amp;i,
+			   buffer, buffer_size, &amp;length,
+			   "TYPE=%d/%d/%d",
+			   usb_dev-&gt;descriptor.bDeviceClass,
+			   usb_dev-&gt;descriptor.bDeviceSubClass,
+			   usb_dev-&gt;descriptor.bDeviceProtocol))
+		return -ENOMEM;
+
+	if (add_uevent_var(envp, num_envp, &amp;i,
+			   buffer, buffer_size, &amp;length,
+			   "INTERFACE=%d/%d/%d",
+			   alt-&gt;desc.bInterfaceClass,
+			   alt-&gt;desc.bInterfaceSubClass,
+			   alt-&gt;desc.bInterfaceProtocol))
+		return -ENOMEM;
+
+	if (add_uevent_var(envp, num_envp, &amp;i,
+			   buffer, buffer_size, &amp;length,
+			   "MODALIAS=usb:v%04Xp%04Xd%04Xdc%02Xdsc%02Xdp%02Xic%02Xisc%02Xip%02X",
+			   le16_to_cpu(usb_dev-&gt;descriptor.idVendor),
+			   le16_to_cpu(usb_dev-&gt;descriptor.idProduct),
+			   le16_to_cpu(usb_dev-&gt;descriptor.bcdDevice),
+			   usb_dev-&gt;descriptor.bDeviceClass,
+			   usb_dev-&gt;descriptor.bDeviceSubClass,
+			   usb_dev-&gt;descriptor.bDeviceProtocol,
+			   alt-&gt;desc.bInterfaceClass,
+			   alt-&gt;desc.bInterfaceSubClass,
+			   alt-&gt;desc.bInterfaceProtocol))
+		return -ENOMEM;
+
+	envp[i] = NULL;
+
+	return 0;
+}
+
+#else
+
+static int usb_uevent(struct device *dev, char **envp,
+			int num_envp, char *buffer, int buffer_size)
+{
+	return -ENODEV;
+}
+
+#endif	/* CONFIG_HOTPLUG */
+
 /**
  * usb_register_driver - register a USB driver
  * @new_driver: USB operations for the driver
@@ -469,3 +635,119 @@ void usb_deregister(struct usb_driver *driver)
 	usbfs_update_special();
 }
 EXPORT_SYMBOL_GPL_FUTURE(usb_deregister);
+
+#ifdef CONFIG_PM
+
+static int verify_suspended(struct device *dev, void *unused)
+{
+	if (dev-&gt;driver == NULL)
+		return 0;
+	return (dev-&gt;power.power_state.event == PM_EVENT_ON) ? -EBUSY : 0;
+}
+
+static int usb_generic_suspend(struct device *dev, pm_message_t message)
+{
+	struct usb_interface	*intf;
+	struct usb_driver	*driver;
+	int			status;
+
+	/* USB devices enter SUSPEND state through their hubs, but can be
+	 * marked for FREEZE as soon as their children are already idled.
+	 * But those semantics are useless, so we equate the two (sigh).
+	 */
+	if (dev-&gt;driver == &amp;usb_generic_driver) {
+		if (dev-&gt;power.power_state.event == message.event)
+			return 0;
+		/* we need to rule out bogus requests through sysfs */
+		status = device_for_each_child(dev, NULL, verify_suspended);
+		if (status)
+			return status;
+ 		return usb_port_suspend(to_usb_device(dev));
+	}
+
+	if ((dev-&gt;driver == NULL) ||
+	    (dev-&gt;driver_data == &amp;usb_generic_driver_data))
+		return 0;
+
+	intf = to_usb_interface(dev);
+	driver = to_usb_driver(dev-&gt;driver);
+
+	/* with no hardware, USB interfaces only use FREEZE and ON states */
+	if (!is_active(intf))
+		return 0;
+
+	if (driver-&gt;suspend &amp;&amp; driver-&gt;resume) {
+		status = driver-&gt;suspend(intf, message);
+		if (status)
+			dev_err(dev, "%s error %d\n", "suspend", status);
+		else
+			mark_quiesced(intf);
+	} else {
+		// FIXME else if there's no suspend method, disconnect...
+		dev_warn(dev, "no suspend for driver %s?\n", driver-&gt;name);
+		mark_quiesced(intf);
+		status = 0;
+	}
+	return status;
+}
+
+static int usb_generic_resume(struct device *dev)
+{
+	struct usb_interface	*intf;
+	struct usb_driver	*driver;
+	struct usb_device	*udev;
+	int			status;
+
+	if (dev-&gt;power.power_state.event == PM_EVENT_ON)
+		return 0;
+
+	/* mark things as "on" immediately, no matter what errors crop up */
+	dev-&gt;power.power_state.event = PM_EVENT_ON;
+
+	/* devices resume through their hubs */
+	if (dev-&gt;driver == &amp;usb_generic_driver) {
+		udev = to_usb_device(dev);
+		if (udev-&gt;state == USB_STATE_NOTATTACHED)
+			return 0;
+		return usb_port_resume(udev);
+	}
+
+	if ((dev-&gt;driver == NULL) ||
+	    (dev-&gt;driver_data == &amp;usb_generic_driver_data)) {
+		dev-&gt;power.power_state.event = PM_EVENT_FREEZE;
+		return 0;
+	}
+
+	intf = to_usb_interface(dev);
+	driver = to_usb_driver(dev-&gt;driver);
+
+	udev = interface_to_usbdev(intf);
+	if (udev-&gt;state == USB_STATE_NOTATTACHED)
+		return 0;
+
+	/* if driver was suspended, it has a resume method;
+	 * however, sysfs can wrongly mark things as suspended
+	 * (on the "no suspend method" FIXME path above)
+	 */
+	if (driver-&gt;resume) {
+		status = driver-&gt;resume(intf);
+		if (status) {
+			dev_err(dev, "%s error %d\n", "resume", status);
+			mark_quiesced(intf);
+		}
+	} else
+		dev_warn(dev, "no resume for driver %s?\n", driver-&gt;name);
+	return 0;
+}
+
+#endif /* CONFIG_PM */
+
+struct bus_type usb_bus_type = {
+	.name =		"usb",
+	.match =	usb_device_match,
+	.uevent =	usb_uevent,
+#ifdef CONFIG_PM
+	.suspend =	usb_generic_suspend,
+	.resume =	usb_generic_resume,
+#endif
+};
diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
new file mode 100644
index 000000000000..7bab9769b34f
--- /dev/null
+++ b/drivers/usb/core/generic.c
@@ -0,0 +1,53 @@
+/*
+ * drivers/usb/generic.c - generic driver for USB devices (not interfaces)
+ *
+ * (C) Copyright 2005 Greg Kroah-Hartman &lt;gregkh@suse.de&gt;
+ *
+ * based on drivers/usb/usb.c which had the following copyrights:
+ *	(C) Copyright Linus Torvalds 1999
+ *	(C) Copyright Johannes Erdfelt 1999-2001
+ *	(C) Copyright Andreas Gal 1999
+ *	(C) Copyright Gregory P. Smith 1999
+ *	(C) Copyright Deti Fliegl 1999 (new USB architecture)
+ *	(C) Copyright Randy Dunlap 2000
+ *	(C) Copyright David Brownell 2000-2004
+ *	(C) Copyright Yggdrasil Computing, Inc. 2000
+ *		(usb_device_id matching changes by Adam J. Richter)
+ *	(C) Copyright Greg Kroah-Hartman 2002-2003
+ *
+ */
+
+#include &lt;linux/config.h&gt;
+#include &lt;linux/usb.h&gt;
+#include "usb.h"
+
+static int generic_probe(struct device *dev)
+{
+	return 0;
+}
+static int generic_remove(struct device *dev)
+{
+	struct usb_device *udev = to_usb_device(dev);
+
+	/* if this is only an unbind, not a physical disconnect, then
+	 * unconfigure the device */
+	if (udev-&gt;state == USB_STATE_CONFIGURED)
+		usb_set_configuration(udev, 0);
+
+	/* in case the call failed or the device was suspended */
+	if (udev-&gt;state &gt;= USB_STATE_CONFIGURED)
+		usb_disable_device(udev, 0);
+	return 0;
+}
+
+struct device_driver usb_generic_driver = {
+	.owner = THIS_MODULE,
+	.name =	"usb",
+	.bus = &amp;usb_bus_type,
+	.probe = generic_probe,
+	.remove = generic_remove,
+};
+
+/* Fun hack to determine if the struct device is a
+ * usb device or a usb interface. */
+int usb_generic_driver_data;
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index b28a31b20308..0b8c67bcde60 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -112,87 +112,6 @@ struct usb_host_interface *usb_altnum_to_altsetting(struct usb_interface *intf,
 	return NULL;
 }
 
-/**
- * usb_driver_claim_interface - bind a driver to an interface
- * @driver: the driver to be bound
- * @iface: the interface to which it will be bound; must be in the
- *	usb device's active configuration
- * @priv: driver data associated with that interface
- *
- * This is used by usb device drivers that need to claim more than one
- * interface on a device when probing (audio and acm are current examples).
- * No device driver should directly modify internal usb_interface or
- * usb_device structure members.
- *
- * Few drivers should need to use this routine, since the most natural
- * way to bind to an interface is to return the private data from
- * the driver's probe() method.
- *
- * Callers must own the device lock and the driver model's usb_bus_type.subsys
- * writelock.  So driver probe() entries don't need extra locking,
- * but other call contexts may need to explicitly claim those locks.
- */
-int usb_driver_claim_interface(struct usb_driver *driver,
-				struct usb_interface *iface, void* priv)
-{
-	struct device *dev = &amp;iface-&gt;dev;
-
-	if (dev-&gt;driver)
-		return -EBUSY;
-
-	dev-&gt;driver = &amp;driver-&gt;driver;
-	usb_set_intfdata(iface, priv);
-	iface-&gt;condition = USB_INTERFACE_BOUND;
-	mark_active(iface);
-
-	/* if interface was already added, bind now; else let
-	 * the future device_add() bind it, bypassing probe()
-	 */
-	if (device_is_registered(dev))
-		device_bind_driver(dev);
-
-	return 0;
-}
-
-/**
- * usb_driver_release_interface - unbind a driver from an interface
- * @driver: the driver to be unbound
- * @iface: the interface from which it will be unbound
- *
- * This can be used by drivers to release an interface without waiting
- * for their disconnect() methods to be called.  In typical cases this
- * also causes the driver disconnect() method to be called.
- *
- * This call is synchronous, and may not be used in an interrupt context.
- * Callers must own the device lock and the driver model's usb_bus_type.subsys
- * writelock.  So driver disconnect() entries don't need extra locking,
- * but other call contexts may need to explicitly claim those locks.
- */
-void usb_driver_release_interface(struct usb_driver *driver,
-					struct usb_interface *iface)
-{
-	struct device *dev = &amp;iface-&gt;dev;
-
-	/* this should never happen, don't release something that's not ours */
-	if (!dev-&gt;driver || dev-&gt;driver != &amp;driver-&gt;driver)
-		return;
-
-	/* don't release from within disconnect() */
-	if (iface-&gt;condition != USB_INTERFACE_BOUND)
-		return;
-
-	/* don't release if the interface hasn't been added yet */
-	if (device_is_registered(dev)) {
-		iface-&gt;condition = USB_INTERFACE_UNBINDING;
-		device_release_driver(dev);
-	}
-
-	dev-&gt;driver = NULL;
-	usb_set_intfdata(iface, NULL);
-	iface-&gt;condition = USB_INTERFACE_UNBOUND;
-	mark_quiesced(iface);
-}
-
 struct find_interface_arg {
 	int minor;
 	struct usb_interface *interface;
@@ -234,120 +153,6 @@ struct usb_interface *usb_find_interface(struct usb_driver *drv, int minor)
 	return argb.interface;
 }
 
-#ifdef	CONFIG_HOTPLUG
-
-/*
- * This sends an uevent to userspace, typically helping to load driver
- * or other modules, configure the device, and more.  Drivers can provide
- * a MODULE_DEVICE_TABLE to help with module loading subtasks.
- *
- * We're called either from khubd (the typical case) or from root hub
- * (init, kapmd, modprobe, rmmod, etc), but the agents need to handle
- * delays in event delivery.  Use sysfs (and DEVPATH) to make sure the
- * device (and this configuration!) are still present.
- */
-static int usb_uevent(struct device *dev, char **envp, int num_envp,
-		      char *buffer, int buffer_size)
-{
-	struct usb_interface *intf;
-	struct usb_device *usb_dev;
-	struct usb_host_interface *alt;
-	int i = 0;
-	int length = 0;
-
-	if (!dev)
-		return -ENODEV;
-
-	/* driver is often null here; dev_dbg() would oops */
-	pr_debug ("usb %s: uevent\n", dev-&gt;bus_id);
-
-	/* Must check driver_data here, as on remove driver is always NULL */
-	if ((dev-&gt;driver == &amp;usb_generic_driver) || 
-	    (dev-&gt;driver_data == &amp;usb_generic_driver_data))
-		return 0;
-
-	intf = to_usb_interface(dev);
-	usb_dev = interface_to_usbdev (intf);
-	alt = intf-&gt;cur_altsetting;
-
-	if (usb_dev-&gt;devnum &lt; 0) {
-		pr_debug ("usb %s: already deleted?\n", dev-&gt;bus_id);
-		return -ENODEV;
-	}
-	if (!usb_dev-&gt;bus) {
-		pr_debug ("usb %s: bus removed?\n", dev-&gt;bus_id);
-		return -ENODEV;
-	}
-
-#ifdef	CONFIG_USB_DEVICEFS
-	/* If this is available, userspace programs can directly read
-	 * all the device descriptors we don't tell them about.  Or
-	 * even act as usermode drivers.
-	 *
-	 * FIXME reduce hardwired intelligence here
-	 */
-	if (add_uevent_var(envp, num_envp, &amp;i,
-			   buffer, buffer_size, &amp;length,
-			   "DEVICE=/proc/bus/usb/%03d/%03d",
-			   usb_dev-&gt;bus-&gt;busnum, usb_dev-&gt;devnum))
-		return -ENOMEM;
-#endif
-
-	/* per-device configurations are common */
-	if (add_uevent_var(envp, num_envp, &amp;i,
-			   buffer, buffer_size, &amp;length,
-			   "PRODUCT=%x/%x/%x",
-			   le16_to_cpu(usb_dev-&gt;descriptor.idVendor),
-			   le16_to_cpu(usb_dev-&gt;descriptor.idProduct),
-			   le16_to_cpu(usb_dev-&gt;descriptor.bcdDevice)))
-		return -ENOMEM;
-
-	/* class-based driver binding models */
-	if (add_uevent_var(envp, num_envp, &amp;i,
-			   buffer, buffer_size, &amp;length,
-			   "TYPE=%d/%d/%d",
-			   usb_dev-&gt;descriptor.bDeviceClass,
-			   usb_dev-&gt;descriptor.bDeviceSubClass,
-			   usb_dev-&gt;descriptor.bDeviceProtocol))
-		return -ENOMEM;
-
-	if (add_uevent_var(envp, num_envp, &amp;i,
-			   buffer, buffer_size, &amp;length,
-			   "INTERFACE=%d/%d/%d",
-			   alt-&gt;desc.bInterfaceClass,
-			   alt-&gt;desc.bInterfaceSubClass,
-			   alt-&gt;desc.bInterfaceProtocol))
-		return -ENOMEM;
-
-	if (add_uevent_var(envp, num_envp, &amp;i,
-			   buffer, buffer_size, &amp;length,
-			   "MODALIAS=usb:v%04Xp%04Xd%04Xdc%02Xdsc%02Xdp%02Xic%02Xisc%02Xip%02X",
-			   le16_to_cpu(usb_dev-&gt;descriptor.idVendor),
-			   le16_to_cpu(usb_dev-&gt;descriptor.idProduct),
-			   le16_to_cpu(usb_dev-&gt;descriptor.bcdDevice),
-			   usb_dev-&gt;descriptor.bDeviceClass,
-			   usb_dev-&gt;descriptor.bDeviceSubClass,
-			   usb_dev-&gt;descriptor.bDeviceProtocol,
-			   alt-&gt;desc.bInterfaceClass,
-			   alt-&gt;desc.bInterfaceSubClass,
-			   alt-&gt;desc.bInterfaceProtocol))
-		return -ENOMEM;
-
-	envp[i] = NULL;
-
-	return 0;
-}
-
-#else
-
-static int usb_uevent(struct device *dev, char **envp,
-			int num_envp, char *buffer, int buffer_size)
-{
-	return -ENODEV;
-}
-
-#endif	/* CONFIG_HOTPLUG */
-
 /**
  * usb_release_dev - free a usb device structure when all users of it are finished.
  * @dev: device that's been disconnected
@@ -990,116 +795,6 @@ void usb_buffer_unmap_sg (struct usb_device *dev, unsigned pipe,
 			usb_pipein (pipe) ? DMA_FROM_DEVICE : DMA_TO_DEVICE);
 }
 
-static int verify_suspended(struct device *dev, void *unused)
-{
-	if (dev-&gt;driver == NULL)
-		return 0;
-	return (dev-&gt;power.power_state.event == PM_EVENT_ON) ? -EBUSY : 0;
-}
-
-static int usb_generic_suspend(struct device *dev, pm_message_t message)
-{
-	struct usb_interface	*intf;
-	struct usb_driver	*driver;
-	int			status;
-
-	/* USB devices enter SUSPEND state through their hubs, but can be
-	 * marked for FREEZE as soon as their children are already idled.
-	 * But those semantics are useless, so we equate the two (sigh).
-	 */
-	if (dev-&gt;driver == &amp;usb_generic_driver) {
-		if (dev-&gt;power.power_state.event == message.event)
-			return 0;
-		/* we need to rule out bogus requests through sysfs */
-		status = device_for_each_child(dev, NULL, verify_suspended);
-		if (status)
-			return status;
- 		return usb_port_suspend(to_usb_device(dev));
-	}
-
-	if ((dev-&gt;driver == NULL) ||
-	    (dev-&gt;driver_data == &amp;usb_generic_driver_data))
-		return 0;
-
-	intf = to_usb_interface(dev);
-	driver = to_usb_driver(dev-&gt;driver);
-
-	/* with no hardware, USB interfaces only use FREEZE and ON states */
-	if (!is_active(intf))
-		return 0;
-
-	if (driver-&gt;suspend &amp;&amp; driver-&gt;resume) {
-		status = driver-&gt;suspend(intf, message);
-		if (status)
-			dev_err(dev, "%s error %d\n", "suspend", status);
-		else
-			mark_quiesced(intf);
-	} else {
-		// FIXME else if there's no suspend method, disconnect...
-		dev_warn(dev, "no suspend for driver %s?\n", driver-&gt;name);
-		mark_quiesced(intf);
-		status = 0;
-	}
-	return status;
-}
-
-static int usb_generic_resume(struct device *dev)
-{
-	struct usb_interface	*intf;
-	struct usb_driver	*driver;
-	struct usb_device	*udev;
-	int			status;
-
-	if (dev-&gt;power.power_state.event == PM_EVENT_ON)
-		return 0;
-
-	/* mark things as "on" immediately, no matter what errors crop up */
-	dev-&gt;power.power_state.event = PM_EVENT_ON;
-
-	/* devices resume through their hubs */
-	if (dev-&gt;driver == &amp;usb_generic_driver) {
-		udev = to_usb_device(dev);
-		if (udev-&gt;state == USB_STATE_NOTATTACHED)
-			return 0;
-		return usb_port_resume(udev);
-	}
-
-	if ((dev-&gt;driver == NULL) ||
-	    (dev-&gt;driver_data == &amp;usb_generic_driver_data)) {
-		dev-&gt;power.power_state.event = PM_EVENT_FREEZE;
-		return 0;
-	}
-
-	intf = to_usb_interface(dev);
-	driver = to_usb_driver(dev-&gt;driver);
-
-	udev = interface_to_usbdev(intf);
-	if (udev-&gt;state == USB_STATE_NOTATTACHED)
-		return 0;
-
-	/* if driver was suspended, it has a resume method;
-	 * however, sysfs can wrongly mark things as suspended
-	 * (on the "no suspend method" FIXME path above)
-	 */
-	if (driver-&gt;resume) {
-		status = driver-&gt;resume(intf);
-		if (status) {
-			dev_err(dev, "%s error %d\n", "resume", status);
-			mark_quiesced(intf);
-		}
-	} else
-		dev_warn(dev, "no resume for driver %s?\n", driver-&gt;name);
-	return 0;
-}
-
-struct bus_type usb_bus_type = {
-	.name =		"usb",
-	.match =	usb_device_match,
-	.uevent =	usb_uevent,
-	.suspend =	usb_generic_suspend,
-	.resume =	usb_generic_resume,
-};
-
 /* format to disable USB on kernel command line is: nousb */
 __module_param_call("", nousb, param_set_bool, param_get_bool, &amp;nousb, 0444);
 
@@ -1203,8 +898,6 @@ EXPORT_SYMBOL(usb_hub_tt_clear_buffer);
 
 EXPORT_SYMBOL(usb_lock_device_for_reset);
 
-EXPORT_SYMBOL(usb_driver_claim_interface);
-EXPORT_SYMBOL(usb_driver_release_interface);
 EXPORT_SYMBOL(usb_find_interface);
 EXPORT_SYMBOL(usb_ifnum_to_if);
 EXPORT_SYMBOL(usb_altnum_to_altsetting);
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 5a4eff5eec86..82d397a6f773 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -33,9 +33,9 @@ extern void usb_host_cleanup(void);
 extern int usb_port_suspend(struct usb_device *dev);
 extern int usb_port_resume(struct usb_device *dev);
 
+extern struct bus_type usb_bus_type;
 extern struct device_driver usb_generic_driver;
 extern int usb_generic_driver_data;
-extern int usb_device_match(struct device *dev, struct device_driver *drv);
 
 /* Interfaces and their "power state" are owned by usbcore */
 </pre><hr><pre>commit 140d8f687457c40a66af362838fac0d7893e7df5
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Jul 1 22:07:21 2006 -0400

    usbcore: rename usb_suspend_device to usb_port_suspend
    
    This revised patch (as715b) renames usb_suspend_device to
    usb_port_suspend, usb_resume_device to usb_port_resume, and
    finish_device_resume to finish_port_resume.  There was no objection to
    the original version of the patch so this should be okay to apply.
    
    The revision was needed only because I have re-arranged the order of the
    earlier patches.
    
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 26c8cb5f3e67..b00514d9a605 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1407,9 +1407,9 @@ int usb_new_device(struct usb_device *udev)
 		 * (Includes HNP test device.)
 		 */
 		if (udev-&gt;bus-&gt;b_hnp_enable || udev-&gt;bus-&gt;is_b_host) {
-			static int __usb_suspend_device(struct usb_device *,
+			static int __usb_port_suspend(struct usb_device *,
 						int port1);
-			err = __usb_suspend_device(udev, udev-&gt;bus-&gt;otg_port);
+			err = __usb_port_suspend(udev, udev-&gt;bus-&gt;otg_port);
 			if (err &lt; 0)
 				dev_dbg(&amp;udev-&gt;dev, "HNP fail, %d\n", err);
 		}
@@ -1684,7 +1684,7 @@ static int hub_port_suspend(struct usb_hub *hub, int port1,
  * the root hub for their bus goes into global suspend ... so we don't
  * (falsely) update the device power state to say it suspended.
  */
-static int __usb_suspend_device (struct usb_device *udev, int port1)
+static int __usb_port_suspend (struct usb_device *udev, int port1)
 {
 	int	status = 0;
 
@@ -1712,8 +1712,8 @@ static int __usb_suspend_device (struct usb_device *udev, int port1)
 		}
 	}
 
-	/* we only change a device's upstream USB link.
-	 * root hubs have no upstream USB link.
+	/* we change the device's upstream USB link,
+	 * but root hubs have no upstream USB link.
 	 */
 	if (udev-&gt;parent)
 		status = hub_port_suspend(hdev_to_hub(udev-&gt;parent), port1,
@@ -1727,14 +1727,14 @@ static int __usb_suspend_device (struct usb_device *udev, int port1)
 #endif
 
 /*
- * usb_suspend_device - suspend a usb device
+ * usb_port_suspend - suspend a usb device's upstream port
  * @udev: device that's no longer in active use
  * Context: must be able to sleep; device not locked; pm locks held
  *
  * Suspends a USB device that isn't in active use, conserving power.
  * Devices may wake out of a suspend, if anything important happens,
  * using the remote wakeup mechanism.  They may also be taken out of
- * suspend by the host, using usb_resume_device().  It's also routine
+ * suspend by the host, using usb_port_resume().  It's also routine
  * to disconnect devices while they are suspended.
  *
  * This only affects the USB hardware for a device; its interfaces
@@ -1746,12 +1746,12 @@ static int __usb_suspend_device (struct usb_device *udev, int port1)
  *
  * Returns 0 on success, else negative errno.
  */
-int usb_suspend_device(struct usb_device *udev)
+int usb_port_suspend(struct usb_device *udev)
 {
 #ifdef	CONFIG_USB_SUSPEND
 	if (udev-&gt;state == USB_STATE_NOTATTACHED)
 		return -ENODEV;
-	return __usb_suspend_device(udev, udev-&gt;portnum);
+	return __usb_port_suspend(udev, udev-&gt;portnum);
 #else
 	/* NOTE:  udev-&gt;state unchanged, it's not lying ... */
 	udev-&gt;dev.power.power_state = PMSG_SUSPEND;
@@ -1767,7 +1767,7 @@ int usb_suspend_device(struct usb_device *udev)
  * resume (by host) or remote wakeup (by device) ... now see what changed
  * in the tree that's rooted at this device.
  */
-static int finish_device_resume(struct usb_device *udev)
+static int finish_port_resume(struct usb_device *udev)
 {
 	int	status;
 	u16	devstatus;
@@ -1891,7 +1891,7 @@ hub_port_resume(struct usb_hub *hub, int port1, struct usb_device *udev)
 			/* TRSMRCY = 10 msec */
 			msleep(10);
 			if (udev)
-				status = finish_device_resume(udev);
+				status = finish_port_resume(udev);
 		}
 	}
 	if (status &lt; 0)
@@ -1903,7 +1903,7 @@ hub_port_resume(struct usb_hub *hub, int port1, struct usb_device *udev)
 #endif
 
 /*
- * usb_resume_device - re-activate a suspended usb device
+ * usb_port_resume - re-activate a suspended usb device's upstream port
  * @udev: device to re-activate
  * Context: must be able to sleep; device not locked; pm locks held
  *
@@ -1915,14 +1915,16 @@ hub_port_resume(struct usb_hub *hub, int port1, struct usb_device *udev)
  *
  * Returns 0 on success, else negative errno.
  */
-int usb_resume_device(struct usb_device *udev)
+int usb_port_resume(struct usb_device *udev)
 {
 	int	status;
 
 	if (udev-&gt;state == USB_STATE_NOTATTACHED)
 		return -ENODEV;
 
-	/* selective resume of one downstream hub-to-device port */
+	/* we change the device's upstream USB link,
+	 * but root hubs have no upstream USB link.
+	 */
 	if (udev-&gt;parent) {
 #ifdef	CONFIG_USB_SUSPEND
 		if (udev-&gt;state == USB_STATE_SUSPENDED) {
@@ -1934,7 +1936,7 @@ int usb_resume_device(struct usb_device *udev)
 #endif
 			status = 0;
 	} else
-		status = finish_device_resume(udev);
+		status = finish_port_resume(udev);
 	if (status &lt; 0)
 		dev_dbg(&amp;udev-&gt;dev, "can't resume, status %d\n",
 			status);
@@ -1962,7 +1964,7 @@ static int remote_wakeup(struct usb_device *udev)
 		dev_dbg(&amp;udev-&gt;dev, "RESUME (wakeup)\n");
 		/* TRSMRCY = 10 msec */
 		msleep(10);
-		status = finish_device_resume(udev);
+		status = finish_port_resume(udev);
 	}
 	usb_unlock_device(udev);
 #endif
@@ -2069,7 +2071,7 @@ static int hub_resume(struct usb_interface *intf)
 		if (portstat &amp; USB_PORT_STAT_SUSPEND)
 			status = hub_port_resume(hub, port1, udev);
 		else {
-			status = finish_device_resume(udev);
+			status = finish_port_resume(udev);
 			if (status &lt; 0) {
 				dev_dbg(&amp;intf-&gt;dev, "resume port %d --&gt; %d\n",
 					port1, status);
@@ -3128,6 +3130,7 @@ int usb_reset_device(struct usb_device *udev)
 	hub_port_logical_disconnect(parent_hub, port1);
 	return -ENODEV;
 }
+EXPORT_SYMBOL(usb_reset_device);
 
 /**
  * usb_reset_composite_device - warn interface drivers and perform a USB port reset
@@ -3206,3 +3209,4 @@ int usb_reset_composite_device(struct usb_device *udev,
 
 	return ret;
 }
+EXPORT_SYMBOL(usb_reset_composite_device);
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index ab766e0fe4ef..b28a31b20308 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -1014,7 +1014,7 @@ static int usb_generic_suspend(struct device *dev, pm_message_t message)
 		status = device_for_each_child(dev, NULL, verify_suspended);
 		if (status)
 			return status;
- 		return usb_suspend_device (to_usb_device(dev));
+ 		return usb_port_suspend(to_usb_device(dev));
 	}
 
 	if ((dev-&gt;driver == NULL) ||
@@ -1061,7 +1061,7 @@ static int usb_generic_resume(struct device *dev)
 		udev = to_usb_device(dev);
 		if (udev-&gt;state == USB_STATE_NOTATTACHED)
 			return 0;
-		return usb_resume_device (to_usb_device(dev));
+		return usb_port_resume(udev);
 	}
 
 	if ((dev-&gt;driver == NULL) ||
@@ -1209,9 +1209,6 @@ EXPORT_SYMBOL(usb_find_interface);
 EXPORT_SYMBOL(usb_ifnum_to_if);
 EXPORT_SYMBOL(usb_altnum_to_altsetting);
 
-EXPORT_SYMBOL(usb_reset_device);
-EXPORT_SYMBOL(usb_reset_composite_device);
-
 EXPORT_SYMBOL(__usb_get_extra_descriptor);
 
 EXPORT_SYMBOL(usb_find_device);
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 1217fbbe5829..5a4eff5eec86 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -30,8 +30,8 @@ extern void usb_major_cleanup(void);
 extern int usb_host_init(void);
 extern void usb_host_cleanup(void);
 
-extern int usb_suspend_device(struct usb_device *dev);
-extern int usb_resume_device(struct usb_device *dev);
+extern int usb_port_suspend(struct usb_device *dev);
+extern int usb_port_resume(struct usb_device *dev);
 
 extern struct device_driver usb_generic_driver;
 extern int usb_generic_driver_data;</pre><hr><pre>commit 121e287cb554f3d3402c85a1950d852691b08f5c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Jul 1 22:06:36 2006 -0400

    usb-skeleton: don't submit URBs after disconnection
    
    This patch (as712b) is a slight revision of one submitted earlier.  It
    fixes the usb-skeleton example driver so that it won't try to submit
    URBs after skel_disconnect() has returned.  This could cause errors, if
    the driver was unbound and then a different driver was bound to the
    device.  It also fixes a couple of small bugs in the skel_write()
    routine.
    
    The revised patch uses a slightly different test, suggested by Dave
    Brownell, for determining whether to free a transfer buffer.  It's a
    little clearer than the earlier version.
    
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/usb-skeleton.c b/drivers/usb/usb-skeleton.c
index b362039792b3..33f0e81c58d3 100644
--- a/drivers/usb/usb-skeleton.c
+++ b/drivers/usb/usb-skeleton.c
@@ -1,5 +1,5 @@
 /*
- * USB Skeleton driver - 2.0
+ * USB Skeleton driver - 2.1
  *
  * Copyright (C) 2001-2004 Greg Kroah-Hartman (greg@kroah.com)
  *
@@ -8,8 +8,7 @@
  *	published by the Free Software Foundation, version 2.
  *
  * This driver is based on the 2.6.3 version of drivers/usb/usb-skeleton.c 
- * but has been rewritten to be easy to read and use, as no locks are now
- * needed anymore.
+ * but has been rewritten to be easier to read and use.
  *
  */
 
@@ -21,6 +20,7 @@
 #include &lt;linux/kref.h&gt;
 #include &lt;asm/uaccess.h&gt;
 #include &lt;linux/usb.h&gt;
+#include &lt;linux/mutex.h&gt;
 
 
 /* Define these values to match your devices */
@@ -52,6 +52,7 @@ struct usb_skel {
 	__u8			bulk_in_endpointAddr;	/* the address of the bulk in endpoint */
 	__u8			bulk_out_endpointAddr;	/* the address of the bulk out endpoint */
 	struct kref		kref;
+	struct mutex		io_mutex;		/* synchronize I/O with disconnect */
 };
 #define to_skel_dev(d) container_of(d, struct usb_skel, kref)
 
@@ -119,7 +120,13 @@ static ssize_t skel_read(struct file *file, char *buffer, size_t count, loff_t *
 	int bytes_read;
 
 	dev = (struct usb_skel *)file-&gt;private_data;
-	
+
+	mutex_lock(&amp;dev-&gt;io_mutex);
+	if (!dev-&gt;interface) {		/* disconnect() was called */
+		retval = -ENODEV;
+		goto exit;
+	}
+
 	/* do a blocking bulk read to get data from the device */
 	retval = usb_bulk_msg(dev-&gt;udev,
 			      usb_rcvbulkpipe(dev-&gt;udev, dev-&gt;bulk_in_endpointAddr),
@@ -135,6 +142,8 @@ static ssize_t skel_read(struct file *file, char *buffer, size_t count, loff_t *
 			retval = bytes_read;
 	}
 
+exit:
+	mutex_unlock(&amp;dev-&gt;io_mutex);
 	return retval;
 }
 
@@ -179,6 +188,12 @@ static ssize_t skel_write(struct file *file, const char *user_buffer, size_t cou
 		goto exit;
 	}
 
+	mutex_lock(&amp;dev-&gt;io_mutex);
+	if (!dev-&gt;interface) {		/* disconnect() was called */
+		retval = -ENODEV;
+		goto error;
+	}
+
 	/* create a urb, and a buffer for it, and copy the data to the urb */
 	urb = usb_alloc_urb(0, GFP_KERNEL);
 	if (!urb) {
@@ -213,13 +228,18 @@ static ssize_t skel_write(struct file *file, const char *user_buffer, size_t cou
 	/* release our reference to this urb, the USB core will eventually free it entirely */
 	usb_free_urb(urb);
 
-exit:
+	mutex_unlock(&amp;dev-&gt;io_mutex);
 	return writesize;
 
 error:
-	usb_buffer_free(dev-&gt;udev, writesize, buf, urb-&gt;transfer_dma);
-	usb_free_urb(urb);
+	if (urb) {
+		usb_buffer_free(dev-&gt;udev, writesize, buf, urb-&gt;transfer_dma);
+		usb_free_urb(urb);
+	}
+	mutex_unlock(&amp;dev-&gt;io_mutex);
 	up(&amp;dev-&gt;limit_sem);
+
+exit:
 	return retval;
 }
 
@@ -258,6 +278,7 @@ static int skel_probe(struct usb_interface *interface, const struct usb_device_i
 	}
 	kref_init(&amp;dev-&gt;kref);
 	sema_init(&amp;dev-&gt;limit_sem, WRITES_IN_FLIGHT);
+	mutex_init(&amp;dev-&gt;io_mutex);
 
 	dev-&gt;udev = usb_get_dev(interface_to_usbdev(interface));
 	dev-&gt;interface = interface;
@@ -334,6 +355,11 @@ static void skel_disconnect(struct usb_interface *interface)
 	/* give back our minor */
 	usb_deregister_dev(interface, &amp;skel_class);
 
+	/* prevent more I/O from starting */
+	mutex_lock(&amp;dev-&gt;io_mutex);
+	dev-&gt;interface = NULL;
+	mutex_unlock(&amp;dev-&gt;io_mutex);
+
 	unlock_kernel();
 
 	/* decrement our usage count */</pre>
    <div class="pagination">
        <a href='2_120.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><span>[121]</span><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_122.html'>Next&gt;&gt;</a>
    <div>
</body>
