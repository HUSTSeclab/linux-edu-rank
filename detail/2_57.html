<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_56.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><span>[57]</span><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_58.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 97b2f900335befbf6c4323ea6fd560ea5df4d154
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jun 7 11:31:05 2011 -0400

    USB: CONFIG_USB_GADGET_DUALSPEED is not user-configurable
    
    This patch (as1468) changes the Kconfig definition for
    USB_GADGET_DUALSPEED.  This option is determined entirely by which
    device controller drivers are to be built, through Select statements;
    it does not need to be (and should not be) configurable by the user.
    
    Also, the "default n" line is superfluous -- everything defaults to N.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Felipe Balbi &lt;balbi@ti.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/Kconfig b/drivers/usb/gadget/Kconfig
index 58456d1aec21..029e288805b6 100644
--- a/drivers/usb/gadget/Kconfig
+++ b/drivers/usb/gadget/Kconfig
@@ -632,13 +632,10 @@ config USB_DUMMY_HCD
 
 endchoice
 
+# Selected by UDC drivers that support high-speed operation.
 config USB_GADGET_DUALSPEED
 	bool
 	depends on USB_GADGET
-	default n
-	help
-	  Means that gadget drivers should include extra descriptors
-	  and code to handle dual-speed controllers.
 
 #
 # USB Gadget Drivers</pre><hr><pre>commit c5c69f3f0dcf9b569c8f3ad67f3af92cfcedac43
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jun 7 11:33:01 2011 -0400

    USB: dummy-hcd needs the has_tt flag
    
    Like with other host controllers capable of operating at both high
    speed and full speed, we need to indicate that the emulated controller
    presented by dummy-hcd has this ability.  Otherwise usbcore will not
    accept full-speed gadgets under dummy-hcd.  This patch (as1469) sets
    the appropriate has_tt flag.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index 61ff927928ab..d3dcabc1a5fc 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -1906,6 +1906,7 @@ static int dummy_hcd_probe(struct platform_device *pdev)
 	if (!hcd)
 		return -ENOMEM;
 	the_controller = hcd_to_dummy (hcd);
+	hcd-&gt;has_tt = 1;
 
 	retval = usb_add_hcd(hcd, 0, 0);
 	if (retval != 0) {</pre><hr><pre>commit 21c13a4f7bc185552c4b402b792c3bbb9aa69df0
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jun 7 11:35:52 2011 -0400

    usb-storage: redo incorrect reads
    
    Some USB mass-storage devices have bugs that cause them not to handle
    the first READ(10) command they receive correctly.  The Corsair
    Padlock v2 returns completely bogus data for its first read (possibly
    it returns the data in encrypted form even though the device is
    supposed to be unlocked).  The Feiya SD/SDHC card reader fails to
    complete the first READ(10) command after it is plugged in or after a
    new card is inserted, returning a status code that indicates it thinks
    the command was invalid, which prevents the kernel from retrying the
    read.
    
    Since the first read of a new device or a new medium is for the
    partition sector, the kernel is unable to retrieve the device's
    partition table.  Users have to manually issue an "hdparm -z" or
    "blockdev --rereadpt" command before they can access the device.
    
    This patch (as1470) works around the problem.  It adds a new quirk
    flag, US_FL_INVALID_READ10, indicating that the first READ(10) should
    always be retried immediately, as should any failing READ(10) commands
    (provided the preceding READ(10) command succeeded, to avoid getting
    stuck in a loop).  The patch also adds appropriate unusual_devs
    entries containing the new flag.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Sven Geggus &lt;sven-usbst@geggus.net&gt;
    Tested-by: Paul Hartman &lt;paul.hartman+linux@gmail.com&gt;
    CC: Matthew Dharm &lt;mdharm-usb@one-eyed-alien.net&gt;
    CC: &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt
index d9a203b058f1..fd248a318211 100644
--- a/Documentation/kernel-parameters.txt
+++ b/Documentation/kernel-parameters.txt
@@ -2598,6 +2598,8 @@ bytes respectively. Such letter suffixes can also be entirely omitted.
 					unlock ejectable media);
 				m = MAX_SECTORS_64 (don't transfer more
 					than 64 sectors = 32 KB at a time);
+				n = INITIAL_READ10 (force a retry of the
+					initial READ(10) command);
 				o = CAPACITY_OK (accept the capacity
 					reported by the device);
 				r = IGNORE_RESIDUE (the device reports
diff --git a/drivers/usb/storage/transport.c b/drivers/usb/storage/transport.c
index 00418995d8e9..e8ae21b2d387 100644
--- a/drivers/usb/storage/transport.c
+++ b/drivers/usb/storage/transport.c
@@ -819,6 +819,35 @@ void usb_stor_invoke_transport(struct scsi_cmnd *srb, struct us_data *us)
 		}
 	}
 
+	/*
+	 * Some devices don't work or return incorrect data the first
+	 * time they get a READ(10) command, or for the first READ(10)
+	 * after a media change.  If the INITIAL_READ10 flag is set,
+	 * keep track of whether READ(10) commands succeed.  If the
+	 * previous one succeeded and this one failed, set the REDO_READ10
+	 * flag to force a retry.
+	 */
+	if (unlikely((us-&gt;fflags &amp; US_FL_INITIAL_READ10) &amp;&amp;
+			srb-&gt;cmnd[0] == READ_10)) {
+		if (srb-&gt;result == SAM_STAT_GOOD) {
+			set_bit(US_FLIDX_READ10_WORKED, &amp;us-&gt;dflags);
+		} else if (test_bit(US_FLIDX_READ10_WORKED, &amp;us-&gt;dflags)) {
+			clear_bit(US_FLIDX_READ10_WORKED, &amp;us-&gt;dflags);
+			set_bit(US_FLIDX_REDO_READ10, &amp;us-&gt;dflags);
+		}
+
+		/*
+		 * Next, if the REDO_READ10 flag is set, return a result
+		 * code that will cause the SCSI core to retry the READ(10)
+		 * command immediately.
+		 */
+		if (test_bit(US_FLIDX_REDO_READ10, &amp;us-&gt;dflags)) {
+			clear_bit(US_FLIDX_REDO_READ10, &amp;us-&gt;dflags);
+			srb-&gt;result = DID_IMM_RETRY &lt;&lt; 16;
+			srb-&gt;sense_buffer[0] = 0;
+		}
+	}
+
 	/* Did we transfer less than the minimum amount required? */
 	if ((srb-&gt;result == SAM_STAT_GOOD || srb-&gt;sense_buffer[2] == 0) &amp;&amp;
 			scsi_bufflen(srb) - scsi_get_resid(srb) &lt; srb-&gt;underflow)
diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index c1602b8c5594..ccff3483eebc 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -1114,6 +1114,16 @@ UNUSUAL_DEV( 0x090c, 0x1132, 0x0000, 0xffff,
 		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
 		US_FL_FIX_CAPACITY ),
 
+/* Reported by Paul Hartman &lt;paul.hartman+linux@gmail.com&gt;
+ * This card reader returns "Illegal Request, Logical Block Address
+ * Out of Range" for the first READ(10) after a new card is inserted.
+ */
+UNUSUAL_DEV(  0x090c, 0x6000, 0x0100, 0x0100,
+		"Feiya",
+		"SD/SDHC Card Reader",
+		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
+		US_FL_INITIAL_READ10 ),
+
 /* This Pentax still camera is not conformant
  * to the USB storage specification: -
  * - It does not like the INQUIRY command. So we must handle this command
@@ -1888,6 +1898,15 @@ UNUSUAL_DEV( 0x1908, 0x3335, 0x0200, 0x0200,
 		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
 		US_FL_NO_READ_DISC_INFO ),
 
+/* Reported by Sven Geggus &lt;sven-usbst@geggus.net&gt;
+ * This encrypted pen drive returns bogus data for the initial READ(10).
+ */
+UNUSUAL_DEV(  0x1b1c, 0x1ab5, 0x0200, 0x0200,
+		"Corsair",
+		"Padlock v2",
+		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
+		US_FL_INITIAL_READ10 ),
+
 /* Patch by Richard Sch?tz &lt;r.schtz@t-online.de&gt;
  * This external hard drive enclosure uses a JMicron chip which
  * needs the US_FL_IGNORE_RESIDUE flag to work properly. */
diff --git a/drivers/usb/storage/usb.c b/drivers/usb/storage/usb.c
index 5ee7ac42e08f..0ca095820f3e 100644
--- a/drivers/usb/storage/usb.c
+++ b/drivers/usb/storage/usb.c
@@ -440,7 +440,8 @@ static void adjust_quirks(struct us_data *us)
 			US_FL_NOT_LOCKABLE | US_FL_MAX_SECTORS_64 |
 			US_FL_CAPACITY_OK | US_FL_IGNORE_RESIDUE |
 			US_FL_SINGLE_LUN | US_FL_NO_WP_DETECT |
-			US_FL_NO_READ_DISC_INFO | US_FL_NO_READ_CAPACITY_16);
+			US_FL_NO_READ_DISC_INFO | US_FL_NO_READ_CAPACITY_16 |
+			US_FL_INITIAL_READ10);
 
 	p = quirks;
 	while (*p) {
@@ -490,6 +491,9 @@ static void adjust_quirks(struct us_data *us)
 		case 'm':
 			f |= US_FL_MAX_SECTORS_64;
 			break;
+		case 'n':
+			f |= US_FL_INITIAL_READ10;
+			break;
 		case 'o':
 			f |= US_FL_CAPACITY_OK;
 			break;
@@ -953,6 +957,13 @@ int usb_stor_probe2(struct us_data *us)
 	if (result)
 		goto BadDevice;
 
+	/*
+	 * If the device returns invalid data for the first READ(10)
+	 * command, indicate the command should be retried.
+	 */
+	if (us-&gt;fflags &amp; US_FL_INITIAL_READ10)
+		set_bit(US_FLIDX_REDO_READ10, &amp;us-&gt;dflags);
+
 	/* Acquire all the other resources and add the host */
 	result = usb_stor_acquire_resources(us);
 	if (result)
diff --git a/drivers/usb/storage/usb.h b/drivers/usb/storage/usb.h
index 89d3bfff98df..7b0f2113632e 100644
--- a/drivers/usb/storage/usb.h
+++ b/drivers/usb/storage/usb.h
@@ -73,6 +73,8 @@ struct us_unusual_dev {
 #define US_FLIDX_RESETTING	4	/* device reset in progress */
 #define US_FLIDX_TIMED_OUT	5	/* SCSI midlayer timed out  */
 #define US_FLIDX_DONT_SCAN	6	/* don't scan (disconnect)  */
+#define US_FLIDX_REDO_READ10	7	/* redo READ(10) command    */
+#define US_FLIDX_READ10_WORKED	8	/* previous READ(10) succeeded */
 
 #define USB_STOR_STRING_LEN 32
 
diff --git a/include/linux/usb_usual.h b/include/linux/usb_usual.h
index 71693d4a4fe1..17df3600bcef 100644
--- a/include/linux/usb_usual.h
+++ b/include/linux/usb_usual.h
@@ -62,7 +62,9 @@
 	US_FLAG(NO_READ_DISC_INFO,	0x00040000)		\
 		/* cannot handle READ_DISC_INFO */		\
 	US_FLAG(NO_READ_CAPACITY_16,	0x00080000)		\
-		/* cannot handle READ_CAPACITY_16 */
+		/* cannot handle READ_CAPACITY_16 */		\
+	US_FLAG(INITIAL_READ10,	0x00100000)			\
+		/* Initial READ(10) (and others) must be retried */
 
 #define US_FLAG(name, value)	US_FL_##name = value ,
 enum { US_DO_ALL_FLAGS };</pre><hr><pre>commit bab1ff1bda27e654dfd382a1fbdfcda1f7ed0a37
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed May 18 10:44:50 2011 +0200

    USB: UHCI: Use ACCESS_ONCE rather than using a full compiler barrier
    
    This patch (as1462) updates the special accessor functions defined in
    uhci-hcd.h.  Rather than using a full compiler barrier, all we really
    need is the ACCESS_ONCE() mechanism, because the idea is to force the
    compiler to store a fixed copy of a possibly changing value.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index 10b68a846f65..0deeab6c9e56 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -168,12 +168,7 @@ struct uhci_qh {
  * We need a special accessor for the element pointer because it is
  * subject to asynchronous updates by the controller.
  */
-static inline __le32 qh_element(struct uhci_qh *qh) {
-	__le32 element = qh-&gt;element;
-
-	barrier();
-	return element;
-}
+#define qh_element(qh)		ACCESS_ONCE((qh)-&gt;element)
 
 #define LINK_TO_QH(qh)		(UHCI_PTR_QH | cpu_to_le32((qh)-&gt;dma_handle))
 
@@ -263,12 +258,7 @@ struct uhci_td {
  * We need a special accessor for the control/status word because it is
  * subject to asynchronous updates by the controller.
  */
-static inline u32 td_status(struct uhci_td *td) {
-	__le32 status = td-&gt;status;
-
-	barrier();
-	return le32_to_cpu(status);
-}
+#define td_status(td)		le32_to_cpu(ACCESS_ONCE((td)-&gt;status))
 
 #define LINK_TO_TD(td)		(cpu_to_le32((td)-&gt;dma_handle))
 </pre><hr><pre>commit 69fff59de4d844f8b4c2454c3c23d32b69dcbfd7
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 17 17:27:12 2011 -0400

    USB: remove remaining usages of hcd-&gt;state from usbcore and fix regression
    
    This patch (as1467) removes the last usages of hcd-&gt;state from
    usbcore.  We no longer check to see if an interrupt handler finds that
    a controller has died; instead we rely on host controller drivers to
    make an explicit call to usb_hc_died().
    
    This fixes a regression introduced by commit
    9b37596a2e860404503a3f2a6513db60c296bfdc (USB: move usbcore away from
    hcd-&gt;state).  It used to be that when a controller shared an IRQ with
    another device and an interrupt arrived while hcd-&gt;state was set to
    HC_STATE_HALT, the interrupt handler would be skipped.  The commit
    removed that test; as a result the current code doesn't skip calling
    the handler and ends up believing the controller has died, even though
    it's only temporarily stopped.  The solution is to ignore HC_STATE_HALT
    following the handler's return.
    
    As a consequence of this change, several of the host controller
    drivers need to be modified.  They can no longer implicitly rely on
    usbcore realizing that a controller has died because of hcd-&gt;state.
    The patch adds calls to usb_hc_died() in the appropriate places.
    
    The patch also changes a few of the interrupt handlers.  They don't
    expect to be called when hcd-&gt;state is equal to HC_STATE_HALT, even if
    the controller is still alive.  Early returns were added to avoid any
    confusion.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Manuel Lauss &lt;manuel.lauss@googlemail.com&gt;
    CC: Rodolfo Giometti &lt;giometti@linux.it&gt;
    CC: Olav Kongas &lt;ok@artecdesign.ee&gt;
    CC: &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 10936ba9c42b..ace9f8442e5d 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -986,7 +986,7 @@ static int register_root_hub(struct usb_hcd *hcd)
 		spin_unlock_irq (&amp;hcd_root_hub_lock);
 
 		/* Did the HC die before the root hub was registered? */
-		if (HCD_DEAD(hcd) || hcd-&gt;state == HC_STATE_HALT)
+		if (HCD_DEAD(hcd))
 			usb_hc_died (hcd);	/* This time clean up */
 	}
 
@@ -2128,9 +2128,6 @@ irqreturn_t usb_hcd_irq (int irq, void *__hcd)
 		set_bit(HCD_FLAG_SAW_IRQ, &amp;hcd-&gt;flags);
 		if (hcd-&gt;shared_hcd)
 			set_bit(HCD_FLAG_SAW_IRQ, &amp;hcd-&gt;shared_hcd-&gt;flags);
-
-		if (unlikely(hcd-&gt;state == HC_STATE_HALT))
-			usb_hc_died(hcd);
 		rc = IRQ_HANDLED;
 	}
 
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index c5719cd258c3..b435ed67dd5c 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -777,8 +777,9 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 		goto dead;
 	}
 
+	/* Shared IRQ? */
 	masked_status = status &amp; INTR_MASK;
-	if (!masked_status) {		/* irq sharing? */
+	if (!masked_status || unlikely(hcd-&gt;state == HC_STATE_HALT)) {
 		spin_unlock(&amp;ehci-&gt;lock);
 		return IRQ_NONE;
 	}
@@ -873,6 +874,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 dead:
 		ehci_reset(ehci);
 		ehci_writel(ehci, 0, &amp;ehci-&gt;regs-&gt;configured_flag);
+		usb_hc_died(hcd);
 		/* generic layer kills/unlinks all urbs, then
 		 * uses ehci_stop to clean up the rest
 		 */
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index a7408d88fda0..6c9fbe352f73 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -471,8 +471,10 @@ static int enable_periodic (struct ehci_hcd *ehci)
 	 */
 	status = handshake_on_error_set_halt(ehci, &amp;ehci-&gt;regs-&gt;status,
 					     STS_PSS, 0, 9 * 125);
-	if (status)
+	if (status) {
+		usb_hc_died(ehci_to_hcd(ehci));
 		return status;
+	}
 
 	cmd = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command) | CMD_PSE;
 	ehci_writel(ehci, cmd, &amp;ehci-&gt;regs-&gt;command);
@@ -510,8 +512,10 @@ static int disable_periodic (struct ehci_hcd *ehci)
 	 */
 	status = handshake_on_error_set_halt(ehci, &amp;ehci-&gt;regs-&gt;status,
 					     STS_PSS, STS_PSS, 9 * 125);
-	if (status)
+	if (status) {
+		usb_hc_died(ehci_to_hcd(ehci));
 		return status;
+	}
 
 	cmd = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command) &amp; ~CMD_PSE;
 	ehci_writel(ehci, cmd, &amp;ehci-&gt;regs-&gt;command);
diff --git a/drivers/usb/host/isp116x-hcd.c b/drivers/usb/host/isp116x-hcd.c
index c0e22f26da19..baae4ccd16ac 100644
--- a/drivers/usb/host/isp116x-hcd.c
+++ b/drivers/usb/host/isp116x-hcd.c
@@ -612,6 +612,7 @@ static irqreturn_t isp116x_irq(struct usb_hcd *hcd)
 			/* IRQ's are off, we do no DMA,
 			   perfectly ready to die ... */
 			hcd-&gt;state = HC_STATE_HALT;
+			usb_hc_died(hcd);
 			ret = IRQ_HANDLED;
 			goto done;
 		}
diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index 8c8dc6559ac7..9aa10bdf3918 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -764,6 +764,7 @@ static irqreturn_t ohci_irq (struct usb_hcd *hcd)
 	if (ints == ~(u32)0) {
 		disable (ohci);
 		ohci_dbg (ohci, "device removed!\n");
+		usb_hc_died(hcd);
 		return IRQ_HANDLED;
 	}
 
@@ -771,7 +772,7 @@ static irqreturn_t ohci_irq (struct usb_hcd *hcd)
 	ints &amp;= ohci_readl(ohci, &amp;regs-&gt;intrenable);
 
 	/* interrupt for some other device? */
-	if (ints == 0)
+	if (ints == 0 || unlikely(hcd-&gt;state == HC_STATE_HALT))
 		return IRQ_NOTMINE;
 
 	if (ints &amp; OHCI_INTR_UE) {
@@ -788,6 +789,7 @@ static irqreturn_t ohci_irq (struct usb_hcd *hcd)
 		} else {
 			disable (ohci);
 			ohci_err (ohci, "OHCI Unrecoverable Error, disabled\n");
+			usb_hc_died(hcd);
 		}
 
 		ohci_dump (ohci, 1);
diff --git a/drivers/usb/host/oxu210hp-hcd.c b/drivers/usb/host/oxu210hp-hcd.c
index 4a771f6cc822..5fbe997dc6df 100644
--- a/drivers/usb/host/oxu210hp-hcd.c
+++ b/drivers/usb/host/oxu210hp-hcd.c
@@ -1884,6 +1884,7 @@ static int enable_periodic(struct oxu_hcd *oxu)
 	status = handshake(oxu, &amp;oxu-&gt;regs-&gt;status, STS_PSS, 0, 9 * 125);
 	if (status != 0) {
 		oxu_to_hcd(oxu)-&gt;state = HC_STATE_HALT;
+		usb_hc_died(oxu_to_hcd(oxu));
 		return status;
 	}
 
@@ -1909,6 +1910,7 @@ static int disable_periodic(struct oxu_hcd *oxu)
 	status = handshake(oxu, &amp;oxu-&gt;regs-&gt;status, STS_PSS, STS_PSS, 9 * 125);
 	if (status != 0) {
 		oxu_to_hcd(oxu)-&gt;state = HC_STATE_HALT;
+		usb_hc_died(oxu_to_hcd(oxu));
 		return status;
 	}
 
@@ -2449,8 +2451,9 @@ static irqreturn_t oxu210_hcd_irq(struct usb_hcd *hcd)
 		goto dead;
 	}
 
+	/* Shared IRQ? */
 	status &amp;= INTR_MASK;
-	if (!status) {			/* irq sharing? */
+	if (!status || unlikely(hcd-&gt;state == HC_STATE_HALT)) {
 		spin_unlock(&amp;oxu-&gt;lock);
 		return IRQ_NONE;
 	}
@@ -2516,6 +2519,7 @@ static irqreturn_t oxu210_hcd_irq(struct usb_hcd *hcd)
 dead:
 			ehci_reset(oxu);
 			writel(0, &amp;oxu-&gt;regs-&gt;configured_flag);
+			usb_hc_died(hcd);
 			/* generic layer kills/unlinks all urbs, then
 			 * uses oxu_stop to clean up the rest
 			 */</pre><hr><pre>commit a8e62dd6d91f3bc3687abbb26227e5fc39c4829c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 17 14:45:48 2011 -0400

    usb-storage: fix up the unusual_realtek device list
    
    This patch (as1461) fixes the unusual_devs entries for the Realtek USB
    card reader.  They should be ordered by PID, and they should not
    override the Subclass and Protocol values provided by the device.
    Otherwise a notification about unnecessary entries gets printed in the
    kernel log during probing.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-By: Tony Vroon &lt;tony@linx.net&gt;
    CC: &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/unusual_realtek.h b/drivers/usb/storage/unusual_realtek.h
index 3236e0328516..e41f50c95ed4 100644
--- a/drivers/usb/storage/unusual_realtek.h
+++ b/drivers/usb/storage/unusual_realtek.h
@@ -23,19 +23,19 @@
 #if defined(CONFIG_USB_STORAGE_REALTEK) || \
 		defined(CONFIG_USB_STORAGE_REALTEK_MODULE)
 
-UNUSUAL_DEV(0x0bda, 0x0159, 0x0000, 0x9999,
+UNUSUAL_DEV(0x0bda, 0x0138, 0x0000, 0x9999,
 		"Realtek",
 		"USB Card Reader",
-		USB_SC_SCSI, USB_PR_BULK, init_realtek_cr, 0),
+		USB_SC_DEVICE, USB_PR_DEVICE, init_realtek_cr, 0),
 
 UNUSUAL_DEV(0x0bda, 0x0158, 0x0000, 0x9999,
 		"Realtek",
 		"USB Card Reader",
-		USB_SC_SCSI, USB_PR_BULK, init_realtek_cr, 0),
+		USB_SC_DEVICE, USB_PR_DEVICE, init_realtek_cr, 0),
 
-UNUSUAL_DEV(0x0bda, 0x0138, 0x0000, 0x9999,
+UNUSUAL_DEV(0x0bda, 0x0159, 0x0000, 0x9999,
 		"Realtek",
 		"USB Card Reader",
-		USB_SC_SCSI, USB_PR_BULK, init_realtek_cr, 0),
+		USB_SC_DEVICE, USB_PR_DEVICE, init_realtek_cr, 0),
 
 #endif  /* defined(CONFIG_USB_STORAGE_REALTEK) || ... */</pre><hr><pre>commit 1e12c910eed82da6971f1c0421a069c680faba2e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 17 10:40:51 2011 -0400

    EHCI: don't rescan interrupt QHs needlessly
    
    This patch (as1466) speeds up processing of ehci-hcd's periodic list.
    The existing code will pointlessly rescan an interrupt endpoint queue
    each time it encounters the queue's QH in the periodic list, which can
    happen quite a few times if the endpoint's period is low.  On some
    embedded systems, this useless overhead can waste so much time that
    the driver falls hopelessly behind and loses events.
    
    The patch introduces a "periodic_stamp" variable, which gets
    incremented each time scan_periodic() runs and each time the scan
    advances to a new frame.  If the corresponding stamp in an interrupt
    QH is equal to the current periodic_stamp, we assume the QH has
    already been scanned and skip over it.  Otherwise we scan the QH as
    usual, and if none of its URBs have completed then we store the
    current periodic_stamp in the QH's stamp, preventing it from being
    scanned again.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index a46d6a1388c9..5d6bc624c961 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -826,6 +826,7 @@ qh_make (
 				is_input, 0,
 				hb_mult(maxp) * max_packet(maxp)));
 		qh-&gt;start = NO_FRAME;
+		qh-&gt;stamp = ehci-&gt;periodic_stamp;
 
 		if (urb-&gt;dev-&gt;speed == USB_SPEED_HIGH) {
 			qh-&gt;c_usecs = 0;
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 1543c838b3d1..a7408d88fda0 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -2287,6 +2287,7 @@ scan_periodic (struct ehci_hcd *ehci)
 	}
 	clock &amp;= mod - 1;
 	clock_frame = clock &gt;&gt; 3;
+	++ehci-&gt;periodic_stamp;
 
 	for (;;) {
 		union ehci_shadow	q, *q_p;
@@ -2315,10 +2316,14 @@ scan_periodic (struct ehci_hcd *ehci)
 				temp.qh = qh_get (q.qh);
 				type = Q_NEXT_TYPE(ehci, q.qh-&gt;hw-&gt;hw_next);
 				q = q.qh-&gt;qh_next;
-				modified = qh_completions (ehci, temp.qh);
-				if (unlikely(list_empty(&amp;temp.qh-&gt;qtd_list) ||
-						temp.qh-&gt;needs_rescan))
-					intr_deschedule (ehci, temp.qh);
+				if (temp.qh-&gt;stamp != ehci-&gt;periodic_stamp) {
+					modified = qh_completions(ehci, temp.qh);
+					if (!modified)
+						temp.qh-&gt;stamp = ehci-&gt;periodic_stamp;
+					if (unlikely(list_empty(&amp;temp.qh-&gt;qtd_list) ||
+							temp.qh-&gt;needs_rescan))
+						intr_deschedule(ehci, temp.qh);
+				}
 				qh_put (temp.qh);
 				break;
 			case Q_TYPE_FSTN:
@@ -2460,6 +2465,7 @@ scan_periodic (struct ehci_hcd *ehci)
 			if (ehci-&gt;clock_frame != clock_frame) {
 				free_cached_lists(ehci);
 				ehci-&gt;clock_frame = clock_frame;
+				++ehci-&gt;periodic_stamp;
 			}
 		} else {
 			now_uframe++;
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 829213423dea..f68e419cae87 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -118,6 +118,7 @@ struct ehci_hcd {			/* one per controller */
 	struct timer_list	watchdog;
 	unsigned long		actions;
 	unsigned		stamp;
+	unsigned		periodic_stamp;
 	unsigned		random_frame;
 	unsigned long		next_statechange;
 	ktime_t			last_periodic_enable;</pre><hr><pre>commit 2b7aaf503d56216b847c8265421d2a7d9b42df3e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon May 16 12:15:19 2011 -0400

    OHCI: fix regression caused by nVidia shutdown workaround
    
    This patch (as1463) fixes a regression caused by commit
    3df7169e73fc1d71a39cffeacc969f6840cdf52b (OHCI: work around for nVidia
    shutdown problem).
    
    The original problem encountered by people using NVIDIA chipsets was
    that USB devices were not turning off when the system shut down.  For
    example, the LED on an optical mouse would remain on, draining a
    laptop's battery.  The problem was caused by a bug in the chipset; an
    OHCI controller in the Reset state would continue to drive a bus reset
    signal even after system shutdown.  The workaround was to put the
    controllers into the Suspend state instead.
    
    It turns out that later NVIDIA chipsets do not suffer from this bug.
    Instead some have the opposite bug: If a system is shut down while an
    OHCI controller is in the Suspend state, USB devices remain powered!
    On other systems, shutting down with a Suspended controller causes the
    system to reboot immediately.  Thus, working around the original bug
    on some machines exposes other bugs on other machines.
    
    The best solution seems to be to limit the workaround to OHCI
    controllers with a low-numbered PCI product ID.  I don't know exactly
    at what point NVIDIA changed their chipsets; the value used here is a
    guess.  So far it was worked out okay for all the people who have
    tested it.
    
    This fixes Bugzilla #35032.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Andre "Osku" Schmidt &lt;andre.osku.schmidt@googlemail.com&gt;
    Tested-by: Yury Siamashka &lt;yurand2@gmail.com&gt;
    CC: &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index d84d6f0314f9..ad8166c681e2 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -181,10 +181,18 @@ static int ohci_quirk_amd700(struct usb_hcd *hcd)
  */
 static int ohci_quirk_nvidia_shutdown(struct usb_hcd *hcd)
 {
+	struct pci_dev *pdev = to_pci_dev(hcd-&gt;self.controller);
 	struct ohci_hcd	*ohci = hcd_to_ohci(hcd);
 
-	ohci-&gt;flags |= OHCI_QUIRK_SHUTDOWN;
-	ohci_dbg(ohci, "enabled nVidia shutdown quirk\n");
+	/* Evidently nVidia fixed their later hardware; this is a guess at
+	 * the changeover point.
+	 */
+#define PCI_DEVICE_ID_NVIDIA_NFORCE_MCP51_USB		0x026d
+
+	if (pdev-&gt;device &lt; PCI_DEVICE_ID_NVIDIA_NFORCE_MCP51_USB) {
+		ohci-&gt;flags |= OHCI_QUIRK_SHUTDOWN;
+		ohci_dbg(ohci, "enabled nVidia shutdown quirk\n");
+	}
 
 	return 0;
 }</pre><hr><pre>commit cee6a262550f53a13acfefbc1e3e5ff35c96182c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon May 2 14:21:44 2011 -0400

    USB: fix regression in usbip by setting has_tt flag
    
    This patch (as1460) fixes a regression in the usbip driver caused by
    the new check for Transaction Translators in USB-2 hubs.  The root hub
    registered by vhci_hcd needs to have the has_tt flag set, because it
    can connect to low- and full-speed devices as well as high-speed
    devices.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Nikola Ciprich &lt;nikola.ciprich@linuxbox.cz&gt;
    CC: &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/usbip/vhci_hcd.c b/drivers/staging/usbip/vhci_hcd.c
index 0f02a4b12ae4..5d0caa8648e2 100644
--- a/drivers/staging/usbip/vhci_hcd.c
+++ b/drivers/staging/usbip/vhci_hcd.c
@@ -1139,7 +1139,7 @@ static int vhci_hcd_probe(struct platform_device *pdev)
 		usbip_uerr("create hcd failed\n");
 		return -ENOMEM;
 	}
-
+	hcd-&gt;has_tt = 1;
 
 	/* this is private data for vhci_hcd */
 	the_controller = hcd_to_vhci(hcd);</pre><hr><pre>commit 869410f82cbbb1464772046d87de8d18a916e706
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Apr 14 11:21:04 2011 -0400

    USB: add queued-unlinks test case to usbtest driver
    
    This patch (as1452b) adds a new test case to the usbtest driver.  Test
    24 exercises the unlink-from-queue pathways in the host.  It queues a
    user-specified number of bulk-OUT URBs of user-specified size, unlinks
    the fourth- and second-from-last URBs in the queue, and then waits to
    see if all the URBs complete in the expected way (except of course
    that the unlinked URBs might complete normally, if they weren't
    unlinked soon enough).
    
    This new test has confirmed the existence of a bug in the ehci-hcd
    driver, to be fixed by a separate patch.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 388cc128072a..58a5685fb7d1 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -1195,6 +1195,104 @@ static int unlink_simple(struct usbtest_dev *dev, int pipe, int len)
 
 /*-------------------------------------------------------------------------*/
 
+struct queued_ctx {
+	struct completion	complete;
+	atomic_t		pending;
+	unsigned		num;
+	int			status;
+	struct urb		**urbs;
+};
+
+static void unlink_queued_callback(struct urb *urb)
+{
+	int			status = urb-&gt;status;
+	struct queued_ctx	*ctx = urb-&gt;context;
+
+	if (ctx-&gt;status)
+		goto done;
+	if (urb == ctx-&gt;urbs[ctx-&gt;num - 4] || urb == ctx-&gt;urbs[ctx-&gt;num - 2]) {
+		if (status == -ECONNRESET)
+			goto done;
+		/* What error should we report if the URB completed normally? */
+	}
+	if (status != 0)
+		ctx-&gt;status = status;
+
+ done:
+	if (atomic_dec_and_test(&amp;ctx-&gt;pending))
+		complete(&amp;ctx-&gt;complete);
+}
+
+static int unlink_queued(struct usbtest_dev *dev, int pipe, unsigned num,
+		unsigned size)
+{
+	struct queued_ctx	ctx;
+	struct usb_device	*udev = testdev_to_usbdev(dev);
+	void			*buf;
+	dma_addr_t		buf_dma;
+	int			i;
+	int			retval = -ENOMEM;
+
+	init_completion(&amp;ctx.complete);
+	atomic_set(&amp;ctx.pending, 1);	/* One more than the actual value */
+	ctx.num = num;
+	ctx.status = 0;
+
+	buf = usb_alloc_coherent(udev, size, GFP_KERNEL, &amp;buf_dma);
+	if (!buf)
+		return retval;
+	memset(buf, 0, size);
+
+	/* Allocate and init the urbs we'll queue */
+	ctx.urbs = kcalloc(num, sizeof(struct urb *), GFP_KERNEL);
+	if (!ctx.urbs)
+		goto free_buf;
+	for (i = 0; i &lt; num; i++) {
+		ctx.urbs[i] = usb_alloc_urb(0, GFP_KERNEL);
+		if (!ctx.urbs[i])
+			goto free_urbs;
+		usb_fill_bulk_urb(ctx.urbs[i], udev, pipe, buf, size,
+				unlink_queued_callback, &amp;ctx);
+		ctx.urbs[i]-&gt;transfer_dma = buf_dma;
+		ctx.urbs[i]-&gt;transfer_flags = URB_NO_TRANSFER_DMA_MAP;
+	}
+
+	/* Submit all the URBs and then unlink URBs num - 4 and num - 2. */
+	for (i = 0; i &lt; num; i++) {
+		atomic_inc(&amp;ctx.pending);
+		retval = usb_submit_urb(ctx.urbs[i], GFP_KERNEL);
+		if (retval != 0) {
+			dev_err(&amp;dev-&gt;intf-&gt;dev, "submit urbs[%d] fail %d\n",
+					i, retval);
+			atomic_dec(&amp;ctx.pending);
+			ctx.status = retval;
+			break;
+		}
+	}
+	if (i == num) {
+		usb_unlink_urb(ctx.urbs[num - 4]);
+		usb_unlink_urb(ctx.urbs[num - 2]);
+	} else {
+		while (--i &gt;= 0)
+			usb_unlink_urb(ctx.urbs[i]);
+	}
+
+	if (atomic_dec_and_test(&amp;ctx.pending))		/* The extra count */
+		complete(&amp;ctx.complete);
+	wait_for_completion(&amp;ctx.complete);
+	retval = ctx.status;
+
+ free_urbs:
+	for (i = 0; i &lt; num; i++)
+		usb_free_urb(ctx.urbs[i]);
+	kfree(ctx.urbs);
+ free_buf:
+	usb_free_coherent(udev, size, buf, buf_dma);
+	return retval;
+}
+
+/*-------------------------------------------------------------------------*/
+
 static int verify_not_halted(struct usbtest_dev *tdev, int ep, struct urb *urb)
 {
 	int	retval;
@@ -1970,8 +2068,6 @@ usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)
 				dev-&gt;in_iso_pipe, dev-&gt;iso_in, 0);
 		break;
 
-	/* FIXME unlink from queue (ring with N urbs) */
-
 	/* FIXME scatterlist cancel (needs helper thread) */
 
 	/* Tests for bulk I/O using DMA mapping by core and odd address */
@@ -2064,6 +2160,26 @@ usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)
 				dev-&gt;in_iso_pipe, dev-&gt;iso_in, 1);
 		break;
 
+	/* unlink URBs from a bulk-OUT queue */
+	case 24:
+		if (dev-&gt;out_pipe == 0 || !param-&gt;length || param-&gt;sglen &lt; 4)
+			break;
+		retval = 0;
+		dev_info(&amp;intf-&gt;dev, "TEST 17:  unlink from %d queues of "
+				"%d %d-byte writes\n",
+				param-&gt;iterations, param-&gt;sglen, param-&gt;length);
+		for (i = param-&gt;iterations; retval == 0 &amp;&amp; i &gt; 0; --i) {
+			retval = unlink_queued(dev, dev-&gt;out_pipe,
+						param-&gt;sglen, param-&gt;length);
+			if (retval) {
+				dev_err(&amp;intf-&gt;dev,
+					"unlink queued writes failed %d, "
+					"iterations left %d\n", retval, i);
+				break;
+			}
+		}
+		break;
+
 	}
 	do_gettimeofday(&amp;param-&gt;duration);
 	param-&gt;duration.tv_sec -= start.tv_sec;</pre>
    <div class="pagination">
        <a href='2_56.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><span>[57]</span><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_58.html'>Next&gt;&gt;</a>
    <div>
</body>
