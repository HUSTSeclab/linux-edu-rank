<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_117.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><span>[118]</span><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_119.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit b4dfdbb3c707474a2254c5b4d7e62be31a4b7da9
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Oct 4 02:17:06 2006 -0700

    [PATCH] cpufreq: make the transition_notifier chain use SRCU
    
    This patch (as762) changes the cpufreq_transition_notifier_list from a
    blocking_notifier_head to an srcu_notifier_head.  This will prevent errors
    caused attempting to call down_read() to access the notifier chain at a
    time when interrupts must remain disabled, during system suspend.
    
    It's not clear to me whether this is really necessary; perhaps the chain
    could be made into an atomic_notifier.  However a couple of the callout
    routines do use blocking operations, so this approach seems safer.
    
    The head of the notifier chain needs to be initialized before use; this is
    done by an __init routine at core_initcall time.  If this turns out not to
    be a good choice, it can easily be changed.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: "Paul E. McKenney" &lt;paulmck@us.ibm.com&gt;
    Cc: Jesse Brandeburg &lt;jesse.brandeburg@gmail.com&gt;
    Cc: Dave Jones &lt;davej@codemonkey.org.uk&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/drivers/cpufreq/cpufreq.c b/drivers/cpufreq/cpufreq.c
index 2caaf71d80c8..86e69b7f9122 100644
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@ -52,8 +52,14 @@ static void handle_update(void *data);
  * The mutex locks both lists.
  */
 static BLOCKING_NOTIFIER_HEAD(cpufreq_policy_notifier_list);
-static BLOCKING_NOTIFIER_HEAD(cpufreq_transition_notifier_list);
+static struct srcu_notifier_head cpufreq_transition_notifier_list;
 
+static int __init init_cpufreq_transition_notifier_list(void)
+{
+	srcu_init_notifier_head(&amp;cpufreq_transition_notifier_list);
+	return 0;
+}
+core_initcall(init_cpufreq_transition_notifier_list);
 
 static LIST_HEAD(cpufreq_governor_list);
 static DEFINE_MUTEX (cpufreq_governor_mutex);
@@ -262,14 +268,14 @@ void cpufreq_notify_transition(struct cpufreq_freqs *freqs, unsigned int state)
 				freqs-&gt;old = policy-&gt;cur;
 			}
 		}
-		blocking_notifier_call_chain(&amp;cpufreq_transition_notifier_list,
+		srcu_notifier_call_chain(&amp;cpufreq_transition_notifier_list,
 				CPUFREQ_PRECHANGE, freqs);
 		adjust_jiffies(CPUFREQ_PRECHANGE, freqs);
 		break;
 
 	case CPUFREQ_POSTCHANGE:
 		adjust_jiffies(CPUFREQ_POSTCHANGE, freqs);
-		blocking_notifier_call_chain(&amp;cpufreq_transition_notifier_list,
+		srcu_notifier_call_chain(&amp;cpufreq_transition_notifier_list,
 				CPUFREQ_POSTCHANGE, freqs);
 		if (likely(policy) &amp;&amp; likely(policy-&gt;cpu == freqs-&gt;cpu))
 			policy-&gt;cur = freqs-&gt;new;
@@ -1049,7 +1055,7 @@ static int cpufreq_suspend(struct sys_device * sysdev, pm_message_t pmsg)
 		freqs.old = cpu_policy-&gt;cur;
 		freqs.new = cur_freq;
 
-		blocking_notifier_call_chain(&amp;cpufreq_transition_notifier_list,
+		srcu_notifier_call_chain(&amp;cpufreq_transition_notifier_list,
 				    CPUFREQ_SUSPENDCHANGE, &amp;freqs);
 		adjust_jiffies(CPUFREQ_SUSPENDCHANGE, &amp;freqs);
 
@@ -1130,7 +1136,7 @@ static int cpufreq_resume(struct sys_device * sysdev)
 			freqs.old = cpu_policy-&gt;cur;
 			freqs.new = cur_freq;
 
-			blocking_notifier_call_chain(
+			srcu_notifier_call_chain(
 					&amp;cpufreq_transition_notifier_list,
 					CPUFREQ_RESUMECHANGE, &amp;freqs);
 			adjust_jiffies(CPUFREQ_RESUMECHANGE, &amp;freqs);
@@ -1176,7 +1182,7 @@ int cpufreq_register_notifier(struct notifier_block *nb, unsigned int list)
 
 	switch (list) {
 	case CPUFREQ_TRANSITION_NOTIFIER:
-		ret = blocking_notifier_chain_register(
+		ret = srcu_notifier_chain_register(
 				&amp;cpufreq_transition_notifier_list, nb);
 		break;
 	case CPUFREQ_POLICY_NOTIFIER:
@@ -1208,7 +1214,7 @@ int cpufreq_unregister_notifier(struct notifier_block *nb, unsigned int list)
 
 	switch (list) {
 	case CPUFREQ_TRANSITION_NOTIFIER:
-		ret = blocking_notifier_chain_unregister(
+		ret = srcu_notifier_chain_unregister(
 				&amp;cpufreq_transition_notifier_list, nb);
 		break;
 	case CPUFREQ_POLICY_NOTIFIER:</pre><hr><pre>commit e6a92013ba458804161c0c5b6d134d82204dc233
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Oct 4 02:17:05 2006 -0700

    [PATCH] SRCU: report out-of-memory errors
    
    Currently the init_srcu_struct() routine has no way to report out-of-memory
    errors.  This patch (as761) makes it return -ENOMEM when the per-cpu data
    allocation fails.
    
    The patch also makes srcu_init_notifier_head() report a BUG if a notifier
    head can't be initialized.  Perhaps it should return -ENOMEM instead, but
    in the most likely cases where this might occur I don't think any recovery
    is possible.  Notifier chains generally are not created dynamically.
    
    [akpm@osdl.org: avoid statement-with-side-effect in macro]
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Paul E. McKenney &lt;paulmck@us.ibm.com&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/include/linux/srcu.h b/include/linux/srcu.h
index 8a45367b5f3a..aca0eee53930 100644
--- a/include/linux/srcu.h
+++ b/include/linux/srcu.h
@@ -43,7 +43,7 @@ struct srcu_struct {
 #define srcu_barrier()
 #endif /* #else #ifndef CONFIG_PREEMPT */
 
-void init_srcu_struct(struct srcu_struct *sp);
+int init_srcu_struct(struct srcu_struct *sp);
 void cleanup_srcu_struct(struct srcu_struct *sp);
 int srcu_read_lock(struct srcu_struct *sp) __acquires(sp);
 void srcu_read_unlock(struct srcu_struct *sp, int idx) __releases(sp);
diff --git a/kernel/srcu.c b/kernel/srcu.c
index 7e1979f624ba..3507cabe963b 100644
--- a/kernel/srcu.c
+++ b/kernel/srcu.c
@@ -42,11 +42,12 @@
  * to any other function.  Each srcu_struct represents a separate domain
  * of SRCU protection.
  */
-void init_srcu_struct(struct srcu_struct *sp)
+int init_srcu_struct(struct srcu_struct *sp)
 {
 	sp-&gt;completed = 0;
-	sp-&gt;per_cpu_ref = alloc_percpu(struct srcu_struct_array);
 	mutex_init(&amp;sp-&gt;mutex);
+	sp-&gt;per_cpu_ref = alloc_percpu(struct srcu_struct_array);
+	return (sp-&gt;per_cpu_ref ? 0 : -ENOMEM);
 }
 
 /*
diff --git a/kernel/sys.c b/kernel/sys.c
index fd5c71006775..98489d82801b 100644
--- a/kernel/sys.c
+++ b/kernel/sys.c
@@ -517,7 +517,8 @@ EXPORT_SYMBOL_GPL(srcu_notifier_call_chain);
 void srcu_init_notifier_head(struct srcu_notifier_head *nh)
 {
 	mutex_init(&amp;nh-&gt;mutex);
-	init_srcu_struct(&amp;nh-&gt;srcu);
+	if (init_srcu_struct(&amp;nh-&gt;srcu) &lt; 0)
+		BUG();
 	nh-&gt;head = NULL;
 }
 </pre><hr><pre>commit eabc069401bcf45bcc3f19e643017bf761780aa8
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Oct 4 02:17:04 2006 -0700

    [PATCH] Add SRCU-based notifier chains
    
    This patch (as751) adds a new type of notifier chain, based on the SRCU
    (Sleepable Read-Copy Update) primitives recently added to the kernel.  An
    SRCU notifier chain is much like a blocking notifier chain, in that it must
    be called in process context and its callout routines are allowed to sleep.
     The difference is that the chain's links are protected by the SRCU
    mechanism rather than by an rw-semaphore, so calling the chain has
    extremely low overhead: no memory barriers and no cache-line bouncing.  On
    the other hand, unregistering from the chain is expensive and the chain
    head requires special runtime initialization (plus cleanup if it is to be
    deallocated).
    
    SRCU notifiers are appropriate for notifiers that will be called very
    frequently and for which unregistration occurs very seldom.  The proposed
    "task notifier" scheme qualifies, as may some of the network notifiers.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Paul E. McKenney &lt;paulmck@us.ibm.com&gt;
    Acked-by: Chandra Seetharaman &lt;sekharan@us.ibm.com&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/include/linux/notifier.h b/include/linux/notifier.h
index 7ff386a6ae87..10a43ed0527e 100644
--- a/include/linux/notifier.h
+++ b/include/linux/notifier.h
@@ -12,9 +12,10 @@
 #include &lt;linux/errno.h&gt;
 #include &lt;linux/mutex.h&gt;
 #include &lt;linux/rwsem.h&gt;
+#include &lt;linux/srcu.h&gt;
 
 /*
- * Notifier chains are of three types:
+ * Notifier chains are of four types:
  *
  *	Atomic notifier chains: Chain callbacks run in interrupt/atomic
  *		context. Callouts are not allowed to block.
@@ -23,13 +24,27 @@
  *	Raw notifier chains: There are no restrictions on callbacks,
  *		registration, or unregistration.  All locking and protection
  *		must be provided by the caller.
+ *	SRCU notifier chains: A variant of blocking notifier chains, with
+ *		the same restrictions.
  *
  * atomic_notifier_chain_register() may be called from an atomic context,
- * but blocking_notifier_chain_register() must be called from a process
- * context.  Ditto for the corresponding _unregister() routines.
+ * but blocking_notifier_chain_register() and srcu_notifier_chain_register()
+ * must be called from a process context.  Ditto for the corresponding
+ * _unregister() routines.
  *
- * atomic_notifier_chain_unregister() and blocking_notifier_chain_unregister()
- * _must not_ be called from within the call chain.
+ * atomic_notifier_chain_unregister(), blocking_notifier_chain_unregister(),
+ * and srcu_notifier_chain_unregister() _must not_ be called from within
+ * the call chain.
+ *
+ * SRCU notifier chains are an alternative form of blocking notifier chains.
+ * They use SRCU (Sleepable Read-Copy Update) instead of rw-semaphores for
+ * protection of the chain links.  This means there is _very_ low overhead
+ * in srcu_notifier_call_chain(): no cache bounces and no memory barriers.
+ * As compensation, srcu_notifier_chain_unregister() is rather expensive.
+ * SRCU notifier chains should be used when the chain will be called very
+ * often but notifier_blocks will seldom be removed.  Also, SRCU notifier
+ * chains are slightly more difficult to use because they require special
+ * runtime initialization.
  */
 
 struct notifier_block {
@@ -52,6 +67,12 @@ struct raw_notifier_head {
 	struct notifier_block *head;
 };
 
+struct srcu_notifier_head {
+	struct mutex mutex;
+	struct srcu_struct srcu;
+	struct notifier_block *head;
+};
+
 #define ATOMIC_INIT_NOTIFIER_HEAD(name) do {	\
 		spin_lock_init(&amp;(name)-&gt;lock);	\
 		(name)-&gt;head = NULL;		\
@@ -64,6 +85,11 @@ struct raw_notifier_head {
 		(name)-&gt;head = NULL;		\
 	} while (0)
 
+/* srcu_notifier_heads must be initialized and cleaned up dynamically */
+extern void srcu_init_notifier_head(struct srcu_notifier_head *nh);
+#define srcu_cleanup_notifier_head(name)	\
+		cleanup_srcu_struct(&amp;(name)-&gt;srcu);
+
 #define ATOMIC_NOTIFIER_INIT(name) {				\
 		.lock = __SPIN_LOCK_UNLOCKED(name.lock),	\
 		.head = NULL }
@@ -72,6 +98,7 @@ struct raw_notifier_head {
 		.head = NULL }
 #define RAW_NOTIFIER_INIT(name)	{				\
 		.head = NULL }
+/* srcu_notifier_heads cannot be initialized statically */
 
 #define ATOMIC_NOTIFIER_HEAD(name)				\
 	struct atomic_notifier_head name =			\
@@ -91,6 +118,8 @@ extern int blocking_notifier_chain_register(struct blocking_notifier_head *,
 		struct notifier_block *);
 extern int raw_notifier_chain_register(struct raw_notifier_head *,
 		struct notifier_block *);
+extern int srcu_notifier_chain_register(struct srcu_notifier_head *,
+		struct notifier_block *);
 
 extern int atomic_notifier_chain_unregister(struct atomic_notifier_head *,
 		struct notifier_block *);
@@ -98,6 +127,8 @@ extern int blocking_notifier_chain_unregister(struct blocking_notifier_head *,
 		struct notifier_block *);
 extern int raw_notifier_chain_unregister(struct raw_notifier_head *,
 		struct notifier_block *);
+extern int srcu_notifier_chain_unregister(struct srcu_notifier_head *,
+		struct notifier_block *);
 
 extern int atomic_notifier_call_chain(struct atomic_notifier_head *,
 		unsigned long val, void *v);
@@ -105,6 +136,8 @@ extern int blocking_notifier_call_chain(struct blocking_notifier_head *,
 		unsigned long val, void *v);
 extern int raw_notifier_call_chain(struct raw_notifier_head *,
 		unsigned long val, void *v);
+extern int srcu_notifier_call_chain(struct srcu_notifier_head *,
+		unsigned long val, void *v);
 
 #define NOTIFY_DONE		0x0000		/* Don't care */
 #define NOTIFY_OK		0x0001		/* Suits me */
diff --git a/include/linux/srcu.h b/include/linux/srcu.h
index 947fdab2ddb0..8a45367b5f3a 100644
--- a/include/linux/srcu.h
+++ b/include/linux/srcu.h
@@ -24,6 +24,9 @@
  *
  */
 
+#ifndef _LINUX_SRCU_H
+#define _LINUX_SRCU_H
+
 struct srcu_struct_array {
 	int c[2];
 };
@@ -46,4 +49,5 @@ int srcu_read_lock(struct srcu_struct *sp) __acquires(sp);
 void srcu_read_unlock(struct srcu_struct *sp, int idx) __releases(sp);
 void synchronize_srcu(struct srcu_struct *sp);
 long srcu_batches_completed(struct srcu_struct *sp);
-void cleanup_srcu_struct(struct srcu_struct *sp);
+
+#endif
diff --git a/kernel/sys.c b/kernel/sys.c
index 2314867ae34f..fd5c71006775 100644
--- a/kernel/sys.c
+++ b/kernel/sys.c
@@ -153,7 +153,7 @@ static int __kprobes notifier_call_chain(struct notifier_block **nl,
 
 /*
  *	Atomic notifier chain routines.  Registration and unregistration
- *	use a mutex, and call_chain is synchronized by RCU (no locks).
+ *	use a spinlock, and call_chain is synchronized by RCU (no locks).
  */
 
 /**
@@ -401,6 +401,128 @@ int raw_notifier_call_chain(struct raw_notifier_head *nh,
 
 EXPORT_SYMBOL_GPL(raw_notifier_call_chain);
 
+/*
+ *	SRCU notifier chain routines.    Registration and unregistration
+ *	use a mutex, and call_chain is synchronized by SRCU (no locks).
+ */
+
+/**
+ *	srcu_notifier_chain_register - Add notifier to an SRCU notifier chain
+ *	@nh: Pointer to head of the SRCU notifier chain
+ *	@n: New entry in notifier chain
+ *
+ *	Adds a notifier to an SRCU notifier chain.
+ *	Must be called in process context.
+ *
+ *	Currently always returns zero.
+ */
+
+int srcu_notifier_chain_register(struct srcu_notifier_head *nh,
+		struct notifier_block *n)
+{
+	int ret;
+
+	/*
+	 * This code gets used during boot-up, when task switching is
+	 * not yet working and interrupts must remain disabled.  At
+	 * such times we must not call mutex_lock().
+	 */
+	if (unlikely(system_state == SYSTEM_BOOTING))
+		return notifier_chain_register(&amp;nh-&gt;head, n);
+
+	mutex_lock(&amp;nh-&gt;mutex);
+	ret = notifier_chain_register(&amp;nh-&gt;head, n);
+	mutex_unlock(&amp;nh-&gt;mutex);
+	return ret;
+}
+
+EXPORT_SYMBOL_GPL(srcu_notifier_chain_register);
+
+/**
+ *	srcu_notifier_chain_unregister - Remove notifier from an SRCU notifier chain
+ *	@nh: Pointer to head of the SRCU notifier chain
+ *	@n: Entry to remove from notifier chain
+ *
+ *	Removes a notifier from an SRCU notifier chain.
+ *	Must be called from process context.
+ *
+ *	Returns zero on success or %-ENOENT on failure.
+ */
+int srcu_notifier_chain_unregister(struct srcu_notifier_head *nh,
+		struct notifier_block *n)
+{
+	int ret;
+
+	/*
+	 * This code gets used during boot-up, when task switching is
+	 * not yet working and interrupts must remain disabled.  At
+	 * such times we must not call mutex_lock().
+	 */
+	if (unlikely(system_state == SYSTEM_BOOTING))
+		return notifier_chain_unregister(&amp;nh-&gt;head, n);
+
+	mutex_lock(&amp;nh-&gt;mutex);
+	ret = notifier_chain_unregister(&amp;nh-&gt;head, n);
+	mutex_unlock(&amp;nh-&gt;mutex);
+	synchronize_srcu(&amp;nh-&gt;srcu);
+	return ret;
+}
+
+EXPORT_SYMBOL_GPL(srcu_notifier_chain_unregister);
+
+/**
+ *	srcu_notifier_call_chain - Call functions in an SRCU notifier chain
+ *	@nh: Pointer to head of the SRCU notifier chain
+ *	@val: Value passed unmodified to notifier function
+ *	@v: Pointer passed unmodified to notifier function
+ *
+ *	Calls each function in a notifier chain in turn.  The functions
+ *	run in a process context, so they are allowed to block.
+ *
+ *	If the return value of the notifier can be and'ed
+ *	with %NOTIFY_STOP_MASK then srcu_notifier_call_chain
+ *	will return immediately, with the return value of
+ *	the notifier function which halted execution.
+ *	Otherwise the return value is the return value
+ *	of the last notifier function called.
+ */
+
+int srcu_notifier_call_chain(struct srcu_notifier_head *nh,
+		unsigned long val, void *v)
+{
+	int ret;
+	int idx;
+
+	idx = srcu_read_lock(&amp;nh-&gt;srcu);
+	ret = notifier_call_chain(&amp;nh-&gt;head, val, v);
+	srcu_read_unlock(&amp;nh-&gt;srcu, idx);
+	return ret;
+}
+
+EXPORT_SYMBOL_GPL(srcu_notifier_call_chain);
+
+/**
+ *	srcu_init_notifier_head - Initialize an SRCU notifier head
+ *	@nh: Pointer to head of the srcu notifier chain
+ *
+ *	Unlike other sorts of notifier heads, SRCU notifier heads require
+ *	dynamic initialization.  Be sure to call this routine before
+ *	calling any of the other SRCU notifier routines for this head.
+ *
+ *	If an SRCU notifier head is deallocated, it must first be cleaned
+ *	up by calling srcu_cleanup_notifier_head().  Otherwise the head's
+ *	per-cpu data (used by the SRCU mechanism) will leak.
+ */
+
+void srcu_init_notifier_head(struct srcu_notifier_head *nh)
+{
+	mutex_init(&amp;nh-&gt;mutex);
+	init_srcu_struct(&amp;nh-&gt;srcu);
+	nh-&gt;head = NULL;
+}
+
+EXPORT_SYMBOL_GPL(srcu_init_notifier_head);
+
 /**
  *	register_reboot_notifier - Register function to be called at reboot time
  *	@nb: Info about notifier function to be called</pre><hr><pre>commit c16a02d6f5fcfe05dc6fd40aa80a8e1d055300db
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Sep 29 02:01:21 2006 -0700

    [PATCH] Add section on function return values to CodingStyle
    
    This patch (as776) adds a new chapter to Documentation/CodingStyle,
    explaining the circumstances under which a function should return 0 for
    failure and non-zero for success as opposed to a negative error code for
    failure and 0 for success.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/Documentation/CodingStyle b/Documentation/CodingStyle
index 6d2412ec91ed..29c18966b050 100644
--- a/Documentation/CodingStyle
+++ b/Documentation/CodingStyle
@@ -532,6 +532,40 @@ appears outweighs the potential value of the hint that tells gcc to do
 something it would have done anyway.
 
 
+		Chapter 16: Function return values and names
+
+Functions can return values of many different kinds, and one of the
+most common is a value indicating whether the function succeeded or
+failed.  Such a value can be represented as an error-code integer
+(-Exxx = failure, 0 = success) or a "succeeded" boolean (0 = failure,
+non-zero = success).
+
+Mixing up these two sorts of representations is a fertile source of
+difficult-to-find bugs.  If the C language included a strong distinction
+between integers and booleans then the compiler would find these mistakes
+for us... but it doesn't.  To help prevent such bugs, always follow this
+convention:
+
+	If the name of a function is an action or an imperative command,
+	the function should return an error-code integer.  If the name
+	is a predicate, the function should return a "succeeded" boolean.
+
+For example, "add work" is a command, and the add_work() function returns 0
+for success or -EBUSY for failure.  In the same way, "PCI device present" is
+a predicate, and the pci_dev_present() function returns 1 if it succeeds in
+finding a matching device or 0 if it doesn't.
+
+All EXPORTed functions must respect this convention, and so should all
+public functions.  Private (static) functions need not, but it is
+recommended that they do.
+
+Functions whose return value is the actual result of a computation, rather
+than an indication of whether the computation succeeded, are not subject to
+this rule.  Generally they indicate failure by returning some out-of-range
+result.  Typical examples would be functions that return pointers; they use
+NULL or the ERR_PTR mechanism to report failure.
+
+
 
 		Appendix I: References
 </pre><hr><pre>commit 6174d0fd35f486f59b743630bdf088a9f9792d4d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 26 14:51:48 2006 -0400

    USB: g_file_storage: Set sense info Valid bit only when needed
    
    Strictly speaking, the Valid bit in SCSI sense data is supposed to
    be set only when the Information field contains a valid number.  This
    patch (as793) turns off the Valid bit when the Information field
    hasn't been set.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/file_storage.c b/drivers/usb/gadget/file_storage.c
index d472c9c29904..c83d3b6c68f2 100644
--- a/drivers/usb/gadget/file_storage.c
+++ b/drivers/usb/gadget/file_storage.c
@@ -567,6 +567,7 @@ struct lun {
 	unsigned int	ro : 1;
 	unsigned int	prevent_medium_removal : 1;
 	unsigned int	registered : 1;
+	unsigned int	info_valid : 1;
 
 	u32		sense_data;
 	u32		sense_data_info;
@@ -1656,6 +1657,7 @@ static int do_read(struct fsg_dev *fsg)
 			curlun-&gt;sense_data =
 					SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;
 			curlun-&gt;sense_data_info = file_offset &gt;&gt; 9;
+			curlun-&gt;info_valid = 1;
 			bh-&gt;inreq-&gt;length = 0;
 			bh-&gt;state = BUF_STATE_FULL;
 			break;
@@ -1691,6 +1693,7 @@ static int do_read(struct fsg_dev *fsg)
 		if (nread &lt; amount) {
 			curlun-&gt;sense_data = SS_UNRECOVERED_READ_ERROR;
 			curlun-&gt;sense_data_info = file_offset &gt;&gt; 9;
+			curlun-&gt;info_valid = 1;
 			break;
 		}
 
@@ -1785,6 +1788,7 @@ static int do_write(struct fsg_dev *fsg)
 				curlun-&gt;sense_data =
 					SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;
 				curlun-&gt;sense_data_info = usb_offset &gt;&gt; 9;
+				curlun-&gt;info_valid = 1;
 				continue;
 			}
 			amount -= (amount &amp; 511);
@@ -1827,6 +1831,7 @@ static int do_write(struct fsg_dev *fsg)
 			if (bh-&gt;outreq-&gt;status != 0) {
 				curlun-&gt;sense_data = SS_COMMUNICATION_FAILURE;
 				curlun-&gt;sense_data_info = file_offset &gt;&gt; 9;
+				curlun-&gt;info_valid = 1;
 				break;
 			}
 
@@ -1868,6 +1873,7 @@ static int do_write(struct fsg_dev *fsg)
 			if (nwritten &lt; amount) {
 				curlun-&gt;sense_data = SS_WRITE_ERROR;
 				curlun-&gt;sense_data_info = file_offset &gt;&gt; 9;
+				curlun-&gt;info_valid = 1;
 				break;
 			}
 
@@ -2010,6 +2016,7 @@ static int do_verify(struct fsg_dev *fsg)
 			curlun-&gt;sense_data =
 					SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;
 			curlun-&gt;sense_data_info = file_offset &gt;&gt; 9;
+			curlun-&gt;info_valid = 1;
 			break;
 		}
 
@@ -2036,6 +2043,7 @@ static int do_verify(struct fsg_dev *fsg)
 		if (nread == 0) {
 			curlun-&gt;sense_data = SS_UNRECOVERED_READ_ERROR;
 			curlun-&gt;sense_data_info = file_offset &gt;&gt; 9;
+			curlun-&gt;info_valid = 1;
 			break;
 		}
 		file_offset += nread;
@@ -2079,6 +2087,7 @@ static int do_request_sense(struct fsg_dev *fsg, struct fsg_buffhd *bh)
 	struct lun	*curlun = fsg-&gt;curlun;
 	u8		*buf = (u8 *) bh-&gt;buf;
 	u32		sd, sdinfo;
+	int		valid;
 
 	/*
 	 * From the SCSI-2 spec., section 7.9 (Unit attention condition):
@@ -2106,15 +2115,18 @@ static int do_request_sense(struct fsg_dev *fsg, struct fsg_buffhd *bh)
 		fsg-&gt;bad_lun_okay = 1;
 		sd = SS_LOGICAL_UNIT_NOT_SUPPORTED;
 		sdinfo = 0;
+		valid = 0;
 	} else {
 		sd = curlun-&gt;sense_data;
 		sdinfo = curlun-&gt;sense_data_info;
+		valid = curlun-&gt;info_valid &lt;&lt; 7;
 		curlun-&gt;sense_data = SS_NO_SENSE;
 		curlun-&gt;sense_data_info = 0;
+		curlun-&gt;info_valid = 0;
 	}
 
 	memset(buf, 0, 18);
-	buf[0] = 0x80 | 0x70;			// Valid, current error
+	buf[0] = valid | 0x70;			// Valid, current error
 	buf[2] = SK(sd);
 	put_be32(&amp;buf[3], sdinfo);		// Sense information
 	buf[7] = 18 - 8;			// Additional sense length
@@ -2703,6 +2715,7 @@ static int check_command(struct fsg_dev *fsg, int cmnd_size,
 		if (fsg-&gt;cmnd[0] != SC_REQUEST_SENSE) {
 			curlun-&gt;sense_data = SS_NO_SENSE;
 			curlun-&gt;sense_data_info = 0;
+			curlun-&gt;info_valid = 0;
 		}
 	} else {
 		fsg-&gt;curlun = curlun = NULL;
@@ -3332,6 +3345,7 @@ static void handle_exception(struct fsg_dev *fsg)
 			curlun-&gt;sense_data = curlun-&gt;unit_attention_data =
 					SS_NO_SENSE;
 			curlun-&gt;sense_data_info = 0;
+			curlun-&gt;info_valid = 0;
 		}
 		fsg-&gt;state = FSG_STATE_IDLE;
 	}</pre><hr><pre>commit e0318ebff4d96131bb3524308b845f642e64df81
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 26 14:50:20 2006 -0400

    USB: fix autosuspend when CONFIG_PM isn't set
    
    This patch (as791b) fixes things up to avoid compiler warnings or
    errors when CONFIG_USB_SUSPEND or CONFIG_PM isn't set.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index ee18d187ca17..113e484c763e 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -303,11 +303,11 @@ int usb_driver_claim_interface(struct usb_driver *driver,
 	dev-&gt;driver = &amp;driver-&gt;drvwrap.driver;
 	usb_set_intfdata(iface, priv);
 
-	mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
+	usb_pm_lock(udev);
 	iface-&gt;condition = USB_INTERFACE_BOUND;
 	mark_active(iface);
 	iface-&gt;pm_usage_cnt = !(driver-&gt;supports_autosuspend);
-	mutex_unlock(&amp;udev-&gt;pm_mutex);
+	usb_pm_unlock(udev);
 
 	/* if interface was already added, bind now; else let
 	 * the future device_add() bind it, bypassing probe()
@@ -356,11 +356,11 @@ void usb_driver_release_interface(struct usb_driver *driver,
 	dev-&gt;driver = NULL;
 	usb_set_intfdata(iface, NULL);
 
-	mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
+	usb_pm_lock(udev);
 	iface-&gt;condition = USB_INTERFACE_UNBOUND;
 	mark_quiesced(iface);
 	iface-&gt;needs_remote_wakeup = 0;
-	mutex_unlock(&amp;udev-&gt;pm_mutex);
+	usb_pm_unlock(udev);
 }
 EXPORT_SYMBOL(usb_driver_release_interface);
 
@@ -789,7 +789,7 @@ EXPORT_SYMBOL_GPL_FUTURE(usb_deregister);
 
 #ifdef CONFIG_PM
 
-/* Caller has locked udev-&gt;pm_mutex */
+/* Caller has locked udev's pm_mutex */
 static int suspend_device(struct usb_device *udev, pm_message_t msg)
 {
 	struct usb_device_driver	*udriver;
@@ -816,7 +816,7 @@ static int suspend_device(struct usb_device *udev, pm_message_t msg)
 	return status;
 }
 
-/* Caller has locked udev-&gt;pm_mutex */
+/* Caller has locked udev's pm_mutex */
 static int resume_device(struct usb_device *udev)
 {
 	struct usb_device_driver	*udriver;
@@ -842,7 +842,7 @@ static int resume_device(struct usb_device *udev)
 	return status;
 }
 
-/* Caller has locked intf's usb_device's pm_mutex */
+/* Caller has locked intf's usb_device's pm mutex */
 static int suspend_interface(struct usb_interface *intf, pm_message_t msg)
 {
 	struct usb_driver	*driver;
@@ -1064,7 +1064,7 @@ int usb_resume_both(struct usb_device *udev)
 	/* Propagate the resume up the tree, if necessary */
 	if (udev-&gt;state == USB_STATE_SUSPENDED) {
 		if (parent) {
-			mutex_lock_nested(&amp;parent-&gt;pm_mutex, parent-&gt;level);
+			usb_pm_lock(parent);
 			parent-&gt;auto_pm = 1;
 			status = usb_resume_both(parent);
 		} else {
@@ -1079,7 +1079,7 @@ int usb_resume_both(struct usb_device *udev)
 		if (status == 0)
 			status = resume_device(udev);
 		if (parent)
-			mutex_unlock(&amp;parent-&gt;pm_mutex);
+			usb_pm_unlock(parent);
 	} else {
 
 		/* Needed only for setting udev-&gt;dev.power.power_state.event
@@ -1129,12 +1129,12 @@ int usb_resume_both(struct usb_device *udev)
  */
 void usb_autosuspend_device(struct usb_device *udev, int dec_usage_cnt)
 {
-	mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
+	usb_pm_lock(udev);
 	udev-&gt;pm_usage_cnt -= dec_usage_cnt;
 	if (udev-&gt;pm_usage_cnt &lt;= 0)
 		queue_delayed_work(ksuspend_usb_wq, &amp;udev-&gt;autosuspend,
 				USB_AUTOSUSPEND_DELAY);
-	mutex_unlock(&amp;udev-&gt;pm_mutex);
+	usb_pm_unlock(udev);
 	// dev_dbg(&amp;udev-&gt;dev, "%s: cnt %d\n",
 	//		__FUNCTION__, udev-&gt;pm_usage_cnt);
 }
@@ -1168,13 +1168,13 @@ int usb_autoresume_device(struct usb_device *udev, int inc_usage_cnt)
 {
 	int	status;
 
-	mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
+	usb_pm_lock(udev);
 	udev-&gt;pm_usage_cnt += inc_usage_cnt;
 	udev-&gt;auto_pm = 1;
 	status = usb_resume_both(udev);
 	if (status != 0)
 		udev-&gt;pm_usage_cnt -= inc_usage_cnt;
-	mutex_unlock(&amp;udev-&gt;pm_mutex);
+	usb_pm_unlock(udev);
 	// dev_dbg(&amp;udev-&gt;dev, "%s: status %d cnt %d\n",
 	//		__FUNCTION__, status, udev-&gt;pm_usage_cnt);
 	return status;
@@ -1215,13 +1215,13 @@ void usb_autopm_put_interface(struct usb_interface *intf)
 {
 	struct usb_device	*udev = interface_to_usbdev(intf);
 
-	mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
+	usb_pm_lock(udev);
 	if (intf-&gt;condition != USB_INTERFACE_UNBOUND &amp;&amp;
 			--intf-&gt;pm_usage_cnt &lt;= 0) {
 		queue_delayed_work(ksuspend_usb_wq, &amp;udev-&gt;autosuspend,
 				USB_AUTOSUSPEND_DELAY);
 	}
-	mutex_unlock(&amp;udev-&gt;pm_mutex);
+	usb_pm_unlock(udev);
 	// dev_dbg(&amp;intf-&gt;dev, "%s: cnt %d\n",
 	//		__FUNCTION__, intf-&gt;pm_usage_cnt);
 }
@@ -1263,7 +1263,7 @@ int usb_autopm_get_interface(struct usb_interface *intf)
 	struct usb_device	*udev = interface_to_usbdev(intf);
 	int			status;
 
-	mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
+	usb_pm_lock(udev);
 	if (intf-&gt;condition == USB_INTERFACE_UNBOUND)
 		status = -ENODEV;
 	else {
@@ -1273,7 +1273,7 @@ int usb_autopm_get_interface(struct usb_interface *intf)
 		if (status != 0)
 			--intf-&gt;pm_usage_cnt;
 	}
-	mutex_unlock(&amp;udev-&gt;pm_mutex);
+	usb_pm_unlock(udev);
 	// dev_dbg(&amp;intf-&gt;dev, "%s: status %d cnt %d\n",
 	//		__FUNCTION__, status, intf-&gt;pm_usage_cnt);
 	return status;
@@ -1289,10 +1289,10 @@ static int usb_suspend(struct device *dev, pm_message_t message)
 	if (is_usb_device(dev)) {
 		struct usb_device *udev = to_usb_device(dev);
 
-		mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
+		usb_pm_lock(udev);
 		udev-&gt;auto_pm = 0;
 		status = usb_suspend_both(udev, message);
-		mutex_unlock(&amp;udev-&gt;pm_mutex);
+		usb_pm_unlock(udev);
 	} else
 		status = 0;
 	return status;
@@ -1305,10 +1305,10 @@ static int usb_resume(struct device *dev)
 	if (is_usb_device(dev)) {
 		struct usb_device *udev = to_usb_device(dev);
 
-		mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
+		usb_pm_lock(udev);
 		udev-&gt;auto_pm = 0;
 		status = usb_resume_both(udev);
-		mutex_unlock(&amp;udev-&gt;pm_mutex);
+		usb_pm_unlock(udev);
 
 		/* Rebind drivers that had no suspend method? */
 	} else
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 2a8cb3c2b19c..7676690a0386 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1779,7 +1779,7 @@ static int remote_wakeup(struct usb_device *udev)
 	 * to the parent hub! */
 
 	usb_lock_device(udev);
-	mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
+	usb_pm_lock(udev);
 	if (udev-&gt;state == USB_STATE_SUSPENDED) {
 		dev_dbg(&amp;udev-&gt;dev, "usb %sresume\n", "wakeup-");
 		/* TRSMRCY = 10 msec */
@@ -1788,7 +1788,7 @@ static int remote_wakeup(struct usb_device *udev)
 		if (status == 0)
 			udev-&gt;dev.power.power_state.event = PM_EVENT_ON;
 	}
-	mutex_unlock(&amp;udev-&gt;pm_mutex);
+	usb_pm_unlock(udev);
 
 	if (status == 0)
 		usb_autoresume_device(udev, 0);
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index 239f8e5d247f..e4df9edf1bc0 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -214,10 +214,10 @@ static void usb_autosuspend_work(void *_udev)
 {
 	struct usb_device	*udev = _udev;
 
-	mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
+	usb_pm_lock(udev);
 	udev-&gt;auto_pm = 1;
 	usb_suspend_both(udev, PMSG_SUSPEND);
-	mutex_unlock(&amp;udev-&gt;pm_mutex);
+	usb_pm_unlock(udev);
 }
 
 #else
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index fb6eb41c374f..f69df137ec0e 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -36,6 +36,16 @@ extern int usb_resume_both(struct usb_device *udev);
 extern int usb_port_suspend(struct usb_device *dev);
 extern int usb_port_resume(struct usb_device *dev);
 
+static inline void usb_pm_lock(struct usb_device *udev)
+{
+	mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
+}
+
+static inline void usb_pm_unlock(struct usb_device *udev)
+{
+	mutex_unlock(&amp;udev-&gt;pm_mutex);
+}
+
 #else
 
 #define usb_suspend_both(udev, msg)	0
@@ -45,6 +55,8 @@ static inline int usb_resume_both(struct usb_device *udev)
 }
 #define usb_port_suspend(dev)		0
 #define usb_port_resume(dev)		0
+static inline void usb_pm_lock(struct usb_device *udev) {}
+static inline void usb_pm_unlock(struct usb_device *udev) {}
 
 #endif
 
@@ -58,7 +70,11 @@ extern int usb_autoresume_device(struct usb_device *udev, int inc_busy_cnt);
 #else
 
 #define usb_autosuspend_device(udev, dec_busy_cnt)	do {} while (0)
-#define usb_autoresume_device(udev, inc_busy_cnt)	0
+static inline int usb_autoresume_device(struct usb_device *udev,
+		int inc_busy_cnt)
+{
+	return 0;
+}
 
 #endif
 
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 0da15b0b02be..190cc1b78fe2 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -380,10 +380,10 @@ struct usb_device {
 	int maxchild;			/* Number of ports if hub */
 	struct usb_device *children[USB_MAXCHILDREN];
 
+	int pm_usage_cnt;		/* usage counter for autosuspend */
 #ifdef CONFIG_PM
 	struct work_struct autosuspend;	/* for delayed autosuspends */
 	struct mutex pm_mutex;		/* protects PM operations */
-	int pm_usage_cnt;		/* usage counter for autosuspend */
 
 	unsigned auto_pm:1;		/* autosuspend/resume in progress */
 	unsigned do_remote_wakeup:1;	/* remote wakeup should be enabled */</pre><hr><pre>commit 8d1a243ba5dda5c1a3cca5df8fb19ab8b138f074
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 26 14:46:16 2006 -0400

    OHCI: add auto-stop support
    
    This patch (as790b) adds "autostop" support to ohci-hcd: the driver
    will automatically stop the host controller when no devices have been
    connected for at least one second.  This feature is useful when the
    USB autosuspend facility isn't available, such as when
    CONFIG_USB_SUSPEND hasn't been set.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index 1027aa04583d..d1d68c402251 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -715,17 +715,8 @@ static irqreturn_t ohci_irq (struct usb_hcd *hcd, struct pt_regs *ptregs)
 		return IRQ_NOTMINE;
 	}
 
-	/* NOTE:  vendors didn't always make the same implementation
-	 * choices for RHSC.  Sometimes it triggers on an edge (like
-	 * setting and maybe clearing a port status change bit); and
-	 * it's level-triggered on other silicon, active until khubd
-	 * clears all active port status change bits.  Poll by timer
-	 * til it's fully debounced and the difference won't matter.
-	 */
 	if (ints &amp; OHCI_INTR_RHSC) {
 		ohci_vdbg (ohci, "rhsc\n");
-		ohci_writel (ohci, OHCI_INTR_RHSC, &amp;regs-&gt;intrdisable);
-		hcd-&gt;poll_rh = 1;
 		ohci-&gt;next_statechange = jiffies + STATECHANGE_DELAY;
 		ohci_writel (ohci, OHCI_INTR_RHSC, &amp;regs-&gt;intrstatus);
 		usb_hcd_poll_rh_status(hcd);
@@ -743,13 +734,18 @@ static irqreturn_t ohci_irq (struct usb_hcd *hcd, struct pt_regs *ptregs)
 	if (ints &amp; OHCI_INTR_RD) {
 		ohci_vdbg (ohci, "resume detect\n");
 		ohci_writel (ohci, OHCI_INTR_RD, &amp;regs-&gt;intrstatus);
-		if (hcd-&gt;state != HC_STATE_QUIESCING)
+		hcd-&gt;poll_rh = 1;
+		if (ohci-&gt;autostop) {
+			spin_lock (&amp;ohci-&gt;lock);
+			ohci_rh_resume (ohci);
+			spin_unlock (&amp;ohci-&gt;lock);
+		} else
 			usb_hcd_resume_root_hub(hcd);
 	}
 
 	if (ints &amp; OHCI_INTR_WDH) {
 		if (HC_IS_RUNNING(hcd-&gt;state))
-			ohci_writel (ohci, OHCI_INTR_WDH, &amp;regs-&gt;intrdisable);	
+			ohci_writel (ohci, OHCI_INTR_WDH, &amp;regs-&gt;intrdisable);
 		spin_lock (&amp;ohci-&gt;lock);
 		dl_done_list (ohci, ptregs);
 		spin_unlock (&amp;ohci-&gt;lock);
diff --git a/drivers/usb/host/ohci-hub.c b/drivers/usb/host/ohci-hub.c
index ef4965450de5..f36cbd02736d 100644
--- a/drivers/usb/host/ohci-hub.c
+++ b/drivers/usb/host/ohci-hub.c
@@ -41,31 +41,20 @@ static void ohci_rhsc_enable (struct usb_hcd *hcd)
 {
 	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
 
-	hcd-&gt;poll_rh = 0;
 	ohci_writel (ohci, OHCI_INTR_RHSC, &amp;ohci-&gt;regs-&gt;intrenable);
 }
 
-#ifdef	CONFIG_PM
-
 #define OHCI_SCHED_ENABLES \
 	(OHCI_CTRL_CLE|OHCI_CTRL_BLE|OHCI_CTRL_PLE|OHCI_CTRL_IE)
 
 static void dl_done_list (struct ohci_hcd *, struct pt_regs *);
 static void finish_unlinks (struct ohci_hcd *, u16 , struct pt_regs *);
-static int ohci_restart (struct ohci_hcd *ohci);
 
-static int ohci_bus_suspend (struct usb_hcd *hcd)
+static int ohci_rh_suspend (struct ohci_hcd *ohci, int autostop)
+__releases(ohci-&gt;lock)
+__acquires(ohci-&gt;lock)
 {
-	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
 	int			status = 0;
-	unsigned long		flags;
-
-	spin_lock_irqsave (&amp;ohci-&gt;lock, flags);
-
-	if (unlikely(!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags))) {
-		spin_unlock_irqrestore (&amp;ohci-&gt;lock, flags);
-		return -ESHUTDOWN;
-	}
 
 	ohci-&gt;hc_control = ohci_readl (ohci, &amp;ohci-&gt;regs-&gt;control);
 	switch (ohci-&gt;hc_control &amp; OHCI_CTRL_HCFS) {
@@ -81,15 +70,16 @@ static int ohci_bus_suspend (struct usb_hcd *hcd)
 		ohci_dbg (ohci, "needs reinit!\n");
 		goto done;
 	case OHCI_USB_SUSPEND:
-		ohci_dbg (ohci, "already suspended\n");
-		goto done;
+		if (!ohci-&gt;autostop) {
+			ohci_dbg (ohci, "already suspended\n");
+			goto done;
+		}
 	}
-	ohci_dbg (ohci, "suspend root hub\n");
+	ohci_dbg (ohci, "%s root hub\n",
+			autostop ? "auto-stop" : "suspend");
 
 	/* First stop any processing */
-	if (ohci-&gt;hc_control &amp; OHCI_SCHED_ENABLES) {
-		int		limit;
-
+	if (!autostop &amp;&amp; (ohci-&gt;hc_control &amp; OHCI_SCHED_ENABLES)) {
 		ohci-&gt;hc_control &amp;= ~OHCI_SCHED_ENABLES;
 		ohci_writel (ohci, ohci-&gt;hc_control, &amp;ohci-&gt;regs-&gt;control);
 		ohci-&gt;hc_control = ohci_readl (ohci, &amp;ohci-&gt;regs-&gt;control);
@@ -99,24 +89,17 @@ static int ohci_bus_suspend (struct usb_hcd *hcd)
 		 * then the last WDH could take 6+ msec
 		 */
 		ohci_dbg (ohci, "stopping schedules ...\n");
-		limit = 2000;
-		while (limit &gt; 0) {
-			udelay (250);
-			limit =- 250;
-			if (ohci_readl (ohci, &amp;ohci-&gt;regs-&gt;intrstatus)
-					&amp; OHCI_INTR_SF)
-				break;
-		}
-		dl_done_list (ohci, NULL);
-		mdelay (7);
+		ohci-&gt;autostop = 0;
+		spin_unlock_irq (&amp;ohci-&gt;lock);
+		msleep (8);
+		spin_lock_irq (&amp;ohci-&gt;lock);
 	}
 	dl_done_list (ohci, NULL);
 	finish_unlinks (ohci, ohci_frame_no(ohci), NULL);
-	ohci_writel (ohci, ohci_readl (ohci, &amp;ohci-&gt;regs-&gt;intrstatus),
-			&amp;ohci-&gt;regs-&gt;intrstatus);
 
 	/* maybe resume can wake root hub */
-	if (device_may_wakeup(&amp;ohci_to_hcd(ohci)-&gt;self.root_hub-&gt;dev))
+	if (device_may_wakeup(&amp;ohci_to_hcd(ohci)-&gt;self.root_hub-&gt;dev) ||
+			autostop)
 		ohci-&gt;hc_control |= OHCI_CTRL_RWE;
 	else {
 		ohci_writel (ohci, OHCI_INTR_RHSC, &amp;ohci-&gt;regs-&gt;intrdisable);
@@ -132,13 +115,12 @@ static int ohci_bus_suspend (struct usb_hcd *hcd)
 	(void) ohci_readl (ohci, &amp;ohci-&gt;regs-&gt;control);
 
 	/* no resumes until devices finish suspending */
-	ohci-&gt;next_statechange = jiffies + msecs_to_jiffies (5);
-
-	/* no timer polling */
-	hcd-&gt;poll_rh = 0;
+	if (!autostop) {
+		ohci-&gt;next_statechange = jiffies + msecs_to_jiffies (5);
+		ohci-&gt;autostop = 0;
+	}
 
 done:
-	spin_unlock_irqrestore (&amp;ohci-&gt;lock, flags);
 	return status;
 }
 
@@ -151,24 +133,16 @@ static inline struct ed *find_head (struct ed *ed)
 }
 
 /* caller has locked the root hub */
-static int ohci_bus_resume (struct usb_hcd *hcd)
+static int ohci_rh_resume (struct ohci_hcd *ohci)
+__releases(ohci-&gt;lock)
+__acquires(ohci-&gt;lock)
 {
-	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
+	struct usb_hcd		*hcd = ohci_to_hcd (ohci);
 	u32			temp, enables;
 	int			status = -EINPROGRESS;
-	unsigned long		flags;
-
-	if (time_before (jiffies, ohci-&gt;next_statechange))
-		msleep(5);
-
-	spin_lock_irqsave (&amp;ohci-&gt;lock, flags);
-
-	if (unlikely(!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags))) {
-		spin_unlock_irqrestore (&amp;ohci-&gt;lock, flags);
-		return -ESHUTDOWN;
-	}
-
+	int			autostopped = ohci-&gt;autostop;
 
+	ohci-&gt;autostop = 0;
 	ohci-&gt;hc_control = ohci_readl (ohci, &amp;ohci-&gt;regs-&gt;control);
 
 	if (ohci-&gt;hc_control &amp; (OHCI_CTRL_IR | OHCI_SCHED_ENABLES)) {
@@ -188,7 +162,8 @@ static int ohci_bus_resume (struct usb_hcd *hcd)
 		ohci-&gt;hc_control |= OHCI_USB_RESUME;
 		ohci_writel (ohci, ohci-&gt;hc_control, &amp;ohci-&gt;regs-&gt;control);
 		(void) ohci_readl (ohci, &amp;ohci-&gt;regs-&gt;control);
-		ohci_dbg (ohci, "resume root hub\n");
+		ohci_dbg (ohci, "%s root hub\n",
+				autostopped ? "auto-start" : "resume");
 		break;
 	case OHCI_USB_RESUME:
 		/* HCFS changes sometime after INTR_RD */
@@ -203,16 +178,26 @@ static int ohci_bus_resume (struct usb_hcd *hcd)
 		ohci_dbg (ohci, "lost power\n");
 		status = -EBUSY;
 	}
-	spin_unlock_irqrestore (&amp;ohci-&gt;lock, flags);
+#ifdef	CONFIG_PM
 	if (status == -EBUSY) {
-		(void) ohci_init (ohci);
-		return ohci_restart (ohci);
+		if (!autostopped) {
+			static int ohci_restart (struct ohci_hcd *ohci);
+
+			spin_unlock_irq (&amp;ohci-&gt;lock);
+			(void) ohci_init (ohci);
+			status = ohci_restart (ohci);
+			spin_lock_irq (&amp;ohci-&gt;lock);
+		}
+		return status;
 	}
+#endif
 	if (status != -EINPROGRESS)
 		return status;
+	if (autostopped)
+		goto skip_resume;
+	spin_unlock_irq (&amp;ohci-&gt;lock);
 
 	temp = ohci-&gt;num_ports;
-	enables = 0;
 	while (temp--) {
 		u32 stat = ohci_readl (ohci,
 				       &amp;ohci-&gt;regs-&gt;roothub.portstatus [temp]);
@@ -245,17 +230,21 @@ static int ohci_bus_resume (struct usb_hcd *hcd)
 	/* Sometimes PCI D3 suspend trashes frame timings ... */
 	periodic_reinit (ohci);
 
+	/* the following code is executed with ohci-&gt;lock held and
+	 * irqs disabled if and only if autostopped is true
+	 */
+
+skip_resume:
 	/* interrupts might have been disabled */
 	ohci_writel (ohci, OHCI_INTR_INIT, &amp;ohci-&gt;regs-&gt;intrenable);
 	if (ohci-&gt;ed_rm_list)
 		ohci_writel (ohci, OHCI_INTR_SF, &amp;ohci-&gt;regs-&gt;intrenable);
-	ohci_writel (ohci, ohci_readl (ohci, &amp;ohci-&gt;regs-&gt;intrstatus),
-			&amp;ohci-&gt;regs-&gt;intrstatus);
 
 	/* Then re-enable operations */
 	ohci_writel (ohci, OHCI_USB_OPER, &amp;ohci-&gt;regs-&gt;control);
 	(void) ohci_readl (ohci, &amp;ohci-&gt;regs-&gt;control);
-	msleep (3);
+	if (!autostopped)
+		msleep (3);
 
 	temp = ohci-&gt;hc_control;
 	temp &amp;= OHCI_CTRL_RWC;
@@ -265,7 +254,11 @@ static int ohci_bus_resume (struct usb_hcd *hcd)
 	(void) ohci_readl (ohci, &amp;ohci-&gt;regs-&gt;control);
 
 	/* TRSMRCY */
-	msleep (10);
+	if (!autostopped) {
+		msleep (10);
+		spin_lock_irq (&amp;ohci-&gt;lock);
+	}
+	/* now ohci-&gt;lock is always held and irqs are always disabled */
 
 	/* keep it alive for more than ~5x suspend + resume costs */
 	ohci-&gt;next_statechange = jiffies + STATECHANGE_DELAY;
@@ -302,6 +295,45 @@ static int ohci_bus_resume (struct usb_hcd *hcd)
 	return 0;
 }
 
+#ifdef	CONFIG_PM
+
+static int ohci_bus_suspend (struct usb_hcd *hcd)
+{
+	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
+	int			rc;
+
+	spin_lock_irq (&amp;ohci-&gt;lock);
+
+	if (unlikely(!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags)))
+		rc = -ESHUTDOWN;
+	else
+		rc = ohci_rh_suspend (ohci, 0);
+	spin_unlock_irq (&amp;ohci-&gt;lock);
+	return rc;
+}
+
+static int ohci_bus_resume (struct usb_hcd *hcd)
+{
+	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
+	int			rc;
+
+	if (time_before (jiffies, ohci-&gt;next_statechange))
+		msleep(5);
+
+	spin_lock_irq (&amp;ohci-&gt;lock);
+
+	if (unlikely(!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags)))
+		rc = -ESHUTDOWN;
+	else
+		rc = ohci_rh_resume (ohci);
+	spin_unlock_irq (&amp;ohci-&gt;lock);
+
+	/* poll until we know a device is connected or we autostop */
+	if (rc == 0)
+		usb_hcd_poll_rh_status(hcd);
+	return rc;
+}
+
 #endif	/* CONFIG_PM */
 
 /*-------------------------------------------------------------------------*/
@@ -313,17 +345,11 @@ ohci_hub_status_data (struct usb_hcd *hcd, char *buf)
 {
 	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
 	int		i, changed = 0, length = 1;
+	int		any_connected = 0, rhsc_enabled = 1;
 	unsigned long	flags;
 
 	spin_lock_irqsave (&amp;ohci-&gt;lock, flags);
 
-	/* handle autosuspended root:  finish resuming before
-	 * letting khubd or root hub timer see state changes.
-	 */
-	if (unlikely((ohci-&gt;hc_control &amp; OHCI_CTRL_HCFS) != OHCI_USB_OPER
-		     || !HC_IS_RUNNING(hcd-&gt;state)))
-		goto done;
-
 	/* undocumented erratum seen on at least rev D */
 	if ((ohci-&gt;flags &amp; OHCI_QUIRK_AMD756)
 			&amp;&amp; (roothub_a (ohci) &amp; RH_A_NDP) &gt; MAX_ROOT_PORTS) {
@@ -347,6 +373,9 @@ ohci_hub_status_data (struct usb_hcd *hcd, char *buf)
 	for (i = 0; i &lt; ohci-&gt;num_ports; i++) {
 		u32	status = roothub_portstatus (ohci, i);
 
+		/* can't autostop if ports are connected */
+		any_connected |= (status &amp; RH_PS_CCS);
+
 		if (status &amp; (RH_PS_CSC | RH_PS_PESC | RH_PS_PSSC
 				| RH_PS_OCIC | RH_PS_PRSC)) {
 			changed = 1;
@@ -354,15 +383,69 @@ ohci_hub_status_data (struct usb_hcd *hcd, char *buf)
 			    buf [0] |= 1 &lt;&lt; (i + 1);
 			else
 			    buf [1] |= 1 &lt;&lt; (i - 7);
-			continue;
 		}
 	}
 
-	/* after root hub changes, stop polling after debouncing
-	 * for a while and maybe kicking in autosuspend
+	/* NOTE:  vendors didn't always make the same implementation
+	 * choices for RHSC.  Sometimes it triggers on an edge (like
+	 * setting and maybe clearing a port status change bit); and
+	 * it's level-triggered on other silicon, active until khubd
+	 * clears all active port status change bits.  If it's still
+	 * set (level-triggered) we must disable it and rely on
+	 * polling until khubd re-enables it.
 	 */
-	if (changed)
-		ohci-&gt;next_statechange = jiffies + STATECHANGE_DELAY;
+	if (ohci_readl (ohci, &amp;ohci-&gt;regs-&gt;intrstatus) &amp; OHCI_INTR_RHSC) {
+		ohci_writel (ohci, OHCI_INTR_RHSC, &amp;ohci-&gt;regs-&gt;intrdisable);
+		(void) ohci_readl (ohci, &amp;ohci-&gt;regs-&gt;intrdisable);
+		rhsc_enabled = 0;
+	}
+	hcd-&gt;poll_rh = 1;
+
+	/* carry out appropriate state changes */
+	switch (ohci-&gt;hc_control &amp; OHCI_CTRL_HCFS) {
+
+	case OHCI_USB_OPER:
+		/* keep on polling until we know a device is connected
+		 * and RHSC is enabled */
+		if (!ohci-&gt;autostop) {
+			if (any_connected) {
+				if (rhsc_enabled)
+					hcd-&gt;poll_rh = 0;
+			} else {
+				ohci-&gt;autostop = 1;
+				ohci-&gt;next_statechange = jiffies + HZ;
+			}
+
+		/* if no devices have been attached for one second, autostop */
+		} else {
+			if (changed || any_connected) {
+				ohci-&gt;autostop = 0;
+				ohci-&gt;next_statechange = jiffies +
+						STATECHANGE_DELAY;
+			} else if (time_after_eq (jiffies,
+						ohci-&gt;next_statechange)
+					&amp;&amp; !ohci-&gt;ed_rm_list
+					&amp;&amp; !(ohci-&gt;hc_control &amp;
+						OHCI_SCHED_ENABLES)) {
+				ohci_rh_suspend (ohci, 1);
+			}
+		}
+		break;
+
+	/* if there is a port change, autostart or ask to be resumed */
+	case OHCI_USB_SUSPEND:
+	case OHCI_USB_RESUME:
+		if (changed) {
+			if (ohci-&gt;autostop)
+				ohci_rh_resume (ohci);
+			else
+				usb_hcd_resume_root_hub (hcd);
+		} else {
+			/* everything is idle, no need for polling */
+			hcd-&gt;poll_rh = 0;
+		}
+		break;
+	}
 
 done:
 	spin_unlock_irqrestore (&amp;ohci-&gt;lock, flags);
diff --git a/drivers/usb/host/ohci.h b/drivers/usb/host/ohci.h
index 93fdc3c35341..a2f42a2f47c6 100644
--- a/drivers/usb/host/ohci.h
+++ b/drivers/usb/host/ohci.h
@@ -388,6 +388,7 @@ struct ohci_hcd {
 	u32 			hc_control;	/* copy of hc control reg */
 	unsigned long		next_statechange;	/* suspend/resume */
 	u32			fminterval;		/* saved register */
+	unsigned		autostop:1;	/* rh auto stopping/stopped */
 
 	unsigned long		flags;		/* for HC bugs */
 #define	OHCI_QUIRK_AMD756	0x01			/* erratum #4 */</pre><hr><pre>commit 1f7e1a3b7e05c833229c4b6e9d3c96262df59e99
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Sep 25 15:41:21 2006 -0400

    OHCI: remove existing autosuspend code
    
    The autosuspend technique used by ohci-hcd doesn't mesh well with the
    newer USB core autosuspend code.  This patch (as789) removes ohci-hcd's
    autosuspend support.  Now the driver will be usable, but it won't
    automatically go into a low-power state when no devices are connected.
    That's for a later patch.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ohci-hub.c b/drivers/usb/host/ohci-hub.c
index 0b899339cac8..ef4965450de5 100644
--- a/drivers/usb/host/ohci-hub.c
+++ b/drivers/usb/host/ohci-hub.c
@@ -41,6 +41,7 @@ static void ohci_rhsc_enable (struct usb_hcd *hcd)
 {
 	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
 
+	hcd-&gt;poll_rh = 0;
 	ohci_writel (ohci, OHCI_INTR_RHSC, &amp;ohci-&gt;regs-&gt;intrenable);
 }
 
@@ -117,8 +118,10 @@ static int ohci_bus_suspend (struct usb_hcd *hcd)
 	/* maybe resume can wake root hub */
 	if (device_may_wakeup(&amp;ohci_to_hcd(ohci)-&gt;self.root_hub-&gt;dev))
 		ohci-&gt;hc_control |= OHCI_CTRL_RWE;
-	else
+	else {
+		ohci_writel (ohci, OHCI_INTR_RHSC, &amp;ohci-&gt;regs-&gt;intrdisable);
 		ohci-&gt;hc_control &amp;= ~OHCI_CTRL_RWE;
+	}
 
 	/* Suspend hub ... this is the "global (to this bus) suspend" mode,
 	 * which doesn't imply ports will first be individually suspended.
@@ -310,20 +313,16 @@ ohci_hub_status_data (struct usb_hcd *hcd, char *buf)
 {
 	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
 	int		i, changed = 0, length = 1;
-	int		can_suspend;
 	unsigned long	flags;
 
-	can_suspend = device_may_wakeup(&amp;hcd-&gt;self.root_hub-&gt;dev);
 	spin_lock_irqsave (&amp;ohci-&gt;lock, flags);
 
 	/* handle autosuspended root:  finish resuming before
 	 * letting khubd or root hub timer see state changes.
 	 */
 	if (unlikely((ohci-&gt;hc_control &amp; OHCI_CTRL_HCFS) != OHCI_USB_OPER
-		     || !HC_IS_RUNNING(hcd-&gt;state))) {
-		can_suspend = 0;
+		     || !HC_IS_RUNNING(hcd-&gt;state)))
 		goto done;
-	}
 
 	/* undocumented erratum seen on at least rev D */
 	if ((ohci-&gt;flags &amp; OHCI_QUIRK_AMD756)
@@ -348,10 +347,6 @@ ohci_hub_status_data (struct usb_hcd *hcd, char *buf)
 	for (i = 0; i &lt; ohci-&gt;num_ports; i++) {
 		u32	status = roothub_portstatus (ohci, i);
 
-		/* can't autosuspend with active ports */
-		if ((status &amp; RH_PS_PES) &amp;&amp; !(status &amp; RH_PS_PSS))
-			can_suspend = 0;
-
 		if (status &amp; (RH_PS_CSC | RH_PS_PESC | RH_PS_PSSC
 				| RH_PS_OCIC | RH_PS_PRSC)) {
 			changed = 1;
@@ -366,42 +361,12 @@ ohci_hub_status_data (struct usb_hcd *hcd, char *buf)
 	/* after root hub changes, stop polling after debouncing
 	 * for a while and maybe kicking in autosuspend
 	 */
-	if (changed) {
+	if (changed)
 		ohci-&gt;next_statechange = jiffies + STATECHANGE_DELAY;
-		can_suspend = 0;
-	} else if (time_before (jiffies, ohci-&gt;next_statechange)) {
-		can_suspend = 0;
-	} else {
-#ifdef	CONFIG_PM
-		can_suspend = can_suspend
-			&amp;&amp; !ohci-&gt;ed_rm_list
-			&amp;&amp; ((OHCI_CTRL_HCFS | OHCI_SCHED_ENABLES)
-					&amp; ohci-&gt;hc_control)
-				== OHCI_USB_OPER;
-#endif
-		if (hcd-&gt;uses_new_polling) {
-			hcd-&gt;poll_rh = 0;
-			/* use INTR_RHSC iff INTR_RD won't apply */
-			if (!can_suspend)
-				ohci_writel (ohci, OHCI_INTR_RHSC,
-						&amp;ohci-&gt;regs-&gt;intrenable);
-		}
-	}
 
 done:
 	spin_unlock_irqrestore (&amp;ohci-&gt;lock, flags);
 
-#ifdef	CONFIG_PM
-	/* save power by autosuspending idle root hubs;
-	 * INTR_RD wakes us when there's work
-	 */
-	if (can_suspend &amp;&amp; usb_trylock_device (hcd-&gt;self.root_hub) == 0) {
-		ohci_vdbg (ohci, "autosuspend\n");
-		(void) ohci_bus_suspend (hcd);
-		usb_unlock_device (hcd-&gt;self.root_hub);
-	}
-#endif
-
 	return changed ? length : 0;
 }
 
@@ -572,9 +537,6 @@ static int ohci_hub_control (
 			break;
 		case USB_PORT_FEAT_SUSPEND:
 			temp = RH_PS_POCI;
-			if ((ohci-&gt;hc_control &amp; OHCI_CTRL_HCFS)
-					!= OHCI_USB_OPER)
-				usb_hcd_resume_root_hub(hcd);
 			break;
 		case USB_PORT_FEAT_C_SUSPEND:
 			temp = RH_PS_PSSC;</pre><hr><pre>commit d19ac7da72ab950c315d0da0aa03464587d88b53
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Sep 25 15:41:12 2006 -0400

    USB: allow both root-hub interrupts and polling
    
    Originally I didn't think any host controller driver would ever use
    interrupts and polling at the same time, but it turns out ohci-hcd wants
    to do exactly that.  This patch (as788) makes it possible.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 0d5cbf254e5e..37f9f5e7425d 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -836,8 +836,7 @@ void usb_enable_root_hub_irq (struct usb_bus *bus)
 	struct usb_hcd *hcd;
 
 	hcd = container_of (bus, struct usb_hcd, self);
-	if (hcd-&gt;driver-&gt;hub_irq_enable &amp;&amp; !hcd-&gt;poll_rh &amp;&amp;
-			hcd-&gt;state != HC_STATE_HALT)
+	if (hcd-&gt;driver-&gt;hub_irq_enable &amp;&amp; hcd-&gt;state != HC_STATE_HALT)
 		hcd-&gt;driver-&gt;hub_irq_enable (hcd);
 }
 </pre><hr><pre>commit 2de9eaefa7330b8e3d3fc5f31288cb1e826173a8
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Sep 25 14:31:15 2006 -0400

    USB: g_file_storage: fix "ignoring return value" warnings
    
    This patch (as792) fixes "ignoring return value" warnings in
    file_storage.c.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/file_storage.c b/drivers/usb/gadget/file_storage.c
index 8d7f1e84cd7b..d472c9c29904 100644
--- a/drivers/usb/gadget/file_storage.c
+++ b/drivers/usb/gadget/file_storage.c
@@ -3873,21 +3873,26 @@ static int __init fsg_bind(struct usb_gadget *gadget)
 	for (i = 0; i &lt; fsg-&gt;nluns; ++i) {
 		curlun = &amp;fsg-&gt;luns[i];
 		curlun-&gt;ro = mod_data.ro[i];
+		curlun-&gt;dev.release = lun_release;
 		curlun-&gt;dev.parent = &amp;gadget-&gt;dev;
 		curlun-&gt;dev.driver = &amp;fsg_driver.driver;
 		dev_set_drvdata(&amp;curlun-&gt;dev, fsg);
 		snprintf(curlun-&gt;dev.bus_id, BUS_ID_SIZE,
 				"%s-lun%d", gadget-&gt;dev.bus_id, i);
 
-		if ((rc = device_register(&amp;curlun-&gt;dev)) != 0)
+		if ((rc = device_register(&amp;curlun-&gt;dev)) != 0) {
 			INFO(fsg, "failed to register LUN%d: %d\n", i, rc);
-		else {
-			curlun-&gt;registered = 1;
-			curlun-&gt;dev.release = lun_release;
-			device_create_file(&amp;curlun-&gt;dev, &amp;dev_attr_ro);
-			device_create_file(&amp;curlun-&gt;dev, &amp;dev_attr_file);
-			kref_get(&amp;fsg-&gt;ref);
+			goto out;
+		}
+		if ((rc = device_create_file(&amp;curlun-&gt;dev,
+					&amp;dev_attr_ro)) != 0 ||
+				(rc = device_create_file(&amp;curlun-&gt;dev,
+					&amp;dev_attr_file)) != 0) {
+			device_unregister(&amp;curlun-&gt;dev);
+			goto out;
 		}
+		curlun-&gt;registered = 1;
+		kref_get(&amp;fsg-&gt;ref);
 
 		if (mod_data.file[i] &amp;&amp; *mod_data.file[i]) {
 			if ((rc = open_backing_file(curlun,</pre>
    <div class="pagination">
        <a href='2_117.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><span>[118]</span><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_119.html'>Next&gt;&gt;</a>
    <div>
</body>
