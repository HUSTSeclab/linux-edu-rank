<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_72.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><span>[73]</span><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_74.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit c2f6595fbdb408d3d6850cfae590c8fa93e27399
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Nov 18 11:37:15 2009 -0500

    USB: EHCI: don't send Clear-TT-Buffer following a STALL
    
    This patch (as1304) fixes a regression in ehci-hcd.  Evidently some
    hubs don't handle Clear-TT-Buffer requests correctly, so we should
    avoid sending them when they don't appear to be absolutely necessary.
    The reported symptom is that output on a downstream audio device cuts
    out because the hub stops relaying isochronous packets.
    
    The patch prevents Clear-TT-Buffer requests from being sent following
    a STALL handshake.  In theory a STALL indicates either that the
    downstream device sent a STALL or that no matching TT buffer could be
    found.  In either case, the transfer is completed and the TT buffer
    does not remain busy, so it doesn't need to be cleared.
    
    Also, the patch fixes a minor flaw in the code that actually sends the
    Clear-TT-Buffer requests.  Although the pipe direction isn't really
    used for control transfers, it should be a Send rather than a Receive.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Javier Kohen &lt;jkohen@users.sourceforge.net&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 5ce839137ad6..0f857e645058 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -444,7 +444,7 @@ static void hub_irq(struct urb *urb)
 static inline int
 hub_clear_tt_buffer (struct usb_device *hdev, u16 devinfo, u16 tt)
 {
-	return usb_control_msg(hdev, usb_rcvctrlpipe(hdev, 0),
+	return usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),
 			       HUB_CLEAR_TT_BUFFER, USB_RT_PORT, devinfo,
 			       tt, NULL, 0, 1000);
 }
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 00ad9ce392ed..139a2cc3f641 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -487,8 +487,20 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 			 * we must clear the TT buffer (11.17.5).
 			 */
 			if (unlikely(last_status != -EINPROGRESS &amp;&amp;
-					last_status != -EREMOTEIO))
-				ehci_clear_tt_buffer(ehci, qh, urb, token);
+					last_status != -EREMOTEIO)) {
+				/* The TT's in some hubs malfunction when they
+				 * receive this request following a STALL (they
+				 * stop sending isochronous packets).  Since a
+				 * STALL can't leave the TT buffer in a busy
+				 * state (if you believe Figures 11-48 - 11-51
+				 * in the USB 2.0 spec), we won't clear the TT
+				 * buffer in this case.  Strictly speaking this
+				 * is a violation of the spec.
+				 */
+				if (last_status != -EPIPE)
+					ehci_clear_tt_buffer(ehci, qh, urb,
+							token);
+			}
 		}
 
 		/* if we're removing something not at the queue head,</pre><hr><pre>commit 862f89b3d4c6bf3caab7fc69661fc6e725edd00a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Nov 25 01:06:37 2009 +0100

    PM: fix irq enable/disable in runtime PM code
    
    This patch (as1305) fixes a bug in the irq-enable settings and removes
    some related overhead in the runtime PM code.
    
            In __pm_runtime_resume(), within the scope of the original
            spin_lock_irq(), we know that irqs are disabled.  There's no
            reason to go through a pair of enable/disable cycles when
            acquiring and releasing the parent's lock.
    
            In __pm_runtime_set_status(), irqs are already disabled when
            the parent's lock is acquired, and they must remain disabled
            when it is released.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;

diff --git a/drivers/base/power/runtime.c b/drivers/base/power/runtime.c
index a770498a74ec..846d89e3d122 100644
--- a/drivers/base/power/runtime.c
+++ b/drivers/base/power/runtime.c
@@ -328,11 +328,11 @@ int __pm_runtime_resume(struct device *dev, bool from_wq)
 		 * necessary.
 		 */
 		parent = dev-&gt;parent;
-		spin_unlock_irq(&amp;dev-&gt;power.lock);
+		spin_unlock(&amp;dev-&gt;power.lock);
 
 		pm_runtime_get_noresume(parent);
 
-		spin_lock_irq(&amp;parent-&gt;power.lock);
+		spin_lock(&amp;parent-&gt;power.lock);
 		/*
 		 * We can resume if the parent's run-time PM is disabled or it
 		 * is set to ignore children.
@@ -343,9 +343,9 @@ int __pm_runtime_resume(struct device *dev, bool from_wq)
 			if (parent-&gt;power.runtime_status != RPM_ACTIVE)
 				retval = -EBUSY;
 		}
-		spin_unlock_irq(&amp;parent-&gt;power.lock);
+		spin_unlock(&amp;parent-&gt;power.lock);
 
-		spin_lock_irq(&amp;dev-&gt;power.lock);
+		spin_lock(&amp;dev-&gt;power.lock);
 		if (retval)
 			goto out;
 		goto repeat;
@@ -777,7 +777,7 @@ int __pm_runtime_set_status(struct device *dev, unsigned int status)
 	}
 
 	if (parent) {
-		spin_lock_irq(&amp;parent-&gt;power.lock);
+		spin_lock(&amp;parent-&gt;power.lock);
 
 		/*
 		 * It is invalid to put an active child under a parent that is
@@ -793,7 +793,7 @@ int __pm_runtime_set_status(struct device *dev, unsigned int status)
 				atomic_inc(&amp;parent-&gt;power.child_count);
 		}
 
-		spin_unlock_irq(&amp;parent-&gt;power.lock);
+		spin_unlock(&amp;parent-&gt;power.lock);
 
 		if (error)
 			goto out;</pre><hr><pre>commit fca94748c5136ff390eadc443871b82f1f77dcd6
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Nov 4 11:35:53 2009 -0500

    USB: usbmon: fix bug in mon_buff_area_shrink
    
    This patch (as1299b) fixes a bug in an error-handling path of usbmon's
    binary interface.  The storage area for URB data is divided into
    fixed-size blocks.  If an URB's data can't be copied, the area
    reserved for it should be decreased to the size of the truncated
    information (rounded up to a block boundary).  Rounding up the amount
    to be removed and subtracting it from the reserved size is definitely
    the wrong thing to do.
    
    Also, when the data for an isochronous URB can't be copied, we can
    still copy the isoc packet descriptors.  In fact the current code does
    copy the descriptors, but then sets the capture length to 0 so they
    remain inaccessible.  The capture length should be reduced to the
    length of the descriptors, not set to 0.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Pete Zaitcev &lt;zaitcev@redhat.com&gt;
    CC: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/mon/mon_bin.c b/drivers/usb/mon/mon_bin.c
index 9ed3e741bee1..10f3205798e8 100644
--- a/drivers/usb/mon/mon_bin.c
+++ b/drivers/usb/mon/mon_bin.c
@@ -348,12 +348,12 @@ static unsigned int mon_buff_area_alloc_contiguous(struct mon_reader_bin *rp,
 
 /*
  * Return a few (kilo-)bytes to the head of the buffer.
- * This is used if a DMA fetch fails.
+ * This is used if a data fetch fails.
  */
 static void mon_buff_area_shrink(struct mon_reader_bin *rp, unsigned int size)
 {
 
-	size = (size + PKT_ALIGN-1) &amp; ~(PKT_ALIGN-1);
+	/* size &amp;= ~(PKT_ALIGN-1);  -- we're called with aligned size */
 	rp-&gt;b_cnt -= size;
 	if (rp-&gt;b_in &lt; size)
 		rp-&gt;b_in += rp-&gt;b_size;
@@ -433,6 +433,7 @@ static void mon_bin_event(struct mon_reader_bin *rp, struct urb *urb,
 	unsigned int urb_length;
 	unsigned int offset;
 	unsigned int length;
+	unsigned int delta;
 	unsigned int ndesc, lendesc;
 	unsigned char dir;
 	struct mon_bin_hdr *ep;
@@ -537,8 +538,10 @@ static void mon_bin_event(struct mon_reader_bin *rp, struct urb *urb,
 	if (length != 0) {
 		ep-&gt;flag_data = mon_bin_get_data(rp, offset, urb, length);
 		if (ep-&gt;flag_data != 0) {	/* Yes, it's 0x00, not '0' */
-			ep-&gt;len_cap = 0;
-			mon_buff_area_shrink(rp, length);
+			delta = (ep-&gt;len_cap + PKT_ALIGN-1) &amp; ~(PKT_ALIGN-1);
+			ep-&gt;len_cap -= length;
+			delta -= (ep-&gt;len_cap + PKT_ALIGN-1) &amp; ~(PKT_ALIGN-1);
+			mon_buff_area_shrink(rp, delta);
 		}
 	} else {
 		ep-&gt;flag_data = data_tag;</pre><hr><pre>commit f1a0743bc0e7a30c032b1eb78f6a2b0f805b4597
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Oct 6 14:07:57 2009 -0400

    USB: storage: When a device returns no sense data, call it a Hardware Error
    
    This patch (as1294) fixes a problem that has plagued users for several
    kernel releases.  Some USB mass-storage devices don't return any sense
    data when they encounter certain kinds of errors.  The SCSI layer
    interprets this to mean that the operation should be retried, and the
    same thing happens -- over and over again with no limit.  In some
    circumstances (such as when a bus reset occurs) that is the right
    thing to do, but not here.
    
    The patch checks for this condition (a transport failure with no sense
    data) and changes the result code to DID_ERROR and the sense code to
    Hardware Error.  This does get only a limited number of retries, and
    so the command will fail relatively quickly instead of getting stuck
    in an infinite loop.
    
    This fixes a large part of Bugzilla #14118.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Mantas Mikulenas &lt;grawity@gmail.com&gt;
    CC: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/transport.c b/drivers/usb/storage/transport.c
index e20dc525d177..3a4fb023af72 100644
--- a/drivers/usb/storage/transport.c
+++ b/drivers/usb/storage/transport.c
@@ -768,17 +768,32 @@ void usb_stor_invoke_transport(struct scsi_cmnd *srb, struct us_data *us)
 		/* set the result so the higher layers expect this data */
 		srb-&gt;result = SAM_STAT_CHECK_CONDITION;
 
-		/* If things are really okay, then let's show that.  Zero
-		 * out the sense buffer so the higher layers won't realize
-		 * we did an unsolicited auto-sense. */
-		if (result == USB_STOR_TRANSPORT_GOOD &amp;&amp;
-			/* Filemark 0, ignore EOM, ILI 0, no sense */
+		/* We often get empty sense data.  This could indicate that
+		 * everything worked or that there was an unspecified
+		 * problem.  We have to decide which.
+		 */
+		if (	/* Filemark 0, ignore EOM, ILI 0, no sense */
 				(srb-&gt;sense_buffer[2] &amp; 0xaf) == 0 &amp;&amp;
 			/* No ASC or ASCQ */
 				srb-&gt;sense_buffer[12] == 0 &amp;&amp;
 				srb-&gt;sense_buffer[13] == 0) {
-			srb-&gt;result = SAM_STAT_GOOD;
-			srb-&gt;sense_buffer[0] = 0x0;
+
+			/* If things are really okay, then let's show that.
+			 * Zero out the sense buffer so the higher layers
+			 * won't realize we did an unsolicited auto-sense.
+			 */
+			if (result == USB_STOR_TRANSPORT_GOOD) {
+				srb-&gt;result = SAM_STAT_GOOD;
+				srb-&gt;sense_buffer[0] = 0x0;
+
+			/* If there was a problem, report an unspecified
+			 * hardware error to prevent the higher layers from
+			 * entering an infinite retry loop.
+			 */
+			} else {
+				srb-&gt;result = DID_ERROR &lt;&lt; 16;
+				srb-&gt;sense_buffer[2] = HARDWARE_ERROR;
+			}
 		}
 	}
 </pre><hr><pre>commit 06bad89da686f6323e95cf925105e8cf88d87caf
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Oct 5 15:53:58 2009 -0400

    USB: ipaq: fix oops when device is plugged in
    
    This patch (as1293) fixes a problem with the ipaq serial driver.  It
    tries to bind to all the interfaces, even those that don't have enough
    endpoints.  The symptom is an invalid memory reference and oops when
    the device is plugged in.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: stable &lt;stable@kernel.org&gt;
    Tested-by: Matthias Geissert &lt;geissert@mathematik.tu-darmstadt.de&gt;
    Tested-by: Tilman Schmidt &lt;tilman@imap.cc&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 24fcc64b837d..d6231c38813e 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -966,6 +966,15 @@ static int ipaq_calc_num_ports(struct usb_serial *serial)
 static int ipaq_startup(struct usb_serial *serial)
 {
 	dbg("%s", __func__);
+
+	/* Some of the devices in ipaq_id_table[] are composite, and we
+	 * shouldn't bind to all the interfaces.  This test will rule out
+	 * some obviously invalid possibilities.
+	 */
+	if (serial-&gt;num_bulk_in &lt; serial-&gt;num_ports ||
+			serial-&gt;num_bulk_out &lt; serial-&gt;num_ports)
+		return -ENODEV;
+
 	if (serial-&gt;dev-&gt;actconfig-&gt;desc.bConfigurationValue != 1) {
 		/*
 		 * FIXME: HP iPaq rx3715, possibly others, have 1 config that</pre><hr><pre>commit a4720c650b68a5fe7faed2edeb0ad12645f7ae63
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Oct 9 12:43:12 2009 -0400

    USB: serial: don't call release without attach
    
    This patch (as1295) fixes a recently-added bug in the USB serial core.
    If certain kinds of errors occur during probing, the core may call a
    serial driver's release method without previously calling the attach
    method.  This causes some drivers (io_ti in particular) to perform an
    invalid memory access.
    
    The patch adds a new flag to keep track of whether or not attach has
    been called.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Jean-Denis Girard &lt;jd.girard@sysnux.pf&gt;
    CC: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/serial/usb-serial.c b/drivers/usb/serial/usb-serial.c
index aa6b2ae951ae..2d0f75d63ff0 100644
--- a/drivers/usb/serial/usb-serial.c
+++ b/drivers/usb/serial/usb-serial.c
@@ -156,7 +156,8 @@ static void destroy_serial(struct kref *kref)
 	if (serial-&gt;minor != SERIAL_TTY_NO_MINOR)
 		return_serial(serial);
 
-	serial-&gt;type-&gt;release(serial);
+	if (serial-&gt;attached)
+		serial-&gt;type-&gt;release(serial);
 
 	/* Now that nothing is using the ports, they can be freed */
 	for (i = 0; i &lt; serial-&gt;num_port_pointers; ++i) {
@@ -1059,12 +1060,15 @@ int usb_serial_probe(struct usb_interface *interface,
 		module_put(type-&gt;driver.owner);
 		if (retval &lt; 0)
 			goto probe_error;
+		serial-&gt;attached = 1;
 		if (retval &gt; 0) {
 			/* quietly accept this device, but don't bind to a
 			   serial port as it's about to disappear */
 			serial-&gt;num_ports = 0;
 			goto exit;
 		}
+	} else {
+		serial-&gt;attached = 1;
 	}
 
 	if (get_free_serial(serial, num_ports, &amp;minor) == NULL) {
diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index c17eb64d7213..ce911ebf91e8 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -150,6 +150,7 @@ struct usb_serial {
 	struct usb_interface		*interface;
 	unsigned char			disconnected:1;
 	unsigned char			suspending:1;
+	unsigned char			attached:1;
 	unsigned char			minor;
 	unsigned char			num_ports;
 	unsigned char			num_port_pointers;</pre><hr><pre>commit 01c6460f968d7b57fc6f98adb587952628c6e099
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 1 11:09:56 2009 -0400

    USB: usbfs: add USBDEVFS_URB_BULK_CONTINUATION flag
    
    This patch (as1283) adds a new flag, USBDEVFS_URB_BULK_CONTINUATION,
    to usbfs.  It is intended for userspace libraries such as libusb and
    openusb.  When they have to break up a single usbfs bulk transfer into
    multiple URBs, they will set the flag on all but the first URB of the
    series.
    
    If an error other than an unlink occurs, the kernel will automatically
    cancel all the following URBs for the same endpoint and refuse to
    accept new submissions, until an URB is encountered that is not marked
    as a BULK_CONTINUATION.  Such an URB would indicate the start of a new
    transfer or the presence of an older library, so the kernel returns to
    normal operation.
    
    This enables libraries to delimit bulk transfers correctly, even in
    the presence of early termination as indicated by short packets.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 71514be8b715..181f78c84105 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -74,6 +74,7 @@ struct dev_state {
 	void __user *disccontext;
 	unsigned long ifclaimed;
 	u32 secid;
+	u32 disabled_bulk_eps;
 };
 
 struct async {
@@ -88,6 +89,8 @@ struct async {
 	struct urb *urb;
 	int status;
 	u32 secid;
+	u8 bulk_addr;
+	u8 bulk_status;
 };
 
 static int usbfs_snoop;
@@ -343,6 +346,43 @@ static void snoop_urb(struct usb_device *udev,
 	}
 }
 
+#define AS_CONTINUATION	1
+#define AS_UNLINK	2
+
+static void cancel_bulk_urbs(struct dev_state *ps, unsigned bulk_addr)
+__releases(ps-&gt;lock)
+__acquires(ps-&gt;lock)
+{
+	struct async *as;
+
+	/* Mark all the pending URBs that match bulk_addr, up to but not
+	 * including the first one without AS_CONTINUATION.  If such an
+	 * URB is encountered then a new transfer has already started so
+	 * the endpoint doesn't need to be disabled; otherwise it does.
+	 */
+	list_for_each_entry(as, &amp;ps-&gt;async_pending, asynclist) {
+		if (as-&gt;bulk_addr == bulk_addr) {
+			if (as-&gt;bulk_status != AS_CONTINUATION)
+				goto rescan;
+			as-&gt;bulk_status = AS_UNLINK;
+			as-&gt;bulk_addr = 0;
+		}
+	}
+	ps-&gt;disabled_bulk_eps |= (1 &lt;&lt; bulk_addr);
+
+	/* Now carefully unlink all the marked pending URBs */
+ rescan:
+	list_for_each_entry(as, &amp;ps-&gt;async_pending, asynclist) {
+		if (as-&gt;bulk_status == AS_UNLINK) {
+			as-&gt;bulk_status = 0;		/* Only once */
+			spin_unlock(&amp;ps-&gt;lock);		/* Allow completions */
+			usb_unlink_urb(as-&gt;urb);
+			spin_lock(&amp;ps-&gt;lock);
+			goto rescan;
+		}
+	}
+}
+
 static void async_completed(struct urb *urb)
 {
 	struct async *as = urb-&gt;context;
@@ -371,6 +411,9 @@ static void async_completed(struct urb *urb)
 	snoop(&amp;urb-&gt;dev-&gt;dev, "urb complete\n");
 	snoop_urb(urb-&gt;dev, as-&gt;userurb, urb-&gt;pipe, urb-&gt;actual_length,
 			as-&gt;status, COMPLETE);
+	if (as-&gt;status &lt; 0 &amp;&amp; as-&gt;bulk_addr &amp;&amp; as-&gt;status != -ECONNRESET &amp;&amp;
+			as-&gt;status != -ENOENT)
+		cancel_bulk_urbs(ps, as-&gt;bulk_addr);
 	spin_unlock(&amp;ps-&gt;lock);
 
 	if (signr)
@@ -993,6 +1036,7 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 
 	if (uurb-&gt;flags &amp; ~(USBDEVFS_URB_ISO_ASAP |
 				USBDEVFS_URB_SHORT_NOT_OK |
+				USBDEVFS_URB_BULK_CONTINUATION |
 				USBDEVFS_URB_NO_FSBR |
 				USBDEVFS_URB_ZERO_PACKET |
 				USBDEVFS_URB_NO_INTERRUPT))
@@ -1194,7 +1238,39 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 	snoop_urb(ps-&gt;dev, as-&gt;userurb, as-&gt;urb-&gt;pipe,
 			as-&gt;urb-&gt;transfer_buffer_length, 0, SUBMIT);
 	async_newpending(as);
-	if ((ret = usb_submit_urb(as-&gt;urb, GFP_KERNEL))) {
+
+	if (usb_endpoint_xfer_bulk(&amp;ep-&gt;desc)) {
+		spin_lock_irq(&amp;ps-&gt;lock);
+
+		/* Not exactly the endpoint address; the direction bit is
+		 * shifted to the 0x10 position so that the value will be
+		 * between 0 and 31.
+		 */
+		as-&gt;bulk_addr = usb_endpoint_num(&amp;ep-&gt;desc) |
+			((ep-&gt;desc.bEndpointAddress &amp; USB_ENDPOINT_DIR_MASK)
+				&gt;&gt; 3);
+
+		/* If this bulk URB is the start of a new transfer, re-enable
+		 * the endpoint.  Otherwise mark it as a continuation URB.
+		 */
+		if (uurb-&gt;flags &amp; USBDEVFS_URB_BULK_CONTINUATION)
+			as-&gt;bulk_status = AS_CONTINUATION;
+		else
+			ps-&gt;disabled_bulk_eps &amp;= ~(1 &lt;&lt; as-&gt;bulk_addr);
+
+		/* Don't accept continuation URBs if the endpoint is
+		 * disabled because of an earlier error.
+		 */
+		if (ps-&gt;disabled_bulk_eps &amp; (1 &lt;&lt; as-&gt;bulk_addr))
+			ret = -EREMOTEIO;
+		else
+			ret = usb_submit_urb(as-&gt;urb, GFP_ATOMIC);
+		spin_unlock_irq(&amp;ps-&gt;lock);
+	} else {
+		ret = usb_submit_urb(as-&gt;urb, GFP_KERNEL);
+	}
+
+	if (ret) {
 		dev_printk(KERN_DEBUG, &amp;ps-&gt;dev-&gt;dev,
 			   "usbfs: usb_submit_urb returned %d\n", ret);
 		snoop_urb(ps-&gt;dev, as-&gt;userurb, as-&gt;urb-&gt;pipe,
diff --git a/include/linux/usbdevice_fs.h b/include/linux/usbdevice_fs.h
index 00ceebeb9e5c..b2a7d8ba6ee3 100644
--- a/include/linux/usbdevice_fs.h
+++ b/include/linux/usbdevice_fs.h
@@ -77,6 +77,7 @@ struct usbdevfs_connectinfo {
 
 #define USBDEVFS_URB_SHORT_NOT_OK	0x01
 #define USBDEVFS_URB_ISO_ASAP		0x02
+#define USBDEVFS_URB_BULK_CONTINUATION	0x04
 #define USBDEVFS_URB_NO_FSBR		0x20
 #define USBDEVFS_URB_ZERO_PACKET	0x40
 #define USBDEVFS_URB_NO_INTERRUPT	0x80</pre><hr><pre>commit a448c9d8c58ff7d3f8cc2a8f835065460099b22d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 19 12:22:44 2009 -0400

    USB: EHCI: change deschedule logic for interrupt QHs
    
    This patch (as1281) changes the way ehci-hcd deschedules interrupt
    QHs, copying the approach used for async QHs.  The caller is no longer
    responsible for rescheduling the QH if its queue is non-empty; instead
    the reschedule is done directly by intr_deschedule(), after calling
    qh_completions().  This is exactly the same as how end_unlink_async()
    works.
    
    ehci_urb_dequeue() and intr_deschedule() now correctly handle the case
    where they are called while another interrupt URB for the same QH is
    being given back.  This was a surprisingly large blind spot.  And
    scan_periodic() now respects the new needs_rescan flag.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index d7e85b6231b3..4f89d7ffd53a 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -934,8 +934,9 @@ static int ehci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 			break;
 		switch (qh-&gt;qh_state) {
 		case QH_STATE_LINKED:
+		case QH_STATE_COMPLETING:
 			intr_deschedule (ehci, qh);
-			/* FALL THROUGH */
+			break;
 		case QH_STATE_IDLE:
 			qh_completions (ehci, qh);
 			break;
@@ -944,23 +945,6 @@ static int ehci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 					qh, qh-&gt;qh_state);
 			goto done;
 		}
-
-		/* reschedule QH iff another request is queued */
-		if (!list_empty (&amp;qh-&gt;qtd_list)
-				&amp;&amp; HC_IS_RUNNING (hcd-&gt;state)) {
-			rc = qh_schedule(ehci, qh);
-
-			/* An error here likely indicates handshake failure
-			 * or no space left in the schedule.  Neither fault
-			 * should happen often ...
-			 *
-			 * FIXME kill the now-dysfunctional queued urbs
-			 */
-			if (rc != 0)
-				ehci_err(ehci,
-					"can't reschedule qh %p, err %d",
-					qh, rc);
-		}
 		break;
 
 	case PIPE_ISOCHRONOUS:
@@ -1079,12 +1063,10 @@ ehci_endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 			 * while the QH is active.  Unlink it now;
 			 * re-linking will call qh_refresh().
 			 */
-			if (eptype == USB_ENDPOINT_XFER_BULK) {
+			if (eptype == USB_ENDPOINT_XFER_BULK)
 				unlink_async(ehci, qh);
-			} else {
+			else
 				intr_deschedule(ehci, qh);
-				(void) qh_schedule(ehci, qh);
-			}
 		}
 	}
 	spin_unlock_irqrestore(&amp;ehci-&gt;lock, flags);
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 57a84795c43f..00ad9ce392ed 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -299,7 +299,6 @@ __acquires(ehci-&gt;lock)
 static void start_unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh);
 static void unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh);
 
-static void intr_deschedule (struct ehci_hcd *ehci, struct ehci_qh *qh);
 static int qh_schedule (struct ehci_hcd *ehci, struct ehci_qh *qh);
 
 /*
@@ -555,14 +554,9 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 			 * That should be rare for interrupt transfers,
 			 * except maybe high bandwidth ...
 			 */
-			if ((cpu_to_hc32(ehci, QH_SMASK)
-					&amp; hw-&gt;hw_info2) != 0) {
-				intr_deschedule (ehci, qh);
-				(void) qh_schedule (ehci, qh);
-			} else {
-				/* Tell the caller to start an unlink */
-				qh-&gt;needs_rescan = 1;
-			}
+
+			/* Tell the caller to start an unlink */
+			qh-&gt;needs_rescan = 1;
 			break;
 		/* otherwise, unlink already started */
 		}
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 327437af2122..3ea05936851f 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -615,8 +615,19 @@ static int qh_unlink_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)
 
 static void intr_deschedule (struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
-	unsigned	wait;
-	struct ehci_qh_hw *hw = qh-&gt;hw;
+	unsigned		wait;
+	struct ehci_qh_hw	*hw = qh-&gt;hw;
+	int			rc;
+
+	/* If the QH isn't linked then there's nothing we can do
+	 * unless we were called during a giveback, in which case
+	 * qh_completions() has to deal with it.
+	 */
+	if (qh-&gt;qh_state != QH_STATE_LINKED) {
+		if (qh-&gt;qh_state == QH_STATE_COMPLETING)
+			qh-&gt;needs_rescan = 1;
+		return;
+	}
 
 	qh_unlink_periodic (ehci, qh);
 
@@ -636,6 +647,24 @@ static void intr_deschedule (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	qh-&gt;qh_state = QH_STATE_IDLE;
 	hw-&gt;hw_next = EHCI_LIST_END(ehci);
 	wmb ();
+
+	qh_completions(ehci, qh);
+
+	/* reschedule QH iff another request is queued */
+	if (!list_empty(&amp;qh-&gt;qtd_list) &amp;&amp;
+			HC_IS_RUNNING(ehci_to_hcd(ehci)-&gt;state)) {
+		rc = qh_schedule(ehci, qh);
+
+		/* An error here likely indicates handshake failure
+		 * or no space left in the schedule.  Neither fault
+		 * should happen often ...
+		 *
+		 * FIXME kill the now-dysfunctional queued urbs
+		 */
+		if (rc != 0)
+			ehci_err(ehci, "can't reschedule qh %p, err %d\n",
+					qh, rc);
+	}
 }
 
 /*-------------------------------------------------------------------------*/
@@ -2213,7 +2242,8 @@ scan_periodic (struct ehci_hcd *ehci)
 				type = Q_NEXT_TYPE(ehci, q.qh-&gt;hw-&gt;hw_next);
 				q = q.qh-&gt;qh_next;
 				modified = qh_completions (ehci, temp.qh);
-				if (unlikely (list_empty (&amp;temp.qh-&gt;qtd_list)))
+				if (unlikely(list_empty(&amp;temp.qh-&gt;qtd_list) ||
+						temp.qh-&gt;needs_rescan))
 					intr_deschedule (ehci, temp.qh);
 				qh_put (temp.qh);
 				break;</pre><hr><pre>commit 3a44494e233c0fdd818d485cfea8998500543589
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 19 12:22:06 2009 -0400

    USB: EHCI: rescan the queue after an unlink
    
    This patch (as1280) fixes an obscure bug in ehci-hcd's dequeuing logic
    for async URBs.  If a later URB is unlinked and the completion
    routine unlinks an earlier URB, then the earlier URB won't be given
    back in a timely manner because the endpoint queue isn't rescanned as
    it should be.
    
    Similar bugs occur if an endpoint is reset or a halt is cleared while
    a completion routine is running, because the subroutines don't test
    for the COMPLETING state.
    
    All these problems are solved by adding a new needs_rescan flag to the
    ehci_qh structure.  If the flag is set while scanning through an idle
    QH, the scan will be repeated.  If the QH isn't idle then an unlink
    cycle will be initiated, and the proper action will be taken when it
    becomes idle.
    
    Also, an unnecessary test is removed from qh_link_async(): That
    routine is never called if the QH's state isn't IDLE.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 6887aac5e73d..d7e85b6231b3 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -863,12 +863,18 @@ static void unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	if (!HC_IS_RUNNING(ehci_to_hcd(ehci)-&gt;state) &amp;&amp; ehci-&gt;reclaim)
 		end_unlink_async(ehci);
 
-	/* if it's not linked then there's nothing to do */
-	if (qh-&gt;qh_state != QH_STATE_LINKED)
-		;
+	/* If the QH isn't linked then there's nothing we can do
+	 * unless we were called during a giveback, in which case
+	 * qh_completions() has to deal with it.
+	 */
+	if (qh-&gt;qh_state != QH_STATE_LINKED) {
+		if (qh-&gt;qh_state == QH_STATE_COMPLETING)
+			qh-&gt;needs_rescan = 1;
+		return;
+	}
 
 	/* defer till later if busy */
-	else if (ehci-&gt;reclaim) {
+	if (ehci-&gt;reclaim) {
 		struct ehci_qh		*last;
 
 		for (last = ehci-&gt;reclaim;
@@ -1001,6 +1007,7 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 		qh-&gt;qh_state = QH_STATE_IDLE;
 	switch (qh-&gt;qh_state) {
 	case QH_STATE_LINKED:
+	case QH_STATE_COMPLETING:
 		for (tmp = ehci-&gt;async-&gt;qh_next.qh;
 				tmp &amp;&amp; tmp != qh;
 				tmp = tmp-&gt;qh_next.qh)
@@ -1065,7 +1072,8 @@ ehci_endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 		usb_settoggle(qh-&gt;dev, epnum, is_out, 0);
 		if (!list_empty(&amp;qh-&gt;qtd_list)) {
 			WARN_ONCE(1, "clear_halt for a busy endpoint\n");
-		} else if (qh-&gt;qh_state == QH_STATE_LINKED) {
+		} else if (qh-&gt;qh_state == QH_STATE_LINKED ||
+				qh-&gt;qh_state == QH_STATE_COMPLETING) {
 
 			/* The toggle value in the QH can't be updated
 			 * while the QH is active.  Unlink it now;
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 377ed530b920..57a84795c43f 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -310,13 +310,13 @@ static int qh_schedule (struct ehci_hcd *ehci, struct ehci_qh *qh);
 static unsigned
 qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
-	struct ehci_qtd		*last = NULL, *end = qh-&gt;dummy;
+	struct ehci_qtd		*last, *end = qh-&gt;dummy;
 	struct list_head	*entry, *tmp;
-	int			last_status = -EINPROGRESS;
+	int			last_status;
 	int			stopped;
 	unsigned		count = 0;
 	u8			state;
-	__le32			halt = HALT_BIT(ehci);
+	const __le32		halt = HALT_BIT(ehci);
 	struct ehci_qh_hw	*hw = qh-&gt;hw;
 
 	if (unlikely (list_empty (&amp;qh-&gt;qtd_list)))
@@ -327,11 +327,20 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	 * they add urbs to this qh's queue or mark them for unlinking.
 	 *
 	 * NOTE:  unlinking expects to be done in queue order.
+	 *
+	 * It's a bug for qh-&gt;qh_state to be anything other than
+	 * QH_STATE_IDLE, unless our caller is scan_async() or
+	 * scan_periodic().
 	 */
 	state = qh-&gt;qh_state;
 	qh-&gt;qh_state = QH_STATE_COMPLETING;
 	stopped = (state == QH_STATE_IDLE);
 
+ rescan:
+	last = NULL;
+	last_status = -EINPROGRESS;
+	qh-&gt;needs_rescan = 0;
+
 	/* remove de-activated QTDs from front of queue.
 	 * after faults (including short reads), cleanup this urb
 	 * then let the queue advance.
@@ -507,6 +516,21 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 		ehci_qtd_free (ehci, last);
 	}
 
+	/* Do we need to rescan for URBs dequeued during a giveback? */
+	if (unlikely(qh-&gt;needs_rescan)) {
+		/* If the QH is already unlinked, do the rescan now. */
+		if (state == QH_STATE_IDLE)
+			goto rescan;
+
+		/* Otherwise we have to wait until the QH is fully unlinked.
+		 * Our caller will start an unlink if qh-&gt;needs_rescan is
+		 * set.  But if an unlink has already started, nothing needs
+		 * to be done.
+		 */
+		if (state != QH_STATE_LINKED)
+			qh-&gt;needs_rescan = 0;
+	}
+
 	/* restore original state; caller must unlink or relink */
 	qh-&gt;qh_state = state;
 
@@ -535,8 +559,10 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 					&amp; hw-&gt;hw_info2) != 0) {
 				intr_deschedule (ehci, qh);
 				(void) qh_schedule (ehci, qh);
-			} else
-				unlink_async (ehci, qh);
+			} else {
+				/* Tell the caller to start an unlink */
+				qh-&gt;needs_rescan = 1;
+			}
 			break;
 		/* otherwise, unlink already started */
 		}
@@ -916,6 +942,8 @@ static void qh_link_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	if (unlikely(qh-&gt;clearing_tt))
 		return;
 
+	WARN_ON(qh-&gt;qh_state != QH_STATE_IDLE);
+
 	/* (re)start the async schedule? */
 	head = ehci-&gt;async;
 	timer_action_done (ehci, TIMER_ASYNC_OFF);
@@ -934,8 +962,7 @@ static void qh_link_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	}
 
 	/* clear halt and/or toggle; and maybe recover from silicon quirk */
-	if (qh-&gt;qh_state == QH_STATE_IDLE)
-		qh_refresh (ehci, qh);
+	qh_refresh(ehci, qh);
 
 	/* splice right after start */
 	qh-&gt;qh_next = head-&gt;qh_next;
@@ -1220,6 +1247,8 @@ static void scan_async (struct ehci_hcd *ehci)
 				qh = qh_get (qh);
 				qh-&gt;stamp = ehci-&gt;stamp;
 				temp = qh_completions (ehci, qh);
+				if (qh-&gt;needs_rescan)
+					unlink_async(ehci, qh);
 				qh_put (qh);
 				if (temp != 0) {
 					goto rescan;
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index ec3dba6b8e48..064e76821ff5 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -341,6 +341,7 @@ struct ehci_qh {
 	u32			refcount;
 	unsigned		stamp;
 
+	u8			needs_rescan;	/* Dequeue during giveback */
 	u8			qh_state;
 #define	QH_STATE_LINKED		1		/* HC sees this */
 #define	QH_STATE_UNLINK		2		/* HC may still see this */</pre><hr><pre>commit 823c3fd9cc71714fe22ea415a68da746800d5a9a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Aug 3 11:05:59 2009 -0400

    USB: s3c2410: unregister should call unbind, not disconnect
    
    This patch (as1275) fixes the s3c2410 device controller driver.  Its
    usb_gadget_unregister_driver() routine is supposed to call the gadget
    driver's unbind method, not the disconnect method.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/s3c2410_udc.c b/drivers/usb/gadget/s3c2410_udc.c
index a9b452fe6221..d5f4c1d45c97 100644
--- a/drivers/usb/gadget/s3c2410_udc.c
+++ b/drivers/usb/gadget/s3c2410_udc.c
@@ -1703,8 +1703,7 @@ int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
 	dprintk(DEBUG_NORMAL,"usb_gadget_register_driver() '%s'\n",
 		driver-&gt;driver.name);
 
-	if (driver-&gt;disconnect)
-		driver-&gt;disconnect(&amp;udc-&gt;gadget);
+	driver-&gt;unbind(&amp;udc-&gt;gadget);
 
 	device_del(&amp;udc-&gt;gadget.dev);
 	udc-&gt;driver = NULL;</pre>
    <div class="pagination">
        <a href='2_72.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><span>[73]</span><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_74.html'>Next&gt;&gt;</a>
    <div>
</body>
