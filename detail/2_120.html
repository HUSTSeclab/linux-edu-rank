<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_119.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><span>[120]</span><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_121.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 1720058343fa43a1a25bfad9e62ea06e7e9743b6
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 30 11:32:52 2006 -0400

    usbcore: trim down usb_bus structure
    
    As part of the ongoing program to flatten out the HCD bus-glue layer,
    this patch (as771b) eliminates the hcpriv, release, and kref fields
    from struct usb_bus.  hcpriv and release were not being used for
    anything worthwhile, and kref has been moved into the enclosing
    usb_hcd structure.
    
    Along with those changes, the patch gets rid of usb_bus_get and
    usb_bus_put, replacing them with usb_get_hcd and usb_put_hcd.
    
    The one interesting aspect is that the dev_set_drvdata call was
    removed from usb_put_hcd, where it clearly doesn't belong.  This means
    the driver private data won't get reset to NULL.  It shouldn't cause
    any problems, since the private data is undefined when no driver is
    bound.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/buffer.c b/drivers/usb/core/buffer.c
index f4f4ef0f377a..840442a25b61 100644
--- a/drivers/usb/core/buffer.c
+++ b/drivers/usb/core/buffer.c
@@ -104,7 +104,7 @@ void *hcd_buffer_alloc (
 	dma_addr_t		*dma
 )
 {
-	struct usb_hcd		*hcd = bus-&gt;hcpriv;
+	struct usb_hcd		*hcd = bus_to_hcd(bus);
 	int 			i;
 
 	/* some USB hosts just use PIO */
@@ -127,7 +127,7 @@ void hcd_buffer_free (
 	dma_addr_t		dma
 )
 {
-	struct usb_hcd		*hcd = bus-&gt;hcpriv;
+	struct usb_hcd		*hcd = bus_to_hcd(bus);
 	int 			i;
 
 	if (!addr)
diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 0cc14206920a..9dfc812de034 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -664,31 +664,6 @@ static int usb_rh_urb_dequeue (struct usb_hcd *hcd, struct urb *urb)
 
 /*-------------------------------------------------------------------------*/
 
-/* exported only within usbcore */
-struct usb_bus *usb_bus_get(struct usb_bus *bus)
-{
-	if (bus)
-		kref_get(&amp;bus-&gt;kref);
-	return bus;
-}
-
-static void usb_host_release(struct kref *kref)
-{
-	struct usb_bus *bus = container_of(kref, struct usb_bus, kref);
-
-	if (bus-&gt;release)
-		bus-&gt;release(bus);
-}
-
-/* exported only within usbcore */
-void usb_bus_put(struct usb_bus *bus)
-{
-	if (bus)
-		kref_put(&amp;bus-&gt;kref, usb_host_release);
-}
-
-/*-------------------------------------------------------------------------*/
-
 static struct class *usb_host_class;
 
 int usb_host_init(void)
@@ -720,15 +695,12 @@ static void usb_bus_init (struct usb_bus *bus)
 	bus-&gt;devnum_next = 1;
 
 	bus-&gt;root_hub = NULL;
-	bus-&gt;hcpriv = NULL;
 	bus-&gt;busnum = -1;
 	bus-&gt;bandwidth_allocated = 0;
 	bus-&gt;bandwidth_int_reqs  = 0;
 	bus-&gt;bandwidth_isoc_reqs = 0;
 
 	INIT_LIST_HEAD (&amp;bus-&gt;bus_list);
-
-	kref_init(&amp;bus-&gt;kref);
 }
 
 /*-------------------------------------------------------------------------*/
@@ -1081,7 +1053,7 @@ static void urb_unlink (struct urb *urb)
 int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
 {
 	int			status;
-	struct usb_hcd		*hcd = urb-&gt;dev-&gt;bus-&gt;hcpriv;
+	struct usb_hcd		*hcd = bus_to_hcd(urb-&gt;dev-&gt;bus);
 	struct usb_host_endpoint *ep;
 	unsigned long		flags;
 
@@ -1189,7 +1161,8 @@ int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
 /* called in any context */
 int usb_hcd_get_frame_number (struct usb_device *udev)
 {
-	struct usb_hcd	*hcd = (struct usb_hcd *)udev-&gt;bus-&gt;hcpriv;
+	struct usb_hcd	*hcd = bus_to_hcd(udev-&gt;bus);
+
 	if (!HC_IS_RUNNING (hcd-&gt;state))
 		return -ESHUTDOWN;
 	return hcd-&gt;driver-&gt;get_frame_number (hcd);
@@ -1262,7 +1235,7 @@ int usb_hcd_unlink_urb (struct urb *urb, int status)
 	spin_lock (&amp;hcd_data_lock);
 
 	sys = &amp;urb-&gt;dev-&gt;dev;
-	hcd = urb-&gt;dev-&gt;bus-&gt;hcpriv;
+	hcd = bus_to_hcd(urb-&gt;dev-&gt;bus);
 	if (hcd == NULL) {
 		retval = -ENODEV;
 		goto done;
@@ -1333,7 +1306,7 @@ void usb_hcd_endpoint_disable (struct usb_device *udev,
 	struct usb_hcd		*hcd;
 	struct urb		*urb;
 
-	hcd = udev-&gt;bus-&gt;hcpriv;
+	hcd = bus_to_hcd(udev-&gt;bus);
 
 	WARN_ON (!HC_IS_RUNNING (hcd-&gt;state) &amp;&amp; hcd-&gt;state != HC_STATE_HALT &amp;&amp;
 			udev-&gt;state != USB_STATE_NOTATTACHED);
@@ -1673,14 +1646,6 @@ EXPORT_SYMBOL_GPL (usb_hc_died);
 
 /*-------------------------------------------------------------------------*/
 
-static void hcd_release (struct usb_bus *bus)
-{
-	struct usb_hcd *hcd;
-
-	hcd = container_of(bus, struct usb_hcd, self);
-	kfree(hcd);
-}
-
 /**
  * usb_create_hcd - create and initialize an HCD structure
  * @driver: HC driver that will use this hcd
@@ -1705,10 +1670,9 @@ struct usb_hcd *usb_create_hcd (const struct hc_driver *driver,
 		return NULL;
 	}
 	dev_set_drvdata(dev, hcd);
+	kref_init(&amp;hcd-&gt;kref);
 
 	usb_bus_init(&amp;hcd-&gt;self);
-	hcd-&gt;self.hcpriv = hcd;
-	hcd-&gt;self.release = &amp;hcd_release;
 	hcd-&gt;self.controller = dev;
 	hcd-&gt;self.bus_name = bus_name;
 	hcd-&gt;self.uses_dma = (dev-&gt;dma_mask != NULL);
@@ -1725,10 +1689,25 @@ struct usb_hcd *usb_create_hcd (const struct hc_driver *driver,
 }
 EXPORT_SYMBOL (usb_create_hcd);
 
+static void hcd_release (struct kref *kref)
+{
+	struct usb_hcd *hcd = container_of (kref, struct usb_hcd, kref);
+
+	kfree(hcd);
+}
+
+struct usb_hcd *usb_get_hcd (struct usb_hcd *hcd)
+{
+	if (hcd)
+		kref_get (&amp;hcd-&gt;kref);
+	return hcd;
+}
+EXPORT_SYMBOL (usb_get_hcd);
+
 void usb_put_hcd (struct usb_hcd *hcd)
 {
-	dev_set_drvdata(hcd-&gt;self.controller, NULL);
-	usb_bus_put(&amp;hcd-&gt;self);
+	if (hcd)
+		kref_put (&amp;hcd-&gt;kref, hcd_release);
 }
 EXPORT_SYMBOL (usb_put_hcd);
 
diff --git a/drivers/usb/core/hcd.h b/drivers/usb/core/hcd.h
index 83e229914797..7a2bcba2ae61 100644
--- a/drivers/usb/core/hcd.h
+++ b/drivers/usb/core/hcd.h
@@ -55,12 +55,13 @@
 
 /*-------------------------------------------------------------------------*/
 
-struct usb_hcd {	/* usb_bus.hcpriv points to this */
+struct usb_hcd {
 
 	/*
 	 * housekeeping
 	 */
 	struct usb_bus		self;		/* hcd is-a bus */
+	struct kref		kref;		/* reference counter */
 
 	const char		*product_desc;	/* product/vendor string */
 	char			irq_descr[24];	/* driver + bus # */
@@ -129,8 +130,10 @@ static inline struct usb_bus *hcd_to_bus (struct usb_hcd *hcd)
 	return &amp;hcd-&gt;self;
 }
 
-
-// urb.hcpriv is really hardware-specific
+static inline struct usb_hcd *bus_to_hcd (struct usb_bus *bus)
+{
+	return container_of(bus, struct usb_hcd, self);
+}
 
 struct hcd_timeout {	/* timeouts we allocate */
 	struct list_head	timeout_list;
@@ -210,6 +213,7 @@ extern int usb_hcd_get_frame_number (struct usb_device *udev);
 
 extern struct usb_hcd *usb_create_hcd (const struct hc_driver *driver,
 		struct device *dev, char *bus_name);
+extern struct usb_hcd *usb_get_hcd (struct usb_hcd *hcd);
 extern void usb_put_hcd (struct usb_hcd *hcd);
 extern int usb_add_hcd(struct usb_hcd *hcd,
 		unsigned int irqnum, unsigned long irqflags);
@@ -356,9 +360,6 @@ extern struct list_head usb_bus_list;
 extern struct mutex usb_bus_list_lock;
 extern wait_queue_head_t usb_kill_urb_queue;
 
-extern struct usb_bus *usb_bus_get (struct usb_bus *bus);
-extern void usb_bus_put (struct usb_bus *bus);
-
 extern void usb_enable_root_hub_irq (struct usb_bus *bus);
 
 extern int usb_find_interface_driver (struct usb_device *dev,
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index 7ab9d29215f8..b0c0a993338f 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -169,7 +169,7 @@ static void usb_release_dev(struct device *dev)
 	udev = to_usb_device(dev);
 
 	usb_destroy_configuration(udev);
-	usb_bus_put(udev-&gt;bus);
+	usb_put_hcd(bus_to_hcd(udev-&gt;bus));
 	kfree(udev-&gt;product);
 	kfree(udev-&gt;manufacturer);
 	kfree(udev-&gt;serial);
@@ -197,8 +197,7 @@ usb_alloc_dev(struct usb_device *parent, struct usb_bus *bus, unsigned port1)
 	if (!dev)
 		return NULL;
 
-	bus = usb_bus_get(bus);
-	if (!bus) {
+	if (!usb_get_hcd(bus_to_hcd(bus))) {
 		kfree(dev);
 		return NULL;
 	}
diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index 7d1c22c34957..fdab97a27c08 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -889,11 +889,9 @@ EXPORT_SYMBOL (net2280_set_fifo_mode);
 static void
 dummy_gadget_release (struct device *dev)
 {
-#if 0		/* usb_bus_put isn't EXPORTed! */
 	struct dummy	*dum = gadget_dev_to_dummy (dev);
 
-	usb_bus_put (&amp;dummy_to_hcd (dum)-&gt;self);
-#endif
+	usb_put_hcd (dummy_to_hcd (dum));
 }
 
 static int dummy_udc_probe (struct platform_device *pdev)
@@ -915,9 +913,7 @@ static int dummy_udc_probe (struct platform_device *pdev)
 	if (rc &lt; 0)
 		return rc;
 
-#if 0		/* usb_bus_get isn't EXPORTed! */
-	usb_bus_get (&amp;dummy_to_hcd (dum)-&gt;self);
-#endif
+	usb_get_hcd (dummy_to_hcd (dum));
 
 	platform_set_drvdata (pdev, dum);
 	device_create_file (&amp;dum-&gt;gadget.dev, &amp;dev_attr_function);
diff --git a/drivers/usb/host/ehci-dbg.c b/drivers/usb/host/ehci-dbg.c
index 65ac9fef3a7c..215ce6d06394 100644
--- a/drivers/usb/host/ehci-dbg.c
+++ b/drivers/usb/host/ehci-dbg.c
@@ -451,7 +451,7 @@ show_async (struct class_device *class_dev, char *buf)
 	*buf = 0;
 
 	bus = class_get_devdata(class_dev);
-	hcd = bus-&gt;hcpriv;
+	hcd = bus_to_hcd(bus);
 	ehci = hcd_to_ehci (hcd);
 	next = buf;
 	size = PAGE_SIZE;
@@ -497,7 +497,7 @@ show_periodic (struct class_device *class_dev, char *buf)
 	seen_count = 0;
 
 	bus = class_get_devdata(class_dev);
-	hcd = bus-&gt;hcpriv;
+	hcd = bus_to_hcd(bus);
 	ehci = hcd_to_ehci (hcd);
 	next = buf;
 	size = PAGE_SIZE;
@@ -634,7 +634,7 @@ show_registers (struct class_device *class_dev, char *buf)
 	static char		label [] = "";
 
 	bus = class_get_devdata(class_dev);
-	hcd = bus-&gt;hcpriv;
+	hcd = bus_to_hcd(bus);
 	ehci = hcd_to_ehci (hcd);
 	next = buf;
 	size = PAGE_SIZE;
diff --git a/drivers/usb/host/ohci-dbg.c b/drivers/usb/host/ohci-dbg.c
index da52609a9290..534d07dcb824 100644
--- a/drivers/usb/host/ohci-dbg.c
+++ b/drivers/usb/host/ohci-dbg.c
@@ -477,7 +477,7 @@ show_async (struct class_device *class_dev, char *buf)
 	unsigned long		flags;
 
 	bus = class_get_devdata(class_dev);
-	hcd = bus-&gt;hcpriv;
+	hcd = bus_to_hcd(bus);
 	ohci = hcd_to_ohci(hcd);
 
 	/* display control and bulk lists together, for simplicity */
@@ -510,7 +510,7 @@ show_periodic (struct class_device *class_dev, char *buf)
 	seen_count = 0;
 
 	bus = class_get_devdata(class_dev);
-	hcd = bus-&gt;hcpriv;
+	hcd = bus_to_hcd(bus);
 	ohci = hcd_to_ohci(hcd);
 	next = buf;
 	size = PAGE_SIZE;
@@ -607,7 +607,7 @@ show_registers (struct class_device *class_dev, char *buf)
 	u32			rdata;
 
 	bus = class_get_devdata(class_dev);
-	hcd = bus-&gt;hcpriv;
+	hcd = bus_to_hcd(bus);
 	ohci = hcd_to_ohci(hcd);
 	regs = ohci-&gt;regs;
 	next = buf;
diff --git a/drivers/usb/mon/mon_main.c b/drivers/usb/mon/mon_main.c
index 275a66f83058..e0ed36cdfd8b 100644
--- a/drivers/usb/mon/mon_main.c
+++ b/drivers/usb/mon/mon_main.c
@@ -265,7 +265,6 @@ static void mon_dissolve(struct mon_bus *mbus, struct usb_bus *ubus)
 	ubus-&gt;mon_bus = NULL;
 	mbus-&gt;u_bus = NULL;
 	mb();
-	// usb_bus_put(ubus);
 }
 
 /*
@@ -297,10 +296,9 @@ static void mon_bus_init(struct dentry *mondir, struct usb_bus *ubus)
 	INIT_LIST_HEAD(&amp;mbus-&gt;r_list);
 
 	/*
-	 * This usb_bus_get here is superfluous, because we receive
-	 * a notification if usb_bus is about to be removed.
+	 * We don't need to take a reference to ubus, because we receive
+	 * a notification if the bus is about to be removed.
 	 */
-	// usb_bus_get(ubus);
 	mbus-&gt;u_bus = ubus;
 	ubus-&gt;mon_bus = mbus;
 
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 09661759621f..c66303285a45 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -280,7 +280,6 @@ struct usb_bus {
 	struct usb_devmap devmap;	/* device address allocation map */
 	struct usb_device *root_hub;	/* Root hub */
 	struct list_head bus_list;	/* list of busses */
-	void *hcpriv;                   /* Host Controller private data */
 
 	int bandwidth_allocated;	/* on this bus: how much of the time
 					 * reserved for periodic (intr/iso)
@@ -295,8 +294,6 @@ struct usb_bus {
 	struct dentry *usbfs_dentry;	/* usbfs dentry entry for the bus */
 
 	struct class_device *class_dev;	/* class device for this bus */
-	struct kref kref;		/* reference counting for this bus */
-	void (*release)(struct usb_bus *bus);
 
 #if defined(CONFIG_USB_MON)
 	struct mon_bus *mon_bus;	/* non-null when associated */</pre><hr><pre>commit dd990f16a39d4e615c0b70a0ab50b79b32bfb16d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 30 11:29:56 2006 -0400

    usbcore: Add flag for whether a host controller uses DMA
    
    This patch (as770b) introduces a new field to usb_bus: a flag
    indicating whether or not the host controller uses DMA.  This serves
    to encapsulate the computation.  It also means we will have only one
    spot to update if the DMA API changes.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 2102c4deec1e..0cc14206920a 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1152,7 +1152,7 @@ int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
 	/* lower level hcd code should use *_dma exclusively,
 	 * unless it uses pio or talks to another transport.
 	 */
-	if (hcd-&gt;self.controller-&gt;dma_mask) {
+	if (hcd-&gt;self.uses_dma) {
 		if (usb_pipecontrol (urb-&gt;pipe)
 			&amp;&amp; !(urb-&gt;transfer_flags &amp; URB_NO_SETUP_DMA_MAP))
 			urb-&gt;setup_dma = dma_map_single (
@@ -1585,8 +1585,9 @@ void usb_hcd_giveback_urb (struct usb_hcd *hcd, struct urb *urb, struct pt_regs
 	at_root_hub = (urb-&gt;dev == hcd-&gt;self.root_hub);
 	urb_unlink (urb);
 
-	/* lower level hcd code should use *_dma exclusively */
-	if (hcd-&gt;self.controller-&gt;dma_mask &amp;&amp; !at_root_hub) {
+	/* lower level hcd code should use *_dma exclusively if the
+	 * host controller does DMA */
+	if (hcd-&gt;self.uses_dma &amp;&amp; !at_root_hub) {
 		if (usb_pipecontrol (urb-&gt;pipe)
 			&amp;&amp; !(urb-&gt;transfer_flags &amp; URB_NO_SETUP_DMA_MAP))
 			dma_unmap_single (hcd-&gt;self.controller, urb-&gt;setup_dma,
@@ -1710,6 +1711,7 @@ struct usb_hcd *usb_create_hcd (const struct hc_driver *driver,
 	hcd-&gt;self.release = &amp;hcd_release;
 	hcd-&gt;self.controller = dev;
 	hcd-&gt;self.bus_name = bus_name;
+	hcd-&gt;self.uses_dma = (dev-&gt;dma_mask != NULL);
 
 	init_timer(&amp;hcd-&gt;rh_timer);
 	hcd-&gt;rh_timer.function = rh_timer_func;
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 4709033f8fa7..09661759621f 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -269,6 +269,7 @@ struct usb_bus {
 	struct device *controller;	/* host/master side hardware */
 	int busnum;			/* Bus number (in order of reg) */
 	char *bus_name;			/* stable id (PCI slot_name etc) */
+	u8 uses_dma;			/* Does the host controller use DMA? */
 	u8 otg_port;			/* 0, or number of OTG/HNP port */
 	unsigned is_b_host:1;		/* true during some HNP roleswitches */
 	unsigned b_hnp_enable:1;	/* OTG: did A-Host enable HNP? */</pre><hr><pre>commit a6d2bb9ff919b4685bd684620ec7a1ffa8bf2349
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 30 11:27:36 2006 -0400

    USB: remove struct usb_operations
    
    All of the currently-supported USB host controller drivers use the HCD
    bus-glue framework.  As part of the program for flattening out the glue
    layer, this patch (as769) removes the usb_operations structure.  All
    function calls now go directly to the HCD routines (slightly renamed
    to remain within the "usb_" namespace).
    
    The patch also removes usb_alloc_bus(), because it's not useful in the
    HCD framework and it wasn't referenced anywhere.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index ea20a3a5a9b9..2102c4deec1e 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -731,30 +731,6 @@ static void usb_bus_init (struct usb_bus *bus)
 	kref_init(&amp;bus-&gt;kref);
 }
 
-/**
- * usb_alloc_bus - creates a new USB host controller structure
- * @op: pointer to a struct usb_operations that this bus structure should use
- * Context: !in_interrupt()
- *
- * Creates a USB host controller bus structure with the specified 
- * usb_operations and initializes all the necessary internal objects.
- *
- * If no memory is available, NULL is returned.
- *
- * The caller should call usb_put_bus() when it is finished with the structure.
- */
-struct usb_bus *usb_alloc_bus (struct usb_operations *op)
-{
-	struct usb_bus *bus;
-
-	bus = kzalloc (sizeof *bus, GFP_KERNEL);
-	if (!bus)
-		return NULL;
-	usb_bus_init (bus);
-	bus-&gt;op = op;
-	return bus;
-}
-
 /*-------------------------------------------------------------------------*/
 
 /**
@@ -1102,7 +1078,7 @@ static void urb_unlink (struct urb *urb)
  * expects usb_submit_urb() to have sanity checked and conditioned all
  * inputs in the urb
  */
-static int hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
+int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
 {
 	int			status;
 	struct usb_hcd		*hcd = urb-&gt;dev-&gt;bus-&gt;hcpriv;
@@ -1211,7 +1187,7 @@ static int hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
 /*-------------------------------------------------------------------------*/
 
 /* called in any context */
-static int hcd_get_frame_number (struct usb_device *udev)
+int usb_hcd_get_frame_number (struct usb_device *udev)
 {
 	struct usb_hcd	*hcd = (struct usb_hcd *)udev-&gt;bus-&gt;hcpriv;
 	if (!HC_IS_RUNNING (hcd-&gt;state))
@@ -1253,7 +1229,7 @@ unlink1 (struct usb_hcd *hcd, struct urb *urb)
  * caller guarantees urb won't be recycled till both unlink()
  * and the urb's completion function return
  */
-static int hcd_unlink_urb (struct urb *urb, int status)
+int usb_hcd_unlink_urb (struct urb *urb, int status)
 {
 	struct usb_host_endpoint	*ep;
 	struct usb_hcd			*hcd = NULL;
@@ -1351,8 +1327,8 @@ static int hcd_unlink_urb (struct urb *urb, int status)
  * example:  a qh stored in ep-&gt;hcpriv, holding state related to endpoint
  * type, maxpacket size, toggle, halt status, and scheduling.
  */
-static void
-hcd_endpoint_disable (struct usb_device *udev, struct usb_host_endpoint *ep)
+void usb_hcd_endpoint_disable (struct usb_device *udev,
+		struct usb_host_endpoint *ep)
 {
 	struct usb_hcd		*hcd;
 	struct urb		*urb;
@@ -1589,20 +1565,6 @@ EXPORT_SYMBOL (usb_bus_start_enum);
 
 /*-------------------------------------------------------------------------*/
 
-/*
- * usb_hcd_operations - adapts usb_bus framework to HCD framework (bus glue)
- */
-static struct usb_operations usb_hcd_operations = {
-	.get_frame_number =	hcd_get_frame_number,
-	.submit_urb =		hcd_submit_urb,
-	.unlink_urb =		hcd_unlink_urb,
-	.buffer_alloc =		hcd_buffer_alloc,
-	.buffer_free =		hcd_buffer_free,
-	.disable =		hcd_endpoint_disable,
-};
-
-/*-------------------------------------------------------------------------*/
-
 /**
  * usb_hcd_giveback_urb - return URB from HCD to device driver
  * @hcd: host controller returning the URB
@@ -1744,7 +1706,6 @@ struct usb_hcd *usb_create_hcd (const struct hc_driver *driver,
 	dev_set_drvdata(dev, hcd);
 
 	usb_bus_init(&amp;hcd-&gt;self);
-	hcd-&gt;self.op = &amp;usb_hcd_operations;
 	hcd-&gt;self.hcpriv = hcd;
 	hcd-&gt;self.release = &amp;hcd_release;
 	hcd-&gt;self.controller = dev;
diff --git a/drivers/usb/core/hcd.h b/drivers/usb/core/hcd.h
index fc71a08a1af4..83e229914797 100644
--- a/drivers/usb/core/hcd.h
+++ b/drivers/usb/core/hcd.h
@@ -139,28 +139,6 @@ struct hcd_timeout {	/* timeouts we allocate */
 
 /*-------------------------------------------------------------------------*/
 
-/*
- * FIXME usb_operations should vanish or become hc_driver,
- * when usb_bus and usb_hcd become the same thing.
- */
-
-struct usb_operations {
-	int (*get_frame_number) (struct usb_device *usb_dev);
-	int (*submit_urb) (struct urb *urb, gfp_t mem_flags);
-	int (*unlink_urb) (struct urb *urb, int status);
-
-	/* allocate dma-consistent buffer for URB_DMA_NOMAPPING */
-	void *(*buffer_alloc)(struct usb_bus *bus, size_t size,
-			gfp_t mem_flags,
-			dma_addr_t *dma);
-	void (*buffer_free)(struct usb_bus *bus, size_t size,
-			void *addr, dma_addr_t dma);
-
-	void (*disable)(struct usb_device *udev,
-			struct usb_host_endpoint *ep);
-};
-
-/* each driver provides one of these, and hardware init support */
 
 struct pt_regs;
 
@@ -222,7 +200,13 @@ struct hc_driver {
 		/* Needed only if port-change IRQs are level-triggered */
 };
 
-extern void usb_hcd_giveback_urb (struct usb_hcd *hcd, struct urb *urb, struct pt_regs *regs);
+extern int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags);
+extern int usb_hcd_unlink_urb (struct urb *urb, int status);
+extern void usb_hcd_giveback_urb (struct usb_hcd *hcd, struct urb *urb,
+		struct pt_regs *regs);
+extern void usb_hcd_endpoint_disable (struct usb_device *udev,
+		struct usb_host_endpoint *ep);
+extern int usb_hcd_get_frame_number (struct usb_device *udev);
 
 extern struct usb_hcd *usb_create_hcd (const struct hc_driver *driver,
 		struct device *dev, char *bus_name);
@@ -361,8 +345,6 @@ extern long usb_calc_bus_time (int speed, int is_input,
 
 /*-------------------------------------------------------------------------*/
 
-extern struct usb_bus *usb_alloc_bus (struct usb_operations *);
-
 extern void usb_set_device_state(struct usb_device *udev,
 		enum usb_device_state new_state);
 
diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 333b22c68aa4..1580c81a0db7 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -984,8 +984,8 @@ void usb_disable_endpoint(struct usb_device *dev, unsigned int epaddr)
 		ep = dev-&gt;ep_in[epnum];
 		dev-&gt;ep_in[epnum] = NULL;
 	}
-	if (ep &amp;&amp; dev-&gt;bus &amp;&amp; dev-&gt;bus-&gt;op &amp;&amp; dev-&gt;bus-&gt;op-&gt;disable)
-		dev-&gt;bus-&gt;op-&gt;disable(dev, ep);
+	if (ep &amp;&amp; dev-&gt;bus)
+		usb_hcd_endpoint_disable(dev, ep);
 }
 
 /**
diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 9864988377c7..576919927f53 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -221,7 +221,6 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 {
 	int			pipe, temp, max;
 	struct usb_device	*dev;
-	struct usb_operations	*op;
 	int			is_out;
 
 	if (!urb || urb-&gt;hcpriv || !urb-&gt;complete)
@@ -233,8 +232,6 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 	if (dev-&gt;bus-&gt;controller-&gt;power.power_state.event != PM_EVENT_ON
 			|| dev-&gt;state == USB_STATE_SUSPENDED)
 		return -EHOSTUNREACH;
-	if (!(op = dev-&gt;bus-&gt;op) || !op-&gt;submit_urb)
-		return -ENODEV;
 
 	urb-&gt;status = -EINPROGRESS;
 	urb-&gt;actual_length = 0;
@@ -376,7 +373,7 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 		urb-&gt;interval = temp;
 	}
 
-	return op-&gt;submit_urb (urb, mem_flags);
+	return usb_hcd_submit_urb (urb, mem_flags);
 }
 
 /*-------------------------------------------------------------------*/
@@ -440,9 +437,9 @@ int usb_unlink_urb(struct urb *urb)
 {
 	if (!urb)
 		return -EINVAL;
-	if (!(urb-&gt;dev &amp;&amp; urb-&gt;dev-&gt;bus &amp;&amp; urb-&gt;dev-&gt;bus-&gt;op))
+	if (!(urb-&gt;dev &amp;&amp; urb-&gt;dev-&gt;bus))
 		return -ENODEV;
-	return urb-&gt;dev-&gt;bus-&gt;op-&gt;unlink_urb(urb, -ECONNRESET);
+	return usb_hcd_unlink_urb(urb, -ECONNRESET);
 }
 
 /**
@@ -468,13 +465,13 @@ int usb_unlink_urb(struct urb *urb)
 void usb_kill_urb(struct urb *urb)
 {
 	might_sleep();
-	if (!(urb &amp;&amp; urb-&gt;dev &amp;&amp; urb-&gt;dev-&gt;bus &amp;&amp; urb-&gt;dev-&gt;bus-&gt;op))
+	if (!(urb &amp;&amp; urb-&gt;dev &amp;&amp; urb-&gt;dev-&gt;bus))
 		return;
 	spin_lock_irq(&amp;urb-&gt;lock);
 	++urb-&gt;reject;
 	spin_unlock_irq(&amp;urb-&gt;lock);
 
-	urb-&gt;dev-&gt;bus-&gt;op-&gt;unlink_urb(urb, -ENOENT);
+	usb_hcd_unlink_urb(urb, -ENOENT);
 	wait_event(usb_kill_urb_queue, atomic_read(&amp;urb-&gt;use_count) == 0);
 
 	spin_lock_irq(&amp;urb-&gt;lock);
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index 4eb98eb3804f..7ab9d29215f8 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -480,7 +480,7 @@ struct usb_device *usb_find_device(u16 vendor_id, u16 product_id)
  */
 int usb_get_current_frame_number(struct usb_device *dev)
 {
-	return dev-&gt;bus-&gt;op-&gt;get_frame_number (dev);
+	return usb_hcd_get_frame_number (dev);
 }
 
 /**
@@ -677,9 +677,9 @@ void *usb_buffer_alloc (
 	dma_addr_t *dma
 )
 {
-	if (!dev || !dev-&gt;bus || !dev-&gt;bus-&gt;op || !dev-&gt;bus-&gt;op-&gt;buffer_alloc)
+	if (!dev || !dev-&gt;bus)
 		return NULL;
-	return dev-&gt;bus-&gt;op-&gt;buffer_alloc (dev-&gt;bus, size, mem_flags, dma);
+	return hcd_buffer_alloc (dev-&gt;bus, size, mem_flags, dma);
 }
 
 /**
@@ -700,11 +700,11 @@ void usb_buffer_free (
 	dma_addr_t dma
 )
 {
-	if (!dev || !dev-&gt;bus || !dev-&gt;bus-&gt;op || !dev-&gt;bus-&gt;op-&gt;buffer_free)
+	if (!dev || !dev-&gt;bus)
 		return;
 	if (!addr)
 		return;
-	dev-&gt;bus-&gt;op-&gt;buffer_free (dev-&gt;bus, size, addr, dma);
+	hcd_buffer_free (dev-&gt;bus, size, addr, dma);
 }
 
 /**
diff --git a/include/linux/usb.h b/include/linux/usb.h
index f104efa04d79..4709033f8fa7 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -257,8 +257,6 @@ int __usb_get_extra_descriptor(char *buffer, unsigned size,
 
 /* ----------------------------------------------------------------------- */
 
-struct usb_operations;
-
 /* USB device number allocation bitmap */
 struct usb_devmap {
 	unsigned long devicemap[128 / (8*sizeof(unsigned long))];
@@ -279,7 +277,6 @@ struct usb_bus {
 					 * round-robin allocation */
 
 	struct usb_devmap devmap;	/* device address allocation map */
-	struct usb_operations *op;	/* Operations (specific to the HC) */
 	struct usb_device *root_hub;	/* Root hub */
 	struct list_head bus_list;	/* list of busses */
 	void *hcpriv;                   /* Host Controller private data */
@@ -1051,7 +1048,6 @@ extern int usb_submit_urb(struct urb *urb, gfp_t mem_flags);
 extern int usb_unlink_urb(struct urb *urb);
 extern void usb_kill_urb(struct urb *urb);
 
-#define HAVE_USB_BUFFERS
 void *usb_buffer_alloc (struct usb_device *dev, size_t size,
 	gfp_t mem_flags, dma_addr_t *dma);
 void usb_buffer_free (struct usb_device *dev, size_t size,</pre><hr><pre>commit 088dc270e1da03744d977cbd9edd4311af142348
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Aug 21 12:08:19 2006 -0400

    usbcore: help drivers to change device configs
    
    It's generally a bad idea for USB interface drivers to try to change a
    device's configuration, and usbcore doesn't provide any way for them
    to do it.  However in a few exceptional circumstances it can make
    sense.  This patch (as767) adds a roundabout mechanism to help drivers
    that may need it.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 49cfd7928a1c..333b22c68aa4 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1493,6 +1493,65 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 	return 0;
 }
 
+struct set_config_request {
+	struct usb_device	*udev;
+	int			config;
+	struct work_struct	work;
+};
+
+/* Worker routine for usb_driver_set_configuration() */
+static void driver_set_config_work(void *_req)
+{
+	struct set_config_request *req = _req;
+
+	usb_lock_device(req-&gt;udev);
+	usb_set_configuration(req-&gt;udev, req-&gt;config);
+	usb_unlock_device(req-&gt;udev);
+	usb_put_dev(req-&gt;udev);
+	kfree(req);
+}
+
+/**
+ * usb_driver_set_configuration - Provide a way for drivers to change device configurations
+ * @udev: the device whose configuration is being updated
+ * @config: the configuration being chosen.
+ * Context: In process context, must be able to sleep
+ *
+ * Device interface drivers are not allowed to change device configurations.
+ * This is because changing configurations will destroy the interface the
+ * driver is bound to and create new ones; it would be like a floppy-disk
+ * driver telling the computer to replace the floppy-disk drive with a
+ * tape drive!
+ *
+ * Still, in certain specialized circumstances the need may arise.  This
+ * routine gets around the normal restrictions by using a work thread to
+ * submit the change-config request.
+ *
+ * Returns 0 if the request was succesfully queued, error code otherwise.
+ * The caller has no way to know whether the queued request will eventually
+ * succeed.
+ */
+int usb_driver_set_configuration(struct usb_device *udev, int config)
+{
+	struct set_config_request *req;
+
+	req = kmalloc(sizeof(*req), GFP_KERNEL);
+	if (!req)
+		return -ENOMEM;
+	req-&gt;udev = udev;
+	req-&gt;config = config;
+	INIT_WORK(&amp;req-&gt;work, driver_set_config_work, req);
+
+	usb_get_dev(udev);
+	if (!schedule_work(&amp;req-&gt;work)) {
+		usb_put_dev(udev);
+		kfree(req);
+		return -EINVAL;
+	}
+	return 0;
+}
+EXPORT_SYMBOL_GPL(usb_driver_set_configuration);
+
 // synchronous request completion model
 EXPORT_SYMBOL(usb_control_msg);
 EXPORT_SYMBOL(usb_bulk_msg);
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 26d8a5f36896..f104efa04d79 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1099,6 +1099,9 @@ extern int usb_clear_halt(struct usb_device *dev, int pipe);
 extern int usb_reset_configuration(struct usb_device *dev);
 extern int usb_set_interface(struct usb_device *dev, int ifnum, int alternate);
 
+/* this request isn't really synchronous, but it belongs with the others */
+extern int usb_driver_set_configuration(struct usb_device *udev, int config);
+
 /*
  * timeouts, in milliseconds, used for sending/receiving control messages
  * they typically complete within a few frames (msec) after they're issued</pre><hr><pre>commit 3a3416b12f1fbd607bc137a57c924a628aa5485c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Aug 21 12:00:53 2006 -0400

    usb-storage: fix for UFI LUN detection
    
    The UFI specification doesn't permit devices to indicate non-existent
    LUNs in the manner prescribed by the SCSI spec.  This patch (as773)
    sets a special flag so that the SCSI scanner will recognize these
    devices and treat them specially.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Matthew Dharm &lt;mdharm-usb@one-eyed-alien.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index a4b7df9ff8c1..e1072d52d641 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -72,12 +72,27 @@ static const char* host_info(struct Scsi_Host *host)
 
 static int slave_alloc (struct scsi_device *sdev)
 {
+	struct us_data *us = host_to_us(sdev-&gt;host);
+
 	/*
 	 * Set the INQUIRY transfer length to 36.  We don't use any of
 	 * the extra data and many devices choke if asked for more or
 	 * less than 36 bytes.
 	 */
 	sdev-&gt;inquiry_len = 36;
+
+	/*
+	 * The UFI spec treates the Peripheral Qualifier bits in an
+	 * INQUIRY result as reserved and requires devices to set them
+	 * to 0.  However the SCSI spec requires these bits to be set
+	 * to 3 to indicate when a LUN is not present.
+	 *
+	 * Let the scanning code know if this target merely sets
+	 * Peripheral Device Type to 0x1f to indicate no LUN.
+	 */
+	if (us-&gt;subclass == US_SC_UFI)
+		sdev-&gt;sdev_target-&gt;pdt_1f_for_no_lun = 1;
+
 	return 0;
 }
 </pre><hr><pre>commit d5cbad4b8b37acfde3e63d31b92561b87288ad0f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 11 16:52:39 2006 -0400

    usbcore: khubd and busy-port handling
    
    We don't want khubd to start interfering in the device-resume process
    merely because the PORT_STATUS_C_SUSPEND feature happens to be set.
    Ports need to be marked as busy while a resume is taking place.
    
    In addition, so long as ports are marked as busy, khubd won't be able to
    clear their various status-change features.  On an interrupt-driven root
    hub this could lead to an interrupt storm.  Root hub IRQs should not be
    re-enabled until the busy_bits value is equal to 0.
    
    This patch (as765) fixes these two potential problems.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 3924dd080bea..bdf5be099650 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1658,6 +1658,8 @@ hub_port_resume(struct usb_hub *hub, int port1, struct usb_device *udev)
 
 	// dev_dbg(hub-&gt;intfdev, "resume port %d\n", port1);
 
+	set_bit(port1, hub-&gt;busy_bits);
+
 	/* see 7.1.7.7; affects power usage, but not budgeting */
 	status = clear_port_feature(hub-&gt;hdev,
 			port1, USB_PORT_FEAT_SUSPEND);
@@ -1707,6 +1709,10 @@ hub_port_resume(struct usb_hub *hub, int port1, struct usb_device *udev)
 	if (status &lt; 0)
 		hub_port_logical_disconnect(hub, port1);
 
+	clear_bit(port1, hub-&gt;busy_bits);
+	if (!hub-&gt;hdev-&gt;parent &amp;&amp; !hub-&gt;busy_bits[0])
+		usb_enable_root_hub_irq(hub-&gt;hdev-&gt;bus);
+
 	return status;
 }
 
@@ -2690,7 +2696,7 @@ static void hub_events(void)
 
 		/* If this is a root hub, tell the HCD it's okay to
 		 * re-enable port-change interrupts now. */
-		if (!hdev-&gt;parent)
+		if (!hdev-&gt;parent &amp;&amp; !hub-&gt;busy_bits[0])
 			usb_enable_root_hub_irq(hdev-&gt;bus);
 
 loop:
@@ -2865,6 +2871,9 @@ int usb_reset_device(struct usb_device *udev)
 			break;
 	}
 	clear_bit(port1, parent_hub-&gt;busy_bits);
+	if (!parent_hdev-&gt;parent &amp;&amp; !parent_hub-&gt;busy_bits[0])
+		usb_enable_root_hub_irq(parent_hdev-&gt;bus);
+
 	if (ret &lt; 0)
 		goto re_enumerate;
  
diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index 29d5f45a8456..0f8e82a4d480 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -212,7 +212,8 @@ struct usb_hub {
 	unsigned long		event_bits[1];	/* status change bitmask */
 	unsigned long		change_bits[1];	/* ports with logical connect
 							status change */
-	unsigned long		busy_bits[1];	/* ports being reset */
+	unsigned long		busy_bits[1];	/* ports being reset or
+							resumed */
 #if USB_MAXCHILDREN &gt; 31 /* 8*sizeof(unsigned long) - 1 */
 #error event_bits[] is too short!
 #endif</pre><hr><pre>commit 455b25fb209c8241e2163b491228b28667d82c1c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 11 16:01:45 2006 -0400

    usbcore: make hcd_endpoint_disable wait for queue to drain
    
    The inconsistent lock state problem in usbcore (the one that shows up
    when an HCD is unloaded) comes down to two inter-related problems:
    
            usb_rh_urb_dequeue() isn't set up to be called with interrupts
            disabled.
    
            hcd_endpoint_disable() doesn't wait for all URBs on the
            endpoint's queue to complete.
    
    The two problems are related because the one type of URB that isn't
    likely to be complete when hcd_endpoint_disable() returns is a root-hub
    URB.  Right now usb_rh_urb_dequeue() waits for them to complete, and it
    assumes interrupts are enabled so it can wait.  But
    hcd_endpoint_disable() calls it with interrupts disabled.
    
    Now, it should be legal to unlink root-hub URBs with interrupts
    disabled.  The solution is to move the waiting into
    hcd_endpoint_disable(), where it belongs.  This patch (as754) does that.
    
    It turns out to be completely safe to replace the del_timer_sync() with
    a simple del_timer().  It doesn't matter if the timer routine is
    running; hcd_root_hub_lock will synchronize the two threads and the
    status URB will complete with an unlink error, as it should.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index dc9628c58933..ea20a3a5a9b9 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -633,31 +633,20 @@ static int rh_urb_enqueue (struct usb_hcd *hcd, struct urb *urb)
 
 /*-------------------------------------------------------------------------*/
 
-/* Asynchronous unlinks of root-hub control URBs are legal, but they
- * don't do anything.  Status URB unlinks must be made in process context
- * with interrupts enabled.
+/* Unlinks of root-hub control URBs are legal, but they don't do anything
+ * since these URBs always execute synchronously.
  */
 static int usb_rh_urb_dequeue (struct usb_hcd *hcd, struct urb *urb)
 {
-	if (usb_pipeendpoint(urb-&gt;pipe) == 0) {	/* Control URB */
-		if (in_interrupt())
-			return 0;		/* nothing to do */
-
-		spin_lock_irq(&amp;urb-&gt;lock);	/* from usb_kill_urb */
-		++urb-&gt;reject;
-		spin_unlock_irq(&amp;urb-&gt;lock);
-
-		wait_event(usb_kill_urb_queue,
-				atomic_read(&amp;urb-&gt;use_count) == 0);
+	unsigned long	flags;
 
-		spin_lock_irq(&amp;urb-&gt;lock);
-		--urb-&gt;reject;
-		spin_unlock_irq(&amp;urb-&gt;lock);
+	if (usb_pipeendpoint(urb-&gt;pipe) == 0) {	/* Control URB */
+		;	/* Do nothing */
 
 	} else {				/* Status URB */
 		if (!hcd-&gt;uses_new_polling)
-			del_timer_sync (&amp;hcd-&gt;rh_timer);
-		local_irq_disable ();
+			del_timer (&amp;hcd-&gt;rh_timer);
+		local_irq_save (flags);
 		spin_lock (&amp;hcd_root_hub_lock);
 		if (urb == hcd-&gt;status_urb) {
 			hcd-&gt;status_urb = NULL;
@@ -667,7 +656,7 @@ static int usb_rh_urb_dequeue (struct usb_hcd *hcd, struct urb *urb)
 		spin_unlock (&amp;hcd_root_hub_lock);
 		if (urb)
 			usb_hcd_giveback_urb (hcd, urb, NULL);
-		local_irq_enable ();
+		local_irq_restore (flags);
 	}
 
 	return 0;
@@ -1355,7 +1344,8 @@ static int hcd_unlink_urb (struct urb *urb, int status)
 /*-------------------------------------------------------------------------*/
 
 /* disables the endpoint: cancels any pending urbs, then synchronizes with
- * the hcd to make sure all endpoint state is gone from hardware. use for
+ * the hcd to make sure all endpoint state is gone from hardware, and then
+ * waits until the endpoint's queue is completely drained. use for
  * set_configuration, set_interface, driver removal, physical disconnect.
  *
  * example:  a qh stored in ep-&gt;hcpriv, holding state related to endpoint
@@ -1374,22 +1364,13 @@ hcd_endpoint_disable (struct usb_device *udev, struct usb_host_endpoint *ep)
 
 	local_irq_disable ();
 
-	/* FIXME move most of this into message.c as part of its
-	 * endpoint disable logic
-	 */
-
 	/* ep is already gone from udev-&gt;ep_{in,out}[]; no more submits */
 rescan:
 	spin_lock (&amp;hcd_data_lock);
 	list_for_each_entry (urb, &amp;ep-&gt;urb_list, urb_list) {
 		int	tmp;
 
-		/* another cpu may be in hcd, spinning on hcd_data_lock
-		 * to giveback() this urb.  the races here should be
-		 * small, but a full fix needs a new "can't submit"
-		 * urb state.
-		 * FIXME urb-&gt;reject should allow that...
-		 */
+		/* the urb may already have been unlinked */
 		if (urb-&gt;status != -EINPROGRESS)
 			continue;
 		usb_get_urb (urb);
@@ -1431,6 +1412,30 @@ hcd_endpoint_disable (struct usb_device *udev, struct usb_host_endpoint *ep)
 	might_sleep ();
 	if (hcd-&gt;driver-&gt;endpoint_disable)
 		hcd-&gt;driver-&gt;endpoint_disable (hcd, ep);
+
+	/* Wait until the endpoint queue is completely empty.  Most HCDs
+	 * will have done this already in their endpoint_disable method,
+	 * but some might not.  And there could be root-hub control URBs
+	 * still pending since they aren't affected by the HCDs'
+	 * endpoint_disable methods.
+	 */
+	while (!list_empty (&amp;ep-&gt;urb_list)) {
+		spin_lock_irq (&amp;hcd_data_lock);
+
+		/* The list may have changed while we acquired the spinlock */
+		urb = NULL;
+		if (!list_empty (&amp;ep-&gt;urb_list)) {
+			urb = list_entry (ep-&gt;urb_list.prev, struct urb,
+					urb_list);
+			usb_get_urb (urb);
+		}
+		spin_unlock_irq (&amp;hcd_data_lock);
+
+		if (urb) {
+			usb_kill_urb (urb);
+			usb_put_urb (urb);
+		}
+	}
 }
 
 /*-------------------------------------------------------------------------*/</pre><hr><pre>commit de06a3b842b31b31220637c869f112cfbc1a5ef6
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 11 11:33:58 2006 -0400

    UHCI: increase Resume-Detect-off delay
    
    The UHCI controller in my laptop takes longer to turn off the
    Resume-Detect bit than the 4 us allowed by uhci-hcd.  Presumably other
    computers will have the same problem.
    
    This patch (as752) increases the maximum delay to 10 us, which should be
    plenty, and uses polling to avoid penalizing systems which can turn the
    bit off more quickly.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hub.c b/drivers/usb/host/uhci-hub.c
index c545ef92fe29..16fb72eb6fc9 100644
--- a/drivers/usb/host/uhci-hub.c
+++ b/drivers/usb/host/uhci-hub.c
@@ -84,6 +84,7 @@ static void uhci_finish_suspend(struct uhci_hcd *uhci, int port,
 		unsigned long port_addr)
 {
 	int status;
+	int i;
 
 	if (inw(port_addr) &amp; (USBPORTSC_SUSP | USBPORTSC_RD)) {
 		CLR_RH_PORTSTAT(USBPORTSC_SUSP | USBPORTSC_RD);
@@ -92,9 +93,14 @@ static void uhci_finish_suspend(struct uhci_hcd *uhci, int port,
 
 		/* The controller won't actually turn off the RD bit until
 		 * it has had a chance to send a low-speed EOP sequence,
-		 * which takes 3 bit times (= 2 microseconds).  We'll delay
-		 * slightly longer for good luck. */
-		udelay(4);
+		 * which is supposed to take 3 bit times (= 2 microseconds).
+		 * Experiments show that some controllers take longer, so
+		 * we'll poll for completion. */
+		for (i = 0; i &lt; 10; ++i) {
+			if (!(inw(port_addr) &amp; USBPORTSC_RD))
+				break;
+			udelay(1);
+		}
 	}
 	clear_bit(port, &amp;uhci-&gt;resuming_ports);
 }</pre><hr><pre>commit d388dab7b562b76525761f89702246686747ba30
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Jul 1 22:14:24 2006 -0400

    hub driver: improve use of #ifdef
    
    This patch (as736) makes the hub driver more readable by improving the
    usage of "#ifdef CONFIG_PM" and "#ifdef CONFIG_USB_SUSPEND".
    
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index a310c7cede99..64e80b964b87 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1041,7 +1041,7 @@ void usb_set_device_state(struct usb_device *udev,
 }
 
 
-#ifdef CONFIG_PM
+#ifdef	CONFIG_PM
 
 /**
  * usb_root_hub_lost_power - called by HCD if the root hub lost Vbus power
@@ -1072,7 +1072,7 @@ void usb_root_hub_lost_power(struct usb_device *rhdev)
 }
 EXPORT_SYMBOL_GPL(usb_root_hub_lost_power);
 
-#endif
+#endif	/* CONFIG_PM */
 
 static void choose_address(struct usb_device *udev)
 {
@@ -1471,6 +1471,7 @@ static void hub_port_logical_disconnect(struct usb_hub *hub, int port1)
  	kick_khubd(hub);
 }
 
+#ifdef	CONFIG_PM
 
 #ifdef	CONFIG_USB_SUSPEND
 
@@ -1569,8 +1570,6 @@ static int __usb_port_suspend (struct usb_device *udev, int port1)
 	return status;
 }
 
-#endif
-
 /*
  * usb_port_suspend - suspend a usb device's upstream port
  * @udev: device that's no longer in active use
@@ -1593,11 +1592,7 @@ static int __usb_port_suspend (struct usb_device *udev, int port1)
  */
 int usb_port_suspend(struct usb_device *udev)
 {
-#ifdef	CONFIG_USB_SUSPEND
 	return __usb_port_suspend(udev, udev-&gt;portnum);
-#else
-	return 0;
-#endif
 }
 
 /*
@@ -1661,8 +1656,6 @@ static int finish_port_resume(struct usb_device *udev)
 	return status;
 }
 
-#ifdef	CONFIG_USB_SUSPEND
-
 static int
 hub_port_resume(struct usb_hub *hub, int port1, struct usb_device *udev)
 {
@@ -1722,8 +1715,6 @@ hub_port_resume(struct usb_hub *hub, int port1, struct usb_device *udev)
 	return status;
 }
 
-#endif
-
 /*
  * usb_port_resume - re-activate a suspended usb device's upstream port
  * @udev: device to re-activate
@@ -1739,17 +1730,15 @@ hub_port_resume(struct usb_hub *hub, int port1, struct usb_device *udev)
  */
 int usb_port_resume(struct usb_device *udev)
 {
-	int	status = 0;
+	int	status;
 
 	/* we change the device's upstream USB link,
 	 * but root hubs have no upstream USB link.
 	 */
 	if (udev-&gt;parent) {
-#ifdef	CONFIG_USB_SUSPEND
 		// NOTE this fails if parent is also suspended...
 		status = hub_port_resume(hdev_to_hub(udev-&gt;parent),
 				udev-&gt;portnum, udev);
-#endif
 	} else
 		status = finish_port_resume(udev);
 	if (status &lt; 0)
@@ -1761,8 +1750,6 @@ static int remote_wakeup(struct usb_device *udev)
 {
 	int	status = 0;
 
-#ifdef	CONFIG_USB_SUSPEND
-
 	/* don't repeat RESUME sequence if this device
 	 * was already woken up by some other task
 	 */
@@ -1777,10 +1764,42 @@ static int remote_wakeup(struct usb_device *udev)
 	if (status == 0)
 		usb_resume_both(udev);
 	usb_unlock_device(udev);
-#endif
 	return status;
 }
 
+#else	/* CONFIG_USB_SUSPEND */
+
+/* When CONFIG_USB_SUSPEND isn't set, we never suspend or resume any ports. */
+
+int usb_port_suspend(struct usb_device *udev)
+{
+	return 0;
+}
+
+static inline int
+finish_port_resume(struct usb_device *udev)
+{
+	return 0;
+}
+
+static inline int
+hub_port_resume(struct usb_hub *hub, int port1, struct usb_device *udev)
+{
+	return 0;
+}
+
+int usb_port_resume(struct usb_device *udev)
+{
+	return 0;
+}
+
+static inline int remote_wakeup(struct usb_device *udev)
+{
+	return 0;
+}
+
+#endif
+
 static int hub_suspend(struct usb_interface *intf, pm_message_t msg)
 {
 	struct usb_hub		*hub = usb_get_intfdata (intf);
@@ -1854,6 +1873,15 @@ static int hub_resume(struct usb_interface *intf)
 	return 0;
 }
 
+#else	/* CONFIG_PM */
+
+static inline int remote_wakeup(struct usb_device *udev)
+{
+	return 0;
+}
+
+#endif
+
 void usb_suspend_root_hub(struct usb_device *hdev)
 {
 	struct usb_hub *hub = hdev_to_hub(hdev);
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 74df0db954c9..98675fb1bc4c 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -30,11 +30,22 @@ extern void usb_major_cleanup(void);
 extern int usb_host_init(void);
 extern void usb_host_cleanup(void);
 
+#ifdef	CONFIG_PM
+
 extern int usb_suspend_both(struct usb_device *udev, pm_message_t msg);
 extern int usb_resume_both(struct usb_device *udev);
 extern int usb_port_suspend(struct usb_device *dev);
 extern int usb_port_resume(struct usb_device *dev);
 
+#else
+
+#define usb_suspend_both(udev, msg)	0
+#define usb_resume_both(udev)		0
+#define usb_port_suspend(dev)		0
+#define usb_port_resume(dev)		0
+
+#endif
+
 extern struct bus_type usb_bus_type;
 extern struct usb_device_driver usb_generic_driver;
 </pre><hr><pre>commit 1c5df7e705671f11a71112eb3a1f9765cd1719f9
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Jul 1 22:13:50 2006 -0400

    usbcore: suspending devices with no driver
    
    Since usb_generic can be unbound from a USB device, we need to be able
    to handle the possibility that a suspend or resume request arrives for a
    device with no driver.  This patch (as735) arranges things so that
    resume requests will fail and suspend requests will use the standard USB
    port-suspend code.  Attempts to suspend or resume an unbound interface
    are handled similarly (although the error caused by trying to resume an
    unbound interface is dropped by the calling routine).
    
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index affbfb53eb5e..a5d11461f5a9 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -761,8 +761,12 @@ static int suspend_device(struct usb_device *udev, pm_message_t msg)
 			udev-&gt;state == USB_STATE_SUSPENDED)
 		goto done;
 
-	if (udev-&gt;dev.driver == NULL)
+	/* For devices that don't have a driver, we do a standard suspend. */
+	if (udev-&gt;dev.driver == NULL) {
+		status = usb_port_suspend(udev);
 		goto done;
+	}
+
 	udriver = to_usb_device_driver(udev-&gt;dev.driver);
 	status = udriver-&gt;suspend(udev, msg);
 
@@ -782,8 +786,12 @@ static int resume_device(struct usb_device *udev)
 			udev-&gt;state != USB_STATE_SUSPENDED)
 		goto done;
 
-	if (udev-&gt;dev.driver == NULL)
+	/* Can't resume it if it doesn't have a driver. */
+	if (udev-&gt;dev.driver == NULL) {
+		status = -ENOTCONN;
 		goto done;
+	}
+
 	udriver = to_usb_device_driver(udev-&gt;dev.driver);
 	status = udriver-&gt;resume(udev);
 
@@ -804,7 +812,7 @@ static int suspend_interface(struct usb_interface *intf, pm_message_t msg)
 			!is_active(intf))
 		goto done;
 
-	if (intf-&gt;dev.driver == NULL)
+	if (intf-&gt;dev.driver == NULL)		/* This can't happen */
 		goto done;
 	driver = to_usb_driver(intf-&gt;dev.driver);
 
@@ -838,8 +846,11 @@ static int resume_interface(struct usb_interface *intf)
 			is_active(intf))
 		goto done;
 
-	if (intf-&gt;dev.driver == NULL)
+	/* Can't resume it if it doesn't have a driver. */
+	if (intf-&gt;dev.driver == NULL) {
+		status = -ENOTCONN;
 		goto done;
+	}
 	driver = to_usb_driver(intf-&gt;dev.driver);
 
 	if (driver-&gt;resume) {</pre>
    <div class="pagination">
        <a href='2_119.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><span>[120]</span><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_121.html'>Next&gt;&gt;</a>
    <div>
</body>
