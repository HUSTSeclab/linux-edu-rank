<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_62.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><span>[63]</span><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_64.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 1fb2e0558781b07d2ecaabf94c81c17ac820d8f0
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 14 11:03:53 2010 -0400

    USB: EHCI: reorganize isochronous scheduler routine
    
    This patch (as1408) rearranges the scheduling code in ehci-hcd, partly
    to improve its structure, but mainly to change the way it works.
    Whether or not a transfer exceeds the hardware schedule length will
    now be determined by looking at the last frame the transfer would use,
    instead of the first available frame following the end of the transfer.
    
    The benefit of this change is that it allows the driver to accept
    valid URBs which would otherwise be rejected.  For example, suppose
    the schedule length is 1024 frames, the endpoint period is 256 frames,
    and a four-packet URB is submitted.  The four transfers would occupy
    slots that are 0, 256, 512, and 768 frames past the current frame
    (plus an extra slop factor).  These don't exceed the 1024-frame limit,
    so the URB should be accepted.  But the current code notices that the
    next available slot would be 1024 frames (plus slop) in the future,
    which is beyond the limit, and so the URB is rejected unnecessarily.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index dd37350170bb..3381319a2b3f 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -1413,13 +1413,6 @@ iso_stream_schedule (
 		goto fail;
 	}
 
-	if (stream-&gt;depth + span &gt; mod) {
-		ehci_dbg (ehci, "request %p would overflow (%d+%d&gt;%d)\n",
-			urb, stream-&gt;depth, span, mod);
-		status = -EFBIG;
-		goto fail;
-	}
-
 	now = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;frame_index) &amp; (mod - 1);
 
 	/* Typical case: reuse current schedule, stream is still active.
@@ -1428,7 +1421,7 @@ iso_stream_schedule (
 	 * slot in the schedule, implicitly assuming URB_ISO_ASAP.
 	 */
 	if (likely (!list_empty (&amp;stream-&gt;td_list))) {
-		start = stream-&gt;next_uframe;
+		u32	excess;
 
 		/* For high speed devices, allow scheduling within the
 		 * isochronous scheduling threshold.  For full speed devices
@@ -1440,21 +1433,23 @@ iso_stream_schedule (
 		else
 			next = now;
 
-		/* Fell behind (by up to twice the slop amount)? */
-		if (((start - next) &amp; (mod - 1)) &gt;=
-				mod - 2 * SCHEDULE_SLOP)
-			start += period * DIV_ROUND_UP(
-					(next - start) &amp; (mod - 1),
-					period);
-
-		/* Tried to schedule too far into the future? */
-		if (unlikely(((start - now) &amp; (mod - 1)) + span
-					&gt;= mod - 2 * SCHEDULE_SLOP)) {
+		/* Fell behind (by up to twice the slop amount)?
+		 * We decide based on the time of the last currently-scheduled
+		 * slot, not the time of the next available slot.
+		 */
+		excess = (stream-&gt;next_uframe - period - next) &amp; (mod - 1);
+		if (excess &gt;= mod - 2 * SCHEDULE_SLOP)
+			start = next + excess - mod + period *
+					DIV_ROUND_UP(mod - excess, period);
+		else
+			start = next + excess + period;
+		if (start - now &gt;= mod) {
+			ehci_dbg(ehci, "request %p would overflow (%d+%d &gt;= %d)\n",
+					urb, start - now - period, period,
+					mod);
 			status = -EFBIG;
 			goto fail;
 		}
-		stream-&gt;next_uframe = start;
-		goto ready;
 	}
 
 	/* need to schedule; when's the next (u)frame we could start?
@@ -1463,51 +1458,60 @@ iso_stream_schedule (
 	 * can also help high bandwidth if the dma and irq loads don't
 	 * jump until after the queue is primed.
 	 */
-	start = SCHEDULE_SLOP + (now &amp; ~0x07);
-	start &amp;= mod - 1;
-	stream-&gt;next_uframe = start;
-
-	/* NOTE:  assumes URB_ISO_ASAP, to limit complexity/bugs */
-
-	/* find a uframe slot with enough bandwidth */
-	for (; start &lt; (stream-&gt;next_uframe + period); start++) {
-		int		enough_space;
-
-		/* check schedule: enough space? */
-		if (stream-&gt;highspeed)
-			enough_space = itd_slot_ok (ehci, mod, start,
-					stream-&gt;usecs, period);
-		else {
-			if ((start % 8) &gt;= 6)
-				continue;
-			enough_space = sitd_slot_ok (ehci, mod, stream,
-					start, sched, period);
+	else {
+		start = SCHEDULE_SLOP + (now &amp; ~0x07);
+
+		/* NOTE:  assumes URB_ISO_ASAP, to limit complexity/bugs */
+
+		/* find a uframe slot with enough bandwidth */
+		next = start + period;
+		for (; start &lt; next; start++) {
+
+			/* check schedule: enough space? */
+			if (stream-&gt;highspeed) {
+				if (itd_slot_ok(ehci, mod, start,
+						stream-&gt;usecs, period))
+					break;
+			} else {
+				if ((start % 8) &gt;= 6)
+					continue;
+				if (sitd_slot_ok(ehci, mod, stream,
+						start, sched, period))
+					break;
+			}
 		}
 
-		/* schedule it here if there's enough bandwidth */
-		if (enough_space) {
-			stream-&gt;next_uframe = start &amp; (mod - 1);
-			goto ready;
+		/* no room in the schedule */
+		if (start == next) {
+			ehci_dbg(ehci, "iso resched full %p (now %d max %d)\n",
+				urb, now, now + mod);
+			status = -ENOSPC;
+			goto fail;
 		}
 	}
 
-	/* no room in the schedule */
-	ehci_dbg (ehci, "iso %ssched full %p (now %d max %d)\n",
-		list_empty (&amp;stream-&gt;td_list) ? "" : "re",
-		urb, now, now + mod);
-	status = -ENOSPC;
+	/* Tried to schedule too far into the future? */
+	if (unlikely(start - now + span - period
+				&gt;= mod - 2 * SCHEDULE_SLOP)) {
+		ehci_dbg(ehci, "request %p would overflow (%d+%d &gt;= %d)\n",
+				urb, start - now, span - period,
+				mod - 2 * SCHEDULE_SLOP);
+		status = -EFBIG;
+		goto fail;
+	}
 
-fail:
-	iso_sched_free (stream, sched);
-	urb-&gt;hcpriv = NULL;
-	return status;
+	stream-&gt;next_uframe = start &amp; (mod - 1);
 
-ready:
 	/* report high speed start in uframes; full speed, in frames */
 	urb-&gt;start_frame = stream-&gt;next_uframe;
 	if (!stream-&gt;highspeed)
 		urb-&gt;start_frame &gt;&gt;= 3;
 	return 0;
+
+ fail:
+	iso_sched_free(stream, sched);
+	urb-&gt;hcpriv = NULL;
+	return status;
 }
 
 /*-------------------------------------------------------------------------*/</pre><hr><pre>commit ffda080353979273e8aa69fc1e6134f20643ae56
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 14 11:03:46 2010 -0400

    USB: EHCI: add missing frame -&gt; microframe conversion
    
    This patch (as1407) fixes a bug in ehci-hcd's isochronous scheduler.
    All its calculations should be done in terms of microframes, but for
    full-speed devices, sched-&gt;span is stored in frames.  It needs to be
    converted.
    
    This fix is liable to expose problems in other drivers.  The old code
    would accept URBs that should not have been accepted, so drivers have
    had no reason to avoid submitting URBs that exceeded the maximum
    schedule length.  In an attempt to partially compensate for this, the
    patch also adjusts the schedule length from a minimum of 256 frames up
    to a minimum of 512 frames.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 2e704fa3cedf..34a928d3b7d2 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -79,7 +79,13 @@ static const char	hcd_name [] = "ehci_hcd";
 #define	EHCI_TUNE_RL_TT		0
 #define	EHCI_TUNE_MULT_HS	1	/* 1-3 transactions/uframe; 4.10.3 */
 #define	EHCI_TUNE_MULT_TT	1
-#define	EHCI_TUNE_FLS		2	/* (small) 256 frame schedule */
+/*
+ * Some drivers think it's safe to schedule isochronous transfers more than
+ * 256 ms into the future (partly as a result of an old bug in the scheduling
+ * code).  In an attempt to avoid trouble, we will use a minimum scheduling
+ * length of 512 frames instead of 256.
+ */
+#define	EHCI_TUNE_FLS		1	/* (medium) 512-frame schedule */
 
 #define EHCI_IAA_MSECS		10		/* arbitrary */
 #define EHCI_IO_JIFFIES		(HZ/10)		/* io watchdog &gt; irq_thresh */
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 27dd841b9aa2..dd37350170bb 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -1395,28 +1395,31 @@ iso_stream_schedule (
 	struct ehci_iso_stream	*stream
 )
 {
-	u32			now, next, start, period;
+	u32			now, next, start, period, span;
 	int			status;
 	unsigned		mod = ehci-&gt;periodic_size &lt;&lt; 3;
 	struct ehci_iso_sched	*sched = urb-&gt;hcpriv;
 
-	if (sched-&gt;span &gt; (mod - SCHEDULE_SLOP)) {
+	period = urb-&gt;interval;
+	span = sched-&gt;span;
+	if (!stream-&gt;highspeed) {
+		period &lt;&lt;= 3;
+		span &lt;&lt;= 3;
+	}
+
+	if (span &gt; mod - SCHEDULE_SLOP) {
 		ehci_dbg (ehci, "iso request %p too long\n", urb);
 		status = -EFBIG;
 		goto fail;
 	}
 
-	if ((stream-&gt;depth + sched-&gt;span) &gt; mod) {
+	if (stream-&gt;depth + span &gt; mod) {
 		ehci_dbg (ehci, "request %p would overflow (%d+%d&gt;%d)\n",
-			urb, stream-&gt;depth, sched-&gt;span, mod);
+			urb, stream-&gt;depth, span, mod);
 		status = -EFBIG;
 		goto fail;
 	}
 
-	period = urb-&gt;interval;
-	if (!stream-&gt;highspeed)
-		period &lt;&lt;= 3;
-
 	now = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;frame_index) &amp; (mod - 1);
 
 	/* Typical case: reuse current schedule, stream is still active.
@@ -1445,7 +1448,7 @@ iso_stream_schedule (
 					period);
 
 		/* Tried to schedule too far into the future? */
-		if (unlikely(((start - now) &amp; (mod - 1)) + sched-&gt;span
+		if (unlikely(((start - now) &amp; (mod - 1)) + span
 					&gt;= mod - 2 * SCHEDULE_SLOP)) {
 			status = -EFBIG;
 			goto fail;</pre><hr><pre>commit bccbefaae050186bed3bcc74b1fd1a9b8c6710b2
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 14 11:03:36 2010 -0400

    USB: EHCI: simplify remainder computations
    
    This patch (as1406) adds a micro-optimization to ehci-hcd's scheduling
    code.  Instead of computing remainders with respect to the schedule
    length, use bitwise-and (which is quicker).  We know that the schedule
    length will always be a power of two, but the compiler doesn't have
    this information.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index efadced4ae67..27dd841b9aa2 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -1417,7 +1417,7 @@ iso_stream_schedule (
 	if (!stream-&gt;highspeed)
 		period &lt;&lt;= 3;
 
-	now = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;frame_index) % mod;
+	now = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;frame_index) &amp; (mod - 1);
 
 	/* Typical case: reuse current schedule, stream is still active.
 	 * Hopefully there are no gaps from the host falling behind
@@ -1461,7 +1461,7 @@ iso_stream_schedule (
 	 * jump until after the queue is primed.
 	 */
 	start = SCHEDULE_SLOP + (now &amp; ~0x07);
-	start %= mod;
+	start &amp;= mod - 1;
 	stream-&gt;next_uframe = start;
 
 	/* NOTE:  assumes URB_ISO_ASAP, to limit complexity/bugs */
@@ -1483,7 +1483,7 @@ iso_stream_schedule (
 
 		/* schedule it here if there's enough bandwidth */
 		if (enough_space) {
-			stream-&gt;next_uframe = start % mod;
+			stream-&gt;next_uframe = start &amp; (mod - 1);
 			goto ready;
 		}
 	}
@@ -1599,7 +1599,7 @@ itd_link_urb (
 	struct ehci_iso_sched	*iso_sched = urb-&gt;hcpriv;
 	struct ehci_itd		*itd;
 
-	next_uframe = stream-&gt;next_uframe % mod;
+	next_uframe = stream-&gt;next_uframe &amp; (mod - 1);
 
 	if (unlikely (list_empty(&amp;stream-&gt;td_list))) {
 		ehci_to_hcd(ehci)-&gt;self.bandwidth_allocated
@@ -1637,13 +1637,13 @@ itd_link_urb (
 
 		next_uframe += stream-&gt;interval;
 		stream-&gt;depth += stream-&gt;interval;
-		next_uframe %= mod;
+		next_uframe &amp;= mod - 1;
 		packet++;
 
 		/* link completed itds into the schedule */
 		if (((next_uframe &gt;&gt; 3) != frame)
 				|| packet == urb-&gt;number_of_packets) {
-			itd_link (ehci, frame % ehci-&gt;periodic_size, itd);
+			itd_link(ehci, frame &amp; (ehci-&gt;periodic_size - 1), itd);
 			itd = NULL;
 		}
 	}
@@ -2020,7 +2020,7 @@ sitd_link_urb (
 			"sched devp %s ep%d%s-iso [%d] %dms/%04x\n",
 			urb-&gt;dev-&gt;devpath, stream-&gt;bEndpointAddress &amp; 0x0f,
 			(stream-&gt;bEndpointAddress &amp; USB_DIR_IN) ? "in" : "out",
-			(next_uframe &gt;&gt; 3) % ehci-&gt;periodic_size,
+			(next_uframe &gt;&gt; 3) &amp; (ehci-&gt;periodic_size - 1),
 			stream-&gt;interval, hc32_to_cpu(ehci, stream-&gt;splits));
 		stream-&gt;start = jiffies;
 	}
@@ -2043,13 +2043,13 @@ sitd_link_urb (
 		sitd-&gt;urb = urb;
 
 		sitd_patch(ehci, stream, sitd, sched, packet);
-		sitd_link (ehci, (next_uframe &gt;&gt; 3) % ehci-&gt;periodic_size,
+		sitd_link(ehci, (next_uframe &gt;&gt; 3) &amp; (ehci-&gt;periodic_size - 1),
 				sitd);
 
 		next_uframe += stream-&gt;interval &lt;&lt; 3;
 		stream-&gt;depth += stream-&gt;interval &lt;&lt; 3;
 	}
-	stream-&gt;next_uframe = next_uframe % mod;
+	stream-&gt;next_uframe = next_uframe &amp; (mod - 1);
 
 	/* don't need that schedule data any more */
 	iso_sched_free (stream, sched);
@@ -2258,7 +2258,7 @@ scan_periodic (struct ehci_hcd *ehci)
 	now_uframe = ehci-&gt;next_uframe;
 	if (HC_IS_RUNNING(ehci_to_hcd(ehci)-&gt;state)) {
 		clock = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;frame_index);
-		clock_frame = (clock &gt;&gt; 3) % ehci-&gt;periodic_size;
+		clock_frame = (clock &gt;&gt; 3) &amp; (ehci-&gt;periodic_size - 1);
 	} else  {
 		clock = now_uframe + mod - 1;
 		clock_frame = -1;
@@ -2267,7 +2267,7 @@ scan_periodic (struct ehci_hcd *ehci)
 		free_cached_lists(ehci);
 		ehci-&gt;clock_frame = clock_frame;
 	}
-	clock %= mod;
+	clock &amp;= mod - 1;
 	clock_frame = clock &gt;&gt; 3;
 
 	for (;;) {
@@ -2356,7 +2356,7 @@ scan_periodic (struct ehci_hcd *ehci)
 				 * frame is current.
 				 */
 				if (((frame == clock_frame) ||
-				     (((frame + 1) % ehci-&gt;periodic_size)
+				     (((frame + 1) &amp; (ehci-&gt;periodic_size - 1))
 				      == clock_frame))
 				    &amp;&amp; live
 				    &amp;&amp; (q.sitd-&gt;hw_results &amp;
@@ -2423,7 +2423,8 @@ scan_periodic (struct ehci_hcd *ehci)
 					|| ehci-&gt;periodic_sched == 0)
 				break;
 			ehci-&gt;next_uframe = now_uframe;
-			now = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;frame_index) % mod;
+			now = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;frame_index) &amp;
+					(mod - 1);
 			if (now_uframe == now)
 				break;
 
@@ -2436,7 +2437,7 @@ scan_periodic (struct ehci_hcd *ehci)
 			}
 		} else {
 			now_uframe++;
-			now_uframe %= mod;
+			now_uframe &amp;= mod - 1;
 		}
 	}
 }</pre><hr><pre>commit ae68a83bdc1971cb02fefc7a686ba6d077065e71
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 14 11:03:23 2010 -0400

    USB: EHCI: remove PCI assumption
    
    This patch (as1405) fixes a small bug in ehci-hcd's isochronous
    scheduler.  Not all EHCI controllers are PCI, and the code shouldn't
    assume that they are.  Instead, introduce a special flag for
    controllers which need to delay iso scheduling for full-speed devices
    beyond the scheduling threshold.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Sarah Sharp &lt;sarah.a.sharp@linux.intel.com&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    CC: stable &lt;stable@kernel.org&gt;
    Acked-by: Sarah Sharp &lt;sarah.a.sharp@linux.intel.com&gt;

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index f555e4f35a04..58b72d741d93 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -114,6 +114,7 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		break;
 	case PCI_VENDOR_ID_INTEL:
 		ehci-&gt;need_io_watchdog = 0;
+		ehci-&gt;fs_i_thresh = 1;
 		if (pdev-&gt;device == 0x27cc) {
 			ehci-&gt;broken_periodic = 1;
 			ehci_info(ehci, "using broken periodic workaround\n");
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index d640346f9b56..efadced4ae67 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -1399,7 +1399,6 @@ iso_stream_schedule (
 	int			status;
 	unsigned		mod = ehci-&gt;periodic_size &lt;&lt; 3;
 	struct ehci_iso_sched	*sched = urb-&gt;hcpriv;
-	struct pci_dev		*pdev;
 
 	if (sched-&gt;span &gt; (mod - SCHEDULE_SLOP)) {
 		ehci_dbg (ehci, "iso request %p too long\n", urb);
@@ -1426,15 +1425,14 @@ iso_stream_schedule (
 	 * slot in the schedule, implicitly assuming URB_ISO_ASAP.
 	 */
 	if (likely (!list_empty (&amp;stream-&gt;td_list))) {
-		pdev = to_pci_dev(ehci_to_hcd(ehci)-&gt;self.controller);
 		start = stream-&gt;next_uframe;
 
 		/* For high speed devices, allow scheduling within the
-		 * isochronous scheduling threshold.  For full speed devices,
-		 * don't. (Work around for Intel ICH9 bug.)
+		 * isochronous scheduling threshold.  For full speed devices
+		 * and Intel PCI-based controllers, don't (work around for
+		 * Intel ICH9 bug).
 		 */
-		if (!stream-&gt;highspeed &amp;&amp;
-				pdev-&gt;vendor == PCI_VENDOR_ID_INTEL)
+		if (!stream-&gt;highspeed &amp;&amp; ehci-&gt;fs_i_thresh)
 			next = now + ehci-&gt;i_thresh;
 		else
 			next = now;
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index a4a63ce290e9..2c050efd1deb 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -130,6 +130,7 @@ struct ehci_hcd {			/* one per controller */
 	unsigned		has_amcc_usb23:1;
 	unsigned		need_io_watchdog:1;
 	unsigned		broken_periodic:1;
+	unsigned		fs_i_thresh:1;	/* Intel iso scheduling */
 
 	/* required for usb32 quirk */
 	#define OHCI_CTRL_HCFS          (3 &lt;&lt; 6)</pre><hr><pre>commit 3da7cff4e79e4a7137b0dac1aaf6841b91bbff63
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jun 25 14:02:57 2010 -0400

    USB: add runtime PM for PCI-based host controllers
    
    This patch (as1386) adds runtime-PM support for PCI-based USB host
    controllers.  By default autosuspend is disallowed; the user must
    enable it by writing "auto" to the controller's power/control sysfs
    attribute.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd-pci.c b/drivers/usb/core/hcd-pci.c
index 352577baa53d..fe6b8d40a506 100644
--- a/drivers/usb/core/hcd-pci.c
+++ b/drivers/usb/core/hcd-pci.c
@@ -250,6 +250,9 @@ int usb_hcd_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
 	if (retval != 0)
 		goto err4;
 	set_hs_companion(dev, hcd);
+
+	if (pci_dev_run_wake(dev))
+		pm_runtime_put_noidle(&amp;dev-&gt;dev);
 	return retval;
 
  err4:
@@ -292,6 +295,9 @@ void usb_hcd_pci_remove(struct pci_dev *dev)
 	if (!hcd)
 		return;
 
+	if (pci_dev_run_wake(dev))
+		pm_runtime_get_noresume(&amp;dev-&gt;dev);
+
 	/* Fake an interrupt request in order to give the driver a chance
 	 * to test whether the controller hardware has been removed (e.g.,
 	 * cardbus physical eject).
@@ -325,12 +331,13 @@ void usb_hcd_pci_shutdown(struct pci_dev *dev)
 	if (!hcd)
 		return;
 
-	if (hcd-&gt;driver-&gt;shutdown)
+	if (test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags) &amp;&amp;
+			hcd-&gt;driver-&gt;shutdown)
 		hcd-&gt;driver-&gt;shutdown(hcd);
 }
 EXPORT_SYMBOL_GPL(usb_hcd_pci_shutdown);
 
-#ifdef	CONFIG_PM_SLEEP
+#ifdef	CONFIG_PM_OPS
 
 #ifdef	CONFIG_PPC_PMAC
 static void powermac_set_asic(struct pci_dev *pci_dev, int enable)
@@ -366,7 +373,7 @@ static int check_root_hub_suspended(struct device *dev)
 	return 0;
 }
 
-static int hcd_pci_suspend(struct device *dev)
+static int suspend_common(struct device *dev, bool do_wakeup)
 {
 	struct pci_dev		*pci_dev = to_pci_dev(dev);
 	struct usb_hcd		*hcd = pci_get_drvdata(pci_dev);
@@ -381,13 +388,7 @@ static int hcd_pci_suspend(struct device *dev)
 	if (retval)
 		return retval;
 
-	/* We might already be suspended (runtime PM -- not yet written) */
-	if (pci_dev-&gt;current_state != PCI_D0)
-		return retval;
-
 	if (hcd-&gt;driver-&gt;pci_suspend) {
-		bool	do_wakeup = device_may_wakeup(dev);
-
 		/* Optimization: Don't suspend if a root-hub wakeup is
 		 * pending and it would cause the HCD to wake up anyway.
 		 */
@@ -439,10 +440,8 @@ static int resume_common(struct device *dev, int event)
 	clear_bit(HCD_FLAG_SAW_IRQ, &amp;hcd-&gt;flags);
 
 	if (hcd-&gt;driver-&gt;pci_resume) {
-		/* This call should be made only during system resume,
-		 * not during runtime resume.
-		 */
-		wait_for_companions(pci_dev, hcd);
+		if (event != PM_EVENT_AUTO_RESUME)
+			wait_for_companions(pci_dev, hcd);
 
 		retval = hcd-&gt;driver-&gt;pci_resume(hcd,
 				event == PM_EVENT_RESTORE);
@@ -454,6 +453,13 @@ static int resume_common(struct device *dev, int event)
 	return retval;
 }
 
+#ifdef	CONFIG_PM_SLEEP
+
+static int hcd_pci_suspend(struct device *dev)
+{
+	return suspend_common(dev, device_may_wakeup(dev));
+}
+
 static int hcd_pci_suspend_noirq(struct device *dev)
 {
 	struct pci_dev		*pci_dev = to_pci_dev(dev);
@@ -513,6 +519,46 @@ static int hcd_pci_restore(struct device *dev)
 	return resume_common(dev, PM_EVENT_RESTORE);
 }
 
+#else
+
+#define hcd_pci_suspend		NULL
+#define hcd_pci_suspend_noirq	NULL
+#define hcd_pci_resume_noirq	NULL
+#define hcd_pci_resume		NULL
+#define hcd_pci_restore		NULL
+
+#endif	/* CONFIG_PM_SLEEP */
+
+#ifdef	CONFIG_PM_RUNTIME
+
+static int hcd_pci_runtime_suspend(struct device *dev)
+{
+	int	retval;
+
+	retval = suspend_common(dev, true);
+	if (retval == 0)
+		powermac_set_asic(to_pci_dev(dev), 0);
+	dev_dbg(dev, "hcd_pci_runtime_suspend: %d\n", retval);
+	return retval;
+}
+
+static int hcd_pci_runtime_resume(struct device *dev)
+{
+	int	retval;
+
+	powermac_set_asic(to_pci_dev(dev), 1);
+	retval = resume_common(dev, PM_EVENT_AUTO_RESUME);
+	dev_dbg(dev, "hcd_pci_runtime_resume: %d\n", retval);
+	return retval;
+}
+
+#else
+
+#define hcd_pci_runtime_suspend	NULL
+#define hcd_pci_runtime_resume	NULL
+
+#endif	/* CONFIG_PM_RUNTIME */
+
 const struct dev_pm_ops usb_hcd_pci_pm_ops = {
 	.suspend	= hcd_pci_suspend,
 	.suspend_noirq	= hcd_pci_suspend_noirq,
@@ -526,7 +572,9 @@ const struct dev_pm_ops usb_hcd_pci_pm_ops = {
 	.poweroff_noirq	= hcd_pci_suspend_noirq,
 	.restore_noirq	= hcd_pci_resume_noirq,
 	.restore	= hcd_pci_restore,
+	.runtime_suspend = hcd_pci_runtime_suspend,
+	.runtime_resume	= hcd_pci_runtime_resume,
 };
 EXPORT_SYMBOL_GPL(usb_hcd_pci_pm_ops);
 
-#endif	/* CONFIG_PM_SLEEP */
+#endif	/* CONFIG_PM_OPS */</pre><hr><pre>commit 0d436b425e07f9e4b0fe571cec061f5d136f1d8b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jun 25 14:02:49 2010 -0400

    USB: UHCI: add support for Intel's wakeup flags
    
    This patch (as1396) adds code to uhci-hcd to support the
    vendor-specific wakeup settings found in Intel's ICHx hardware.  A
    couple of unnecessary memory barriers are removed.  And the root hub
    isn't put back into the "suspended" state if power was lost during a
    system sleep -- there's not much point in doing so because the root hub
    will be resumed shortly.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 9d4d81248f96..b04506036b64 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -176,6 +176,8 @@ static void check_and_reset_hc(struct uhci_hcd *uhci)
  */
 static void configure_hc(struct uhci_hcd *uhci)
 {
+	struct pci_dev *pdev = to_pci_dev(uhci_dev(uhci));
+
 	/* Set the frame length to the default: 1 ms exactly */
 	outb(USBSOF_DEFAULT, uhci-&gt;io_addr + USBSOF);
 
@@ -191,8 +193,11 @@ static void configure_hc(struct uhci_hcd *uhci)
 	mb();
 
 	/* Enable PIRQ */
-	pci_write_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP,
-			USBLEGSUP_DEFAULT);
+	pci_write_config_word(pdev, USBLEGSUP, USBLEGSUP_DEFAULT);
+
+	/* Disable platform-specific non-PME# wakeup */
+	if (pdev-&gt;vendor == PCI_VENDOR_ID_INTEL)
+		pci_write_config_byte(pdev, USBRES_INTEL, 0);
 }
 
 
@@ -791,6 +796,7 @@ static int uhci_rh_resume(struct usb_hcd *hcd)
 static int uhci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
+	struct pci_dev *pdev = to_pci_dev(uhci_dev(uhci));
 	int rc = 0;
 
 	dev_dbg(uhci_dev(uhci), "%s\n", __func__);
@@ -808,11 +814,15 @@ static int uhci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)
 	/* All PCI host controllers are required to disable IRQ generation
 	 * at the source, so we must turn off PIRQ.
 	 */
-	pci_write_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP, 0);
-	mb();
+	pci_write_config_word(pdev, USBLEGSUP, 0);
 	clear_bit(HCD_FLAG_POLL_RH, &amp;hcd-&gt;flags);
 
-	/* FIXME: Enable non-PME# remote wakeup? */
+	/* Enable platform-specific non-PME# wakeup */
+	if (do_wakeup) {
+		if (pdev-&gt;vendor == PCI_VENDOR_ID_INTEL)
+			pci_write_config_byte(pdev, USBRES_INTEL,
+					USBPORT1EN | USBPORT2EN);
+	}
 
 done_okay:
 	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
@@ -831,7 +841,6 @@ static int uhci_pci_resume(struct usb_hcd *hcd, bool hibernated)
 	 * even if the controller was dead.
 	 */
 	set_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
-	mb();
 
 	spin_lock_irq(&amp;uhci-&gt;lock);
 
@@ -839,8 +848,6 @@ static int uhci_pci_resume(struct usb_hcd *hcd, bool hibernated)
 	if (hibernated)
 		uhci_hc_died(uhci);
 
-	/* FIXME: Disable non-PME# remote wakeup? */
-
 	/* The firmware or a boot kernel may have changed the controller
 	 * settings during a system wakeup.  Check it and reconfigure
 	 * to avoid problems.
@@ -850,12 +857,9 @@ static int uhci_pci_resume(struct usb_hcd *hcd, bool hibernated)
 	/* If the controller was dead before, it's back alive now */
 	configure_hc(uhci);
 
-	if (uhci-&gt;rh_state == UHCI_RH_RESET) {
-
-		/* The controller had to be reset */
+	/* Tell the core if the controller had to be reset */
+	if (uhci-&gt;rh_state == UHCI_RH_RESET)
 		usb_root_hub_lost_power(hcd-&gt;self.root_hub);
-		suspend_rh(uhci, UHCI_RH_SUSPENDED);
-	}
 
 	spin_unlock_irq(&amp;uhci-&gt;lock);
 
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index 26bd1b2bcbfc..49bf2790f9c2 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -67,12 +67,17 @@
 #define   USBPORTSC_RES3	0x4000	/* reserved, write zeroes */
 #define   USBPORTSC_RES4	0x8000	/* reserved, write zeroes */
 
-/* Legacy support register */
+/* PCI legacy support register */
 #define USBLEGSUP		0xc0
 #define   USBLEGSUP_DEFAULT	0x2000	/* only PIRQ enable set */
 #define   USBLEGSUP_RWC		0x8f00	/* the R/WC bits */
 #define   USBLEGSUP_RO		0x5040	/* R/O and reserved bits */
 
+/* PCI Intel-specific resume-enable register */
+#define USBRES_INTEL		0xc4
+#define   USBPORT1EN		0x01
+#define   USBPORT2EN		0x02
+
 #define UHCI_PTR_BITS		cpu_to_le32(0x000F)
 #define UHCI_PTR_TERM		cpu_to_le32(0x0001)
 #define UHCI_PTR_QH		cpu_to_le32(0x0002)</pre><hr><pre>commit ff2f07874362d34684296f2bd5547a099f33c6d4
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jun 25 14:02:35 2010 -0400

    USB: fix race between root-hub wakeup &amp; controller suspend
    
    This patch (as1395) adds code to hcd_pci_suspend() for handling wakeup
    races.  This is another general race pattern, similar to the "open
    vs. unregister" race we're all familiar with.  Here, the race is
    between suspending a device and receiving a wakeup request from one of
    the device's suspended children.
    
    In particular, if a root-hub wakeup is requested at about the same
    time as the corresponding USB controller is suspended, and if the
    controller is enabled for wakeup, then the controller should either
    fail to suspend or else wake right back up again.
    
    During system sleep this won't happen very much, especially since host
    controllers generally aren't enabled for wakeup during sleep.  However
    it is definitely an issue for runtime PM.  Something like this will be
    needed to prevent the controller from autosuspending while waiting for
    a root-hub resume to take place.  (That is, in fact, the common case,
    for which there is an extra test.)
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd-pci.c b/drivers/usb/core/hcd-pci.c
index e387e394f876..352577baa53d 100644
--- a/drivers/usb/core/hcd-pci.c
+++ b/drivers/usb/core/hcd-pci.c
@@ -388,8 +388,20 @@ static int hcd_pci_suspend(struct device *dev)
 	if (hcd-&gt;driver-&gt;pci_suspend) {
 		bool	do_wakeup = device_may_wakeup(dev);
 
+		/* Optimization: Don't suspend if a root-hub wakeup is
+		 * pending and it would cause the HCD to wake up anyway.
+		 */
+		if (do_wakeup &amp;&amp; HCD_WAKEUP_PENDING(hcd))
+			return -EBUSY;
 		retval = hcd-&gt;driver-&gt;pci_suspend(hcd, do_wakeup);
 		suspend_report_result(hcd-&gt;driver-&gt;pci_suspend, retval);
+
+		/* Check again in case wakeup raced with pci_suspend */
+		if (retval == 0 &amp;&amp; do_wakeup &amp;&amp; HCD_WAKEUP_PENDING(hcd)) {
+			if (hcd-&gt;driver-&gt;pci_resume)
+				hcd-&gt;driver-&gt;pci_resume(hcd, false);
+			retval = -EBUSY;
+		}
 		if (retval)
 			return retval;
 	}
diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index f2fe7c8e991d..0358c05e6e8a 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1940,6 +1940,7 @@ int hcd_bus_resume(struct usb_device *rhdev, pm_message_t msg)
 
 	dev_dbg(&amp;rhdev-&gt;dev, "usb %s%s\n",
 			(msg.event &amp; PM_EVENT_AUTO ? "auto-" : ""), "resume");
+	clear_bit(HCD_FLAG_WAKEUP_PENDING, &amp;hcd-&gt;flags);
 	if (!hcd-&gt;driver-&gt;bus_resume)
 		return -ENOENT;
 	if (hcd-&gt;state == HC_STATE_RUNNING)
@@ -1993,8 +1994,10 @@ void usb_hcd_resume_root_hub (struct usb_hcd *hcd)
 	unsigned long flags;
 
 	spin_lock_irqsave (&amp;hcd_root_hub_lock, flags);
-	if (hcd-&gt;rh_registered)
+	if (hcd-&gt;rh_registered) {
+		set_bit(HCD_FLAG_WAKEUP_PENDING, &amp;hcd-&gt;flags);
 		queue_work(pm_wq, &amp;hcd-&gt;wakeup_work);
+	}
 	spin_unlock_irqrestore (&amp;hcd_root_hub_lock, flags);
 }
 EXPORT_SYMBOL_GPL(usb_hcd_resume_root_hub);
diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index ae10020b4023..3b571f1ffbb3 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -98,6 +98,7 @@ struct usb_hcd {
 #define HCD_FLAG_SAW_IRQ		1
 #define HCD_FLAG_POLL_RH		2	/* poll for rh status? */
 #define HCD_FLAG_POLL_PENDING		3	/* status has changed? */
+#define HCD_FLAG_WAKEUP_PENDING		4	/* root hub is resuming? */
 
 	/* The flags can be tested using these macros; they are likely to
 	 * be slightly faster than test_bit().
@@ -106,6 +107,7 @@ struct usb_hcd {
 #define HCD_SAW_IRQ(hcd)	((hcd)-&gt;flags &amp; (1U &lt;&lt; HCD_FLAG_SAW_IRQ))
 #define HCD_POLL_RH(hcd)	((hcd)-&gt;flags &amp; (1U &lt;&lt; HCD_FLAG_POLL_RH))
 #define HCD_POLL_PENDING(hcd)	((hcd)-&gt;flags &amp; (1U &lt;&lt; HCD_FLAG_POLL_PENDING))
+#define HCD_WAKEUP_PENDING(hcd)	((hcd)-&gt;flags &amp; (1U &lt;&lt; HCD_FLAG_WAKEUP_PENDING))
 
 	/* Flags that get set only during HCD registration or removal. */
 	unsigned		rh_registered:1;/* is root hub registered? */</pre><hr><pre>commit ee0b9be829803e3ff5adec7456bd59a08425ffa1
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jun 25 14:02:24 2010 -0400

    USB: controller resume should check the root hub
    
    This patch (as1394) adds code to ehci-hcd, ohci-hcd, and uhci-hcd for
    automatically resuming the root hub when the controller is resumed, if
    the root hub has a wakeup request pending on some port.
    
    During resume from system sleep this doesn't matter, because the root
    hubs will naturally be resumed along with every other device in the
    system.  However it _will_ matter for runtime PM: If the controller is
    suspended and a remote wakeup request is received then the controller
    will autoresume, but we need to ensure that the root hub also
    autoresumes.  Otherwise the wakeup request would be ignored, the
    controller would go back to sleep, and the cycle would repeat a large
    number of times (I saw this happen before the patch was written).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 1292a5b2197a..796ea0c8900f 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -166,6 +166,10 @@ static void ehci_adjust_port_wakeup_flags(struct ehci_hcd *ehci,
 			ehci_writel(ehci, temp | HOSTPC_PHCD, hostpc_reg);
 		}
 	}
+
+	/* Does the root hub have a port wakeup pending? */
+	if (!suspending &amp;&amp; (ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;status) &amp; STS_PCD))
+		usb_hcd_resume_root_hub(ehci_to_hcd(ehci));
 }
 
 static int ehci_bus_suspend (struct usb_hcd *hcd)
diff --git a/drivers/usb/host/ohci-hub.c b/drivers/usb/host/ohci-hub.c
index 4dd39022c388..cddcda95b579 100644
--- a/drivers/usb/host/ohci-hub.c
+++ b/drivers/usb/host/ohci-hub.c
@@ -355,6 +355,11 @@ static void ohci_finish_controller_resume(struct usb_hcd *hcd)
 		ohci_readl(ohci, &amp;ohci-&gt;regs-&gt;intrenable);
 		msleep(20);
 	}
+
+	/* Does the root hub have a port wakeup pending? */
+	if (ohci_readl(ohci, &amp;ohci-&gt;regs-&gt;intrstatus) &amp;
+			(OHCI_INTR_RD | OHCI_INTR_RHSC))
+		usb_hcd_resume_root_hub(hcd);
 }
 
 /* Carry out polling-, autostop-, and autoresume-related state changes */
@@ -364,7 +369,7 @@ static int ohci_root_hub_state_changes(struct ohci_hcd *ohci, int changed,
 	int	poll_rh = 1;
 	int	rhsc_enable;
 
-	/* Some broken controllers never turn off RHCS in the interrupt
+	/* Some broken controllers never turn off RHSC in the interrupt
 	 * status register.  For their sake we won't re-enable RHSC
 	 * interrupts if the interrupt bit is already active.
 	 */
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index a7850f51fdc5..9d4d81248f96 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -862,10 +862,11 @@ static int uhci_pci_resume(struct usb_hcd *hcd, bool hibernated)
 	/* If interrupts don't work and remote wakeup is enabled then
 	 * the suspended root hub needs to be polled.
 	 */
-	if (!uhci-&gt;RD_enable &amp;&amp; hcd-&gt;self.root_hub-&gt;do_remote_wakeup) {
+	if (!uhci-&gt;RD_enable &amp;&amp; hcd-&gt;self.root_hub-&gt;do_remote_wakeup)
 		set_bit(HCD_FLAG_POLL_RH, &amp;hcd-&gt;flags);
-		usb_hcd_poll_rh_status(hcd);
-	}
+
+	/* Does the root hub have a port wakeup pending? */
+	usb_hcd_poll_rh_status(hcd);
 	return 0;
 }
 #endif
diff --git a/drivers/usb/host/uhci-hub.c b/drivers/usb/host/uhci-hub.c
index f0c58116c0ad..6d59c0f77f25 100644
--- a/drivers/usb/host/uhci-hub.c
+++ b/drivers/usb/host/uhci-hub.c
@@ -200,7 +200,7 @@ static int uhci_hub_status_data(struct usb_hcd *hcd, char *buf)
 	    case UHCI_RH_SUSPENDING:
 	    case UHCI_RH_SUSPENDED:
 		/* if port change, ask to be resumed */
-		if (status)
+		if (status || uhci-&gt;resuming_ports)
 			usb_hcd_resume_root_hub(hcd);
 		break;
 </pre><hr><pre>commit 4147200d25c423e627ab4487530b3d9f2ef829c8
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jun 25 14:02:14 2010 -0400

    USB: add do_wakeup parameter for PCI HCD suspend
    
    This patch (as1385) adds a "do_wakeup" parameter to the pci_suspend
    method used by PCI-based host controller drivers.  ehci-hcd in
    particular needs to know whether or not to enable wakeup when
    suspending a controller.  Although that information is currently
    available through device_may_wakeup(), when support is added for
    runtime suspend this will no longer be true.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd-pci.c b/drivers/usb/core/hcd-pci.c
index f0156de8db67..e387e394f876 100644
--- a/drivers/usb/core/hcd-pci.c
+++ b/drivers/usb/core/hcd-pci.c
@@ -386,7 +386,9 @@ static int hcd_pci_suspend(struct device *dev)
 		return retval;
 
 	if (hcd-&gt;driver-&gt;pci_suspend) {
-		retval = hcd-&gt;driver-&gt;pci_suspend(hcd);
+		bool	do_wakeup = device_may_wakeup(dev);
+
+		retval = hcd-&gt;driver-&gt;pci_suspend(hcd, do_wakeup);
 		suspend_report_result(hcd-&gt;driver-&gt;pci_suspend, retval);
 		if (retval)
 			return retval;
diff --git a/drivers/usb/host/ehci-au1xxx.c b/drivers/usb/host/ehci-au1xxx.c
index faa61748db70..2baf8a849086 100644
--- a/drivers/usb/host/ehci-au1xxx.c
+++ b/drivers/usb/host/ehci-au1xxx.c
@@ -228,7 +228,7 @@ static int ehci_hcd_au1xxx_drv_suspend(struct device *dev)
 	 * the root hub is either suspended or stopped.
 	 */
 	spin_lock_irqsave(&amp;ehci-&gt;lock, flags);
-	ehci_prepare_ports_for_controller_suspend(ehci);
+	ehci_prepare_ports_for_controller_suspend(ehci, device_may_wakeup(dev));
 	ehci_writel(ehci, 0, &amp;ehci-&gt;regs-&gt;intr_enable);
 	(void)ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;intr_enable);
 
diff --git a/drivers/usb/host/ehci-fsl.c b/drivers/usb/host/ehci-fsl.c
index 5cd967d28938..a416421abfa2 100644
--- a/drivers/usb/host/ehci-fsl.c
+++ b/drivers/usb/host/ehci-fsl.c
@@ -313,7 +313,8 @@ static int ehci_fsl_drv_suspend(struct device *dev)
 	struct ehci_fsl *ehci_fsl = hcd_to_ehci_fsl(hcd);
 	void __iomem *non_ehci = hcd-&gt;regs;
 
-	ehci_prepare_ports_for_controller_suspend(hcd_to_ehci(hcd));
+	ehci_prepare_ports_for_controller_suspend(hcd_to_ehci(hcd),
+			device_may_wakeup(dev));
 	if (!fsl_deep_sleep())
 		return 0;
 
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 0931f5a7dec4..1292a5b2197a 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -107,7 +107,7 @@ static void ehci_handover_companion_ports(struct ehci_hcd *ehci)
 }
 
 static void ehci_adjust_port_wakeup_flags(struct ehci_hcd *ehci,
-		bool suspending)
+		bool suspending, bool do_wakeup)
 {
 	int		port;
 	u32		temp;
@@ -117,8 +117,7 @@ static void ehci_adjust_port_wakeup_flags(struct ehci_hcd *ehci,
 	 * when the controller is suspended or resumed.  In all other
 	 * cases they don't need to be changed.
 	 */
-	if (!ehci_to_hcd(ehci)-&gt;self.root_hub-&gt;do_remote_wakeup ||
-			device_may_wakeup(ehci_to_hcd(ehci)-&gt;self.controller))
+	if (!ehci_to_hcd(ehci)-&gt;self.root_hub-&gt;do_remote_wakeup || do_wakeup)
 		return;
 
 	/* clear phy low-power mode before changing wakeup flags */
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index a307d550bdaf..f555e4f35a04 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -277,7 +277,7 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
  * Also they depend on separate root hub suspend/resume.
  */
 
-static int ehci_pci_suspend(struct usb_hcd *hcd)
+static int ehci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
 	unsigned long		flags;
@@ -291,7 +291,7 @@ static int ehci_pci_suspend(struct usb_hcd *hcd)
 	 * the root hub is either suspended or stopped.
 	 */
 	spin_lock_irqsave (&amp;ehci-&gt;lock, flags);
-	ehci_prepare_ports_for_controller_suspend(ehci);
+	ehci_prepare_ports_for_controller_suspend(ehci, do_wakeup);
 	ehci_writel(ehci, 0, &amp;ehci-&gt;regs-&gt;intr_enable);
 	(void)ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;intr_enable);
 
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index e6c57cc416f6..a4a63ce290e9 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -540,11 +540,11 @@ struct ehci_fstn {
 
 /* Prepare the PORTSC wakeup flags during controller suspend/resume */
 
-#define ehci_prepare_ports_for_controller_suspend(ehci)		\
-		ehci_adjust_port_wakeup_flags(ehci, true);
+#define ehci_prepare_ports_for_controller_suspend(ehci, do_wakeup)	\
+		ehci_adjust_port_wakeup_flags(ehci, true, do_wakeup);
 
-#define ehci_prepare_ports_for_controller_resume(ehci)		\
-		ehci_adjust_port_wakeup_flags(ehci, false);
+#define ehci_prepare_ports_for_controller_resume(ehci)			\
+		ehci_adjust_port_wakeup_flags(ehci, false, false);
 
 /*-------------------------------------------------------------------------*/
 
diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index b8a1148f248e..6bdc8b25a6a1 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -392,7 +392,7 @@ static int __devinit ohci_pci_start (struct usb_hcd *hcd)
 
 #ifdef	CONFIG_PM
 
-static int ohci_pci_suspend(struct usb_hcd *hcd)
+static int ohci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)
 {
 	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
 	unsigned long	flags;
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 2743ec770f0c..a7850f51fdc5 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -788,7 +788,7 @@ static int uhci_rh_resume(struct usb_hcd *hcd)
 	return rc;
 }
 
-static int uhci_pci_suspend(struct usb_hcd *hcd)
+static int uhci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 	int rc = 0;
diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index f8f8fa7a56e8..ae10020b4023 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -211,7 +211,7 @@ struct hc_driver {
 	 * a whole, not just the root hub; they're for PCI bus glue.
 	 */
 	/* called after suspending the hub, before entering D3 etc */
-	int	(*pci_suspend)(struct usb_hcd *hcd);
+	int	(*pci_suspend)(struct usb_hcd *hcd, bool do_wakeup);
 
 	/* called after entering D0 (etc), before resuming the hub */
 	int	(*pci_resume)(struct usb_hcd *hcd, bool hibernated);</pre><hr><pre>commit 057c58bfb1dc9bbb75b8ba3b6c6336cfca63b9d0
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jun 25 14:02:03 2010 -0400

    USB: move PCI HCD resume routine
    
    This patch (as1384) moves the resume_common() routine in hcd-pci.c a
    little higher in the source file to avoid forward references in an
    upcoming patch.  It also replaces the "hibernated" argument with a
    more general "event" argument, which will be useful when the routine
    is called during a runtime resume.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd-pci.c b/drivers/usb/core/hcd-pci.c
index 7c3b0af62241..f0156de8db67 100644
--- a/drivers/usb/core/hcd-pci.c
+++ b/drivers/usb/core/hcd-pci.c
@@ -403,6 +403,43 @@ static int hcd_pci_suspend(struct device *dev)
 	return retval;
 }
 
+static int resume_common(struct device *dev, int event)
+{
+	struct pci_dev		*pci_dev = to_pci_dev(dev);
+	struct usb_hcd		*hcd = pci_get_drvdata(pci_dev);
+	int			retval;
+
+	if (hcd-&gt;state != HC_STATE_SUSPENDED) {
+		dev_dbg(dev, "can't resume, not suspended!\n");
+		return 0;
+	}
+
+	retval = pci_enable_device(pci_dev);
+	if (retval &lt; 0) {
+		dev_err(dev, "can't re-enable after resume, %d!\n", retval);
+		return retval;
+	}
+
+	pci_set_master(pci_dev);
+
+	clear_bit(HCD_FLAG_SAW_IRQ, &amp;hcd-&gt;flags);
+
+	if (hcd-&gt;driver-&gt;pci_resume) {
+		/* This call should be made only during system resume,
+		 * not during runtime resume.
+		 */
+		wait_for_companions(pci_dev, hcd);
+
+		retval = hcd-&gt;driver-&gt;pci_resume(hcd,
+				event == PM_EVENT_RESTORE);
+		if (retval) {
+			dev_err(dev, "PCI post-resume error %d!\n", retval);
+			usb_hc_died(hcd);
+		}
+	}
+	return retval;
+}
+
 static int hcd_pci_suspend_noirq(struct device *dev)
 {
 	struct pci_dev		*pci_dev = to_pci_dev(dev);
@@ -452,50 +489,14 @@ static int hcd_pci_resume_noirq(struct device *dev)
 	return 0;
 }
 
-static int resume_common(struct device *dev, bool hibernated)
-{
-	struct pci_dev		*pci_dev = to_pci_dev(dev);
-	struct usb_hcd		*hcd = pci_get_drvdata(pci_dev);
-	int			retval;
-
-	if (hcd-&gt;state != HC_STATE_SUSPENDED) {
-		dev_dbg(dev, "can't resume, not suspended!\n");
-		return 0;
-	}
-
-	retval = pci_enable_device(pci_dev);
-	if (retval &lt; 0) {
-		dev_err(dev, "can't re-enable after resume, %d!\n", retval);
-		return retval;
-	}
-
-	pci_set_master(pci_dev);
-
-	clear_bit(HCD_FLAG_SAW_IRQ, &amp;hcd-&gt;flags);
-
-	if (hcd-&gt;driver-&gt;pci_resume) {
-		/* This call should be made only during system resume,
-		 * not during runtime resume.
-		 */
-		wait_for_companions(pci_dev, hcd);
-
-		retval = hcd-&gt;driver-&gt;pci_resume(hcd, hibernated);
-		if (retval) {
-			dev_err(dev, "PCI post-resume error %d!\n", retval);
-			usb_hc_died(hcd);
-		}
-	}
-	return retval;
-}
-
 static int hcd_pci_resume(struct device *dev)
 {
-	return resume_common(dev, false);
+	return resume_common(dev, PM_EVENT_RESUME);
 }
 
 static int hcd_pci_restore(struct device *dev)
 {
-	return resume_common(dev, true);
+	return resume_common(dev, PM_EVENT_RESTORE);
 }
 
 const struct dev_pm_ops usb_hcd_pci_pm_ops = {</pre>
    <div class="pagination">
        <a href='2_62.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><span>[63]</span><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_64.html'>Next&gt;&gt;</a>
    <div>
</body>
