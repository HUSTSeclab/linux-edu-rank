<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_5.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><span>[6]</span><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_7.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 5b67b315037250a61861119683e7fcb509deea25
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jan 24 15:14:40 2022 -0500

    usb-storage: Add unusual-devs entry for VL817 USB-SATA bridge
    
    Two people have reported (and mentioned numerous other reports on the
    web) that VIA's VL817 USB-SATA bridge does not work with the uas
    driver.  Typical log messages are:
    
    [ 3606.232149] sd 14:0:0:0: [sdg] tag#2 uas_zap_pending 0 uas-tag 1 inflight: CMD
    [ 3606.232154] sd 14:0:0:0: [sdg] tag#2 CDB: Write(16) 8a 00 00 00 00 00 18 0c c9 80 00 00 00 80 00 00
    [ 3606.306257] usb 4-4.4: reset SuperSpeed Plus Gen 2x1 USB device number 11 using xhci_hcd
    [ 3606.328584] scsi host14: uas_eh_device_reset_handler success
    
    Surprisingly, the devices do seem to work okay for some other people.
    The cause of the differing behaviors is not known.
    
    In the hope of getting the devices to work for the most users, even at
    the possible cost of degraded performance for some, this patch adds an
    unusual_devs entry for the VL817 to block it from binding to the uas
    driver by default.  Users will be able to override this entry by means
    of a module parameter, if they want.
    
    CC: &lt;stable@vger.kernel.org&gt;
    Reported-by: DocMAX &lt;mail@vacharakis.de&gt;
    Reported-and-tested-by: Thomas Weißschuh &lt;linux@weissschuh.net&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/Ye8IsK2sjlEv1rqU@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index 29191d33c0e3..1a05e3dcfec8 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -2301,6 +2301,16 @@ UNUSUAL_DEV(  0x2027, 0xa001, 0x0000, 0x9999,
 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_euscsi_init,
 		US_FL_SCM_MULT_TARG ),
 
+/*
+ * Reported by DocMAX &lt;mail@vacharakis.de&gt;
+ * and Thomas Weißschuh &lt;linux@weissschuh.net&gt;
+ */
+UNUSUAL_DEV( 0x2109, 0x0715, 0x9999, 0x9999,
+		"VIA Labs, Inc.",
+		"VL817 SATA Bridge",
+		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
+		US_FL_IGNORE_UAS),
+
 UNUSUAL_DEV( 0x2116, 0x0320, 0x0001, 0x0001,
 		"ST",
 		"2A",</pre><hr><pre>commit 0f663729bb4afc92a9986b66131ebd5b8a9254d1
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Jan 1 14:52:14 2022 -0500

    USB: core: Fix bug in resuming hub's handling of wakeup requests
    
    Bugzilla #213839 reports a 7-port hub that doesn't work properly when
    devices are plugged into some of the ports; the kernel goes into an
    unending disconnect/reinitialize loop as shown in the bug report.
    
    This "7-port hub" comprises two four-port hubs with one plugged into
    the other; the failures occur when a device is plugged into one of the
    downstream hub's ports.  (These hubs have other problems too.  For
    example, they bill themselves as USB-2.0 compliant but they only run
    at full speed.)
    
    It turns out that the failures are caused by bugs in both the kernel
    and the hub.  The hub's bug is that it reports a different
    bmAttributes value in its configuration descriptor following a remote
    wakeup (0xe0 before, 0xc0 after -- the wakeup-support bit has
    changed).
    
    The kernel's bug is inside the hub driver's resume handler.  When
    hub_activate() sees that one of the hub's downstream ports got a
    wakeup request from a child device, it notes this fact by setting the
    corresponding bit in the hub-&gt;change_bits variable.  But this variable
    is meant for connection changes, not wakeup events; setting it causes
    the driver to believe the downstream port has been disconnected and
    then connected again (in addition to having received a wakeup
    request).
    
    Because of this, the hub driver then tries to check whether the device
    currently plugged into the downstream port is the same as the device
    that had been attached there before.  Normally this check succeeds and
    wakeup handling continues with no harm done (which is why the bug
    remained undetected until now).  But with these dodgy hubs, the check
    fails because the config descriptor has changed.  This causes the hub
    driver to reinitialize the child device, leading to the
    disconnect/reinitialize loop described in the bug report.
    
    The proper way to note reception of a downstream wakeup request is
    to set a bit in the hub-&gt;event_bits variable instead of
    hub-&gt;change_bits.  That way the hub driver will realize that something
    has happened to the port but will not think the port and child device
    have been disconnected.  This patch makes that change.
    
    Cc: &lt;stable@vger.kernel.org&gt;
    Tested-by: Jonathan McDowell &lt;noodles@earth.li&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/YdCw7nSfWYPKWQoD@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 721794f0f494..47a1c8bddf86 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1228,7 +1228,7 @@ static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)
 			 */
 			if (portchange || (hub_is_superspeed(hub-&gt;hdev) &amp;&amp;
 						port_resumed))
-				set_bit(port1, hub-&gt;change_bits);
+				set_bit(port1, hub-&gt;event_bits);
 
 		} else if (udev-&gt;persist_enabled) {
 #ifdef CONFIG_PM</pre><hr><pre>commit 1d7d4c07932e04355d6e6528d44a2f2c9e354346
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Dec 31 21:07:12 2021 -0500

    USB: Fix "slab-out-of-bounds Write" bug in usb_hcd_poll_rh_status
    
    When the USB core code for getting root-hub status reports was
    originally written, it was assumed that the hub driver would be its
    only caller.  But this isn't true now; user programs can use usbfs to
    communicate with root hubs and get status reports.  When they do this,
    they may use a transfer_buffer that is smaller than the data returned
    by the HCD, which will lead to a buffer overflow error when
    usb_hcd_poll_rh_status() tries to store the status data.  This was
    discovered by syzbot:
    
    BUG: KASAN: slab-out-of-bounds in memcpy include/linux/fortify-string.h:225 [inline]
    BUG: KASAN: slab-out-of-bounds in usb_hcd_poll_rh_status+0x5f4/0x780 drivers/usb/core/hcd.c:776
    Write of size 2 at addr ffff88801da403c0 by task syz-executor133/4062
    
    This patch fixes the bug by reducing the amount of status data if it
    won't fit in the transfer_buffer.  If some data gets discarded then
    the URB's completion status is set to -EOVERFLOW rather than 0, to let
    the user know what happened.
    
    Reported-and-tested-by: syzbot+3ae6a2b06f131ab9849f@syzkaller.appspotmail.com
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: &lt;stable@vger.kernel.org&gt;
    Link: https://lore.kernel.org/r/Yc+3UIQJ2STbxNua@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 9ffc63ae65ac..3e01dd6e509b 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -753,6 +753,7 @@ void usb_hcd_poll_rh_status(struct usb_hcd *hcd)
 {
 	struct urb	*urb;
 	int		length;
+	int		status;
 	unsigned long	flags;
 	char		buffer[6];	/* Any root hubs with &gt; 31 ports? */
 
@@ -770,11 +771,17 @@ void usb_hcd_poll_rh_status(struct usb_hcd *hcd)
 		if (urb) {
 			clear_bit(HCD_FLAG_POLL_PENDING, &amp;hcd-&gt;flags);
 			hcd-&gt;status_urb = NULL;
+			if (urb-&gt;transfer_buffer_length &gt;= length) {
+				status = 0;
+			} else {
+				status = -EOVERFLOW;
+				length = urb-&gt;transfer_buffer_length;
+			}
 			urb-&gt;actual_length = length;
 			memcpy(urb-&gt;transfer_buffer, buffer, length);
 
 			usb_hcd_unlink_urb_from_ep(hcd, urb);
-			usb_hcd_giveback_urb(hcd, urb, 0);
+			usb_hcd_giveback_urb(hcd, urb, status);
 		} else {
 			length = 0;
 			set_bit(HCD_FLAG_POLL_PENDING, &amp;hcd-&gt;flags);</pre><hr><pre>commit 6e1fcab00a23f7fe9f4fe9704905a790efa1eeab
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Dec 20 19:21:26 2021 +0800

    scsi: block: pm: Always set request queue runtime active in blk_post_runtime_resume()
    
    John Garry reported a deadlock that occurs when trying to access a
    runtime-suspended SATA device.  For obscure reasons, the rescan procedure
    causes the link to be hard-reset, which disconnects the device.
    
    The rescan tries to carry out a runtime resume when accessing the device.
    scsi_rescan_device() holds the SCSI device lock and won't release it until
    it can put commands onto the device's block queue.  This can't happen until
    the queue is successfully runtime-resumed or the device is unregistered.
    But the runtime resume fails because the device is disconnected, and
    __scsi_remove_device() can't do the unregistration because it can't get the
    device lock.
    
    The best way to resolve this deadlock appears to be to allow the block
    queue to start running again even after an unsuccessful runtime resume.
    The idea is that the driver or the SCSI error handler will need to be able
    to use the queue to resolve the runtime resume failure.
    
    This patch removes the err argument to blk_post_runtime_resume() and makes
    the routine act as though the resume was successful always.  This fixes the
    deadlock.
    
    Link: https://lore.kernel.org/r/1639999298-244569-4-git-send-email-chenxiang66@hisilicon.com
    Fixes: e27829dc92e5 ("scsi: serialize -&gt;rescan against -&gt;remove")
    Reported-and-tested-by: John Garry &lt;john.garry@huawei.com&gt;
    Reviewed-by: Bart Van Assche &lt;bvanassche@acm.org&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Xiang Chen &lt;chenxiang66@hisilicon.com&gt;
    Signed-off-by: Martin K. Petersen &lt;martin.petersen@oracle.com&gt;

diff --git a/block/blk-pm.c b/block/blk-pm.c
index 17bd020268d4..2dad62cc1572 100644
--- a/block/blk-pm.c
+++ b/block/blk-pm.c
@@ -163,27 +163,19 @@ EXPORT_SYMBOL(blk_pre_runtime_resume);
 /**
  * blk_post_runtime_resume - Post runtime resume processing
  * @q: the queue of the device
- * @err: return value of the device's runtime_resume function
  *
  * Description:
- *    Update the queue's runtime status according to the return value of the
- *    device's runtime_resume function. If the resume was successful, call
- *    blk_set_runtime_active() to do the real work of restarting the queue.
+ *    For historical reasons, this routine merely calls blk_set_runtime_active()
+ *    to do the real work of restarting the queue.  It does this regardless of
+ *    whether the device's runtime-resume succeeded; even if it failed the
+ *    driver or error handler will need to communicate with the device.
  *
  *    This function should be called near the end of the device's
  *    runtime_resume callback.
  */
-void blk_post_runtime_resume(struct request_queue *q, int err)
+void blk_post_runtime_resume(struct request_queue *q)
 {
-	if (!q-&gt;dev)
-		return;
-	if (!err) {
-		blk_set_runtime_active(q);
-	} else {
-		spin_lock_irq(&amp;q-&gt;queue_lock);
-		q-&gt;rpm_status = RPM_SUSPENDED;
-		spin_unlock_irq(&amp;q-&gt;queue_lock);
-	}
+	blk_set_runtime_active(q);
 }
 EXPORT_SYMBOL(blk_post_runtime_resume);
 
@@ -201,7 +193,7 @@ EXPORT_SYMBOL(blk_post_runtime_resume);
  * runtime PM status and re-enable peeking requests from the queue. It
  * should be called before first request is added to the queue.
  *
- * This function is also called by blk_post_runtime_resume() for successful
+ * This function is also called by blk_post_runtime_resume() for
  * runtime resumes.  It does everything necessary to restart the queue.
  */
 void blk_set_runtime_active(struct request_queue *q)
diff --git a/drivers/scsi/scsi_pm.c b/drivers/scsi/scsi_pm.c
index 0e841e8761c5..d581613d87c7 100644
--- a/drivers/scsi/scsi_pm.c
+++ b/drivers/scsi/scsi_pm.c
@@ -180,7 +180,7 @@ static int sdev_runtime_resume(struct device *dev)
 	blk_pre_runtime_resume(sdev-&gt;request_queue);
 	if (pm &amp;&amp; pm-&gt;runtime_resume)
 		err = pm-&gt;runtime_resume(dev);
-	blk_post_runtime_resume(sdev-&gt;request_queue, err);
+	blk_post_runtime_resume(sdev-&gt;request_queue);
 
 	return err;
 }
diff --git a/include/linux/blk-pm.h b/include/linux/blk-pm.h
index b80c65aba249..2580e05a8ab6 100644
--- a/include/linux/blk-pm.h
+++ b/include/linux/blk-pm.h
@@ -14,7 +14,7 @@ extern void blk_pm_runtime_init(struct request_queue *q, struct device *dev);
 extern int blk_pre_runtime_suspend(struct request_queue *q);
 extern void blk_post_runtime_suspend(struct request_queue *q, int err);
 extern void blk_pre_runtime_resume(struct request_queue *q);
-extern void blk_post_runtime_resume(struct request_queue *q, int err);
+extern void blk_post_runtime_resume(struct request_queue *q);
 extern void blk_set_runtime_active(struct request_queue *q);
 #else
 static inline void blk_pm_runtime_init(struct request_queue *q,</pre><hr><pre>commit 846cbf98cbef20376b1a95fa3734c435543f3519
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Oct 2 15:02:17 2021 -0400

    USB: EHCI: Improve port index sanitizing
    
    Now that Kees Cook has added a definition for HCS_N_PORTS_MAX in
    commit 72dd1843232c ("USB: EHCI: Add register array bounds to HCS
    ports"), the code in ehci_hub_control() which sanitizes port index
    values can be improved a little.
    
    The idea behind this change is that it prevents a possible
    out-of-bounds pointer computation, which the compiler might be able to
    detect since the port_status[] array now has a fixed length rather
    than a variable length.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/20211002190217.GA537967@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index c4f6a2559a98..efe30e3be22f 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -745,12 +745,13 @@ int ehci_hub_control(
 	unsigned	selector;
 
 	/*
-	 * Avoid underflow while calculating (wIndex &amp; 0xff) - 1.
-	 * The compiler might deduce that wIndex can never be 0 and then
-	 * optimize away the tests for !wIndex below.
+	 * Avoid out-of-bounds values while calculating the port index
+	 * from wIndex.  The compiler doesn't like pointers to invalid
+	 * addresses, even if they are never used.
 	 */
-	temp = wIndex &amp; 0xff;
-	temp -= (temp &gt; 0);
+	temp = (wIndex - 1) &amp; 0xff;
+	if (temp &gt;= HCS_N_PORTS_MAX)
+		temp = 0;
 	status_reg = &amp;ehci-&gt;regs-&gt;port_status[temp];
 	hostpc_reg = &amp;ehci-&gt;regs-&gt;hostpc[temp];
 </pre><hr><pre>commit ae8709b296d80c7f45aa1f35c0e7659ad69edce1
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Sep 3 13:53:12 2021 -0400

    USB: core: Make do_proc_control() and do_proc_bulk() killable
    
    The USBDEVFS_CONTROL and USBDEVFS_BULK ioctls invoke
    usb_start_wait_urb(), which contains an uninterruptible wait with a
    user-specified timeout value.  If timeout value is very large and the
    device being accessed does not respond in a reasonable amount of time,
    the kernel will complain about "Task X blocked for more than N
    seconds", as found in testing by syzbot:
    
    INFO: task syz-executor.0:8700 blocked for more than 143 seconds.
          Not tainted 5.14.0-rc7-syzkaller #0
    "echo 0 &gt; /proc/sys/kernel/hung_task_timeout_secs" disables this message.
    task:syz-executor.0  state:D stack:23192 pid: 8700 ppid:  8455 flags:0x00004004
    Call Trace:
     context_switch kernel/sched/core.c:4681 [inline]
     __schedule+0xc07/0x11f0 kernel/sched/core.c:5938
     schedule+0x14b/0x210 kernel/sched/core.c:6017
     schedule_timeout+0x98/0x2f0 kernel/time/timer.c:1857
     do_wait_for_common+0x2da/0x480 kernel/sched/completion.c:85
     __wait_for_common kernel/sched/completion.c:106 [inline]
     wait_for_common kernel/sched/completion.c:117 [inline]
     wait_for_completion_timeout+0x46/0x60 kernel/sched/completion.c:157
     usb_start_wait_urb+0x167/0x550 drivers/usb/core/message.c:63
     do_proc_bulk+0x978/0x1080 drivers/usb/core/devio.c:1236
     proc_bulk drivers/usb/core/devio.c:1273 [inline]
     usbdev_do_ioctl drivers/usb/core/devio.c:2547 [inline]
     usbdev_ioctl+0x3441/0x6b10 drivers/usb/core/devio.c:2713
    ...
    
    To fix this problem, this patch replaces usbfs's calls to
    usb_control_msg() and usb_bulk_msg() with special-purpose code that
    does essentially the same thing (as recommended in the comment for
    usb_start_wait_urb()), except that it always uses a killable wait and
    it uses GFP_KERNEL rather than GFP_NOIO.
    
    Reported-and-tested-by: syzbot+ada0f7d3d9fd2016d927@syzkaller.appspotmail.com
    Suggested-by: Oliver Neukum &lt;oneukum@suse.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/20210903175312.GA468440@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 9618ba622a2d..fa66e6e58792 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -32,6 +32,7 @@
 #include &lt;linux/usb.h&gt;
 #include &lt;linux/usbdevice_fs.h&gt;
 #include &lt;linux/usb/hcd.h&gt;	/* for usbcore internals */
+#include &lt;linux/usb/quirks.h&gt;
 #include &lt;linux/cdev.h&gt;
 #include &lt;linux/notifier.h&gt;
 #include &lt;linux/security.h&gt;
@@ -1102,14 +1103,55 @@ static int usbdev_release(struct inode *inode, struct file *file)
 	return 0;
 }
 
+static void usbfs_blocking_completion(struct urb *urb)
+{
+	complete((struct completion *) urb-&gt;context);
+}
+
+/*
+ * Much like usb_start_wait_urb, but returns status separately from
+ * actual_length and uses a killable wait.
+ */
+static int usbfs_start_wait_urb(struct urb *urb, int timeout,
+		unsigned int *actlen)
+{
+	DECLARE_COMPLETION_ONSTACK(ctx);
+	unsigned long expire;
+	int rc;
+
+	urb-&gt;context = &amp;ctx;
+	urb-&gt;complete = usbfs_blocking_completion;
+	*actlen = 0;
+	rc = usb_submit_urb(urb, GFP_KERNEL);
+	if (unlikely(rc))
+		return rc;
+
+	expire = (timeout ? msecs_to_jiffies(timeout) : MAX_SCHEDULE_TIMEOUT);
+	rc = wait_for_completion_killable_timeout(&amp;ctx, expire);
+	if (rc &lt;= 0) {
+		usb_kill_urb(urb);
+		*actlen = urb-&gt;actual_length;
+		if (urb-&gt;status != -ENOENT)
+			;	/* Completed before it was killed */
+		else if (rc &lt; 0)
+			return -EINTR;
+		else
+			return -ETIMEDOUT;
+	}
+	*actlen = urb-&gt;actual_length;
+	return urb-&gt;status;
+}
+
 static int do_proc_control(struct usb_dev_state *ps,
 		struct usbdevfs_ctrltransfer *ctrl)
 {
 	struct usb_device *dev = ps-&gt;dev;
 	unsigned int tmo;
 	unsigned char *tbuf;
-	unsigned wLength;
+	unsigned int wLength, actlen;
 	int i, pipe, ret;
+	struct urb *urb = NULL;
+	struct usb_ctrlrequest *dr = NULL;
 
 	ret = check_ctrlrecip(ps, ctrl-&gt;bRequestType, ctrl-&gt;bRequest,
 			      ctrl-&gt;wIndex);
@@ -1122,51 +1164,63 @@ static int do_proc_control(struct usb_dev_state *ps,
 			sizeof(struct usb_ctrlrequest));
 	if (ret)
 		return ret;
+
+	ret = -ENOMEM;
 	tbuf = (unsigned char *)__get_free_page(GFP_KERNEL);
-	if (!tbuf) {
-		ret = -ENOMEM;
+	if (!tbuf)
 		goto done;
-	}
+	urb = usb_alloc_urb(0, GFP_NOIO);
+	if (!urb)
+		goto done;
+	dr = kmalloc(sizeof(struct usb_ctrlrequest), GFP_NOIO);
+	if (!dr)
+		goto done;
+
+	dr-&gt;bRequestType = ctrl-&gt;bRequestType;
+	dr-&gt;bRequest = ctrl-&gt;bRequest;
+	dr-&gt;wValue = cpu_to_le16(ctrl-&gt;wValue);
+	dr-&gt;wIndex = cpu_to_le16(ctrl-&gt;wIndex);
+	dr-&gt;wLength = cpu_to_le16(ctrl-&gt;wLength);
+
 	tmo = ctrl-&gt;timeout;
 	snoop(&amp;dev-&gt;dev, "control urb: bRequestType=%02x "
 		"bRequest=%02x wValue=%04x "
 		"wIndex=%04x wLength=%04x\n",
 		ctrl-&gt;bRequestType, ctrl-&gt;bRequest, ctrl-&gt;wValue,
 		ctrl-&gt;wIndex, ctrl-&gt;wLength);
-	if ((ctrl-&gt;bRequestType &amp; USB_DIR_IN) &amp;&amp; ctrl-&gt;wLength) {
+
+	if ((ctrl-&gt;bRequestType &amp; USB_DIR_IN) &amp;&amp; wLength) {
 		pipe = usb_rcvctrlpipe(dev, 0);
-		snoop_urb(dev, NULL, pipe, ctrl-&gt;wLength, tmo, SUBMIT, NULL, 0);
+		usb_fill_control_urb(urb, dev, pipe, (unsigned char *) dr, tbuf,
+				wLength, NULL, NULL);
+		snoop_urb(dev, NULL, pipe, wLength, tmo, SUBMIT, NULL, 0);
 
 		usb_unlock_device(dev);
-		i = usb_control_msg(dev, pipe, ctrl-&gt;bRequest,
-				    ctrl-&gt;bRequestType, ctrl-&gt;wValue, ctrl-&gt;wIndex,
-				    tbuf, ctrl-&gt;wLength, tmo);
+		i = usbfs_start_wait_urb(urb, tmo, &amp;actlen);
 		usb_lock_device(dev);
-		snoop_urb(dev, NULL, pipe, max(i, 0), min(i, 0), COMPLETE,
-			  tbuf, max(i, 0));
-		if ((i &gt; 0) &amp;&amp; ctrl-&gt;wLength) {
-			if (copy_to_user(ctrl-&gt;data, tbuf, i)) {
+		snoop_urb(dev, NULL, pipe, actlen, i, COMPLETE, tbuf, actlen);
+		if (!i &amp;&amp; actlen) {
+			if (copy_to_user(ctrl-&gt;data, tbuf, actlen)) {
 				ret = -EFAULT;
-				goto done;
+				goto recv_fault;
 			}
 		}
 	} else {
-		if (ctrl-&gt;wLength) {
-			if (copy_from_user(tbuf, ctrl-&gt;data, ctrl-&gt;wLength)) {
+		if (wLength) {
+			if (copy_from_user(tbuf, ctrl-&gt;data, wLength)) {
 				ret = -EFAULT;
 				goto done;
 			}
 		}
 		pipe = usb_sndctrlpipe(dev, 0);
-		snoop_urb(dev, NULL, pipe, ctrl-&gt;wLength, tmo, SUBMIT,
-			tbuf, ctrl-&gt;wLength);
+		usb_fill_control_urb(urb, dev, pipe, (unsigned char *) dr, tbuf,
+				wLength, NULL, NULL);
+		snoop_urb(dev, NULL, pipe, wLength, tmo, SUBMIT, tbuf, wLength);
 
 		usb_unlock_device(dev);
-		i = usb_control_msg(dev, pipe, ctrl-&gt;bRequest,
-				    ctrl-&gt;bRequestType, ctrl-&gt;wValue, ctrl-&gt;wIndex,
-				    tbuf, ctrl-&gt;wLength, tmo);
+		i = usbfs_start_wait_urb(urb, tmo, &amp;actlen);
 		usb_lock_device(dev);
-		snoop_urb(dev, NULL, pipe, max(i, 0), min(i, 0), COMPLETE, NULL, 0);
+		snoop_urb(dev, NULL, pipe, actlen, i, COMPLETE, NULL, 0);
 	}
 	if (i &lt; 0 &amp;&amp; i != -EPIPE) {
 		dev_printk(KERN_DEBUG, &amp;dev-&gt;dev, "usbfs: USBDEVFS_CONTROL "
@@ -1174,8 +1228,15 @@ static int do_proc_control(struct usb_dev_state *ps,
 			   current-&gt;comm, ctrl-&gt;bRequestType, ctrl-&gt;bRequest,
 			   ctrl-&gt;wLength, i);
 	}
-	ret = i;
+	ret = (i &lt; 0 ? i : actlen);
+
+ recv_fault:
+	/* Linger a bit, prior to the next control message. */
+	if (dev-&gt;quirks &amp; USB_QUIRK_DELAY_CTRL_MSG)
+		msleep(200);
  done:
+	kfree(dr);
+	usb_free_urb(urb);
 	free_page((unsigned long) tbuf);
 	usbfs_decrease_memory_usage(PAGE_SIZE + sizeof(struct urb) +
 			sizeof(struct usb_ctrlrequest));
@@ -1195,10 +1256,11 @@ static int do_proc_bulk(struct usb_dev_state *ps,
 		struct usbdevfs_bulktransfer *bulk)
 {
 	struct usb_device *dev = ps-&gt;dev;
-	unsigned int tmo, len1, pipe;
-	int len2;
+	unsigned int tmo, len1, len2, pipe;
 	unsigned char *tbuf;
 	int i, ret;
+	struct urb *urb = NULL;
+	struct usb_host_endpoint *ep;
 
 	ret = findintfep(ps-&gt;dev, bulk-&gt;ep);
 	if (ret &lt; 0)
@@ -1206,14 +1268,17 @@ static int do_proc_bulk(struct usb_dev_state *ps,
 	ret = checkintf(ps, ret);
 	if (ret)
 		return ret;
+
+	len1 = bulk-&gt;len;
+	if (len1 &lt; 0 || len1 &gt;= (INT_MAX - sizeof(struct urb)))
+		return -EINVAL;
+
 	if (bulk-&gt;ep &amp; USB_DIR_IN)
 		pipe = usb_rcvbulkpipe(dev, bulk-&gt;ep &amp; 0x7f);
 	else
 		pipe = usb_sndbulkpipe(dev, bulk-&gt;ep &amp; 0x7f);
-	if (!usb_maxpacket(dev, pipe, !(bulk-&gt;ep &amp; USB_DIR_IN)))
-		return -EINVAL;
-	len1 = bulk-&gt;len;
-	if (len1 &gt;= (INT_MAX - sizeof(struct urb)))
+	ep = usb_pipe_endpoint(dev, pipe);
+	if (!ep || !usb_endpoint_maxp(&amp;ep-&gt;desc))
 		return -EINVAL;
 	ret = usbfs_increase_memory_usage(len1 + sizeof(struct urb));
 	if (ret)
@@ -1223,17 +1288,29 @@ static int do_proc_bulk(struct usb_dev_state *ps,
 	 * len1 can be almost arbitrarily large.  Don't WARN if it's
 	 * too big, just fail the request.
 	 */
+	ret = -ENOMEM;
 	tbuf = kmalloc(len1, GFP_KERNEL | __GFP_NOWARN);
-	if (!tbuf) {
-		ret = -ENOMEM;
+	if (!tbuf)
+		goto done;
+	urb = usb_alloc_urb(0, GFP_KERNEL);
+	if (!urb)
 		goto done;
+
+	if ((ep-&gt;desc.bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK) ==
+			USB_ENDPOINT_XFER_INT) {
+		pipe = (pipe &amp; ~(3 &lt;&lt; 30)) | (PIPE_INTERRUPT &lt;&lt; 30);
+		usb_fill_int_urb(urb, dev, pipe, tbuf, len1,
+				NULL, NULL, ep-&gt;desc.bInterval);
+	} else {
+		usb_fill_bulk_urb(urb, dev, pipe, tbuf, len1, NULL, NULL);
 	}
+
 	tmo = bulk-&gt;timeout;
 	if (bulk-&gt;ep &amp; 0x80) {
 		snoop_urb(dev, NULL, pipe, len1, tmo, SUBMIT, NULL, 0);
 
 		usb_unlock_device(dev);
-		i = usb_bulk_msg(dev, pipe, tbuf, len1, &amp;len2, tmo);
+		i = usbfs_start_wait_urb(urb, tmo, &amp;len2);
 		usb_lock_device(dev);
 		snoop_urb(dev, NULL, pipe, len2, i, COMPLETE, tbuf, len2);
 
@@ -1253,12 +1330,13 @@ static int do_proc_bulk(struct usb_dev_state *ps,
 		snoop_urb(dev, NULL, pipe, len1, tmo, SUBMIT, tbuf, len1);
 
 		usb_unlock_device(dev);
-		i = usb_bulk_msg(dev, pipe, tbuf, len1, &amp;len2, tmo);
+		i = usbfs_start_wait_urb(urb, tmo, &amp;len2);
 		usb_lock_device(dev);
 		snoop_urb(dev, NULL, pipe, len2, i, COMPLETE, NULL, 0);
 	}
 	ret = (i &lt; 0 ? i : len2);
  done:
+	usb_free_urb(urb);
 	kfree(tbuf);
 	usbfs_decrease_memory_usage(len1 + sizeof(struct urb));
 	return ret;</pre><hr><pre>commit d2f311ec91984adb219ac6985d4dd72c37ae734d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Sep 1 12:36:06 2021 -0400

    HID: usbhid: Simplify code in hid_submit_ctrl()
    
    This patch makes a small simplification to the code in
    hid_submit_ctrl().  The test for maxpacket being &gt; 0 is unnecessary,
    because endpoint 0 always has a maxpacket value which is &gt;= 8.
    
    Furthermore, endpoint 0's maxpacket value is always a power of 2, so
    instead of open-coding the round-to-next-multiple computation we can
    call the optimized round_up() routine.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Benjamin Tissoires &lt;benjamin.tissoires@redhat.com&gt;
    Acked-by: Benjamin Tissoires &lt;benjamin.tissoires@redhat.com&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c
index c56cb03c1551..2dcaf31eb9cd 100644
--- a/drivers/hid/usbhid/hid-core.c
+++ b/drivers/hid/usbhid/hid-core.c
@@ -388,14 +388,10 @@ static int hid_submit_ctrl(struct hid_device *hid)
 		usbhid-&gt;urbctrl-&gt;pipe = usb_rcvctrlpipe(hid_to_usb_dev(hid), 0);
 		maxpacket = usb_maxpacket(hid_to_usb_dev(hid),
 					  usbhid-&gt;urbctrl-&gt;pipe, 0);
-		if (maxpacket &gt; 0) {
-			len += (len == 0);    /* Don't allow 0-length reports */
-			len = DIV_ROUND_UP(len, maxpacket);
-			len *= maxpacket;
-			if (len &gt; usbhid-&gt;bufsize)
-				len = usbhid-&gt;bufsize;
-		} else
-			len = 0;
+		len += (len == 0);	/* Don't allow 0-length reports */
+		len = round_up(len, maxpacket);
+		if (len &gt; usbhid-&gt;bufsize)
+			len = usbhid-&gt;bufsize;
 	}
 	usbhid-&gt;urbctrl-&gt;transfer_buffer_length = len;
 	usbhid-&gt;urbctrl-&gt;dev = hid_to_usb_dev(hid);</pre><hr><pre>commit 0a824efdb724e07574bafcd2c2486b2a3de35ff6
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Sep 1 12:36:00 2021 -0400

    HID: usbhid: Fix warning caused by 0-length input reports
    
    Syzbot found a warning caused by hid_submit_ctrl() submitting a
    control request to transfer a 0-length input report:
    
            usb 1-1: BOGUS control dir, pipe 80000280 doesn't match bRequestType a1
    
    (The warning message is a little difficult to understand.  It means
    that the control request claims to be for an IN transfer but this
    contradicts the USB spec, which requires 0-length control transfers
    always to be in the OUT direction.)
    
    Now, a zero-length report isn't good for anything and there's no
    reason for a device to have one, but the fuzzer likes to pick out
    these weird edge cases.  In the future, perhaps we will decide to
    reject 0-length reports at probe time.  For now, the simplest approach
    for avoiding these warnings is to pretend that the report actually has
    length 1.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: syzbot+9b57a46bf1801ce2a2ca@syzkaller.appspotmail.com
    Tested-by: Oleksandr Natalenko &lt;oleksandr@natalenko.name&gt;
    Tested-by: Benjamin Tissoires &lt;benjamin.tissoires@redhat.com&gt;
    Acked-by: Benjamin Tissoires &lt;benjamin.tissoires@redhat.com&gt;
    Cc: stable@vger.kernel.org
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c
index 6b8690878435..c56cb03c1551 100644
--- a/drivers/hid/usbhid/hid-core.c
+++ b/drivers/hid/usbhid/hid-core.c
@@ -389,6 +389,7 @@ static int hid_submit_ctrl(struct hid_device *hid)
 		maxpacket = usb_maxpacket(hid_to_usb_dev(hid),
 					  usbhid-&gt;urbctrl-&gt;pipe, 0);
 		if (maxpacket &gt; 0) {
+			len += (len == 0);    /* Don't allow 0-length reports */
 			len = DIV_ROUND_UP(len, maxpacket);
 			len *= maxpacket;
 			if (len &gt; usbhid-&gt;bufsize)</pre><hr><pre>commit b0863f1927323110e3d0d69f6adb6a91018a9a3c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jul 12 14:54:36 2021 -0400

    USB: core: Fix incorrect pipe calculation in do_proc_control()
    
    When the user submits a control URB via usbfs, the user supplies the
    bRequestType value and the kernel uses it to compute the pipe value.
    However, do_proc_control() performs this computation incorrectly in
    the case where the bRequestType direction bit is set to USB_DIR_IN and
    the URB's transfer length is 0: The pipe's direction is also set to IN
    but it should be OUT, which is the direction the actual transfer will
    use regardless of bRequestType.
    
    Commit 5cc59c418fde ("USB: core: WARN if pipe direction != setup
    packet direction") added a check to compare the direction bit in the
    pipe value to a control URB's actual direction and to WARN if they are
    different.  This can be triggered by the incorrect computation
    mentioned above, as found by syzbot.
    
    This patch fixes the computation, thus avoiding the WARNing.
    
    Reported-and-tested-by: syzbot+72af3105289dcb4c055b@syzkaller.appspotmail.com
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/20210712185436.GB326369@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index b97464498763..9618ba622a2d 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -1133,7 +1133,7 @@ static int do_proc_control(struct usb_dev_state *ps,
 		"wIndex=%04x wLength=%04x\n",
 		ctrl-&gt;bRequestType, ctrl-&gt;bRequest, ctrl-&gt;wValue,
 		ctrl-&gt;wIndex, ctrl-&gt;wLength);
-	if (ctrl-&gt;bRequestType &amp; 0x80) {
+	if ((ctrl-&gt;bRequestType &amp; USB_DIR_IN) &amp;&amp; ctrl-&gt;wLength) {
 		pipe = usb_rcvctrlpipe(dev, 0);
 		snoop_urb(dev, NULL, pipe, ctrl-&gt;wLength, tmo, SUBMIT, NULL, 0);
 </pre><hr><pre>commit 60dfe484cef45293e631b3a6e8995f1689818172
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jun 7 11:23:07 2021 -0400

    USB: core: Avoid WARNings for 0-length descriptor requests
    
    The USB core has utility routines to retrieve various types of
    descriptors.  These routines will now provoke a WARN if they are asked
    to retrieve 0 bytes (USB "receive" requests must not have zero
    length), so avert this by checking the size argument at the start.
    
    CC: Johan Hovold &lt;johan@kernel.org&gt;
    Reported-and-tested-by: syzbot+7dbcd9ff34dc4ed45240@syzkaller.appspotmail.com
    Reviewed-by: Johan Hovold &lt;johan@kernel.org&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/20210607152307.GD1768031@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 30e9e680c74c..4d59d927ae3e 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -783,6 +783,9 @@ int usb_get_descriptor(struct usb_device *dev, unsigned char type,
 	int i;
 	int result;
 
+	if (size &lt;= 0)		/* No point in asking for no data */
+		return -EINVAL;
+
 	memset(buf, 0, size);	/* Make sure we parse really received data */
 
 	for (i = 0; i &lt; 3; ++i) {
@@ -832,6 +835,9 @@ static int usb_get_string(struct usb_device *dev, unsigned short langid,
 	int i;
 	int result;
 
+	if (size &lt;= 0)		/* No point in asking for no data */
+		return -EINVAL;
+
 	for (i = 0; i &lt; 3; ++i) {
 		/* retry on length 0 or stall; some devices are flakey */
 		result = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),</pre>
    <div class="pagination">
        <a href='2_5.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><span>[6]</span><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_7.html'>Next&gt;&gt;</a>
    <div>
</body>
