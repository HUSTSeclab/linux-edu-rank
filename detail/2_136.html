<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_135.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><span>[136]</span><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_137.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 903f4fed858a7b56b260cbd55d174fe54d188fb7
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jul 26 10:20:53 2005 -0400

    [SCSI] fix callers of scsi_remove_device() who already hold the scan muted
    
    This patch (as544) adds a private entry point to scsi_remove_device, for
    use when callers already own the scan_mutex.  The appropriate callers are
    modified to use the new entry point.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/scsi_priv.h b/drivers/scsi/scsi_priv.h
index ee6de1768e53..d05f778d31a8 100644
--- a/drivers/scsi/scsi_priv.h
+++ b/drivers/scsi/scsi_priv.h
@@ -124,6 +124,7 @@ extern void scsi_sysfs_unregister(void);
 extern void scsi_sysfs_device_initialize(struct scsi_device *);
 extern int scsi_sysfs_target_initialize(struct scsi_device *);
 extern struct scsi_transport_template blank_transport_template;
+extern void __scsi_remove_device(struct scsi_device *);
 
 extern struct bus_type scsi_bus_type;
 
diff --git a/drivers/scsi/scsi_sysfs.c b/drivers/scsi/scsi_sysfs.c
index dae59d1da07a..b8052d5206cc 100644
--- a/drivers/scsi/scsi_sysfs.c
+++ b/drivers/scsi/scsi_sysfs.c
@@ -653,7 +653,7 @@ int scsi_sysfs_add_sdev(struct scsi_device *sdev)
 			error = attr_add(&amp;sdev-&gt;sdev_gendev,
 					sdev-&gt;host-&gt;hostt-&gt;sdev_attrs[i]);
 			if (error) {
-				scsi_remove_device(sdev);
+				__scsi_remove_device(sdev);
 				goto out;
 			}
 		}
@@ -667,7 +667,7 @@ int scsi_sysfs_add_sdev(struct scsi_device *sdev)
 							scsi_sysfs_sdev_attrs[i]);
 			error = device_create_file(&amp;sdev-&gt;sdev_gendev, attr);
 			if (error) {
-				scsi_remove_device(sdev);
+				__scsi_remove_device(sdev);
 				goto out;
 			}
 		}
@@ -687,17 +687,10 @@ int scsi_sysfs_add_sdev(struct scsi_device *sdev)
 	return error;
 }
 
-/**
- * scsi_remove_device - unregister a device from the scsi bus
- * @sdev:	scsi_device to unregister
- **/
-void scsi_remove_device(struct scsi_device *sdev)
+void __scsi_remove_device(struct scsi_device *sdev)
 {
-	struct Scsi_Host *shost = sdev-&gt;host;
-
-	down(&amp;shost-&gt;scan_mutex);
 	if (scsi_device_set_state(sdev, SDEV_CANCEL) != 0)
-		goto out;
+		return;
 
 	class_device_unregister(&amp;sdev-&gt;sdev_classdev);
 	device_del(&amp;sdev-&gt;sdev_gendev);
@@ -706,8 +699,17 @@ void scsi_remove_device(struct scsi_device *sdev)
 		sdev-&gt;host-&gt;hostt-&gt;slave_destroy(sdev);
 	transport_unregister_device(&amp;sdev-&gt;sdev_gendev);
 	put_device(&amp;sdev-&gt;sdev_gendev);
-out:
-	up(&amp;shost-&gt;scan_mutex);
+}
+
+/**
+ * scsi_remove_device - unregister a device from the scsi bus
+ * @sdev:	scsi_device to unregister
+ **/
+void scsi_remove_device(struct scsi_device *sdev)
+{
+	down(&amp;sdev-&gt;host-&gt;scan_mutex);
+	__scsi_remove_device(sdev);
+	up(&amp;sdev-&gt;host-&gt;scan_mutex);
 }
 EXPORT_SYMBOL(scsi_remove_device);
 </pre><hr><pre>commit e517d3133f62c27b211f305a6dbd6f6ccac0db1b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jul 26 10:18:45 2005 -0400

    [SCSI] add missing scan mutex to scsi_scan_target()
    
    This patch (as543) adds a private entry point to scsi_scan_target, for use
    when the caller already owns the scan_mutex, and updates the kerneldoc for
    that routine (which was badly out-of-date).  It converts scsi_scan_channel
    to use the new entry point.  Lastly, it modifies scsi_get_host_dev to make
    it acquire the scan_mutex, necessary since the routine adds a new
    scsi_device even if it doesn't do any actual scanning.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c
index 19c9a232a754..76577fae60fa 100644
--- a/drivers/scsi/scsi_scan.c
+++ b/drivers/scsi/scsi_scan.c
@@ -1276,27 +1276,8 @@ void scsi_rescan_device(struct device *dev)
 }
 EXPORT_SYMBOL(scsi_rescan_device);
 
-/**
- * scsi_scan_target - scan a target id, possibly including all LUNs on the
- *     target.
- * @sdevsca:	Scsi_Device handle for scanning
- * @shost:	host to scan
- * @channel:	channel to scan
- * @id:		target id to scan
- *
- * Description:
- *     Scan the target id on @shost, @channel, and @id. Scan at least LUN
- *     0, and possibly all LUNs on the target id.
- *
- *     Use the pre-allocated @sdevscan as a handle for the scanning. This
- *     function sets sdevscan-&gt;host, sdevscan-&gt;id and sdevscan-&gt;lun; the
- *     scanning functions modify sdevscan-&gt;lun.
- *
- *     First try a REPORT LUN scan, if that does not scan the target, do a
- *     sequential scan of LUNs on the target id.
- **/
-void scsi_scan_target(struct device *parent, unsigned int channel,
-		      unsigned int id, unsigned int lun, int rescan)
+static void __scsi_scan_target(struct device *parent, unsigned int channel,
+		unsigned int id, unsigned int lun, int rescan)
 {
 	struct Scsi_Host *shost = dev_to_shost(parent);
 	int bflags = 0;
@@ -1310,9 +1291,7 @@ void scsi_scan_target(struct device *parent, unsigned int channel,
 		 */
 		return;
 
-
 	starget = scsi_alloc_target(parent, channel, id);
-
 	if (!starget)
 		return;
 
@@ -1358,6 +1337,33 @@ void scsi_scan_target(struct device *parent, unsigned int channel,
 
 	put_device(&amp;starget-&gt;dev);
 }
+
+/**
+ * scsi_scan_target - scan a target id, possibly including all LUNs on the
+ *     target.
+ * @parent:	host to scan
+ * @channel:	channel to scan
+ * @id:		target id to scan
+ * @lun:	Specific LUN to scan or SCAN_WILD_CARD
+ * @rescan:	passed to LUN scanning routines
+ *
+ * Description:
+ *     Scan the target id on @parent, @channel, and @id. Scan at least LUN 0,
+ *     and possibly all LUNs on the target id.
+ *
+ *     First try a REPORT LUN scan, if that does not scan the target, do a
+ *     sequential scan of LUNs on the target id.
+ **/
+void scsi_scan_target(struct device *parent, unsigned int channel,
+		      unsigned int id, unsigned int lun, int rescan)
+{
+	struct Scsi_Host *shost = dev_to_shost(parent);
+
+	down(&amp;shost-&gt;scan_mutex);
+	if (scsi_host_scan_allowed(shost))
+		__scsi_scan_target(parent, channel, id, lun, rescan);
+	up(&amp;shost-&gt;scan_mutex);
+}
 EXPORT_SYMBOL(scsi_scan_target);
 
 static void scsi_scan_channel(struct Scsi_Host *shost, unsigned int channel,
@@ -1383,10 +1389,12 @@ static void scsi_scan_channel(struct Scsi_Host *shost, unsigned int channel,
 				order_id = shost-&gt;max_id - id - 1;
 			else
 				order_id = id;
-			scsi_scan_target(&amp;shost-&gt;shost_gendev, channel, order_id, lun, rescan);
+			__scsi_scan_target(&amp;shost-&gt;shost_gendev, channel,
+					order_id, lun, rescan);
 		}
 	else
-		scsi_scan_target(&amp;shost-&gt;shost_gendev, channel, id, lun, rescan);
+		__scsi_scan_target(&amp;shost-&gt;shost_gendev, channel,
+				id, lun, rescan);
 }
 
 int scsi_scan_host_selected(struct Scsi_Host *shost, unsigned int channel,
@@ -1484,12 +1492,15 @@ void scsi_forget_host(struct Scsi_Host *shost)
  */
 struct scsi_device *scsi_get_host_dev(struct Scsi_Host *shost)
 {
-	struct scsi_device *sdev;
+	struct scsi_device *sdev = NULL;
 	struct scsi_target *starget;
 
+	down(&amp;shost-&gt;scan_mutex);
+	if (!scsi_host_scan_allowed(shost))
+		goto out;
 	starget = scsi_alloc_target(&amp;shost-&gt;shost_gendev, 0, shost-&gt;this_id);
 	if (!starget)
-		return NULL;
+		goto out;
 
 	sdev = scsi_alloc_sdev(starget, 0, NULL);
 	if (sdev) {
@@ -1497,6 +1508,8 @@ struct scsi_device *scsi_get_host_dev(struct Scsi_Host *shost)
 		sdev-&gt;borken = 0;
 	}
 	put_device(&amp;starget-&gt;dev);
+ out:
+	up(&amp;shost-&gt;scan_mutex);
 	return sdev;
 }
 EXPORT_SYMBOL(scsi_get_host_dev);</pre><hr><pre>commit 3b4d7f79164853e10342d707e32307e0c8054982
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Aug 11 15:50:32 2005 -0400

    [PATCH] USB: Support unbinding of the usb_generic driver
    
    This patch (as556) adds support for unbinding the usb_generic "driver".
    That driver only binds to USB devices, as opposed to interfaces, and it
    does nothing much besides marking which struct device's go with an
    overall USB device plus providing suspend/resume methods.  Now that
    users can unbind drivers at will using the sysfs "unbind" attribute, we
    need a rational way of dealing with USB devices that are no longer under
    full control of the USB stack.  The patch handles this by unconfiguring
    the device, thereby removing all the interfaces and their associated
    drivers and children.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index 109f7558167a..087af73a59dd 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -65,6 +65,16 @@ static int generic_probe (struct device *dev)
 }
 static int generic_remove (struct device *dev)
 {
+	struct usb_device *udev = to_usb_device(dev);
+
+	/* if this is only an unbind, not a physical disconnect, then
+	 * unconfigure the device */
+	if (udev-&gt;state == USB_STATE_CONFIGURED)
+		usb_set_configuration(udev, 0);
+
+	/* in case the call failed or the device was suspended */
+	if (udev-&gt;state &gt;= USB_STATE_CONFIGURED)
+		usb_disable_device(udev, 0);
 	return 0;
 }
 </pre><hr><pre>commit 3ea15966ed59f2bc20928c7b0496b4585f6de206
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Aug 11 10:15:39 2005 -0400

    [PATCH] USB: Add timeout to usb_lock_device_for_reset
    
    This patch (as555) modifies the already-awkward
    usb_lock_device_for_reset routine in usbcore by adding a timeout.  The
    whole point of the routine is that the caller wants to acquire some
    semaphores in the wrong order; protecting against the possibility of
    deadlock by timing out seems only prudent.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index bc966dbc6021..109f7558167a 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -912,7 +912,7 @@ int usb_trylock_device(struct usb_device *udev)
  * is neither BINDING nor BOUND.  Rather than sleeping to wait for the
  * lock, the routine polls repeatedly.  This is to prevent deadlock with
  * disconnect; in some drivers (such as usb-storage) the disconnect()
- * callback will block waiting for a device reset to complete.
+ * or suspend() method will block waiting for a device reset to complete.
  *
  * Returns a negative error code for failure, otherwise 1 or 0 to indicate
  * that the device will or will not have to be unlocked.  (0 can be
@@ -922,6 +922,8 @@ int usb_trylock_device(struct usb_device *udev)
 int usb_lock_device_for_reset(struct usb_device *udev,
 		struct usb_interface *iface)
 {
+	unsigned long jiffies_expire = jiffies + HZ;
+
 	if (udev-&gt;state == USB_STATE_NOTATTACHED)
 		return -ENODEV;
 	if (udev-&gt;state == USB_STATE_SUSPENDED)
@@ -938,6 +940,12 @@ int usb_lock_device_for_reset(struct usb_device *udev,
 	}
 
 	while (!usb_trylock_device(udev)) {
+
+		/* If we can't acquire the lock after waiting one second,
+		 * we're probably deadlocked */
+		if (time_after(jiffies, jiffies_expire))
+			return -EBUSY;
+
 		msleep(15);
 		if (udev-&gt;state == USB_STATE_NOTATTACHED)
 			return -ENODEV;</pre><hr><pre>commit bf193d3cd2a3b73f2df74f57106114867946c09c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 10 17:12:31 2005 -0400

    [PATCH] USB: Disconnect children when unbinding the hub driver
    
    This patch (as554) makes the hub driver disconnect any child USB devices
    when it is unbound from a hub.  Normally this will never happen, but
    there are a few oddball ways to unbind the hub driver while leaving the
    children intact.  For example, the new "unbind" sysfs attribute can be
    used for this purpose.
    
    Given that unbinding hubs with children is now safe, the patch also
    removes the code that prevented people from doing so using usbfs.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 56c082f34927..b4265aa7d45e 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -1238,7 +1238,6 @@ static int proc_ioctl (struct dev_state *ps, void __user *arg)
 	int			retval = 0;
 	struct usb_interface    *intf = NULL;
 	struct usb_driver       *driver = NULL;
-	int			i;
 
 	/* get input parameters and alloc buffer */
 	if (copy_from_user(&amp;ctrl, arg, sizeof (ctrl)))
@@ -1270,15 +1269,6 @@ static int proc_ioctl (struct dev_state *ps, void __user *arg)
 	/* disconnect kernel driver from interface */
 	case USBDEVFS_DISCONNECT:
 
-		/* don't allow the user to unbind the hub driver from
-		 * a hub with children to manage */
-		for (i = 0; i &lt; ps-&gt;dev-&gt;maxchild; ++i) {
-			if (ps-&gt;dev-&gt;children[i])
-				retval = -EBUSY;
-		}
-		if (retval)
-			break;
-
 		down_write(&amp;usb_bus_type.subsys.rwsem);
 		if (intf-&gt;dev.driver) {
 			driver = to_usb_driver(intf-&gt;dev.driver);
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 4a4b41f2665a..9f54e8330f78 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -729,10 +729,29 @@ static int hub_configure(struct usb_hub *hub,
 
 static unsigned highspeed_hubs;
 
+/* Called after the hub driver is unbound from a hub with children */
+static void hub_remove_children_work(void *__hub)
+{
+	struct usb_hub		*hub = __hub;
+	struct usb_device	*hdev = hub-&gt;hdev;
+	int			i;
+
+	kfree(hub);
+
+	usb_lock_device(hdev);
+	for (i = 0; i &lt; hdev-&gt;maxchild; ++i) {
+		if (hdev-&gt;children[i])
+			usb_disconnect(&amp;hdev-&gt;children[i]);
+	}
+	usb_unlock_device(hdev);
+	usb_put_dev(hdev);
+}
+
 static void hub_disconnect(struct usb_interface *intf)
 {
 	struct usb_hub *hub = usb_get_intfdata (intf);
 	struct usb_device *hdev;
+	int n, port1;
 
 	usb_set_intfdata (intf, NULL);
 	hdev = hub-&gt;hdev;
@@ -760,8 +779,27 @@ static void hub_disconnect(struct usb_interface *intf)
 		hub-&gt;buffer = NULL;
 	}
 
-	/* Free the memory */
-	kfree(hub);
+	/* If there are any children then this is an unbind only, not a
+	 * physical disconnection.  The active ports must be disabled
+	 * and later on we must call usb_disconnect().  We can't call
+	 * it now because we may not hold the hub's device lock.
+	 */
+	n = 0;
+	for (port1 = 1; port1 &lt;= hdev-&gt;maxchild; ++port1) {
+		if (hdev-&gt;children[port1 - 1]) {
+			++n;
+			hub_port_disable(hub, port1, 1);
+		}
+	}
+
+	if (n == 0)
+		kfree(hub);
+	else {
+		/* Reuse the hub-&gt;leds work_struct for our own purposes */
+		INIT_WORK(&amp;hub-&gt;leds, hub_remove_children_work, hub);
+		schedule_work(&amp;hub-&gt;leds);
+		usb_get_dev(hdev);
+	}
 }
 
 static int hub_probe(struct usb_interface *intf, const struct usb_device_id *id)</pre><hr><pre>commit 8b28c7526a302bbfa618f7eab4ef961edd68c9a0
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 10 17:04:13 2005 -0400

    [PATCH] USB: Code motion in the hub driver
    
    This patch (as553) merely moves some code and deletes an unneeded test in
    the hub driver.  This is in preparation for the patch that follows.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index a220a5e7f4a5..4a4b41f2665a 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -492,6 +492,23 @@ static int hub_hub_status(struct usb_hub *hub,
 	return ret;
 }
 
+static int hub_port_disable(struct usb_hub *hub, int port1, int set_state)
+{
+	struct usb_device *hdev = hub-&gt;hdev;
+	int ret;
+
+	if (hdev-&gt;children[port1-1] &amp;&amp; set_state) {
+		usb_set_device_state(hdev-&gt;children[port1-1],
+				USB_STATE_NOTATTACHED);
+	}
+	ret = clear_port_feature(hdev, port1, USB_PORT_FEAT_ENABLE);
+	if (ret)
+		dev_err(hub-&gt;intfdev, "cannot disable port %d (err = %d)\n",
+			port1, ret);
+
+	return ret;
+}
+
 static int hub_configure(struct usb_hub *hub,
 	struct usb_endpoint_descriptor *endpoint)
 {
@@ -717,15 +734,12 @@ static void hub_disconnect(struct usb_interface *intf)
 	struct usb_hub *hub = usb_get_intfdata (intf);
 	struct usb_device *hdev;
 
-	if (!hub)
-		return;
+	usb_set_intfdata (intf, NULL);
 	hdev = hub-&gt;hdev;
 
 	if (hdev-&gt;speed == USB_SPEED_HIGH)
 		highspeed_hubs--;
 
-	usb_set_intfdata (intf, NULL);
-
 	hub_quiesce(hub);
 	usb_free_urb(hub-&gt;urb);
 	hub-&gt;urb = NULL;
@@ -1430,23 +1444,6 @@ static int hub_port_reset(struct usb_hub *hub, int port1,
 	return status;
 }
 
-static int hub_port_disable(struct usb_hub *hub, int port1, int set_state)
-{
-	struct usb_device *hdev = hub-&gt;hdev;
-	int ret;
-
-	if (hdev-&gt;children[port1-1] &amp;&amp; set_state) {
-		usb_set_device_state(hdev-&gt;children[port1-1],
-				USB_STATE_NOTATTACHED);
-	}
-	ret = clear_port_feature(hdev, port1, USB_PORT_FEAT_ENABLE);
-	if (ret)
-		dev_err(hub-&gt;intfdev, "cannot disable port %d (err = %d)\n",
-			port1, ret);
-
-	return ret;
-}
-
 /*
  * Disable a port and mark a logical connnect-change event, so that some
  * time later khubd will disconnect() any existing usb_device on the port</pre><hr><pre>commit b375a0495fd622037560c73c05f23ae6f127bb0c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jul 29 16:11:07 2005 -0400

    [PATCH] USB: URB_ASYNC_UNLINK flag removed from the kernel
    
    29 July 2005, Cambridge, MA:
    
    This afternoon Alan Stern submitted a patch to remove the URB_ASYNC_UNLINK
    flag from the Linux kernel.  Mr. Stern explained, "This flag is a relic
    from an earlier, less-well-designed system.  For over a year it hasn't
    been used for anything other than printing warning messages."
    
    An anonymous spokesman for the Linux kernel development community
    commented, "This is exactly the sort of thing we see happening all the
    time.  As the kernel evolves, support for old techniques and old code can
    be jettisoned and replaced by newer, better approaches.  Proprietary
    operating systems do not have the freedom or flexibility to change so
    quickly."
    
    Mr. Stern, a staff member at Harvard University's Rowland Institute who
    works on Linux only as a hobby, noted that the patch (labelled as548) did
    not update two files, keyspan.c and option.c, in the USB drivers' "serial"
    subdirectory.  "Those files need more extensive changes," he remarked.
    "They examine the status field of several URBs at times when they're not
    supposed to.  That will need to be fixed before the URB_ASYNC_UNLINK flag
    is removed."
    
    Greg Kroah-Hartman, the kernel maintainer responsible for overseeing all
    of Linux's USB drivers, did not respond to our inquiries or return our
    calls.  His only comment was "Applied, thanks."
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/block/ub.c b/drivers/block/ub.c
index 57d3279a8815..aa0bf7ee008d 100644
--- a/drivers/block/ub.c
+++ b/drivers/block/ub.c
@@ -1010,7 +1010,7 @@ static int ub_scsi_cmd_start(struct ub_dev *sc, struct ub_scsi_cmd *cmd)
 	sc-&gt;last_pipe = sc-&gt;send_bulk_pipe;
 	usb_fill_bulk_urb(&amp;sc-&gt;work_urb, sc-&gt;dev, sc-&gt;send_bulk_pipe,
 	    bcb, US_BULK_CB_WRAP_LEN, ub_urb_complete, sc);
-	sc-&gt;work_urb.transfer_flags = URB_ASYNC_UNLINK;
+	sc-&gt;work_urb.transfer_flags = 0;
 
 	/* Fill what we shouldn't be filling, because usb-storage did so. */
 	sc-&gt;work_urb.actual_length = 0;
@@ -1395,7 +1395,7 @@ static void ub_data_start(struct ub_dev *sc, struct ub_scsi_cmd *cmd)
 	usb_fill_bulk_urb(&amp;sc-&gt;work_urb, sc-&gt;dev, pipe,
 	    page_address(sg-&gt;page) + sg-&gt;offset, sg-&gt;length,
 	    ub_urb_complete, sc);
-	sc-&gt;work_urb.transfer_flags = URB_ASYNC_UNLINK;
+	sc-&gt;work_urb.transfer_flags = 0;
 	sc-&gt;work_urb.actual_length = 0;
 	sc-&gt;work_urb.error_count = 0;
 	sc-&gt;work_urb.status = 0;
@@ -1442,7 +1442,7 @@ static int __ub_state_stat(struct ub_dev *sc, struct ub_scsi_cmd *cmd)
 	sc-&gt;last_pipe = sc-&gt;recv_bulk_pipe;
 	usb_fill_bulk_urb(&amp;sc-&gt;work_urb, sc-&gt;dev, sc-&gt;recv_bulk_pipe,
 	    &amp;sc-&gt;work_bcs, US_BULK_CS_WRAP_LEN, ub_urb_complete, sc);
-	sc-&gt;work_urb.transfer_flags = URB_ASYNC_UNLINK;
+	sc-&gt;work_urb.transfer_flags = 0;
 	sc-&gt;work_urb.actual_length = 0;
 	sc-&gt;work_urb.error_count = 0;
 	sc-&gt;work_urb.status = 0;
@@ -1563,7 +1563,7 @@ static int ub_submit_clear_stall(struct ub_dev *sc, struct ub_scsi_cmd *cmd,
 
 	usb_fill_control_urb(&amp;sc-&gt;work_urb, sc-&gt;dev, sc-&gt;send_ctrl_pipe,
 	    (unsigned char*) cr, NULL, 0, ub_urb_complete, sc);
-	sc-&gt;work_urb.transfer_flags = URB_ASYNC_UNLINK;
+	sc-&gt;work_urb.transfer_flags = 0;
 	sc-&gt;work_urb.actual_length = 0;
 	sc-&gt;work_urb.error_count = 0;
 	sc-&gt;work_urb.status = 0;
diff --git a/drivers/net/irda/irda-usb.c b/drivers/net/irda/irda-usb.c
index 46e0022d3258..6c766fdc51a6 100644
--- a/drivers/net/irda/irda-usb.c
+++ b/drivers/net/irda/irda-usb.c
@@ -267,7 +267,7 @@ static void irda_usb_change_speed_xbofs(struct irda_usb_cb *self)
                       frame, IRDA_USB_SPEED_MTU,
                       speed_bulk_callback, self);
 	urb-&gt;transfer_buffer_length = USB_IRDA_HEADER;
-	urb-&gt;transfer_flags = URB_ASYNC_UNLINK;
+	urb-&gt;transfer_flags = 0;
 
 	/* Irq disabled -&gt; GFP_ATOMIC */
 	if ((ret = usb_submit_urb(urb, GFP_ATOMIC))) {
@@ -401,15 +401,12 @@ static int irda_usb_hard_xmit(struct sk_buff *skb, struct net_device *netdev)
                       skb-&gt;data, IRDA_SKB_MAX_MTU,
                       write_bulk_callback, skb);
 	urb-&gt;transfer_buffer_length = skb-&gt;len;
-	/* Note : unlink *must* be Asynchronous because of the code in 
-	 * irda_usb_net_timeout() -&gt; call in irq - Jean II */
-	urb-&gt;transfer_flags = URB_ASYNC_UNLINK;
 	/* This flag (URB_ZERO_PACKET) indicates that what we send is not
 	 * a continuous stream of data but separate packets.
 	 * In this case, the USB layer will insert an empty USB frame (TD)
 	 * after each of our packets that is exact multiple of the frame size.
 	 * This is how the dongle will detect the end of packet - Jean II */
-	urb-&gt;transfer_flags |= URB_ZERO_PACKET;
+	urb-&gt;transfer_flags = URB_ZERO_PACKET;
 
 	/* Generate min turn time. FIXME: can we do better than this? */
 	/* Trying to a turnaround time at this level is trying to measure
@@ -630,8 +627,6 @@ static void irda_usb_net_timeout(struct net_device *netdev)
 			 * in completion handler, because urb-&gt;status will
 			 * be -ENOENT. We will fix that at the next watchdog,
 			 * leaving more time to USB to recover...
-			 * Also, we are in interrupt, so we need to have
-			 * URB_ASYNC_UNLINK to work properly...
 			 * Jean II */
 			done = 1;
 			break;
@@ -1008,9 +1003,7 @@ static int irda_usb_net_close(struct net_device *netdev)
 		}
 	}
 	/* Cancel Tx and speed URB - need to be synchronous to avoid races */
-	self-&gt;tx_urb-&gt;transfer_flags &amp;= ~URB_ASYNC_UNLINK;
 	usb_kill_urb(self-&gt;tx_urb);
-	self-&gt;speed_urb-&gt;transfer_flags &amp;= ~URB_ASYNC_UNLINK;
 	usb_kill_urb(self-&gt;speed_urb);
 
 	/* Stop and remove instance of IrLAP */
@@ -1521,9 +1514,7 @@ static void irda_usb_disconnect(struct usb_interface *intf)
 			usb_kill_urb(self-&gt;rx_urb[i]);
 		/* Cancel Tx and speed URB.
 		 * Toggle flags to make sure it's synchronous. */
-		self-&gt;tx_urb-&gt;transfer_flags &amp;= ~URB_ASYNC_UNLINK;
 		usb_kill_urb(self-&gt;tx_urb);
-		self-&gt;speed_urb-&gt;transfer_flags &amp;= ~URB_ASYNC_UNLINK;
 		usb_kill_urb(self-&gt;speed_urb);
 	}
 
diff --git a/drivers/usb/atm/cxacru.c b/drivers/usb/atm/cxacru.c
index 8e184e2641cb..79861ee12a29 100644
--- a/drivers/usb/atm/cxacru.c
+++ b/drivers/usb/atm/cxacru.c
@@ -715,13 +715,11 @@ static int cxacru_bind(struct usbatm_data *usbatm_instance,
 			usb_dev, usb_rcvintpipe(usb_dev, CXACRU_EP_CMD),
 			instance-&gt;rcv_buf, PAGE_SIZE,
 			cxacru_blocking_completion, &amp;instance-&gt;rcv_done, 1);
-	instance-&gt;rcv_urb-&gt;transfer_flags |= URB_ASYNC_UNLINK;
 
 	usb_fill_int_urb(instance-&gt;snd_urb,
 			usb_dev, usb_sndintpipe(usb_dev, CXACRU_EP_CMD),
 			instance-&gt;snd_buf, PAGE_SIZE,
 			cxacru_blocking_completion, &amp;instance-&gt;snd_done, 4);
-	instance-&gt;snd_urb-&gt;transfer_flags |= URB_ASYNC_UNLINK;
 
 	init_MUTEX(&amp;instance-&gt;cm_serialize);
 
diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 88d1b376f67c..74197249c245 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -48,7 +48,6 @@ static int usb_start_wait_urb(struct urb *urb, int timeout, int* actual_length)
 
 	init_completion(&amp;done); 	
 	urb-&gt;context = &amp;done;
-	urb-&gt;transfer_flags |= URB_ASYNC_UNLINK;
 	urb-&gt;actual_length = 0;
 	status = usb_submit_urb(urb, GFP_NOIO);
 
@@ -357,8 +356,7 @@ int usb_sg_init (
 	if (!io-&gt;urbs)
 		goto nomem;
 
-	urb_flags = URB_ASYNC_UNLINK | URB_NO_TRANSFER_DMA_MAP
-			| URB_NO_INTERRUPT;
+	urb_flags = URB_NO_TRANSFER_DMA_MAP | URB_NO_INTERRUPT;
 	if (usb_pipein (pipe))
 		urb_flags |= URB_SHORT_NOT_OK;
 
diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index c0feee25ff0a..c846fefb7386 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -309,9 +309,8 @@ int usb_submit_urb(struct urb *urb, unsigned mem_flags)
 	unsigned int	allowed;
 
 	/* enforce simple/standard policy */
-	allowed = URB_ASYNC_UNLINK;	// affects later unlinks
-	allowed |= (URB_NO_TRANSFER_DMA_MAP | URB_NO_SETUP_DMA_MAP);
-	allowed |= URB_NO_INTERRUPT;
+	allowed = (URB_NO_TRANSFER_DMA_MAP | URB_NO_SETUP_DMA_MAP |
+			URB_NO_INTERRUPT);
 	switch (temp) {
 	case PIPE_BULK:
 		if (is_out)
@@ -400,14 +399,8 @@ int usb_submit_urb(struct urb *urb, unsigned mem_flags)
  * canceled (rather than any other code) and will quickly be removed
  * from host controller data structures.
  *
- * In the past, clearing the URB_ASYNC_UNLINK transfer flag for the
- * URB indicated that the request was synchronous.  This usage is now
- * deprecated; if the flag is clear the call will be forwarded to
- * usb_kill_urb() and the return value will be 0.  In the future, drivers
- * should call usb_kill_urb() directly for synchronous unlinking.
- *
- * When the URB_ASYNC_UNLINK transfer flag for the URB is set, this
- * request is asynchronous.  Success is indicated by returning -EINPROGRESS,
+ * This request is always asynchronous.
+ * Success is indicated by returning -EINPROGRESS,
  * at which time the URB will normally have been unlinked but not yet
  * given back to the device driver.  When it is called, the completion
  * function will see urb-&gt;status == -ECONNRESET.  Failure is indicated
@@ -453,17 +446,6 @@ int usb_unlink_urb(struct urb *urb)
 {
 	if (!urb)
 		return -EINVAL;
-	if (!(urb-&gt;transfer_flags &amp; URB_ASYNC_UNLINK)) {
-#ifdef CONFIG_DEBUG_KERNEL
-		if (printk_ratelimit()) {
-			printk(KERN_NOTICE "usb_unlink_urb() is deprecated for "
-				"synchronous unlinks.  Use usb_kill_urb() instead.\n");
-			WARN_ON(1);
-		}
-#endif
-		usb_kill_urb(urb);
-		return 0;
-	}
 	if (!(urb-&gt;dev &amp;&amp; urb-&gt;dev-&gt;bus &amp;&amp; urb-&gt;dev-&gt;bus-&gt;op))
 		return -ENODEV;
 	return urb-&gt;dev-&gt;bus-&gt;op-&gt;unlink_urb(urb, -ECONNRESET);
diff --git a/drivers/usb/input/hid-core.c b/drivers/usb/input/hid-core.c
index 719c0316cc39..1ab95d24c5e2 100644
--- a/drivers/usb/input/hid-core.c
+++ b/drivers/usb/input/hid-core.c
@@ -1688,7 +1688,7 @@ static struct hid_device *usb_hid_configure(struct usb_interface *intf)
 			usb_fill_int_urb(hid-&gt;urbin, dev, pipe, hid-&gt;inbuf, 0,
 					 hid_irq_in, hid, interval);
 			hid-&gt;urbin-&gt;transfer_dma = hid-&gt;inbuf_dma;
-			hid-&gt;urbin-&gt;transfer_flags |=(URB_NO_TRANSFER_DMA_MAP | URB_ASYNC_UNLINK);
+			hid-&gt;urbin-&gt;transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
 		} else {
 			if (hid-&gt;urbout)
 				continue;
@@ -1698,7 +1698,7 @@ static struct hid_device *usb_hid_configure(struct usb_interface *intf)
 			usb_fill_int_urb(hid-&gt;urbout, dev, pipe, hid-&gt;outbuf, 0,
 					 hid_irq_out, hid, interval);
 			hid-&gt;urbout-&gt;transfer_dma = hid-&gt;outbuf_dma;
-			hid-&gt;urbout-&gt;transfer_flags |= (URB_NO_TRANSFER_DMA_MAP | URB_ASYNC_UNLINK);
+			hid-&gt;urbout-&gt;transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
 		}
 	}
 
@@ -1750,7 +1750,7 @@ static struct hid_device *usb_hid_configure(struct usb_interface *intf)
 			     hid-&gt;ctrlbuf, 1, hid_ctrl, hid);
 	hid-&gt;urbctrl-&gt;setup_dma = hid-&gt;cr_dma;
 	hid-&gt;urbctrl-&gt;transfer_dma = hid-&gt;ctrlbuf_dma;
-	hid-&gt;urbctrl-&gt;transfer_flags |= (URB_NO_TRANSFER_DMA_MAP | URB_NO_SETUP_DMA_MAP | URB_ASYNC_UNLINK);
+	hid-&gt;urbctrl-&gt;transfer_flags |= (URB_NO_TRANSFER_DMA_MAP | URB_NO_SETUP_DMA_MAP);
 
 	return hid;
 
diff --git a/drivers/usb/misc/auerswald.c b/drivers/usb/misc/auerswald.c
index 6f7994f5a714..ae4681f9f0ea 100644
--- a/drivers/usb/misc/auerswald.c
+++ b/drivers/usb/misc/auerswald.c
@@ -426,7 +426,7 @@ static int auerchain_submit_urb (pauerchain_t acp, struct urb * urb)
 
 /* cancel an urb which is submitted to the chain
    the result is 0 if the urb is cancelled, or -EINPROGRESS if
-   URB_ASYNC_UNLINK is set and the function is successfully started.
+   the function is successfully started.
 */
 static int auerchain_unlink_urb (pauerchain_t acp, struct urb * urb)
 {
@@ -515,7 +515,6 @@ static void auerchain_unlink_all (pauerchain_t acp)
         acep = acp-&gt;active;
         if (acep) {
                 urbp = acep-&gt;urbp;
-                urbp-&gt;transfer_flags &amp;= ~URB_ASYNC_UNLINK;
                 dbg ("unlink active urb");
                 usb_kill_urb (urbp);
         }
diff --git a/drivers/usb/misc/sisusbvga/sisusb.c b/drivers/usb/misc/sisusbvga/sisusb.c
index 2fd12264fd53..d63ce6c030f3 100644
--- a/drivers/usb/misc/sisusbvga/sisusb.c
+++ b/drivers/usb/misc/sisusbvga/sisusb.c
@@ -229,7 +229,7 @@ sisusb_bulkout_msg(struct sisusb_usb_data *sisusb, int index, unsigned int pipe,
 	usb_fill_bulk_urb(urb, sisusb-&gt;sisusb_dev, pipe, data, len,
 		sisusb_bulk_completeout, &amp;sisusb-&gt;urbout_context[index]);
 
-	urb-&gt;transfer_flags |= (tflags | URB_ASYNC_UNLINK);
+	urb-&gt;transfer_flags |= tflags;
 	urb-&gt;actual_length = 0;
 
 	if ((urb-&gt;transfer_dma = transfer_dma))
@@ -295,7 +295,7 @@ sisusb_bulkin_msg(struct sisusb_usb_data *sisusb, unsigned int pipe, void *data,
 	usb_fill_bulk_urb(urb, sisusb-&gt;sisusb_dev, pipe, data, len,
 			sisusb_bulk_completein, sisusb);
 
-	urb-&gt;transfer_flags |= (tflags | URB_ASYNC_UNLINK);
+	urb-&gt;transfer_flags |= tflags;
 	urb-&gt;actual_length = 0;
 
 	if ((urb-&gt;transfer_dma = transfer_dma))
diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index fd7fb98e4b20..54799eb0bc60 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -986,7 +986,6 @@ test_ctrl_queue (struct usbtest_dev *dev, struct usbtest_param *param)
 
 		u-&gt;context = &amp;context;
 		u-&gt;complete = ctrl_complete;
-		u-&gt;transfer_flags |= URB_ASYNC_UNLINK;
 	}
 
 	/* queue the urbs */
@@ -1052,7 +1051,6 @@ static int unlink1 (struct usbtest_dev *dev, int pipe, int size, int async)
 	urb = simple_alloc_urb (testdev_to_usbdev (dev), pipe, size);
 	if (!urb)
 		return -ENOMEM;
-	urb-&gt;transfer_flags |= URB_ASYNC_UNLINK;
 	urb-&gt;context = &amp;completion;
 	urb-&gt;complete = unlink1_callback;
 
diff --git a/drivers/usb/net/catc.c b/drivers/usb/net/catc.c
index c8be912f24e1..37ef365a2472 100644
--- a/drivers/usb/net/catc.c
+++ b/drivers/usb/net/catc.c
@@ -383,7 +383,6 @@ static void catc_tx_done(struct urb *urb, struct pt_regs *regs)
 
 	if (urb-&gt;status == -ECONNRESET) {
 		dbg("Tx Reset.");
-		urb-&gt;transfer_flags &amp;= ~URB_ASYNC_UNLINK;
 		urb-&gt;status = 0;
 		catc-&gt;netdev-&gt;trans_start = jiffies;
 		catc-&gt;stats.tx_errors++;
@@ -445,7 +444,6 @@ static void catc_tx_timeout(struct net_device *netdev)
 	struct catc *catc = netdev_priv(netdev);
 
 	warn("Transmit timed out.");
-	catc-&gt;tx_urb-&gt;transfer_flags |= URB_ASYNC_UNLINK;
 	usb_unlink_urb(catc-&gt;tx_urb);
 }
 
diff --git a/drivers/usb/net/kaweth.c b/drivers/usb/net/kaweth.c
index 7ffa99b9760f..e04b0ce3611a 100644
--- a/drivers/usb/net/kaweth.c
+++ b/drivers/usb/net/kaweth.c
@@ -787,7 +787,6 @@ static int kaweth_start_xmit(struct sk_buff *skb, struct net_device *net)
 		      kaweth_usb_transmit_complete,
 		      kaweth);
 	kaweth-&gt;end = 0;
-	kaweth-&gt;tx_urb-&gt;transfer_flags |= URB_ASYNC_UNLINK;
 
 	if((res = usb_submit_urb(kaweth-&gt;tx_urb, GFP_ATOMIC)))
 	{
diff --git a/drivers/usb/net/pegasus.c b/drivers/usb/net/pegasus.c
index fcd6d3ccef44..7484d34780fc 100644
--- a/drivers/usb/net/pegasus.c
+++ b/drivers/usb/net/pegasus.c
@@ -825,7 +825,6 @@ static void pegasus_tx_timeout(struct net_device *net)
 	pegasus_t *pegasus = netdev_priv(net);
 	if (netif_msg_timer(pegasus))
 		printk(KERN_WARNING "%s: tx timeout\n", net-&gt;name);
-	pegasus-&gt;tx_urb-&gt;transfer_flags |= URB_ASYNC_UNLINK;
 	usb_unlink_urb(pegasus-&gt;tx_urb);
 	pegasus-&gt;stats.tx_errors++;
 }
diff --git a/drivers/usb/net/rtl8150.c b/drivers/usb/net/rtl8150.c
index 59ab40ebb394..c3d4e3589e30 100644
--- a/drivers/usb/net/rtl8150.c
+++ b/drivers/usb/net/rtl8150.c
@@ -653,7 +653,6 @@ static void rtl8150_tx_timeout(struct net_device *netdev)
 {
 	rtl8150_t *dev = netdev_priv(netdev);
 	warn("%s: Tx timeout.", netdev-&gt;name);
-	dev-&gt;tx_urb-&gt;transfer_flags |= URB_ASYNC_UNLINK;
 	usb_unlink_urb(dev-&gt;tx_urb);
 	dev-&gt;stats.tx_errors++;
 }
diff --git a/drivers/usb/net/usbnet.c b/drivers/usb/net/usbnet.c
index 4682696450db..3c6eef4168e5 100644
--- a/drivers/usb/net/usbnet.c
+++ b/drivers/usb/net/usbnet.c
@@ -2987,7 +2987,6 @@ static void rx_submit (struct usbnet *dev, struct urb *urb, unsigned flags)
 
 	usb_fill_bulk_urb (urb, dev-&gt;udev, dev-&gt;in,
 		skb-&gt;data, size, rx_complete, skb);
-	urb-&gt;transfer_flags |= URB_ASYNC_UNLINK;
 
 	spin_lock_irqsave (&amp;dev-&gt;rxq.lock, lockflags);
 
@@ -3561,7 +3560,6 @@ static int usbnet_start_xmit (struct sk_buff *skb, struct net_device *net)
 
 	usb_fill_bulk_urb (urb, dev-&gt;udev, dev-&gt;out,
 			skb-&gt;data, skb-&gt;len, tx_complete, skb);
-	urb-&gt;transfer_flags |= URB_ASYNC_UNLINK;
 
 	/* don't assume the hardware handles USB_ZERO_PACKET
 	 * NOTE:  strictly conforming cdc-ether devices should expect
diff --git a/drivers/usb/net/zd1201.c b/drivers/usb/net/zd1201.c
index fc013978837e..c4e479ee926a 100644
--- a/drivers/usb/net/zd1201.c
+++ b/drivers/usb/net/zd1201.c
@@ -847,7 +847,6 @@ static void zd1201_tx_timeout(struct net_device *dev)
 		return;
 	dev_warn(&amp;zd-&gt;usb-&gt;dev, "%s: TX timeout, shooting down urb\n",
 	    dev-&gt;name);
-	zd-&gt;tx_urb-&gt;transfer_flags |= URB_ASYNC_UNLINK;
 	usb_unlink_urb(zd-&gt;tx_urb);
 	zd-&gt;stats.tx_errors++;
 	/* Restart the timeout to quiet the watchdog: */
diff --git a/drivers/usb/storage/transport.c b/drivers/usb/storage/transport.c
index e42875152c34..c1ba5301ebfc 100644
--- a/drivers/usb/storage/transport.c
+++ b/drivers/usb/storage/transport.c
@@ -96,8 +96,8 @@
  * or before the URB_ACTIVE bit was set.  If so, it's essential to cancel
  * the URB if it hasn't been cancelled already (i.e., if the URB_ACTIVE bit
  * is still set).  Either way, the function must then wait for the URB to
- * finish.  Note that because the URB_ASYNC_UNLINK flag is set, the URB can
- * still be in progress even after a call to usb_unlink_urb() returns.
+ * finish.  Note that the URB can still be in progress even after a call to
+ * usb_unlink_urb() returns.
  *
  * The idea is that (1) once the ABORTING or DISCONNECTING bit is set,
  * either the stop_transport() function or the submitting function
@@ -158,8 +158,7 @@ static int usb_stor_msg_common(struct us_data *us, int timeout)
 	 * hasn't been mapped for DMA.  Yes, this is clunky, but it's
 	 * easier than always having the caller tell us whether the
 	 * transfer buffer has already been mapped. */
-	us-&gt;current_urb-&gt;transfer_flags =
-			URB_ASYNC_UNLINK | URB_NO_SETUP_DMA_MAP;
+	us-&gt;current_urb-&gt;transfer_flags = URB_NO_SETUP_DMA_MAP;
 	if (us-&gt;current_urb-&gt;transfer_buffer == us-&gt;iobuf)
 		us-&gt;current_urb-&gt;transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
 	us-&gt;current_urb-&gt;transfer_dma = us-&gt;iobuf_dma;
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 434e35120c65..4dbe580f9335 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -616,7 +616,6 @@ extern int usb_disabled(void);
 #define URB_ISO_ASAP		0x0002	/* iso-only, urb-&gt;start_frame ignored */
 #define URB_NO_TRANSFER_DMA_MAP	0x0004	/* urb-&gt;transfer_dma valid on submit */
 #define URB_NO_SETUP_DMA_MAP	0x0008	/* urb-&gt;setup_dma valid on submit */
-#define URB_ASYNC_UNLINK	0x0010	/* usb_unlink_urb() returns asap */
 #define URB_NO_FSBR		0x0020	/* UHCI-specific */
 #define URB_ZERO_PACKET		0x0040	/* Finish bulk OUTs with short packet */
 #define URB_NO_INTERRUPT	0x0080	/* HINT: no non-error interrupt needed */
@@ -724,13 +723,7 @@ typedef void (*usb_complete_t)(struct urb *, struct pt_regs *);
  * Initialization:
  *
  * All URBs submitted must initialize the dev, pipe, transfer_flags (may be
- * zero), and complete fields.
- * The URB_ASYNC_UNLINK transfer flag affects later invocations of
- * the usb_unlink_urb() routine.  Note: Failure to set URB_ASYNC_UNLINK
- * with usb_unlink_urb() is deprecated.  For synchronous unlinks use
- * usb_kill_urb() instead.
- *
- * All URBs must also initialize 
+ * zero), and complete fields.  All URBs must also initialize
  * transfer_buffer and transfer_buffer_length.  They may provide the
  * URB_SHORT_NOT_OK transfer flag, indicating that short reads are
  * to be treated as errors; that flag is invalid for write requests.
diff --git a/sound/usb/usbaudio.c b/sound/usb/usbaudio.c
index 5aa5fe651a8a..bfbec5876659 100644
--- a/sound/usb/usbaudio.c
+++ b/sound/usb/usbaudio.c
@@ -735,10 +735,9 @@ static int deactivate_urbs(snd_usb_substream_t *subs, int force, int can_sleep)
 		if (test_bit(i, &amp;subs-&gt;active_mask)) {
 			if (! test_and_set_bit(i, &amp;subs-&gt;unlink_mask)) {
 				struct urb *u = subs-&gt;dataurb[i].urb;
-				if (async) {
-					u-&gt;transfer_flags |= URB_ASYNC_UNLINK;
+				if (async)
 					usb_unlink_urb(u);
-				} else
+				else
 					usb_kill_urb(u);
 			}
 		}
@@ -748,10 +747,9 @@ static int deactivate_urbs(snd_usb_substream_t *subs, int force, int can_sleep)
 			if (test_bit(i+16, &amp;subs-&gt;active_mask)) {
  				if (! test_and_set_bit(i+16, &amp;subs-&gt;unlink_mask)) {
 					struct urb *u = subs-&gt;syncurb[i].urb;
-					if (async) {
-						u-&gt;transfer_flags |= URB_ASYNC_UNLINK;
+					if (async)
 						usb_unlink_urb(u);
-					} else
+					else
 						usb_kill_urb(u);
 				}
 			}</pre><hr><pre>commit fad21bdf56a25e1cb3e92bba33349de368e8f0b0
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 10 15:15:57 2005 -0400

    [PATCH] USB: Fix regression in core/devio.c
    
    This patch (as551) fixes another little problem recently added to the
    USB core.  Someone didn't fix the type of the first argument to
    unregister_chrdev_region.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index d12bc5e84a1a..56c082f34927 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -76,6 +76,8 @@ MODULE_PARM_DESC (usbfs_snoop, "true to log all usbfs traffic");
 			dev_info( dev , format , ## arg);	\
 	} while (0)
 
+#define USB_DEVICE_DEV		MKDEV(USB_DEVICE_MAJOR, 0)
+
 
 #define	MAX_USBFS_BUFFER_SIZE	16384
 
@@ -1530,18 +1532,17 @@ int __init usbdev_init(void)
 {
 	int retval;
 
-	retval = register_chrdev_region(MKDEV(USB_DEVICE_MAJOR, 0),
-				        USB_DEVICE_MAX, "usb_device");
+	retval = register_chrdev_region(USB_DEVICE_DEV, USB_DEVICE_MAX,
+			"usb_device");
 	if (retval) {
 		err("unable to register minors for usb_device");
 		goto out;
 	}
 	cdev_init(&amp;usb_device_cdev, &amp;usbfs_device_file_operations);
-	retval = cdev_add(&amp;usb_device_cdev,
-			  MKDEV(USB_DEVICE_MAJOR, 0), USB_DEVICE_MAX);
+	retval = cdev_add(&amp;usb_device_cdev, USB_DEVICE_DEV, USB_DEVICE_MAX);
 	if (retval) {
 		err("unable to get usb_device major %d", USB_DEVICE_MAJOR);
-		unregister_chrdev_region(USB_DEVICE_MAJOR, USB_DEVICE_MAX);
+		unregister_chrdev_region(USB_DEVICE_DEV, USB_DEVICE_MAX);
 		goto out;
 	}
 	usb_device_class = class_create(THIS_MODULE, "usb_device");
@@ -1550,7 +1551,7 @@ int __init usbdev_init(void)
 		retval = PTR_ERR(usb_device_class);
 		usb_device_class = NULL;
 		cdev_del(&amp;usb_device_cdev);
-		unregister_chrdev_region(USB_DEVICE_MAJOR, USB_DEVICE_MAX);
+		unregister_chrdev_region(USB_DEVICE_DEV, USB_DEVICE_MAX);
 	}
 
 out:
@@ -1561,6 +1562,6 @@ void usbdev_cleanup(void)
 {
 	class_destroy(usb_device_class);
 	cdev_del(&amp;usb_device_cdev);
-	unregister_chrdev_region(USB_DEVICE_MAJOR, USB_DEVICE_MAX);
+	unregister_chrdev_region(USB_DEVICE_DEV, USB_DEVICE_MAX);
 }
 </pre><hr><pre>commit 11f3859b1e85dd408756c72e228cfb5aa7230c87
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 10 15:18:44 2005 -0400

    [PATCH] PCI: Fix regression in pci_enable_device_bars
    
    This patch (as552) fixes yet another small problem recently added.  If an
    attempt to put a PCI device back into D0 fails because the device doesn't
    support PCI PM, it shouldn't count as error.  Without this patch the UHCI
    controllers on my Intel motherboard don't work.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index afee2de3f323..3dcb83d7eb25 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -445,7 +445,7 @@ pci_enable_device_bars(struct pci_dev *dev, int bars)
 	int err;
 
 	err = pci_set_power_state(dev, PCI_D0);
-	if (err)
+	if (err &lt; 0 &amp;&amp; err != -EIO)
 		return err;
 	err = pcibios_enable_device(dev, bars);
 	if (err &lt; 0)</pre><hr><pre>commit 4451e472627881e3e2240b224f127c99be500f91
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jul 12 10:45:17 2005 -0400

    [SCSI] sd: pause in sd_spinup_disk for slow USB devices
    
    This patch adds a delay tailored for USB flash devices that are slow to
    initialize their firmware.  The symptom is a repeated Unit Attention with
    ASC=0x28 (Not Ready to Ready transition).  The patch will wait for up to 5
    seconds for such devices to become ready.  Normal devices won't send the
    repeated Unit Attention sense key and hence won't trigger the patch.
    
    This fixes a problem with James Roberts-Thomson's USB device, and I've
    seen several reports of other devices exhibiting the same symptoms --
    presumably they will be helped as well.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c
index 0410e1bf109a..41ba0809f791 100644
--- a/drivers/scsi/sd.c
+++ b/drivers/scsi/sd.c
@@ -984,7 +984,7 @@ static void
 sd_spinup_disk(struct scsi_disk *sdkp, char *diskname,
 	       struct scsi_request *SRpnt, unsigned char *buffer) {
 	unsigned char cmd[10];
-	unsigned long spintime_value = 0;
+	unsigned long spintime_expire = 0;
 	int retries, spintime;
 	unsigned int the_result;
 	struct scsi_sense_hdr sshdr;
@@ -1071,12 +1071,27 @@ sd_spinup_disk(struct scsi_disk *sdkp, char *diskname,
 				scsi_wait_req(SRpnt, (void *)cmd, 
 					      (void *) buffer, 0/*512*/, 
 					      SD_TIMEOUT, SD_MAX_RETRIES);
-				spintime_value = jiffies;
+				spintime_expire = jiffies + 100 * HZ;
+				spintime = 1;
 			}
-			spintime = 1;
 			/* Wait 1 second for next try */
 			msleep(1000);
 			printk(".");
+
+		/*
+		 * Wait for USB flash devices with slow firmware.
+		 * Yes, this sense key/ASC combination shouldn't
+		 * occur here.  It's characteristic of these devices.
+		 */
+		} else if (sense_valid &amp;&amp;
+				sshdr.sense_key == UNIT_ATTENTION &amp;&amp;
+				sshdr.asc == 0x28) {
+			if (!spintime) {
+				spintime_expire = jiffies + 5 * HZ;
+				spintime = 1;
+			}
+			/* Wait 1 second for next try */
+			msleep(1000);
 		} else {
 			/* we don't understand the sense code, so it's
 			 * probably pointless to loop */
@@ -1088,8 +1103,7 @@ sd_spinup_disk(struct scsi_disk *sdkp, char *diskname,
 			break;
 		}
 				
-	} while (spintime &amp;&amp;
-		 time_after(spintime_value + 100 * HZ, jiffies));
+	} while (spintime &amp;&amp; time_before_eq(jiffies, spintime_expire));
 
 	if (spintime) {
 		if (scsi_status_is_good(the_result))</pre>
    <div class="pagination">
        <a href='2_135.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><span>[136]</span><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_137.html'>Next&gt;&gt;</a>
    <div>
</body>
