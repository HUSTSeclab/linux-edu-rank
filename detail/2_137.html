<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_136.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><span>[137]</span><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_138.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit e47373ec1c9aab9ee134f4e2b8249957e9f4c7ef
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Mar 30 15:05:45 2005 -0500

    [SCSI] return success after retries in scsi_eh_tur
    
    The problem lies in the way the error handler uses TEST UNIT READY to
    tell whether error recovery has succeeded.  The scsi_eh_tur function
    gives up after one round of retrying; after that it decides that more
    error recovery is needed.
    
    However TUR is liable to report sense data indicating a retry is needed
    when in fact error recovery has succeeded.  A typical example might be
    SK=2, ASC=4, ASCQ=1 (Logical unit in process of becoming ready).  The mere
    fact that we were able to get a sensible reply to the TUR should indicate
    that the device is working well enough to stop error recovery.
    
    I ran across a case back in January where this happened.  A CD-ROM drive
    timed out the INQUIRY command, and a device reset fixed the blockage.
    But then the drive kept responding with 2/4/1 -- because it was spinning
    up I suppose -- until the error handler gave up and placed it offline.
    If the initial INQUIRY had received the 2/4/1 instead, everything would
    have worked okay.  It doesn't seem reasonable for things to fail just
    because the error handler had started running.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/scsi_error.c b/drivers/scsi/scsi_error.c
index e9c451ba71fc..688bce740786 100644
--- a/drivers/scsi/scsi_error.c
+++ b/drivers/scsi/scsi_error.c
@@ -776,9 +776,11 @@ static int scsi_eh_tur(struct scsi_cmnd *scmd)
 		__FUNCTION__, scmd, rtn));
 	if (rtn == SUCCESS)
 		return 0;
-	else if (rtn == NEEDS_RETRY)
+	else if (rtn == NEEDS_RETRY) {
 		if (retry_cnt--)
 			goto retry_tur;
+		return 0;
+	}
 	return 1;
 }
 </pre><hr><pre>commit 86d30741e480f40676c2173e1153368a4846da48
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jul 29 12:17:16 2005 -0700

    [PATCH] USB: Usbcore: Don't try to delete unregistered interfaces
    
    This patch handles a rarely-encountered failure mode in usbcore.  It's
    legal for device_add to fail (although now it happens even more rarely
    than before since failure to bind a driver is no longer fatal).  So when
    we destroy the interfaces in a configuration, we shouldn't try to delete
    ones which weren't successfully registered.  Also, failure to register an
    interface shouldn't be fatal either -- I think; you may disagree about
    this part of the patch.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index a428ef479bd7..88d1b376f67c 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -985,8 +985,10 @@ void usb_disable_device(struct usb_device *dev, int skip_ep0)
 		for (i = 0; i &lt; dev-&gt;actconfig-&gt;desc.bNumInterfaces; i++) {
 			struct usb_interface	*interface;
 
-			/* remove this interface */
+			/* remove this interface if it has been registered */
 			interface = dev-&gt;actconfig-&gt;interface[i];
+			if (!klist_node_attached(&amp;interface-&gt;dev.knode_bus))
+				continue;
 			dev_dbg (&amp;dev-&gt;dev, "unregistering interface %s\n",
 				interface-&gt;dev.bus_id);
 			usb_remove_sysfs_intf_files(interface);
@@ -1439,7 +1441,7 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 		}
 	}
 
-	return ret;
+	return 0;
 }
 
 // synchronous request completion model</pre><hr><pre>commit fe0410c7f43e133e156e54e3156392e800bedc21
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jul 29 12:16:58 2005 -0700

    [PATCH] USB: usbfs: Don't leak uninitialized data
    
    This patch fixes an information leak in the usbfs snoop facility:
    uninitialized data from __get_free_page can be returned to userspace and
    written to the system log.  It also improves the snoop output by printing
    the wLength value.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 787c27a63c51..f86bf1454e21 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -569,8 +569,11 @@ static int proc_control(struct dev_state *ps, void __user *arg)
 			free_page((unsigned long)tbuf);
 			return -EINVAL;
 		}
-		snoop(&amp;dev-&gt;dev, "control read: bRequest=%02x bRrequestType=%02x wValue=%04x wIndex=%04x\n", 
-			ctrl.bRequest, ctrl.bRequestType, ctrl.wValue, ctrl.wIndex);
+		snoop(&amp;dev-&gt;dev, "control read: bRequest=%02x "
+				"bRrequestType=%02x wValue=%04x "
+				"wIndex=%04x wLength=%04x\n",
+			ctrl.bRequest, ctrl.bRequestType, ctrl.wValue,
+				ctrl.wIndex, ctrl.wLength);
 
 		usb_unlock_device(dev);
 		i = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), ctrl.bRequest, ctrl.bRequestType,
@@ -579,11 +582,11 @@ static int proc_control(struct dev_state *ps, void __user *arg)
 		if ((i &gt; 0) &amp;&amp; ctrl.wLength) {
 			if (usbfs_snoop) {
 				dev_info(&amp;dev-&gt;dev, "control read: data ");
-				for (j = 0; j &lt; ctrl.wLength; ++j)
+				for (j = 0; j &lt; i; ++j)
 					printk ("%02x ", (unsigned char)(tbuf)[j]);
 				printk("\n");
 			}
-			if (copy_to_user(ctrl.data, tbuf, ctrl.wLength)) {
+			if (copy_to_user(ctrl.data, tbuf, i)) {
 				free_page((unsigned long)tbuf);
 				return -EFAULT;
 			}
@@ -595,8 +598,11 @@ static int proc_control(struct dev_state *ps, void __user *arg)
 				return -EFAULT;
 			}
 		}
-		snoop(&amp;dev-&gt;dev, "control write: bRequest=%02x bRrequestType=%02x wValue=%04x wIndex=%04x\n", 
-			ctrl.bRequest, ctrl.bRequestType, ctrl.wValue, ctrl.wIndex);
+		snoop(&amp;dev-&gt;dev, "control write: bRequest=%02x "
+				"bRrequestType=%02x wValue=%04x "
+				"wIndex=%04x wLength=%04x\n",
+			ctrl.bRequest, ctrl.bRequestType, ctrl.wValue,
+				ctrl.wIndex, ctrl.wLength);
 		if (usbfs_snoop) {
 			dev_info(&amp;dev-&gt;dev, "control write: data: ");
 			for (j = 0; j &lt; ctrl.wLength; ++j)</pre><hr><pre>commit b24b1033451fcc87087a692fc47ca45daebd51ac
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 27 11:43:46 2005 -0700

    [PATCH] scsi_scan: check return code from scsi_sysfs_add_sdev
    
    Adds a missing check for an error return code from scsi_sysfs_add_sdev.
    This resolves entry #4863 in the OSDL bugzilla.  Although in that bug
    report the failure occurred because of a confusion over scanning vs.
    rescanning, in general add_sdev can fail for a number of reasons (the
    simplest being insufficient memory) and the caller should cope properly.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c
index ad3a5b142468..2d3c4ac475f2 100644
--- a/drivers/scsi/scsi_scan.c
+++ b/drivers/scsi/scsi_scan.c
@@ -756,7 +756,8 @@ static int scsi_add_lun(struct scsi_device *sdev, char *inq_result, int *bflags)
 	 * register it and tell the rest of the kernel
 	 * about it.
 	 */
-	scsi_sysfs_add_sdev(sdev);
+	if (scsi_sysfs_add_sdev(sdev) != 0)
+		return SCSI_SCAN_NO_RESPONSE;
 
 	return SCSI_SCAN_LUN_PRESENT;
 }</pre><hr><pre>commit 0ed0c0c48c508578c30aa58f755ca0d692636906
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jun 15 15:49:48 2005 -0400

    [PATCH] USB: usbcore: inverted test for resuming interfaces
    
    This one-liner fixes a test for interfaces that are already resumed.
    
    It would be nice if this could get into 2.6.12, but it's not critical
    since it only affects people doing selective (runtime) suspend/resume.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 63ee3d97b6a9..32ff32181852 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1733,7 +1733,7 @@ static int finish_port_resume(struct usb_device *udev)
 			struct usb_driver	*driver;
 
 			intf = udev-&gt;actconfig-&gt;interface[i];
-			if (intf-&gt;dev.power.power_state == PMSG_SUSPEND)
+			if (intf-&gt;dev.power.power_state == PMSG_ON)
 				continue;
 			if (!intf-&gt;dev.driver) {
 				/* FIXME maybe force to alt 0 */</pre><hr><pre>commit e07fefa6b212f43c40fdbc1a62de690d91a4b617
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 31 16:33:21 2005 -0400

    [PATCH] USB UHCI: Detect invalid ports
    
    This patch changes the way uhci-hcd detects valid ports.  The
    specification doesn't mention any way to find out how many ports a
    controller has, so the driver has to use some heuristics, reading the port
    status and control register and deciding whether the value makes sense.
    With this patch the driver will recognize a typical failure mode (all bits
    set to one) for nonexistent ports and won't assume there are always at
    least 2 ports -- such an assumption seems silly if the heuristics have
    already shown that the ports don't exist.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index fdf54295da73..0d5d2545bf07 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -495,24 +495,24 @@ static int uhci_reset(struct usb_hcd *hcd)
 
 	/* The UHCI spec says devices must have 2 ports, and goes on to say
 	 * they may have more but gives no way to determine how many there
-	 * are.  However, according to the UHCI spec, Bit 7 of the port
+	 * are.  However according to the UHCI spec, Bit 7 of the port
 	 * status and control register is always set to 1.  So we try to
-	 * use this to our advantage.
+	 * use this to our advantage.  Another common failure mode when
+	 * a nonexistent register is addressed is to return all ones, so
+	 * we test for that also.
 	 */
 	for (port = 0; port &lt; (io_size - USBPORTSC1) / 2; port++) {
 		unsigned int portstatus;
 
 		portstatus = inw(uhci-&gt;io_addr + USBPORTSC1 + (port * 2));
-		if (!(portstatus &amp; 0x0080))
+		if (!(portstatus &amp; 0x0080) || portstatus == 0xffff)
 			break;
 	}
 	if (debug)
 		dev_info(uhci_dev(uhci), "detected %d ports\n", port);
 
-	/* Anything less than 2 or greater than 7 is weird,
-	 * so we'll ignore it.
-	 */
-	if (port &lt; 2 || port &gt; UHCI_RH_MAXCHILD) {
+	/* Anything greater than 7 is weird so we'll ignore it. */
+	if (port &gt; UHCI_RH_MAXCHILD) {
 		dev_info(uhci_dev(uhci), "port count misdetected? "
 				"forcing to 2 ports\n");
 		port = 2;</pre><hr><pre>commit 391eca9d8892a940ff8dbfee2ca78942e05c2d37
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 10 15:34:16 2005 -0400

    [PATCH] USB: dummy_hcd: add suspend/resume support
    
    This patch adds support to dummy_hcd for suspending and resuming the root
    hub and the emulated platform devices.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index c78c64ae87af..4d692670f288 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -65,7 +65,7 @@
 
 
 #define DRIVER_DESC	"USB Host+Gadget Emulator"
-#define DRIVER_VERSION	"17 Dec 2004"
+#define DRIVER_VERSION	"02 May 2005"
 
 static const char	driver_name [] = "dummy_hcd";
 static const char	driver_desc [] = "USB Host+Gadget Emulator";
@@ -150,6 +150,13 @@ struct urbp {
 	struct list_head	urbp_list;
 };
 
+
+enum dummy_rh_state {
+	DUMMY_RH_RESET,
+	DUMMY_RH_SUSPENDED,
+	DUMMY_RH_RUNNING
+};
+
 struct dummy {
 	spinlock_t			lock;
 
@@ -163,6 +170,7 @@ struct dummy {
 	struct dummy_request		fifo_req;
 	u8				fifo_buf [FIFO_SIZE];
 	u16				devstatus;
+	unsigned			udc_suspended:1;
 	unsigned			pullup:1;
 	unsigned			active:1;
 	unsigned			old_active:1;
@@ -170,6 +178,7 @@ struct dummy {
 	/*
 	 * MASTER/HOST side support
 	 */
+	enum dummy_rh_state		rh_state;
 	struct timer_list		timer;
 	u32				port_status;
 	u32				old_status;
@@ -262,7 +271,9 @@ set_link_state (struct dummy *dum)
 	dum-&gt;active = 0;
 	if ((dum-&gt;port_status &amp; USB_PORT_STAT_POWER) == 0)
 		dum-&gt;port_status = 0;
-	else if (!dum-&gt;pullup) {
+
+	/* UDC suspend must cause a disconnect */
+	else if (!dum-&gt;pullup || dum-&gt;udc_suspended) {
 		dum-&gt;port_status &amp;= ~(USB_PORT_STAT_CONNECTION |
 					USB_PORT_STAT_ENABLE |
 					USB_PORT_STAT_LOW_SPEED |
@@ -276,7 +287,8 @@ set_link_state (struct dummy *dum)
 			dum-&gt;port_status |= (USB_PORT_STAT_C_CONNECTION &lt;&lt; 16);
 		if ((dum-&gt;port_status &amp; USB_PORT_STAT_ENABLE) == 0)
 			dum-&gt;port_status &amp;= ~USB_PORT_STAT_SUSPEND;
-		else if ((dum-&gt;port_status &amp; USB_PORT_STAT_SUSPEND) == 0)
+		else if ((dum-&gt;port_status &amp; USB_PORT_STAT_SUSPEND) == 0 &amp;&amp;
+				dum-&gt;rh_state != DUMMY_RH_SUSPENDED)
 			dum-&gt;active = 1;
 	}
 
@@ -675,11 +687,16 @@ static int dummy_wakeup (struct usb_gadget *_gadget)
 	struct dummy	*dum;
 
 	dum = gadget_to_dummy (_gadget);
-	if (!(dum-&gt;port_status &amp; USB_PORT_STAT_SUSPEND)
-			|| !(dum-&gt;devstatus &amp;
-				( (1 &lt;&lt; USB_DEVICE_B_HNP_ENABLE)
+	if (!(dum-&gt;devstatus &amp;	( (1 &lt;&lt; USB_DEVICE_B_HNP_ENABLE)
 				| (1 &lt;&lt; USB_DEVICE_REMOTE_WAKEUP))))
 		return -EINVAL;
+	if ((dum-&gt;port_status &amp; USB_PORT_STAT_CONNECTION) == 0)
+		return -ENOLINK;
+	if ((dum-&gt;port_status &amp; USB_PORT_STAT_SUSPEND) == 0 &amp;&amp;
+			 dum-&gt;rh_state != DUMMY_RH_SUSPENDED)
+		return -EIO;
+
+	/* FIXME: What if the root hub is suspended but the port isn't? */
 
 	/* hub notices our request, issues downstream resume, etc */
 	dum-&gt;resuming = 1;
@@ -917,11 +934,50 @@ static int dummy_udc_remove (struct device *dev)
 	return 0;
 }
 
+static int dummy_udc_suspend (struct device *dev, pm_message_t state,
+		u32 level)
+{
+	struct dummy	*dum = dev_get_drvdata(dev);
+
+	if (level != SUSPEND_DISABLE)
+		return 0;
+
+	dev_dbg (dev, "%s\n", __FUNCTION__);
+	spin_lock_irq (&amp;dum-&gt;lock);
+	dum-&gt;udc_suspended = 1;
+	set_link_state (dum);
+	spin_unlock_irq (&amp;dum-&gt;lock);
+
+	dev-&gt;power.power_state = state;
+	usb_hcd_poll_rh_status (dummy_to_hcd (dum));
+	return 0;
+}
+
+static int dummy_udc_resume (struct device *dev, u32 level)
+{
+	struct dummy	*dum = dev_get_drvdata(dev);
+
+	if (level != RESUME_ENABLE)
+		return 0;
+
+	dev_dbg (dev, "%s\n", __FUNCTION__);
+	spin_lock_irq (&amp;dum-&gt;lock);
+	dum-&gt;udc_suspended = 0;
+	set_link_state (dum);
+	spin_unlock_irq (&amp;dum-&gt;lock);
+
+	dev-&gt;power.power_state = PMSG_ON;
+	usb_hcd_poll_rh_status (dummy_to_hcd (dum));
+	return 0;
+}
+
 static struct device_driver dummy_udc_driver = {
 	.name		= (char *) gadget_name,
 	.bus		= &amp;platform_bus_type,
 	.probe		= dummy_udc_probe,
 	.remove		= dummy_udc_remove,
+	.suspend	= dummy_udc_suspend,
+	.resume		= dummy_udc_resume,
 };
 
 /*-------------------------------------------------------------------------*/
@@ -980,7 +1036,16 @@ static int dummy_urb_enqueue (
 
 static int dummy_urb_dequeue (struct usb_hcd *hcd, struct urb *urb)
 {
-	/* giveback happens automatically in timer callback */
+	struct dummy	*dum;
+	unsigned long	flags;
+
+	/* giveback happens automatically in timer callback,
+	 * so make sure the callback happens */
+	dum = hcd_to_dummy (hcd);
+	spin_lock_irqsave (&amp;dum-&gt;lock, flags);
+	if (dum-&gt;rh_state != DUMMY_RH_RUNNING &amp;&amp; !list_empty(&amp;dum-&gt;urbp_list))
+		mod_timer (&amp;dum-&gt;timer, jiffies);
+	spin_unlock_irqrestore (&amp;dum-&gt;lock, flags);
 	return 0;
 }
 
@@ -1222,7 +1287,8 @@ static void dummy_timer (unsigned long _dum)
 		if (urb-&gt;status != -EINPROGRESS) {
 			/* likely it was just unlinked */
 			goto return_urb;
-		}
+		} else if (dum-&gt;rh_state != DUMMY_RH_RUNNING)
+			continue;
 		type = usb_pipetype (urb-&gt;pipe);
 
 		/* used up this frame's non-periodic bandwidth?
@@ -1486,12 +1552,12 @@ static void dummy_timer (unsigned long _dum)
 		goto restart;
 	}
 
-	/* want a 1 msec delay here */
-	if (!list_empty (&amp;dum-&gt;urbp_list))
-		mod_timer (&amp;dum-&gt;timer, jiffies + msecs_to_jiffies(1));
-	else {
+	if (list_empty (&amp;dum-&gt;urbp_list)) {
 		usb_put_dev (dum-&gt;udev);
 		dum-&gt;udev = NULL;
+	} else if (dum-&gt;rh_state == DUMMY_RH_RUNNING) {
+		/* want a 1 msec delay here */
+		mod_timer (&amp;dum-&gt;timer, jiffies + msecs_to_jiffies(1));
 	}
 
 	spin_unlock_irqrestore (&amp;dum-&gt;lock, flags);
@@ -1510,11 +1576,13 @@ static int dummy_hub_status (struct usb_hcd *hcd, char *buf)
 {
 	struct dummy		*dum;
 	unsigned long		flags;
-	int			retval;
+	int			retval = 0;
 
 	dum = hcd_to_dummy (hcd);
 
 	spin_lock_irqsave (&amp;dum-&gt;lock, flags);
+	if (hcd-&gt;state != HC_STATE_RUNNING)
+		goto done;
 
 	if (dum-&gt;resuming &amp;&amp; time_after_eq (jiffies, dum-&gt;re_timeout)) {
 		dum-&gt;port_status |= (USB_PORT_STAT_C_SUSPEND &lt;&lt; 16);
@@ -1522,14 +1590,15 @@ static int dummy_hub_status (struct usb_hcd *hcd, char *buf)
 		set_link_state (dum);
 	}
 
-	if (!(dum-&gt;port_status &amp; PORT_C_MASK))
-		retval = 0;
-	else {
+	if ((dum-&gt;port_status &amp; PORT_C_MASK) != 0) {
 		*buf = (1 &lt;&lt; 1);
 		dev_dbg (dummy_dev(dum), "port status 0x%08x has changes\n",
-			dum-&gt;port_status);
+				dum-&gt;port_status);
 		retval = 1;
+		if (dum-&gt;rh_state == DUMMY_RH_SUSPENDED)
+			usb_hcd_resume_root_hub (hcd);
 	}
+done:
 	spin_unlock_irqrestore (&amp;dum-&gt;lock, flags);
 	return retval;
 }
@@ -1559,6 +1628,9 @@ static int dummy_hub_control (
 	int		retval = 0;
 	unsigned long	flags;
 
+	if (hcd-&gt;state != HC_STATE_RUNNING)
+		return -ETIMEDOUT;
+
 	dum = hcd_to_dummy (hcd);
 	spin_lock_irqsave (&amp;dum-&gt;lock, flags);
 	switch (typeReq) {
@@ -1658,6 +1730,7 @@ static int dummy_hub_control (
 			dum-&gt;port_status &amp;= ~(USB_PORT_STAT_ENABLE
 					| USB_PORT_STAT_LOW_SPEED
 					| USB_PORT_STAT_HIGH_SPEED);
+			dum-&gt;devstatus = 0;
 			/* 50msec reset signaling */
 			dum-&gt;re_timeout = jiffies + msecs_to_jiffies(50);
 			/* FALLS THROUGH */
@@ -1684,6 +1757,29 @@ static int dummy_hub_control (
 	return retval;
 }
 
+static int dummy_hub_suspend (struct usb_hcd *hcd)
+{
+	struct dummy *dum = hcd_to_dummy (hcd);
+
+	spin_lock_irq (&amp;dum-&gt;lock);
+	dum-&gt;rh_state = DUMMY_RH_SUSPENDED;
+	set_link_state (dum);
+	spin_unlock_irq (&amp;dum-&gt;lock);
+	return 0;
+}
+
+static int dummy_hub_resume (struct usb_hcd *hcd)
+{
+	struct dummy *dum = hcd_to_dummy (hcd);
+
+	spin_lock_irq (&amp;dum-&gt;lock);
+	dum-&gt;rh_state = DUMMY_RH_RUNNING;
+	set_link_state (dum);
+	if (!list_empty(&amp;dum-&gt;urbp_list))
+		mod_timer (&amp;dum-&gt;timer, jiffies);
+	spin_unlock_irq (&amp;dum-&gt;lock);
+	return 0;
+}
 
 /*-------------------------------------------------------------------------*/
 
@@ -1751,6 +1847,7 @@ static int dummy_start (struct usb_hcd *hcd)
 	init_timer (&amp;dum-&gt;timer);
 	dum-&gt;timer.function = dummy_timer;
 	dum-&gt;timer.data = (unsigned long) dum;
+	dum-&gt;rh_state = DUMMY_RH_RUNNING;
 
 	INIT_LIST_HEAD (&amp;dum-&gt;urbp_list);
 
@@ -1803,6 +1900,8 @@ static const struct hc_driver dummy_hcd = {
 
 	.hub_status_data = 	dummy_hub_status,
 	.hub_control = 		dummy_hub_control,
+	.hub_suspend =		dummy_hub_suspend,
+	.hub_resume =		dummy_hub_resume,
 };
 
 static int dummy_hcd_probe (struct device *dev)
@@ -1836,11 +1935,57 @@ static int dummy_hcd_remove (struct device *dev)
 	return 0;
 }
 
+static int dummy_hcd_suspend (struct device *dev, pm_message_t state,
+		u32 level)
+{
+	struct usb_hcd		*hcd;
+
+	if (level != SUSPEND_DISABLE)
+		return 0;
+
+	dev_dbg (dev, "%s\n", __FUNCTION__);
+	hcd = dev_get_drvdata (dev);
+
+#ifndef CONFIG_USB_SUSPEND
+	/* Otherwise this would never happen */
+	usb_lock_device (hcd-&gt;self.root_hub);
+	dummy_hub_suspend (hcd);
+	usb_unlock_device (hcd-&gt;self.root_hub);
+#endif
+
+	hcd-&gt;state = HC_STATE_SUSPENDED;
+	return 0;
+}
+
+static int dummy_hcd_resume (struct device *dev, u32 level)
+{
+	struct usb_hcd		*hcd;
+
+	if (level != RESUME_ENABLE)
+		return 0;
+
+	dev_dbg (dev, "%s\n", __FUNCTION__);
+	hcd = dev_get_drvdata (dev);
+	hcd-&gt;state = HC_STATE_RUNNING;
+
+#ifndef CONFIG_USB_SUSPEND
+	/* Otherwise this would never happen */
+	usb_lock_device (hcd-&gt;self.root_hub);
+	dummy_hub_resume (hcd);
+	usb_unlock_device (hcd-&gt;self.root_hub);
+#endif
+
+	usb_hcd_poll_rh_status (hcd);
+	return 0;
+}
+
 static struct device_driver dummy_hcd_driver = {
 	.name		= (char *) driver_name,
 	.bus		= &amp;platform_bus_type,
 	.probe		= dummy_hcd_probe,
 	.remove		= dummy_hcd_remove,
+	.suspend	= dummy_hcd_suspend,
+	.resume		= dummy_hcd_resume,
 };
 
 /*-------------------------------------------------------------------------*/</pre><hr><pre>commit cc095b0b5b653dca3e106710a72ba28b5bb7456b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 10 15:28:38 2005 -0400

    [PATCH] USB: dummy_hcd: sparse cleanups
    
    This patch fixes the byte-ordering issue for setup packets in the
    dummy_hcd driver and cleans up a few things that sparse -Wbitwise
    dislikes.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index f9540adf2a4f..c78c64ae87af 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -734,7 +734,7 @@ show_function (struct device *dev, struct device_attribute *attr, char *buf)
 		return 0;
 	return scnprintf (buf, PAGE_SIZE, "%s\n", dum-&gt;driver-&gt;function);
 }
-DEVICE_ATTR (function, S_IRUGO, show_function, NULL);
+static DEVICE_ATTR (function, S_IRUGO, show_function, NULL);
 
 /*-------------------------------------------------------------------------*/
 
@@ -857,6 +857,9 @@ EXPORT_SYMBOL (usb_gadget_unregister_driver);
 
 #undef is_enabled
 
+/* just declare this in any driver that really need it */
+extern int net2280_set_fifo_mode (struct usb_gadget *gadget, int mode);
+
 int net2280_set_fifo_mode (struct usb_gadget *gadget, int mode)
 {
 	return -ENOSYS;
@@ -1122,7 +1125,6 @@ static int periodic_bytes (struct dummy *dum, struct dummy_ep *ep)
 
 		/* high bandwidth mode */
 		tmp = le16_to_cpu(ep-&gt;desc-&gt;wMaxPacketSize);
-		tmp = le16_to_cpu (tmp);
 		tmp = (tmp &gt;&gt; 11) &amp; 0x03;
 		tmp *= 8 /* applies to entire frame */;
 		limit += limit * tmp;
@@ -1265,9 +1267,14 @@ static void dummy_timer (unsigned long _dum)
 			struct usb_ctrlrequest		setup;
 			int				value = 1;
 			struct dummy_ep			*ep2;
+			unsigned			w_index;
+			unsigned			w_value;
 
 			setup = *(struct usb_ctrlrequest*) urb-&gt;setup_packet;
-			if (setup.wLength != urb-&gt;transfer_buffer_length) {
+			w_index = le16_to_cpu(setup.wIndex);
+			w_value = le16_to_cpu(setup.wValue);
+			if (le16_to_cpu(setup.wLength) !=
+					urb-&gt;transfer_buffer_length) {
 				maybe_set_status (urb, -EOVERFLOW);
 				goto return_urb;
 			}
@@ -1297,16 +1304,16 @@ static void dummy_timer (unsigned long _dum)
 			case USB_REQ_SET_ADDRESS:
 				if (setup.bRequestType != Dev_Request)
 					break;
-				dum-&gt;address = setup.wValue;
+				dum-&gt;address = w_value;
 				maybe_set_status (urb, 0);
 				dev_dbg (udc_dev(dum), "set_address = %d\n",
-						setup.wValue);
+						w_value);
 				value = 0;
 				break;
 			case USB_REQ_SET_FEATURE:
 				if (setup.bRequestType == Dev_Request) {
 					value = 0;
-					switch (setup.wValue) {
+					switch (w_value) {
 					case USB_DEVICE_REMOTE_WAKEUP:
 						break;
 					case USB_DEVICE_B_HNP_ENABLE:
@@ -1324,14 +1331,13 @@ static void dummy_timer (unsigned long _dum)
 					}
 					if (value == 0) {
 						dum-&gt;devstatus |=
-							(1 &lt;&lt; setup.wValue);
+							(1 &lt;&lt; w_value);
 						maybe_set_status (urb, 0);
 					}
 
 				} else if (setup.bRequestType == Ep_Request) {
 					// endpoint halt
-					ep2 = find_endpoint (dum,
-							setup.wIndex);
+					ep2 = find_endpoint (dum, w_index);
 					if (!ep2) {
 						value = -EOPNOTSUPP;
 						break;
@@ -1343,7 +1349,7 @@ static void dummy_timer (unsigned long _dum)
 				break;
 			case USB_REQ_CLEAR_FEATURE:
 				if (setup.bRequestType == Dev_Request) {
-					switch (setup.wValue) {
+					switch (w_value) {
 					case USB_DEVICE_REMOTE_WAKEUP:
 						dum-&gt;devstatus &amp;= ~(1 &lt;&lt;
 							USB_DEVICE_REMOTE_WAKEUP);
@@ -1356,8 +1362,7 @@ static void dummy_timer (unsigned long _dum)
 					}
 				} else if (setup.bRequestType == Ep_Request) {
 					// endpoint halt
-					ep2 = find_endpoint (dum,
-							setup.wIndex);
+					ep2 = find_endpoint (dum, w_index);
 					if (!ep2) {
 						value = -EOPNOTSUPP;
 						break;
@@ -1383,7 +1388,7 @@ static void dummy_timer (unsigned long _dum)
 					if (urb-&gt;transfer_buffer_length &gt; 0) {
 						if (setup.bRequestType ==
 								Ep_InRequest) {
-	ep2 = find_endpoint (dum, setup.wIndex);
+	ep2 = find_endpoint (dum, w_index);
 	if (!ep2) {
 		value = -EOPNOTSUPP;
 		break;
@@ -1535,7 +1540,8 @@ hub_descriptor (struct usb_hub_descriptor *desc)
 	memset (desc, 0, sizeof *desc);
 	desc-&gt;bDescriptorType = 0x29;
 	desc-&gt;bDescLength = 9;
-	desc-&gt;wHubCharacteristics = __constant_cpu_to_le16 (0x0001);
+	desc-&gt;wHubCharacteristics = (__force __u16)
+			(__constant_cpu_to_le16 (0x0001));
 	desc-&gt;bNbrPorts = 1;
 	desc-&gt;bitmap [0] = 0xff;
 	desc-&gt;bitmap [1] = 0xff;
@@ -1581,7 +1587,7 @@ static int dummy_hub_control (
 		hub_descriptor ((struct usb_hub_descriptor *) buf);
 		break;
 	case GetHubStatus:
-		*(u32 *) buf = __constant_cpu_to_le32 (0);
+		*(__le32 *) buf = __constant_cpu_to_le32 (0);
 		break;
 	case GetPortStatus:
 		if (wIndex != 1)
@@ -1621,8 +1627,8 @@ static int dummy_hub_control (
 			}
 		}
 		set_link_state (dum);
-		((u16 *) buf)[0] = cpu_to_le16 (dum-&gt;port_status);
-		((u16 *) buf)[1] = cpu_to_le16 (dum-&gt;port_status &gt;&gt; 16);
+		((__le16 *) buf)[0] = cpu_to_le16 (dum-&gt;port_status);
+		((__le16 *) buf)[1] = cpu_to_le16 (dum-&gt;port_status &gt;&gt; 16);
 		break;
 	case SetHubFeature:
 		retval = -EPIPE;</pre><hr><pre>commit 685eb93f086eb15d9fb1e82c7400fd750f564640
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 3 16:27:26 2005 -0400

    [PATCH] USB dummy_hcd: Use root-hub interrupts instead of polling
    
    This patch makes the dummy_hcd driver use emulated root-hub interrupts
    instead of polling.  It's in the spirit of similar changes being made to
    the other HCDs.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index 2d6d22951326..73d2f24050ab 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -684,6 +684,7 @@ static int dummy_wakeup (struct usb_gadget *_gadget)
 	/* hub notices our request, issues downstream resume, etc */
 	dum-&gt;resuming = 1;
 	dum-&gt;re_timeout = jiffies + msecs_to_jiffies(20);
+	mod_timer (&amp;dummy_to_hcd (dum)-&gt;rh_timer, dum-&gt;re_timeout);
 	return 0;
 }
 
@@ -709,6 +710,8 @@ static int dummy_pullup (struct usb_gadget *_gadget, int value)
 	dum-&gt;pullup = (value != 0);
 	set_link_state (dum);
 	spin_unlock_irqrestore (&amp;dum-&gt;lock, flags);
+
+	usb_hcd_poll_rh_status (dummy_to_hcd (dum));
 	return 0;
 }
 
@@ -811,6 +814,8 @@ usb_gadget_register_driver (struct usb_gadget_driver *driver)
 	dum-&gt;pullup = 1;
 	set_link_state (dum);
 	spin_unlock_irq (&amp;dum-&gt;lock);
+
+	usb_hcd_poll_rh_status (dummy_to_hcd (dum));
 	return 0;
 }
 EXPORT_SYMBOL (usb_gadget_register_driver);
@@ -845,6 +850,7 @@ usb_gadget_unregister_driver (struct usb_gadget_driver *driver)
 	set_link_state (dum);
 	spin_unlock_irqrestore (&amp;dum-&gt;lock, flags);
 
+	usb_hcd_poll_rh_status (dummy_to_hcd (dum));
 	return 0;
 }
 EXPORT_SYMBOL (usb_gadget_unregister_driver);
@@ -1669,6 +1675,9 @@ static int dummy_hub_control (
 		retval = -EPIPE;
 	}
 	spin_unlock_irqrestore (&amp;dum-&gt;lock, flags);
+
+	if ((dum-&gt;port_status &amp; PORT_C_MASK) != 0)
+		usb_hcd_poll_rh_status (hcd);
 	return retval;
 }
 
@@ -1745,6 +1754,7 @@ static int dummy_start (struct usb_hcd *hcd)
 	/* only show a low-power port: just 8mA */
 	hcd-&gt;power_budget = 8;
 	hcd-&gt;state = HC_STATE_RUNNING;
+	hcd-&gt;uses_new_polling = 1;
 
 #ifdef CONFIG_USB_OTG
 	hcd-&gt;self.otg_port = 1;</pre><hr><pre>commit f1c39fad7d1bbea31744138cd3a532ff346cd4ab
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 3 16:24:04 2005 -0400

    [PATCH] USB dummy_hcd: Centralize link state computations
    
    This patch adds to the dummy_hcd driver a new routine for keeping track of
    all changes in the state of the emulated USB link.  The logic is now kept
    in one spot instead of spread around, and it's easier to verify and
    update the code.  The behavior of the port features has been corrected in
    a few respects as well (for instance, if the POWER feature is clear then
    none of the other features can be set).
    
    Also added is support for the (relatively new) _connect() and
    _disconnect() calls of the Gadget API.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index dc0e3233b0e9..2d6d22951326 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -163,12 +163,16 @@ struct dummy {
 	struct dummy_request		fifo_req;
 	u8				fifo_buf [FIFO_SIZE];
 	u16				devstatus;
+	unsigned			pullup:1;
+	unsigned			active:1;
+	unsigned			old_active:1;
 
 	/*
 	 * MASTER/HOST side support
 	 */
 	struct timer_list		timer;
 	u32				port_status;
+	u32				old_status;
 	unsigned			resuming:1;
 	unsigned long			re_timeout;
 
@@ -215,6 +219,98 @@ static struct dummy			*the_controller;
 
 /*-------------------------------------------------------------------------*/
 
+/* SLAVE/GADGET SIDE UTILITY ROUTINES */
+
+/* called with spinlock held */
+static void nuke (struct dummy *dum, struct dummy_ep *ep)
+{
+	while (!list_empty (&amp;ep-&gt;queue)) {
+		struct dummy_request	*req;
+
+		req = list_entry (ep-&gt;queue.next, struct dummy_request, queue);
+		list_del_init (&amp;req-&gt;queue);
+		req-&gt;req.status = -ESHUTDOWN;
+
+		spin_unlock (&amp;dum-&gt;lock);
+		req-&gt;req.complete (&amp;ep-&gt;ep, &amp;req-&gt;req);
+		spin_lock (&amp;dum-&gt;lock);
+	}
+}
+
+/* caller must hold lock */
+static void
+stop_activity (struct dummy *dum)
+{
+	struct dummy_ep	*ep;
+
+	/* prevent any more requests */
+	dum-&gt;address = 0;
+
+	/* The timer is left running so that outstanding URBs can fail */
+
+	/* nuke any pending requests first, so driver i/o is quiesced */
+	list_for_each_entry (ep, &amp;dum-&gt;gadget.ep_list, ep.ep_list)
+		nuke (dum, ep);
+
+	/* driver now does any non-usb quiescing necessary */
+}
+
+/* caller must hold lock */
+static void
+set_link_state (struct dummy *dum)
+{
+	dum-&gt;active = 0;
+	if ((dum-&gt;port_status &amp; USB_PORT_STAT_POWER) == 0)
+		dum-&gt;port_status = 0;
+	else if (!dum-&gt;pullup) {
+		dum-&gt;port_status &amp;= ~(USB_PORT_STAT_CONNECTION |
+					USB_PORT_STAT_ENABLE |
+					USB_PORT_STAT_LOW_SPEED |
+					USB_PORT_STAT_HIGH_SPEED |
+					USB_PORT_STAT_SUSPEND);
+		if ((dum-&gt;old_status &amp; USB_PORT_STAT_CONNECTION) != 0)
+			dum-&gt;port_status |= (USB_PORT_STAT_C_CONNECTION &lt;&lt; 16);
+	} else {
+		dum-&gt;port_status |= USB_PORT_STAT_CONNECTION;
+		if ((dum-&gt;old_status &amp; USB_PORT_STAT_CONNECTION) == 0)
+			dum-&gt;port_status |= (USB_PORT_STAT_C_CONNECTION &lt;&lt; 16);
+		if ((dum-&gt;port_status &amp; USB_PORT_STAT_ENABLE) == 0)
+			dum-&gt;port_status &amp;= ~USB_PORT_STAT_SUSPEND;
+		else if ((dum-&gt;port_status &amp; USB_PORT_STAT_SUSPEND) == 0)
+			dum-&gt;active = 1;
+	}
+
+	if ((dum-&gt;port_status &amp; USB_PORT_STAT_ENABLE) == 0 || dum-&gt;active)
+		dum-&gt;resuming = 0;
+
+	if ((dum-&gt;port_status &amp; USB_PORT_STAT_CONNECTION) == 0 ||
+			(dum-&gt;port_status &amp; USB_PORT_STAT_RESET) != 0) {
+		if ((dum-&gt;old_status &amp; USB_PORT_STAT_CONNECTION) != 0 &amp;&amp;
+				(dum-&gt;old_status &amp; USB_PORT_STAT_RESET) == 0 &amp;&amp;
+				dum-&gt;driver) {
+			stop_activity (dum);
+			spin_unlock (&amp;dum-&gt;lock);
+			dum-&gt;driver-&gt;disconnect (&amp;dum-&gt;gadget);
+			spin_lock (&amp;dum-&gt;lock);
+		}
+	} else if (dum-&gt;active != dum-&gt;old_active) {
+		if (dum-&gt;old_active &amp;&amp; dum-&gt;driver-&gt;suspend) {
+			spin_unlock (&amp;dum-&gt;lock);
+			dum-&gt;driver-&gt;suspend (&amp;dum-&gt;gadget);
+			spin_lock (&amp;dum-&gt;lock);
+		} else if (!dum-&gt;old_active &amp;&amp; dum-&gt;driver-&gt;resume) {
+			spin_unlock (&amp;dum-&gt;lock);
+			dum-&gt;driver-&gt;resume (&amp;dum-&gt;gadget);
+			spin_lock (&amp;dum-&gt;lock);
+		}
+	}
+
+	dum-&gt;old_status = dum-&gt;port_status;
+	dum-&gt;old_active = dum-&gt;active;
+}
+
+/*-------------------------------------------------------------------------*/
+
 /* SLAVE/GADGET SIDE DRIVER
  *
  * This only tracks gadget state.  All the work is done when the host
@@ -339,22 +435,6 @@ dummy_enable (struct usb_ep *_ep, const struct usb_endpoint_descriptor *desc)
 	return retval;
 }
 
-/* called with spinlock held */
-static void nuke (struct dummy *dum, struct dummy_ep *ep)
-{
-	while (!list_empty (&amp;ep-&gt;queue)) {
-		struct dummy_request	*req;
-
-		req = list_entry (ep-&gt;queue.next, struct dummy_request, queue);
-		list_del_init (&amp;req-&gt;queue);
-		req-&gt;req.status = -ESHUTDOWN;
-
-		spin_unlock (&amp;dum-&gt;lock);
-		req-&gt;req.complete (&amp;ep-&gt;ep, &amp;req-&gt;req);
-		spin_lock (&amp;dum-&gt;lock);
-	}
-}
-
 static int dummy_disable (struct usb_ep *_ep)
 {
 	struct dummy_ep		*ep;
@@ -603,7 +683,7 @@ static int dummy_wakeup (struct usb_gadget *_gadget)
 
 	/* hub notices our request, issues downstream resume, etc */
 	dum-&gt;resuming = 1;
-	dum-&gt;port_status |= (USB_PORT_STAT_C_SUSPEND &lt;&lt; 16);
+	dum-&gt;re_timeout = jiffies + msecs_to_jiffies(20);
 	return 0;
 }
 
@@ -619,10 +699,24 @@ static int dummy_set_selfpowered (struct usb_gadget *_gadget, int value)
 	return 0;
 }
 
+static int dummy_pullup (struct usb_gadget *_gadget, int value)
+{
+	struct dummy	*dum;
+	unsigned long	flags;
+
+	dum = gadget_to_dummy (_gadget);
+	spin_lock_irqsave (&amp;dum-&gt;lock, flags);
+	dum-&gt;pullup = (value != 0);
+	set_link_state (dum);
+	spin_unlock_irqrestore (&amp;dum-&gt;lock, flags);
+	return 0;
+}
+
 static const struct usb_gadget_ops dummy_ops = {
 	.get_frame	= dummy_g_get_frame,
 	.wakeup		= dummy_wakeup,
 	.set_selfpowered = dummy_set_selfpowered,
+	.pullup		= dummy_pullup,
 };
 
 /*-------------------------------------------------------------------------*/
@@ -675,7 +769,6 @@ usb_gadget_register_driver (struct usb_gadget_driver *driver)
 	 */
 
 	dum-&gt;devstatus = 0;
-	dum-&gt;resuming = 0;
 
 	INIT_LIST_HEAD (&amp;dum-&gt;gadget.ep_list);
 	for (i = 0; i &lt; DUMMY_ENDPOINTS; i++) {
@@ -714,35 +807,14 @@ usb_gadget_register_driver (struct usb_gadget_driver *driver)
 	device_bind_driver (&amp;dum-&gt;gadget.dev);
 
 	/* khubd will enumerate this in a while */
-	dum-&gt;port_status |= USB_PORT_STAT_CONNECTION
-		| (USB_PORT_STAT_C_CONNECTION &lt;&lt; 16);
+	spin_lock_irq (&amp;dum-&gt;lock);
+	dum-&gt;pullup = 1;
+	set_link_state (dum);
+	spin_unlock_irq (&amp;dum-&gt;lock);
 	return 0;
 }
 EXPORT_SYMBOL (usb_gadget_register_driver);
 
-/* caller must hold lock */
-static void
-stop_activity (struct dummy *dum, struct usb_gadget_driver *driver)
-{
-	struct dummy_ep	*ep;
-
-	/* prevent any more requests */
-	dum-&gt;address = 0;
-
-	/* The timer is left running so that outstanding URBs can fail */
-
-	/* nuke any pending requests first, so driver i/o is quiesced */
-	list_for_each_entry (ep, &amp;dum-&gt;gadget.ep_list, ep.ep_list)
-		nuke (dum, ep);
-
-	/* driver now does any non-usb quiescing necessary */
-	if (driver) {
-		spin_unlock (&amp;dum-&gt;lock);
-		driver-&gt;disconnect (&amp;dum-&gt;gadget);
-		spin_lock (&amp;dum-&gt;lock);
-	}
-}
-
 int
 usb_gadget_unregister_driver (struct usb_gadget_driver *driver)
 {
@@ -758,10 +830,8 @@ usb_gadget_unregister_driver (struct usb_gadget_driver *driver)
 			driver-&gt;driver.name);
 
 	spin_lock_irqsave (&amp;dum-&gt;lock, flags);
-	stop_activity (dum, driver);
-	dum-&gt;port_status &amp;= ~(USB_PORT_STAT_CONNECTION | USB_PORT_STAT_ENABLE |
-			USB_PORT_STAT_LOW_SPEED | USB_PORT_STAT_HIGH_SPEED);
-	dum-&gt;port_status |= (USB_PORT_STAT_C_CONNECTION &lt;&lt; 16);
+	dum-&gt;pullup = 0;
+	set_link_state (dum);
 	spin_unlock_irqrestore (&amp;dum-&gt;lock, flags);
 
 	driver-&gt;unbind (&amp;dum-&gt;gadget);
@@ -770,6 +840,11 @@ usb_gadget_unregister_driver (struct usb_gadget_driver *driver)
 	device_release_driver (&amp;dum-&gt;gadget.dev);
 	driver_unregister (&amp;driver-&gt;driver);
 
+	spin_lock_irqsave (&amp;dum-&gt;lock, flags);
+	dum-&gt;pullup = 0;
+	set_link_state (dum);
+	spin_unlock_irqrestore (&amp;dum-&gt;lock, flags);
+
 	return 0;
 }
 EXPORT_SYMBOL (usb_gadget_unregister_driver);
@@ -1432,6 +1507,13 @@ static int dummy_hub_status (struct usb_hcd *hcd, char *buf)
 	dum = hcd_to_dummy (hcd);
 
 	spin_lock_irqsave (&amp;dum-&gt;lock, flags);
+
+	if (dum-&gt;resuming &amp;&amp; time_after_eq (jiffies, dum-&gt;re_timeout)) {
+		dum-&gt;port_status |= (USB_PORT_STAT_C_SUSPEND &lt;&lt; 16);
+		dum-&gt;port_status &amp;= ~USB_PORT_STAT_SUSPEND;
+		set_link_state (dum);
+	}
+
 	if (!(dum-&gt;port_status &amp; PORT_C_MASK))
 		retval = 0;
 	else {
@@ -1480,16 +1562,16 @@ static int dummy_hub_control (
 				/* 20msec resume signaling */
 				dum-&gt;resuming = 1;
 				dum-&gt;re_timeout = jiffies +
-							msecs_to_jiffies(20);
+						msecs_to_jiffies(20);
 			}
 			break;
 		case USB_PORT_FEAT_POWER:
-			dum-&gt;port_status = 0;
-			dum-&gt;resuming = 0;
-			stop_activity(dum, dum-&gt;driver);
-			break;
+			if (dum-&gt;port_status &amp; USB_PORT_STAT_POWER)
+				dev_dbg (dummy_dev(dum), "power-off\n");
+			/* FALLS THROUGH */
 		default:
 			dum-&gt;port_status &amp;= ~(1 &lt;&lt; wValue);
+			set_link_state (dum);
 		}
 		break;
 	case GetHubDescriptor:
@@ -1505,23 +1587,16 @@ static int dummy_hub_control (
 		/* whoever resets or resumes must GetPortStatus to
 		 * complete it!!
 		 */
-		if (dum-&gt;resuming &amp;&amp; time_after (jiffies, dum-&gt;re_timeout)) {
+		if (dum-&gt;resuming &amp;&amp;
+				time_after_eq (jiffies, dum-&gt;re_timeout)) {
 			dum-&gt;port_status |= (USB_PORT_STAT_C_SUSPEND &lt;&lt; 16);
 			dum-&gt;port_status &amp;= ~USB_PORT_STAT_SUSPEND;
-			dum-&gt;resuming = 0;
-			dum-&gt;re_timeout = 0;
-			if (dum-&gt;driver &amp;&amp; dum-&gt;driver-&gt;resume) {
-				spin_unlock (&amp;dum-&gt;lock);
-				dum-&gt;driver-&gt;resume (&amp;dum-&gt;gadget);
-				spin_lock (&amp;dum-&gt;lock);
-			}
 		}
-		if ((dum-&gt;port_status &amp; USB_PORT_STAT_RESET) != 0
-				&amp;&amp; time_after (jiffies, dum-&gt;re_timeout)) {
+		if ((dum-&gt;port_status &amp; USB_PORT_STAT_RESET) != 0 &amp;&amp;
+				time_after_eq (jiffies, dum-&gt;re_timeout)) {
 			dum-&gt;port_status |= (USB_PORT_STAT_C_RESET &lt;&lt; 16);
 			dum-&gt;port_status &amp;= ~USB_PORT_STAT_RESET;
-			dum-&gt;re_timeout = 0;
-			if (dum-&gt;driver) {
+			if (dum-&gt;pullup) {
 				dum-&gt;port_status |= USB_PORT_STAT_ENABLE;
 				/* give it the best speed we agree on */
 				dum-&gt;gadget.speed = dum-&gt;driver-&gt;speed;
@@ -1542,6 +1617,7 @@ static int dummy_hub_control (
 				}
 			}
 		}
+		set_link_state (dum);
 		((u16 *) buf)[0] = cpu_to_le16 (dum-&gt;port_status);
 		((u16 *) buf)[1] = cpu_to_le16 (dum-&gt;port_status &gt;&gt; 16);
 		break;
@@ -1551,42 +1627,36 @@ static int dummy_hub_control (
 	case SetPortFeature:
 		switch (wValue) {
 		case USB_PORT_FEAT_SUSPEND:
-			if ((dum-&gt;port_status &amp; USB_PORT_STAT_SUSPEND)
-					== 0) {
+			if (dum-&gt;active) {
 				dum-&gt;port_status |= USB_PORT_STAT_SUSPEND;
-				if (dum-&gt;driver &amp;&amp; dum-&gt;driver-&gt;suspend) {
-					spin_unlock (&amp;dum-&gt;lock);
-					dum-&gt;driver-&gt;suspend (&amp;dum-&gt;gadget);
-					spin_lock (&amp;dum-&gt;lock);
-					/* HNP would happen here; for now we
-					 * assume b_bus_req is always true.
-					 */
-					if (((1 &lt;&lt; USB_DEVICE_B_HNP_ENABLE)
-							&amp; dum-&gt;devstatus) != 0)
-						dev_dbg (dummy_dev(dum),
+
+				/* HNP would happen here; for now we
+				 * assume b_bus_req is always true.
+				 */
+				set_link_state (dum);
+				if (((1 &lt;&lt; USB_DEVICE_B_HNP_ENABLE)
+						&amp; dum-&gt;devstatus) != 0)
+					dev_dbg (dummy_dev(dum),
 							"no HNP yet!\n");
-				}
 			}
 			break;
+		case USB_PORT_FEAT_POWER:
+			dum-&gt;port_status |= USB_PORT_STAT_POWER;
+			set_link_state (dum);
+			break;
 		case USB_PORT_FEAT_RESET:
-			/* if it's already running, disconnect first */
-			if (dum-&gt;port_status &amp; USB_PORT_STAT_ENABLE) {
-				dum-&gt;port_status &amp;= ~(USB_PORT_STAT_ENABLE
-						| USB_PORT_STAT_LOW_SPEED
-						| USB_PORT_STAT_HIGH_SPEED);
-				if (dum-&gt;driver) {
-					dev_dbg (udc_dev(dum),
-							"disconnect\n");
-					stop_activity (dum, dum-&gt;driver);
-				}
-
-				/* FIXME test that code path! */
-			}
+			/* if it's already enabled, disable */
+			dum-&gt;port_status &amp;= ~(USB_PORT_STAT_ENABLE
+					| USB_PORT_STAT_LOW_SPEED
+					| USB_PORT_STAT_HIGH_SPEED);
 			/* 50msec reset signaling */
 			dum-&gt;re_timeout = jiffies + msecs_to_jiffies(50);
-			/* FALLTHROUGH */
+			/* FALLS THROUGH */
 		default:
-			dum-&gt;port_status |= (1 &lt;&lt; wValue);
+			if ((dum-&gt;port_status &amp; USB_PORT_STAT_POWER) != 0) {
+				dum-&gt;port_status |= (1 &lt;&lt; wValue);
+				set_link_state (dum);
+			}
 		}
 		break;
 </pre>
    <div class="pagination">
        <a href='2_136.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><span>[137]</span><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_138.html'>Next&gt;&gt;</a>
    <div>
</body>
