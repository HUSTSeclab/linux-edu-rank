<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_47.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><span>[48]</span><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_49.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 0070513b5e005161a7a7fd9a3f48f982b41eb094
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jun 20 16:04:30 2012 -0400

    usb-storage: revert commit afff07e61a52 (Add 090c:1000 to unusal-devs)
    
    This patch (as1560) reverts commit
    afff07e61a5243e14ee3f0a272a0380cd744a8a3 (usb-storage: Add 090c:1000
    to unusal-devs).  It is no longer needed, because usb-storage now
    tells the sd driver to try READ CAPACITY(10) before READ CAPACITY(16)
    for every USB mass-storage device.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Hans de Goede &lt;hdegoede@redhat.com&gt;
    CC: Matthew Dharm &lt;mdharm-usb@one-eyed-alien.net&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index caf22bf5f822..1719886bb9be 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -1107,13 +1107,6 @@ UNUSUAL_DEV( 0x090a, 0x1200, 0x0000, 0x9999,
 		USB_SC_RBC, USB_PR_BULK, NULL,
 		0 ),
 
-/* Feiya QDI U2 DISK, reported by Hans de Goede &lt;hdegoede@redhat.com&gt; */
-UNUSUAL_DEV( 0x090c, 0x1000, 0x0000, 0xffff,
-		"Feiya",
-		"QDI U2 DISK",
-		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
-		US_FL_NO_READ_CAPACITY_16 ),
-
 /* aeb */
 UNUSUAL_DEV( 0x090c, 0x1132, 0x0000, 0xffff,
 		"Feiya",</pre><hr><pre>commit 6a0bdffa0073857870a4ed1b4489762146359eb4
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jun 20 16:04:19 2012 -0400

    SCSI &amp; usb-storage: add try_rc_10_first flag
    
    Several bug reports have been received recently for USB mass-storage
    devices that don't handle READ CAPACITY(16) commands properly.  They
    report bogus sizes, in some cases becoming unusable as a result.
    
    The bugs were triggered by commit
    09b6b51b0b6c1b9bb61815baf205e4d74c89ff04 (SCSI &amp; usb-storage: add
    flags for VPD pages and REPORT LUNS), which caused usb-storage to stop
    overriding the SCSI level reported by devices.  By default, the sd
    driver will try READ CAPACITY(16) first for any device whose level is
    above SCSI_SPC_2.
    
    It seems likely that any device large enough to require the use of
    READ CAPACITY(16) (i.e., 2 TB or more) would be able to handle READ
    CAPACITY(10) commands properly.  Indeed, I don't know of any devices
    that don't handle READ CAPACITY(10) properly.
    
    Therefore this patch (as1559) adds a new flag telling the sd driver
    to try READ CAPACITY(10) before READ CAPACITY(16), and sets this flag
    for every USB mass-storage device.  If a device really is larger than
    2 TB, sd will fall back to READ CAPACITY(16) just as it used to.
    
    This fixes Bugzilla #43391.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Hans de Goede &lt;hdegoede@redhat.com&gt;
    CC: "James E.J. Bottomley" &lt;JBottomley@parallels.com&gt;
    CC: Matthew Dharm &lt;mdharm-usb@one-eyed-alien.net&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c
index 6f0a4c612b3b..6f72b80121a0 100644
--- a/drivers/scsi/sd.c
+++ b/drivers/scsi/sd.c
@@ -1899,6 +1899,8 @@ static int sd_try_rc16_first(struct scsi_device *sdp)
 {
 	if (sdp-&gt;host-&gt;max_cmd_len &lt; 16)
 		return 0;
+	if (sdp-&gt;try_rc_10_first)
+		return 0;
 	if (sdp-&gt;scsi_level &gt; SCSI_SPC_2)
 		return 1;
 	if (scsi_device_protection(sdp))
diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index a324a5d21e99..11418da9bc09 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -202,6 +202,12 @@ static int slave_configure(struct scsi_device *sdev)
 		if (us-&gt;fflags &amp; US_FL_NO_READ_CAPACITY_16)
 			sdev-&gt;no_read_capacity_16 = 1;
 
+		/*
+		 * Many devices do not respond properly to READ_CAPACITY_16.
+		 * Tell the SCSI layer to try READ_CAPACITY_10 first.
+		 */
+		sdev-&gt;try_rc_10_first = 1;
+
 		/* assume SPC3 or latter devices support sense size &gt; 18 */
 		if (sdev-&gt;scsi_level &gt; SCSI_SPC_2)
 			us-&gt;fflags |= US_FL_SANE_SENSE;
diff --git a/include/scsi/scsi_device.h b/include/scsi/scsi_device.h
index 6efb2e1416e0..ba9698852321 100644
--- a/include/scsi/scsi_device.h
+++ b/include/scsi/scsi_device.h
@@ -151,6 +151,7 @@ struct scsi_device {
 					   SD_LAST_BUGGY_SECTORS */
 	unsigned no_read_disc_info:1;	/* Avoid READ_DISC_INFO cmds */
 	unsigned no_read_capacity_16:1; /* Avoid READ_CAPACITY_16 cmds */
+	unsigned try_rc_10_first:1;	/* Try READ_CAPACACITY_10 first */
 	unsigned is_visible:1;	/* is the device visible in sysfs */
 
 	DECLARE_BITMAP(supported_events, SDEV_EVT_MAXBITS); /* supported events */</pre><hr><pre>commit 0b84704a2d6fdf55a3dcdd2a1f2ac8b48913c84b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu May 31 17:03:52 2012 -0400

    USB: serial-generic: use a single set of device IDs
    
    The usb-serial-generic driver uses different device IDs for its USB
    matching and its serial matching.  This can lead to problems: The
    driver can end up getting bound to a USB interface without being
    allowed to bind to the corresponding serial port.
    
    This patch (as1557) fixes the problem by using the same device ID
    table (the one that can be altered by the "vendor=" and "product="
    module parameters) for both purposes.  The unused table is removed.
    Now the driver will bind only to the intended devices.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Bjørn Mork &lt;bjorn@mork.no&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/serial/generic.c b/drivers/usb/serial/generic.c
index 105a6d898ca4..9b026bf7afef 100644
--- a/drivers/usb/serial/generic.c
+++ b/drivers/usb/serial/generic.c
@@ -39,13 +39,6 @@ MODULE_PARM_DESC(product, "User specified USB idProduct");
 
 static struct usb_device_id generic_device_ids[2]; /* Initially all zeroes. */
 
-/* we want to look at all devices, as the vendor/product id can change
- * depending on the command line argument */
-static const struct usb_device_id generic_serial_ids[] = {
-	{.driver_info = 42},
-	{}
-};
-
 /* All of the device info needed for the Generic Serial Converter */
 struct usb_serial_driver usb_serial_generic_device = {
 	.driver = {
@@ -79,7 +72,8 @@ int usb_serial_generic_register(int _debug)
 		USB_DEVICE_ID_MATCH_VENDOR | USB_DEVICE_ID_MATCH_PRODUCT;
 
 	/* register our generic driver with ourselves */
-	retval = usb_serial_register_drivers(serial_drivers, "usbserial_generic", generic_serial_ids);
+	retval = usb_serial_register_drivers(serial_drivers,
+			"usbserial_generic", generic_device_ids);
 #endif
 	return retval;
 }</pre><hr><pre>commit c2fb8a3fa25513de8fedb38509b1f15a5bbee47b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jun 13 11:20:19 2012 -0400

    USB: add NO_D3_DURING_SLEEP flag and revert 151b61284776be2
    
    This patch (as1558) fixes a problem affecting several ASUS computers:
    The machine crashes or corrupts memory when going into suspend if the
    ehci-hcd driver is bound to any controllers.  Users have been forced
    to unbind or unload ehci-hcd before putting their systems to sleep.
    
    After extensive testing, it was determined that the machines don't
    like going into suspend when any EHCI controllers are in the PCI D3
    power state.  Presumably this is a firmware bug, but there's nothing
    we can do about it except to avoid putting the controllers in D3
    during system sleep.
    
    The patch adds a new flag to indicate whether the problem is present,
    and avoids changing the controller's power state if the flag is set.
    Runtime suspend is unaffected; this matters only for system suspend.
    However as a side effect, the controller will not respond to remote
    wakeup requests while the system is asleep.  Hence USB wakeup is not
    functional -- but of course, this is already true in the current state
    of affairs.
    
    A similar patch has already been applied as commit
    151b61284776be2d6f02d48c23c3625678960b97 (USB: EHCI: fix crash during
    suspend on ASUS computers).  The patch supersedes that one and reverts
    it.  There are two differences:
    
            The old patch added the flag at the USB level; this patch
            adds it at the PCI level.
    
            The old patch applied to all chipsets with the same vendor,
            subsystem vendor, and product IDs; this patch makes an
            exception for a known-good system (based on DMI information).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Dâniel Fraga &lt;fragabr@gmail.com&gt;
    Tested-by: Andrey Rahmatullin &lt;wrar@wrar.name&gt;
    Tested-by: Steven Rostedt &lt;rostedt@goodmis.org&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Reviewed-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 447e83472c01..77cb54a65cde 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1744,6 +1744,11 @@ int pci_prepare_to_sleep(struct pci_dev *dev)
 	if (target_state == PCI_POWER_ERROR)
 		return -EIO;
 
+	/* Some devices mustn't be in D3 during system sleep */
+	if (target_state == PCI_D3hot &amp;&amp;
+			(dev-&gt;dev_flags &amp; PCI_DEV_FLAGS_NO_D3_DURING_SLEEP))
+		return 0;
+
 	pci_enable_wake(dev, target_state, device_may_wakeup(&amp;dev-&gt;dev));
 
 	error = pci_set_power_state(dev, target_state);
diff --git a/drivers/pci/quirks.c b/drivers/pci/quirks.c
index 2a7521677541..194b243a2817 100644
--- a/drivers/pci/quirks.c
+++ b/drivers/pci/quirks.c
@@ -2929,6 +2929,32 @@ static void __devinit disable_igfx_irq(struct pci_dev *dev)
 DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x0102, disable_igfx_irq);
 DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x010a, disable_igfx_irq);
 
+/*
+ * The Intel 6 Series/C200 Series chipset's EHCI controllers on many
+ * ASUS motherboards will cause memory corruption or a system crash
+ * if they are in D3 while the system is put into S3 sleep.
+ */
+static void __devinit asus_ehci_no_d3(struct pci_dev *dev)
+{
+	const char *sys_info;
+	static const char good_Asus_board[] = "P8Z68-V";
+
+	if (dev-&gt;dev_flags &amp; PCI_DEV_FLAGS_NO_D3_DURING_SLEEP)
+		return;
+	if (dev-&gt;subsystem_vendor != PCI_VENDOR_ID_ASUSTEK)
+		return;
+	sys_info = dmi_get_system_info(DMI_BOARD_NAME);
+	if (sys_info &amp;&amp; memcmp(sys_info, good_Asus_board,
+			sizeof(good_Asus_board) - 1) == 0)
+		return;
+
+	dev_info(&amp;dev-&gt;dev, "broken D3 during system sleep on ASUS\n");
+	dev-&gt;dev_flags |= PCI_DEV_FLAGS_NO_D3_DURING_SLEEP;
+	device_set_wakeup_capable(&amp;dev-&gt;dev, false);
+}
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x1c26, asus_ehci_no_d3);
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x1c2d, asus_ehci_no_d3);
+
 static void pci_do_fixups(struct pci_dev *dev, struct pci_fixup *f,
 			  struct pci_fixup *end)
 {
diff --git a/drivers/usb/core/hcd-pci.c b/drivers/usb/core/hcd-pci.c
index 57ed9e400c06..622b4a48e732 100644
--- a/drivers/usb/core/hcd-pci.c
+++ b/drivers/usb/core/hcd-pci.c
@@ -493,15 +493,6 @@ static int hcd_pci_suspend_noirq(struct device *dev)
 
 	pci_save_state(pci_dev);
 
-	/*
-	 * Some systems crash if an EHCI controller is in D3 during
-	 * a sleep transition.  We have to leave such controllers in D0.
-	 */
-	if (hcd-&gt;broken_pci_sleep) {
-		dev_dbg(dev, "Staying in PCI D0\n");
-		return retval;
-	}
-
 	/* If the root hub is dead rather than suspended, disallow remote
 	 * wakeup.  usb_hc_died() should ensure that both hosts are marked as
 	 * dying, so we only need to check the primary roothub.
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index bc94d7bf072d..123481793a47 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -144,14 +144,6 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 			hcd-&gt;has_tt = 1;
 			tdi_reset(ehci);
 		}
-		if (pdev-&gt;subsystem_vendor == PCI_VENDOR_ID_ASUSTEK) {
-			/* EHCI #1 or #2 on 6 Series/C200 Series chipset */
-			if (pdev-&gt;device == 0x1c26 || pdev-&gt;device == 0x1c2d) {
-				ehci_info(ehci, "broken D3 during system sleep on ASUS\n");
-				hcd-&gt;broken_pci_sleep = 1;
-				device_set_wakeup_capable(&amp;pdev-&gt;dev, false);
-			}
-		}
 		break;
 	case PCI_VENDOR_ID_TDI:
 		if (pdev-&gt;device == PCI_DEVICE_ID_TDI_EHCI) {
diff --git a/include/linux/pci.h b/include/linux/pci.h
index d8c379dba6ad..fefb4e19bf6a 100644
--- a/include/linux/pci.h
+++ b/include/linux/pci.h
@@ -176,6 +176,8 @@ enum pci_dev_flags {
 	PCI_DEV_FLAGS_NO_D3 = (__force pci_dev_flags_t) 2,
 	/* Provide indication device is assigned by a Virtual Machine Manager */
 	PCI_DEV_FLAGS_ASSIGNED = (__force pci_dev_flags_t) 4,
+	/* Device causes system crash if in D3 during S3 sleep */
+	PCI_DEV_FLAGS_NO_D3_DURING_SLEEP = (__force pci_dev_flags_t) 8,
 };
 
 enum pci_irq_reroute_variant {
diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 7f855d50cdf5..49b3ac29726a 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -126,8 +126,6 @@ struct usb_hcd {
 	unsigned		wireless:1;	/* Wireless USB HCD */
 	unsigned		authorized_default:1;
 	unsigned		has_tt:1;	/* Integrated TT in root hub */
-	unsigned		broken_pci_sleep:1;	/* Don't put the
-			controller in PCI-D3 for system sleep */
 
 	unsigned int		irq;		/* irq allocated */
 	void __iomem		*regs;		/* device memory/io */</pre><hr><pre>commit 1996e6c572969a8cf6d7fa97eef621219acd94a9
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon May 14 13:48:16 2012 -0400

    USB: EHCI: work around bug in the Philips ISP1562 controller
    
    This patch (as1556) works around a bug in the Philips ISP1562 EHCI
    controller.  Although the controller claims to support frame-list
    lengths smaller than the default of 1024 for its periodic schedule, in
    fact smaller values don't work.  A new quirk flag is added to indicate
    when the bug is present, and if it is then the schedule size is left
    at the default value.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 5cb775b1802d..f644ba9529ed 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -639,7 +639,7 @@ static int ehci_init(struct usb_hcd *hcd)
 	INIT_LIST_HEAD(&amp;ehci-&gt;cached_itd_list);
 	INIT_LIST_HEAD(&amp;ehci-&gt;cached_sitd_list);
 
-	if (HCC_PGM_FRAMELISTLEN(hcc_params)) {
+	if (HCC_PGM_FRAMELISTLEN(hcc_params) &amp;&amp; !ehci-&gt;sched_size_bug) {
 		/* periodic schedule size can be smaller than default */
 		switch (EHCI_TUNE_FLS) {
 		case 0: ehci-&gt;periodic_size = 1024; break;
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index bc94d7bf072d..4baafa3e80b2 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -97,6 +97,13 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 			break;
 		}
 		break;
+
+	case PCI_VENDOR_ID_PHILIPS:
+		/*
+		 * Philips controllers set HCC_PGM_FRAMELISTLEN, but
+		 * they don't implement schedule sizes shorter than 1024.
+		 */
+		ehci-&gt;sched_size_bug = 1;
 	}
 
 	/* cache this readonly data; minimize chip reads */
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 2694ed6558d2..2a6652fd5400 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -149,6 +149,7 @@ struct ehci_hcd {			/* one per controller */
 	unsigned		use_dummy_qh:1;	/* AMD Frame List table quirk*/
 	unsigned		has_synopsys_hc_bug:1; /* Synopsys HC */
 	unsigned		frame_index_bug:1; /* MosChip (AKA NetMos) */
+	unsigned		sched_size_bug:1; /* Philips */
 
 	/* required for usb32 quirk */
 	#define OHCI_CTRL_HCFS          (3 &lt;&lt; 6)</pre><hr><pre>commit 65b8e5cbdddc86474372bdb48dc233b06710a576
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon May 14 13:47:20 2012 -0400

    USB: EHCI: improve full-speed isochronous scheduling routine
    
    This patch (as1555) improves the code ehci-hcd uses while checking the
    periodic schedule for isochronous transfers to full-speed devices.  In
    addition to making sure that a new transfer does not violate the
    restrictions on the high-speed schedule, it also has to check the
    restrictions on the full-speed part of the bus, i.e., the part beyond
    the Transaction Translator (TT).
    
    It does this by calling tt_available() (or tt_no_collision() if
    CONFIG_USB_EHCI_TT_NEWSCHED isn't enabled).  However it calls that
    routine on each pass through a loop over the frames being modified,
    which is an unnecessary expense because tt_available() (or
    tt_no_collision) already does its own loop over frames.  It is
    sufficient to do the check just once, before starting the loop.
    
    In addition, the function calls incorrectly converted the transfer's
    period from microframes to frames by doing a left shift instead of a
    right shift.  The patch fixes this while moving the calls.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index cb7667967e5a..33182c6d1ff9 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -1331,34 +1331,36 @@ sitd_slot_ok (
 	if (mask &amp; ~0xffff)
 		return 0;
 
+	/* check bandwidth */
+	uframe %= period_uframes;
+	frame = uframe &gt;&gt; 3;
+
+#ifdef CONFIG_USB_EHCI_TT_NEWSCHED
+	/* The tt's fullspeed bus bandwidth must be available.
+	 * tt_available scheduling guarantees 10+% for control/bulk.
+	 */
+	uf = uframe &amp; 7;
+	if (!tt_available(ehci, period_uframes &gt;&gt; 3,
+			stream-&gt;udev, frame, uf, stream-&gt;tt_usecs))
+		return 0;
+#else
+	/* tt must be idle for start(s), any gap, and csplit.
+	 * assume scheduling slop leaves 10+% for control/bulk.
+	 */
+	if (!tt_no_collision(ehci, period_uframes &gt;&gt; 3,
+			stream-&gt;udev, frame, mask))
+		return 0;
+#endif
+
 	/* this multi-pass logic is simple, but performance may
 	 * suffer when the schedule data isn't cached.
 	 */
-
-	/* check bandwidth */
-	uframe %= period_uframes;
 	do {
 		u32		max_used;
 
 		frame = uframe &gt;&gt; 3;
 		uf = uframe &amp; 7;
 
-#ifdef CONFIG_USB_EHCI_TT_NEWSCHED
-		/* The tt's fullspeed bus bandwidth must be available.
-		 * tt_available scheduling guarantees 10+% for control/bulk.
-		 */
-		if (!tt_available (ehci, period_uframes &lt;&lt; 3,
-				stream-&gt;udev, frame, uf, stream-&gt;tt_usecs))
-			return 0;
-#else
-		/* tt must be idle for start(s), any gap, and csplit.
-		 * assume scheduling slop leaves 10+% for control/bulk.
-		 */
-		if (!tt_no_collision (ehci, period_uframes &lt;&lt; 3,
-				stream-&gt;udev, frame, mask))
-			return 0;
-#endif
-
 		/* check starts (OUT uses more than one) */
 		max_used = ehci-&gt;uframe_periodic_max - stream-&gt;usecs;
 		for (tmp = stream-&gt;raw_mask &amp; 0xff; tmp; tmp &gt;&gt;= 1, uf++) {</pre><hr><pre>commit 356c05d58af05d582e634b54b40050c73609617b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon May 14 13:30:03 2012 -0400

    sysfs: get rid of some lockdep false positives
    
    This patch (as1554) fixes a lockdep false-positive report.  The
    problem arises because lockdep is unable to deal with the
    tree-structured locks created by the device core and sysfs.
    
    This particular problem involves a sysfs attribute method that
    unregisters itself, not from the device it was called for, but from a
    descendant device.  Lockdep doesn't understand the distinction and
    reports a possible deadlock, even though the operation is safe.
    
    This is the sort of thing that would normally be handled by using a
    nested lock annotation; unfortunately it's not feasible to do that
    here.  There's no sensible way to tell sysfs when attribute removal
    occurs in the context of a parent attribute method.
    
    As a workaround, the patch adds a new flag to struct attribute
    telling sysfs not to inform lockdep when it acquires a readlock on a
    sysfs_dirent instance for the attribute.  The readlock is still
    acquired, but lockdep doesn't know about it and hence does not
    complain about impossible deadlock scenarios.
    
    Also added are macros for static initialization of attribute
    structures with the ignore_lockdep flag set.  The three offending
    attributes in the USB subsystem are converted to use the new macros.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Tejun Heo &lt;tj@kernel.org&gt;
    CC: Eric W. Biederman &lt;ebiederm@xmission.com&gt;
    CC: Peter Zijlstra &lt;peterz@infradead.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c
index 566d9f94f735..9a56e3adf476 100644
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -73,7 +73,7 @@ set_bConfigurationValue(struct device *dev, struct device_attribute *attr,
 	return (value &lt; 0) ? value : count;
 }
 
-static DEVICE_ATTR(bConfigurationValue, S_IRUGO | S_IWUSR,
+static DEVICE_ATTR_IGNORE_LOCKDEP(bConfigurationValue, S_IRUGO | S_IWUSR,
 		show_bConfigurationValue, set_bConfigurationValue);
 
 /* String fields */
@@ -595,7 +595,7 @@ static ssize_t usb_dev_authorized_store(struct device *dev,
 	return result &lt; 0? result : size;
 }
 
-static DEVICE_ATTR(authorized, 0644,
+static DEVICE_ATTR_IGNORE_LOCKDEP(authorized, 0644,
 	    usb_dev_authorized_show, usb_dev_authorized_store);
 
 /* "Safely remove a device" */
@@ -618,7 +618,7 @@ static ssize_t usb_remove_store(struct device *dev,
 	usb_unlock_device(udev);
 	return rc;
 }
-static DEVICE_ATTR(remove, 0200, NULL, usb_remove_store);
+static DEVICE_ATTR_IGNORE_LOCKDEP(remove, 0200, NULL, usb_remove_store);
 
 
 static struct attribute *dev_attrs[] = {
diff --git a/fs/sysfs/dir.c b/fs/sysfs/dir.c
index 24fa995f0312..e6bb9b2a4cbe 100644
--- a/fs/sysfs/dir.c
+++ b/fs/sysfs/dir.c
@@ -132,6 +132,24 @@ static void sysfs_unlink_sibling(struct sysfs_dirent *sd)
 	rb_erase(&amp;sd-&gt;s_rb, &amp;sd-&gt;s_parent-&gt;s_dir.children);
 }
 
+#ifdef CONFIG_DEBUG_LOCK_ALLOC
+
+/* Test for attributes that want to ignore lockdep for read-locking */
+static bool ignore_lockdep(struct sysfs_dirent *sd)
+{
+	return sysfs_type(sd) == SYSFS_KOBJ_ATTR &amp;&amp;
+			sd-&gt;s_attr.attr-&gt;ignore_lockdep;
+}
+
+#else
+
+static inline bool ignore_lockdep(struct sysfs_dirent *sd)
+{
+	return true;
+}
+
+#endif
+
 /**
  *	sysfs_get_active - get an active reference to sysfs_dirent
  *	@sd: sysfs_dirent to get an active reference to
@@ -155,15 +173,17 @@ struct sysfs_dirent *sysfs_get_active(struct sysfs_dirent *sd)
 			return NULL;
 
 		t = atomic_cmpxchg(&amp;sd-&gt;s_active, v, v + 1);
-		if (likely(t == v)) {
-			rwsem_acquire_read(&amp;sd-&gt;dep_map, 0, 1, _RET_IP_);
-			return sd;
-		}
+		if (likely(t == v))
+			break;
 		if (t &lt; 0)
 			return NULL;
 
 		cpu_relax();
 	}
+
+	if (likely(!ignore_lockdep(sd)))
+		rwsem_acquire_read(&amp;sd-&gt;dep_map, 0, 1, _RET_IP_);
+	return sd;
 }
 
 /**
@@ -180,7 +200,8 @@ void sysfs_put_active(struct sysfs_dirent *sd)
 	if (unlikely(!sd))
 		return;
 
-	rwsem_release(&amp;sd-&gt;dep_map, 1, _RET_IP_);
+	if (likely(!ignore_lockdep(sd)))
+		rwsem_release(&amp;sd-&gt;dep_map, 1, _RET_IP_);
 	v = atomic_dec_return(&amp;sd-&gt;s_active);
 	if (likely(v != SD_DEACTIVATED_BIAS))
 		return;
diff --git a/include/linux/device.h b/include/linux/device.h
index a8db2cfa2c81..e04f5776f6d0 100644
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@ -504,6 +504,9 @@ ssize_t device_store_int(struct device *dev, struct device_attribute *attr,
 #define DEVICE_INT_ATTR(_name, _mode, _var) \
 	struct dev_ext_attribute dev_attr_##_name = \
 		{ __ATTR(_name, _mode, device_show_int, device_store_int), &amp;(_var) }
+#define DEVICE_ATTR_IGNORE_LOCKDEP(_name, _mode, _show, _store) \
+	struct device_attribute dev_attr_##_name =		\
+		__ATTR_IGNORE_LOCKDEP(_name, _mode, _show, _store)
 
 extern int device_create_file(struct device *device,
 			      const struct device_attribute *entry);
diff --git a/include/linux/sysfs.h b/include/linux/sysfs.h
index 0010009b2f00..381f06db2fe5 100644
--- a/include/linux/sysfs.h
+++ b/include/linux/sysfs.h
@@ -27,6 +27,7 @@ struct attribute {
 	const char		*name;
 	umode_t			mode;
 #ifdef CONFIG_DEBUG_LOCK_ALLOC
+	bool			ignore_lockdep:1;
 	struct lock_class_key	*key;
 	struct lock_class_key	skey;
 #endif
@@ -80,6 +81,17 @@ struct attribute_group {
 
 #define __ATTR_NULL { .attr = { .name = NULL } }
 
+#ifdef CONFIG_DEBUG_LOCK_ALLOC
+#define __ATTR_IGNORE_LOCKDEP(_name, _mode, _show, _store) {	\
+	.attr = {.name = __stringify(_name), .mode = _mode,	\
+			.ignore_lockdep = true },		\
+	.show		= _show,				\
+	.store		= _store,				\
+}
+#else
+#define __ATTR_IGNORE_LOCKDEP	__ATTR
+#endif
+
 #define attr_name(_attr) (_attr).attr.name
 
 struct file;</pre><hr><pre>commit df767b71e5816692134d59c0c17e0f77cd73333d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 8 15:15:25 2012 -0400

    usb-storage: unusual_devs entry for Yarvik PMP400 MP4 player
    
    This patch (as1553) adds an unusual_dev entrie for the Yarvik PMP400
    MP4 music player.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Jesse Feddema &lt;jdfeddema@gmail.com&gt;
    Tested-by: Jesse Feddema &lt;jdfeddema@gmail.com&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index 856ad92c40de..8f3cbb8dc81b 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -1885,6 +1885,13 @@ UNUSUAL_DEV(  0x1652, 0x6600, 0x0201, 0x0201,
 		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
 		US_FL_IGNORE_RESIDUE ),
 
+/* Reported by Jesse Feddema &lt;jdfeddema@gmail.com&gt; */
+UNUSUAL_DEV(  0x177f, 0x0400, 0x0000, 0x0000,
+		"Yarvik",
+		"PMP400",
+		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
+		US_FL_BULK_IGNORE_TAG | US_FL_MAX_SECTORS_64 ),
+
 /* Reported by Hans de Goede &lt;hdegoede@redhat.com&gt;
  * These Appotech controllers are found in Picture Frames, they provide a
  * (buggy) emulation of a cdrom drive which contains the windows software</pre><hr><pre>commit 1949f9e2435cc2e87c63da167af63faafc49b388
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon May 7 13:22:52 2012 -0400

    USB: xhci-hcd: print URB's expected length in decimal, not hex
    
    This patch changes the output format specifier of a debugging line in
    the xhci-hcd driver.  An URB's transfer_buffer_length should be
    printed in decimal; there's no reason to print it in hex.  Especially
    since the actual_length value, printed earlier on the same line, is
    already in decimal.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: Sarah Sharp &lt;sarah.a.sharp@linux.intel.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c
index d40194c8ca60..329fd2a98dd6 100644
--- a/drivers/usb/host/xhci-ring.c
+++ b/drivers/usb/host/xhci-ring.c
@@ -2272,7 +2272,7 @@ static int handle_tx_event(struct xhci_hcd *xhci,
 					(status != 0 &amp;&amp;
 					 !usb_endpoint_xfer_isoc(&amp;urb-&gt;ep-&gt;desc)))
 				xhci_dbg(xhci, "Giveback URB %p, len = %d, "
-						"expected = %x, status = %d\n",
+						"expected = %d, status = %d\n",
 						urb, urb-&gt;actual_length,
 						urb-&gt;transfer_buffer_length,
 						status);</pre><hr><pre>commit c7f3619b90fc4c43ed326ec8b3f0299374763c92
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon May 7 11:24:05 2012 -0400

    usb-serial: clean up unneeded PM-related fields
    
    This patch (as1551) cleans up the PM-related entries in the usb_driver
    structures of the various USB serial driver modules.  Those entries
    are now filled in by the usb-serial core during driver registration,
    so they don't need to be initialized explicitly in the source code.
    
    The same is true of the one remaining no_dynamic_id entry.
    
    reset_resume remains a small problem, because the serial core doesn't
    support it.  The patch ignores these entries.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/serial/ch341.c b/drivers/usb/serial/ch341.c
index 70c46b0426ff..ba4f067cf277 100644
--- a/drivers/usb/serial/ch341.c
+++ b/drivers/usb/serial/ch341.c
@@ -599,11 +599,8 @@ static struct usb_driver ch341_driver = {
 	.name		= "ch341",
 	.probe		= usb_serial_probe,
 	.disconnect	= usb_serial_disconnect,
-	.suspend	= usb_serial_suspend,
-	.resume		= usb_serial_resume,
 	.reset_resume	= ch341_reset_resume,
 	.id_table	= id_table,
-	.supports_autosuspend =	1,
 };
 
 static struct usb_serial_driver ch341_device = {
diff --git a/drivers/usb/serial/f81232.c b/drivers/usb/serial/f81232.c
index 46aee85210e2..c32486d73a76 100644
--- a/drivers/usb/serial/f81232.c
+++ b/drivers/usb/serial/f81232.c
@@ -355,10 +355,6 @@ static struct usb_driver f81232_driver = {
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	id_table,
-	.suspend =      usb_serial_suspend,
-	.resume =       usb_serial_resume,
-	.no_dynamic_id = 	1,
-	.supports_autosuspend =	1,
 };
 
 static struct usb_serial_driver f81232_device = {
diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c
index ae0b4aa9aa59..d1674bc3d4fa 100644
--- a/drivers/usb/serial/option.c
+++ b/drivers/usb/serial/option.c
@@ -1224,11 +1224,6 @@ static struct usb_driver option_driver = {
 	.name       = "option",
 	.probe      = usb_serial_probe,
 	.disconnect = usb_serial_disconnect,
-#ifdef CONFIG_PM
-	.suspend    = usb_serial_suspend,
-	.resume     = usb_serial_resume,
-	.supports_autosuspend =	1,
-#endif
 	.id_table   = option_ids,
 };
 
diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 9eec2c3574d8..34e51a04dde0 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -100,9 +100,6 @@ static struct usb_driver pl2303_driver = {
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	id_table,
-	.suspend =      usb_serial_suspend,
-	.resume =       usb_serial_resume,
-	.supports_autosuspend =	1,
 };
 
 #define SET_LINE_REQUEST_TYPE		0x21
diff --git a/drivers/usb/serial/qcserial.c b/drivers/usb/serial/qcserial.c
index 201f2810d503..3696924c1eb3 100644
--- a/drivers/usb/serial/qcserial.c
+++ b/drivers/usb/serial/qcserial.c
@@ -117,9 +117,6 @@ static struct usb_driver qcdriver = {
 	.probe			= usb_serial_probe,
 	.disconnect		= usb_serial_disconnect,
 	.id_table		= id_table,
-	.suspend		= usb_serial_suspend,
-	.resume			= usb_serial_resume,
-	.supports_autosuspend	= true,
 };
 
 static int qcprobe(struct usb_serial *serial, const struct usb_device_id *id)
diff --git a/drivers/usb/serial/sierra.c b/drivers/usb/serial/sierra.c
index f298ddaac684..7b7771491a64 100644
--- a/drivers/usb/serial/sierra.c
+++ b/drivers/usb/serial/sierra.c
@@ -1055,11 +1055,8 @@ static struct usb_driver sierra_driver = {
 	.name       = "sierra",
 	.probe      = usb_serial_probe,
 	.disconnect = usb_serial_disconnect,
-	.suspend    = usb_serial_suspend,
-	.resume     = usb_serial_resume,
 	.reset_resume = sierra_reset_resume,
 	.id_table   = id_table,
-	.supports_autosuspend =	1,
 };
 
 static struct usb_serial_driver sierra_device = {
diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index cda513bb01c7..9820492cf885 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -68,9 +68,6 @@ static struct usb_driver ssu100_driver = {
 	.probe			       = usb_serial_probe,
 	.disconnect		       = usb_serial_disconnect,
 	.id_table		       = id_table,
-	.suspend		       = usb_serial_suspend,
-	.resume			       = usb_serial_resume,
-	.supports_autosuspend	       = 1,
 };
 
 struct ssu100_port_private {</pre>
    <div class="pagination">
        <a href='2_47.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><span>[48]</span><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_49.html'>Next&gt;&gt;</a>
    <div>
</body>
