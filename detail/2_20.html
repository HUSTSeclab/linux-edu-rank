<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_19.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><span>[20]</span><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_21.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 113f6eb6d50cfa5e2a1cdcf1678b12661fa272ab
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Sep 21 15:59:30 2017 -0400

    usb-storage: unusual_devs entry to fix write-access regression for Seagate external drives
    
    Kris Lindgren reports that without the NO_WP_DETECT flag, his Seagate
    external disk drive fails all write accesses.  This regresssion dates
    back approximately to the start of the 4.x kernel releases.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Kris Lindgren &lt;kris.lindgren@gmail.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index 5a70c33ef0e0..eb06d88b41d6 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -1459,6 +1459,13 @@ UNUSUAL_DEV( 0x0bc2, 0x3010, 0x0000, 0x0000,
 		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
 		US_FL_SANE_SENSE ),
 
+/* Reported by Kris Lindgren &lt;kris.lindgren@gmail.com&gt; */
+UNUSUAL_DEV( 0x0bc2, 0x3332, 0x0000, 0x9999,
+		"Seagate",
+		"External",
+		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
+		US_FL_NO_WP_DETECT ),
+
 UNUSUAL_DEV(  0x0d49, 0x7310, 0x0000, 0x9999,
 		"Maxtor",
 		"USB to SATA",</pre><hr><pre>commit a4fd4a724d6c30ad671046d83be2e9be2f11d275
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Sep 21 16:02:05 2017 -0400

    usb-storage: fix bogus hardware error messages for ATA pass-thru devices
    
    Ever since commit a621bac3044e ("scsi_lib: correctly retry failed zero
    length REQ_TYPE_FS commands"), people have been getting bogus error
    messages for USB disk drives using ATA pass-thru.  For example:
    
    [ 1344.880193] sd 6:0:0:0: [sdb] Attached SCSI disk
    [ 1345.069152] sd 6:0:0:0: [sdb] tag#0 FAILED Result: hostbyte=DID_ERROR driverbyte=DRIVER_SENSE
    [ 1345.069159] sd 6:0:0:0: [sdb] tag#0 Sense Key : Hardware Error [current] [descriptor]
    [ 1345.069162] sd 6:0:0:0: [sdb] tag#0 Add. Sense: No additional sense information
    [ 1345.069168] sd 6:0:0:0: [sdb] tag#0 CDB: ATA command pass through(16) 85 06 20 00 00 00 00 00 00 00 00 00 00 00 e5 00
    [ 1345.172252] sd 6:0:0:0: [sdb] tag#0 FAILED Result: hostbyte=DID_ERROR driverbyte=DRIVER_SENSE
    [ 1345.172258] sd 6:0:0:0: [sdb] tag#0 Sense Key : Hardware Error [current] [descriptor]
    [ 1345.172261] sd 6:0:0:0: [sdb] tag#0 Add. Sense: No additional sense information
    [ 1345.172266] sd 6:0:0:0: [sdb] tag#0 CDB: ATA command pass through(12)/Blank a1 06 20 da 00 00 4f c2 00 b0 00 00
    
    These messages can be quite annoying, because programs like udisks2
    provoke them every 10 minutes or so.  Other programs can also have
    this effect, such as those in smartmontools.
    
    I don't fully understand how that commit induced the SCSI core to log
    these error messages, but the underlying cause for them is code added
    to usb-storage by commit f1a0743bc0e7 ("USB: storage: When a device
    returns no sense data, call it a Hardware Error").  At the time it was
    necessary to do this, in order to prevent an infinite retry loop with
    some not-so-great mass storage devices.
    
    However, the ATA pass-thru protocol uses SCSI sense data to return
    command status values, and some devices always report Check Condition
    status for ATA pass-thru commands to ensure that the host retrieves
    the sense data, even if the command succeeded.  This violates the USB
    mass-storage protocol (Check Condition status is supposed to mean the
    command failed), but we can't help that.
    
    This patch attempts to mitigate the problem of these bogus error
    reports by changing usb-storage.  The HARDWARE ERROR sense key will be
    inserted only for commands that aren't ATA pass-thru.
    
    Thanks to Ewan Milne for pointing out that this mechanism was present
    in usb-storage.  8 years after writing it, I had completely forgotten
    its existence.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Kris Lindgren &lt;kris.lindgren@gmail.com&gt;
    Ref: https://bugzilla.redhat.com/show_bug.cgi?id=1351305
    CC: Ewan D. Milne &lt;emilne@redhat.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/storage/transport.c b/drivers/usb/storage/transport.c
index 1a59f335b063..a3ccb899df60 100644
--- a/drivers/usb/storage/transport.c
+++ b/drivers/usb/storage/transport.c
@@ -834,13 +834,25 @@ void usb_stor_invoke_transport(struct scsi_cmnd *srb, struct us_data *us)
 			if (result == USB_STOR_TRANSPORT_GOOD) {
 				srb-&gt;result = SAM_STAT_GOOD;
 				srb-&gt;sense_buffer[0] = 0x0;
+			}
+
+			/*
+			 * ATA-passthru commands use sense data to report
+			 * the command completion status, and often devices
+			 * return Check Condition status when nothing is
+			 * wrong.
+			 */
+			else if (srb-&gt;cmnd[0] == ATA_16 ||
+					srb-&gt;cmnd[0] == ATA_12) {
+				/* leave the data alone */
+			}
 
 			/*
 			 * If there was a problem, report an unspecified
 			 * hardware error to prevent the higher layers from
 			 * entering an infinite retry loop.
 			 */
-			} else {
+			else {
 				srb-&gt;result = DID_ERROR &lt;&lt; 16;
 				if ((sshdr.response_code &amp; 0x72) == 0x72)
 					srb-&gt;sense_buffer[1] = HARDWARE_ERROR;</pre><hr><pre>commit afd7fd81f22bf90474216515dbd6088f9bd70343
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Aug 17 14:49:55 2017 -0400

    USB: Gadget core: fix inconsistency in the interface tousb_add_gadget_udc_release()
    
    The usb_add_gadget_udc_release() routine in the USB gadget core will
    sometimes but not always call the gadget's release function when an
    error occurs.  More specifically, if the struct usb_udc allocation
    fails then the release function is not called, and for other errors it
    is.
    
    As a result, users of this routine cannot know whether they need to
    deallocate the memory containing the gadget structure following an
    error.  This leads to unavoidable memory leaks or double frees.
    
    This patch fixes the problem by splitting the existing
    device_register() call into device_initialize() and device_add(), and
    doing the udc allocation in between.  That way, even if the allocation
    fails it is still possible to call device_del(), and so the release
    function will be always called following an error.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Alexey Khoroshilov &lt;khoroshilov@ispras.ru&gt;
    Signed-off-by: Felipe Balbi &lt;felipe.balbi@linux.intel.com&gt;

diff --git a/drivers/usb/gadget/udc/core.c b/drivers/usb/gadget/udc/core.c
index c1cef6a11ecb..75c51ca4ee0f 100644
--- a/drivers/usb/gadget/udc/core.c
+++ b/drivers/usb/gadget/udc/core.c
@@ -1133,6 +1133,7 @@ static int check_pending_gadget_drivers(struct usb_udc *udc)
  * @release: a gadget release function.
  *
  * Returns zero on success, negative errno otherwise.
+ * Calls the gadget release function in the latter case.
  */
 int usb_add_gadget_udc_release(struct device *parent, struct usb_gadget *gadget,
 		void (*release)(struct device *dev))
@@ -1140,10 +1141,6 @@ int usb_add_gadget_udc_release(struct device *parent, struct usb_gadget *gadget,
 	struct usb_udc		*udc;
 	int			ret = -ENOMEM;
 
-	udc = kzalloc(sizeof(*udc), GFP_KERNEL);
-	if (!udc)
-		goto err1;
-
 	dev_set_name(&amp;gadget-&gt;dev, "gadget");
 	INIT_WORK(&amp;gadget-&gt;work, usb_gadget_state_work);
 	gadget-&gt;dev.parent = parent;
@@ -1153,7 +1150,13 @@ int usb_add_gadget_udc_release(struct device *parent, struct usb_gadget *gadget,
 	else
 		gadget-&gt;dev.release = usb_udc_nop_release;
 
-	ret = device_register(&amp;gadget-&gt;dev);
+	device_initialize(&amp;gadget-&gt;dev);
+
+	udc = kzalloc(sizeof(*udc), GFP_KERNEL);
+	if (!udc)
+		goto err1;
+
+	ret = device_add(&amp;gadget-&gt;dev);
 	if (ret)
 		goto err2;
 
@@ -1200,10 +1203,10 @@ int usb_add_gadget_udc_release(struct device *parent, struct usb_gadget *gadget,
 	device_del(&amp;gadget-&gt;dev);
 
 err2:
-	put_device(&amp;gadget-&gt;dev);
 	kfree(udc);
 
 err1:
+	put_device(&amp;gadget-&gt;dev);
 	return ret;
 }
 EXPORT_SYMBOL_GPL(usb_add_gadget_udc_release);</pre><hr><pre>commit 94c43b9897abf4ea366ed4dba027494e080c7050
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Aug 1 10:41:56 2017 -0400

    USB: Check for dropped connection before switching to full speed
    
    Some buggy USB disk adapters disconnect and reconnect multiple times
    during the enumeration procedure.  This may lead to a device
    connecting at full speed instead of high speed, because when the USB
    stack sees that a device isn't able to enumerate at high speed, it
    tries to hand the connection over to a full-speed companion
    controller.
    
    The logic for doing this is careful to check that the device is still
    connected.  But this check is inadequate if the device disconnects and
    reconnects before the check is done.  The symptom is that a device
    works, but much more slowly than it is capable of operating.
    
    The situation was made worse recently by commit 22547c4cc4fe ("usb:
    hub: Wait for connection to be reestablished after port reset"), which
    increases the delay following a reset before a disconnect is
    recognized, thus giving the device more time to reconnect.
    
    This patch makes the check more robust.  If the device was
    disconnected at any time during enumeration, we will now skip the
    full-speed handover.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Zdenek Kabelac &lt;zkabelac@redhat.com&gt;
    Reviewed-by: Guenter Roeck &lt;linux@roeck-us.net&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 6e6797d145dd..822f8c50e423 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -4725,7 +4725,8 @@ hub_power_remaining(struct usb_hub *hub)
 static void hub_port_connect(struct usb_hub *hub, int port1, u16 portstatus,
 		u16 portchange)
 {
-	int status, i;
+	int status = -ENODEV;
+	int i;
 	unsigned unit_load;
 	struct usb_device *hdev = hub-&gt;hdev;
 	struct usb_hcd *hcd = bus_to_hcd(hdev-&gt;bus);
@@ -4929,9 +4930,10 @@ static void hub_port_connect(struct usb_hub *hub, int port1, u16 portstatus,
 
 done:
 	hub_port_disable(hub, port1, 1);
-	if (hcd-&gt;driver-&gt;relinquish_port &amp;&amp; !hub-&gt;hdev-&gt;parent)
-		hcd-&gt;driver-&gt;relinquish_port(hcd, port1);
-
+	if (hcd-&gt;driver-&gt;relinquish_port &amp;&amp; !hub-&gt;hdev-&gt;parent) {
+		if (status != -ENOTCONN &amp;&amp; status != -ENODEV)
+			hcd-&gt;driver-&gt;relinquish_port(hcd, port1);
+	}
 }
 
 /* Handle physical or logical connection change events.</pre><hr><pre>commit 8b52291a0743fc4db4a7495c846a6f31ee84d282
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 26 11:49:19 2017 -0400

    usb-storage: fix deadlock involving host lock and scsi_done
    
    Christoph Hellwig says that since version 4.12, the kernel switched to
    using blk-mq by default.  The old code used a softirq for handling
    request completions, but blk-mq can handle completions in the caller's
    context.  This may cause a problem for usb-storage, because it invokes
    the -&gt;scsi_done callback while holding the host lock, and the
    completion routine sometimes tries to acquire the same lock (when
    running the error handler, for example).
    
    The consequence is that the existing code will sometimes deadlock upon
    error completion of a SCSI command (with a lockdep warning).
    
    This is easy enough to fix, since usb-storage doesn't really need to
    hold the host lock while the callback runs.  It was simpler to write
    it that way, but moving the call outside the locked region is pretty
    easy and there's no downside.  That's what this patch does.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Arthur Marsh &lt;arthur.marsh@internode.on.net&gt;
    CC: Christoph Hellwig &lt;hch@lst.de&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/storage/usb.c b/drivers/usb/storage/usb.c
index 06615934fed1..0dceb9fa3a06 100644
--- a/drivers/usb/storage/usb.c
+++ b/drivers/usb/storage/usb.c
@@ -315,6 +315,7 @@ static int usb_stor_control_thread(void * __us)
 {
 	struct us_data *us = (struct us_data *)__us;
 	struct Scsi_Host *host = us_to_host(us);
+	struct scsi_cmnd *srb;
 
 	for (;;) {
 		usb_stor_dbg(us, "*** thread sleeping\n");
@@ -330,6 +331,7 @@ static int usb_stor_control_thread(void * __us)
 		scsi_lock(host);
 
 		/* When we are called with no command pending, we're done */
+		srb = us-&gt;srb;
 		if (us-&gt;srb == NULL) {
 			scsi_unlock(host);
 			mutex_unlock(&amp;us-&gt;dev_mutex);
@@ -398,14 +400,11 @@ static int usb_stor_control_thread(void * __us)
 		/* lock access to the state */
 		scsi_lock(host);
 
-		/* indicate that the command is done */
-		if (us-&gt;srb-&gt;result != DID_ABORT &lt;&lt; 16) {
-			usb_stor_dbg(us, "scsi cmd done, result=0x%x\n",
-				     us-&gt;srb-&gt;result);
-			us-&gt;srb-&gt;scsi_done(us-&gt;srb);
-		} else {
+		/* was the command aborted? */
+		if (us-&gt;srb-&gt;result == DID_ABORT &lt;&lt; 16) {
 SkipForAbort:
 			usb_stor_dbg(us, "scsi command aborted\n");
+			srb = NULL;	/* Don't call srb-&gt;scsi_done() */
 		}
 
 		/*
@@ -429,6 +428,13 @@ static int usb_stor_control_thread(void * __us)
 
 		/* unlock the device pointers */
 		mutex_unlock(&amp;us-&gt;dev_mutex);
+
+		/* now that the locks are released, notify the SCSI core */
+		if (srb) {
+			usb_stor_dbg(us, "scsi cmd done, result=0x%x\n",
+					srb-&gt;result);
+			srb-&gt;scsi_done(srb);
+		}
 	} /* for (;;) */
 
 	/* Wait until we are told to stop */</pre><hr><pre>commit f16443a034c7aa359ddf6f0f9bc40d01ca31faea
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jun 13 15:23:42 2017 -0400

    USB: gadgetfs, dummy-hcd, net2280: fix locking for callbacks
    
    Using the syzkaller kernel fuzzer, Andrey Konovalov generated the
    following error in gadgetfs:
    
    &gt; BUG: KASAN: use-after-free in __lock_acquire+0x3069/0x3690
    &gt; kernel/locking/lockdep.c:3246
    &gt; Read of size 8 at addr ffff88003a2bdaf8 by task kworker/3:1/903
    &gt;
    &gt; CPU: 3 PID: 903 Comm: kworker/3:1 Not tainted 4.12.0-rc4+ #35
    &gt; Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011
    &gt; Workqueue: usb_hub_wq hub_event
    &gt; Call Trace:
    &gt;  __dump_stack lib/dump_stack.c:16 [inline]
    &gt;  dump_stack+0x292/0x395 lib/dump_stack.c:52
    &gt;  print_address_description+0x78/0x280 mm/kasan/report.c:252
    &gt;  kasan_report_error mm/kasan/report.c:351 [inline]
    &gt;  kasan_report+0x230/0x340 mm/kasan/report.c:408
    &gt;  __asan_report_load8_noabort+0x19/0x20 mm/kasan/report.c:429
    &gt;  __lock_acquire+0x3069/0x3690 kernel/locking/lockdep.c:3246
    &gt;  lock_acquire+0x22d/0x560 kernel/locking/lockdep.c:3855
    &gt;  __raw_spin_lock include/linux/spinlock_api_smp.h:142 [inline]
    &gt;  _raw_spin_lock+0x2f/0x40 kernel/locking/spinlock.c:151
    &gt;  spin_lock include/linux/spinlock.h:299 [inline]
    &gt;  gadgetfs_suspend+0x89/0x130 drivers/usb/gadget/legacy/inode.c:1682
    &gt;  set_link_state+0x88e/0xae0 drivers/usb/gadget/udc/dummy_hcd.c:455
    &gt;  dummy_hub_control+0xd7e/0x1fb0 drivers/usb/gadget/udc/dummy_hcd.c:2074
    &gt;  rh_call_control drivers/usb/core/hcd.c:689 [inline]
    &gt;  rh_urb_enqueue drivers/usb/core/hcd.c:846 [inline]
    &gt;  usb_hcd_submit_urb+0x92f/0x20b0 drivers/usb/core/hcd.c:1650
    &gt;  usb_submit_urb+0x8b2/0x12c0 drivers/usb/core/urb.c:542
    &gt;  usb_start_wait_urb+0x148/0x5b0 drivers/usb/core/message.c:56
    &gt;  usb_internal_control_msg drivers/usb/core/message.c:100 [inline]
    &gt;  usb_control_msg+0x341/0x4d0 drivers/usb/core/message.c:151
    &gt;  usb_clear_port_feature+0x74/0xa0 drivers/usb/core/hub.c:412
    &gt;  hub_port_disable+0x123/0x510 drivers/usb/core/hub.c:4177
    &gt;  hub_port_init+0x1ed/0x2940 drivers/usb/core/hub.c:4648
    &gt;  hub_port_connect drivers/usb/core/hub.c:4826 [inline]
    &gt;  hub_port_connect_change drivers/usb/core/hub.c:4999 [inline]
    &gt;  port_event drivers/usb/core/hub.c:5105 [inline]
    &gt;  hub_event+0x1ae1/0x3d40 drivers/usb/core/hub.c:5185
    &gt;  process_one_work+0xc08/0x1bd0 kernel/workqueue.c:2097
    &gt;  process_scheduled_works kernel/workqueue.c:2157 [inline]
    &gt;  worker_thread+0xb2b/0x1860 kernel/workqueue.c:2233
    &gt;  kthread+0x363/0x440 kernel/kthread.c:231
    &gt;  ret_from_fork+0x2a/0x40 arch/x86/entry/entry_64.S:424
    &gt;
    &gt; Allocated by task 9958:
    &gt;  save_stack_trace+0x1b/0x20 arch/x86/kernel/stacktrace.c:59
    &gt;  save_stack+0x43/0xd0 mm/kasan/kasan.c:513
    &gt;  set_track mm/kasan/kasan.c:525 [inline]
    &gt;  kasan_kmalloc+0xad/0xe0 mm/kasan/kasan.c:617
    &gt;  kmem_cache_alloc_trace+0x87/0x280 mm/slub.c:2745
    &gt;  kmalloc include/linux/slab.h:492 [inline]
    &gt;  kzalloc include/linux/slab.h:665 [inline]
    &gt;  dev_new drivers/usb/gadget/legacy/inode.c:170 [inline]
    &gt;  gadgetfs_fill_super+0x24f/0x540 drivers/usb/gadget/legacy/inode.c:1993
    &gt;  mount_single+0xf6/0x160 fs/super.c:1192
    &gt;  gadgetfs_mount+0x31/0x40 drivers/usb/gadget/legacy/inode.c:2019
    &gt;  mount_fs+0x9c/0x2d0 fs/super.c:1223
    &gt;  vfs_kern_mount.part.25+0xcb/0x490 fs/namespace.c:976
    &gt;  vfs_kern_mount fs/namespace.c:2509 [inline]
    &gt;  do_new_mount fs/namespace.c:2512 [inline]
    &gt;  do_mount+0x41b/0x2d90 fs/namespace.c:2834
    &gt;  SYSC_mount fs/namespace.c:3050 [inline]
    &gt;  SyS_mount+0xb0/0x120 fs/namespace.c:3027
    &gt;  entry_SYSCALL_64_fastpath+0x1f/0xbe
    &gt;
    &gt; Freed by task 9960:
    &gt;  save_stack_trace+0x1b/0x20 arch/x86/kernel/stacktrace.c:59
    &gt;  save_stack+0x43/0xd0 mm/kasan/kasan.c:513
    &gt;  set_track mm/kasan/kasan.c:525 [inline]
    &gt;  kasan_slab_free+0x72/0xc0 mm/kasan/kasan.c:590
    &gt;  slab_free_hook mm/slub.c:1357 [inline]
    &gt;  slab_free_freelist_hook mm/slub.c:1379 [inline]
    &gt;  slab_free mm/slub.c:2961 [inline]
    &gt;  kfree+0xed/0x2b0 mm/slub.c:3882
    &gt;  put_dev+0x124/0x160 drivers/usb/gadget/legacy/inode.c:163
    &gt;  gadgetfs_kill_sb+0x33/0x60 drivers/usb/gadget/legacy/inode.c:2027
    &gt;  deactivate_locked_super+0x8d/0xd0 fs/super.c:309
    &gt;  deactivate_super+0x21e/0x310 fs/super.c:340
    &gt;  cleanup_mnt+0xb7/0x150 fs/namespace.c:1112
    &gt;  __cleanup_mnt+0x1b/0x20 fs/namespace.c:1119
    &gt;  task_work_run+0x1a0/0x280 kernel/task_work.c:116
    &gt;  exit_task_work include/linux/task_work.h:21 [inline]
    &gt;  do_exit+0x18a8/0x2820 kernel/exit.c:878
    &gt;  do_group_exit+0x14e/0x420 kernel/exit.c:982
    &gt;  get_signal+0x784/0x1780 kernel/signal.c:2318
    &gt;  do_signal+0xd7/0x2130 arch/x86/kernel/signal.c:808
    &gt;  exit_to_usermode_loop+0x1ac/0x240 arch/x86/entry/common.c:157
    &gt;  prepare_exit_to_usermode arch/x86/entry/common.c:194 [inline]
    &gt;  syscall_return_slowpath+0x3ba/0x410 arch/x86/entry/common.c:263
    &gt;  entry_SYSCALL_64_fastpath+0xbc/0xbe
    &gt;
    &gt; The buggy address belongs to the object at ffff88003a2bdae0
    &gt;  which belongs to the cache kmalloc-1024 of size 1024
    &gt; The buggy address is located 24 bytes inside of
    &gt;  1024-byte region [ffff88003a2bdae0, ffff88003a2bdee0)
    &gt; The buggy address belongs to the page:
    &gt; page:ffffea0000e8ae00 count:1 mapcount:0 mapping:          (null)
    &gt; index:0x0 compound_mapcount: 0
    &gt; flags: 0x100000000008100(slab|head)
    &gt; raw: 0100000000008100 0000000000000000 0000000000000000 0000000100170017
    &gt; raw: ffffea0000ed3020 ffffea0000f5f820 ffff88003e80efc0 0000000000000000
    &gt; page dumped because: kasan: bad access detected
    &gt;
    &gt; Memory state around the buggy address:
    &gt;  ffff88003a2bd980: fb fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
    &gt;  ffff88003a2bda00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
    &gt; &gt;ffff88003a2bda80: fc fc fc fc fc fc fc fc fc fc fc fc fb fb fb fb
    &gt;                                                                 ^
    &gt;  ffff88003a2bdb00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    &gt;  ffff88003a2bdb80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    &gt; ==================================================================
    
    What this means is that the gadgetfs_suspend() routine was trying to
    access dev-&gt;lock after it had been deallocated.  The root cause is a
    race in the dummy_hcd driver; the dummy_udc_stop() routine can race
    with the rest of the driver because it contains no locking.  And even
    when proper locking is added, it can still race with the
    set_link_state() function because that function incorrectly drops the
    private spinlock before invoking any gadget driver callbacks.
    
    The result of this race, as seen above, is that set_link_state() can
    invoke a callback in gadgetfs even after gadgetfs has been unbound
    from dummy_hcd's UDC and its private data structures have been
    deallocated.
    
    include/linux/usb/gadget.h documents that the -&gt;reset, -&gt;disconnect,
    -&gt;suspend, and -&gt;resume callbacks may be invoked in interrupt context.
    In general this is necessary, to prevent races with gadget driver
    removal.  This patch fixes dummy_hcd to retain the spinlock across
    these calls, and it adds a spinlock acquisition to dummy_udc_stop() to
    prevent the race.
    
    The net2280 driver makes the same mistake of dropping the private
    spinlock for its -&gt;disconnect and -&gt;reset callback invocations.  The
    patch fixes it too.
    
    Lastly, since gadgetfs_suspend() may be invoked in interrupt context,
    it cannot assume that interrupts are enabled when it runs.  It must
    use spin_lock_irqsave() instead of spin_lock_irq().  The patch fixes
    that bug as well.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Andrey Konovalov &lt;andreyknvl@google.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Acked-by: Felipe Balbi &lt;felipe.balbi@linux.intel.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/gadget/legacy/inode.c b/drivers/usb/gadget/legacy/inode.c
index 5ffd879f7886..684900fcfe24 100644
--- a/drivers/usb/gadget/legacy/inode.c
+++ b/drivers/usb/gadget/legacy/inode.c
@@ -1679,9 +1679,10 @@ static void
 gadgetfs_suspend (struct usb_gadget *gadget)
 {
 	struct dev_data		*dev = get_gadget_data (gadget);
+	unsigned long		flags;
 
 	INFO (dev, "suspended from state %d\n", dev-&gt;state);
-	spin_lock (&amp;dev-&gt;lock);
+	spin_lock_irqsave(&amp;dev-&gt;lock, flags);
 	switch (dev-&gt;state) {
 	case STATE_DEV_SETUP:		// VERY odd... host died??
 	case STATE_DEV_CONNECTED:
@@ -1692,7 +1693,7 @@ gadgetfs_suspend (struct usb_gadget *gadget)
 	default:
 		break;
 	}
-	spin_unlock (&amp;dev-&gt;lock);
+	spin_unlock_irqrestore(&amp;dev-&gt;lock, flags);
 }
 
 static struct usb_gadget_driver gadgetfs_driver = {
diff --git a/drivers/usb/gadget/udc/dummy_hcd.c b/drivers/usb/gadget/udc/dummy_hcd.c
index ccabb51cb98d..7635fd7cc328 100644
--- a/drivers/usb/gadget/udc/dummy_hcd.c
+++ b/drivers/usb/gadget/udc/dummy_hcd.c
@@ -442,23 +442,16 @@ static void set_link_state(struct dummy_hcd *dum_hcd)
 		/* Report reset and disconnect events to the driver */
 		if (dum-&gt;driver &amp;&amp; (disconnect || reset)) {
 			stop_activity(dum);
-			spin_unlock(&amp;dum-&gt;lock);
 			if (reset)
 				usb_gadget_udc_reset(&amp;dum-&gt;gadget, dum-&gt;driver);
 			else
 				dum-&gt;driver-&gt;disconnect(&amp;dum-&gt;gadget);
-			spin_lock(&amp;dum-&gt;lock);
 		}
 	} else if (dum_hcd-&gt;active != dum_hcd-&gt;old_active) {
-		if (dum_hcd-&gt;old_active &amp;&amp; dum-&gt;driver-&gt;suspend) {
-			spin_unlock(&amp;dum-&gt;lock);
+		if (dum_hcd-&gt;old_active &amp;&amp; dum-&gt;driver-&gt;suspend)
 			dum-&gt;driver-&gt;suspend(&amp;dum-&gt;gadget);
-			spin_lock(&amp;dum-&gt;lock);
-		} else if (!dum_hcd-&gt;old_active &amp;&amp;  dum-&gt;driver-&gt;resume) {
-			spin_unlock(&amp;dum-&gt;lock);
+		else if (!dum_hcd-&gt;old_active &amp;&amp;  dum-&gt;driver-&gt;resume)
 			dum-&gt;driver-&gt;resume(&amp;dum-&gt;gadget);
-			spin_lock(&amp;dum-&gt;lock);
-		}
 	}
 
 	dum_hcd-&gt;old_status = dum_hcd-&gt;port_status;
@@ -983,7 +976,9 @@ static int dummy_udc_stop(struct usb_gadget *g)
 	struct dummy_hcd	*dum_hcd = gadget_to_dummy_hcd(g);
 	struct dummy		*dum = dum_hcd-&gt;dum;
 
+	spin_lock_irq(&amp;dum-&gt;lock);
 	dum-&gt;driver = NULL;
+	spin_unlock_irq(&amp;dum-&gt;lock);
 
 	return 0;
 }
diff --git a/drivers/usb/gadget/udc/net2280.c b/drivers/usb/gadget/udc/net2280.c
index 6cf07857eaca..f2cbd7f8005e 100644
--- a/drivers/usb/gadget/udc/net2280.c
+++ b/drivers/usb/gadget/udc/net2280.c
@@ -2470,11 +2470,8 @@ static void stop_activity(struct net2280 *dev, struct usb_gadget_driver *driver)
 		nuke(&amp;dev-&gt;ep[i]);
 
 	/* report disconnect; the driver is already quiesced */
-	if (driver) {
-		spin_unlock(&amp;dev-&gt;lock);
+	if (driver)
 		driver-&gt;disconnect(&amp;dev-&gt;gadget);
-		spin_lock(&amp;dev-&gt;lock);
-	}
 
 	usb_reinit(dev);
 }
@@ -3348,8 +3345,6 @@ static void handle_stat0_irqs(struct net2280 *dev, u32 stat)
 		BIT(PCI_RETRY_ABORT_INTERRUPT))
 
 static void handle_stat1_irqs(struct net2280 *dev, u32 stat)
-__releases(dev-&gt;lock)
-__acquires(dev-&gt;lock)
 {
 	struct net2280_ep	*ep;
 	u32			tmp, num, mask, scratch;
@@ -3390,14 +3385,12 @@ __acquires(dev-&gt;lock)
 			if (disconnect || reset) {
 				stop_activity(dev, dev-&gt;driver);
 				ep0_start(dev);
-				spin_unlock(&amp;dev-&gt;lock);
 				if (reset)
 					usb_gadget_udc_reset
 						(&amp;dev-&gt;gadget, dev-&gt;driver);
 				else
 					(dev-&gt;driver-&gt;disconnect)
 						(&amp;dev-&gt;gadget);
-				spin_lock(&amp;dev-&gt;lock);
 				return;
 			}
 		}</pre><hr><pre>commit c01b244ad848ac7f0faa141182db80650a8a761a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jun 5 10:28:01 2017 -0400

    USB: add usbfs ioctl to retrieve the connection speed
    
    The usbfs interface does not provide any way for the user to learn the
    speed at which a device is connected.  The current API includes a
    USBDEVFS_CONNECTINFO ioctl, but all it provides is the device's
    address and a one-bit value indicating whether the connection is low
    speed.  That may have sufficed in the era of USB-1.1, but it isn't
    good enough today.
    
    This patch introduces a new ioctl, USBDEVFS_GET_SPEED, which returns a
    numeric value indicating the speed of the connection: unknown, low,
    full, high, wireless, super, or super-plus.
    
    Similar information (not exactly the same) is available through sysfs,
    but it seems reasonable to provide the actual value in usbfs.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Reinhard Huck &lt;reinhard.huck@thesycon.de&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 8e6ef671be9b..0e7d0e81a7cb 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -2537,6 +2537,9 @@ static long usbdev_do_ioctl(struct file *file, unsigned int cmd,
 	case USBDEVFS_DROP_PRIVILEGES:
 		ret = proc_drop_privileges(ps, p);
 		break;
+	case USBDEVFS_GET_SPEED:
+		ret = ps-&gt;dev-&gt;speed;
+		break;
 	}
 
  done:
diff --git a/include/uapi/linux/usbdevice_fs.h b/include/uapi/linux/usbdevice_fs.h
index a8653a6f40df..0bbfd4abd2e3 100644
--- a/include/uapi/linux/usbdevice_fs.h
+++ b/include/uapi/linux/usbdevice_fs.h
@@ -156,6 +156,11 @@ struct usbdevfs_streams {
 	unsigned char eps[0];
 };
 
+/*
+ * USB_SPEED_* values returned by USBDEVFS_GET_SPEED are defined in
+ * linux/usb/ch9.h
+ */
+
 #define USBDEVFS_CONTROL           _IOWR('U', 0, struct usbdevfs_ctrltransfer)
 #define USBDEVFS_CONTROL32           _IOWR('U', 0, struct usbdevfs_ctrltransfer32)
 #define USBDEVFS_BULK              _IOWR('U', 2, struct usbdevfs_bulktransfer)
@@ -190,5 +195,6 @@ struct usbdevfs_streams {
 #define USBDEVFS_ALLOC_STREAMS     _IOR('U', 28, struct usbdevfs_streams)
 #define USBDEVFS_FREE_STREAMS      _IOR('U', 29, struct usbdevfs_streams)
 #define USBDEVFS_DROP_PRIVILEGES   _IOW('U', 30, __u32)
+#define USBDEVFS_GET_SPEED         _IO('U', 31)
 
 #endif /* _UAPI_LINUX_USBDEVICE_FS_H */</pre><hr><pre>commit f50b878fed33e360d01dcdc31a8eeb1815d033d5
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jun 8 13:55:59 2017 -0400

    USB: gadget: fix GPF in gadgetfs
    
    A NULL-pointer dereference bug in gadgetfs was uncovered by syzkaller:
    
    &gt; kasan: GPF could be caused by NULL-ptr deref or user memory access
    &gt; general protection fault: 0000 [#1] SMP KASAN
    &gt; Dumping ftrace buffer:
    &gt;    (ftrace buffer empty)
    &gt; Modules linked in:
    &gt; CPU: 2 PID: 4820 Comm: syz-executor0 Not tainted 4.12.0-rc4+ #5
    &gt; Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011
    &gt; task: ffff880039542dc0 task.stack: ffff88003bdd0000
    &gt; RIP: 0010:__list_del_entry_valid+0x7e/0x170 lib/list_debug.c:51
    &gt; RSP: 0018:ffff88003bdd6e50 EFLAGS: 00010246
    &gt; RAX: dffffc0000000000 RBX: 0000000000000000 RCX: 0000000000010000
    &gt; RDX: 0000000000000000 RSI: ffffffff86504948 RDI: ffffffff86504950
    &gt; RBP: ffff88003bdd6e68 R08: ffff880039542dc0 R09: ffffffff8778ce00
    &gt; R10: ffff88003bdd6e68 R11: dffffc0000000000 R12: 0000000000000000
    &gt; R13: dffffc0000000000 R14: 1ffff100077badd2 R15: ffffffff864d2e40
    &gt; FS:  0000000000000000(0000) GS:ffff88006dc00000(0000) knlGS:0000000000000000
    &gt; CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    &gt; CR2: 000000002014aff9 CR3: 0000000006022000 CR4: 00000000000006e0
    &gt; Call Trace:
    &gt;  __list_del_entry include/linux/list.h:116 [inline]
    &gt;  list_del include/linux/list.h:124 [inline]
    &gt;  usb_gadget_unregister_driver+0x166/0x4c0 drivers/usb/gadget/udc/core.c:1387
    &gt;  dev_release+0x80/0x160 drivers/usb/gadget/legacy/inode.c:1187
    &gt;  __fput+0x332/0x7f0 fs/file_table.c:209
    &gt;  ____fput+0x15/0x20 fs/file_table.c:245
    &gt;  task_work_run+0x19b/0x270 kernel/task_work.c:116
    &gt;  exit_task_work include/linux/task_work.h:21 [inline]
    &gt;  do_exit+0x18a3/0x2820 kernel/exit.c:878
    &gt;  do_group_exit+0x149/0x420 kernel/exit.c:982
    &gt;  get_signal+0x77f/0x1780 kernel/signal.c:2318
    &gt;  do_signal+0xd2/0x2130 arch/x86/kernel/signal.c:808
    &gt;  exit_to_usermode_loop+0x1a7/0x240 arch/x86/entry/common.c:157
    &gt;  prepare_exit_to_usermode arch/x86/entry/common.c:194 [inline]
    &gt;  syscall_return_slowpath+0x3ba/0x410 arch/x86/entry/common.c:263
    &gt;  entry_SYSCALL_64_fastpath+0xbc/0xbe
    &gt; RIP: 0033:0x4461f9
    &gt; RSP: 002b:00007fdac2b1ecf8 EFLAGS: 00000246 ORIG_RAX: 00000000000000ca
    &gt; RAX: fffffffffffffe00 RBX: 00000000007080c8 RCX: 00000000004461f9
    &gt; RDX: 0000000000000000 RSI: 0000000000000000 RDI: 00000000007080c8
    &gt; RBP: 00000000007080a8 R08: 0000000000000000 R09: 0000000000000000
    &gt; R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000
    &gt; R13: 0000000000000000 R14: 00007fdac2b1f9c0 R15: 00007fdac2b1f700
    &gt; Code: 00 00 00 00 ad de 49 39 c4 74 6a 48 b8 00 02 00 00 00 00 ad de
    &gt; 48 89 da 48 39 c3 74 74 48 c1 ea 03 48 b8 00 00 00 00 00 fc ff df &lt;80&gt;
    &gt; 3c 02 00 0f 85 92 00 00 00 48 8b 13 48 39 f2 75 66 49 8d 7c
    &gt; RIP: __list_del_entry_valid+0x7e/0x170 lib/list_debug.c:51 RSP: ffff88003bdd6e50
    &gt; ---[ end trace 30e94b1eec4831c8 ]---
    &gt; Kernel panic - not syncing: Fatal exception
    
    The bug was caused by dev_release() failing to turn off its
    gadget_registered flag after unregistering the gadget driver.  As a
    result, when a later user closed the device file before writing a
    valid set of descriptors, dev_release() thought the gadget had been
    registered and tried to unregister it, even though it had not been.
    This led to the NULL pointer dereference.
    
    The fix is simple: turn off the flag when the gadget is unregistered.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Andrey Konovalov &lt;andreyknvl@google.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Felipe Balbi &lt;felipe.balbi@linux.intel.com&gt;

diff --git a/drivers/usb/gadget/legacy/inode.c b/drivers/usb/gadget/legacy/inode.c
index b9ca0a26cbd9..5ffd879f7886 100644
--- a/drivers/usb/gadget/legacy/inode.c
+++ b/drivers/usb/gadget/legacy/inode.c
@@ -1183,8 +1183,10 @@ dev_release (struct inode *inode, struct file *fd)
 
 	/* closing ep0 === shutdown all */
 
-	if (dev-&gt;gadget_registered)
+	if (dev-&gt;gadget_registered) {
 		usb_gadget_unregister_driver (&amp;gadgetfs_driver);
+		dev-&gt;gadget_registered = false;
+	}
 
 	/* at this point "good" hardware has disconnected the
 	 * device from USB; the host won't see it any more.</pre><hr><pre>commit 5fcf93795e6b72368cd98cd541b6d4bbe8804320
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 16 11:48:20 2017 -0400

    USB: ene_usb6250: turn off the Removable flag
    
    In the ene_usb6250 sub-driver for usb-storage, the INQUIRY data
    returned by the driver indicates that the device has removable media.
    While this is technically correct (memory cards can be removed from
    the reader), it is not useful because the device automatically
    disconnects itself from the USB bus when no media is present.
    
    In addition, the driver does not support the PREVENT-ALLOW MEDIUM
    REMOVAL and START STOP UNIT commands, and this can cause
    user-interface frameworks to get confused when the user asks for the
    card to be removed or ejected.
    
    This patch fixes the problem by changing the INQUIRY data to specify
    non-removable media; in practice this value works much better.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Andreas Hartmann &lt;andihartmann@01019freenet.de&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/storage/ene_ub6250.c b/drivers/usb/storage/ene_ub6250.c
index a5ccdefed31e..22b850a1ce06 100644
--- a/drivers/usb/storage/ene_ub6250.c
+++ b/drivers/usb/storage/ene_ub6250.c
@@ -596,7 +596,7 @@ static int do_scsi_request_sense(struct us_data *us, struct scsi_cmnd *srb)
 static int do_scsi_inquiry(struct us_data *us, struct scsi_cmnd *srb)
 {
 	unsigned char data_ptr[36] = {
-		0x00, 0x80, 0x02, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x55,
+		0x00, 0x00, 0x02, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x55,
 		0x53, 0x42, 0x32, 0x2E, 0x30, 0x20, 0x20, 0x43, 0x61,
 		0x72, 0x64, 0x52, 0x65, 0x61, 0x64, 0x65, 0x72, 0x20,
 		0x20, 0x20, 0x20, 0x20, 0x20, 0x30, 0x31, 0x30, 0x30 };</pre><hr><pre>commit f8efdabd14532c47e5420dc593c2a13028e42140
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 16 11:48:10 2017 -0400

    USB: ene_usb6250: remove subroutine duplication
    
    In the ene_usb6250 sub-driver for usb-storage, the sd_scsi_inquiry()
    and ms_scsi_inquiry() subroutines (one meant for use with SD memory
    cards and the other for use with MS memory cards) are exact
    duplicates.  This patch removes the duplication by creating a single
    do_scsi_inquiry() command and using it instead of the other two.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Andreas Hartmann &lt;andihartmann@01019freenet.de&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/storage/ene_ub6250.c b/drivers/usb/storage/ene_ub6250.c
index 44aca29ad6cc..a5ccdefed31e 100644
--- a/drivers/usb/storage/ene_ub6250.c
+++ b/drivers/usb/storage/ene_ub6250.c
@@ -593,6 +593,18 @@ static int do_scsi_request_sense(struct us_data *us, struct scsi_cmnd *srb)
 	return USB_STOR_TRANSPORT_GOOD;
 }
 
+static int do_scsi_inquiry(struct us_data *us, struct scsi_cmnd *srb)
+{
+	unsigned char data_ptr[36] = {
+		0x00, 0x80, 0x02, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x55,
+		0x53, 0x42, 0x32, 0x2E, 0x30, 0x20, 0x20, 0x43, 0x61,
+		0x72, 0x64, 0x52, 0x65, 0x61, 0x64, 0x65, 0x72, 0x20,
+		0x20, 0x20, 0x20, 0x20, 0x20, 0x30, 0x31, 0x30, 0x30 };
+
+	usb_stor_set_xfer_buf(data_ptr, 36, srb);
+	return USB_STOR_TRANSPORT_GOOD;
+}
+
 static int sd_scsi_test_unit_ready(struct us_data *us, struct scsi_cmnd *srb)
 {
 	struct ene_ub6250_info *info = (struct ene_ub6250_info *) us-&gt;extra;
@@ -607,18 +619,6 @@ static int sd_scsi_test_unit_ready(struct us_data *us, struct scsi_cmnd *srb)
 	return USB_STOR_TRANSPORT_GOOD;
 }
 
-static int sd_scsi_inquiry(struct us_data *us, struct scsi_cmnd *srb)
-{
-	unsigned char data_ptr[36] = {
-		0x00, 0x80, 0x02, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x55,
-		0x53, 0x42, 0x32, 0x2E, 0x30, 0x20, 0x20, 0x43, 0x61,
-		0x72, 0x64, 0x52, 0x65, 0x61, 0x64, 0x65, 0x72, 0x20,
-		0x20, 0x20, 0x20, 0x20, 0x20, 0x30, 0x31, 0x30, 0x30 };
-
-	usb_stor_set_xfer_buf(data_ptr, 36, srb);
-	return USB_STOR_TRANSPORT_GOOD;
-}
-
 static int sd_scsi_mode_sense(struct us_data *us, struct scsi_cmnd *srb)
 {
 	struct ene_ub6250_info *info = (struct ene_ub6250_info *) us-&gt;extra;
@@ -1462,19 +1462,6 @@ static int ms_scsi_test_unit_ready(struct us_data *us, struct scsi_cmnd *srb)
 	return USB_STOR_TRANSPORT_GOOD;
 }
 
-static int ms_scsi_inquiry(struct us_data *us, struct scsi_cmnd *srb)
-{
-	/* pr_info("MS_SCSI_Inquiry\n"); */
-	unsigned char data_ptr[36] = {
-		0x00, 0x80, 0x02, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x55,
-		0x53, 0x42, 0x32, 0x2E, 0x30, 0x20, 0x20, 0x43, 0x61,
-		0x72, 0x64, 0x52, 0x65, 0x61, 0x64, 0x65, 0x72, 0x20,
-		0x20, 0x20, 0x20, 0x20, 0x20, 0x30, 0x31, 0x30, 0x30};
-
-	usb_stor_set_xfer_buf(data_ptr, 36, srb);
-	return USB_STOR_TRANSPORT_GOOD;
-}
-
 static int ms_scsi_mode_sense(struct us_data *us, struct scsi_cmnd *srb)
 {
 	struct ene_ub6250_info *info = (struct ene_ub6250_info *) us-&gt;extra;
@@ -2236,7 +2223,7 @@ static int sd_scsi_irp(struct us_data *us, struct scsi_cmnd *srb)
 		result = do_scsi_request_sense(us, srb);
 		break; /* 0x03 */
 	case INQUIRY:
-		result = sd_scsi_inquiry(us, srb);
+		result = do_scsi_inquiry(us, srb);
 		break; /* 0x12 */
 	case MODE_SENSE:
 		result = sd_scsi_mode_sense(us, srb);
@@ -2281,7 +2268,7 @@ static int ms_scsi_irp(struct us_data *us, struct scsi_cmnd *srb)
 		result = do_scsi_request_sense(us, srb);
 		break; /* 0x03 */
 	case INQUIRY:
-		result = ms_scsi_inquiry(us, srb);
+		result = do_scsi_inquiry(us, srb);
 		break; /* 0x12 */
 	case MODE_SENSE:
 		result = ms_scsi_mode_sense(us, srb);</pre>
    <div class="pagination">
        <a href='2_19.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><span>[20]</span><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_21.html'>Next&gt;&gt;</a>
    <div>
</body>
