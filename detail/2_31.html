<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_30.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><span>[31]</span><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_32.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 543d7784b07ffd16cc82a9cb4e1e0323fd0040f1
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jan 7 10:43:02 2014 -0500

    USB: fix race between hub_disconnect and recursively_mark_NOTATTACHED
    
    There is a race in the hub driver between hub_disconnect() and
    recursively_mark_NOTATTACHED().  This race can be triggered if the
    driver is unbound from a device at the same time as the bus's root hub
    is removed.  When the race occurs, it can cause an oops:
    
    BUG: unable to handle kernel NULL pointer dereference at 0000015c
    IP: [&lt;c16d5fb0&gt;] recursively_mark_NOTATTACHED+0x20/0x60
    Call Trace:
     [&lt;c16d5fc4&gt;] recursively_mark_NOTATTACHED+0x34/0x60
     [&lt;c16d5fc4&gt;] recursively_mark_NOTATTACHED+0x34/0x60
     [&lt;c16d5fc4&gt;] recursively_mark_NOTATTACHED+0x34/0x60
     [&lt;c16d5fc4&gt;] recursively_mark_NOTATTACHED+0x34/0x60
     [&lt;c16d6082&gt;] usb_set_device_state+0x92/0x120
     [&lt;c16d862b&gt;] usb_disconnect+0x2b/0x1a0
     [&lt;c16dd4c0&gt;] usb_remove_hcd+0xb0/0x160
     [&lt;c19ca846&gt;] ? _raw_spin_unlock_irqrestore+0x26/0x50
     [&lt;c1704efc&gt;] ehci_mid_remove+0x1c/0x30
     [&lt;c1704f26&gt;] ehci_mid_stop_host+0x16/0x30
     [&lt;c16f7698&gt;] penwell_otg_work+0xd28/0x3520
     [&lt;c19c945b&gt;] ? __schedule+0x39b/0x7f0
     [&lt;c19cdb9d&gt;] ? sub_preempt_count+0x3d/0x50
     [&lt;c125e97d&gt;] process_one_work+0x11d/0x3d0
     [&lt;c19c7f4d&gt;] ? mutex_unlock+0xd/0x10
     [&lt;c125e0e5&gt;] ? manage_workers.isra.24+0x1b5/0x270
     [&lt;c125f009&gt;] worker_thread+0xf9/0x320
     [&lt;c19ca846&gt;] ? _raw_spin_unlock_irqrestore+0x26/0x50
     [&lt;c125ef10&gt;] ? rescuer_thread+0x2b0/0x2b0
     [&lt;c1264ac4&gt;] kthread+0x94/0xa0
     [&lt;c19d0f77&gt;] ret_from_kernel_thread+0x1b/0x28
     [&lt;c1264a30&gt;] ? kthread_create_on_node+0xc0/0xc0
    
    One problem is that recursively_mark_NOTATTACHED() uses the intfdata
    value and hub-&gt;hdev-&gt;maxchild while hub_disconnect() is clearing them.
    Another problem is that it uses hub-&gt;ports[i] while the port device is
    being released.
    
    To fix this race, we need to hold the device_state_lock while
    hub_disconnect() changes the values.  (Note that usb_disconnect()
    and hub_port_connect_change() already acquire this lock at similar
    critical times during a USB device's life cycle.)  We also need to
    remove the port devices after maxchild has been set to 0, instead of
    before.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: "Du, Changbin" &lt;changbinx.du@intel.com&gt;
    Tested-by: "Du, Changbin" &lt;changbinx.du@intel.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 92e052db27ac..9e49c6d6e4a2 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1600,7 +1600,7 @@ static void hub_disconnect(struct usb_interface *intf)
 {
 	struct usb_hub *hub = usb_get_intfdata(intf);
 	struct usb_device *hdev = interface_to_usbdev(intf);
-	int i;
+	int port1;
 
 	/* Take the hub off the event list and don't let it be added again */
 	spin_lock_irq(&amp;hub_event_lock);
@@ -1615,11 +1615,15 @@ static void hub_disconnect(struct usb_interface *intf)
 	hub-&gt;error = 0;
 	hub_quiesce(hub, HUB_DISCONNECT);
 
-	usb_set_intfdata (intf, NULL);
+	/* Avoid races with recursively_mark_NOTATTACHED() */
+	spin_lock_irq(&amp;device_state_lock);
+	port1 = hdev-&gt;maxchild;
+	hdev-&gt;maxchild = 0;
+	usb_set_intfdata(intf, NULL);
+	spin_unlock_irq(&amp;device_state_lock);
 
-	for (i = 0; i &lt; hdev-&gt;maxchild; i++)
-		usb_hub_remove_port_device(hub, i + 1);
-	hub-&gt;hdev-&gt;maxchild = 0;
+	for (; port1 &gt; 0; --port1)
+		usb_hub_remove_port_device(hub, port1);
 
 	if (hub-&gt;hdev-&gt;speed == USB_SPEED_HIGH)
 		highspeed_hubs--;</pre><hr><pre>commit a535d81c92615b8ffb99b7e1fd1fb01effaed1af
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Nov 1 12:05:12 2013 -0400

    usb: dwc3: fix implementation of endpoint wedge
    
    The dwc3 UDC driver doesn't implement endpoint wedging correctly.
    When an endpoint is wedged, the gadget driver should be allowed to
    clear the wedge by calling usb_ep_clear_halt().  Only the host is
    prevented from resetting the endpoint.
    
    This patch fixes the implementation.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Pratyush Anand &lt;pratyush.anand@st.com&gt;
    Cc: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Felipe Balbi &lt;balbi@ti.com&gt;

diff --git a/drivers/usb/dwc3/ep0.c b/drivers/usb/dwc3/ep0.c
index 95f7649c71a7..21a352079bc2 100644
--- a/drivers/usb/dwc3/ep0.c
+++ b/drivers/usb/dwc3/ep0.c
@@ -459,6 +459,8 @@ static int dwc3_ep0_handle_feature(struct dwc3 *dwc,
 			dep = dwc3_wIndex_to_dep(dwc, wIndex);
 			if (!dep)
 				return -EINVAL;
+			if (set == 0 &amp;&amp; (dep-&gt;flags &amp; DWC3_EP_WEDGE))
+				break;
 			ret = __dwc3_gadget_ep_set_halt(dep, set);
 			if (ret)
 				return -EINVAL;
diff --git a/drivers/usb/dwc3/gadget.c b/drivers/usb/dwc3/gadget.c
index 5452c0fce360..02e44fcaf205 100644
--- a/drivers/usb/dwc3/gadget.c
+++ b/drivers/usb/dwc3/gadget.c
@@ -1200,9 +1200,6 @@ int __dwc3_gadget_ep_set_halt(struct dwc3_ep *dep, int value)
 		else
 			dep-&gt;flags |= DWC3_EP_STALL;
 	} else {
-		if (dep-&gt;flags &amp; DWC3_EP_WEDGE)
-			return 0;
-
 		ret = dwc3_send_gadget_ep_cmd(dwc, dep-&gt;number,
 			DWC3_DEPCMD_CLEARSTALL, &amp;params);
 		if (ret)
@@ -1210,7 +1207,7 @@ int __dwc3_gadget_ep_set_halt(struct dwc3_ep *dep, int value)
 					value ? "set" : "clear",
 					dep-&gt;name);
 		else
-			dep-&gt;flags &amp;= ~DWC3_EP_STALL;
+			dep-&gt;flags &amp;= ~(DWC3_EP_STALL | DWC3_EP_WEDGE);
 	}
 
 	return ret;</pre><hr><pre>commit 1c124c9962b4ee6555fd6179ca318c2ad3a30354
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Oct 18 11:19:18 2013 -0400

    USB: UHCI: check for wakeup/suspend race
    
    hcd-pci.c in usbcore contains a check for wakeup requests racing with
    controller suspend.  This check is going to be moved out of usbcore
    and into the individual controller drivers, where it can apply to all
    platforms, not just PCI.
    
    This patch adds the check to uhci-hcd.  Ironically, none of the
    non-PCI platform drivers for uhci-hcd implement suspend/resume.
    Nevertheless, this change is needed to accomodate the upcoming change
    to usbcore.
    
    The patch also removes an outdated check of the root hub state.  For
    one thing, the PM layer has long been quite reliable about suspending
    root hubs before controllers.  For another, virtually the same check
    is also made in hcd-pci.c; there's no point in repeating it.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/uhci-pci.c b/drivers/usb/host/uhci-pci.c
index 8de0da0e6dfc..4cd79888804b 100644
--- a/drivers/usb/host/uhci-pci.c
+++ b/drivers/usb/host/uhci-pci.c
@@ -162,6 +162,8 @@ static void uhci_shutdown(struct pci_dev *pdev)
 
 #ifdef CONFIG_PM
 
+static int uhci_pci_resume(struct usb_hcd *hcd, bool hibernated);
+
 static int uhci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
@@ -174,12 +176,6 @@ static int uhci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)
 	if (!HCD_HW_ACCESSIBLE(hcd) || uhci-&gt;dead)
 		goto done_okay;		/* Already suspended or dead */
 
-	if (uhci-&gt;rh_state &gt; UHCI_RH_SUSPENDED) {
-		dev_warn(uhci_dev(uhci), "Root hub isn't suspended!\n");
-		rc = -EBUSY;
-		goto done;
-	}
-
 	/* All PCI host controllers are required to disable IRQ generation
 	 * at the source, so we must turn off PIRQ.
 	 */
@@ -195,8 +191,15 @@ static int uhci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)
 
 done_okay:
 	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
-done:
 	spin_unlock_irq(&amp;uhci-&gt;lock);
+
+	synchronize_irq(hcd-&gt;irq);
+
+	/* Check for race with a wakeup request */
+	if (do_wakeup &amp;&amp; HCD_WAKEUP_PENDING(hcd)) {
+		uhci_pci_resume(hcd, false);
+		rc = -EBUSY;
+	}
 	return rc;
 }
 </pre><hr><pre>commit b8efdafb4005a79ab2305f8af31025d49292d4cf
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Oct 18 11:18:21 2013 -0400

    USB: EHCI: add check for wakeup/suspend race
    
    hcd-pci.c in usbcore contains a check for wakeup requests racing with
    controller suspend.  This check is going to be moved out of usbcore
    and into the individual controller drivers, where it can apply to all
    platforms, not just PCI.
    
    This patch adds the check to ehci-hcd.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index e66706aa9f0c..e8ba4c44223a 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1095,6 +1095,14 @@ int ehci_suspend(struct usb_hcd *hcd, bool do_wakeup)
 	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
 	spin_unlock_irq(&amp;ehci-&gt;lock);
 
+	synchronize_irq(hcd-&gt;irq);
+
+	/* Check for race with a wakeup request */
+	if (do_wakeup &amp;&amp; HCD_WAKEUP_PENDING(hcd)) {
+		ehci_resume(hcd, false);
+		return -EBUSY;
+	}
+
 	return 0;
 }
 EXPORT_SYMBOL_GPL(ehci_suspend);</pre><hr><pre>commit 0a56b4fa6844f74976d4bfa4956fa6d606b392ea
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Oct 18 11:17:21 2013 -0400

    USB: change dev_warn about missing reset-resume to dev_dbg
    
    This patch changes a dev_warn() call in usbcore to dev_dbg().  It's
    not necessary to warn about drivers missing a reset-resume callback,
    since the reset-resume method is optional.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Clemens Ladisch &lt;clemens@ladisch.de&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 689433cdef25..47aade2a5e74 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -1179,8 +1179,8 @@ static int usb_resume_interface(struct usb_device *udev,
 						"reset_resume", status);
 		} else {
 			intf-&gt;needs_binding = 1;
-			dev_warn(&amp;intf-&gt;dev, "no %s for driver %s?\n",
-					"reset_resume", driver-&gt;name);
+			dev_dbg(&amp;intf-&gt;dev, "no reset_resume for driver %s?\n",
+					driver-&gt;name);
 		}
 	} else {
 		status = driver-&gt;resume(intf);</pre><hr><pre>commit 7c71c6e6befd4b234e166f2f40d4430bacc779e6
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Oct 18 11:16:07 2013 -0400

    USB: OHCI: fix and explain sparse errors
    
    This patch fixes an endian-related error in ohci-hcd (detected by
    sparse) and clarifies a comment explaining a peculiar locking
    arrangement that sparse warns about.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ohci-hub.c b/drivers/usb/host/ohci-hub.c
index 2347ab83f046..61705a760e7d 100644
--- a/drivers/usb/host/ohci-hub.c
+++ b/drivers/usb/host/ohci-hub.c
@@ -212,10 +212,11 @@ __acquires(ohci-&gt;lock)
 	/* Sometimes PCI D3 suspend trashes frame timings ... */
 	periodic_reinit (ohci);
 
-	/* the following code is executed with ohci-&gt;lock held and
-	 * irqs disabled if and only if autostopped is true
+	/*
+	 * The following code is executed with ohci-&gt;lock held and
+	 * irqs disabled if and only if autostopped is true.  This
+	 * will cause sparse to warn about a "context imbalance".
 	 */
-
 skip_resume:
 	/* interrupts might have been disabled */
 	ohci_writel (ohci, OHCI_INTR_INIT, &amp;ohci-&gt;regs-&gt;intrenable);
@@ -531,7 +532,7 @@ ohci_hub_descriptor (
 	    temp |= 0x0010;
 	else if (rh &amp; RH_A_OCPM)	/* per-port overcurrent reporting? */
 	    temp |= 0x0008;
-	desc-&gt;wHubCharacteristics = (__force __u16)cpu_to_hc16(ohci, temp);
+	desc-&gt;wHubCharacteristics = cpu_to_le16(temp);
 
 	/* ports removable, and usb 1.0 legacy PortPwrCtrlMask */
 	rh = roothub_b (ohci);</pre><hr><pre>commit 4a71f242e51767e75c7ecdba890debab2c0dceaf
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Oct 18 11:15:14 2013 -0400

    USB: EHCI: fix sparse errors
    
    This patch fixes several sparse errors in ehci-hcd introduced by
    commit 3d091a6f7039 (USB: EHCI: AMD periodic frame list table quirk).
    Although the problem fixed by that commit affects only little-endian
    systems, the source code has to use types appropriate for big-endian
    too.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-mem.c b/drivers/usb/host/ehci-mem.c
index 52a77734a225..c0fb6a8ae6a3 100644
--- a/drivers/usb/host/ehci-mem.c
+++ b/drivers/usb/host/ehci-mem.c
@@ -224,11 +224,11 @@ static int ehci_mem_init (struct ehci_hcd *ehci, gfp_t flags)
 		hw-&gt;hw_next = EHCI_LIST_END(ehci);
 		hw-&gt;hw_qtd_next = EHCI_LIST_END(ehci);
 		hw-&gt;hw_alt_next = EHCI_LIST_END(ehci);
-		hw-&gt;hw_token &amp;= ~QTD_STS_ACTIVE;
 		ehci-&gt;dummy-&gt;hw = hw;
 
 		for (i = 0; i &lt; ehci-&gt;periodic_size; i++)
-			ehci-&gt;periodic[i] = ehci-&gt;dummy-&gt;qh_dma;
+			ehci-&gt;periodic[i] = cpu_to_hc32(ehci,
+					ehci-&gt;dummy-&gt;qh_dma);
 	} else {
 		for (i = 0; i &lt; ehci-&gt;periodic_size; i++)
 			ehci-&gt;periodic[i] = EHCI_LIST_END(ehci);
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index fbeb82e552b8..e113fd73aeae 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -103,7 +103,7 @@ static void periodic_unlink (struct ehci_hcd *ehci, unsigned frame, void *ptr)
 		*hw_p = *shadow_next_periodic(ehci, &amp;here,
 				Q_NEXT_TYPE(ehci, *hw_p));
 	else
-		*hw_p = ehci-&gt;dummy-&gt;qh_dma;
+		*hw_p = cpu_to_hc32(ehci, ehci-&gt;dummy-&gt;qh_dma);
 }
 
 /*-------------------------------------------------------------------------*/
@@ -2446,7 +2446,8 @@ static void scan_isoc(struct ehci_hcd *ehci)
 				    q.itd-&gt;hw_next != EHCI_LIST_END(ehci))
 					*hw_p = q.itd-&gt;hw_next;
 				else
-					*hw_p = ehci-&gt;dummy-&gt;qh_dma;
+					*hw_p = cpu_to_hc32(ehci,
+							ehci-&gt;dummy-&gt;qh_dma);
 				type = Q_NEXT_TYPE(ehci, q.itd-&gt;hw_next);
 				wmb();
 				modified = itd_complete (ehci, q.itd);
@@ -2481,7 +2482,8 @@ static void scan_isoc(struct ehci_hcd *ehci)
 				    q.sitd-&gt;hw_next != EHCI_LIST_END(ehci))
 					*hw_p = q.sitd-&gt;hw_next;
 				else
-					*hw_p = ehci-&gt;dummy-&gt;qh_dma;
+					*hw_p = cpu_to_hc32(ehci,
+							ehci-&gt;dummy-&gt;qh_dma);
 				type = Q_NEXT_TYPE(ehci, q.sitd-&gt;hw_next);
 				wmb();
 				modified = sitd_complete (ehci, q.sitd);</pre><hr><pre>commit 5d8f681f3d14880d5b509eb32a910ba90ef28c36
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Oct 18 11:13:08 2013 -0400

    USB: EHCI: fix type mismatch in check_intr_schedule
    
    This patch fixes a type mismatch in ehci-hcd caused by commit
    b35c5009bbf6 (USB: EHCI: create per-TT bandwidth tables).  The c_maskp
    parameter in check_intr_schedule() was changed to point to unsigned
    int rather than __hc32, but the prototype declaration wasn't adjusted
    accordingly.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: kbuild test robot &lt;fengguang.wu@intel.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 7ce5c2a2fe31..fbeb82e552b8 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -794,7 +794,7 @@ static int check_intr_schedule (
 	unsigned		frame,
 	unsigned		uframe,
 	struct ehci_qh		*qh,
-	__hc32			*c_maskp,
+	unsigned		*c_maskp,
 	struct ehci_tt		*tt
 )
 {</pre><hr><pre>commit a393a807d0c805e7c723315ff0e88a857055e9c6
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Oct 11 11:29:36 2013 -0400

    USB: EHCI: start new isochronous streams ASAP
    
    This patch changes the initial delay before the startup of a newly
    scheduled isochronous stream.  Currently the stream doesn't start
    for at least 5 ms (40 microframes).  This value is just an estimate;
    it has no real justification.
    
    Instead, we can start the stream as soon as possible after the
    scheduling computations are complete.  Essentially this requires
    nothing more than reading the frame counter after the stream is
    scheduled, instead of before.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index b5f957d322e3..7ce5c2a2fe31 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -1491,8 +1491,6 @@ sitd_slot_ok (
  * given EHCI_TUNE_FLS and the slop).  Or, write a smarter scheduler!
  */
 
-#define SCHEDULING_DELAY	40	/* microframes */
-
 static int
 iso_stream_schedule (
 	struct ehci_hcd		*ehci,
@@ -1506,27 +1504,13 @@ iso_stream_schedule (
 	unsigned		mod = ehci-&gt;periodic_size &lt;&lt; 3;
 	struct ehci_iso_sched	*sched = urb-&gt;hcpriv;
 	bool			empty = list_empty(&amp;stream-&gt;td_list);
+	bool			new_stream = false;
 
 	period = stream-&gt;uperiod;
 	span = sched-&gt;span;
 	if (!stream-&gt;highspeed)
 		span &lt;&lt;= 3;
 
-	now = ehci_read_frame_index(ehci) &amp; (mod - 1);
-
-	/* Take the isochronous scheduling threshold into account */
-	if (ehci-&gt;i_thresh)
-		next = now + ehci-&gt;i_thresh;	/* uframe cache */
-	else
-		next = (now + 2 + 7) &amp; ~0x07;	/* full frame cache */
-
-	/*
-	 * Use ehci-&gt;last_iso_frame as the base.  There can't be any
-	 * TDs scheduled for earlier than that.
-	 */
-	base = ehci-&gt;last_iso_frame &lt;&lt; 3;
-	next = (next - base) &amp; (mod - 1);
-
 	/* Start a new isochronous stream? */
 	if (unlikely(empty &amp;&amp; !hcd_periodic_completion_in_progress(
 			ehci_to_hcd(ehci), urb-&gt;ep))) {
@@ -1542,7 +1526,7 @@ iso_stream_schedule (
 			}
 			compute_tt_budget(ehci-&gt;tt_budget, tt);
 
-			start = (now &amp; ~0x07) + SCHEDULING_DELAY;
+			start = ((-(++ehci-&gt;random_frame)) &lt;&lt; 3) &amp; (period - 1);
 
 			/* find a uframe slot with enough bandwidth.
 			 * Early uframes are more precious because full-speed
@@ -1585,17 +1569,35 @@ iso_stream_schedule (
 			start = (stream-&gt;ps.phase &lt;&lt; 3) + stream-&gt;ps.phase_uf;
 		}
 
-		start = (start - base) &amp; (mod - 1);
-		goto use_start;
+		stream-&gt;next_uframe = start;
+		new_stream = true;
 	}
 
+	now = ehci_read_frame_index(ehci) &amp; (mod - 1);
+
+	/* Take the isochronous scheduling threshold into account */
+	if (ehci-&gt;i_thresh)
+		next = now + ehci-&gt;i_thresh;	/* uframe cache */
+	else
+		next = (now + 2 + 7) &amp; ~0x07;	/* full frame cache */
+
+	/*
+	 * Use ehci-&gt;last_iso_frame as the base.  There can't be any
+	 * TDs scheduled for earlier than that.
+	 */
+	base = ehci-&gt;last_iso_frame &lt;&lt; 3;
+	next = (next - base) &amp; (mod - 1);
+	start = (stream-&gt;next_uframe - base) &amp; (mod - 1);
+
+	if (unlikely(new_stream))
+		goto do_ASAP;
+
 	/*
 	 * Typical case: reuse current schedule, stream may still be active.
 	 * Hopefully there are no gaps from the host falling behind
 	 * (irq delays etc).  If there are, the behavior depends on
 	 * whether URB_ISO_ASAP is set.
 	 */
-	start = (stream-&gt;next_uframe - base) &amp; (mod - 1);
 	now2 = (now - base) &amp; (mod - 1);
 
 	/* Is the schedule already full? */</pre><hr><pre>commit b35c5009bbf619d8885b4b3c8b102d09002acfe5
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Oct 11 22:16:21 2013 -0400

    USB: EHCI: create per-TT bandwidth tables
    
    This patch continues the scheduling changes in ehci-hcd by adding a
    table to store the bandwidth allocation below each TT.  This will
    speed up the scheduling code, as it will no longer need to read
    through the entire schedule to compute the bandwidth currently in use.
    
    Properly speaking, the FS/LS budget calculations should be done in
    terms of full-speed bytes per microframe, as described in the USB-2
    spec.  However the driver currently uses microseconds per microframe,
    and the scheduling code isn't robust enough at this point to change
    over.  For the time being, we leave the calculations as they are.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-dbg.c b/drivers/usb/host/ehci-dbg.c
index 5bbfb1f9929c..4a9c2edbcb2b 100644
--- a/drivers/usb/host/ehci-dbg.c
+++ b/drivers/usb/host/ehci-dbg.c
@@ -536,10 +536,14 @@ static ssize_t fill_async_buffer(struct debug_buffer *buf)
 static ssize_t fill_bandwidth_buffer(struct debug_buffer *buf)
 {
 	struct ehci_hcd		*ehci;
+	struct ehci_tt		*tt;
+	struct ehci_per_sched	*ps;
 	unsigned		temp, size;
 	char			*next;
 	unsigned		i;
 	u8			*bw;
+	u16			*bf;
+	u8			budget[EHCI_BANDWIDTH_SIZE];
 
 	ehci = hcd_to_ehci(bus_to_hcd(buf-&gt;bus));
 	next = buf-&gt;output_buf;
@@ -563,6 +567,50 @@ static ssize_t fill_bandwidth_buffer(struct debug_buffer *buf)
 		size -= temp;
 		next += temp;
 	}
+
+	/* Dump all the FS/LS tables */
+	list_for_each_entry(tt, &amp;ehci-&gt;tt_list, tt_list) {
+		temp = scnprintf(next, size,
+				"\nTT %s port %d  FS/LS bandwidth allocation (us per frame)\n",
+				dev_name(&amp;tt-&gt;usb_tt-&gt;hub-&gt;dev),
+				tt-&gt;tt_port + !!tt-&gt;usb_tt-&gt;multi);
+		size -= temp;
+		next += temp;
+
+		bf = tt-&gt;bandwidth;
+		temp = scnprintf(next, size,
+				"  %5u%5u%5u%5u%5u%5u%5u%5u\n",
+				bf[0], bf[1], bf[2], bf[3],
+					bf[4], bf[5], bf[6], bf[7]);
+		size -= temp;
+		next += temp;
+
+		temp = scnprintf(next, size,
+				"FS/LS budget (us per microframe)\n");
+		size -= temp;
+		next += temp;
+		compute_tt_budget(budget, tt);
+		for (i = 0; i &lt; EHCI_BANDWIDTH_SIZE; i += 8) {
+			bw = &amp;budget[i];
+			temp = scnprintf(next, size,
+					"%2u: %4u%4u%4u%4u%4u%4u%4u%4u\n",
+					i, bw[0], bw[1], bw[2], bw[3],
+						bw[4], bw[5], bw[6], bw[7]);
+			size -= temp;
+			next += temp;
+		}
+		list_for_each_entry(ps, &amp;tt-&gt;ps_list, ps_list) {
+			temp = scnprintf(next, size,
+					"%s ep %02x:  %4u @ %2u.%u+%u mask %04x\n",
+					dev_name(&amp;ps-&gt;udev-&gt;dev),
+					ps-&gt;ep-&gt;desc.bEndpointAddress,
+					ps-&gt;tt_usecs,
+					ps-&gt;bw_phase, ps-&gt;phase_uf,
+					ps-&gt;bw_period, ps-&gt;cs_mask);
+			size -= temp;
+			next += temp;
+		}
+	}
 	spin_unlock_irq(&amp;ehci-&gt;lock);
 
 	return next - buf-&gt;output_buf;
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 398e8fa3032f..e66706aa9f0c 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -110,6 +110,9 @@ MODULE_PARM_DESC (ignore_oc, "ignore bogus hardware overcurrent indications");
 #include "ehci.h"
 #include "pci-quirks.h"
 
+static void compute_tt_budget(u8 budget_table[EHCI_BANDWIDTH_SIZE],
+		struct ehci_tt *tt);
+
 /*
  * The MosChip MCS9990 controller updates its microframe counter
  * a little before the frame counter, and occasionally we will read
@@ -484,6 +487,7 @@ static int ehci_init(struct usb_hcd *hcd)
 	INIT_LIST_HEAD(&amp;ehci-&gt;intr_qh_list);
 	INIT_LIST_HEAD(&amp;ehci-&gt;cached_itd_list);
 	INIT_LIST_HEAD(&amp;ehci-&gt;cached_sitd_list);
+	INIT_LIST_HEAD(&amp;ehci-&gt;tt_list);
 
 	if (HCC_PGM_FRAMELISTLEN(hcc_params)) {
 		/* periodic schedule size can be smaller than default */
@@ -1051,6 +1055,19 @@ static int ehci_get_frame (struct usb_hcd *hcd)
 
 /*-------------------------------------------------------------------------*/
 
+/* Device addition and removal */
+
+static void ehci_remove_device(struct usb_hcd *hcd, struct usb_device *udev)
+{
+	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
+
+	spin_lock_irq(&amp;ehci-&gt;lock);
+	drop_tt(udev);
+	spin_unlock_irq(&amp;ehci-&gt;lock);
+}
+
+/*-------------------------------------------------------------------------*/
+
 #ifdef	CONFIG_PM
 
 /* suspend/resume, section 4.3 */
@@ -1194,6 +1211,11 @@ static const struct hc_driver ehci_hc_driver = {
 	.bus_resume =		ehci_bus_resume,
 	.relinquish_port =	ehci_relinquish_port,
 	.port_handed_over =	ehci_port_handed_over,
+
+	/*
+	 * device support
+	 */
+	.free_dev =		ehci_remove_device,
 };
 
 void ehci_init_driver(struct hc_driver *drv,
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 790a64c0da5c..b5f957d322e3 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -106,6 +106,103 @@ static void periodic_unlink (struct ehci_hcd *ehci, unsigned frame, void *ptr)
 		*hw_p = ehci-&gt;dummy-&gt;qh_dma;
 }
 
+/*-------------------------------------------------------------------------*/
+
+/* Bandwidth and TT management */
+
+/* Find the TT data structure for this device; create it if necessary */
+static struct ehci_tt *find_tt(struct usb_device *udev)
+{
+	struct usb_tt		*utt = udev-&gt;tt;
+	struct ehci_tt		*tt, **tt_index, **ptt;
+	unsigned		port;
+	bool			allocated_index = false;
+
+	if (!utt)
+		return NULL;		/* Not below a TT */
+
+	/*
+	 * Find/create our data structure.
+	 * For hubs with a single TT, we get it directly.
+	 * For hubs with multiple TTs, there's an extra level of pointers.
+	 */
+	tt_index = NULL;
+	if (utt-&gt;multi) {
+		tt_index = utt-&gt;hcpriv;
+		if (!tt_index) {		/* Create the index array */
+			tt_index = kzalloc(utt-&gt;hub-&gt;maxchild *
+					sizeof(*tt_index), GFP_ATOMIC);
+			if (!tt_index)
+				return ERR_PTR(-ENOMEM);
+			utt-&gt;hcpriv = tt_index;
+			allocated_index = true;
+		}
+		port = udev-&gt;ttport - 1;
+		ptt = &amp;tt_index[port];
+	} else {
+		port = 0;
+		ptt = (struct ehci_tt **) &amp;utt-&gt;hcpriv;
+	}
+
+	tt = *ptt;
+	if (!tt) {				/* Create the ehci_tt */
+		struct ehci_hcd		*ehci =
+				hcd_to_ehci(bus_to_hcd(udev-&gt;bus));
+
+		tt = kzalloc(sizeof(*tt), GFP_ATOMIC);
+		if (!tt) {
+			if (allocated_index) {
+				utt-&gt;hcpriv = NULL;
+				kfree(tt_index);
+			}
+			return ERR_PTR(-ENOMEM);
+		}
+		list_add_tail(&amp;tt-&gt;tt_list, &amp;ehci-&gt;tt_list);
+		INIT_LIST_HEAD(&amp;tt-&gt;ps_list);
+		tt-&gt;usb_tt = utt;
+		tt-&gt;tt_port = port;
+		*ptt = tt;
+	}
+
+	return tt;
+}
+
+/* Release the TT above udev, if it's not in use */
+static void drop_tt(struct usb_device *udev)
+{
+	struct usb_tt		*utt = udev-&gt;tt;
+	struct ehci_tt		*tt, **tt_index, **ptt;
+	int			cnt, i;
+
+	if (!utt || !utt-&gt;hcpriv)
+		return;		/* Not below a TT, or never allocated */
+
+	cnt = 0;
+	if (utt-&gt;multi) {
+		tt_index = utt-&gt;hcpriv;
+		ptt = &amp;tt_index[udev-&gt;ttport - 1];
+
+		/* How many entries are left in tt_index? */
+		for (i = 0; i &lt; utt-&gt;hub-&gt;maxchild; ++i)
+			cnt += !!tt_index[i];
+	} else {
+		tt_index = NULL;
+		ptt = (struct ehci_tt **) &amp;utt-&gt;hcpriv;
+	}
+
+	tt = *ptt;
+	if (!tt || !list_empty(&amp;tt-&gt;ps_list))
+		return;		/* never allocated, or still in use */
+
+	list_del(&amp;tt-&gt;tt_list);
+	*ptt = NULL;
+	kfree(tt);
+	if (cnt == 1) {
+		utt-&gt;hcpriv = NULL;
+		kfree(tt_index);
+	}
+}
+
 static void bandwidth_dbg(struct ehci_hcd *ehci, int sign, char *type,
 		struct ehci_per_sched *ps)
 {
@@ -125,6 +222,8 @@ static void reserve_release_intr_bandwidth(struct ehci_hcd *ehci,
 	unsigned		i, j, m;
 	int			usecs = qh-&gt;ps.usecs;
 	int			c_usecs = qh-&gt;ps.c_usecs;
+	int			tt_usecs = qh-&gt;ps.tt_usecs;
+	struct ehci_tt		*tt;
 
 	if (qh-&gt;ps.phase == NO_FRAME)	/* Bandwidth wasn't reserved */
 		return;
@@ -135,6 +234,7 @@ static void reserve_release_intr_bandwidth(struct ehci_hcd *ehci,
 	if (sign &lt; 0) {		/* Release bandwidth */
 		usecs = -usecs;
 		c_usecs = -c_usecs;
+		tt_usecs = -tt_usecs;
 	}
 
 	/* Entire transaction (high speed) or start-split (full/low speed) */
@@ -153,11 +253,60 @@ static void reserve_release_intr_bandwidth(struct ehci_hcd *ehci,
 			}
 		}
 	}
+
+	/* FS/LS bus bandwidth */
+	if (tt_usecs) {
+		tt = find_tt(qh-&gt;ps.udev);
+		if (sign &gt; 0)
+			list_add_tail(&amp;qh-&gt;ps.ps_list, &amp;tt-&gt;ps_list);
+		else
+			list_del(&amp;qh-&gt;ps.ps_list);
+
+		for (i = start_uf &gt;&gt; 3; i &lt; EHCI_BANDWIDTH_FRAMES;
+				i += qh-&gt;ps.bw_period)
+			tt-&gt;bandwidth[i] += tt_usecs;
+	}
 }
 
 /*-------------------------------------------------------------------------*/
 
-static int same_tt (struct usb_device *dev1, struct usb_device *dev2)
+static void compute_tt_budget(u8 budget_table[EHCI_BANDWIDTH_SIZE],
+		struct ehci_tt *tt)
+{
+	struct ehci_per_sched	*ps;
+	unsigned		uframe, uf, x;
+	u8			*budget_line;
+
+	if (!tt)
+		return;
+	memset(budget_table, 0, EHCI_BANDWIDTH_SIZE);
+
+	/* Add up the contributions from all the endpoints using this TT */
+	list_for_each_entry(ps, &amp;tt-&gt;ps_list, ps_list) {
+		for (uframe = ps-&gt;bw_phase &lt;&lt; 3; uframe &lt; EHCI_BANDWIDTH_SIZE;
+				uframe += ps-&gt;bw_uperiod) {
+			budget_line = &amp;budget_table[uframe];
+			x = ps-&gt;tt_usecs;
+
+			/* propagate the time forward */
+			for (uf = ps-&gt;phase_uf; uf &lt; 8; ++uf) {
+				x += budget_line[uf];
+
+				/* Each microframe lasts 125 us */
+				if (x &lt;= 125) {
+					budget_line[uf] = x;
+					break;
+				} else {
+					budget_line[uf] = 125;
+					x -= 125;
+				}
+			}
+		}
+	}
+}
+
+static int __maybe_unused same_tt(struct usb_device *dev1,
+		struct usb_device *dev2)
 {
 	if (!dev1-&gt;tt || !dev2-&gt;tt)
 		return 0;
@@ -205,68 +354,6 @@ static inline void carryover_tt_bandwidth(unsigned short tt_usecs[8])
 	}
 }
 
-/* How many of the tt's periodic downstream 1000 usecs are allocated?
- *
- * While this measures the bandwidth in terms of usecs/uframe,
- * the low/fullspeed bus has no notion of uframes, so any particular
- * low/fullspeed transfer can "carry over" from one uframe to the next,
- * since the TT just performs downstream transfers in sequence.
- *
- * For example two separate 100 usec transfers can start in the same uframe,
- * and the second one would "carry over" 75 usecs into the next uframe.
- */
-static void
-periodic_tt_usecs (
-	struct ehci_hcd *ehci,
-	struct usb_device *dev,
-	unsigned frame,
-	unsigned short tt_usecs[8]
-)
-{
-	__hc32			*hw_p = &amp;ehci-&gt;periodic [frame];
-	union ehci_shadow	*q = &amp;ehci-&gt;pshadow [frame];
-	unsigned char		uf;
-
-	memset(tt_usecs, 0, 16);
-
-	while (q-&gt;ptr) {
-		switch (hc32_to_cpu(ehci, Q_NEXT_TYPE(ehci, *hw_p))) {
-		case Q_TYPE_ITD:
-			hw_p = &amp;q-&gt;itd-&gt;hw_next;
-			q = &amp;q-&gt;itd-&gt;itd_next;
-			continue;
-		case Q_TYPE_QH:
-			if (same_tt(dev, q-&gt;qh-&gt;ps.udev)) {
-				uf = tt_start_uframe(ehci, q-&gt;qh-&gt;hw-&gt;hw_info2);
-				tt_usecs[uf] += q-&gt;qh-&gt;ps.tt_usecs;
-			}
-			hw_p = &amp;q-&gt;qh-&gt;hw-&gt;hw_next;
-			q = &amp;q-&gt;qh-&gt;qh_next;
-			continue;
-		case Q_TYPE_SITD:
-			if (same_tt(dev, q-&gt;sitd-&gt;urb-&gt;dev)) {
-				uf = tt_start_uframe(ehci, q-&gt;sitd-&gt;hw_uframe);
-				tt_usecs[uf] += q-&gt;sitd-&gt;stream-&gt;ps.tt_usecs;
-			}
-			hw_p = &amp;q-&gt;sitd-&gt;hw_next;
-			q = &amp;q-&gt;sitd-&gt;sitd_next;
-			continue;
-		// case Q_TYPE_FSTN:
-		default:
-			ehci_dbg(ehci, "ignoring periodic frame %d FSTN\n",
-					frame);
-			hw_p = &amp;q-&gt;fstn-&gt;hw_next;
-			q = &amp;q-&gt;fstn-&gt;fstn_next;
-		}
-	}
-
-	carryover_tt_bandwidth(tt_usecs);
-
-	if (max_tt_usecs[7] &lt; tt_usecs[7])
-		ehci_err(ehci, "frame %d tt sched overrun: %d usecs\n",
-			frame, tt_usecs[7] - max_tt_usecs[7]);
-}
-
 /*
  * Return true if the device's tt's downstream bus is available for a
  * periodic transfer of the specified length (usecs), starting at the
@@ -290,20 +377,29 @@ periodic_tt_usecs (
  */
 static int tt_available (
 	struct ehci_hcd		*ehci,
-	unsigned		period,
-	struct usb_device	*dev,
+	struct ehci_per_sched	*ps,
+	struct ehci_tt		*tt,
 	unsigned		frame,
-	unsigned		uframe,
-	u16			usecs
+	unsigned		uframe
 )
 {
+	unsigned		period = ps-&gt;bw_period;
+	unsigned		usecs = ps-&gt;tt_usecs;
+
 	if ((period == 0) || (uframe &gt;= 7))	/* error */
 		return 0;
 
-	for (; frame &lt; ehci-&gt;periodic_size; frame += period) {
-		unsigned short tt_usecs[8];
+	for (frame &amp;= period - 1; frame &lt; EHCI_BANDWIDTH_FRAMES;
+			frame += period) {
+		unsigned	i, uf;
+		unsigned short	tt_usecs[8];
+
+		if (tt-&gt;bandwidth[frame] + usecs &gt; 900)
+			return 0;
 
-		periodic_tt_usecs (ehci, dev, frame, tt_usecs);
+		uf = frame &lt;&lt; 3;
+		for (i = 0; i &lt; 8; (++i, ++uf))
+			tt_usecs[i] = ehci-&gt;tt_budget[uf];
 
 		if (max_tt_usecs[uframe] &lt;= tt_usecs[uframe])
 			return 0;
@@ -315,7 +411,7 @@ static int tt_available (
 		 */
 		if (125 &lt; usecs) {
 			int ufs = (usecs / 125);
-			int i;
+
 			for (i = uframe; i &lt; (uframe + ufs) &amp;&amp; i &lt; 8; i++)
 				if (0 &lt; tt_usecs[i])
 					return 0;
@@ -697,8 +793,9 @@ static int check_intr_schedule (
 	struct ehci_hcd		*ehci,
 	unsigned		frame,
 	unsigned		uframe,
-	const struct ehci_qh	*qh,
-	__hc32			*c_maskp
+	struct ehci_qh		*qh,
+	__hc32			*c_maskp,
+	struct ehci_tt		*tt
 )
 {
 	int		retval = -ENOSPC;
@@ -716,8 +813,7 @@ static int check_intr_schedule (
 	}
 
 #ifdef CONFIG_USB_EHCI_TT_NEWSCHED
-	if (tt_available(ehci, qh-&gt;ps.bw_period, qh-&gt;ps.udev, frame, uframe,
-				qh-&gt;ps.tt_usecs)) {
+	if (tt_available(ehci, &amp;qh-&gt;ps, tt, frame, uframe)) {
 		unsigned i;
 
 		/* TODO : this may need FSTN for SSPLIT in uframe 5. */
@@ -763,10 +859,11 @@ static int check_intr_schedule (
  */
 static int qh_schedule(struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
-	int		status;
+	int		status = 0;
 	unsigned	uframe;
 	unsigned	c_mask;
 	struct ehci_qh_hw	*hw = qh-&gt;hw;
+	struct ehci_tt		*tt;
 
 	hw-&gt;hw_next = EHCI_LIST_END(ehci);
 
@@ -778,7 +875,12 @@ static int qh_schedule(struct ehci_hcd *ehci, struct ehci_qh *qh)
 
 	uframe = 0;
 	c_mask = 0;
-	status = -ENOSPC;
+	tt = find_tt(qh-&gt;ps.udev);
+	if (IS_ERR(tt)) {
+		status = PTR_ERR(tt);
+		goto done;
+	}
+	compute_tt_budget(ehci-&gt;tt_budget, tt);
 
 	/* else scan the schedule to find a group of slots such that all
 	 * uframes have enough periodic bandwidth available.
@@ -788,22 +890,24 @@ static int qh_schedule(struct ehci_hcd *ehci, struct ehci_qh *qh)
 		int		i;
 		unsigned	frame;
 
-		for (i = qh-&gt;ps.bw_period; status &amp;&amp; i &gt; 0; --i) {
+		for (i = qh-&gt;ps.bw_period; i &gt; 0; --i) {
 			frame = ++ehci-&gt;random_frame &amp; (qh-&gt;ps.bw_period - 1);
 			for (uframe = 0; uframe &lt; 8; uframe++) {
 				status = check_intr_schedule(ehci,
-						frame, uframe, qh, &amp;c_mask);
+						frame, uframe, qh, &amp;c_mask, tt);
 				if (status == 0)
-					break;
+					goto got_it;
 			}
 		}
 
 	/* qh-&gt;ps.bw_period == 0 means every uframe */
 	} else {
-		status = check_intr_schedule(ehci, 0, 0, qh, &amp;c_mask);
+		status = check_intr_schedule(ehci, 0, 0, qh, &amp;c_mask, tt);
 	}
 	if (status)
 		goto done;
+
+ got_it:
 	qh-&gt;ps.phase = (qh-&gt;ps.period ? ehci-&gt;random_frame &amp;
 			(qh-&gt;ps.period - 1) : 0);
 	qh-&gt;ps.bw_phase = qh-&gt;ps.phase &amp; (qh-&gt;ps.bw_period - 1);
@@ -1232,6 +1336,8 @@ static void reserve_release_iso_bandwidth(struct ehci_hcd *ehci,
 	unsigned		s_mask, c_mask, m;
 	int			usecs = stream-&gt;ps.usecs;
 	int			c_usecs = stream-&gt;ps.c_usecs;
+	int			tt_usecs = stream-&gt;ps.tt_usecs;
+	struct ehci_tt		*tt;
 
 	if (stream-&gt;ps.phase == NO_FRAME)	/* Bandwidth wasn't reserved */
 		return;
@@ -1242,6 +1348,7 @@ static void reserve_release_iso_bandwidth(struct ehci_hcd *ehci,
 	if (sign &lt; 0) {		/* Release bandwidth */
 		usecs = -usecs;
 		c_usecs = -c_usecs;
+		tt_usecs = -tt_usecs;
 	}
 
 	if (!stream-&gt;splits) {		/* High speed */
@@ -1264,6 +1371,16 @@ static void reserve_release_iso_bandwidth(struct ehci_hcd *ehci,
 					ehci-&gt;bandwidth[i+j] += c_usecs;
 			}
 		}
+
+		tt = find_tt(stream-&gt;ps.udev);
+		if (sign &gt; 0)
+			list_add_tail(&amp;stream-&gt;ps.ps_list, &amp;tt-&gt;ps_list);
+		else
+			list_del(&amp;stream-&gt;ps.ps_list);
+
+		for (i = uframe &gt;&gt; 3; i &lt; EHCI_BANDWIDTH_FRAMES;
+				i += stream-&gt;ps.bw_period)
+			tt-&gt;bandwidth[i] += tt_usecs;
 	}
 }
 
@@ -1292,7 +1409,8 @@ sitd_slot_ok (
 	struct ehci_hcd		*ehci,
 	struct ehci_iso_stream	*stream,
 	unsigned		uframe,
-	struct ehci_iso_sched	*sched
+	struct ehci_iso_sched	*sched,
+	struct ehci_tt		*tt
 )
 {
 	unsigned		mask, tmp;
@@ -1317,8 +1435,7 @@ sitd_slot_ok (
 	 * tt_available scheduling guarantees 10+% for control/bulk.
 	 */
 	uf = uframe &amp; 7;
-	if (!tt_available(ehci, stream-&gt;ps.bw_period,
-			stream-&gt;ps.udev, frame, uf, stream-&gt;ps.tt_usecs))
+	if (!tt_available(ehci, &amp;stream-&gt;ps, tt, frame, uf))
 		return 0;
 #else
 	/* tt must be idle for start(s), any gap, and csplit.
@@ -1417,6 +1534,13 @@ iso_stream_schedule (
 		/* Schedule the endpoint */
 		if (stream-&gt;ps.phase == NO_FRAME) {
 			int		done = 0;
+			struct ehci_tt	*tt = find_tt(stream-&gt;ps.udev);
+
+			if (IS_ERR(tt)) {
+				status = PTR_ERR(tt);
+				goto fail;
+			}
+			compute_tt_budget(ehci-&gt;tt_budget, tt);
 
 			start = (now &amp; ~0x07) + SCHEDULING_DELAY;
 
@@ -1437,7 +1561,7 @@ iso_stream_schedule (
 					if ((start % 8) &gt;= 6)
 						continue;
 					if (sitd_slot_ok(ehci, stream, start,
-							sched))
+							sched, tt))
 						done = 1;
 				}
 			} while (start &gt; next &amp;&amp; !done);
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 12504fbded56..e8f41c5e771b 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -61,6 +61,7 @@ struct ehci_stats {
 struct ehci_per_sched {
 	struct usb_device	*udev;		/* access to the TT */
 	struct usb_host_endpoint *ep;
+	struct list_head	ps_list;	/* node on ehci_tt's ps_list */
 	u16			tt_usecs;	/* time on the FS/LS bus */
 	u16			cs_mask;	/* C-mask and S-mask bytes */
 	u16			period;		/* actual period in frames */
@@ -256,6 +257,9 @@ struct ehci_hcd {			/* one per controller */
 #define EHCI_BANDWIDTH_FRAMES	(EHCI_BANDWIDTH_SIZE &gt;&gt; 3)
 	u8			bandwidth[EHCI_BANDWIDTH_SIZE];
 						/* us allocated per uframe */
+	u8			tt_budget[EHCI_BANDWIDTH_SIZE];
+						/* us budgeted per uframe */
+	struct list_head	tt_list;
 
 	/* platform-specific data -- must come last */
 	unsigned long		priv[0] __aligned(sizeof(s64));
@@ -595,6 +599,35 @@ struct ehci_fstn {
 
 /*-------------------------------------------------------------------------*/
 
+/*
+ * USB-2.0 Specification Sections 11.14 and 11.18
+ * Scheduling and budgeting split transactions using TTs
+ *
+ * A hub can have a single TT for all its ports, or multiple TTs (one for each
+ * port).  The bandwidth and budgeting information for the full/low-speed bus
+ * below each TT is self-contained and independent of the other TTs or the
+ * high-speed bus.
+ *
+ * "Bandwidth" refers to the number of microseconds on the FS/LS bus allocated
+ * to an interrupt or isochronous endpoint for each frame.  "Budget" refers to
+ * the best-case estimate of the number of full-speed bytes allocated to an
+ * endpoint for each microframe within an allocated frame.
+ *
+ * Removal of an endpoint invalidates a TT's budget.  Instead of trying to
+ * keep an up-to-date record, we recompute the budget when it is needed.
+ */
+
+struct ehci_tt {
+	u16			bandwidth[EHCI_BANDWIDTH_FRAMES];
+
+	struct list_head	tt_list;	/* List of all ehci_tt's */
+	struct list_head	ps_list;	/* Items using this TT */
+	struct usb_tt		*usb_tt;
+	int			tt_port;	/* TT port number */
+};
+
+/*-------------------------------------------------------------------------*/
+
 /* Prepare the PORTSC wakeup flags during controller suspend/resume */
 
 #define ehci_prepare_ports_for_controller_suspend(ehci, do_wakeup)	\</pre>
    <div class="pagination">
        <a href='2_30.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><span>[31]</span><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_32.html'>Next&gt;&gt;</a>
    <div>
</body>
