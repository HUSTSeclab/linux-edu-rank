<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_138.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><span>[139]</span><a href='2_140.html'>140</a><a href='2_140.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit c074b416b94c0aa4a371f24bf6cc13d8cf1fab59
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Apr 22 14:39:12 2005 -0400

    [PATCH] USB UHCI: improved reset handling
    
    This patch improves the strategy uhci-hcd uses for performing controller
    resets and checking whether they are needed.
    
            The HCRESET command doesn't affect the Suspend, Resume,
            or Reset bits in the port status &amp; control registers, so
            the driver must clear them by itself.  This means the
            code to figure out how many ports there are has to be moved
            to an earlier spot in the driver.
    
            The R/WC bits in the USBLEGSUP register can be set by the
            hardware even in the absence of BIOS meddling with legacy
            support features.  Hence it's not a good idea to check them
            while trying to determine whether the BIOS has altered the
            controller's state.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 25a718eb1d0f..cec070fa8c83 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -112,6 +112,8 @@ static inline void restart_timer(struct uhci_hcd *uhci)
  */
 static void reset_hc(struct uhci_hcd *uhci)
 {
+	int port;
+
 	/* Turn off PIRQ enable and SMI enable.  (This also turns off the
 	 * BIOS's USB Legacy Support.)  Turn off all the R/WC bits too.
 	 */
@@ -135,6 +137,13 @@ static void reset_hc(struct uhci_hcd *uhci)
 	outw(0, uhci-&gt;io_addr + USBINTR);
 	outw(0, uhci-&gt;io_addr + USBCMD);
 
+	/* HCRESET doesn't affect the Suspend, Reset, and Resume Detect
+	 * bits in the port status and control registers.
+	 * We have to clear them by hand.
+	 */
+	for (port = 0; port &lt; uhci-&gt;rh_numports; ++port)
+		outw(0, uhci-&gt;io_addr + USBPORTSC1 + (port * 2));
+
 	uhci-&gt;port_c_suspend = uhci-&gt;suspended_ports =
 			uhci-&gt;resuming_ports = 0;
 	uhci-&gt;rh_state = UHCI_RH_RESET;
@@ -166,14 +175,14 @@ static void check_and_reset_hc(struct uhci_hcd *uhci)
 	 * When restarting a suspended controller, we expect all the
 	 * settings to be the same as we left them:
 	 *
-	 *	PIRQ and SMI disabled, no R/WC bits set in USBLEGSUP;
+	 *	PIRQ and SMI disabled, no R/W bits set in USBLEGSUP;
 	 *	Controller is stopped and configured with EGSM set;
 	 *	No interrupts enabled except possibly Resume Detect.
 	 *
 	 * If any of these conditions are violated we do a complete reset.
 	 */
 	pci_read_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP, &amp;legsup);
-	if (legsup &amp; ~USBLEGSUP_RO) {
+	if (legsup &amp; ~(USBLEGSUP_RO | USBLEGSUP_RWC)) {
 		dev_dbg(uhci_dev(uhci), "%s: legsup = 0x%04x\n",
 				__FUNCTION__, legsup);
 		goto reset_needed;
@@ -478,9 +487,37 @@ static void release_uhci(struct uhci_hcd *uhci)
 static int uhci_reset(struct usb_hcd *hcd)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
+	unsigned io_size = (unsigned) hcd-&gt;rsrc_len;
+	int port;
 
 	uhci-&gt;io_addr = (unsigned long) hcd-&gt;rsrc_start;
 
+	/* The UHCI spec says devices must have 2 ports, and goes on to say
+	 * they may have more but gives no way to determine how many there
+	 * are.  However, according to the UHCI spec, Bit 7 of the port
+	 * status and control register is always set to 1.  So we try to
+	 * use this to our advantage.
+	 */
+	for (port = 0; port &lt; (io_size - USBPORTSC1) / 2; port++) {
+		unsigned int portstatus;
+
+		portstatus = inw(uhci-&gt;io_addr + USBPORTSC1 + (port * 2));
+		if (!(portstatus &amp; 0x0080))
+			break;
+	}
+	if (debug)
+		dev_info(uhci_dev(uhci), "detected %d ports\n", port);
+
+	/* Anything less than 2 or greater than 7 is weird,
+	 * so we'll ignore it.
+	 */
+	if (port &lt; 2 || port &gt; UHCI_RH_MAXCHILD) {
+		dev_info(uhci_dev(uhci), "port count misdetected? "
+				"forcing to 2 ports\n");
+		port = 2;
+	}
+	uhci-&gt;rh_numports = port;
+
 	/* Kick BIOS off this hardware and reset if the controller
 	 * isn't already safely quiescent.
 	 */
@@ -508,13 +545,11 @@ static int uhci_start(struct usb_hcd *hcd)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 	int retval = -EBUSY;
-	int i, port;
-	unsigned io_size;
+	int i;
 	dma_addr_t dma_handle;
 	struct usb_device *udev;
 	struct dentry *dentry;
 
-	io_size = (unsigned) hcd-&gt;rsrc_len;
 	hcd-&gt;uses_new_polling = 1;
 	if (pci_find_capability(to_pci_dev(uhci_dev(uhci)), PCI_CAP_ID_PM))
 		hcd-&gt;can_wakeup = 1;		/* Assume it supports PME# */
@@ -578,30 +613,6 @@ static int uhci_start(struct usb_hcd *hcd)
 
 	/* Initialize the root hub */
 
-	/* UHCI specs says devices must have 2 ports, but goes on to say */
-	/*  they may have more but give no way to determine how many they */
-	/*  have. However, according to the UHCI spec, Bit 7 is always set */
-	/*  to 1. So we try to use this to our advantage */
-	for (port = 0; port &lt; (io_size - 0x10) / 2; port++) {
-		unsigned int portstatus;
-
-		portstatus = inw(uhci-&gt;io_addr + 0x10 + (port * 2));
-		if (!(portstatus &amp; 0x0080))
-			break;
-	}
-	if (debug)
-		dev_info(uhci_dev(uhci), "detected %d ports\n", port);
-
-	/* This is experimental so anything less than 2 or greater than 8 is */
-	/*  something weird and we'll ignore it */
-	if (port &lt; 2 || port &gt; UHCI_RH_MAXCHILD) {
-		dev_info(uhci_dev(uhci), "port count misdetected? "
-				"forcing to 2 ports\n");
-		port = 2;
-	}
-
-	uhci-&gt;rh_numports = port;
-
 	udev = usb_alloc_dev(NULL, &amp;hcd-&gt;self, 0);
 	if (!udev) {
 		dev_err(uhci_dev(uhci), "unable to allocate root hub\n");</pre><hr><pre>commit 6c1b445c226dd82d0961725dec8051b95003723a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Apr 21 16:04:58 2005 -0400

    [PATCH] USB UHCI: Use root-hub IRQs while suspended
    
    This patch, which has as478b as a prerequisite, enables the uhci-hcd
    driver to take advantage of root-hub IRQs rather than polling during the
    time it is suspended.  (Unfortunately the hardware doesn't support
    port-change interrupts while the controller is running.)  It also turns
    off the driver's private timer while the controller is suspended, as it
    isn't needed then.  The combined elimination of polling interrupts and
    timer interrupts ought to be enough to allow some systems to save a
    noticeable amount of power while they are otherwise idle.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 82e608a4bbd0..25a718eb1d0f 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -84,6 +84,8 @@ static char *errbuf;
 
 static kmem_cache_t *uhci_up_cachep;	/* urb_priv */
 
+static void suspend_rh(struct uhci_hcd *uhci, enum uhci_rh_state new_state);
+static void wakeup_rh(struct uhci_hcd *uhci);
 static void uhci_get_current_frame_number(struct uhci_hcd *uhci);
 
 /* If a transfer is still active after this much time, turn off FSBR */
@@ -133,12 +135,12 @@ static void reset_hc(struct uhci_hcd *uhci)
 	outw(0, uhci-&gt;io_addr + USBINTR);
 	outw(0, uhci-&gt;io_addr + USBCMD);
 
-	uhci-&gt;resume_detect = 0;
 	uhci-&gt;port_c_suspend = uhci-&gt;suspended_ports =
 			uhci-&gt;resuming_ports = 0;
 	uhci-&gt;rh_state = UHCI_RH_RESET;
 	uhci-&gt;is_stopped = UHCI_IS_STOPPED;
 	uhci_to_hcd(uhci)-&gt;state = HC_STATE_HALT;
+	uhci_to_hcd(uhci)-&gt;poll_rh = 0;
 }
 
 /*
@@ -148,6 +150,7 @@ static void hc_died(struct uhci_hcd *uhci)
 {
 	reset_hc(uhci);
 	uhci-&gt;hc_inaccessible = 1;
+	del_timer(&amp;uhci-&gt;stall_timer);
 }
 
 /*
@@ -302,14 +305,14 @@ __acquires(uhci-&gt;lock)
 
 	uhci-&gt;rh_state = new_state;
 	uhci-&gt;is_stopped = UHCI_IS_STOPPED;
-	uhci-&gt;resume_detect = 0;
+	del_timer(&amp;uhci-&gt;stall_timer);
+	uhci_to_hcd(uhci)-&gt;poll_rh = !int_enable;
 
 	uhci_scan_schedule(uhci, NULL);
 }
 
 static void start_rh(struct uhci_hcd *uhci)
 {
-	uhci-&gt;rh_state = UHCI_RH_RUNNING;
 	uhci-&gt;is_stopped = 0;
 	smp_wmb();
 
@@ -320,6 +323,9 @@ static void start_rh(struct uhci_hcd *uhci)
 	outw(USBINTR_TIMEOUT | USBINTR_RESUME | USBINTR_IOC | USBINTR_SP,
 			uhci-&gt;io_addr + USBINTR);
 	mb();
+	uhci-&gt;rh_state = UHCI_RH_RUNNING;
+	uhci_to_hcd(uhci)-&gt;poll_rh = 1;
+	restart_timer(uhci);
 }
 
 static void wakeup_rh(struct uhci_hcd *uhci)
@@ -353,36 +359,9 @@ __acquires(uhci-&gt;lock)
 	}
 
 	start_rh(uhci);
-}
-
-static void rh_state_transitions(struct uhci_hcd *uhci)
-{
-	switch (uhci-&gt;rh_state) {
-	    case UHCI_RH_RUNNING:
-		/* are any devices attached? */
-		if (!any_ports_active(uhci)) {
-			uhci-&gt;rh_state = UHCI_RH_RUNNING_NODEVS;
-			uhci-&gt;auto_stop_time = jiffies + HZ;
-		}
-		break;
 
-	    case UHCI_RH_RUNNING_NODEVS:
-		/* auto-stop if nothing connected for 1 second */
-		if (any_ports_active(uhci))
-			uhci-&gt;rh_state = UHCI_RH_RUNNING;
-		else if (time_after_eq(jiffies, uhci-&gt;auto_stop_time))
-			suspend_rh(uhci, UHCI_RH_AUTO_STOPPED);
-		break;
-
-	    case UHCI_RH_AUTO_STOPPED:
-		/* wakeup if requested by a device */
-		if (uhci-&gt;resume_detect)
-			wakeup_rh(uhci);
-		break;
-
-	    default:
-		break;
-	}
+	/* Restart root hub polling */
+	mod_timer(&amp;uhci_to_hcd(uhci)-&gt;rh_timer, jiffies);
 }
 
 static void stall_callback(unsigned long _uhci)
@@ -394,14 +373,8 @@ static void stall_callback(unsigned long _uhci)
 	uhci_scan_schedule(uhci, NULL);
 	check_fsbr(uhci);
 
-	/* Poll for and perform state transitions */
-	if (!uhci-&gt;hc_inaccessible) {
-		rh_state_transitions(uhci);
-		if (uhci-&gt;suspended_ports)
-			uhci_check_ports(uhci);
-	}
-
-	restart_timer(uhci);
+	if (!uhci-&gt;is_stopped)
+		restart_timer(uhci);
 	spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
 }
 
@@ -443,7 +416,7 @@ static irqreturn_t uhci_irq(struct usb_hcd *hcd, struct pt_regs *regs)
 	}
 
 	if (status &amp; USBSTS_RD)
-		uhci-&gt;resume_detect = 1;
+		usb_hcd_poll_rh_status(hcd);
 
 	spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
 	uhci_scan_schedule(uhci, regs);
@@ -542,6 +515,7 @@ static int uhci_start(struct usb_hcd *hcd)
 	struct dentry *dentry;
 
 	io_size = (unsigned) hcd-&gt;rsrc_len;
+	hcd-&gt;uses_new_polling = 1;
 	if (pci_find_capability(to_pci_dev(uhci_dev(uhci)), PCI_CAP_ID_PM))
 		hcd-&gt;can_wakeup = 1;		/* Assume it supports PME# */
 
@@ -714,8 +688,6 @@ static int uhci_start(struct usb_hcd *hcd)
 	configure_hc(uhci);
 	start_rh(uhci);
 
-	restart_timer(uhci);
-
 	udev-&gt;speed = USB_SPEED_FULL;
 
 	if (usb_hcd_register_root_hub(udev, hcd) != 0) {
@@ -730,8 +702,8 @@ static int uhci_start(struct usb_hcd *hcd)
  * error exits:
  */
 err_start_root_hub:
-	del_timer_sync(&amp;uhci-&gt;stall_timer);
 	reset_hc(uhci);
+	del_timer_sync(&amp;uhci-&gt;stall_timer);
 
 err_alloc_skelqh:
 	for (i = 0; i &lt; UHCI_NUM_SKELQH; i++)
@@ -771,13 +743,12 @@ static void uhci_stop(struct usb_hcd *hcd)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 
-	del_timer_sync(&amp;uhci-&gt;stall_timer);
-
 	spin_lock_irq(&amp;uhci-&gt;lock);
 	reset_hc(uhci);
 	uhci_scan_schedule(uhci, NULL);
 	spin_unlock_irq(&amp;uhci-&gt;lock);
-	
+
+	del_timer_sync(&amp;uhci-&gt;stall_timer);
 	release_uhci(uhci);
 }
 
@@ -844,6 +815,8 @@ static int uhci_suspend(struct usb_hcd *hcd, pm_message_t message)
 
 done:
 	spin_unlock_irq(&amp;uhci-&gt;lock);
+	if (rc == 0)
+		del_timer_sync(&amp;hcd-&gt;rh_timer);
 	return rc;
 }
 
@@ -875,6 +848,9 @@ static int uhci_resume(struct usb_hcd *hcd)
 		suspend_rh(uhci, UHCI_RH_SUSPENDED);
 
 	spin_unlock_irq(&amp;uhci-&gt;lock);
+
+	if (hcd-&gt;poll_rh)
+		usb_hcd_poll_rh_status(hcd);
 	return 0;
 }
 #endif
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index 827df5e06800..d7c67b73eb7a 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -327,18 +327,19 @@ static inline int __interval_to_skel(int interval)
  * driver learns to autosuspend.)
  */
 enum uhci_rh_state {
-	/* In the next 4 states the HC must be halted */
-	UHCI_RH_RESET,			/* These two must come first */
+	/* In the following states the HC must be halted.
+	 * These two must come first */
+	UHCI_RH_RESET,
 	UHCI_RH_SUSPENDED,
 
 	UHCI_RH_AUTO_STOPPED,
 	UHCI_RH_RESUMING,
 
-	/* In the next state the HC changes from running to halted, so it
-	 * can legally appear either way */
+	/* In this state the HC changes from running to halted,
+	 * so it can legally appear either way. */
 	UHCI_RH_SUSPENDING,
 
-	/* In the next two states it's an error if the HC is halted.
+	/* In the following states it's an error if the HC is halted.
 	 * These two must come last */
 	UHCI_RH_RUNNING,		/* The normal state */
 	UHCI_RH_RUNNING_NODEVS,		/* Running with no devices attached */
@@ -380,7 +381,6 @@ struct uhci_hcd {
 
 	unsigned int scan_in_progress:1;	/* Schedule scan is running */
 	unsigned int need_rescan:1;		/* Redo the schedule scan */
-	unsigned int resume_detect:1;		/* Need a Global Resume */
 	unsigned int hc_inaccessible:1;		/* HC is suspended or dead */
 
 	/* Support for port suspend/resume/reset */
diff --git a/drivers/usb/host/uhci-hub.c b/drivers/usb/host/uhci-hub.c
index 13652de52203..4eace2b19ddb 100644
--- a/drivers/usb/host/uhci-hub.c
+++ b/drivers/usb/host/uhci-hub.c
@@ -49,22 +49,16 @@ static int any_ports_active(struct uhci_hcd *uhci)
 	return 0;
 }
 
-static int uhci_hub_status_data(struct usb_hcd *hcd, char *buf)
+static inline int get_hub_status_data(struct uhci_hcd *uhci, char *buf)
 {
-	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 	int port;
 
-	if (uhci-&gt;hc_inaccessible)
-		return 0;
-
 	*buf = 0;
 	for (port = 0; port &lt; uhci-&gt;rh_numports; ++port) {
 		if ((inw(uhci-&gt;io_addr + USBPORTSC1 + port * 2) &amp; RWC_BITS) ||
 				test_bit(port, &amp;uhci-&gt;port_c_suspend))
 			*buf |= (1 &lt;&lt; (port + 1));
 	}
-	if (*buf &amp;&amp; uhci-&gt;is_stopped)
-		uhci-&gt;resume_detect = 1;
 	return !!*buf;
 }
 
@@ -134,6 +128,11 @@ static void uhci_check_ports(struct uhci_hcd *uhci)
 				set_bit(port, &amp;uhci-&gt;resuming_ports);
 				uhci-&gt;ports_timeout = jiffies +
 						msecs_to_jiffies(20);
+
+				/* Make sure we see the port again
+				 * after the resuming period is over. */
+				mod_timer(&amp;uhci_to_hcd(uhci)-&gt;rh_timer,
+						uhci-&gt;ports_timeout);
 			} else if (time_after_eq(jiffies,
 						uhci-&gt;ports_timeout)) {
 				uhci_finish_suspend(uhci, port, port_addr);
@@ -142,6 +141,60 @@ static void uhci_check_ports(struct uhci_hcd *uhci)
 	}
 }
 
+static int uhci_hub_status_data(struct usb_hcd *hcd, char *buf)
+{
+	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
+	unsigned long flags;
+	int status;
+
+	spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
+	if (uhci-&gt;hc_inaccessible) {
+		status = 0;
+		goto done;
+	}
+
+	uhci_check_ports(uhci);
+	status = get_hub_status_data(uhci, buf);
+
+	switch (uhci-&gt;rh_state) {
+	    case UHCI_RH_SUSPENDING:
+	    case UHCI_RH_SUSPENDED:
+		/* if port change, ask to be resumed */
+		if (status)
+			usb_hcd_resume_root_hub(hcd);
+		break;
+
+	    case UHCI_RH_AUTO_STOPPED:
+		/* if port change, auto start */
+		if (status)
+			wakeup_rh(uhci);
+		break;
+
+	    case UHCI_RH_RUNNING:
+		/* are any devices attached? */
+		if (!any_ports_active(uhci)) {
+			uhci-&gt;rh_state = UHCI_RH_RUNNING_NODEVS;
+			uhci-&gt;auto_stop_time = jiffies + HZ;
+		}
+		break;
+
+	    case UHCI_RH_RUNNING_NODEVS:
+		/* auto-stop if nothing connected for 1 second */
+		if (any_ports_active(uhci))
+			uhci-&gt;rh_state = UHCI_RH_RUNNING;
+		else if (time_after_eq(jiffies, uhci-&gt;auto_stop_time))
+			suspend_rh(uhci, UHCI_RH_AUTO_STOPPED);
+		break;
+
+	    default:
+		break;
+	}
+
+done:
+	spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
+	return status;
+}
+
 /* size of returned buffer is part of USB spec */
 static int uhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 			u16 wIndex, char *buf, u16 wLength)
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index f5c75885f7be..77f264851e98 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -32,6 +32,8 @@ static void uhci_free_pending_tds(struct uhci_hcd *uhci);
  */
 static inline void uhci_set_next_interrupt(struct uhci_hcd *uhci)
 {
+	if (uhci-&gt;is_stopped)
+		mod_timer(&amp;uhci-&gt;stall_timer, jiffies);
 	uhci-&gt;term_td-&gt;status |= cpu_to_le32(TD_CTRL_IOC); 
 }
 
@@ -1497,6 +1499,7 @@ static void uhci_scan_schedule(struct uhci_hcd *uhci, struct pt_regs *regs)
  rescan:
 	uhci-&gt;need_rescan = 0;
 
+	uhci_clear_next_interrupt(uhci);
 	uhci_get_current_frame_number(uhci);
 
 	if (uhci-&gt;frame_number + uhci-&gt;is_stopped != uhci-&gt;qh_remove_age)</pre><hr><pre>commit 4daaa87c8f19c5f1978470e9e91b74d9e0fb0f8e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Apr 9 17:30:08 2005 -0400

    [PATCH] USB UHCI: Fix up loose ends
    
    This patch tidies up a few loose ends left by the preceding patches.
    It indicates the controller supports remote wakeup whenever the PM
    capability is present -- which shouldn't cause any harm if the
    assumption turns out to be wrong.  It refuses to suspend the
    controller if the root hub is still active, and it refuses to resume
    the root hub if the controller is suspended.  It adds checks for a
    dead controller in several spots, and it adds memory barriers as
    needed to insure that I/O operations are completed before moving on.
    
    Actually I'm not certain the last part is being done correctly.  With
    code like this:
    
            outw(..., ...);
            mb();
            udelay(5);
    
    do we know for certain that the outw() will complete _before_ the
    delay begins?  If not, how should this be written?
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 730ba3a621ae..82e608a4bbd0 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -13,18 +13,13 @@
  * (C) Copyright 2000 Yggdrasil Computing, Inc. (port of new PCI interface
  *               support from usb-ohci.c by Adam Richter, adam@yggdrasil.com).
  * (C) Copyright 1999 Gregory P. Smith (from usb-ohci.c)
- * (C) Copyright 2004 Alan Stern, stern@rowland.harvard.edu
+ * (C) Copyright 2004-2005 Alan Stern, stern@rowland.harvard.edu
  *
  * Intel documents this fairly well, and as far as I know there
  * are no royalties or anything like that, but even so there are
  * people who decided that they want to do the same thing in a
  * completely different way.
  *
- * WARNING! The USB documentation is downright evil. Most of it
- * is just crap, written by a committee. You're better off ignoring
- * most of it, the important stuff is:
- *  - the low-level protocol (fairly simple but lots of small details)
- *  - working around the horridness of the rest
  */
 
 #include &lt;linux/config.h&gt;
@@ -146,6 +141,15 @@ static void reset_hc(struct uhci_hcd *uhci)
 	uhci_to_hcd(uhci)-&gt;state = HC_STATE_HALT;
 }
 
+/*
+ * Last rites for a defunct/nonfunctional controller
+ */
+static void hc_died(struct uhci_hcd *uhci)
+{
+	reset_hc(uhci);
+	uhci-&gt;hc_inaccessible = 1;
+}
+
 /*
  * Initialize a controller that was newly discovered or has just been
  * resumed.  In either case we can't be sure of its previous state.
@@ -287,6 +291,8 @@ __acquires(uhci-&gt;lock)
 		spin_unlock_irq(&amp;uhci-&gt;lock);
 		msleep(1);
 		spin_lock_irq(&amp;uhci-&gt;lock);
+		if (uhci-&gt;hc_inaccessible)	/* Died */
+			return;
 	}
 	if (!(inw(uhci-&gt;io_addr + USBSTS) &amp; USBSTS_HCH))
 		dev_warn(uhci_dev(uhci), "Controller not stopped yet!\n");
@@ -335,6 +341,8 @@ __acquires(uhci-&gt;lock)
 		spin_unlock_irq(&amp;uhci-&gt;lock);
 		msleep(20);
 		spin_lock_irq(&amp;uhci-&gt;lock);
+		if (uhci-&gt;hc_inaccessible)	/* Died */
+			return;
 
 		/* End Global Resume and wait for EOP to be sent */
 		outw(USBCMD_CF, uhci-&gt;io_addr + USBCMD);
@@ -387,9 +395,11 @@ static void stall_callback(unsigned long _uhci)
 	check_fsbr(uhci);
 
 	/* Poll for and perform state transitions */
-	rh_state_transitions(uhci);
-	if (uhci-&gt;suspended_ports &amp;&amp; !uhci-&gt;hc_inaccessible)
-		uhci_check_ports(uhci);
+	if (!uhci-&gt;hc_inaccessible) {
+		rh_state_transitions(uhci);
+		if (uhci-&gt;suspended_ports)
+			uhci_check_ports(uhci);
+	}
 
 	restart_timer(uhci);
 	spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
@@ -399,6 +409,7 @@ static irqreturn_t uhci_irq(struct usb_hcd *hcd, struct pt_regs *regs)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 	unsigned short status;
+	unsigned long flags;
 
 	/*
 	 * Read the interrupt status, and write it back to clear the
@@ -417,20 +428,26 @@ static irqreturn_t uhci_irq(struct usb_hcd *hcd, struct pt_regs *regs)
 		if (status &amp; USBSTS_HCPE)
 			dev_err(uhci_dev(uhci), "host controller process "
 					"error, something bad happened!\n");
-		if ((status &amp; USBSTS_HCH) &amp;&amp;
-				uhci-&gt;rh_state &gt;= UHCI_RH_RUNNING) {
-			dev_err(uhci_dev(uhci), "host controller halted, "
+		if (status &amp; USBSTS_HCH) {
+			spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
+			if (uhci-&gt;rh_state &gt;= UHCI_RH_RUNNING) {
+				dev_err(uhci_dev(uhci),
+					"host controller halted, "
 					"very bad!\n");
-			/* FIXME: Reset the controller, fix the offending TD */
+				hc_died(uhci);
+				spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
+				return IRQ_HANDLED;
+			}
+			spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
 		}
 	}
 
 	if (status &amp; USBSTS_RD)
 		uhci-&gt;resume_detect = 1;
 
-	spin_lock(&amp;uhci-&gt;lock);
+	spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
 	uhci_scan_schedule(uhci, regs);
-	spin_unlock(&amp;uhci-&gt;lock);
+	spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
 
 	return IRQ_HANDLED;
 }
@@ -525,10 +542,15 @@ static int uhci_start(struct usb_hcd *hcd)
 	struct dentry *dentry;
 
 	io_size = (unsigned) hcd-&gt;rsrc_len;
+	if (pci_find_capability(to_pci_dev(uhci_dev(uhci)), PCI_CAP_ID_PM))
+		hcd-&gt;can_wakeup = 1;		/* Assume it supports PME# */
 
-	dentry = debugfs_create_file(hcd-&gt;self.bus_name, S_IFREG|S_IRUGO|S_IWUSR, uhci_debugfs_root, uhci, &amp;uhci_debug_operations);
+	dentry = debugfs_create_file(hcd-&gt;self.bus_name,
+			S_IFREG|S_IRUGO|S_IWUSR, uhci_debugfs_root, uhci,
+			&amp;uhci_debug_operations);
 	if (!dentry) {
-		dev_err(uhci_dev(uhci), "couldn't create uhci debugfs entry\n");
+		dev_err(uhci_dev(uhci),
+				"couldn't create uhci debugfs entry\n");
 		retval = -ENOMEM;
 		goto err_create_debug_entry;
 	}
@@ -765,7 +787,8 @@ static int uhci_rh_suspend(struct usb_hcd *hcd)
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 
 	spin_lock_irq(&amp;uhci-&gt;lock);
-	suspend_rh(uhci, UHCI_RH_SUSPENDED);
+	if (!uhci-&gt;hc_inaccessible)		/* Not dead */
+		suspend_rh(uhci, UHCI_RH_SUSPENDED);
 	spin_unlock_irq(&amp;uhci-&gt;lock);
 	return 0;
 }
@@ -773,26 +796,44 @@ static int uhci_rh_suspend(struct usb_hcd *hcd)
 static int uhci_rh_resume(struct usb_hcd *hcd)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
+	int rc = 0;
 
 	spin_lock_irq(&amp;uhci-&gt;lock);
-	wakeup_rh(uhci);
+	if (uhci-&gt;hc_inaccessible) {
+		if (uhci-&gt;rh_state == UHCI_RH_SUSPENDED) {
+			dev_warn(uhci_dev(uhci), "HC isn't running!\n");
+			rc = -ENODEV;
+		}
+		/* Otherwise the HC is dead */
+	} else
+		wakeup_rh(uhci);
 	spin_unlock_irq(&amp;uhci-&gt;lock);
-	return 0;
+	return rc;
 }
 
 static int uhci_suspend(struct usb_hcd *hcd, pm_message_t message)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
+	int rc = 0;
 
 	dev_dbg(uhci_dev(uhci), "%s\n", __FUNCTION__);
 
 	spin_lock_irq(&amp;uhci-&gt;lock);
+	if (uhci-&gt;hc_inaccessible)	/* Dead or already suspended */
+		goto done;
 
 #ifndef CONFIG_USB_SUSPEND
 	/* Otherwise this would never happen */
 	suspend_rh(uhci, UHCI_RH_SUSPENDED);
 #endif
 
+	if (uhci-&gt;rh_state &gt; UHCI_RH_SUSPENDED) {
+		dev_warn(uhci_dev(uhci), "Root hub isn't suspended!\n");
+		hcd-&gt;state = HC_STATE_RUNNING;
+		rc = -EBUSY;
+		goto done;
+	};
+
 	/* All PCI host controllers are required to disable IRQ generation
 	 * at the source, so we must turn off PIRQ.
 	 */
@@ -801,8 +842,9 @@ static int uhci_suspend(struct usb_hcd *hcd, pm_message_t message)
 
 	/* FIXME: Enable non-PME# remote wakeup? */
 
+done:
 	spin_unlock_irq(&amp;uhci-&gt;lock);
-	return 0;
+	return rc;
 }
 
 static int uhci_resume(struct usb_hcd *hcd)
@@ -811,6 +853,8 @@ static int uhci_resume(struct usb_hcd *hcd)
 
 	dev_dbg(uhci_dev(uhci), "%s\n", __FUNCTION__);
 
+	if (uhci-&gt;rh_state == UHCI_RH_RESET)	/* Dead */
+		return 0;
 	spin_lock_irq(&amp;uhci-&gt;lock);
 
 	/* FIXME: Disable non-PME# remote wakeup? */</pre><hr><pre>commit a8bed8b6be75bc5a46aa599ab360d5f1db291c8f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Apr 9 17:29:00 2005 -0400

    [PATCH] USB UHCI: Add root-hub suspend/resume support
    
    This patch implements (finally!) separate suspend and resume routines
    for the root hub and the controller in the UHCI driver.  It also
    changes the sequence used to reset the controller during initial
    probing, so as to preserve the existing state during a Resume-From-Disk.
    (This new sequence is what should be used in the PCI Quirks code for
    early USB handoffs, incidentally.)  Lastly it adds a notion of the
    controller being "inaccessible" while in a PCI low-power state, when
    normal I/O operations shouldn't be allowed.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 57b36dcea5d0..730ba3a621ae 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -109,28 +109,113 @@ static inline void restart_timer(struct uhci_hcd *uhci)
 #include "uhci-debug.c"
 #include "uhci-q.c"
 
+/*
+ * Make sure the controller is completely inactive, unable to
+ * generate interrupts or do DMA.
+ */
 static void reset_hc(struct uhci_hcd *uhci)
 {
-	unsigned long io_addr = uhci-&gt;io_addr;
+	/* Turn off PIRQ enable and SMI enable.  (This also turns off the
+	 * BIOS's USB Legacy Support.)  Turn off all the R/WC bits too.
+	 */
+	pci_write_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP,
+			USBLEGSUP_RWC);
 
-	/* Turn off PIRQ, SMI, and all interrupts.  This also turns off
-	 * the BIOS's USB Legacy Support.
+	/* Reset the HC - this will force us to get a
+	 * new notification of any already connected
+	 * ports due to the virtual disconnect that it
+	 * implies.
 	 */
-	pci_write_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP, 0);
-	outw(0, uhci-&gt;io_addr + USBINTR);
+	outw(USBCMD_HCRESET, uhci-&gt;io_addr + USBCMD);
+	mb();
+	udelay(5);
+	if (inw(uhci-&gt;io_addr + USBCMD) &amp; USBCMD_HCRESET)
+		dev_warn(uhci_dev(uhci), "HCRESET not completed yet!\n");
 
-	/* Global reset for 50ms */
-	outw(USBCMD_GRESET, io_addr + USBCMD);
-	msleep(50);
-	outw(0, io_addr + USBCMD);
+	/* Just to be safe, disable interrupt requests and
+	 * make sure the controller is stopped.
+	 */
+	outw(0, uhci-&gt;io_addr + USBINTR);
+	outw(0, uhci-&gt;io_addr + USBCMD);
 
-	/* Another 10ms delay */
-	msleep(10);
 	uhci-&gt;resume_detect = 0;
-	uhci-&gt;is_stopped = UHCI_IS_STOPPED;
+	uhci-&gt;port_c_suspend = uhci-&gt;suspended_ports =
+			uhci-&gt;resuming_ports = 0;
 	uhci-&gt;rh_state = UHCI_RH_RESET;
+	uhci-&gt;is_stopped = UHCI_IS_STOPPED;
+	uhci_to_hcd(uhci)-&gt;state = HC_STATE_HALT;
 }
 
+/*
+ * Initialize a controller that was newly discovered or has just been
+ * resumed.  In either case we can't be sure of its previous state.
+ */
+static void check_and_reset_hc(struct uhci_hcd *uhci)
+{
+	u16 legsup;
+	unsigned int cmd, intr;
+
+	/*
+	 * When restarting a suspended controller, we expect all the
+	 * settings to be the same as we left them:
+	 *
+	 *	PIRQ and SMI disabled, no R/WC bits set in USBLEGSUP;
+	 *	Controller is stopped and configured with EGSM set;
+	 *	No interrupts enabled except possibly Resume Detect.
+	 *
+	 * If any of these conditions are violated we do a complete reset.
+	 */
+	pci_read_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP, &amp;legsup);
+	if (legsup &amp; ~USBLEGSUP_RO) {
+		dev_dbg(uhci_dev(uhci), "%s: legsup = 0x%04x\n",
+				__FUNCTION__, legsup);
+		goto reset_needed;
+	}
+
+	cmd = inw(uhci-&gt;io_addr + USBCMD);
+	if ((cmd &amp; USBCMD_RS) || !(cmd &amp; USBCMD_CF) || !(cmd &amp; USBCMD_EGSM)) {
+		dev_dbg(uhci_dev(uhci), "%s: cmd = 0x%04x\n",
+				__FUNCTION__, cmd);
+		goto reset_needed;
+	}
+
+	intr = inw(uhci-&gt;io_addr + USBINTR);
+	if (intr &amp; (~USBINTR_RESUME)) {
+		dev_dbg(uhci_dev(uhci), "%s: intr = 0x%04x\n",
+				__FUNCTION__, intr);
+		goto reset_needed;
+	}
+	return;
+
+reset_needed:
+	dev_dbg(uhci_dev(uhci), "Performing full reset\n");
+	reset_hc(uhci);
+}
+
+/*
+ * Store the basic register settings needed by the controller.
+ */
+static void configure_hc(struct uhci_hcd *uhci)
+{
+	/* Set the frame length to the default: 1 ms exactly */
+	outb(USBSOF_DEFAULT, uhci-&gt;io_addr + USBSOF);
+
+	/* Store the frame list base address */
+	outl(uhci-&gt;fl-&gt;dma_handle, uhci-&gt;io_addr + USBFLBASEADD);
+
+	/* Set the current frame number */
+	outw(uhci-&gt;frame_number, uhci-&gt;io_addr + USBFRNUM);
+
+	/* Mark controller as running before we enable interrupts */
+	uhci_to_hcd(uhci)-&gt;state = HC_STATE_RUNNING;
+	mb();
+
+	/* Enable PIRQ */
+	pci_write_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP,
+			USBLEGSUP_DEFAULT);
+}
+
+
 static int resume_detect_interrupts_are_broken(struct uhci_hcd *uhci)
 {
 	int port;
@@ -163,7 +248,7 @@ static int resume_detect_interrupts_are_broken(struct uhci_hcd *uhci)
 	return 0;
 }
 
-static void suspend_hc(struct uhci_hcd *uhci, enum uhci_rh_state new_state)
+static void suspend_rh(struct uhci_hcd *uhci, enum uhci_rh_state new_state)
 __releases(uhci-&gt;lock)
 __acquires(uhci-&gt;lock)
 {
@@ -189,6 +274,7 @@ __acquires(uhci-&gt;lock)
 			0 : USBINTR_RESUME);
 	outw(int_enable, uhci-&gt;io_addr + USBINTR);
 	outw(USBCMD_EGSM | USBCMD_CF, uhci-&gt;io_addr + USBCMD);
+	mb();
 	udelay(5);
 
 	/* If we're auto-stopping then no devices have been attached
@@ -215,7 +301,22 @@ __acquires(uhci-&gt;lock)
 	uhci_scan_schedule(uhci, NULL);
 }
 
-static void wakeup_hc(struct uhci_hcd *uhci)
+static void start_rh(struct uhci_hcd *uhci)
+{
+	uhci-&gt;rh_state = UHCI_RH_RUNNING;
+	uhci-&gt;is_stopped = 0;
+	smp_wmb();
+
+	/* Mark it configured and running with a 64-byte max packet.
+	 * All interrupts are enabled, even though RESUME won't do anything.
+	 */
+	outw(USBCMD_RS | USBCMD_CF | USBCMD_MAXP, uhci-&gt;io_addr + USBCMD);
+	outw(USBINTR_TIMEOUT | USBINTR_RESUME | USBINTR_IOC | USBINTR_SP,
+			uhci-&gt;io_addr + USBINTR);
+	mb();
+}
+
+static void wakeup_rh(struct uhci_hcd *uhci)
 __releases(uhci-&gt;lock)
 __acquires(uhci-&gt;lock)
 {
@@ -237,62 +338,13 @@ __acquires(uhci-&gt;lock)
 
 		/* End Global Resume and wait for EOP to be sent */
 		outw(USBCMD_CF, uhci-&gt;io_addr + USBCMD);
+		mb();
 		udelay(4);
 		if (inw(uhci-&gt;io_addr + USBCMD) &amp; USBCMD_FGR)
 			dev_warn(uhci_dev(uhci), "FGR not stopped yet!\n");
 	}
 
-	uhci-&gt;rh_state = UHCI_RH_RUNNING;
-	uhci-&gt;is_stopped = 0;
-	smp_wmb();
-
-	/* Mark it configured and running with a 64-byte max packet.
-	 * All interrupts are enabled, even though RD won't do anything.
-	 */
-	outw(USBCMD_RS | USBCMD_CF | USBCMD_MAXP, uhci-&gt;io_addr + USBCMD);
-	outw(USBINTR_TIMEOUT | USBINTR_RESUME | USBINTR_IOC | USBINTR_SP,
-			uhci-&gt;io_addr + USBINTR);
-}
-
-static int start_hc(struct uhci_hcd *uhci)
-{
-	unsigned long io_addr = uhci-&gt;io_addr;
-	int timeout = 10;
-
-	/*
-	 * Reset the HC - this will force us to get a
-	 * new notification of any already connected
-	 * ports due to the virtual disconnect that it
-	 * implies.
-	 */
-	outw(USBCMD_HCRESET, io_addr + USBCMD);
-	while (inw(io_addr + USBCMD) &amp; USBCMD_HCRESET) {
-		if (--timeout &lt; 0) {
-			dev_err(uhci_dev(uhci), "USBCMD_HCRESET timed out!\n");
-			return -ETIMEDOUT;
-		}
-		msleep(1);
-	}
-
-	/* Mark controller as running before we enable interrupts */
-	uhci_to_hcd(uhci)-&gt;state = HC_STATE_RUNNING;
-
-	/* Turn on PIRQ and all interrupts */
-	pci_write_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP,
-			USBLEGSUP_DEFAULT);
-	outw(USBINTR_TIMEOUT | USBINTR_RESUME | USBINTR_IOC | USBINTR_SP,
-		io_addr + USBINTR);
-
-	/* Start at frame 0 */
-	outw(0, io_addr + USBFRNUM);
-	outl(uhci-&gt;fl-&gt;dma_handle, io_addr + USBFLBASEADD);
-
-	/* Run and mark it configured with a 64-byte max packet */
-	uhci-&gt;rh_state = UHCI_RH_RUNNING;
-	outw(USBCMD_RS | USBCMD_CF | USBCMD_MAXP, io_addr + USBCMD);
-	uhci-&gt;is_stopped = 0;
-
-	return 0;
+	start_rh(uhci);
 }
 
 static void rh_state_transitions(struct uhci_hcd *uhci)
@@ -311,13 +363,13 @@ static void rh_state_transitions(struct uhci_hcd *uhci)
 		if (any_ports_active(uhci))
 			uhci-&gt;rh_state = UHCI_RH_RUNNING;
 		else if (time_after_eq(jiffies, uhci-&gt;auto_stop_time))
-			suspend_hc(uhci, UHCI_RH_AUTO_STOPPED);
+			suspend_rh(uhci, UHCI_RH_AUTO_STOPPED);
 		break;
 
 	    case UHCI_RH_AUTO_STOPPED:
 		/* wakeup if requested by a device */
 		if (uhci-&gt;resume_detect)
-			wakeup_hc(uhci);
+			wakeup_rh(uhci);
 		break;
 
 	    default:
@@ -336,7 +388,7 @@ static void stall_callback(unsigned long _uhci)
 
 	/* Poll for and perform state transitions */
 	rh_state_transitions(uhci);
-	if (unlikely(uhci-&gt;suspended_ports))
+	if (uhci-&gt;suspended_ports &amp;&amp; !uhci-&gt;hc_inaccessible)
 		uhci_check_ports(uhci);
 
 	restart_timer(uhci);
@@ -346,7 +398,6 @@ static void stall_callback(unsigned long _uhci)
 static irqreturn_t uhci_irq(struct usb_hcd *hcd, struct pt_regs *regs)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
-	unsigned long io_addr = uhci-&gt;io_addr;
 	unsigned short status;
 
 	/*
@@ -354,10 +405,10 @@ static irqreturn_t uhci_irq(struct usb_hcd *hcd, struct pt_regs *regs)
 	 * interrupt cause.  Contrary to the UHCI specification, the
 	 * "HC Halted" status bit is persistent: it is RO, not R/WC.
 	 */
-	status = inw(io_addr + USBSTS);
+	status = inw(uhci-&gt;io_addr + USBSTS);
 	if (!(status &amp; ~USBSTS_HCH))	/* shared interrupt, not mine */
 		return IRQ_NONE;
-	outw(status, io_addr + USBSTS);		/* Clear it */
+	outw(status, uhci-&gt;io_addr + USBSTS);		/* Clear it */
 
 	if (status &amp; ~(USBSTS_USBINT | USBSTS_ERROR | USBSTS_RD)) {
 		if (status &amp; USBSTS_HSE)
@@ -440,10 +491,10 @@ static int uhci_reset(struct usb_hcd *hcd)
 
 	uhci-&gt;io_addr = (unsigned long) hcd-&gt;rsrc_start;
 
-	/* Kick BIOS off this hardware and reset, so we won't get
-	 * interrupts from any previous setup.
+	/* Kick BIOS off this hardware and reset if the controller
+	 * isn't already safely quiescent.
 	 */
-	reset_hc(uhci);
+	check_and_reset_hc(uhci);
 	return 0;
 }
 
@@ -634,11 +685,12 @@ static int uhci_start(struct usb_hcd *hcd)
 
 	/*
 	 * Some architectures require a full mb() to enforce completion of
-	 * the memory writes above before the I/O transfers in start_hc().
+	 * the memory writes above before the I/O transfers in configure_hc().
 	 */
 	mb();
-	if ((retval = start_hc(uhci)) != 0)
-		goto err_alloc_skelqh;
+
+	configure_hc(uhci);
+	start_rh(uhci);
 
 	restart_timer(uhci);
 
@@ -656,9 +708,8 @@ static int uhci_start(struct usb_hcd *hcd)
  * error exits:
  */
 err_start_root_hub:
-	reset_hc(uhci);
-
 	del_timer_sync(&amp;uhci-&gt;stall_timer);
+	reset_hc(uhci);
 
 err_alloc_skelqh:
 	for (i = 0; i &lt; UHCI_NUM_SKELQH; i++)
@@ -699,9 +750,9 @@ static void uhci_stop(struct usb_hcd *hcd)
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 
 	del_timer_sync(&amp;uhci-&gt;stall_timer);
-	reset_hc(uhci);
 
 	spin_lock_irq(&amp;uhci-&gt;lock);
+	reset_hc(uhci);
 	uhci_scan_schedule(uhci, NULL);
 	spin_unlock_irq(&amp;uhci-&gt;lock);
 	
@@ -709,12 +760,47 @@ static void uhci_stop(struct usb_hcd *hcd)
 }
 
 #ifdef CONFIG_PM
+static int uhci_rh_suspend(struct usb_hcd *hcd)
+{
+	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
+
+	spin_lock_irq(&amp;uhci-&gt;lock);
+	suspend_rh(uhci, UHCI_RH_SUSPENDED);
+	spin_unlock_irq(&amp;uhci-&gt;lock);
+	return 0;
+}
+
+static int uhci_rh_resume(struct usb_hcd *hcd)
+{
+	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
+
+	spin_lock_irq(&amp;uhci-&gt;lock);
+	wakeup_rh(uhci);
+	spin_unlock_irq(&amp;uhci-&gt;lock);
+	return 0;
+}
+
 static int uhci_suspend(struct usb_hcd *hcd, pm_message_t message)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 
+	dev_dbg(uhci_dev(uhci), "%s\n", __FUNCTION__);
+
 	spin_lock_irq(&amp;uhci-&gt;lock);
-	suspend_hc(uhci, UHCI_RH_SUSPENDED);
+
+#ifndef CONFIG_USB_SUSPEND
+	/* Otherwise this would never happen */
+	suspend_rh(uhci, UHCI_RH_SUSPENDED);
+#endif
+
+	/* All PCI host controllers are required to disable IRQ generation
+	 * at the source, so we must turn off PIRQ.
+	 */
+	pci_write_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP, 0);
+	uhci-&gt;hc_inaccessible = 1;
+
+	/* FIXME: Enable non-PME# remote wakeup? */
+
 	spin_unlock_irq(&amp;uhci-&gt;lock);
 	return 0;
 }
@@ -723,28 +809,28 @@ static int uhci_resume(struct usb_hcd *hcd)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 
+	dev_dbg(uhci_dev(uhci), "%s\n", __FUNCTION__);
+
 	spin_lock_irq(&amp;uhci-&gt;lock);
-	if (uhci-&gt;rh_state == UHCI_RH_SUSPENDED) {
 
-		/*
-		 * Some systems don't maintain the UHCI register values
-		 * during a PM suspend/resume cycle, so reinitialize
-		 * the Frame Number, Framelist Base Address, Interrupt
-		 * Enable, and Legacy Support registers.
-		 */
-		pci_write_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP,
-				0);
-		outw(uhci-&gt;frame_number, uhci-&gt;io_addr + USBFRNUM);
-		outl(uhci-&gt;fl-&gt;dma_handle, uhci-&gt;io_addr + USBFLBASEADD);
-		outw(USBINTR_TIMEOUT | USBINTR_RESUME | USBINTR_IOC |
-				USBINTR_SP, uhci-&gt;io_addr + USBINTR);
-		pci_write_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP,
-				USBLEGSUP_DEFAULT);
-		wakeup_hc(uhci);
-	}
-	spin_unlock_irq(&amp;uhci-&gt;lock);
+	/* FIXME: Disable non-PME# remote wakeup? */
+
+	uhci-&gt;hc_inaccessible = 0;
+
+	/* The BIOS may have changed the controller settings during a
+	 * system wakeup.  Check it and reconfigure to avoid problems.
+	 */
+	check_and_reset_hc(uhci);
+	configure_hc(uhci);
+
+#ifndef CONFIG_USB_SUSPEND
+	/* Otherwise this would never happen */
+	wakeup_rh(uhci);
+#endif
+	if (uhci-&gt;rh_state == UHCI_RH_RESET)
+		suspend_rh(uhci, UHCI_RH_SUSPENDED);
 
-	hcd-&gt;state = HC_STATE_RUNNING;
+	spin_unlock_irq(&amp;uhci-&gt;lock);
 	return 0;
 }
 #endif
@@ -792,6 +878,8 @@ static const struct hc_driver uhci_driver = {
 #ifdef CONFIG_PM
 	.suspend =		uhci_suspend,
 	.resume =		uhci_resume,
+	.hub_suspend =		uhci_rh_suspend,
+	.hub_resume =		uhci_rh_resume,
 #endif
 	.stop =			uhci_stop,
 
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index 4bac57c74ec2..827df5e06800 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -41,6 +41,7 @@
 #define USBFRNUM	6
 #define USBFLBASEADD	8
 #define USBSOF		12
+#define   USBSOF_DEFAULT	64	/* Frame length is exactly 1 ms */
 
 /* USB port status and control registers */
 #define USBPORTSC1	16
@@ -66,6 +67,8 @@
 /* Legacy support register */
 #define USBLEGSUP		0xc0
 #define   USBLEGSUP_DEFAULT	0x2000	/* only PIRQ enable set */
+#define   USBLEGSUP_RWC		0x8f00	/* the R/WC bits */
+#define   USBLEGSUP_RO		0x5040	/* R/O and reserved bits */
 
 #define UHCI_NULL_DATA_SIZE	0x7FF	/* for UHCI controller TD */
 
@@ -325,8 +328,9 @@ static inline int __interval_to_skel(int interval)
  */
 enum uhci_rh_state {
 	/* In the next 4 states the HC must be halted */
-	UHCI_RH_RESET,
+	UHCI_RH_RESET,			/* These two must come first */
 	UHCI_RH_SUSPENDED,
+
 	UHCI_RH_AUTO_STOPPED,
 	UHCI_RH_RESUMING,
 
@@ -334,7 +338,8 @@ enum uhci_rh_state {
 	 * can legally appear either way */
 	UHCI_RH_SUSPENDING,
 
-	/* In the next two states it's an error if the HC is halted */
+	/* In the next two states it's an error if the HC is halted.
+	 * These two must come last */
 	UHCI_RH_RUNNING,		/* The normal state */
 	UHCI_RH_RUNNING_NODEVS,		/* Running with no devices attached */
 };
@@ -376,6 +381,7 @@ struct uhci_hcd {
 	unsigned int scan_in_progress:1;	/* Schedule scan is running */
 	unsigned int need_rescan:1;		/* Redo the schedule scan */
 	unsigned int resume_detect:1;		/* Need a Global Resume */
+	unsigned int hc_inaccessible:1;		/* HC is suspended or dead */
 
 	/* Support for port suspend/resume/reset */
 	unsigned long port_c_suspend;		/* Bit-arrays of ports */
diff --git a/drivers/usb/host/uhci-hub.c b/drivers/usb/host/uhci-hub.c
index fc34fee2ab07..13652de52203 100644
--- a/drivers/usb/host/uhci-hub.c
+++ b/drivers/usb/host/uhci-hub.c
@@ -54,6 +54,9 @@ static int uhci_hub_status_data(struct usb_hcd *hcd, char *buf)
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 	int port;
 
+	if (uhci-&gt;hc_inaccessible)
+		return 0;
+
 	*buf = 0;
 	for (port = 0; port &lt; uhci-&gt;rh_numports; ++port) {
 		if ((inw(uhci-&gt;io_addr + USBPORTSC1 + port * 2) &amp; RWC_BITS) ||
@@ -150,6 +153,9 @@ static int uhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 	u16 wPortChange, wPortStatus;
 	unsigned long flags;
 
+	if (uhci-&gt;hc_inaccessible)
+		return -ETIMEDOUT;
+
 	spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
 	switch (typeReq) {
 </pre><hr><pre>commit c8f4fe4358c5e0a79b4bd47b814d19f1d1d06f21
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Apr 9 17:27:32 2005 -0400

    [PATCH] USB UHCI: Add root hub states
    
    This patch starts making some serious changes to the UHCI driver.
    There's a set of private states for the root hub, and the internal
    routines for suspending and resuming work completely differently, with
    transitions based on the new states.  Now the driver distinguishes
    between a privately auto-stopped state and a publicly suspended state,
    and it will properly suspend controllers with broken resume-detect
    interrupts instead of resetting them.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-debug.c b/drivers/usb/host/uhci-debug.c
index 24c73c5a3435..4538a98b6f9d 100644
--- a/drivers/usb/host/uhci-debug.c
+++ b/drivers/usb/host/uhci-debug.c
@@ -237,6 +237,37 @@ static int uhci_show_sc(int port, unsigned short status, char *buf, int len)
 	return out - buf;
 }
 
+static int uhci_show_root_hub_state(struct uhci_hcd *uhci, char *buf, int len)
+{
+	char *out = buf;
+	char *rh_state;
+
+	/* Try to make sure there's enough memory */
+	if (len &lt; 60)
+		return 0;
+
+	switch (uhci-&gt;rh_state) {
+	    case UHCI_RH_RESET:
+		rh_state = "reset";		break;
+	    case UHCI_RH_SUSPENDED:
+		rh_state = "suspended";		break;
+	    case UHCI_RH_AUTO_STOPPED:
+		rh_state = "auto-stopped";	break;
+	    case UHCI_RH_RESUMING:
+		rh_state = "resuming";		break;
+	    case UHCI_RH_SUSPENDING:
+		rh_state = "suspending";	break;
+	    case UHCI_RH_RUNNING:
+		rh_state = "running";		break;
+	    case UHCI_RH_RUNNING_NODEVS:
+		rh_state = "running, no devs";	break;
+	    default:
+		rh_state = "?";			break;
+	}
+	out += sprintf(out, "Root-hub state: %s\n", rh_state);
+	return out - buf;
+}
+
 static int uhci_show_status(struct uhci_hcd *uhci, char *buf, int len)
 {
 	char *out = buf;
@@ -408,6 +439,7 @@ static int uhci_sprint_schedule(struct uhci_hcd *uhci, char *buf, int len)
 
 	spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
 
+	out += uhci_show_root_hub_state(uhci, out, len - (out - buf));
 	out += sprintf(out, "HC status\n");
 	out += uhci_show_status(uhci, out, len - (out - buf));
 
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index c17bd7ebc021..57b36dcea5d0 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -64,7 +64,7 @@
 /*
  * Version Information
  */
-#define DRIVER_VERSION "v2.2"
+#define DRIVER_VERSION "v2.3"
 #define DRIVER_AUTHOR "Linus 'Frodo Rabbit' Torvalds, Johannes Erdfelt, \
 Randy Dunlap, Georg Acher, Deti Fliegl, Thomas Sailer, Roman Weissgaerber, \
 Alan Stern"
@@ -109,33 +109,6 @@ static inline void restart_timer(struct uhci_hcd *uhci)
 #include "uhci-debug.c"
 #include "uhci-q.c"
 
-static int suspend_allowed(struct uhci_hcd *uhci)
-{
-	unsigned long io_addr = uhci-&gt;io_addr;
-	int i;
-
-	if (to_pci_dev(uhci_dev(uhci))-&gt;vendor != PCI_VENDOR_ID_INTEL)
-		return 1;
-
-	/* Some of Intel's USB controllers have a bug that causes false
-	 * resume indications if any port has an over current condition.
-	 * To prevent problems, we will not allow a global suspend if
-	 * any ports are OC.
-	 *
-	 * Some motherboards using Intel's chipsets (but not using all
-	 * the USB ports) appear to hardwire the over current inputs active
-	 * to disable the USB ports.
-	 */
-
-	/* check for over current condition on any port */
-	for (i = 0; i &lt; uhci-&gt;rh_numports; i++) {
-		if (inw(io_addr + USBPORTSC1 + i * 2) &amp; USBPORTSC_OC)
-			return 0;
-	}
-
-	return 1;
-}
-
 static void reset_hc(struct uhci_hcd *uhci)
 {
 	unsigned long io_addr = uhci-&gt;io_addr;
@@ -147,7 +120,6 @@ static void reset_hc(struct uhci_hcd *uhci)
 	outw(0, uhci-&gt;io_addr + USBINTR);
 
 	/* Global reset for 50ms */
-	uhci-&gt;state = UHCI_RESET;
 	outw(USBCMD_GRESET, io_addr + USBCMD);
 	msleep(50);
 	outw(0, io_addr + USBCMD);
@@ -156,63 +128,130 @@ static void reset_hc(struct uhci_hcd *uhci)
 	msleep(10);
 	uhci-&gt;resume_detect = 0;
 	uhci-&gt;is_stopped = UHCI_IS_STOPPED;
+	uhci-&gt;rh_state = UHCI_RH_RESET;
 }
 
-static void suspend_hc(struct uhci_hcd *uhci)
+static int resume_detect_interrupts_are_broken(struct uhci_hcd *uhci)
 {
-	unsigned long io_addr = uhci-&gt;io_addr;
+	int port;
 
-	dev_dbg(uhci_dev(uhci), "%s\n", __FUNCTION__);
-	uhci-&gt;state = UHCI_SUSPENDED;
-	uhci-&gt;resume_detect = 0;
-	outw(USBCMD_EGSM, io_addr + USBCMD);
+	switch (to_pci_dev(uhci_dev(uhci))-&gt;vendor) {
+	    default:
+		break;
+
+	    case PCI_VENDOR_ID_GENESYS:
+		/* Genesys Logic's GL880S controllers don't generate
+		 * resume-detect interrupts.
+		 */
+		return 1;
+
+	    case PCI_VENDOR_ID_INTEL:
+		/* Some of Intel's USB controllers have a bug that causes
+		 * resume-detect interrupts if any port has an over-current
+		 * condition.  To make matters worse, some motherboards
+		 * hardwire unused USB ports' over-current inputs active!
+		 * To prevent problems, we will not enable resume-detect
+		 * interrupts if any ports are OC.
+		 */
+		for (port = 0; port &lt; uhci-&gt;rh_numports; ++port) {
+			if (inw(uhci-&gt;io_addr + USBPORTSC1 + port * 2) &amp;
+					USBPORTSC_OC)
+				return 1;
+		}
+		break;
+	}
+	return 0;
+}
+
+static void suspend_hc(struct uhci_hcd *uhci, enum uhci_rh_state new_state)
+__releases(uhci-&gt;lock)
+__acquires(uhci-&gt;lock)
+{
+	int auto_stop;
+	int int_enable;
+
+	auto_stop = (new_state == UHCI_RH_AUTO_STOPPED);
+	dev_dbg(uhci_dev(uhci), "%s%s\n", __FUNCTION__,
+			(auto_stop ? " (auto-stop)" : ""));
+
+	/* If we get a suspend request when we're already auto-stopped
+	 * then there's nothing to do.
+	 */
+	if (uhci-&gt;rh_state == UHCI_RH_AUTO_STOPPED) {
+		uhci-&gt;rh_state = new_state;
+		return;
+	}
+
+	/* Enable resume-detect interrupts if they work.
+	 * Then enter Global Suspend mode, still configured.
+	 */
+	int_enable = (resume_detect_interrupts_are_broken(uhci) ?
+			0 : USBINTR_RESUME);
+	outw(int_enable, uhci-&gt;io_addr + USBINTR);
+	outw(USBCMD_EGSM | USBCMD_CF, uhci-&gt;io_addr + USBCMD);
+	udelay(5);
+
+	/* If we're auto-stopping then no devices have been attached
+	 * for a while, so there shouldn't be any active URBs and the
+	 * controller should stop after a few microseconds.  Otherwise
+	 * we will give the controller one frame to stop.
+	 */
+	if (!auto_stop &amp;&amp; !(inw(uhci-&gt;io_addr + USBSTS) &amp; USBSTS_HCH)) {
+		uhci-&gt;rh_state = UHCI_RH_SUSPENDING;
+		spin_unlock_irq(&amp;uhci-&gt;lock);
+		msleep(1);
+		spin_lock_irq(&amp;uhci-&gt;lock);
+	}
+	if (!(inw(uhci-&gt;io_addr + USBSTS) &amp; USBSTS_HCH))
+		dev_warn(uhci_dev(uhci), "Controller not stopped yet!\n");
 
-	/* FIXME: Wait for the controller to actually stop */
 	uhci_get_current_frame_number(uhci);
+	smp_wmb();
+
+	uhci-&gt;rh_state = new_state;
 	uhci-&gt;is_stopped = UHCI_IS_STOPPED;
+	uhci-&gt;resume_detect = 0;
 
 	uhci_scan_schedule(uhci, NULL);
 }
 
 static void wakeup_hc(struct uhci_hcd *uhci)
+__releases(uhci-&gt;lock)
+__acquires(uhci-&gt;lock)
 {
-	unsigned long io_addr = uhci-&gt;io_addr;
+	dev_dbg(uhci_dev(uhci), "%s%s\n", __FUNCTION__,
+			uhci-&gt;rh_state == UHCI_RH_AUTO_STOPPED ?
+				" (auto-start)" : "");
 
-	switch (uhci-&gt;state) {
-		case UHCI_SUSPENDED:		/* Start the resume */
-			dev_dbg(uhci_dev(uhci), "%s\n", __FUNCTION__);
-
-			/* Global resume for &gt;= 20ms */
-			outw(USBCMD_FGR | USBCMD_EGSM, io_addr + USBCMD);
-			uhci-&gt;state = UHCI_RESUMING_1;
-			uhci-&gt;state_end = jiffies + msecs_to_jiffies(20);
-			uhci-&gt;is_stopped = 0;
-			break;
+	/* If we are auto-stopped then no devices are attached so there's
+	 * no need for wakeup signals.  Otherwise we send Global Resume
+	 * for 20 ms.
+	 */
+	if (uhci-&gt;rh_state == UHCI_RH_SUSPENDED) {
+		uhci-&gt;rh_state = UHCI_RH_RESUMING;
+		outw(USBCMD_FGR | USBCMD_EGSM | USBCMD_CF,
+				uhci-&gt;io_addr + USBCMD);
+		spin_unlock_irq(&amp;uhci-&gt;lock);
+		msleep(20);
+		spin_lock_irq(&amp;uhci-&gt;lock);
 
-		case UHCI_RESUMING_1:		/* End global resume */
-			uhci-&gt;state = UHCI_RESUMING_2;
-			outw(0, io_addr + USBCMD);
-			/* Falls through */
-
-		case UHCI_RESUMING_2:		/* Wait for EOP to be sent */
-			if (inw(io_addr + USBCMD) &amp; USBCMD_FGR)
-				break;
-
-			/* Run for at least 1 second, and
-			 * mark it configured with a 64-byte max packet */
-			uhci-&gt;state = UHCI_RUNNING_GRACE;
-			uhci-&gt;state_end = jiffies + HZ;
-			outw(USBCMD_RS | USBCMD_CF | USBCMD_MAXP,
-					io_addr + USBCMD);
-			break;
+		/* End Global Resume and wait for EOP to be sent */
+		outw(USBCMD_CF, uhci-&gt;io_addr + USBCMD);
+		udelay(4);
+		if (inw(uhci-&gt;io_addr + USBCMD) &amp; USBCMD_FGR)
+			dev_warn(uhci_dev(uhci), "FGR not stopped yet!\n");
+	}
 
-		case UHCI_RUNNING_GRACE:	/* Now allowed to suspend */
-			uhci-&gt;state = UHCI_RUNNING;
-			break;
+	uhci-&gt;rh_state = UHCI_RH_RUNNING;
+	uhci-&gt;is_stopped = 0;
+	smp_wmb();
 
-		default:
-			break;
-	}
+	/* Mark it configured and running with a 64-byte max packet.
+	 * All interrupts are enabled, even though RD won't do anything.
+	 */
+	outw(USBCMD_RS | USBCMD_CF | USBCMD_MAXP, uhci-&gt;io_addr + USBCMD);
+	outw(USBINTR_TIMEOUT | USBINTR_RESUME | USBINTR_IOC | USBINTR_SP,
+			uhci-&gt;io_addr + USBINTR);
 }
 
 static int start_hc(struct uhci_hcd *uhci)
@@ -249,49 +288,40 @@ static int start_hc(struct uhci_hcd *uhci)
 	outl(uhci-&gt;fl-&gt;dma_handle, io_addr + USBFLBASEADD);
 
 	/* Run and mark it configured with a 64-byte max packet */
-	uhci-&gt;state = UHCI_RUNNING_GRACE;
-	uhci-&gt;state_end = jiffies + HZ;
+	uhci-&gt;rh_state = UHCI_RH_RUNNING;
 	outw(USBCMD_RS | USBCMD_CF | USBCMD_MAXP, io_addr + USBCMD);
 	uhci-&gt;is_stopped = 0;
 
 	return 0;
 }
 
-static void hc_state_transitions(struct uhci_hcd *uhci)
+static void rh_state_transitions(struct uhci_hcd *uhci)
 {
-	switch (uhci-&gt;state) {
-		case UHCI_RUNNING:
-
-			/* global suspend if nothing connected for 1 second */
-			if (!any_ports_active(uhci) &amp;&amp; suspend_allowed(uhci)) {
-				uhci-&gt;state = UHCI_SUSPENDING_GRACE;
-				uhci-&gt;state_end = jiffies + HZ;
-			}
-			break;
-
-		case UHCI_SUSPENDING_GRACE:
-			if (any_ports_active(uhci))
-				uhci-&gt;state = UHCI_RUNNING;
-			else if (time_after_eq(jiffies, uhci-&gt;state_end))
-				suspend_hc(uhci);
-			break;
-
-		case UHCI_SUSPENDED:
-
-			/* wakeup if requested by a device */
-			if (uhci-&gt;resume_detect)
-				wakeup_hc(uhci);
-			break;
-
-		case UHCI_RESUMING_1:
-		case UHCI_RESUMING_2:
-		case UHCI_RUNNING_GRACE:
-			if (time_after_eq(jiffies, uhci-&gt;state_end))
-				wakeup_hc(uhci);
-			break;
-
-		default:
-			break;
+	switch (uhci-&gt;rh_state) {
+	    case UHCI_RH_RUNNING:
+		/* are any devices attached? */
+		if (!any_ports_active(uhci)) {
+			uhci-&gt;rh_state = UHCI_RH_RUNNING_NODEVS;
+			uhci-&gt;auto_stop_time = jiffies + HZ;
+		}
+		break;
+
+	    case UHCI_RH_RUNNING_NODEVS:
+		/* auto-stop if nothing connected for 1 second */
+		if (any_ports_active(uhci))
+			uhci-&gt;rh_state = UHCI_RH_RUNNING;
+		else if (time_after_eq(jiffies, uhci-&gt;auto_stop_time))
+			suspend_hc(uhci, UHCI_RH_AUTO_STOPPED);
+		break;
+
+	    case UHCI_RH_AUTO_STOPPED:
+		/* wakeup if requested by a device */
+		if (uhci-&gt;resume_detect)
+			wakeup_hc(uhci);
+		break;
+
+	    default:
+		break;
 	}
 }
 
@@ -305,8 +335,8 @@ static void stall_callback(unsigned long _uhci)
 	check_fsbr(uhci);
 
 	/* Poll for and perform state transitions */
-	hc_state_transitions(uhci);
-	if (unlikely(uhci-&gt;suspended_ports &amp;&amp; uhci-&gt;state != UHCI_SUSPENDED))
+	rh_state_transitions(uhci);
+	if (unlikely(uhci-&gt;suspended_ports))
 		uhci_check_ports(uhci);
 
 	restart_timer(uhci);
@@ -336,7 +366,8 @@ static irqreturn_t uhci_irq(struct usb_hcd *hcd, struct pt_regs *regs)
 		if (status &amp; USBSTS_HCPE)
 			dev_err(uhci_dev(uhci), "host controller process "
 					"error, something bad happened!\n");
-		if ((status &amp; USBSTS_HCH) &amp;&amp; uhci-&gt;state &gt; 0) {
+		if ((status &amp; USBSTS_HCH) &amp;&amp;
+				uhci-&gt;rh_state &gt;= UHCI_RH_RUNNING) {
 			dev_err(uhci_dev(uhci), "host controller halted, "
 					"very bad!\n");
 			/* FIXME: Reset the controller, fix the offending TD */
@@ -683,17 +714,7 @@ static int uhci_suspend(struct usb_hcd *hcd, pm_message_t message)
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 
 	spin_lock_irq(&amp;uhci-&gt;lock);
-
-	/* Don't try to suspend broken motherboards, reset instead */
-	if (suspend_allowed(uhci))
-		suspend_hc(uhci);
-	else {
-		spin_unlock_irq(&amp;uhci-&gt;lock);
-		reset_hc(uhci);
-		spin_lock_irq(&amp;uhci-&gt;lock);
-		uhci_scan_schedule(uhci, NULL);
-	}
-
+	suspend_hc(uhci, UHCI_RH_SUSPENDED);
 	spin_unlock_irq(&amp;uhci-&gt;lock);
 	return 0;
 }
@@ -701,13 +722,9 @@ static int uhci_suspend(struct usb_hcd *hcd, pm_message_t message)
 static int uhci_resume(struct usb_hcd *hcd)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
-	int rc;
-
-	pci_set_master(to_pci_dev(uhci_dev(uhci)));
 
 	spin_lock_irq(&amp;uhci-&gt;lock);
-
-	if (uhci-&gt;state == UHCI_SUSPENDED) {
+	if (uhci-&gt;rh_state == UHCI_RH_SUSPENDED) {
 
 		/*
 		 * Some systems don't maintain the UHCI register values
@@ -721,19 +738,13 @@ static int uhci_resume(struct usb_hcd *hcd)
 		outl(uhci-&gt;fl-&gt;dma_handle, uhci-&gt;io_addr + USBFLBASEADD);
 		outw(USBINTR_TIMEOUT | USBINTR_RESUME | USBINTR_IOC |
 				USBINTR_SP, uhci-&gt;io_addr + USBINTR);
-		uhci-&gt;resume_detect = 1;
 		pci_write_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP,
 				USBLEGSUP_DEFAULT);
-	} else {
-		spin_unlock_irq(&amp;uhci-&gt;lock);
-		reset_hc(uhci);
-		if ((rc = start_hc(uhci)) != 0)
-			return rc;
-		spin_lock_irq(&amp;uhci-&gt;lock);
+		wakeup_hc(uhci);
 	}
-	hcd-&gt;state = HC_STATE_RUNNING;
-
 	spin_unlock_irq(&amp;uhci-&gt;lock);
+
+	hcd-&gt;state = HC_STATE_RUNNING;
 	return 0;
 }
 #endif
@@ -750,13 +761,15 @@ static void uhci_hcd_endpoint_disable(struct usb_hcd *hcd,
 static int uhci_hcd_get_frame_number(struct usb_hcd *hcd)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
-	int frame_number;
 	unsigned long flags;
+	int is_stopped;
+	int frame_number;
 
 	/* Minimize latency by avoiding the spinlock */
 	local_irq_save(flags);
-	rmb();
-	frame_number = (uhci-&gt;is_stopped ? uhci-&gt;frame_number :
+	is_stopped = uhci-&gt;is_stopped;
+	smp_rmb();
+	frame_number = (is_stopped ? uhci-&gt;frame_number :
 			inw(uhci-&gt;io_addr + USBFRNUM));
 	local_irq_restore(flags);
 	return frame_number;
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index 02255d69e1fe..4bac57c74ec2 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -314,26 +314,29 @@ static inline int __interval_to_skel(int interval)
 }
 
 /*
- * Device states for the host controller.
+ * States for the root hub.
  *
  * To prevent "bouncing" in the presence of electrical noise,
- * we insist on a 1-second "grace" period, before switching to
- * the RUNNING or SUSPENDED states, during which the state is
- * not allowed to change.
- *
- * The resume process is divided into substates in order to avoid
- * potentially length delays during the timer handler.
- *
- * States in which the host controller is halted must have values &lt;= 0.
+ * when there are no devices attached we delay for 1 second in the
+ * RUNNING_NODEVS state before switching to the AUTO_STOPPED state.
+ * 
+ * (Note that the AUTO_STOPPED state won't be necessary once the hub
+ * driver learns to autosuspend.)
  */
-enum uhci_state {
-	UHCI_RESET,
-	UHCI_RUNNING_GRACE,		/* Before RUNNING */
-	UHCI_RUNNING,			/* The normal state */
-	UHCI_SUSPENDING_GRACE,		/* Before SUSPENDED */
-	UHCI_SUSPENDED = -10,		/* When no devices are attached */
-	UHCI_RESUMING_1,
-	UHCI_RESUMING_2
+enum uhci_rh_state {
+	/* In the next 4 states the HC must be halted */
+	UHCI_RH_RESET,
+	UHCI_RH_SUSPENDED,
+	UHCI_RH_AUTO_STOPPED,
+	UHCI_RH_RESUMING,
+
+	/* In the next state the HC changes from running to halted, so it
+	 * can legally appear either way */
+	UHCI_RH_SUSPENDING,
+
+	/* In the next two states it's an error if the HC is halted */
+	UHCI_RH_RUNNING,		/* The normal state */
+	UHCI_RH_RUNNING_NODEVS,		/* Running with no devices attached */
 };
 
 /*
@@ -363,8 +366,9 @@ struct uhci_hcd {
 	int fsbr;				/* Full-speed bandwidth reclamation */
 	unsigned long fsbrtimeout;		/* FSBR delay */
 
-	enum uhci_state state;			/* FIXME: needs a spinlock */
-	unsigned long state_end;		/* Time of next transition */
+	enum uhci_rh_state rh_state;
+	unsigned long auto_stop_time;		/* When to AUTO_STOP */
+
 	unsigned int frame_number;		/* As of last check */
 	unsigned int is_stopped;
 #define UHCI_IS_STOPPED		9999		/* Larger than a frame # */
@@ -451,4 +455,11 @@ struct urb_priv {
  * #2 urb-&gt;lock
  */
 
+
+/* Some special IDs */
+
+#define PCI_VENDOR_ID_GENESYS		0x17a0
+#define PCI_DEVICE_ID_GL880S_UHCI	0x8083
+#define PCI_DEVICE_ID_GL880S_EHCI	0x8084
+
 #endif
diff --git a/drivers/usb/host/uhci-hub.c b/drivers/usb/host/uhci-hub.c
index ddb19cbf4b75..fc34fee2ab07 100644
--- a/drivers/usb/host/uhci-hub.c
+++ b/drivers/usb/host/uhci-hub.c
@@ -60,7 +60,7 @@ static int uhci_hub_status_data(struct usb_hcd *hcd, char *buf)
 				test_bit(port, &amp;uhci-&gt;port_c_suspend))
 			*buf |= (1 &lt;&lt; (port + 1));
 	}
-	if (*buf &amp;&amp; uhci-&gt;state == UHCI_SUSPENDED)
+	if (*buf &amp;&amp; uhci-&gt;is_stopped)
 		uhci-&gt;resume_detect = 1;
 	return !!*buf;
 }</pre><hr><pre>commit f5946f8220a866dcdb8edc6abe23c1443e252425
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Apr 9 17:26:00 2005 -0400

    [PATCH] USB UHCI: Minor improvements
    
    This patch makes a few small improvements in the UHCI driver.  Some
    code is moved between different source files and a more useful pointer
    is passed to a callback routine.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 8b6c87ef486b..c17bd7ebc021 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -100,22 +100,15 @@ static void uhci_get_current_frame_number(struct uhci_hcd *uhci);
 /* to make sure it doesn't hog all of the bandwidth */
 #define DEPTH_INTERVAL 5
 
+static inline void restart_timer(struct uhci_hcd *uhci)
+{
+	mod_timer(&amp;uhci-&gt;stall_timer, jiffies + msecs_to_jiffies(100));
+}
+
 #include "uhci-hub.c"
 #include "uhci-debug.c"
 #include "uhci-q.c"
 
-static int ports_active(struct uhci_hcd *uhci)
-{
-	unsigned long io_addr = uhci-&gt;io_addr;
-	int connection = 0;
-	int i;
-
-	for (i = 0; i &lt; uhci-&gt;rh_numports; i++)
-		connection |= (inw(io_addr + USBPORTSC1 + i * 2) &amp; USBPORTSC_CCS);
-
-	return connection;
-}
-
 static int suspend_allowed(struct uhci_hcd *uhci)
 {
 	unsigned long io_addr = uhci-&gt;io_addr;
@@ -270,14 +263,14 @@ static void hc_state_transitions(struct uhci_hcd *uhci)
 		case UHCI_RUNNING:
 
 			/* global suspend if nothing connected for 1 second */
-			if (!ports_active(uhci) &amp;&amp; suspend_allowed(uhci)) {
+			if (!any_ports_active(uhci) &amp;&amp; suspend_allowed(uhci)) {
 				uhci-&gt;state = UHCI_SUSPENDING_GRACE;
 				uhci-&gt;state_end = jiffies + HZ;
 			}
 			break;
 
 		case UHCI_SUSPENDING_GRACE:
-			if (ports_active(uhci))
+			if (any_ports_active(uhci))
 				uhci-&gt;state = UHCI_RUNNING;
 			else if (time_after_eq(jiffies, uhci-&gt;state_end))
 				suspend_hc(uhci);
@@ -302,58 +295,24 @@ static void hc_state_transitions(struct uhci_hcd *uhci)
 	}
 }
 
-static int init_stall_timer(struct usb_hcd *hcd);
-
-static void stall_callback(unsigned long ptr)
+static void stall_callback(unsigned long _uhci)
 {
-	struct usb_hcd *hcd = (struct usb_hcd *)ptr;
-	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
-	struct urb_priv *up;
+	struct uhci_hcd *uhci = (struct uhci_hcd *) _uhci;
 	unsigned long flags;
 
 	spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
 	uhci_scan_schedule(uhci, NULL);
-
-	list_for_each_entry(up, &amp;uhci-&gt;urb_list, urb_list) {
-		struct urb *u = up-&gt;urb;
-
-		spin_lock(&amp;u-&gt;lock);
-
-		/* Check if the FSBR timed out */
-		if (up-&gt;fsbr &amp;&amp; !up-&gt;fsbr_timeout &amp;&amp; time_after_eq(jiffies, up-&gt;fsbrtime + IDLE_TIMEOUT))
-			uhci_fsbr_timeout(uhci, u);
-
-		spin_unlock(&amp;u-&gt;lock);
-	}
-
-	/* Really disable FSBR */
-	if (!uhci-&gt;fsbr &amp;&amp; uhci-&gt;fsbrtimeout &amp;&amp; time_after_eq(jiffies, uhci-&gt;fsbrtimeout)) {
-		uhci-&gt;fsbrtimeout = 0;
-		uhci-&gt;skel_term_qh-&gt;link = UHCI_PTR_TERM;
-	}
+	check_fsbr(uhci);
 
 	/* Poll for and perform state transitions */
 	hc_state_transitions(uhci);
 	if (unlikely(uhci-&gt;suspended_ports &amp;&amp; uhci-&gt;state != UHCI_SUSPENDED))
 		uhci_check_ports(uhci);
 
-	init_stall_timer(hcd);
+	restart_timer(uhci);
 	spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
 }
 
-static int init_stall_timer(struct usb_hcd *hcd)
-{
-	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
-
-	init_timer(&amp;uhci-&gt;stall_timer);
-	uhci-&gt;stall_timer.function = stall_callback;
-	uhci-&gt;stall_timer.data = (unsigned long)hcd;
-	uhci-&gt;stall_timer.expires = jiffies + msecs_to_jiffies(100);
-	add_timer(&amp;uhci-&gt;stall_timer);
-
-	return 0;
-}
-
 static irqreturn_t uhci_irq(struct usb_hcd *hcd, struct pt_regs *regs)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
@@ -509,6 +468,10 @@ static int uhci_start(struct usb_hcd *hcd)
 
 	init_waitqueue_head(&amp;uhci-&gt;waitqh);
 
+	init_timer(&amp;uhci-&gt;stall_timer);
+	uhci-&gt;stall_timer.function = stall_callback;
+	uhci-&gt;stall_timer.data = (unsigned long) uhci;
+
 	uhci-&gt;fl = dma_alloc_coherent(uhci_dev(uhci), sizeof(*uhci-&gt;fl),
 			&amp;dma_handle, 0);
 	if (!uhci-&gt;fl) {
@@ -646,7 +609,7 @@ static int uhci_start(struct usb_hcd *hcd)
 	if ((retval = start_hc(uhci)) != 0)
 		goto err_alloc_skelqh;
 
-	init_stall_timer(hcd);
+	restart_timer(uhci);
 
 	udev-&gt;speed = USB_SPEED_FULL;
 
diff --git a/drivers/usb/host/uhci-hub.c b/drivers/usb/host/uhci-hub.c
index 4c45ba8390f8..ddb19cbf4b75 100644
--- a/drivers/usb/host/uhci-hub.c
+++ b/drivers/usb/host/uhci-hub.c
@@ -33,6 +33,22 @@ static __u8 root_hub_hub_des[] =
 /* status change bits:  nonzero writes will clear */
 #define RWC_BITS	(USBPORTSC_OCC | USBPORTSC_PEC | USBPORTSC_CSC)
 
+/* A port that either is connected or has a changed-bit set will prevent
+ * us from AUTO_STOPPING.
+ */
+static int any_ports_active(struct uhci_hcd *uhci)
+{
+	int port;
+
+	for (port = 0; port &lt; uhci-&gt;rh_numports; ++port) {
+		if ((inw(uhci-&gt;io_addr + USBPORTSC1 + port * 2) &amp;
+				(USBPORTSC_CCS | RWC_BITS)) ||
+				test_bit(port, &amp;uhci-&gt;port_c_suspend))
+			return 1;
+	}
+	return 0;
+}
+
 static int uhci_hub_status_data(struct usb_hcd *hcd, char *buf)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 2a7c19501f24..f5c75885f7be 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -1537,3 +1537,26 @@ static void uhci_scan_schedule(struct uhci_hcd *uhci, struct pt_regs *regs)
 	/* Wake up anyone waiting for an URB to complete */
 	wake_up_all(&amp;uhci-&gt;waitqh);
 }
+
+static void check_fsbr(struct uhci_hcd *uhci)
+{
+	struct urb_priv *up;
+
+	list_for_each_entry(up, &amp;uhci-&gt;urb_list, urb_list) {
+		struct urb *u = up-&gt;urb;
+
+		spin_lock(&amp;u-&gt;lock);
+
+		/* Check if the FSBR timed out */
+		if (up-&gt;fsbr &amp;&amp; !up-&gt;fsbr_timeout &amp;&amp; time_after_eq(jiffies, up-&gt;fsbrtime + IDLE_TIMEOUT))
+			uhci_fsbr_timeout(uhci, u);
+
+		spin_unlock(&amp;u-&gt;lock);
+	}
+
+	/* Really disable FSBR */
+	if (!uhci-&gt;fsbr &amp;&amp; uhci-&gt;fsbrtimeout &amp;&amp; time_after_eq(jiffies, uhci-&gt;fsbrtimeout)) {
+		uhci-&gt;fsbrtimeout = 0;
+		uhci-&gt;skel_term_qh-&gt;link = UHCI_PTR_TERM;
+	}
+}</pre><hr><pre>commit 014e73c99aa408f3766afe8d11a1caa3a708b736
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Apr 9 17:24:42 2005 -0400

    [PATCH] USB UHCI: subroutine reordering
    
    This patch moves a few subroutines around in the uhci-hcd source file.
    Nothing else is changed.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 49bd83ee0c75..8b6c87ef486b 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -90,7 +90,6 @@ static char *errbuf;
 static kmem_cache_t *uhci_up_cachep;	/* urb_priv */
 
 static void uhci_get_current_frame_number(struct uhci_hcd *uhci);
-static void hc_state_transitions(struct uhci_hcd *uhci);
 
 /* If a transfer is still active after this much time, turn off FSBR */
 #define IDLE_TIMEOUT	msecs_to_jiffies(50)
@@ -105,96 +104,43 @@ static void hc_state_transitions(struct uhci_hcd *uhci);
 #include "uhci-debug.c"
 #include "uhci-q.c"
 
-static int init_stall_timer(struct usb_hcd *hcd);
-
-static void stall_callback(unsigned long ptr)
-{
-	struct usb_hcd *hcd = (struct usb_hcd *)ptr;
-	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
-	struct urb_priv *up;
-	unsigned long flags;
-
-	spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
-	uhci_scan_schedule(uhci, NULL);
-
-	list_for_each_entry(up, &amp;uhci-&gt;urb_list, urb_list) {
-		struct urb *u = up-&gt;urb;
-
-		spin_lock(&amp;u-&gt;lock);
-
-		/* Check if the FSBR timed out */
-		if (up-&gt;fsbr &amp;&amp; !up-&gt;fsbr_timeout &amp;&amp; time_after_eq(jiffies, up-&gt;fsbrtime + IDLE_TIMEOUT))
-			uhci_fsbr_timeout(uhci, u);
-
-		spin_unlock(&amp;u-&gt;lock);
-	}
-
-	/* Really disable FSBR */
-	if (!uhci-&gt;fsbr &amp;&amp; uhci-&gt;fsbrtimeout &amp;&amp; time_after_eq(jiffies, uhci-&gt;fsbrtimeout)) {
-		uhci-&gt;fsbrtimeout = 0;
-		uhci-&gt;skel_term_qh-&gt;link = UHCI_PTR_TERM;
-	}
-
-	/* Poll for and perform state transitions */
-	hc_state_transitions(uhci);
-	if (unlikely(uhci-&gt;suspended_ports &amp;&amp; uhci-&gt;state != UHCI_SUSPENDED))
-		uhci_check_ports(uhci);
-
-	init_stall_timer(hcd);
-	spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
-}
-
-static int init_stall_timer(struct usb_hcd *hcd)
+static int ports_active(struct uhci_hcd *uhci)
 {
-	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
+	unsigned long io_addr = uhci-&gt;io_addr;
+	int connection = 0;
+	int i;
 
-	init_timer(&amp;uhci-&gt;stall_timer);
-	uhci-&gt;stall_timer.function = stall_callback;
-	uhci-&gt;stall_timer.data = (unsigned long)hcd;
-	uhci-&gt;stall_timer.expires = jiffies + msecs_to_jiffies(100);
-	add_timer(&amp;uhci-&gt;stall_timer);
+	for (i = 0; i &lt; uhci-&gt;rh_numports; i++)
+		connection |= (inw(io_addr + USBPORTSC1 + i * 2) &amp; USBPORTSC_CCS);
 
-	return 0;
+	return connection;
 }
 
-static irqreturn_t uhci_irq(struct usb_hcd *hcd, struct pt_regs *regs)
+static int suspend_allowed(struct uhci_hcd *uhci)
 {
-	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 	unsigned long io_addr = uhci-&gt;io_addr;
-	unsigned short status;
+	int i;
 
-	/*
-	 * Read the interrupt status, and write it back to clear the
-	 * interrupt cause.  Contrary to the UHCI specification, the
-	 * "HC Halted" status bit is persistent: it is RO, not R/WC.
+	if (to_pci_dev(uhci_dev(uhci))-&gt;vendor != PCI_VENDOR_ID_INTEL)
+		return 1;
+
+	/* Some of Intel's USB controllers have a bug that causes false
+	 * resume indications if any port has an over current condition.
+	 * To prevent problems, we will not allow a global suspend if
+	 * any ports are OC.
+	 *
+	 * Some motherboards using Intel's chipsets (but not using all
+	 * the USB ports) appear to hardwire the over current inputs active
+	 * to disable the USB ports.
 	 */
-	status = inw(io_addr + USBSTS);
-	if (!(status &amp; ~USBSTS_HCH))	/* shared interrupt, not mine */
-		return IRQ_NONE;
-	outw(status, io_addr + USBSTS);		/* Clear it */
 
-	if (status &amp; ~(USBSTS_USBINT | USBSTS_ERROR | USBSTS_RD)) {
-		if (status &amp; USBSTS_HSE)
-			dev_err(uhci_dev(uhci), "host system error, "
-					"PCI problems?\n");
-		if (status &amp; USBSTS_HCPE)
-			dev_err(uhci_dev(uhci), "host controller process "
-					"error, something bad happened!\n");
-		if ((status &amp; USBSTS_HCH) &amp;&amp; uhci-&gt;state &gt; 0) {
-			dev_err(uhci_dev(uhci), "host controller halted, "
-					"very bad!\n");
-			/* FIXME: Reset the controller, fix the offending TD */
-		}
+	/* check for over current condition on any port */
+	for (i = 0; i &lt; uhci-&gt;rh_numports; i++) {
+		if (inw(io_addr + USBPORTSC1 + i * 2) &amp; USBPORTSC_OC)
+			return 0;
 	}
 
-	if (status &amp; USBSTS_RD)
-		uhci-&gt;resume_detect = 1;
-
-	spin_lock(&amp;uhci-&gt;lock);
-	uhci_scan_schedule(uhci, regs);
-	spin_unlock(&amp;uhci-&gt;lock);
-
-	return IRQ_HANDLED;
+	return 1;
 }
 
 static void reset_hc(struct uhci_hcd *uhci)
@@ -276,43 +222,46 @@ static void wakeup_hc(struct uhci_hcd *uhci)
 	}
 }
 
-static int ports_active(struct uhci_hcd *uhci)
+static int start_hc(struct uhci_hcd *uhci)
 {
 	unsigned long io_addr = uhci-&gt;io_addr;
-	int connection = 0;
-	int i;
-
-	for (i = 0; i &lt; uhci-&gt;rh_numports; i++)
-		connection |= (inw(io_addr + USBPORTSC1 + i * 2) &amp; USBPORTSC_CCS);
+	int timeout = 10;
 
-	return connection;
-}
+	/*
+	 * Reset the HC - this will force us to get a
+	 * new notification of any already connected
+	 * ports due to the virtual disconnect that it
+	 * implies.
+	 */
+	outw(USBCMD_HCRESET, io_addr + USBCMD);
+	while (inw(io_addr + USBCMD) &amp; USBCMD_HCRESET) {
+		if (--timeout &lt; 0) {
+			dev_err(uhci_dev(uhci), "USBCMD_HCRESET timed out!\n");
+			return -ETIMEDOUT;
+		}
+		msleep(1);
+	}
 
-static int suspend_allowed(struct uhci_hcd *uhci)
-{
-	unsigned long io_addr = uhci-&gt;io_addr;
-	int i;
+	/* Mark controller as running before we enable interrupts */
+	uhci_to_hcd(uhci)-&gt;state = HC_STATE_RUNNING;
 
-	if (to_pci_dev(uhci_dev(uhci))-&gt;vendor != PCI_VENDOR_ID_INTEL)
-		return 1;
+	/* Turn on PIRQ and all interrupts */
+	pci_write_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP,
+			USBLEGSUP_DEFAULT);
+	outw(USBINTR_TIMEOUT | USBINTR_RESUME | USBINTR_IOC | USBINTR_SP,
+		io_addr + USBINTR);
 
-	/* Some of Intel's USB controllers have a bug that causes false
-	 * resume indications if any port has an over current condition.
-	 * To prevent problems, we will not allow a global suspend if
-	 * any ports are OC.
-	 *
-	 * Some motherboards using Intel's chipsets (but not using all
-	 * the USB ports) appear to hardwire the over current inputs active
-	 * to disable the USB ports.
-	 */
+	/* Start at frame 0 */
+	outw(0, io_addr + USBFRNUM);
+	outl(uhci-&gt;fl-&gt;dma_handle, io_addr + USBFLBASEADD);
 
-	/* check for over current condition on any port */
-	for (i = 0; i &lt; uhci-&gt;rh_numports; i++) {
-		if (inw(io_addr + USBPORTSC1 + i * 2) &amp; USBPORTSC_OC)
-			return 0;
-	}
+	/* Run and mark it configured with a 64-byte max packet */
+	uhci-&gt;state = UHCI_RUNNING_GRACE;
+	uhci-&gt;state_end = jiffies + HZ;
+	outw(USBCMD_RS | USBCMD_CF | USBCMD_MAXP, io_addr + USBCMD);
+	uhci-&gt;is_stopped = 0;
 
-	return 1;
+	return 0;
 }
 
 static void hc_state_transitions(struct uhci_hcd *uhci)
@@ -353,56 +302,106 @@ static void hc_state_transitions(struct uhci_hcd *uhci)
 	}
 }
 
-/*
- * Store the current frame number in uhci-&gt;frame_number if the controller
- * is runnning
- */
-static void uhci_get_current_frame_number(struct uhci_hcd *uhci)
+static int init_stall_timer(struct usb_hcd *hcd);
+
+static void stall_callback(unsigned long ptr)
 {
-	if (!uhci-&gt;is_stopped)
-		uhci-&gt;frame_number = inw(uhci-&gt;io_addr + USBFRNUM);
+	struct usb_hcd *hcd = (struct usb_hcd *)ptr;
+	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
+	struct urb_priv *up;
+	unsigned long flags;
+
+	spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
+	uhci_scan_schedule(uhci, NULL);
+
+	list_for_each_entry(up, &amp;uhci-&gt;urb_list, urb_list) {
+		struct urb *u = up-&gt;urb;
+
+		spin_lock(&amp;u-&gt;lock);
+
+		/* Check if the FSBR timed out */
+		if (up-&gt;fsbr &amp;&amp; !up-&gt;fsbr_timeout &amp;&amp; time_after_eq(jiffies, up-&gt;fsbrtime + IDLE_TIMEOUT))
+			uhci_fsbr_timeout(uhci, u);
+
+		spin_unlock(&amp;u-&gt;lock);
+	}
+
+	/* Really disable FSBR */
+	if (!uhci-&gt;fsbr &amp;&amp; uhci-&gt;fsbrtimeout &amp;&amp; time_after_eq(jiffies, uhci-&gt;fsbrtimeout)) {
+		uhci-&gt;fsbrtimeout = 0;
+		uhci-&gt;skel_term_qh-&gt;link = UHCI_PTR_TERM;
+	}
+
+	/* Poll for and perform state transitions */
+	hc_state_transitions(uhci);
+	if (unlikely(uhci-&gt;suspended_ports &amp;&amp; uhci-&gt;state != UHCI_SUSPENDED))
+		uhci_check_ports(uhci);
+
+	init_stall_timer(hcd);
+	spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
 }
 
-static int start_hc(struct uhci_hcd *uhci)
+static int init_stall_timer(struct usb_hcd *hcd)
 {
+	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
+
+	init_timer(&amp;uhci-&gt;stall_timer);
+	uhci-&gt;stall_timer.function = stall_callback;
+	uhci-&gt;stall_timer.data = (unsigned long)hcd;
+	uhci-&gt;stall_timer.expires = jiffies + msecs_to_jiffies(100);
+	add_timer(&amp;uhci-&gt;stall_timer);
+
+	return 0;
+}
+
+static irqreturn_t uhci_irq(struct usb_hcd *hcd, struct pt_regs *regs)
+{
+	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 	unsigned long io_addr = uhci-&gt;io_addr;
-	int timeout = 10;
+	unsigned short status;
 
 	/*
-	 * Reset the HC - this will force us to get a
-	 * new notification of any already connected
-	 * ports due to the virtual disconnect that it
-	 * implies.
+	 * Read the interrupt status, and write it back to clear the
+	 * interrupt cause.  Contrary to the UHCI specification, the
+	 * "HC Halted" status bit is persistent: it is RO, not R/WC.
 	 */
-	outw(USBCMD_HCRESET, io_addr + USBCMD);
-	while (inw(io_addr + USBCMD) &amp; USBCMD_HCRESET) {
-		if (--timeout &lt; 0) {
-			dev_err(uhci_dev(uhci), "USBCMD_HCRESET timed out!\n");
-			return -ETIMEDOUT;
+	status = inw(io_addr + USBSTS);
+	if (!(status &amp; ~USBSTS_HCH))	/* shared interrupt, not mine */
+		return IRQ_NONE;
+	outw(status, io_addr + USBSTS);		/* Clear it */
+
+	if (status &amp; ~(USBSTS_USBINT | USBSTS_ERROR | USBSTS_RD)) {
+		if (status &amp; USBSTS_HSE)
+			dev_err(uhci_dev(uhci), "host system error, "
+					"PCI problems?\n");
+		if (status &amp; USBSTS_HCPE)
+			dev_err(uhci_dev(uhci), "host controller process "
+					"error, something bad happened!\n");
+		if ((status &amp; USBSTS_HCH) &amp;&amp; uhci-&gt;state &gt; 0) {
+			dev_err(uhci_dev(uhci), "host controller halted, "
+					"very bad!\n");
+			/* FIXME: Reset the controller, fix the offending TD */
 		}
-		msleep(1);
 	}
 
-	/* Mark controller as running before we enable interrupts */
-	uhci_to_hcd(uhci)-&gt;state = HC_STATE_RUNNING;
-
-	/* Turn on PIRQ and all interrupts */
-	pci_write_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP,
-			USBLEGSUP_DEFAULT);
-	outw(USBINTR_TIMEOUT | USBINTR_RESUME | USBINTR_IOC | USBINTR_SP,
-		io_addr + USBINTR);
+	if (status &amp; USBSTS_RD)
+		uhci-&gt;resume_detect = 1;
 
-	/* Start at frame 0 */
-	outw(0, io_addr + USBFRNUM);
-	outl(uhci-&gt;fl-&gt;dma_handle, io_addr + USBFLBASEADD);
+	spin_lock(&amp;uhci-&gt;lock);
+	uhci_scan_schedule(uhci, regs);
+	spin_unlock(&amp;uhci-&gt;lock);
 
-	/* Run and mark it configured with a 64-byte max packet */
-	uhci-&gt;state = UHCI_RUNNING_GRACE;
-	uhci-&gt;state_end = jiffies + HZ;
-	outw(USBCMD_RS | USBCMD_CF | USBCMD_MAXP, io_addr + USBCMD);
-	uhci-&gt;is_stopped = 0;
+	return IRQ_HANDLED;
+}
 
-	return 0;
+/*
+ * Store the current frame number in uhci-&gt;frame_number if the controller
+ * is runnning
+ */
+static void uhci_get_current_frame_number(struct uhci_hcd *uhci)
+{
+	if (!uhci-&gt;is_stopped)
+		uhci-&gt;frame_number = inw(uhci-&gt;io_addr + USBFRNUM);
 }
 
 /*</pre><hr><pre>commit d794ac7ae3613c2abfb678617ac7d74c8ff0099c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Apr 18 12:43:25 2005 -0400

    [PATCH] USB: g_file_storage: export "stall" parameter
    
    This patch changes the g_file_storage driver to make the "stall" module
    parameter generally available; currently it is available only if the
    testing version of the module has been configured.  It also fixes a typo
    in a comment -- thanks, Pat!
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/file_storage.c b/drivers/usb/gadget/file_storage.c
index 507a24924177..f5ce45c4b2a3 100644
--- a/drivers/usb/gadget/file_storage.c
+++ b/drivers/usb/gadget/file_storage.c
@@ -81,6 +81,10 @@
  *	removable		Default false, boolean for removable media
  *	luns=N			Default N = number of filenames, number of
  *					LUNs to support
+ *	stall			Default determined according to the type of
+ *					USB device controller (usually true),
+ *					boolean to permit the driver to halt
+ *					bulk endpoints
  *	transport=XXX		Default BBB, transport name (CB, CBI, or BBB)
  *	protocol=YYY		Default SCSI, protocol name (RBC, 8020 or
  *					ATAPI, QIC, UFI, 8070, or SCSI;
@@ -91,14 +95,10 @@
  *	buflen=N		Default N=16384, buffer size used (will be
  *					rounded down to a multiple of
  *					PAGE_CACHE_SIZE)
- *	stall			Default determined according to the type of
- *					USB device controller (usually true),
- *					boolean to permit the driver to halt
- *					bulk endpoints
  *
  * If CONFIG_USB_FILE_STORAGE_TEST is not set, only the "file", "ro",
- * "removable", and "luns" options are available; default values are used
- * for everything else.
+ * "removable", "luns", and "stall" options are available; default values
+ * are used for everything else.
  *
  * The pathnames of the backing files and the ro settings are available in
  * the attribute files "file" and "ro" in the lun&lt;n&gt; subdirectory of the
@@ -342,14 +342,15 @@ static struct {
 	int		num_ros;
 	unsigned int	nluns;
 
+	int		removable;
+	int		can_stall;
+
 	char		*transport_parm;
 	char		*protocol_parm;
-	int		removable;
 	unsigned short	vendor;
 	unsigned short	product;
 	unsigned short	release;
 	unsigned int	buflen;
-	int		can_stall;
 
 	int		transport_type;
 	char		*transport_name;
@@ -360,11 +361,11 @@ static struct {
 	.transport_parm		= "BBB",
 	.protocol_parm		= "SCSI",
 	.removable		= 0,
+	.can_stall		= 1,
 	.vendor			= DRIVER_VENDOR_ID,
 	.product		= DRIVER_PRODUCT_ID,
 	.release		= 0xffff,	// Use controller chip type
 	.buflen			= 16384,
-	.can_stall		= 1,
 	};
 
 
@@ -380,6 +381,9 @@ MODULE_PARM_DESC(luns, "number of LUNs");
 module_param_named(removable, mod_data.removable, bool, S_IRUGO);
 MODULE_PARM_DESC(removable, "true to simulate removable media");
 
+module_param_named(stall, mod_data.can_stall, bool, S_IRUGO);
+MODULE_PARM_DESC(stall, "false to prevent bulk stalls");
+
 
 /* In the non-TEST version, only the module parameters listed above
  * are available. */
@@ -404,9 +408,6 @@ MODULE_PARM_DESC(release, "USB release number");
 module_param_named(buflen, mod_data.buflen, uint, S_IRUGO);
 MODULE_PARM_DESC(buflen, "I/O buffer size");
 
-module_param_named(stall, mod_data.can_stall, bool, S_IRUGO);
-MODULE_PARM_DESC(stall, "false to prevent bulk stalls");
-
 #endif /* CONFIG_USB_FILE_STORAGE_TEST */
 
 
@@ -2657,7 +2658,7 @@ static int check_command(struct fsg_dev *fsg, int cmnd_size,
 		}
 	}
 
-	/* Check that the LUN values are oonsistent */
+	/* Check that the LUN values are consistent */
 	if (transport_is_bbb()) {
 		if (fsg-&gt;lun != lun)
 			DBG(fsg, "using LUN %d from CBW, "</pre><hr><pre>commit 76f4af8efc72b6091d230cbe718cedca06d2d79e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Apr 5 11:56:54 2005 -0400

    [PATCH] USB: g_file_storage: Consolidate min()s
    
    This patch simplifies the g_file_storage driver by consolidating a bunch
    of min() calculations at a single spot.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/file_storage.c b/drivers/usb/gadget/file_storage.c
index a9be85103d23..507a24924177 100644
--- a/drivers/usb/gadget/file_storage.c
+++ b/drivers/usb/gadget/file_storage.c
@@ -1312,7 +1312,7 @@ static int class_setup_req(struct fsg_dev *fsg,
 			}
 			VDBG(fsg, "get max LUN\n");
 			*(u8 *) req-&gt;buf = fsg-&gt;nluns - 1;
-			value = min(w_length, (u16) 1);
+			value = 1;
 			break;
 		}
 	}
@@ -1360,7 +1360,6 @@ static int standard_setup_req(struct fsg_dev *fsg,
 	int			value = -EOPNOTSUPP;
 	u16			w_index = ctrl-&gt;wIndex;
 	u16			w_value = ctrl-&gt;wValue;
-	u16			w_length = ctrl-&gt;wLength;
 
 	/* Usually this just stores reply data in the pre-allocated ep0 buffer,
 	 * but config change events will also reconfigure hardware. */
@@ -1374,7 +1373,7 @@ static int standard_setup_req(struct fsg_dev *fsg,
 
 		case USB_DT_DEVICE:
 			VDBG(fsg, "get device descriptor\n");
-			value = min(w_length, (u16) sizeof device_desc);
+			value = sizeof device_desc;
 			memcpy(req-&gt;buf, &amp;device_desc, value);
 			break;
 #ifdef CONFIG_USB_GADGET_DUALSPEED
@@ -1382,7 +1381,7 @@ static int standard_setup_req(struct fsg_dev *fsg,
 			VDBG(fsg, "get device qualifier\n");
 			if (!fsg-&gt;gadget-&gt;is_dualspeed)
 				break;
-			value = min(w_length, (u16) sizeof dev_qualifier);
+			value = sizeof dev_qualifier;
 			memcpy(req-&gt;buf, &amp;dev_qualifier, value);
 			break;
 
@@ -1401,8 +1400,6 @@ static int standard_setup_req(struct fsg_dev *fsg,
 					req-&gt;buf,
 					w_value &gt;&gt; 8,
 					w_value &amp; 0xff);
-			if (value &gt;= 0)
-				value = min(w_length, (u16) value);
 			break;
 
 		case USB_DT_STRING:
@@ -1411,8 +1408,6 @@ static int standard_setup_req(struct fsg_dev *fsg,
 			/* wIndex == language code */
 			value = usb_gadget_get_string(&amp;stringtab,
 					w_value &amp; 0xff, req-&gt;buf);
-			if (value &gt;= 0)
-				value = min(w_length, (u16) value);
 			break;
 		}
 		break;
@@ -1438,7 +1433,7 @@ static int standard_setup_req(struct fsg_dev *fsg,
 			break;
 		VDBG(fsg, "get configuration\n");
 		*(u8 *) req-&gt;buf = fsg-&gt;config;
-		value = min(w_length, (u16) 1);
+		value = 1;
 		break;
 
 	case USB_REQ_SET_INTERFACE:
@@ -1466,14 +1461,14 @@ static int standard_setup_req(struct fsg_dev *fsg,
 		}
 		VDBG(fsg, "get interface\n");
 		*(u8 *) req-&gt;buf = 0;
-		value = min(w_length, (u16) 1);
+		value = 1;
 		break;
 
 	default:
 		VDBG(fsg,
 			"unknown control req %02x.%02x v%04x i%04x l%u\n",
 			ctrl-&gt;bRequestType, ctrl-&gt;bRequest,
-			w_value, w_index, w_length);
+			w_value, w_index, ctrl-&gt;wLength);
 	}
 
 	return value;
@@ -1485,6 +1480,7 @@ static int fsg_setup(struct usb_gadget *gadget,
 {
 	struct fsg_dev		*fsg = get_gadget_data(gadget);
 	int			rc;
+	int			w_length = ctrl-&gt;wLength;
 
 	++fsg-&gt;ep0_req_tag;		// Record arrival of a new request
 	fsg-&gt;ep0req-&gt;context = NULL;
@@ -1498,8 +1494,9 @@ static int fsg_setup(struct usb_gadget *gadget,
 
 	/* Respond with data/status or defer until later? */
 	if (rc &gt;= 0 &amp;&amp; rc != DELAYED_STATUS) {
+		rc = min(rc, w_length);
 		fsg-&gt;ep0req-&gt;length = rc;
-		fsg-&gt;ep0req-&gt;zero = (rc &lt; ctrl-&gt;wLength &amp;&amp;
+		fsg-&gt;ep0req-&gt;zero = (rc &lt; w_length &amp;&amp;
 				(rc % gadget-&gt;ep0-&gt;maxpacket) == 0);
 		fsg-&gt;ep0req_name = (ctrl-&gt;bRequestType &amp; USB_DIR_IN ?
 				"ep0-in" : "ep0-out");</pre><hr><pre>commit f409661877a25d11c2495bcd879807f17c286684
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 6 15:41:08 2005 -0400

    [PATCH] usbcore: Don't call device_release_driver recursively
    
    This patch fixes usb_driver_release_interface() to make it avoid calling
    device_release_driver() recursively, i.e., when invoked from within the
    disconnect routine for the same device.  The patch applies to your
    "driver" tree.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index 66678763c24d..a3c42203213a 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -322,9 +322,15 @@ void usb_driver_release_interface(struct usb_driver *driver,
 	if (!dev-&gt;driver || dev-&gt;driver != &amp;driver-&gt;driver)
 		return;
 
-	/* don't disconnect from disconnect(), or before dev_add() */
-	if (!klist_node_attached(&amp;dev-&gt;knode_driver) &amp;&amp; !klist_node_attached(&amp;dev-&gt;knode_bus))
+	/* don't release from within disconnect() */
+	if (iface-&gt;condition != USB_INTERFACE_BOUND)
+		return;
+
+	/* release only after device_add() */
+	if (klist_node_attached(&amp;dev-&gt;knode_bus)) {
+		iface-&gt;condition = USB_INTERFACE_UNBINDING;
 		device_release_driver(dev);
+	}
 
 	dev-&gt;driver = NULL;
 	usb_set_intfdata(iface, NULL);</pre>
    <div class="pagination">
        <a href='2_138.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><span>[139]</span><a href='2_140.html'>140</a><a href='2_140.html'>Next&gt;&gt;</a>
    <div>
</body>
