<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_13.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><span>[14]</span><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_15.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 31e0456de5be379b10fea0fa94a681057114a96e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 7 12:39:47 2019 -0400

    media: usb: siano: Fix general protection fault in smsusb
    
    The syzkaller USB fuzzer found a general-protection-fault bug in the
    smsusb part of the Siano DVB driver.  The fault occurs during probe
    because the driver assumes without checking that the device has both
    IN and OUT endpoints and the IN endpoint is ep1.
    
    By slightly rearranging the driver's initialization code, we can make
    the appropriate checks early on and thus avoid the problem.  If the
    expected endpoints aren't present, the new code safely returns -ENODEV
    from the probe routine.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: syzbot+53f029db71c19a47325a@syzkaller.appspotmail.com
    CC: &lt;stable@vger.kernel.org&gt;
    Reviewed-by: Johan Hovold &lt;johan@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/media/usb/siano/smsusb.c b/drivers/media/usb/siano/smsusb.c
index 4fc03ec8a4f1..27ad14a3f831 100644
--- a/drivers/media/usb/siano/smsusb.c
+++ b/drivers/media/usb/siano/smsusb.c
@@ -400,6 +400,7 @@ static int smsusb_init_device(struct usb_interface *intf, int board_id)
 	struct smsusb_device_t *dev;
 	void *mdev;
 	int i, rc;
+	int in_maxp;
 
 	/* create device object */
 	dev = kzalloc(sizeof(struct smsusb_device_t), GFP_KERNEL);
@@ -411,6 +412,24 @@ static int smsusb_init_device(struct usb_interface *intf, int board_id)
 	dev-&gt;udev = interface_to_usbdev(intf);
 	dev-&gt;state = SMSUSB_DISCONNECTED;
 
+	for (i = 0; i &lt; intf-&gt;cur_altsetting-&gt;desc.bNumEndpoints; i++) {
+		struct usb_endpoint_descriptor *desc =
+				&amp;intf-&gt;cur_altsetting-&gt;endpoint[i].desc;
+
+		if (desc-&gt;bEndpointAddress &amp; USB_DIR_IN) {
+			dev-&gt;in_ep = desc-&gt;bEndpointAddress;
+			in_maxp = usb_endpoint_maxp(desc);
+		} else {
+			dev-&gt;out_ep = desc-&gt;bEndpointAddress;
+		}
+	}
+
+	pr_debug("in_ep = %02x, out_ep = %02x\n", dev-&gt;in_ep, dev-&gt;out_ep);
+	if (!dev-&gt;in_ep || !dev-&gt;out_ep) {	/* Missing endpoints? */
+		smsusb_term_device(intf);
+		return -ENODEV;
+	}
+
 	params.device_type = sms_get_board(board_id)-&gt;type;
 
 	switch (params.device_type) {
@@ -425,24 +444,12 @@ static int smsusb_init_device(struct usb_interface *intf, int board_id)
 		/* fall-thru */
 	default:
 		dev-&gt;buffer_size = USB2_BUFFER_SIZE;
-		dev-&gt;response_alignment =
-		    le16_to_cpu(dev-&gt;udev-&gt;ep_in[1]-&gt;desc.wMaxPacketSize) -
-		    sizeof(struct sms_msg_hdr);
+		dev-&gt;response_alignment = in_maxp - sizeof(struct sms_msg_hdr);
 
 		params.flags |= SMS_DEVICE_FAMILY2;
 		break;
 	}
 
-	for (i = 0; i &lt; intf-&gt;cur_altsetting-&gt;desc.bNumEndpoints; i++) {
-		if (intf-&gt;cur_altsetting-&gt;endpoint[i].desc. bEndpointAddress &amp; USB_DIR_IN)
-			dev-&gt;in_ep = intf-&gt;cur_altsetting-&gt;endpoint[i].desc.bEndpointAddress;
-		else
-			dev-&gt;out_ep = intf-&gt;cur_altsetting-&gt;endpoint[i].desc.bEndpointAddress;
-	}
-
-	pr_debug("in_ep = %02x, out_ep = %02x\n",
-		dev-&gt;in_ep, dev-&gt;out_ep);
-
 	params.device = &amp;dev-&gt;udev-&gt;dev;
 	params.usb_device = dev-&gt;udev;
 	params.buffer_size = dev-&gt;buffer_size;</pre><hr><pre>commit a03ff54460817c76105f81f3aa8ef655759ccc9a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon May 13 13:14:29 2019 -0400

    USB: Fix slab-out-of-bounds write in usb_get_bos_descriptor
    
    The syzkaller USB fuzzer found a slab-out-of-bounds write bug in the
    USB core, caused by a failure to check the actual size of a BOS
    descriptor.  This patch adds a check to make sure the descriptor is at
    least as large as it is supposed to be, so that the code doesn't
    inadvertently access memory beyond the end of the allocated region
    when assigning to dev-&gt;bos-&gt;desc-&gt;bNumDeviceCaps later on.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: syzbot+71f1e64501a309fcc012@syzkaller.appspotmail.com
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c
index 20ff036b4c22..9d6cb709ca7b 100644
--- a/drivers/usb/core/config.c
+++ b/drivers/usb/core/config.c
@@ -932,8 +932,8 @@ int usb_get_bos_descriptor(struct usb_device *dev)
 
 	/* Get BOS descriptor */
 	ret = usb_get_descriptor(dev, USB_DT_BOS, 0, bos, USB_DT_BOS_SIZE);
-	if (ret &lt; USB_DT_BOS_SIZE) {
-		dev_err(ddev, "unable to get BOS descriptor\n");
+	if (ret &lt; USB_DT_BOS_SIZE || bos-&gt;bLength &lt; USB_DT_BOS_SIZE) {
+		dev_err(ddev, "unable to get BOS descriptor or descriptor too short\n");
 		if (ret &gt;= 0)
 			ret = -ENOMSG;
 		kfree(bos);</pre><hr><pre>commit de497f634609aa1710fef4b6d833a037120369cc
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Apr 15 13:35:46 2019 -0400

    USB: UDC: net22{80,72}: remove mistaken test of req-&gt;zero
    
    The net2280 UDC driver (and also net2272, probably via copy-and-paste)
    incorrectly checks the req-&gt;zero flag during OUT transfers, after
    copying data from the UDC's FIFO into memory.  This makes no sense at
    all; the "zero" flag indicates that an extra zero-length packet should
    be appended to an IN transfer if the length is an even multiple of the
    maxpacket size.  It has nothing to do with OUT transfers.
    
    In practice this doesn't cause any problems because gadget drivers
    never set req-&gt;zero for OUT transfers anyway.  Still, it is an error
    and unnecessary code, so this patch removes the check.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Felipe Balbi &lt;felipe.balbi@linux.intel.com&gt;

diff --git a/drivers/usb/gadget/udc/net2272.c b/drivers/usb/gadget/udc/net2272.c
index c2011cd7df8c..564aeee1a1fe 100644
--- a/drivers/usb/gadget/udc/net2272.c
+++ b/drivers/usb/gadget/udc/net2272.c
@@ -573,8 +573,7 @@ net2272_read_fifo(struct net2272_ep *ep, struct net2272_request *req)
 
 		/* completion */
 		if (unlikely(cleanup || is_short ||
-				((req-&gt;req.actual == req-&gt;req.length)
-				 &amp;&amp; !req-&gt;req.zero))) {
+				req-&gt;req.actual == req-&gt;req.length)) {
 
 			if (cleanup) {
 				net2272_out_flush(ep);
diff --git a/drivers/usb/gadget/udc/net2280.c b/drivers/usb/gadget/udc/net2280.c
index b17473a00b43..b6bbe2e448ba 100644
--- a/drivers/usb/gadget/udc/net2280.c
+++ b/drivers/usb/gadget/udc/net2280.c
@@ -789,8 +789,7 @@ static int read_fifo(struct net2280_ep *ep, struct net2280_request *req)
 		(void) readl(&amp;ep-&gt;regs-&gt;ep_rsp);
 	}
 
-	return is_short || ((req-&gt;req.actual == req-&gt;req.length) &amp;&amp;
-			!req-&gt;req.zero);
+	return is_short || req-&gt;req.actual == req-&gt;req.length;
 }
 
 /* fill out dma descriptor to match a given request */</pre><hr><pre>commit 6574abe69946589bf0f69cf9b32f6a2c71ae764f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Apr 15 13:36:58 2019 -0400

    USB: UDC: net2280: Remove redundant "if" condition
    
    The net2280 driver includes an unnecessary test for an endpoint's
    queue being empty.  The test is redundant; it sits inside a
    conditional block of an "if" statement which already tests the
    endpoint's queue.
    
    This patch removes the redundant test.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Felipe Balbi &lt;felipe.balbi@linux.intel.com&gt;

diff --git a/drivers/usb/gadget/udc/net2280.c b/drivers/usb/gadget/udc/net2280.c
index 898339e5df10..b17473a00b43 100644
--- a/drivers/usb/gadget/udc/net2280.c
+++ b/drivers/usb/gadget/udc/net2280.c
@@ -1058,7 +1058,7 @@ net2280_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)
 			/* PIO ... stuff the fifo, or unblock it.  */
 			if (ep-&gt;is_in)
 				write_fifo(ep, _req);
-			else if (list_empty(&amp;ep-&gt;queue)) {
+			else {
 				u32	s;
 
 				/* OUT FIFO might have packet(s) buffered */</pre><hr><pre>commit 50896c410354432e8e7baf97fcdd7df265e683ae
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Apr 18 13:12:07 2019 -0400

    USB: dummy-hcd: Fix failure to give back unlinked URBs
    
    The syzkaller USB fuzzer identified a failure mode in which dummy-hcd
    would never give back an unlinked URB.  This causes usb_kill_urb() to
    hang, leading to WARNINGs and unkillable threads.
    
    In dummy-hcd, all URBs are given back by the dummy_timer() routine as
    it scans through the list of pending URBS.  Failure to give back URBs
    can be caused by failure to start or early exit from the scanning
    loop.  The code currently has two such pathways: One is triggered when
    an unsupported bus transfer speed is encountered, and the other by
    exhausting the simulated bandwidth for USB transfers during a frame.
    
    This patch removes those two paths, thereby allowing all unlinked URBs
    to be given back in a timely manner.  It adds a check for the bus
    speed when the gadget first starts running, so that dummy_timer() will
    never thereafter encounter an unsupported speed.  And it prevents the
    loop from exiting as soon as the total bandwidth has been used up (the
    scanning loop continues, giving back unlinked URBs as they are found,
    but not transferring any more data).
    
    Thanks to Andrey Konovalov for manually running the syzkaller fuzzer
    to help track down the source of the bug.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: syzbot+d919b0f29d7b5a4994b9@syzkaller.appspotmail.com
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Felipe Balbi &lt;felipe.balbi@linux.intel.com&gt;

diff --git a/drivers/usb/gadget/udc/dummy_hcd.c b/drivers/usb/gadget/udc/dummy_hcd.c
index baf72f95f0f1..213b52508621 100644
--- a/drivers/usb/gadget/udc/dummy_hcd.c
+++ b/drivers/usb/gadget/udc/dummy_hcd.c
@@ -979,8 +979,18 @@ static int dummy_udc_start(struct usb_gadget *g,
 	struct dummy_hcd	*dum_hcd = gadget_to_dummy_hcd(g);
 	struct dummy		*dum = dum_hcd-&gt;dum;
 
-	if (driver-&gt;max_speed == USB_SPEED_UNKNOWN)
+	switch (g-&gt;speed) {
+	/* All the speeds we support */
+	case USB_SPEED_LOW:
+	case USB_SPEED_FULL:
+	case USB_SPEED_HIGH:
+	case USB_SPEED_SUPER:
+		break;
+	default:
+		dev_err(dummy_dev(dum_hcd), "Unsupported driver max speed %d\n",
+				driver-&gt;max_speed);
 		return -EINVAL;
+	}
 
 	/*
 	 * SLAVE side init ... the layer above hardware, which
@@ -1784,9 +1794,10 @@ static void dummy_timer(struct timer_list *t)
 		/* Bus speed is 500000 bytes/ms, so use a little less */
 		total = 490000;
 		break;
-	default:
+	default:	/* Can't happen */
 		dev_err(dummy_dev(dum_hcd), "bogus device speed\n");
-		return;
+		total = 0;
+		break;
 	}
 
 	/* FIXME if HZ != 1000 this will probably misbehave ... */
@@ -1828,7 +1839,7 @@ static void dummy_timer(struct timer_list *t)
 
 		/* Used up this frame's bandwidth? */
 		if (total &lt;= 0)
-			break;
+			continue;
 
 		/* find the gadget's ep for this request (if configured) */
 		address = usb_pipeendpoint (urb-&gt;pipe);</pre><hr><pre>commit c114944d7d67f24e71562fcfc18d550ab787e4d4
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Apr 22 11:16:04 2019 -0400

    USB: w1 ds2490: Fix bug caused by improper use of altsetting array
    
    The syzkaller USB fuzzer spotted a slab-out-of-bounds bug in the
    ds2490 driver.  This bug is caused by improper use of the altsetting
    array in the usb_interface structure (the array's entries are not
    always stored in numerical order), combined with a naive assumption
    that all interfaces probed by the driver will have the expected number
    of altsettings.
    
    The bug can be fixed by replacing references to the possibly
    non-existent intf-&gt;altsetting[alt] entry with the guaranteed-to-exist
    intf-&gt;cur_altsetting entry.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: syzbot+d65f673b847a1a96cdba@syzkaller.appspotmail.com
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/w1/masters/ds2490.c b/drivers/w1/masters/ds2490.c
index 0f4ecfcdb549..a9fb77585272 100644
--- a/drivers/w1/masters/ds2490.c
+++ b/drivers/w1/masters/ds2490.c
@@ -1016,15 +1016,15 @@ static int ds_probe(struct usb_interface *intf,
 	/* alternative 3, 1ms interrupt (greatly speeds search), 64 byte bulk */
 	alt = 3;
 	err = usb_set_interface(dev-&gt;udev,
-		intf-&gt;altsetting[alt].desc.bInterfaceNumber, alt);
+		intf-&gt;cur_altsetting-&gt;desc.bInterfaceNumber, alt);
 	if (err) {
 		dev_err(&amp;dev-&gt;udev-&gt;dev, "Failed to set alternative setting %d "
 			"for %d interface: err=%d.\n", alt,
-			intf-&gt;altsetting[alt].desc.bInterfaceNumber, err);
+			intf-&gt;cur_altsetting-&gt;desc.bInterfaceNumber, err);
 		goto err_out_clear;
 	}
 
-	iface_desc = &amp;intf-&gt;altsetting[alt];
+	iface_desc = intf-&gt;cur_altsetting;
 	if (iface_desc-&gt;desc.bNumEndpoints != NUM_EP-1) {
 		pr_info("Num endpoints=%d. It is not DS9490R.\n",
 			iface_desc-&gt;desc.bNumEndpoints);</pre><hr><pre>commit ef61eb43ada6c1d6b94668f0f514e4c268093ff3
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Apr 23 14:48:29 2019 -0400

    USB: yurex: Fix protection fault after device removal
    
    The syzkaller USB fuzzer found a general-protection-fault bug in the
    yurex driver.  The fault occurs when a device has been unplugged; the
    driver's interrupt-URB handler logs an error message referring to the
    device by name, after the device has been unregistered and its name
    deallocated.
    
    This problem is caused by the fact that the interrupt URB isn't
    cancelled until the driver's private data structure is released, which
    can happen long after the device is gone.  The cure is to make sure
    that the interrupt URB is killed before yurex_disconnect() returns;
    this is exactly the sort of thing that usb_poison_urb() was meant for.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: syzbot+2eb9121678bdb36e6d57@syzkaller.appspotmail.com
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/misc/yurex.c b/drivers/usb/misc/yurex.c
index 6d9fd5f64903..7b306aa22d25 100644
--- a/drivers/usb/misc/yurex.c
+++ b/drivers/usb/misc/yurex.c
@@ -314,6 +314,7 @@ static void yurex_disconnect(struct usb_interface *interface)
 	usb_deregister_dev(interface, &amp;yurex_class);
 
 	/* prevent more I/O from starting */
+	usb_poison_urb(dev-&gt;urb);
 	mutex_lock(&amp;dev-&gt;io_mutex);
 	dev-&gt;interface = NULL;
 	mutex_unlock(&amp;dev-&gt;io_mutex);</pre><hr><pre>commit c2b71462d294cf517a0bc6e4fd6424d7cee5596f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Apr 19 13:52:38 2019 -0400

    USB: core: Fix bug caused by duplicate interface PM usage counter
    
    The syzkaller fuzzer reported a bug in the USB hub driver which turned
    out to be caused by a negative runtime-PM usage counter.  This allowed
    a hub to be runtime suspended at a time when the driver did not expect
    it.  The symptom is a WARNING issued because the hub's status URB is
    submitted while it is already active:
    
            URB 0000000031fb463e submitted while active
            WARNING: CPU: 0 PID: 2917 at drivers/usb/core/urb.c:363
    
    The negative runtime-PM usage count was caused by an unfortunate
    design decision made when runtime PM was first implemented for USB.
    At that time, USB class drivers were allowed to unbind from their
    interfaces without balancing the usage counter (i.e., leaving it with
    a positive count).  The core code would take care of setting the
    counter back to 0 before allowing another driver to bind to the
    interface.
    
    Later on when runtime PM was implemented for the entire kernel, the
    opposite decision was made: Drivers were required to balance their
    runtime-PM get and put calls.  In order to maintain backward
    compatibility, however, the USB subsystem adapted to the new
    implementation by keeping an independent usage counter for each
    interface and using it to automatically adjust the normal usage
    counter back to 0 whenever a driver was unbound.
    
    This approach involves duplicating information, but what is worse, it
    doesn't work properly in cases where a USB class driver delays
    decrementing the usage counter until after the driver's disconnect()
    routine has returned and the counter has been adjusted back to 0.
    Doing so would cause the usage counter to become negative.  There's
    even a warning about this in the USB power management documentation!
    
    As it happens, this is exactly what the hub driver does.  The
    kick_hub_wq() routine increments the runtime-PM usage counter, and the
    corresponding decrement is carried out by hub_event() in the context
    of the hub_wq work-queue thread.  This work routine may sometimes run
    after the driver has been unbound from its interface, and when it does
    it causes the usage counter to go negative.
    
    It is not possible for hub_disconnect() to wait for a pending
    hub_event() call to finish, because hub_disconnect() is called with
    the device lock held and hub_event() acquires that lock.  The only
    feasible fix is to reverse the original design decision: remove the
    duplicate interface-specific usage counter and require USB drivers to
    balance their runtime PM gets and puts.  As far as I know, all
    existing drivers currently do this.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: syzbot+7634edaea4d0b341c625@syzkaller.appspotmail.com
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/Documentation/driver-api/usb/power-management.rst b/Documentation/driver-api/usb/power-management.rst
index 79beb807996b..4a74cf6f2797 100644
--- a/Documentation/driver-api/usb/power-management.rst
+++ b/Documentation/driver-api/usb/power-management.rst
@@ -370,11 +370,15 @@ autosuspend the interface's device.  When the usage counter is = 0
 then the interface is considered to be idle, and the kernel may
 autosuspend the device.
 
-Drivers need not be concerned about balancing changes to the usage
-counter; the USB core will undo any remaining "get"s when a driver
-is unbound from its interface.  As a corollary, drivers must not call
-any of the ``usb_autopm_*`` functions after their ``disconnect``
-routine has returned.
+Drivers must be careful to balance their overall changes to the usage
+counter.  Unbalanced "get"s will remain in effect when a driver is
+unbound from its interface, preventing the device from going into
+runtime suspend should the interface be bound to a driver again.  On
+the other hand, drivers are allowed to achieve this balance by calling
+the ``usb_autopm_*`` functions even after their ``disconnect`` routine
+has returned -- say from within a work-queue routine -- provided they
+retain an active reference to the interface (via ``usb_get_intf`` and
+``usb_put_intf``).
 
 Drivers using the async routines are responsible for their own
 synchronization and mutual exclusion.
diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 8987cec9549d..ebcadaad89d1 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -473,11 +473,6 @@ static int usb_unbind_interface(struct device *dev)
 		pm_runtime_disable(dev);
 	pm_runtime_set_suspended(dev);
 
-	/* Undo any residual pm_autopm_get_interface_* calls */
-	for (r = atomic_read(&amp;intf-&gt;pm_usage_cnt); r &gt; 0; --r)
-		usb_autopm_put_interface_no_suspend(intf);
-	atomic_set(&amp;intf-&gt;pm_usage_cnt, 0);
-
 	if (!error)
 		usb_autosuspend_device(udev);
 
@@ -1633,7 +1628,6 @@ void usb_autopm_put_interface(struct usb_interface *intf)
 	int			status;
 
 	usb_mark_last_busy(udev);
-	atomic_dec(&amp;intf-&gt;pm_usage_cnt);
 	status = pm_runtime_put_sync(&amp;intf-&gt;dev);
 	dev_vdbg(&amp;intf-&gt;dev, "%s: cnt %d -&gt; %d\n",
 			__func__, atomic_read(&amp;intf-&gt;dev.power.usage_count),
@@ -1662,7 +1656,6 @@ void usb_autopm_put_interface_async(struct usb_interface *intf)
 	int			status;
 
 	usb_mark_last_busy(udev);
-	atomic_dec(&amp;intf-&gt;pm_usage_cnt);
 	status = pm_runtime_put(&amp;intf-&gt;dev);
 	dev_vdbg(&amp;intf-&gt;dev, "%s: cnt %d -&gt; %d\n",
 			__func__, atomic_read(&amp;intf-&gt;dev.power.usage_count),
@@ -1684,7 +1677,6 @@ void usb_autopm_put_interface_no_suspend(struct usb_interface *intf)
 	struct usb_device	*udev = interface_to_usbdev(intf);
 
 	usb_mark_last_busy(udev);
-	atomic_dec(&amp;intf-&gt;pm_usage_cnt);
 	pm_runtime_put_noidle(&amp;intf-&gt;dev);
 }
 EXPORT_SYMBOL_GPL(usb_autopm_put_interface_no_suspend);
@@ -1715,8 +1707,6 @@ int usb_autopm_get_interface(struct usb_interface *intf)
 	status = pm_runtime_get_sync(&amp;intf-&gt;dev);
 	if (status &lt; 0)
 		pm_runtime_put_sync(&amp;intf-&gt;dev);
-	else
-		atomic_inc(&amp;intf-&gt;pm_usage_cnt);
 	dev_vdbg(&amp;intf-&gt;dev, "%s: cnt %d -&gt; %d\n",
 			__func__, atomic_read(&amp;intf-&gt;dev.power.usage_count),
 			status);
@@ -1750,8 +1740,6 @@ int usb_autopm_get_interface_async(struct usb_interface *intf)
 	status = pm_runtime_get(&amp;intf-&gt;dev);
 	if (status &lt; 0 &amp;&amp; status != -EINPROGRESS)
 		pm_runtime_put_noidle(&amp;intf-&gt;dev);
-	else
-		atomic_inc(&amp;intf-&gt;pm_usage_cnt);
 	dev_vdbg(&amp;intf-&gt;dev, "%s: cnt %d -&gt; %d\n",
 			__func__, atomic_read(&amp;intf-&gt;dev.power.usage_count),
 			status);
@@ -1775,7 +1763,6 @@ void usb_autopm_get_interface_no_resume(struct usb_interface *intf)
 	struct usb_device	*udev = interface_to_usbdev(intf);
 
 	usb_mark_last_busy(udev);
-	atomic_inc(&amp;intf-&gt;pm_usage_cnt);
 	pm_runtime_get_noresume(&amp;intf-&gt;dev);
 }
 EXPORT_SYMBOL_GPL(usb_autopm_get_interface_no_resume);
diff --git a/drivers/usb/storage/realtek_cr.c b/drivers/usb/storage/realtek_cr.c
index 31b024441938..cc794e25a0b6 100644
--- a/drivers/usb/storage/realtek_cr.c
+++ b/drivers/usb/storage/realtek_cr.c
@@ -763,18 +763,16 @@ static void rts51x_suspend_timer_fn(struct timer_list *t)
 		break;
 	case RTS51X_STAT_IDLE:
 	case RTS51X_STAT_SS:
-		usb_stor_dbg(us, "RTS51X_STAT_SS, intf-&gt;pm_usage_cnt:%d, power.usage:%d\n",
-			     atomic_read(&amp;us-&gt;pusb_intf-&gt;pm_usage_cnt),
+		usb_stor_dbg(us, "RTS51X_STAT_SS, power.usage:%d\n",
 			     atomic_read(&amp;us-&gt;pusb_intf-&gt;dev.power.usage_count));
 
-		if (atomic_read(&amp;us-&gt;pusb_intf-&gt;pm_usage_cnt) &gt; 0) {
+		if (atomic_read(&amp;us-&gt;pusb_intf-&gt;dev.power.usage_count) &gt; 0) {
 			usb_stor_dbg(us, "Ready to enter SS state\n");
 			rts51x_set_stat(chip, RTS51X_STAT_SS);
 			/* ignore mass storage interface's children */
 			pm_suspend_ignore_children(&amp;us-&gt;pusb_intf-&gt;dev, true);
 			usb_autopm_put_interface_async(us-&gt;pusb_intf);
-			usb_stor_dbg(us, "RTS51X_STAT_SS 01, intf-&gt;pm_usage_cnt:%d, power.usage:%d\n",
-				     atomic_read(&amp;us-&gt;pusb_intf-&gt;pm_usage_cnt),
+			usb_stor_dbg(us, "RTS51X_STAT_SS 01, power.usage:%d\n",
 				     atomic_read(&amp;us-&gt;pusb_intf-&gt;dev.power.usage_count));
 		}
 		break;
@@ -807,11 +805,10 @@ static void rts51x_invoke_transport(struct scsi_cmnd *srb, struct us_data *us)
 	int ret;
 
 	if (working_scsi(srb)) {
-		usb_stor_dbg(us, "working scsi, intf-&gt;pm_usage_cnt:%d, power.usage:%d\n",
-			     atomic_read(&amp;us-&gt;pusb_intf-&gt;pm_usage_cnt),
+		usb_stor_dbg(us, "working scsi, power.usage:%d\n",
 			     atomic_read(&amp;us-&gt;pusb_intf-&gt;dev.power.usage_count));
 
-		if (atomic_read(&amp;us-&gt;pusb_intf-&gt;pm_usage_cnt) &lt;= 0) {
+		if (atomic_read(&amp;us-&gt;pusb_intf-&gt;dev.power.usage_count) &lt;= 0) {
 			ret = usb_autopm_get_interface(us-&gt;pusb_intf);
 			usb_stor_dbg(us, "working scsi, ret=%d\n", ret);
 		}
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 5e49e82c4368..ff010d1fd1c7 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -200,7 +200,6 @@ usb_find_last_int_out_endpoint(struct usb_host_interface *alt,
  * @dev: driver model's view of this device
  * @usb_dev: if an interface is bound to the USB major, this will point
  *	to the sysfs representation for that device.
- * @pm_usage_cnt: PM usage counter for this interface
  * @reset_ws: Used for scheduling resets from atomic context.
  * @resetting_device: USB core reset the device, so use alt setting 0 as
  *	current; needs bandwidth alloc after reset.
@@ -257,7 +256,6 @@ struct usb_interface {
 
 	struct device dev;		/* interface specific device info */
 	struct device *usb_dev;
-	atomic_t pm_usage_cnt;		/* usage counter for autosuspend */
 	struct work_struct reset_ws;	/* for resets in atomic context */
 };
 #define	to_usb_interface(d) container_of(d, struct usb_interface, dev)</pre><hr><pre>commit fc834e607ae3d18e1a20bca3f9a2d7f52ea7a2be
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Apr 18 13:12:07 2019 -0400

    USB: dummy-hcd: Fix failure to give back unlinked URBs
    
    The syzkaller USB fuzzer identified a failure mode in which dummy-hcd
    would never give back an unlinked URB.  This causes usb_kill_urb() to
    hang, leading to WARNINGs and unkillable threads.
    
    In dummy-hcd, all URBs are given back by the dummy_timer() routine as
    it scans through the list of pending URBS.  Failure to give back URBs
    can be caused by failure to start or early exit from the scanning
    loop.  The code currently has two such pathways: One is triggered when
    an unsupported bus transfer speed is encountered, and the other by
    exhausting the simulated bandwidth for USB transfers during a frame.
    
    This patch removes those two paths, thereby allowing all unlinked URBs
    to be given back in a timely manner.  It adds a check for the bus
    speed when the gadget first starts running, so that dummy_timer() will
    never thereafter encounter an unsupported speed.  And it prevents the
    loop from exiting as soon as the total bandwidth has been used up (the
    scanning loop continues, giving back unlinked URBs as they are found,
    but not transferring any more data).
    
    Thanks to Andrey Konovalov for manually running the syzkaller fuzzer
    to help track down the source of the bug.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: syzbot+d919b0f29d7b5a4994b9@syzkaller.appspotmail.com
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/gadget/udc/dummy_hcd.c b/drivers/usb/gadget/udc/dummy_hcd.c
index baf72f95f0f1..213b52508621 100644
--- a/drivers/usb/gadget/udc/dummy_hcd.c
+++ b/drivers/usb/gadget/udc/dummy_hcd.c
@@ -979,8 +979,18 @@ static int dummy_udc_start(struct usb_gadget *g,
 	struct dummy_hcd	*dum_hcd = gadget_to_dummy_hcd(g);
 	struct dummy		*dum = dum_hcd-&gt;dum;
 
-	if (driver-&gt;max_speed == USB_SPEED_UNKNOWN)
+	switch (g-&gt;speed) {
+	/* All the speeds we support */
+	case USB_SPEED_LOW:
+	case USB_SPEED_FULL:
+	case USB_SPEED_HIGH:
+	case USB_SPEED_SUPER:
+		break;
+	default:
+		dev_err(dummy_dev(dum_hcd), "Unsupported driver max speed %d\n",
+				driver-&gt;max_speed);
 		return -EINVAL;
+	}
 
 	/*
 	 * SLAVE side init ... the layer above hardware, which
@@ -1784,9 +1794,10 @@ static void dummy_timer(struct timer_list *t)
 		/* Bus speed is 500000 bytes/ms, so use a little less */
 		total = 490000;
 		break;
-	default:
+	default:	/* Can't happen */
 		dev_err(dummy_dev(dum_hcd), "bogus device speed\n");
-		return;
+		total = 0;
+		break;
 	}
 
 	/* FIXME if HZ != 1000 this will probably misbehave ... */
@@ -1828,7 +1839,7 @@ static void dummy_timer(struct timer_list *t)
 
 		/* Used up this frame's bandwidth? */
 		if (total &lt;= 0)
-			break;
+			continue;
 
 		/* find the gadget's ep for this request (if configured) */
 		address = usb_pipeendpoint (urb-&gt;pipe);</pre><hr><pre>commit 381419fa720060ba48b7bbc483be787d5b1dca6f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Apr 16 10:50:01 2019 -0400

    USB: core: Don't unbind interfaces following device reset failure
    
    The SCSI core does not like to have devices or hosts unregistered
    while error recovery is in progress.  Trying to do so can lead to
    self-deadlock: Part of the removal code tries to obtain a lock already
    held by the error handler.
    
    This can cause problems for the usb-storage and uas drivers, because
    their error handler routines perform a USB reset, and if the reset
    fails then the USB core automatically goes on to unbind all drivers
    from the device's interfaces -- all while still in the context of the
    SCSI error handler.
    
    As it turns out, practically all the scenarios leading to a USB reset
    failure end up causing a device disconnect (the main error pathway in
    usb_reset_and_verify_device(), at the end of the routine, calls
    hub_port_logical_disconnect() before returning).  As a result, the
    hub_wq thread will soon become aware of the problem and will unbind
    all the device's drivers in its own context, not in the
    error-handler's context.
    
    This means that usb_reset_device() does not need to call
    usb_unbind_and_rebind_marked_interfaces() in cases where
    usb_reset_and_verify_device() has returned an error, because hub_wq
    will take care of everything anyway.
    
    This particular problem was observed in somewhat artificial
    circumstances, by using usbfs to tell a hub to power-down a port
    connected to a USB-3 mass storage device using the UAS protocol.  With
    the port turned off, the currently executing command timed out and the
    error handler started running.  The USB reset naturally failed,
    because the hub port was off, and the error handler deadlocked as
    described above.  Not carrying out the call to
    usb_unbind_and_rebind_marked_interfaces() fixes this issue.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Kento Kobayashi &lt;Kento.A.Kobayashi@sony.com&gt;
    Tested-by: Kento Kobayashi &lt;Kento.A.Kobayashi@sony.com&gt;
    CC: Bart Van Assche &lt;bvanassche@acm.org&gt;
    CC: Martin K. Petersen &lt;martin.petersen@oracle.com&gt;
    CC: Jacky Cao &lt;Jacky.Cao@sony.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 15a2934dc29d..1949134f72e6 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -5901,7 +5901,10 @@ int usb_reset_device(struct usb_device *udev)
 					cintf-&gt;needs_binding = 1;
 			}
 		}
-		usb_unbind_and_rebind_marked_interfaces(udev);
+
+		/* If the reset failed, hub_wq will unbind drivers later */
+		if (ret == 0)
+			usb_unbind_and_rebind_marked_interfaces(udev);
 	}
 
 	usb_autosuspend_device(udev);</pre>
    <div class="pagination">
        <a href='2_13.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><span>[14]</span><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_15.html'>Next&gt;&gt;</a>
    <div>
</body>
