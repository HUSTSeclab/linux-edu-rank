<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_17.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><span>[18]</span><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_19.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit bf28ae5627442355dbb8d99238da4fb95c2dd4ec
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Feb 20 15:25:12 2018 -0800

    tools/memory-model: Remove rb-dep, smp_read_barrier_depends, and lockless_dereference
    
    Since commit 76ebbe78f739 ("locking/barriers: Add implicit
    smp_read_barrier_depends() to READ_ONCE()") was merged for the 4.15
    kernel, it has not been necessary to use smp_read_barrier_depends().
    Similarly, commit 59ecbbe7b31c ("locking/barriers: Kill
    lockless_dereference()") removed lockless_dereference() from the
    kernel.
    
    Since these primitives are no longer part of the kernel, they do not
    belong in the Linux Kernel Memory Consistency Model.  This patch
    removes them, along with the internal rb-dep relation, and updates the
    revelant documentation.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Paul E. McKenney &lt;paulmck@linux.vnet.ibm.com&gt;
    Acked-by: Peter Zijlstra &lt;peterz@infradead.org&gt;
    Cc: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;
    Cc: Thomas Gleixner &lt;tglx@linutronix.de&gt;
    Cc: akiyks@gmail.com
    Cc: boqun.feng@gmail.com
    Cc: dhowells@redhat.com
    Cc: j.alglave@ucl.ac.uk
    Cc: linux-arch@vger.kernel.org
    Cc: luc.maranget@inria.fr
    Cc: nborisov@suse.com
    Cc: npiggin@gmail.com
    Cc: parri.andrea@gmail.com
    Cc: will.deacon@arm.com
    Link: http://lkml.kernel.org/r/1519169112-20593-12-git-send-email-paulmck@linux.vnet.ibm.com
    Signed-off-by: Ingo Molnar &lt;mingo@kernel.org&gt;

diff --git a/tools/memory-model/Documentation/cheatsheet.txt b/tools/memory-model/Documentation/cheatsheet.txt
index 1917712bce99..04e458acd6d4 100644
--- a/tools/memory-model/Documentation/cheatsheet.txt
+++ b/tools/memory-model/Documentation/cheatsheet.txt
@@ -6,8 +6,7 @@
 Store, e.g., WRITE_ONCE()            Y                                       Y
 Load, e.g., READ_ONCE()              Y                              Y        Y
 Unsuccessful RMW operation           Y                              Y        Y
-smp_read_barrier_depends()              Y                       Y   Y
-*_dereference()                      Y                          Y   Y        Y
+rcu_dereference()                    Y                          Y   Y        Y
 Successful *_acquire()               R                   Y  Y   Y   Y    Y   Y
 Successful *_release()         C        Y  Y    Y     W                      Y
 smp_rmb()                               Y       R        Y      Y        R
diff --git a/tools/memory-model/Documentation/explanation.txt b/tools/memory-model/Documentation/explanation.txt
index 867e0ea69b6d..dae8b8cb2ad3 100644
--- a/tools/memory-model/Documentation/explanation.txt
+++ b/tools/memory-model/Documentation/explanation.txt
@@ -1,5 +1,5 @@
-Explanation of the Linux-Kernel Memory Model
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+Explanation of the Linux-Kernel Memory Consistency Model
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 :Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
 :Created: October 2017
@@ -35,25 +35,24 @@ Explanation of the Linux-Kernel Memory Model
 INTRODUCTION
 ------------
 
-The Linux-kernel memory model (LKMM) is rather complex and obscure.
-This is particularly evident if you read through the linux-kernel.bell
-and linux-kernel.cat files that make up the formal version of the
-memory model; they are extremely terse and their meanings are far from
-clear.
+The Linux-kernel memory consistency model (LKMM) is rather complex and
+obscure.  This is particularly evident if you read through the
+linux-kernel.bell and linux-kernel.cat files that make up the formal
+version of the model; they are extremely terse and their meanings are
+far from clear.
 
 This document describes the ideas underlying the LKMM.  It is meant
-for people who want to understand how the memory model was designed.
-It does not go into the details of the code in the .bell and .cat
-files; rather, it explains in English what the code expresses
-symbolically.
+for people who want to understand how the model was designed.  It does
+not go into the details of the code in the .bell and .cat files;
+rather, it explains in English what the code expresses symbolically.
 
 Sections 2 (BACKGROUND) through 5 (ORDERING AND CYCLES) are aimed
-toward beginners; they explain what memory models are and the basic
-notions shared by all such models.  People already familiar with these
-concepts can skim or skip over them.  Sections 6 (EVENTS) through 12
-(THE FROM_READS RELATION) describe the fundamental relations used in
-many memory models.  Starting in Section 13 (AN OPERATIONAL MODEL),
-the workings of the LKMM itself are covered.
+toward beginners; they explain what memory consistency models are and
+the basic notions shared by all such models.  People already familiar
+with these concepts can skim or skip over them.  Sections 6 (EVENTS)
+through 12 (THE FROM_READS RELATION) describe the fundamental
+relations used in many models.  Starting in Section 13 (AN OPERATIONAL
+MODEL), the workings of the LKMM itself are covered.
 
 Warning: The code examples in this document are not written in the
 proper format for litmus tests.  They don't include a header line, the
@@ -827,8 +826,8 @@ A-cumulative; they only affect the propagation of stores that are
 executed on C before the fence (i.e., those which precede the fence in
 program order).
 
-smp_read_barrier_depends(), rcu_read_lock(), rcu_read_unlock(), and
-synchronize_rcu() fences have other properties which we discuss later.
+read_lock(), rcu_read_unlock(), and synchronize_rcu() fences have
+other properties which we discuss later.
 
 
 PROPAGATION ORDER RELATION: cumul-fence
@@ -988,8 +987,8 @@ Another possibility, not mentioned earlier but discussed in the next
 section, is:
 
 	X and Y are both loads, X -&gt;addr Y (i.e., there is an address
-	dependency from X to Y), and an smp_read_barrier_depends()
-	fence occurs between them.
+	dependency from X to Y), and X is a READ_ONCE() or an atomic
+	access.
 
 Dependencies can also cause instructions to be executed in program
 order.  This is uncontroversial when the second instruction is a
@@ -1015,9 +1014,9 @@ After all, a CPU cannot ask the memory subsystem to load a value from
 a particular location before it knows what that location is.  However,
 the split-cache design used by Alpha can cause it to behave in a way
 that looks as if the loads were executed out of order (see the next
-section for more details).  For this reason, the LKMM does not include
-address dependencies between read events in the ppo relation unless an
-smp_read_barrier_depends() fence is present.
+section for more details).  The kernel includes a workaround for this
+problem when the loads come from READ_ONCE(), and therefore the LKMM
+includes address dependencies to loads in the ppo relation.
 
 On the other hand, dependencies can indirectly affect the ordering of
 two loads.  This happens when there is a dependency from a load to a
@@ -1114,11 +1113,12 @@ code such as the following:
 		int *r1;
 		int r2;
 
-		r1 = READ_ONCE(ptr);
+		r1 = ptr;
 		r2 = READ_ONCE(*r1);
 	}
 
-can malfunction on Alpha systems.  It is quite possible that r1 = &amp;x
+can malfunction on Alpha systems (notice that P1 uses an ordinary load
+to read ptr instead of READ_ONCE()).  It is quite possible that r1 = &amp;x
 and r2 = 0 at the end, in spite of the address dependency.
 
 At first glance this doesn't seem to make sense.  We know that the
@@ -1141,11 +1141,15 @@ This could not have happened if the local cache had processed the
 incoming stores in FIFO order.  In constrast, other architectures
 maintain at least the appearance of FIFO order.
 
-In practice, this difficulty is solved by inserting an
-smp_read_barrier_depends() fence between P1's two loads.  The effect
-of this fence is to cause the CPU not to execute any po-later
-instructions until after the local cache has finished processing all
-the stores it has already received.  Thus, if the code was changed to:
+In practice, this difficulty is solved by inserting a special fence
+between P1's two loads when the kernel is compiled for the Alpha
+architecture.  In fact, as of version 4.15, the kernel automatically
+adds this fence (called smp_read_barrier_depends() and defined as
+nothing at all on non-Alpha builds) after every READ_ONCE() and atomic
+load.  The effect of the fence is to cause the CPU not to execute any
+po-later instructions until after the local cache has finished
+processing all the stores it has already received.  Thus, if the code
+was changed to:
 
 	P1()
 	{
@@ -1153,13 +1157,15 @@ the stores it has already received.  Thus, if the code was changed to:
 		int r2;
 
 		r1 = READ_ONCE(ptr);
-		smp_read_barrier_depends();
 		r2 = READ_ONCE(*r1);
 	}
 
 then we would never get r1 = &amp;x and r2 = 0.  By the time P1 executed
 its second load, the x = 1 store would already be fully processed by
-the local cache and available for satisfying the read request.
+the local cache and available for satisfying the read request.  Thus
+we have yet another reason why shared data should always be read with
+READ_ONCE() or another synchronization primitive rather than accessed
+directly.
 
 The LKMM requires that smp_rmb(), acquire fences, and strong fences
 share this property with smp_read_barrier_depends(): They do not allow
@@ -1751,11 +1757,10 @@ no further involvement from the CPU.  Since the CPU doesn't ever read
 the value of x, there is nothing for the smp_rmb() fence to act on.
 
 The LKMM defines a few extra synchronization operations in terms of
-things we have already covered.  In particular, rcu_dereference() and
-lockless_dereference() are both treated as a READ_ONCE() followed by
-smp_read_barrier_depends() -- which also happens to be how they are
-defined in include/linux/rcupdate.h and include/linux/compiler.h,
-respectively.
+things we have already covered.  In particular, rcu_dereference() is
+treated as READ_ONCE() and rcu_assign_pointer() is treated as
+smp_store_release() -- which is basically how the Linux kernel treats
+them.
 
 There are a few oddball fences which need special treatment:
 smp_mb__before_atomic(), smp_mb__after_atomic(), and
diff --git a/tools/memory-model/linux-kernel.bell b/tools/memory-model/linux-kernel.bell
index 18885ad15de9..432c7cf71b23 100644
--- a/tools/memory-model/linux-kernel.bell
+++ b/tools/memory-model/linux-kernel.bell
@@ -24,7 +24,6 @@ instructions RMW[{'once,'acquire,'release}]
 enum Barriers = 'wmb (*smp_wmb*) ||
 		'rmb (*smp_rmb*) ||
 		'mb (*smp_mb*) ||
-		'rb_dep (*smp_read_barrier_depends*) ||
 		'rcu-lock (*rcu_read_lock*)  ||
 		'rcu-unlock (*rcu_read_unlock*) ||
 		'sync-rcu (*synchronize_rcu*) ||
diff --git a/tools/memory-model/linux-kernel.cat b/tools/memory-model/linux-kernel.cat
index f0d27f813ec2..df97db03b6c2 100644
--- a/tools/memory-model/linux-kernel.cat
+++ b/tools/memory-model/linux-kernel.cat
@@ -25,7 +25,6 @@ include "lock.cat"
 (*******************)
 
 (* Fences *)
-let rb-dep = [R] ; fencerel(Rb_dep) ; [R]
 let rmb = [R \ Noreturn] ; fencerel(Rmb) ; [R \ Noreturn]
 let wmb = [W] ; fencerel(Wmb) ; [W]
 let mb = ([M] ; fencerel(Mb) ; [M]) |
@@ -61,11 +60,9 @@ let dep = addr | data
 let rwdep = (dep | ctrl) ; [W]
 let overwrite = co | fr
 let to-w = rwdep | (overwrite &amp; int)
-let rrdep = addr | (dep ; rfi)
-let strong-rrdep = rrdep+ &amp; rb-dep
-let to-r = strong-rrdep | rfi-rel-acq
+let to-r = addr | (dep ; rfi) | rfi-rel-acq
 let fence = strong-fence | wmb | po-rel | rmb | acq-po
-let ppo = rrdep* ; (to-r | to-w | fence)
+let ppo = to-r | to-w | fence
 
 (* Propagation: Ordering from release operations and strong fences. *)
 let A-cumul(r) = rfe? ; r
diff --git a/tools/memory-model/linux-kernel.def b/tools/memory-model/linux-kernel.def
index f5a1eb04cb64..5dfb9c7f3462 100644
--- a/tools/memory-model/linux-kernel.def
+++ b/tools/memory-model/linux-kernel.def
@@ -13,14 +13,12 @@ WRITE_ONCE(X,V) { __store{once}(X,V); }
 smp_store_release(X,V) { __store{release}(*X,V); }
 smp_load_acquire(X) __load{acquire}(*X)
 rcu_assign_pointer(X,V) { __store{release}(X,V); }
-lockless_dereference(X) __load{lderef}(X)
 rcu_dereference(X) __load{deref}(X)
 
 // Fences
 smp_mb() { __fence{mb} ; }
 smp_rmb() { __fence{rmb} ; }
 smp_wmb() { __fence{wmb} ; }
-smp_read_barrier_depends() { __fence{rb_dep}; }
 smp_mb__before_atomic() { __fence{before-atomic} ; }
 smp_mb__after_atomic() { __fence{after-atomic} ; }
 smp_mb__after_spinlock() { __fence{after-spinlock} ; }</pre><hr><pre>commit 556bb7d252ae42d4653557325670e665087c38ad
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Feb 20 15:25:10 2018 -0800

    tools/memory-model: Add a S lock-based external-view litmus test
    
    This commit adds a litmus test in which P0() and P1() form a lock-based S
    litmus test, with the addition of P2(), which observes P0()'s and P1()'s
    accesses with a full memory barrier but without the lock.  This litmus
    test asks whether writes carried out by two different processes under the
    same lock will be seen in order by a third process not holding that lock.
    The answer to this question is "yes" for all architectures supporting
    the Linux kernel, but is "no" according to the current version of LKMM.
    
    A patch to LKMM is under development.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Paul E. McKenney &lt;paulmck@linux.vnet.ibm.com&gt;
    Acked-by: Peter Zijlstra &lt;peterz@infradead.org&gt;
    Cc: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;
    Cc: Thomas Gleixner &lt;tglx@linutronix.de&gt;
    Cc: akiyks@gmail.com
    Cc: boqun.feng@gmail.com
    Cc: dhowells@redhat.com
    Cc: j.alglave@ucl.ac.uk
    Cc: linux-arch@vger.kernel.org
    Cc: luc.maranget@inria.fr
    Cc: nborisov@suse.com
    Cc: npiggin@gmail.com
    Cc: parri.andrea@gmail.com
    Cc: will.deacon@arm.com
    Link: http://lkml.kernel.org/r/1519169112-20593-10-git-send-email-paulmck@linux.vnet.ibm.com
    Signed-off-by: Ingo Molnar &lt;mingo@kernel.org&gt;

diff --git a/tools/memory-model/litmus-tests/ISA2+pooncelock+pooncelock+pombonce.litmus b/tools/memory-model/litmus-tests/ISA2+pooncelock+pooncelock+pombonce.litmus
new file mode 100644
index 000000000000..7a39a0aaa976
--- /dev/null
+++ b/tools/memory-model/litmus-tests/ISA2+pooncelock+pooncelock+pombonce.litmus
@@ -0,0 +1,41 @@
+C ISA2+pooncelock+pooncelock+pombonce.litmus
+
+(*
+ * Result: Sometimes
+ *
+ * This test shows that the ordering provided by a lock-protected S
+ * litmus test (P0() and P1()) are not visible to external process P2().
+ * This is likely to change soon.
+ *)
+
+{}
+
+P0(int *x, int *y, spinlock_t *mylock)
+{
+	spin_lock(mylock);
+	WRITE_ONCE(*x, 1);
+	WRITE_ONCE(*y, 1);
+	spin_unlock(mylock);
+}
+
+P1(int *y, int *z, spinlock_t *mylock)
+{
+	int r0;
+
+	spin_lock(mylock);
+	r0 = READ_ONCE(*y);
+	WRITE_ONCE(*z, 1);
+	spin_unlock(mylock);
+}
+
+P2(int *x, int *z)
+{
+	int r1;
+	int r2;
+
+	r2 = READ_ONCE(*z);
+	smp_mb();
+	r1 = READ_ONCE(*x);
+}
+
+exists (1:r0=1 /\ 2:r2=1 /\ 2:r1=0)</pre><hr><pre>commit 7ae2c3c280db183ca9ada2675c34ec2f7378abfa
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jan 3 12:51:51 2018 -0500

    USB: UDC core: fix double-free in usb_add_gadget_udc_release
    
    The error-handling pathways in usb_add_gadget_udc_release() are messed
    up.  Aside from the uninformative statement labels, they can deallocate
    the udc structure after calling put_device(), which is a double-free.
    This was observed by KASAN in automatic testing.
    
    This patch cleans up the routine.  It preserves the requirement that
    when any failure occurs, we call put_device(&amp;gadget-&gt;dev).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Fengguang Wu &lt;fengguang.wu@intel.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Reviewed-by: Peter Chen &lt;peter.chen@nxp.com&gt;
    Acked-by: Felipe Balbi &lt;felipe.balbi@linux.intel.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/gadget/udc/core.c b/drivers/usb/gadget/udc/core.c
index 93eff7dec2f5..1b3efb14aec7 100644
--- a/drivers/usb/gadget/udc/core.c
+++ b/drivers/usb/gadget/udc/core.c
@@ -1147,11 +1147,7 @@ int usb_add_gadget_udc_release(struct device *parent, struct usb_gadget *gadget,
 
 	udc = kzalloc(sizeof(*udc), GFP_KERNEL);
 	if (!udc)
-		goto err1;
-
-	ret = device_add(&amp;gadget-&gt;dev);
-	if (ret)
-		goto err2;
+		goto err_put_gadget;
 
 	device_initialize(&amp;udc-&gt;dev);
 	udc-&gt;dev.release = usb_udc_release;
@@ -1160,7 +1156,11 @@ int usb_add_gadget_udc_release(struct device *parent, struct usb_gadget *gadget,
 	udc-&gt;dev.parent = parent;
 	ret = dev_set_name(&amp;udc-&gt;dev, "%s", kobject_name(&amp;parent-&gt;kobj));
 	if (ret)
-		goto err3;
+		goto err_put_udc;
+
+	ret = device_add(&amp;gadget-&gt;dev);
+	if (ret)
+		goto err_put_udc;
 
 	udc-&gt;gadget = gadget;
 	gadget-&gt;udc = udc;
@@ -1170,7 +1170,7 @@ int usb_add_gadget_udc_release(struct device *parent, struct usb_gadget *gadget,
 
 	ret = device_add(&amp;udc-&gt;dev);
 	if (ret)
-		goto err4;
+		goto err_unlist_udc;
 
 	usb_gadget_set_state(gadget, USB_STATE_NOTATTACHED);
 	udc-&gt;vbus = true;
@@ -1178,27 +1178,25 @@ int usb_add_gadget_udc_release(struct device *parent, struct usb_gadget *gadget,
 	/* pick up one of pending gadget drivers */
 	ret = check_pending_gadget_drivers(udc);
 	if (ret)
-		goto err5;
+		goto err_del_udc;
 
 	mutex_unlock(&amp;udc_lock);
 
 	return 0;
 
-err5:
+ err_del_udc:
 	device_del(&amp;udc-&gt;dev);
 
-err4:
+ err_unlist_udc:
 	list_del(&amp;udc-&gt;list);
 	mutex_unlock(&amp;udc_lock);
 
-err3:
-	put_device(&amp;udc-&gt;dev);
 	device_del(&amp;gadget-&gt;dev);
 
-err2:
-	kfree(udc);
+ err_put_udc:
+	put_device(&amp;udc-&gt;dev);
 
-err1:
+ err_put_gadget:
 	put_device(&amp;gadget-&gt;dev);
 	return ret;
 }</pre><hr><pre>commit 48a4ff1c7bb5a32d2e396b03132d20d552c0eca7
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Dec 12 14:25:13 2017 -0500

    USB: core: prevent malicious bNumInterfaces overflow
    
    A malicious USB device with crafted descriptors can cause the kernel
    to access unallocated memory by setting the bNumInterfaces value too
    high in a configuration descriptor.  Although the value is adjusted
    during parsing, this adjustment is skipped in one of the error return
    paths.
    
    This patch prevents the problem by setting bNumInterfaces to 0
    initially.  The existing code already sets it to the proper value
    after parsing is complete.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Andrey Konovalov &lt;andreyknvl@google.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c
index 55b198ba629b..78e92d29f8d9 100644
--- a/drivers/usb/core/config.c
+++ b/drivers/usb/core/config.c
@@ -555,6 +555,9 @@ static int usb_parse_configuration(struct usb_device *dev, int cfgidx,
 	unsigned iad_num = 0;
 
 	memcpy(&amp;config-&gt;desc, buffer, USB_DT_CONFIG_SIZE);
+	nintf = nintf_orig = config-&gt;desc.bNumInterfaces;
+	config-&gt;desc.bNumInterfaces = 0;	// Adjusted later
+
 	if (config-&gt;desc.bDescriptorType != USB_DT_CONFIG ||
 	    config-&gt;desc.bLength &lt; USB_DT_CONFIG_SIZE ||
 	    config-&gt;desc.bLength &gt; size) {
@@ -568,7 +571,6 @@ static int usb_parse_configuration(struct usb_device *dev, int cfgidx,
 	buffer += config-&gt;desc.bLength;
 	size -= config-&gt;desc.bLength;
 
-	nintf = nintf_orig = config-&gt;desc.bNumInterfaces;
 	if (nintf &gt; USB_MAXINTERFACES) {
 		dev_warn(ddev, "config %d has too many interfaces: %d, "
 		    "using maximum allowed: %d\n",</pre><hr><pre>commit aa15d3d257f9edcb8d15ed27e228d1c0080cb919
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Dec 11 11:58:21 2017 -0500

    USB: remove the URB_NO_FSBR flag
    
    The URB_NO_FSBR flag has never really been used.  It was introduced as
    a potential way for UHCI to minimize PCI bus usage (by not attempting
    full-speed bulk and control transfers more than once per frame), but
    the flag was not set by any drivers.
    
    There's no point in keeping it around.  This patch simplifies the API
    by removing it.  Unfortunately, it does have to be kept as part of the
    usbfs ABI, but at least we can document in
    include/uapi/linux/usbdevice_fs.h that it doesn't do anything.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Shuah Khan &lt;shuahkh@osg.samsung.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/Documentation/usb/usbip_protocol.txt b/Documentation/usb/usbip_protocol.txt
index 16b6fe27284c..c7a0f4c7e7f1 100644
--- a/Documentation/usb/usbip_protocol.txt
+++ b/Documentation/usb/usbip_protocol.txt
@@ -274,7 +274,6 @@ USBIP_CMD_SUBMIT: Submit an URB
   URB_SHORT_NOT_OK        | 0x00000001 | only in | only in   | only in  | no
   URB_ISO_ASAP            | 0x00000002 | no      | no        | no       | yes
   URB_NO_TRANSFER_DMA_MAP | 0x00000004 | yes     | yes       | yes      | yes
-  URB_NO_FSBR             | 0x00000020 | yes     | no        | no       | no
   URB_ZERO_PACKET         | 0x00000040 | no      | no        | only out | no
   URB_NO_INTERRUPT        | 0x00000080 | yes     | yes       | yes      | yes
   URB_FREE_BUFFER         | 0x00000100 | yes     | yes       | yes      | yes
diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 705c573d0257..808b370f1737 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -1677,8 +1677,6 @@ static int proc_do_submiturb(struct usb_dev_state *ps, struct usbdevfs_urb *uurb
 		u |= URB_ISO_ASAP;
 	if (uurb-&gt;flags &amp; USBDEVFS_URB_SHORT_NOT_OK &amp;&amp; is_in)
 		u |= URB_SHORT_NOT_OK;
-	if (uurb-&gt;flags &amp; USBDEVFS_URB_NO_FSBR)
-		u |= URB_NO_FSBR;
 	if (uurb-&gt;flags &amp; USBDEVFS_URB_ZERO_PACKET)
 		u |= URB_ZERO_PACKET;
 	if (uurb-&gt;flags &amp; USBDEVFS_URB_NO_INTERRUPT)
diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 9fdf137c4865..796c9b149728 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -479,9 +479,6 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 		if (is_out)
 			allowed |= URB_ZERO_PACKET;
 		/* FALLTHROUGH */
-	case USB_ENDPOINT_XFER_CONTROL:
-		allowed |= URB_NO_FSBR;	/* only affects UHCI */
-		/* FALLTHROUGH */
 	default:			/* all non-iso endpoints */
 		if (!is_out)
 			allowed |= URB_SHORT_NOT_OK;
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index d40438238938..35fcb826152c 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -73,8 +73,7 @@ static void uhci_add_fsbr(struct uhci_hcd *uhci, struct urb *urb)
 {
 	struct urb_priv *urbp = urb-&gt;hcpriv;
 
-	if (!(urb-&gt;transfer_flags &amp; URB_NO_FSBR))
-		urbp-&gt;fsbr = 1;
+	urbp-&gt;fsbr = 1;
 }
 
 static void uhci_urbp_wants_fsbr(struct uhci_hcd *uhci, struct urb_priv *urbp)
diff --git a/drivers/usb/usbip/stub_rx.c b/drivers/usb/usbip/stub_rx.c
index 536e037f541f..7a9aa9ff485d 100644
--- a/drivers/usb/usbip/stub_rx.c
+++ b/drivers/usb/usbip/stub_rx.c
@@ -412,9 +412,6 @@ static void masking_bogus_flags(struct urb *urb)
 		if (is_out)
 			allowed |= URB_ZERO_PACKET;
 		/* FALLTHROUGH */
-	case USB_ENDPOINT_XFER_CONTROL:
-		allowed |= URB_NO_FSBR;	/* only affects UHCI */
-		/* FALLTHROUGH */
 	default:			/* all non-iso endpoints */
 		if (!is_out)
 			allowed |= URB_SHORT_NOT_OK;
diff --git a/include/linux/usb.h b/include/linux/usb.h
index fbbe974661f2..fe665a0d5bce 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1293,7 +1293,6 @@ extern int usb_disabled(void);
 #define URB_ISO_ASAP		0x0002	/* iso-only; use the first unexpired
 					 * slot in the schedule */
 #define URB_NO_TRANSFER_DMA_MAP	0x0004	/* urb-&gt;transfer_dma valid on submit */
-#define URB_NO_FSBR		0x0020	/* UHCI-specific */
 #define URB_ZERO_PACKET		0x0040	/* Finish bulk OUT with short packet */
 #define URB_NO_INTERRUPT	0x0080	/* HINT: no non-error interrupt
 					 * needed */
diff --git a/include/uapi/linux/usbdevice_fs.h b/include/uapi/linux/usbdevice_fs.h
index 70ed5338d447..964e87217be4 100644
--- a/include/uapi/linux/usbdevice_fs.h
+++ b/include/uapi/linux/usbdevice_fs.h
@@ -79,7 +79,7 @@ struct usbdevfs_connectinfo {
 #define USBDEVFS_URB_SHORT_NOT_OK	0x01
 #define USBDEVFS_URB_ISO_ASAP		0x02
 #define USBDEVFS_URB_BULK_CONTINUATION	0x04
-#define USBDEVFS_URB_NO_FSBR		0x20
+#define USBDEVFS_URB_NO_FSBR		0x20	/* Not used */
 #define USBDEVFS_URB_ZERO_PACKET	0x40
 #define USBDEVFS_URB_NO_INTERRUPT	0x80
 </pre><hr><pre>commit 2ef47001b3ee3ded579b7532ebdcf8680e4d8c54
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Nov 8 12:23:17 2017 -0500

    USB: usbfs: compute urb-&gt;actual_length for isochronous
    
    The USB kerneldoc says that the actual_length field "is read in
    non-iso completion functions", but the usbfs driver uses it for all
    URB types in processcompl().  Since not all of the host controller
    drivers set actual_length for isochronous URBs, programs using usbfs
    with some host controllers don't work properly.  For example, Minas
    reports that a USB camera controlled by libusb doesn't work properly
    with a dwc2 controller.
    
    It doesn't seem worthwhile to change the HCDs and the documentation,
    since the in-kernel USB class drivers evidently don't rely on
    actual_length for isochronous transfers.  The easiest solution is for
    usbfs to calculate the actual_length value for itself, by adding up
    the lengths of the individual packets in an isochronous transfer.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Minas Harutyunyan &lt;Minas.Harutyunyan@synopsys.com&gt;
    Reported-and-tested-by: wlf &lt;wulf@rock-chips.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index c3aaafc25a04..2edb4e7b2ab8 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -1820,6 +1820,18 @@ static int proc_unlinkurb(struct usb_dev_state *ps, void __user *arg)
 	return 0;
 }
 
+static void compute_isochronous_actual_length(struct urb *urb)
+{
+	unsigned int i;
+
+	if (urb-&gt;number_of_packets &gt; 0) {
+		urb-&gt;actual_length = 0;
+		for (i = 0; i &lt; urb-&gt;number_of_packets; i++)
+			urb-&gt;actual_length +=
+					urb-&gt;iso_frame_desc[i].actual_length;
+	}
+}
+
 static int processcompl(struct async *as, void __user * __user *arg)
 {
 	struct urb *urb = as-&gt;urb;
@@ -1827,6 +1839,7 @@ static int processcompl(struct async *as, void __user * __user *arg)
 	void __user *addr = as-&gt;userurb;
 	unsigned int i;
 
+	compute_isochronous_actual_length(urb);
 	if (as-&gt;userbuffer &amp;&amp; urb-&gt;actual_length) {
 		if (copy_urb_data_to_user(as-&gt;userbuffer, urb))
 			goto err_out;
@@ -1995,6 +2008,7 @@ static int processcompl_compat(struct async *as, void __user * __user *arg)
 	void __user *addr = as-&gt;userurb;
 	unsigned int i;
 
+	compute_isochronous_actual_length(urb);
 	if (as-&gt;userbuffer &amp;&amp; urb-&gt;actual_length) {
 		if (copy_urb_data_to_user(as-&gt;userbuffer, urb))
 			return -EFAULT;</pre><hr><pre>commit 32bf9fd50ff439184ddcf925cfb3c6bc0138f7c5
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Oct 25 10:40:05 2017 -0400

    usb-storage: make use of srb local variable
    
    Commit 8b52291a0743 ("usb-storage: fix deadlock involving host lock
    and scsi_done") added a local variable to usb_stor_control_thread() in
    the usb-storage driver.  This local variable holds the value of
    us-&gt;srb, for use after the host lock has been released.
    
    But as long as we have the value in a local variable, we may as well
    use it instead of dereferencing the us pointer all over the place.
    This patch makes no functional change; it just makes the code a little
    shorter and a little neater.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/storage/usb.c b/drivers/usb/storage/usb.c
index 0dceb9fa3a06..1ae2b8554a88 100644
--- a/drivers/usb/storage/usb.c
+++ b/drivers/usb/storage/usb.c
@@ -332,7 +332,7 @@ static int usb_stor_control_thread(void * __us)
 
 		/* When we are called with no command pending, we're done */
 		srb = us-&gt;srb;
-		if (us-&gt;srb == NULL) {
+		if (srb == NULL) {
 			scsi_unlock(host);
 			mutex_unlock(&amp;us-&gt;dev_mutex);
 			usb_stor_dbg(us, "-- exiting\n");
@@ -341,7 +341,7 @@ static int usb_stor_control_thread(void * __us)
 
 		/* has the command timed out *already* ? */
 		if (test_bit(US_FLIDX_TIMED_OUT, &amp;us-&gt;dflags)) {
-			us-&gt;srb-&gt;result = DID_ABORT &lt;&lt; 16;
+			srb-&gt;result = DID_ABORT &lt;&lt; 16;
 			goto SkipForAbort;
 		}
 
@@ -351,35 +351,35 @@ static int usb_stor_control_thread(void * __us)
 		 * reject the command if the direction indicator
 		 * is UNKNOWN
 		 */
-		if (us-&gt;srb-&gt;sc_data_direction == DMA_BIDIRECTIONAL) {
+		if (srb-&gt;sc_data_direction == DMA_BIDIRECTIONAL) {
 			usb_stor_dbg(us, "UNKNOWN data direction\n");
-			us-&gt;srb-&gt;result = DID_ERROR &lt;&lt; 16;
+			srb-&gt;result = DID_ERROR &lt;&lt; 16;
 		}
 
 		/*
 		 * reject if target != 0 or if LUN is higher than
 		 * the maximum known LUN
 		 */
-		else if (us-&gt;srb-&gt;device-&gt;id &amp;&amp;
+		else if (srb-&gt;device-&gt;id &amp;&amp;
 				!(us-&gt;fflags &amp; US_FL_SCM_MULT_TARG)) {
 			usb_stor_dbg(us, "Bad target number (%d:%llu)\n",
-				     us-&gt;srb-&gt;device-&gt;id,
-				     us-&gt;srb-&gt;device-&gt;lun);
-			us-&gt;srb-&gt;result = DID_BAD_TARGET &lt;&lt; 16;
+				     srb-&gt;device-&gt;id,
+				     srb-&gt;device-&gt;lun);
+			srb-&gt;result = DID_BAD_TARGET &lt;&lt; 16;
 		}
 
-		else if (us-&gt;srb-&gt;device-&gt;lun &gt; us-&gt;max_lun) {
+		else if (srb-&gt;device-&gt;lun &gt; us-&gt;max_lun) {
 			usb_stor_dbg(us, "Bad LUN (%d:%llu)\n",
-				     us-&gt;srb-&gt;device-&gt;id,
-				     us-&gt;srb-&gt;device-&gt;lun);
-			us-&gt;srb-&gt;result = DID_BAD_TARGET &lt;&lt; 16;
+				     srb-&gt;device-&gt;id,
+				     srb-&gt;device-&gt;lun);
+			srb-&gt;result = DID_BAD_TARGET &lt;&lt; 16;
 		}
 
 		/*
 		 * Handle those devices which need us to fake
 		 * their inquiry data
 		 */
-		else if ((us-&gt;srb-&gt;cmnd[0] == INQUIRY) &amp;&amp;
+		else if ((srb-&gt;cmnd[0] == INQUIRY) &amp;&amp;
 			    (us-&gt;fflags &amp; US_FL_FIX_INQUIRY)) {
 			unsigned char data_ptr[36] = {
 			    0x00, 0x80, 0x02, 0x02,
@@ -387,13 +387,13 @@ static int usb_stor_control_thread(void * __us)
 
 			usb_stor_dbg(us, "Faking INQUIRY command\n");
 			fill_inquiry_response(us, data_ptr, 36);
-			us-&gt;srb-&gt;result = SAM_STAT_GOOD;
+			srb-&gt;result = SAM_STAT_GOOD;
 		}
 
 		/* we've got a command, let's do it! */
 		else {
-			US_DEBUG(usb_stor_show_command(us, us-&gt;srb));
-			us-&gt;proto_handler(us-&gt;srb, us);
+			US_DEBUG(usb_stor_show_command(us, srb));
+			us-&gt;proto_handler(srb, us);
 			usb_mark_last_busy(us-&gt;pusb_dev);
 		}
 
@@ -401,7 +401,7 @@ static int usb_stor_control_thread(void * __us)
 		scsi_lock(host);
 
 		/* was the command aborted? */
-		if (us-&gt;srb-&gt;result == DID_ABORT &lt;&lt; 16) {
+		if (srb-&gt;result == DID_ABORT &lt;&lt; 16) {
 SkipForAbort:
 			usb_stor_dbg(us, "scsi command aborted\n");
 			srb = NULL;	/* Don't call srb-&gt;scsi_done() */</pre><hr><pre>commit 1c0edc3633b56000e18d82fc241e3995ca18a69e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Oct 18 12:49:38 2017 -0400

    USB: core: fix out-of-bounds access bug in usb_get_bos_descriptor()
    
    Andrey used the syzkaller fuzzer to find an out-of-bounds memory
    access in usb_get_bos_descriptor().  The code wasn't checking that the
    next usb_dev_cap_header structure could fit into the remaining buffer
    space.
    
    This patch fixes the error and also reduces the bNumDeviceCaps field
    in the header to match the actual number of capabilities found, in
    cases where there are fewer than expected.
    
    Reported-by: Andrey Konovalov &lt;andreyknvl@google.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Andrey Konovalov &lt;andreyknvl@google.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c
index 68b54bd88d1e..883549ee946c 100644
--- a/drivers/usb/core/config.c
+++ b/drivers/usb/core/config.c
@@ -960,10 +960,12 @@ int usb_get_bos_descriptor(struct usb_device *dev)
 	for (i = 0; i &lt; num; i++) {
 		buffer += length;
 		cap = (struct usb_dev_cap_header *)buffer;
-		length = cap-&gt;bLength;
 
-		if (total_len &lt; length)
+		if (total_len &lt; sizeof(*cap) || total_len &lt; cap-&gt;bLength) {
+			dev-&gt;bos-&gt;desc-&gt;bNumDeviceCaps = i;
 			break;
+		}
+		length = cap-&gt;bLength;
 		total_len -= length;
 
 		if (cap-&gt;bDescriptorType != USB_DT_DEVICE_CAPABILITY) {</pre><hr><pre>commit 7c80f9e4a588f1925b07134bb2e3689335f6c6d8
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Sep 29 10:54:24 2017 -0400

    usb: usbtest: fix NULL pointer dereference
    
    If the usbtest driver encounters a device with an IN bulk endpoint but
    no OUT bulk endpoint, it will try to dereference a NULL pointer
    (out-&gt;desc.bEndpointAddress).  The problem can be solved by adding a
    missing test.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Andrey Konovalov &lt;andreyknvl@google.com&gt;
    Tested-by: Andrey Konovalov &lt;andreyknvl@google.com&gt;
    Signed-off-by: Felipe Balbi &lt;felipe.balbi@linux.intel.com&gt;

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 113e38bfe0ef..b3fc602b2e24 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -202,12 +202,13 @@ get_endpoints(struct usbtest_dev *dev, struct usb_interface *intf)
 			return tmp;
 	}
 
-	if (in) {
+	if (in)
 		dev-&gt;in_pipe = usb_rcvbulkpipe(udev,
 			in-&gt;desc.bEndpointAddress &amp; USB_ENDPOINT_NUMBER_MASK);
+	if (out)
 		dev-&gt;out_pipe = usb_sndbulkpipe(udev,
 			out-&gt;desc.bEndpointAddress &amp; USB_ENDPOINT_NUMBER_MASK);
-	}
+
 	if (iso_in) {
 		dev-&gt;iso_in = &amp;iso_in-&gt;desc;
 		dev-&gt;in_iso_pipe = usb_rcvisocpipe(udev,</pre><hr><pre>commit ab219221a5064abfff9f78c323c4a257b16cdb81
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Oct 6 10:27:44 2017 -0400

    USB: dummy-hcd: Fix deadlock caused by disconnect detection
    
    The dummy-hcd driver calls the gadget driver's disconnect callback
    under the wrong conditions.  It should invoke the callback when Vbus
    power is turned off, but instead it does so when the D+ pullup is
    turned off.
    
    This can cause a deadlock in the composite core when a gadget driver
    is unregistered:
    
    [   88.361471] ============================================
    [   88.362014] WARNING: possible recursive locking detected
    [   88.362580] 4.14.0-rc2+ #9 Not tainted
    [   88.363010] --------------------------------------------
    [   88.363561] v4l_id/526 is trying to acquire lock:
    [   88.364062]  (&amp;(&amp;cdev-&gt;lock)-&gt;rlock){....}, at: [&lt;ffffffffa0547e03&gt;] composite_disconnect+0x43/0x100 [libcomposite]
    [   88.365051]
    [   88.365051] but task is already holding lock:
    [   88.365826]  (&amp;(&amp;cdev-&gt;lock)-&gt;rlock){....}, at: [&lt;ffffffffa0547b09&gt;] usb_function_deactivate+0x29/0x80 [libcomposite]
    [   88.366858]
    [   88.366858] other info that might help us debug this:
    [   88.368301]  Possible unsafe locking scenario:
    [   88.368301]
    [   88.369304]        CPU0
    [   88.369701]        ----
    [   88.370101]   lock(&amp;(&amp;cdev-&gt;lock)-&gt;rlock);
    [   88.370623]   lock(&amp;(&amp;cdev-&gt;lock)-&gt;rlock);
    [   88.371145]
    [   88.371145]  *** DEADLOCK ***
    [   88.371145]
    [   88.372211]  May be due to missing lock nesting notation
    [   88.372211]
    [   88.373191] 2 locks held by v4l_id/526:
    [   88.373715]  #0:  (&amp;(&amp;cdev-&gt;lock)-&gt;rlock){....}, at: [&lt;ffffffffa0547b09&gt;] usb_function_deactivate+0x29/0x80 [libcomposite]
    [   88.374814]  #1:  (&amp;(&amp;dum_hcd-&gt;dum-&gt;lock)-&gt;rlock){....}, at: [&lt;ffffffffa05bd48d&gt;] dummy_pullup+0x7d/0xf0 [dummy_hcd]
    [   88.376289]
    [   88.376289] stack backtrace:
    [   88.377726] CPU: 0 PID: 526 Comm: v4l_id Not tainted 4.14.0-rc2+ #9
    [   88.378557] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1 04/01/2014
    [   88.379504] Call Trace:
    [   88.380019]  dump_stack+0x86/0xc7
    [   88.380605]  __lock_acquire+0x841/0x1120
    [   88.381252]  lock_acquire+0xd5/0x1c0
    [   88.381865]  ? composite_disconnect+0x43/0x100 [libcomposite]
    [   88.382668]  _raw_spin_lock_irqsave+0x40/0x54
    [   88.383357]  ? composite_disconnect+0x43/0x100 [libcomposite]
    [   88.384290]  composite_disconnect+0x43/0x100 [libcomposite]
    [   88.385490]  set_link_state+0x2d4/0x3c0 [dummy_hcd]
    [   88.386436]  dummy_pullup+0xa7/0xf0 [dummy_hcd]
    [   88.387195]  usb_gadget_disconnect+0xd8/0x160 [udc_core]
    [   88.387990]  usb_gadget_deactivate+0xd3/0x160 [udc_core]
    [   88.388793]  usb_function_deactivate+0x64/0x80 [libcomposite]
    [   88.389628]  uvc_function_disconnect+0x1e/0x40 [usb_f_uvc]
    
    This patch changes the code to test the port-power status bit rather
    than the port-connect status bit when deciding whether to isue the
    callback.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: David Tulloh &lt;david@tulloh.id.au&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Felipe Balbi &lt;felipe.balbi@linux.intel.com&gt;

diff --git a/drivers/usb/gadget/udc/dummy_hcd.c b/drivers/usb/gadget/udc/dummy_hcd.c
index b17618a55f1b..f04e91ef9e7c 100644
--- a/drivers/usb/gadget/udc/dummy_hcd.c
+++ b/drivers/usb/gadget/udc/dummy_hcd.c
@@ -419,6 +419,7 @@ static void set_link_state_by_speed(struct dummy_hcd *dum_hcd)
 static void set_link_state(struct dummy_hcd *dum_hcd)
 {
 	struct dummy *dum = dum_hcd-&gt;dum;
+	unsigned int power_bit;
 
 	dum_hcd-&gt;active = 0;
 	if (dum-&gt;pullup)
@@ -429,17 +430,19 @@ static void set_link_state(struct dummy_hcd *dum_hcd)
 			return;
 
 	set_link_state_by_speed(dum_hcd);
+	power_bit = (dummy_hcd_to_hcd(dum_hcd)-&gt;speed == HCD_USB3 ?
+			USB_SS_PORT_STAT_POWER : USB_PORT_STAT_POWER);
 
 	if ((dum_hcd-&gt;port_status &amp; USB_PORT_STAT_ENABLE) == 0 ||
 	     dum_hcd-&gt;active)
 		dum_hcd-&gt;resuming = 0;
 
 	/* Currently !connected or in reset */
-	if ((dum_hcd-&gt;port_status &amp; USB_PORT_STAT_CONNECTION) == 0 ||
+	if ((dum_hcd-&gt;port_status &amp; power_bit) == 0 ||
 			(dum_hcd-&gt;port_status &amp; USB_PORT_STAT_RESET) != 0) {
-		unsigned disconnect = USB_PORT_STAT_CONNECTION &amp;
+		unsigned int disconnect = power_bit &amp;
 				dum_hcd-&gt;old_status &amp; (~dum_hcd-&gt;port_status);
-		unsigned reset = USB_PORT_STAT_RESET &amp;
+		unsigned int reset = USB_PORT_STAT_RESET &amp;
 				(~dum_hcd-&gt;old_status) &amp; dum_hcd-&gt;port_status;
 
 		/* Report reset and disconnect events to the driver */</pre>
    <div class="pagination">
        <a href='2_17.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><span>[18]</span><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_19.html'>Next&gt;&gt;</a>
    <div>
</body>
