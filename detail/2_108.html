<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_107.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><span>[108]</span><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_109.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit f3fd77cd2f4499f3e2ef9a1e6d5e4f4349d556c3
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 4 11:54:28 2007 -0400

    USB: remove references to dev.power.power_state
    
    This revised patch (as891b) removes two unnecessary references to
    intf-&gt;dev.power.power_state from usb-storage, and replaces a reference
    to root_hub-&gt;dev.power.power_state with a check of hcd-&gt;state.  This
    is in preparation for the removal of dev.power.power_state, which is
    already deprecated.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd-pci.c b/drivers/usb/core/hcd-pci.c
index edf4300a3f7a..5cf6d5f9acbd 100644
--- a/drivers/usb/core/hcd-pci.c
+++ b/drivers/usb/core/hcd-pci.c
@@ -207,7 +207,8 @@ int usb_hcd_pci_suspend (struct pci_dev *dev, pm_message_t message)
 	 * We must ignore the FREEZE vs SUSPEND distinction here, because
 	 * otherwise the swsusp will save (and restore) garbage state.
 	 */
-	if (hcd-&gt;self.root_hub-&gt;dev.power.power_state.event == PM_EVENT_ON)
+	if (!(hcd-&gt;state == HC_STATE_SUSPENDED ||
+			hcd-&gt;state == HC_STATE_HALT))
 		return -EBUSY;
 
 	if (hcd-&gt;driver-&gt;suspend) {
diff --git a/drivers/usb/storage/usb.c b/drivers/usb/storage/usb.c
index 8e898e3d861e..df5dc186aef5 100644
--- a/drivers/usb/storage/usb.c
+++ b/drivers/usb/storage/usb.c
@@ -197,7 +197,6 @@ static int storage_suspend(struct usb_interface *iface, pm_message_t message)
 	US_DEBUGP("%s\n", __FUNCTION__);
 	if (us-&gt;suspend_resume_hook)
 		(us-&gt;suspend_resume_hook)(us, US_SUSPEND);
-	iface-&gt;dev.power.power_state.event = message.event;
 
 	/* When runtime PM is working, we'll set a flag to indicate
 	 * whether we should autoresume when a SCSI request arrives. */
@@ -215,7 +214,6 @@ static int storage_resume(struct usb_interface *iface)
 	US_DEBUGP("%s\n", __FUNCTION__);
 	if (us-&gt;suspend_resume_hook)
 		(us-&gt;suspend_resume_hook)(us, US_RESUME);
-	iface-&gt;dev.power.power_state.event = PM_EVENT_ON;
 
 	mutex_unlock(&amp;us-&gt;dev_mutex);
 	return 0;</pre><hr><pre>commit 8adb4786789c25007f39b4d00dd03cc83bdcb896
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 4 11:53:30 2007 -0400

    USB: don't unsuspend for a new connection
    
    This patch (as889) prevents the hub driver from trying to resume a
    port when there is a new connection.  For one thing, the resume is not
    needed -- the upcoming port reset will clear the suspend feature
    automatically.  For another, on some systems the resume fails and
    causes problems.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 8aea8559bec2..702023075310 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2426,19 +2426,6 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 		return;
 	}
 
-#ifdef  CONFIG_USB_SUSPEND
-	/* If something is connected, but the port is suspended, wake it up. */
-	if (portstatus &amp; USB_PORT_STAT_SUSPEND) {
-		status = hub_port_resume(hub, port1, NULL);
-		if (status &lt; 0) {
-			dev_dbg(hub_dev,
-				"can't clear suspend on port %d; %d\n",
-				port1, status);
-			goto done;
-		}
-	}
-#endif
-
 	for (i = 0; i &lt; SET_CONFIG_TRIES; i++) {
 		struct usb_device *udev;
 </pre><hr><pre>commit b6f6436da0c6853eedad86f5075b139c1a3bcb5d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 4 11:51:54 2007 -0400

    USB: move bus_suspend and bus_resume method calls
    
    This patch (as885) moves the root-hub bus_suspend() and bus_resume()
    method calls from the hub driver's suspend and resume methods into the
    usb_generic driver methods, where they make just as much sense.
    
    Their old locations were not fully correct.  For example, in a kernel
    compiled without CONFIG_USB_SUSPEND, if one were to do:
    
            echo -n 1-0:1.0 &gt;/sys/bus/usb/drivers/hub/unbind
    
    to unbind the hub driver from a root hub, there would then be no way
    to suspend that root hub.  Attempts to put the system to sleep would
    fail; the USB controller driver would refuse to suspend because the
    root hub was still active.
    
    The patch also makes a very slight change in the way devices with no
    driver are handled during suspend.  Rather than doing a standard USB
    port-suspend directly, now the suspend routine in usb_generic is
    called.  In practice this should never affect anyone.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 63d47946e3db..e8b447e06c54 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -802,14 +802,13 @@ static int usb_suspend_device(struct usb_device *udev, pm_message_t msg)
 			udev-&gt;state == USB_STATE_SUSPENDED)
 		goto done;
 
-	/* For devices that don't have a driver, we do a standard suspend. */
-	if (udev-&gt;dev.driver == NULL) {
+	/* For devices that don't have a driver, we do a generic suspend. */
+	if (udev-&gt;dev.driver)
+		udriver = to_usb_device_driver(udev-&gt;dev.driver);
+	else {
 		udev-&gt;do_remote_wakeup = 0;
-		status = usb_port_suspend(udev);
-		goto done;
+		udriver = &amp;usb_generic_driver;
 	}
-
-	udriver = to_usb_device_driver(udev-&gt;dev.driver);
 	status = udriver-&gt;suspend(udev, msg);
 
 done:
diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index e7ec9b6b7a93..7cbf992adccd 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -19,6 +19,7 @@
 
 #include &lt;linux/usb.h&gt;
 #include "usb.h"
+#include "hcd.h"
 
 static inline const char *plural(int n)
 {
@@ -193,12 +194,46 @@ static void generic_disconnect(struct usb_device *udev)
 
 static int generic_suspend(struct usb_device *udev, pm_message_t msg)
 {
-	return usb_port_suspend(udev);
+	int rc;
+
+	rc = usb_port_suspend(udev);
+
+	/* Root hubs don't have upstream ports to suspend,
+	 * so the line above won't do much for them.  We have to
+	 * shut down their downstream HC-to-USB interfaces manually,
+	 * by doing a bus (or "global") suspend.
+	 */
+	if (rc == 0 &amp;&amp; !udev-&gt;parent) {
+		rc = hcd_bus_suspend(udev-&gt;bus);
+		if (rc) {
+			dev_dbg(&amp;udev-&gt;dev, "'global' suspend %d\n", rc);
+			usb_port_resume(udev);
+		}
+	}
+	return rc;
 }
 
 static int generic_resume(struct usb_device *udev)
 {
-	return usb_port_resume(udev);
+	int rc;
+
+	rc = usb_port_resume(udev);
+
+	/* Root hubs don't have upstream ports to resume or reset,
+	 * so the line above won't do much for them.  We have to
+	 * start up their downstream HC-to-USB interfaces manually,
+	 * by doing a bus (or "global") resume.
+	 */
+	if (rc == 0 &amp;&amp; !udev-&gt;parent) {
+		rc = hcd_bus_resume(udev-&gt;bus);
+		if (rc)
+			dev_dbg(&amp;udev-&gt;dev, "'global' resume %d\n", rc);
+		else {
+			/* TRSMRCY = 10 msec */
+			msleep(10);
+		}
+	}
+	return rc;
 }
 
 #endif	/* CONFIG_PM */
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index a9cf8b30bccc..8aea8559bec2 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1916,7 +1916,6 @@ static int hub_suspend(struct usb_interface *intf, pm_message_t msg)
 	struct usb_hub		*hub = usb_get_intfdata (intf);
 	struct usb_device	*hdev = hub-&gt;hdev;
 	unsigned		port1;
-	int			status = 0;
 
 	/* fail if children aren't already suspended */
 	for (port1 = 1; port1 &lt;= hdev-&gt;maxchild; port1++) {
@@ -1942,44 +1941,15 @@ static int hub_suspend(struct usb_interface *intf, pm_message_t msg)
 
 	/* stop khubd and related activity */
 	hub_quiesce(hub);
-
-	/* "global suspend" of the downstream HC-to-USB interface */
-	if (!hdev-&gt;parent) {
-		status = hcd_bus_suspend(hdev-&gt;bus);
-		if (status != 0) {
-			dev_dbg(&amp;hdev-&gt;dev, "'global' suspend %d\n", status);
-			hub_activate(hub);
-		}
-	}
-	return status;
+	return 0;
 }
 
 static int hub_resume(struct usb_interface *intf)
 {
 	struct usb_hub		*hub = usb_get_intfdata (intf);
-	struct usb_device	*hdev = hub-&gt;hdev;
-	int			status;
 
 	dev_dbg(&amp;intf-&gt;dev, "%s\n", __FUNCTION__);
 
-	/* "global resume" of the downstream HC-to-USB interface */
-	if (!hdev-&gt;parent) {
-		struct usb_bus	*bus = hdev-&gt;bus;
-		if (bus) {
-			status = hcd_bus_resume (bus);
-			if (status) {
-				dev_dbg(&amp;intf-&gt;dev, "'global' resume %d\n",
-					status);
-				return status;
-			}
-		} else
-			return -EOPNOTSUPP;
-		if (status == 0) {
-			/* TRSMRCY = 10 msec */
-			msleep(10);
-		}
-	}
-
 	/* tell khubd to look for changes on this hub */
 	hub_activate(hub);
 	return 0;</pre><hr><pre>commit 4d461095ef6967324bc5da5d65d23ad27fc604f9
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 4 11:51:25 2007 -0400

    USB: Implement PM FREEZE and PRETHAW
    
    This patch (as884) finally implements the time-saving semantics
    possible with the Power Management FREEZE and PRETHAW events.  Their
    proper handling requires only that devices be quiesced, with
    interrupts and DMA turned off; non-root USB devices don't actually
    need to be put in a suspended state.  The patch checks and avoids
    doing the suspend call when possible.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 38c3dd2a44e0..63d47946e3db 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -1050,8 +1050,15 @@ static int usb_suspend_both(struct usb_device *udev, pm_message_t msg)
 				break;
 		}
 	}
-	if (status == 0)
+	if (status == 0) {
+
+		/* Non-root devices don't need to do anything for FREEZE
+		 * or PRETHAW. */
+		if (udev-&gt;parent &amp;&amp; (msg.event == PM_EVENT_FREEZE ||
+				msg.event == PM_EVENT_PRETHAW))
+			goto done;
 		status = usb_suspend_device(udev, msg);
+	}
 
 	/* If the suspend failed, resume interfaces that did get suspended */
 	if (status != 0) {
diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index 9bbcb20e2d94..e7ec9b6b7a93 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -193,10 +193,6 @@ static void generic_disconnect(struct usb_device *udev)
 
 static int generic_suspend(struct usb_device *udev, pm_message_t msg)
 {
-	/* USB devices enter SUSPEND state through their hubs, but can be
-	 * marked for FREEZE as soon as their children are already idled.
-	 * But those semantics are useless, so we equate the two (sigh).
-	 */
 	return usb_port_suspend(udev);
 }
 </pre><hr><pre>commit 784a6e1cc406b7ef48476a1f38b83fc551f5616f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 4 11:49:57 2007 -0400

    USB: interface PM state
    
    This patch (as880) strives to keep the PM core's idea of a USB
    interface's power state in synch with usbcore's own idea.  In the end
    this doesn't really matter, but it's better to be consistent.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 2619986e5300..38c3dd2a44e0 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -879,8 +879,6 @@ static int usb_suspend_interface(struct usb_interface *intf, pm_message_t msg)
 
 done:
 	// dev_dbg(&amp;intf-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
-	if (status == 0)
-		intf-&gt;dev.power.power_state.event = msg.event;
 	return status;
 }
 
@@ -920,8 +918,6 @@ static int usb_resume_interface(struct usb_interface *intf)
 
 done:
 	// dev_dbg(&amp;intf-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
-	if (status == 0)
-		intf-&gt;dev.power.power_state.event = PM_EVENT_ON;
 	return status;
 }
 
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index bf2eb0dae2ec..6f361df374fc 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -100,11 +100,13 @@ static inline int is_usb_device_driver(struct device_driver *drv)
 static inline void mark_active(struct usb_interface *f)
 {
 	f-&gt;is_active = 1;
+	f-&gt;dev.power.power_state.event = PM_EVENT_ON;
 }
 
 static inline void mark_quiesced(struct usb_interface *f)
 {
 	f-&gt;is_active = 0;
+	f-&gt;dev.power.power_state.event = PM_EVENT_SUSPEND;
 }
 
 static inline int is_active(const struct usb_interface *f)</pre><hr><pre>commit 2fa45a4cffd0c4ab4e238e8ad3b4f9b0c10ac1f3
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed May 30 11:11:12 2007 -0400

    USB HID: avoid flush_scheduled_work()
    
    This patch (as914) replaces a call to flush_scheduled_work() with
    cancel_work_sync(), in order to help avoid potential deadlocks.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c
index d91b9dac6dff..093abb5c9879 100644
--- a/drivers/hid/usbhid/hid-core.c
+++ b/drivers/hid/usbhid/hid-core.c
@@ -956,7 +956,7 @@ static void hid_disconnect(struct usb_interface *intf)
 	usb_kill_urb(usbhid-&gt;urbctrl);
 
 	del_timer_sync(&amp;usbhid-&gt;io_retry);
-	flush_scheduled_work();
+	cancel_work_sync(&amp;usbhid-&gt;reset_work);
 
 	if (hid-&gt;claimed &amp; HID_CLAIMED_INPUT)
 		hidinput_disconnect(hid);</pre><hr><pre>commit 6fd75b19483b2f6e6619602a535b4939e46921c1
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 4 11:57:00 2007 -0400

    OHCI: Fix machine check in ohci_hub_status_data
    
    This patch (as901) fixes an oversight in ohci-hcd.  The
    hub_status_data routine must not try to access the controller's
    memory-mapped registers if the controller is in a low-power state;
    such attempts will cause a crash on some architectures (such as PPC).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ohci-hub.c b/drivers/usb/host/ohci-hub.c
index 216c9c9d4d6d..bb9cc595219e 100644
--- a/drivers/usb/host/ohci-hub.c
+++ b/drivers/usb/host/ohci-hub.c
@@ -417,6 +417,8 @@ ohci_hub_status_data (struct usb_hcd *hcd, char *buf)
 	unsigned long	flags;
 
 	spin_lock_irqsave (&amp;ohci-&gt;lock, flags);
+	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags))
+		goto done;
 
 	/* undocumented erratum seen on at least rev D */
 	if ((ohci-&gt;flags &amp; OHCI_QUIRK_AMD756)</pre><hr><pre>commit 615ae11b3b4af7a5adb0819ff11b3b764eb92268
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jun 8 15:23:27 2007 -0400

    USB: Fix up bogus bInterval values in endpoint descriptors
    
    This patch (as904) adds code to check for endpoint descriptor bInterval
    values outside the legal limits.  Illegal values are set to 32 ms, which
    seems like a reasonable default.
    
    This fixes Bugzilla #8432.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c
index 2d4fd530e5e4..dd3482328ad2 100644
--- a/drivers/usb/core/config.c
+++ b/drivers/usb/core/config.c
@@ -1,4 +1,5 @@
 #include &lt;linux/usb.h&gt;
+#include &lt;linux/usb/ch9.h&gt;
 #include &lt;linux/module.h&gt;
 #include &lt;linux/init.h&gt;
 #include &lt;linux/slab.h&gt;
@@ -49,7 +50,7 @@ static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,
 	unsigned char *buffer0 = buffer;
 	struct usb_endpoint_descriptor *d;
 	struct usb_host_endpoint *endpoint;
-	int n, i;
+	int n, i, j;
 
 	d = (struct usb_endpoint_descriptor *) buffer;
 	buffer += d-&gt;bLength;
@@ -84,6 +85,45 @@ static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,
 	memcpy(&amp;endpoint-&gt;desc, d, n);
 	INIT_LIST_HEAD(&amp;endpoint-&gt;urb_list);
 
+	/* If the bInterval value is outside the legal range,
+	 * set it to a default value: 32 ms */
+	i = 0;		/* i = min, j = max, n = default */
+	j = 255;
+	if (usb_endpoint_xfer_int(d)) {
+		i = 1;
+		switch (to_usb_device(ddev)-&gt;speed) {
+		case USB_SPEED_HIGH:
+			n = 9;		/* 32 ms = 2^(9-1) uframes */
+			j = 16;
+			break;
+		default:		/* USB_SPEED_FULL or _LOW */
+			/* For low-speed, 10 ms is the official minimum.
+			 * But some "overclocked" devices might want faster
+			 * polling so we'll allow it. */
+			n = 32;
+			break;
+		}
+	} else if (usb_endpoint_xfer_isoc(d)) {
+		i = 1;
+		j = 16;
+		switch (to_usb_device(ddev)-&gt;speed) {
+		case USB_SPEED_HIGH:
+			n = 9;		/* 32 ms = 2^(9-1) uframes */
+			break;
+		default:		/* USB_SPEED_FULL */
+			n = 6;		/* 32 ms = 2^(6-1) frames */
+			break;
+		}
+	}
+	if (d-&gt;bInterval &lt; i || d-&gt;bInterval &gt; j) {
+		dev_warn(ddev, "config %d interface %d altsetting %d "
+		    "endpoint 0x%X has an invalid bInterval %d, "
+		    "changing to %d\n",
+		    cfgno, inum, asnum,
+		    d-&gt;bEndpointAddress, d-&gt;bInterval, n);
+		endpoint-&gt;desc.bInterval = n;
+	}
+
 	/* Skip over any Class Specific or Vendor Specific descriptors;
 	 * find the next endpoint or interface descriptor */
 	endpoint-&gt;extra = buffer;</pre><hr><pre>commit d5d4db704b962773c03ee3beb3258b6450611e66
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 29 16:34:52 2007 -0400

    USB: replace flush_workqueue with cancel_sync_work
    
    This patch (as912) replaces a couple of calls to flush_workqueue()
    with cancel_sync_work() and cancel_rearming_delayed_work().  Using a
    more directed approach allows us to avoid some nasty deadlocks.  The
    prime example occurs when a first-level device (the parent is a root
    hub) is removed while at the same time the root hub gets a remote
    wakeup request.  khubd would try to flush the autosuspend workqueue
    while holding the root-hub's lock, and the remote-wakeup workqueue
    routine would be waiting to lock the root hub.
    
    The patch also reorganizes the power management portion of
    usb_disconnect(), separating it out into its own routine.  The
    autosuspend workqueue entry is cancelled immediately instead of
    waiting for the device's release routine.  In addition,
    synchronization with the autosuspend thread is carried out even for
    root hubs (an oversight in the original code).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: Andrew Morton &lt;akpm@linux-foundation.org&gt;
    Cc: Greg KH &lt;gregkh@suse.de&gt;
    Cc: Mark Lord &lt;lkml@rtr.ca&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index e277258df382..8969e42434b9 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1681,7 +1681,7 @@ void usb_remove_hcd(struct usb_hcd *hcd)
 	spin_unlock_irq (&amp;hcd_root_hub_lock);
 
 #ifdef CONFIG_PM
-	flush_workqueue(ksuspend_usb_wq);
+	cancel_work_sync(&amp;hcd-&gt;wakeup_work);
 #endif
 
 	mutex_lock(&amp;usb_bus_list_lock);
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index caaa46f2dec7..24f10a19dbdb 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1158,6 +1158,30 @@ static void release_address(struct usb_device *udev)
 	}
 }
 
+#ifdef	CONFIG_USB_SUSPEND
+
+static void usb_stop_pm(struct usb_device *udev)
+{
+	/* Synchronize with the ksuspend thread to prevent any more
+	 * autosuspend requests from being submitted, and decrement
+	 * the parent's count of unsuspended children.
+	 */
+	usb_pm_lock(udev);
+	if (udev-&gt;parent &amp;&amp; !udev-&gt;discon_suspended)
+		usb_autosuspend_device(udev-&gt;parent);
+	usb_pm_unlock(udev);
+
+	/* Stop any autosuspend requests already submitted */
+	cancel_rearming_delayed_work(&amp;udev-&gt;autosuspend);
+}
+
+#else
+
+static inline void usb_stop_pm(struct usb_device *udev)
+{ }
+
+#endif
+
 /**
  * usb_disconnect - disconnect a device (usbcore-internal)
  * @pdev: pointer to device being disconnected
@@ -1224,13 +1248,7 @@ void usb_disconnect(struct usb_device **pdev)
 	*pdev = NULL;
 	spin_unlock_irq(&amp;device_state_lock);
 
-	/* Decrement the parent's count of unsuspended children */
-	if (udev-&gt;parent) {
-		usb_pm_lock(udev);
-		if (!udev-&gt;discon_suspended)
-			usb_autosuspend_device(udev-&gt;parent);
-		usb_pm_unlock(udev);
-	}
+	usb_stop_pm(udev);
 
 	put_device(&amp;udev-&gt;dev);
 }
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index 80627b6a2bf9..4a6299bd0047 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -184,10 +184,6 @@ static void usb_release_dev(struct device *dev)
 
 	udev = to_usb_device(dev);
 
-#ifdef	CONFIG_USB_SUSPEND
-	cancel_delayed_work(&amp;udev-&gt;autosuspend);
-	flush_workqueue(ksuspend_usb_wq);
-#endif
 	usb_destroy_configuration(udev);
 	usb_put_hcd(bus_to_hcd(udev-&gt;bus));
 	kfree(udev-&gt;product);</pre><hr><pre>commit ae2d990eede0ef5938c210d48a177c044258ecd8
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed May 23 13:58:12 2007 -0700

    HiSax: fix error checking for hisax_register()]
    
    This patch (as875) adds error-checking to the callers of hisax_register().
    It also changes an error pathway in that routine, making it return an error
    code rather than 0.
    
    This fixes Bugzilla #7960.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Karsten Keil &lt;kkeil@suse.de&gt;
    Cc: Martin Bachem &lt;info@colognechip.com&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;

diff --git a/drivers/isdn/hisax/config.c b/drivers/isdn/hisax/config.c
index da4196f21e0f..8d53a7fd2671 100644
--- a/drivers/isdn/hisax/config.c
+++ b/drivers/isdn/hisax/config.c
@@ -1551,7 +1551,7 @@ int hisax_register(struct hisax_d_if *hisax_d_if, struct hisax_b_if *b_if[],
 	if (retval == 0) { // yuck
 		cards[i].typ = 0;
 		nrcards--;
-		return retval;
+		return -EINVAL;
 	}
 	cs = cards[i].cs;
 	hisax_d_if-&gt;cs = cs;
diff --git a/drivers/isdn/hisax/hfc_usb.c b/drivers/isdn/hisax/hfc_usb.c
index 1f18f1993387..b1a26e02df02 100644
--- a/drivers/isdn/hisax/hfc_usb.c
+++ b/drivers/isdn/hisax/hfc_usb.c
@@ -485,7 +485,6 @@ fill_isoc_urb(struct urb *urb, struct usb_device *dev, unsigned int pipe,
 {
 	int k;
 
-	spin_lock_init(&amp;urb-&gt;lock);
 	urb-&gt;dev = dev;
 	urb-&gt;pipe = pipe;
 	urb-&gt;complete = complete;
@@ -578,16 +577,14 @@ stop_isoc_chain(usb_fifo * fifo)
 			    "HFC-S USB: Stopping iso chain for fifo %i.%i",
 			    fifo-&gt;fifonum, i);
 #endif
-			usb_unlink_urb(fifo-&gt;iso[i].purb);
+			usb_kill_urb(fifo-&gt;iso[i].purb);
 			usb_free_urb(fifo-&gt;iso[i].purb);
 			fifo-&gt;iso[i].purb = NULL;
 		}
 	}
-	if (fifo-&gt;urb) {
-		usb_unlink_urb(fifo-&gt;urb);
-		usb_free_urb(fifo-&gt;urb);
-		fifo-&gt;urb = NULL;
-	}
+	usb_kill_urb(fifo-&gt;urb);
+	usb_free_urb(fifo-&gt;urb);
+	fifo-&gt;urb = NULL;
 	fifo-&gt;active = 0;
 }
 
@@ -1305,7 +1302,11 @@ usb_init(hfcusb_data * hfc)
 	}
 	/* default Prot: EURO ISDN, should be a module_param */
 	hfc-&gt;protocol = 2;
-	hisax_register(&amp;hfc-&gt;d_if, p_b_if, "hfc_usb", hfc-&gt;protocol);
+	i = hisax_register(&amp;hfc-&gt;d_if, p_b_if, "hfc_usb", hfc-&gt;protocol);
+	if (i) {
+		printk(KERN_INFO "HFC-S USB: hisax_register -&gt; %d\n", i);
+		return i;
+	}
 
 #ifdef CONFIG_HISAX_DEBUG
 	hfc_debug = debug;
@@ -1626,11 +1627,9 @@ hfc_usb_probe(struct usb_interface *intf, const struct usb_device_id *id)
 #endif
 			/* init the chip and register the driver */
 			if (usb_init(context)) {
-				if (context-&gt;ctrl_urb) {
-					usb_unlink_urb(context-&gt;ctrl_urb);
-					usb_free_urb(context-&gt;ctrl_urb);
-					context-&gt;ctrl_urb = NULL;
-				}
+				usb_kill_urb(context-&gt;ctrl_urb);
+				usb_free_urb(context-&gt;ctrl_urb);
+				context-&gt;ctrl_urb = NULL;
 				kfree(context);
 				return (-EIO);
 			}
@@ -1682,21 +1681,15 @@ hfc_usb_disconnect(struct usb_interface
 				    i);
 #endif
 			}
-			if (context-&gt;fifos[i].urb) {
-				usb_unlink_urb(context-&gt;fifos[i].urb);
-				usb_free_urb(context-&gt;fifos[i].urb);
-				context-&gt;fifos[i].urb = NULL;
-			}
+			usb_kill_urb(context-&gt;fifos[i].urb);
+			usb_free_urb(context-&gt;fifos[i].urb);
+			context-&gt;fifos[i].urb = NULL;
 		}
 		context-&gt;fifos[i].active = 0;
 	}
-	/* wait for all URBS to terminate */
-	mdelay(10);
-	if (context-&gt;ctrl_urb) {
-		usb_unlink_urb(context-&gt;ctrl_urb);
-		usb_free_urb(context-&gt;ctrl_urb);
-		context-&gt;ctrl_urb = NULL;
-	}
+	usb_kill_urb(context-&gt;ctrl_urb);
+	usb_free_urb(context-&gt;ctrl_urb);
+	context-&gt;ctrl_urb = NULL;
 	hisax_unregister(&amp;context-&gt;d_if);
 	kfree(context);		/* free our structure again */
 }				/* hfc_usb_disconnect */
diff --git a/drivers/isdn/hisax/hisax_fcpcipnp.c b/drivers/isdn/hisax/hisax_fcpcipnp.c
index 9e088fce8c3a..7993e01f9fc5 100644
--- a/drivers/isdn/hisax/hisax_fcpcipnp.c
+++ b/drivers/isdn/hisax/hisax_fcpcipnp.c
@@ -859,7 +859,11 @@ new_adapter(void)
 	for (i = 0; i &lt; 2; i++)
 		b_if[i] = &amp;adapter-&gt;bcs[i].b_if;
 
-	hisax_register(&amp;adapter-&gt;isac.hisax_d_if, b_if, "fcpcipnp", protocol);
+	if (hisax_register(&amp;adapter-&gt;isac.hisax_d_if, b_if, "fcpcipnp",
+			protocol) != 0) {
+		kfree(adapter);
+		adapter = NULL;
+	}
 
 	return adapter;
 }
diff --git a/drivers/isdn/hisax/st5481_init.c b/drivers/isdn/hisax/st5481_init.c
index bb3a28a53ff4..13751237bfcd 100644
--- a/drivers/isdn/hisax/st5481_init.c
+++ b/drivers/isdn/hisax/st5481_init.c
@@ -107,12 +107,17 @@ static int probe_st5481(struct usb_interface *intf,
 	for (i = 0; i &lt; 2; i++)
 		b_if[i] = &amp;adapter-&gt;bcs[i].b_if;
 
-	hisax_register(&amp;adapter-&gt;hisax_d_if, b_if, "st5481_usb", protocol);
+	if (hisax_register(&amp;adapter-&gt;hisax_d_if, b_if, "st5481_usb",
+			protocol) != 0)
+		goto err_b1;
+
 	st5481_start(adapter);
 
 	usb_set_intfdata(intf, adapter);
 	return 0;
 
+ err_b1:
+	st5481_release_b(&amp;adapter-&gt;bcs[1]);
  err_b:
 	st5481_release_b(&amp;adapter-&gt;bcs[0]);
  err_d:
diff --git a/drivers/isdn/hisax/st5481_usb.c b/drivers/isdn/hisax/st5481_usb.c
index ff1595122048..4ada66b8b679 100644
--- a/drivers/isdn/hisax/st5481_usb.c
+++ b/drivers/isdn/hisax/st5481_usb.c
@@ -407,7 +407,6 @@ fill_isoc_urb(struct urb *urb, struct usb_device *dev,
 {
 	int k;
 
-	spin_lock_init(&amp;urb-&gt;lock);
 	urb-&gt;dev=dev;
 	urb-&gt;pipe=pipe;
 	urb-&gt;interval = 1;</pre>
    <div class="pagination">
        <a href='2_107.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><span>[108]</span><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_109.html'>Next&gt;&gt;</a>
    <div>
</body>
