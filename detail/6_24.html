<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Zhejiang University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Zhejiang University</h1>
    <div class="pagination">
        <a href='6_23.html'>&lt;&lt;Prev</a><a href='6.html'>1</a><a href='6_2.html'>2</a><a href='6_3.html'>3</a><a href='6_4.html'>4</a><a href='6_5.html'>5</a><a href='6_6.html'>6</a><a href='6_7.html'>7</a><a href='6_8.html'>8</a><a href='6_9.html'>9</a><a href='6_10.html'>10</a><a href='6_11.html'>11</a><a href='6_12.html'>12</a><a href='6_13.html'>13</a><a href='6_14.html'>14</a><a href='6_15.html'>15</a><a href='6_16.html'>16</a><a href='6_17.html'>17</a><a href='6_18.html'>18</a><a href='6_19.html'>19</a><a href='6_20.html'>20</a><a href='6_21.html'>21</a><a href='6_22.html'>22</a><a href='6_23.html'>23</a><span>[24]</span><a href='6_25.html'>25</a><a href='6_26.html'>26</a><a href='6_27.html'>27</a><a href='6_28.html'>28</a><a href='6_29.html'>29</a><a href='6_30.html'>30</a><a href='6_31.html'>31</a><a href='6_32.html'>32</a><a href='6_33.html'>33</a><a href='6_34.html'>34</a><a href='6_25.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 869f4fdaf4ca7bb6e0d05caf6fa1108dddc346a7
Author: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
Date:   Sat Jan 9 20:01:21 2021 +0800

    netfilter: nf_nat: Fix memleak in nf_nat_init
    
    When register_pernet_subsys() fails, nf_nat_bysource
    should be freed just like when nf_ct_extend_register()
    fails.
    
    Fixes: 1cd472bf036ca ("netfilter: nf_nat: add nat hook register functions to nf_nat")
    Signed-off-by: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
    Acked-by: Florian Westphal &lt;fw@strlen.de&gt;
    Signed-off-by: Pablo Neira Ayuso &lt;pablo@netfilter.org&gt;

diff --git a/net/netfilter/nf_nat_core.c b/net/netfilter/nf_nat_core.c
index ea923f8cf9c4..b7c3c902290f 100644
--- a/net/netfilter/nf_nat_core.c
+++ b/net/netfilter/nf_nat_core.c
@@ -1174,6 +1174,7 @@ static int __init nf_nat_init(void)
 	ret = register_pernet_subsys(&amp;nat_net_ops);
 	if (ret &lt; 0) {
 		nf_ct_extend_unregister(&amp;nat_extend);
+		kvfree(nf_nat_bysource);
 		return ret;
 	}
 </pre><hr><pre>commit 5b0bb12c58ac7d22e05b5bfdaa30a116c8c32e32
Author: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
Date:   Mon Dec 21 19:27:31 2020 +0800

    net/mlx5e: Fix memleak in mlx5e_create_l2_table_groups
    
    When mlx5_create_flow_group() fails, ft-&gt;g should be
    freed just like when kvzalloc() fails. The caller of
    mlx5e_create_l2_table_groups() does not catch this
    issue on failure, which leads to memleak.
    
    Fixes: 33cfaaa8f36f ("net/mlx5e: Split the main flow steering table")
    Signed-off-by: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
    Reviewed-by: Leon Romanovsky &lt;leonro@nvidia.com&gt;
    Signed-off-by: Saeed Mahameed &lt;saeedm@nvidia.com&gt;

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c b/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
index 44a2dfbc3853..e02e5895703d 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
@@ -1392,6 +1392,7 @@ static int mlx5e_create_l2_table_groups(struct mlx5e_l2_table *l2_table)
 	ft-&gt;g[ft-&gt;num_groups] = NULL;
 	mlx5e_destroy_groups(ft);
 	kvfree(in);
+	kfree(ft-&gt;g);
 
 	return err;
 }</pre><hr><pre>commit 7a6eb072a9548492ead086f3e820e9aac71c7138
Author: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
Date:   Mon Dec 28 16:48:40 2020 +0800

    net/mlx5e: Fix two double free cases
    
    mlx5e_create_ttc_table_groups() frees ft-&gt;g on failure of
    kvzalloc(), but such failure will be caught by its caller
    in mlx5e_create_ttc_table() and ft-&gt;g will be freed again
    in mlx5e_destroy_flow_table(). The same issue also occurs
    in mlx5e_create_ttc_table_groups(). Set ft-&gt;g to NULL after
    kfree() to avoid double free.
    
    Fixes: 7b3722fa9ef6 ("net/mlx5e: Support RSS for GRE tunneled packets")
    Fixes: 33cfaaa8f36f ("net/mlx5e: Split the main flow steering table")
    Signed-off-by: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
    Reviewed-by: Leon Romanovsky &lt;leonro@nvidia.com&gt;
    Signed-off-by: Saeed Mahameed &lt;saeedm@nvidia.com&gt;

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c b/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
index fa8149f6eb08..44a2dfbc3853 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
@@ -942,6 +942,7 @@ static int mlx5e_create_ttc_table_groups(struct mlx5e_ttc_table *ttc,
 	in = kvzalloc(inlen, GFP_KERNEL);
 	if (!in) {
 		kfree(ft-&gt;g);
+		ft-&gt;g = NULL;
 		return -ENOMEM;
 	}
 
@@ -1087,6 +1088,7 @@ static int mlx5e_create_inner_ttc_table_groups(struct mlx5e_ttc_table *ttc)
 	in = kvzalloc(inlen, GFP_KERNEL);
 	if (!in) {
 		kfree(ft-&gt;g);
+		ft-&gt;g = NULL;
 		return -ENOMEM;
 	}
 </pre><hr><pre>commit a306aba9c8d869b1fdfc8ad9237f1ed718ea55e6
Author: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
Date:   Sat Dec 26 15:42:48 2020 +0800

    RDMA/usnic: Fix memleak in find_free_vf_and_create_qp_grp
    
    If usnic_ib_qp_grp_create() fails at the first call, dev_list
    will not be freed on error, which leads to memleak.
    
    Fixes: e3cf00d0a87f ("IB/usnic: Add Cisco VIC low-level hardware driver")
    Link: https://lore.kernel.org/r/20201226074248.2893-1-dinghao.liu@zju.edu.cn
    Signed-off-by: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
    Reviewed-by: Leon Romanovsky &lt;leonro@nvidia.com&gt;
    Signed-off-by: Jason Gunthorpe &lt;jgg@nvidia.com&gt;

diff --git a/drivers/infiniband/hw/usnic/usnic_ib_verbs.c b/drivers/infiniband/hw/usnic/usnic_ib_verbs.c
index 38a37770c016..3705c6b8b223 100644
--- a/drivers/infiniband/hw/usnic/usnic_ib_verbs.c
+++ b/drivers/infiniband/hw/usnic/usnic_ib_verbs.c
@@ -214,6 +214,7 @@ find_free_vf_and_create_qp_grp(struct usnic_ib_dev *us_ibdev,
 
 		}
 		usnic_uiom_free_dev_list(dev_list);
+		dev_list = NULL;
 	}
 
 	/* Try to find resources on an unused vf */
@@ -239,6 +240,8 @@ find_free_vf_and_create_qp_grp(struct usnic_ib_dev *us_ibdev,
 qp_grp_check:
 	if (IS_ERR_OR_NULL(qp_grp)) {
 		usnic_err("Failed to allocate qp_grp\n");
+		if (usnic_ib_share_vf)
+			usnic_uiom_free_dev_list(dev_list);
 		return ERR_PTR(qp_grp ? PTR_ERR(qp_grp) : -ENOMEM);
 	}
 	return qp_grp;</pre><hr><pre>commit 71f8e707557b9bc25dc90a59a752528d4e7c1cbf
Author: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
Date:   Sat Jan 2 13:47:55 2021 +0800

    Bluetooth: hci_qca: Fix memleak in qca_controller_memdump
    
    When __le32_to_cpu() fails, qca_memdump should be freed
    just like when vmalloc() fails.
    
    Fixes: d841502c79e3f ("Bluetooth: hci_qca: Collect controller memory dump during SSR")
    Signed-off-by: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
    Signed-off-by: Marcel Holtmann &lt;marcel@holtmann.org&gt;

diff --git a/drivers/bluetooth/hci_qca.c b/drivers/bluetooth/hci_qca.c
index 4a963682c702..5dbcb7c42b80 100644
--- a/drivers/bluetooth/hci_qca.c
+++ b/drivers/bluetooth/hci_qca.c
@@ -1024,7 +1024,9 @@ static void qca_controller_memdump(struct work_struct *work)
 			dump_size = __le32_to_cpu(dump-&gt;dump_size);
 			if (!(dump_size)) {
 				bt_dev_err(hu-&gt;hdev, "Rx invalid memdump size");
+				kfree(qca_memdump);
 				kfree_skb(skb);
+				qca-&gt;qca_memdump = NULL;
 				mutex_unlock(&amp;qca-&gt;hci_memdump_lock);
 				return;
 			}</pre><hr><pre>commit 3b01d7ea4dae907d34fa0eeb3f17bacd714c6d0c
Author: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
Date:   Sat Dec 26 14:15:03 2020 +0800

    scsi: scsi_debug: Fix memleak in scsi_debug_init()
    
    When sdeb_zbc_model does not match BLK_ZONED_NONE, BLK_ZONED_HA or
    BLK_ZONED_HM, we should free sdebug_q_arr to prevent memleak. Also there is
    no need to execute sdebug_erase_store() on failure of sdeb_zbc_model_str().
    
    Link: https://lore.kernel.org/r/20201226061503.20050-1-dinghao.liu@zju.edu.cn
    Acked-by: Douglas Gilbert &lt;dgilbert@interlog.com&gt;
    Signed-off-by: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
    Signed-off-by: Martin K. Petersen &lt;martin.petersen@oracle.com&gt;

diff --git a/drivers/scsi/scsi_debug.c b/drivers/scsi/scsi_debug.c
index 24c0f7ec0351..4a08c450b756 100644
--- a/drivers/scsi/scsi_debug.c
+++ b/drivers/scsi/scsi_debug.c
@@ -6740,7 +6740,7 @@ static int __init scsi_debug_init(void)
 		k = sdeb_zbc_model_str(sdeb_zbc_model_s);
 		if (k &lt; 0) {
 			ret = k;
-			goto free_vm;
+			goto free_q_arr;
 		}
 		sdeb_zbc_model = k;
 		switch (sdeb_zbc_model) {
@@ -6753,7 +6753,8 @@ static int __init scsi_debug_init(void)
 			break;
 		default:
 			pr_err("Invalid ZBC model\n");
-			return -EINVAL;
+			ret = -EINVAL;
+			goto free_q_arr;
 		}
 	}
 	if (sdeb_zbc_model != BLK_ZONED_NONE) {</pre><hr><pre>commit ff2b46d7cff80d27d82f7f3252711f4ca1666129
Author: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
Date:   Tue Jan 5 13:18:37 2021 +0800

    iommu/intel: Fix memleak in intel_irq_remapping_alloc
    
    When irq_domain_get_irq_data() or irqd_cfg() fails
    at i == 0, data allocated by kzalloc() has not been
    freed before returning, which leads to memleak.
    
    Fixes: b106ee63abcc ("irq_remapping/vt-d: Enhance Intel IR driver to support hierarchical irqdomains")
    Signed-off-by: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
    Acked-by: Lu Baolu &lt;baolu.lu@linux.intel.com&gt;
    Link: https://lore.kernel.org/r/20210105051837.32118-1-dinghao.liu@zju.edu.cn
    Signed-off-by: Will Deacon &lt;will@kernel.org&gt;

diff --git a/drivers/iommu/intel/irq_remapping.c b/drivers/iommu/intel/irq_remapping.c
index aeffda92b10b..685200a5cff0 100644
--- a/drivers/iommu/intel/irq_remapping.c
+++ b/drivers/iommu/intel/irq_remapping.c
@@ -1353,6 +1353,8 @@ static int intel_irq_remapping_alloc(struct irq_domain *domain,
 		irq_data = irq_domain_get_irq_data(domain, virq + i);
 		irq_cfg = irqd_cfg(irq_data);
 		if (!irq_data || !irq_cfg) {
+			if (!i)
+				kfree(data);
 			ret = -EINVAL;
 			goto out_free_data;
 		}</pre><hr><pre>commit b000700d6db50c933ce8b661154e26cf4ad06dba
Author: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
Date:   Sat Dec 26 15:27:14 2020 +0800

    habanalabs: Fix memleak in hl_device_reset
    
    When kzalloc() fails, we should execute hl_mmu_fini()
    to release the MMU module. It's the same when
    hl_ctx_init() fails.
    
    Signed-off-by: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
    Reviewed-by: Oded Gabbay &lt;ogabbay@kernel.org&gt;
    Signed-off-by: Oded Gabbay &lt;ogabbay@kernel.org&gt;

diff --git a/drivers/misc/habanalabs/common/device.c b/drivers/misc/habanalabs/common/device.c
index 0749c92cbcf6..1456eabf9601 100644
--- a/drivers/misc/habanalabs/common/device.c
+++ b/drivers/misc/habanalabs/common/device.c
@@ -1092,6 +1092,7 @@ int hl_device_reset(struct hl_device *hdev, bool hard_reset,
 						GFP_KERNEL);
 		if (!hdev-&gt;kernel_ctx) {
 			rc = -ENOMEM;
+			hl_mmu_fini(hdev);
 			goto out_err;
 		}
 
@@ -1103,6 +1104,7 @@ int hl_device_reset(struct hl_device *hdev, bool hard_reset,
 				"failed to init kernel ctx in hard reset\n");
 			kfree(hdev-&gt;kernel_ctx);
 			hdev-&gt;kernel_ctx = NULL;
+			hl_mmu_fini(hdev);
 			goto out_err;
 		}
 	}</pre><hr><pre>commit f31559af97a0eabd467e4719253675b7dccb8a46
Author: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
Date:   Mon Dec 21 20:24:35 2020 +0800

    staging: fwserial: Fix error handling in fwserial_create
    
    When fw_core_add_address_handler() fails, we need to destroy
    the port by tty_port_destroy(). Also we need to unregister
    the address handler by fw_core_remove_address_handler() on
    failure.
    
    Signed-off-by: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
    Link: https://lore.kernel.org/r/20201221122437.10274-1-dinghao.liu@zju.edu.cn
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/fwserial/fwserial.c b/drivers/staging/fwserial/fwserial.c
index db83d34cd677..c368082aae1a 100644
--- a/drivers/staging/fwserial/fwserial.c
+++ b/drivers/staging/fwserial/fwserial.c
@@ -2189,6 +2189,7 @@ static int fwserial_create(struct fw_unit *unit)
 		err = fw_core_add_address_handler(&amp;port-&gt;rx_handler,
 						  &amp;fw_high_memory_region);
 		if (err) {
+			tty_port_destroy(&amp;port-&gt;port);
 			kfree(port);
 			goto free_ports;
 		}
@@ -2271,6 +2272,7 @@ static int fwserial_create(struct fw_unit *unit)
 
 free_ports:
 	for (--i; i &gt;= 0; --i) {
+		fw_core_remove_address_handler(&amp;serial-&gt;ports[i]-&gt;rx_handler);
 		tty_port_destroy(&amp;serial-&gt;ports[i]-&gt;port);
 		kfree(serial-&gt;ports[i]);
 	}</pre><hr><pre>commit ec36ae7189acd9a24f417e4814e627034da68922
Author: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
Date:   Sat Dec 26 16:02:56 2020 +0800

    staging: rtl8192u: Add null check in rtl8192_usb_initendpoints
    
    There is an allocation for priv-&gt;rx_urb[16] has no null check,
    which may lead to a null pointer dereference.
    
    Signed-off-by: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
    Link: https://lore.kernel.org/r/20201226080258.6576-1-dinghao.liu@zju.edu.cn
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/rtl8192u/r8192U_core.c b/drivers/staging/rtl8192u/r8192U_core.c
index 93676af98629..9fc4adc83d77 100644
--- a/drivers/staging/rtl8192u/r8192U_core.c
+++ b/drivers/staging/rtl8192u/r8192U_core.c
@@ -1608,6 +1608,8 @@ static short rtl8192_usb_initendpoints(struct net_device *dev)
 		void *oldaddr, *newaddr;
 
 		priv-&gt;rx_urb[16] = usb_alloc_urb(0, GFP_KERNEL);
+		if (!priv-&gt;rx_urb[16])
+			return -ENOMEM;
 		priv-&gt;oldaddr = kmalloc(16, GFP_KERNEL);
 		if (!priv-&gt;oldaddr)
 			return -ENOMEM;</pre>
    <div class="pagination">
        <a href='6_23.html'>&lt;&lt;Prev</a><a href='6.html'>1</a><a href='6_2.html'>2</a><a href='6_3.html'>3</a><a href='6_4.html'>4</a><a href='6_5.html'>5</a><a href='6_6.html'>6</a><a href='6_7.html'>7</a><a href='6_8.html'>8</a><a href='6_9.html'>9</a><a href='6_10.html'>10</a><a href='6_11.html'>11</a><a href='6_12.html'>12</a><a href='6_13.html'>13</a><a href='6_14.html'>14</a><a href='6_15.html'>15</a><a href='6_16.html'>16</a><a href='6_17.html'>17</a><a href='6_18.html'>18</a><a href='6_19.html'>19</a><a href='6_20.html'>20</a><a href='6_21.html'>21</a><a href='6_22.html'>22</a><a href='6_23.html'>23</a><span>[24]</span><a href='6_25.html'>25</a><a href='6_26.html'>26</a><a href='6_27.html'>27</a><a href='6_28.html'>28</a><a href='6_29.html'>29</a><a href='6_30.html'>30</a><a href='6_31.html'>31</a><a href='6_32.html'>32</a><a href='6_33.html'>33</a><a href='6_34.html'>34</a><a href='6_25.html'>Next&gt;&gt;</a>
    <div>
</body>
