<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_7.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><span>[8]</span><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_9.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit c318840fb2a42ce25febc95c4c19357acf1ae5ca
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Dec 30 11:20:44 2020 -0500

    USB: Gadget: dummy-hcd: Fix shift-out-of-bounds bug
    
    The dummy-hcd driver was written under the assumption that all the
    parameters in URBs sent to its root hub would be valid.  With URBs
    sent from userspace via usbfs, that assumption can be violated.
    
    In particular, the driver doesn't fully check the port-feature values
    stored in the wValue entry of Clear-Port-Feature and Set-Port-Feature
    requests.  Values that are too large can cause the driver to perform
    an invalid left shift of more than 32 bits.  Ironically, two of those
    left shifts are unnecessary, because they implement Set-Port-Feature
    requests that hubs are not required to support, according to section
    11.24.2.13 of the USB-2.0 spec.
    
    This patch adds the appropriate checks for the port feature selector
    values and removes the unnecessary feature settings.  It also rejects
    requests to set the TEST feature or to set or clear the INDICATOR and
    C_OVERCURRENT features, as none of these are relevant to dummy-hcd's
    root-hub emulation.
    
    CC: &lt;stable@vger.kernel.org&gt;
    Reported-and-tested-by: syzbot+5925509f78293baa7331@syzkaller.appspotmail.com
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/20201230162044.GA727759@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/gadget/udc/dummy_hcd.c b/drivers/usb/gadget/udc/dummy_hcd.c
index ab5e978b5052..1a953f44183a 100644
--- a/drivers/usb/gadget/udc/dummy_hcd.c
+++ b/drivers/usb/gadget/udc/dummy_hcd.c
@@ -2118,9 +2118,21 @@ static int dummy_hub_control(
 				dum_hcd-&gt;port_status &amp;= ~USB_PORT_STAT_POWER;
 			set_link_state(dum_hcd);
 			break;
-		default:
+		case USB_PORT_FEAT_ENABLE:
+		case USB_PORT_FEAT_C_ENABLE:
+		case USB_PORT_FEAT_C_SUSPEND:
+			/* Not allowed for USB-3 */
+			if (hcd-&gt;speed == HCD_USB3)
+				goto error;
+			fallthrough;
+		case USB_PORT_FEAT_C_CONNECTION:
+		case USB_PORT_FEAT_C_RESET:
 			dum_hcd-&gt;port_status &amp;= ~(1 &lt;&lt; wValue);
 			set_link_state(dum_hcd);
+			break;
+		default:
+		/* Disallow INDICATOR and C_OVER_CURRENT */
+			goto error;
 		}
 		break;
 	case GetHubDescriptor:
@@ -2281,18 +2293,17 @@ static int dummy_hub_control(
 			 */
 			dum_hcd-&gt;re_timeout = jiffies + msecs_to_jiffies(50);
 			fallthrough;
+		case USB_PORT_FEAT_C_CONNECTION:
+		case USB_PORT_FEAT_C_RESET:
+		case USB_PORT_FEAT_C_ENABLE:
+		case USB_PORT_FEAT_C_SUSPEND:
+			/* Not allowed for USB-3, and ignored for USB-2 */
+			if (hcd-&gt;speed == HCD_USB3)
+				goto error;
+			break;
 		default:
-			if (hcd-&gt;speed == HCD_USB3) {
-				if ((dum_hcd-&gt;port_status &amp;
-				     USB_SS_PORT_STAT_POWER) != 0) {
-					dum_hcd-&gt;port_status |= (1 &lt;&lt; wValue);
-				}
-			} else
-				if ((dum_hcd-&gt;port_status &amp;
-				     USB_PORT_STAT_POWER) != 0) {
-					dum_hcd-&gt;port_status |= (1 &lt;&lt; wValue);
-				}
-			set_link_state(dum_hcd);
+		/* Disallow TEST, INDICATOR, and C_OVER_CURRENT */
+			goto error;
 		}
 		break;
 	case GetPortErrorCount:</pre><hr><pre>commit 52abca64fd9410ea6c9a3a74eab25663b403d7da
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Dec 8 21:29:51 2020 -0800

    scsi: block: Do not accept any requests while suspended
    
    blk_queue_enter() accepts BLK_MQ_REQ_PM requests independent of the runtime
    power management state. Now that SCSI domain validation no longer depends
    on this behavior, modify the behavior of blk_queue_enter() as follows:
    
       - Do not accept any requests while suspended.
    
       - Only process power management requests while suspending or resuming.
    
    Submitting BLK_MQ_REQ_PM requests to a device that is runtime suspended
    causes runtime-suspended devices not to resume as they should. The request
    which should cause a runtime resume instead gets issued directly, without
    resuming the device first. Of course the device can't handle it properly,
    the I/O fails, and the device remains suspended.
    
    The problem is fixed by checking that the queue's runtime-PM status isn't
    RPM_SUSPENDED before allowing a request to be issued, and queuing a
    runtime-resume request if it is.  In particular, the inline
    blk_pm_request_resume() routine is renamed blk_pm_resume_queue() and the
    code is unified by merging the surrounding checks into the routine.  If the
    queue isn't set up for runtime PM, or there currently is no restriction on
    allowed requests, the request is allowed.  Likewise if the BLK_MQ_REQ_PM
    flag is set and the status isn't RPM_SUSPENDED.  Otherwise a runtime resume
    is queued and the request is blocked until conditions are more suitable.
    
    [ bvanassche: modified commit message and removed Cc: stable because
      without the previous patches from this series this patch would break
      parallel SCSI domain validation + introduced queue_rpm_status() ]
    
    Link: https://lore.kernel.org/r/20201209052951.16136-9-bvanassche@acm.org
    Cc: Jens Axboe &lt;axboe@kernel.dk&gt;
    Cc: Christoph Hellwig &lt;hch@lst.de&gt;
    Cc: Hannes Reinecke &lt;hare@suse.de&gt;
    Cc: Can Guo &lt;cang@codeaurora.org&gt;
    Cc: Stanley Chu &lt;stanley.chu@mediatek.com&gt;
    Cc: Ming Lei &lt;ming.lei@redhat.com&gt;
    Cc: Rafael J. Wysocki &lt;rafael.j.wysocki@intel.com&gt;
    Reported-and-tested-by: Martin Kepplinger &lt;martin.kepplinger@puri.sm&gt;
    Reviewed-by: Hannes Reinecke &lt;hare@suse.de&gt;
    Reviewed-by: Can Guo &lt;cang@codeaurora.org&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Bart Van Assche &lt;bvanassche@acm.org&gt;
    Signed-off-by: Martin K. Petersen &lt;martin.petersen@oracle.com&gt;

diff --git a/block/blk-core.c b/block/blk-core.c
index a00bce9f46d8..2d53e2ff48ff 100644
--- a/block/blk-core.c
+++ b/block/blk-core.c
@@ -18,6 +18,7 @@
 #include &lt;linux/bio.h&gt;
 #include &lt;linux/blkdev.h&gt;
 #include &lt;linux/blk-mq.h&gt;
+#include &lt;linux/blk-pm.h&gt;
 #include &lt;linux/highmem.h&gt;
 #include &lt;linux/mm.h&gt;
 #include &lt;linux/pagemap.h&gt;
@@ -440,7 +441,8 @@ int blk_queue_enter(struct request_queue *q, blk_mq_req_flags_t flags)
 			 * responsible for ensuring that that counter is
 			 * globally visible before the queue is unfrozen.
 			 */
-			if (pm || !blk_queue_pm_only(q)) {
+			if ((pm &amp;&amp; queue_rpm_status(q) != RPM_SUSPENDED) ||
+			    !blk_queue_pm_only(q)) {
 				success = true;
 			} else {
 				percpu_ref_put(&amp;q-&gt;q_usage_counter);
@@ -465,8 +467,7 @@ int blk_queue_enter(struct request_queue *q, blk_mq_req_flags_t flags)
 
 		wait_event(q-&gt;mq_freeze_wq,
 			   (!q-&gt;mq_freeze_depth &amp;&amp;
-			    (pm || (blk_pm_request_resume(q),
-				    !blk_queue_pm_only(q)))) ||
+			    blk_pm_resume_queue(pm, q)) ||
 			   blk_queue_dying(q));
 		if (blk_queue_dying(q))
 			return -ENODEV;
diff --git a/block/blk-pm.h b/block/blk-pm.h
index ea5507d23e75..a2283cc9f716 100644
--- a/block/blk-pm.h
+++ b/block/blk-pm.h
@@ -6,11 +6,14 @@
 #include &lt;linux/pm_runtime.h&gt;
 
 #ifdef CONFIG_PM
-static inline void blk_pm_request_resume(struct request_queue *q)
+static inline int blk_pm_resume_queue(const bool pm, struct request_queue *q)
 {
-	if (q-&gt;dev &amp;&amp; (q-&gt;rpm_status == RPM_SUSPENDED ||
-		       q-&gt;rpm_status == RPM_SUSPENDING))
-		pm_request_resume(q-&gt;dev);
+	if (!q-&gt;dev || !blk_queue_pm_only(q))
+		return 1;	/* Nothing to do */
+	if (pm &amp;&amp; q-&gt;rpm_status != RPM_SUSPENDED)
+		return 1;	/* Request allowed */
+	pm_request_resume(q-&gt;dev);
+	return 0;
 }
 
 static inline void blk_pm_mark_last_busy(struct request *rq)
@@ -44,8 +47,9 @@ static inline void blk_pm_put_request(struct request *rq)
 		--rq-&gt;q-&gt;nr_pending;
 }
 #else
-static inline void blk_pm_request_resume(struct request_queue *q)
+static inline int blk_pm_resume_queue(const bool pm, struct request_queue *q)
 {
+	return 1;
 }
 
 static inline void blk_pm_mark_last_busy(struct request *rq)
diff --git a/include/linux/blkdev.h b/include/linux/blkdev.h
index 7d4b746f7e6a..2b6fc3fb3a99 100644
--- a/include/linux/blkdev.h
+++ b/include/linux/blkdev.h
@@ -692,6 +692,18 @@ static inline bool queue_is_mq(struct request_queue *q)
 	return q-&gt;mq_ops;
 }
 
+#ifdef CONFIG_PM
+static inline enum rpm_status queue_rpm_status(struct request_queue *q)
+{
+	return q-&gt;rpm_status;
+}
+#else
+static inline enum rpm_status queue_rpm_status(struct request_queue *q)
+{
+	return RPM_ACTIVE;
+}
+#endif
+
 static inline enum blk_zoned_model
 blk_queue_zoned_model(struct request_queue *q)
 {</pre><hr><pre>commit b175d273d4e4100b66e68f0675fef7a3c07a7957
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Dec 8 11:30:42 2020 -0500

    USB: legotower: fix logical error in recent commit
    
    Commit d9f0d82f06c6 ("USB: legousbtower: use usb_control_msg_recv()")
    contained an elementary logical error.  The check of the return code
    from the new usb_control_msg_recv() function was inverted.
    
    Reported-and-tested-by: syzbot+9be25235b7a69b24d117@syzkaller.appspotmail.com
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/20201208163042.GD1298255@rowland.harvard.edu
    Fixes: d9f0d82f06c6 ("USB: legousbtower: use usb_control_msg_recv()")
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/misc/legousbtower.c b/drivers/usb/misc/legousbtower.c
index ba655b4af4fc..1c9e09138c10 100644
--- a/drivers/usb/misc/legousbtower.c
+++ b/drivers/usb/misc/legousbtower.c
@@ -797,7 +797,7 @@ static int tower_probe(struct usb_interface *interface, const struct usb_device_
 				      &amp;get_version_reply,
 				      sizeof(get_version_reply),
 				      1000, GFP_KERNEL);
-	if (!result) {
+	if (result) {
 		dev_err(idev, "get version request failed: %d\n", result);
 		retval = result;
 		goto error;</pre><hr><pre>commit e469d0b09a19496e1972a20974bbf55b728151eb
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Dec 2 18:20:04 2020 +0100

    media: gspca: Fix memory leak in probe
    
    The gspca driver leaks memory when a probe fails.  gspca_dev_probe2()
    calls v4l2_device_register(), which takes a reference to the
    underlying device node (in this case, a USB interface).  But the
    failure pathway neglects to call v4l2_device_unregister(), the routine
    responsible for dropping this reference.  Consequently the memory for
    the USB interface and its device never gets released.
    
    This patch adds the missing function call.
    
    Reported-and-tested-by: syzbot+44e64397bd81d5e84cba@syzkaller.appspotmail.com
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Hans Verkuil &lt;hverkuil-cisco@xs4all.nl&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab+huawei@kernel.org&gt;

diff --git a/drivers/media/usb/gspca/gspca.c b/drivers/media/usb/gspca/gspca.c
index c295f642d352..158c8e28ed2c 100644
--- a/drivers/media/usb/gspca/gspca.c
+++ b/drivers/media/usb/gspca/gspca.c
@@ -1575,6 +1575,7 @@ int gspca_dev_probe2(struct usb_interface *intf,
 		input_unregister_device(gspca_dev-&gt;input_dev);
 #endif
 	v4l2_ctrl_handler_free(gspca_dev-&gt;vdev.ctrl_handler);
+	v4l2_device_unregister(&amp;gspca_dev-&gt;v4l2_dev);
 	kfree(gspca_dev-&gt;usb_buf);
 	kfree(gspca_dev);
 	return ret;</pre><hr><pre>commit f3bc432aa8a7a2bfe9ebb432502be5c5d979d7fe
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Nov 19 12:02:28 2020 -0500

    USB: core: Change %pK for __user pointers to %px
    
    Commit 2f964780c03b ("USB: core: replace %p with %pK") used the %pK
    format specifier for a bunch of __user pointers.  But as the 'K' in
    the specifier indicates, it is meant for kernel pointers.  The reason
    for the %pK specifier is to avoid leaks of kernel addresses, but when
    the pointer is to an address in userspace the security implications
    are minimal.  In particular, no kernel information is leaked.
    
    This patch changes the __user %pK specifiers (used in a bunch of
    debugging output lines) to %px, which will always print the actual
    address with no mangling.  (Notably, there is no printk format
    specifier particularly intended for __user pointers.)
    
    Fixes: 2f964780c03b ("USB: core: replace %p with %pK")
    CC: Vamsi Krishna Samavedam &lt;vskrishn@codeaurora.org&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/20201119170228.GB576844@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index e96a858a1218..533236366a03 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -482,11 +482,11 @@ static void snoop_urb(struct usb_device *udev,
 
 	if (userurb) {		/* Async */
 		if (when == SUBMIT)
-			dev_info(&amp;udev-&gt;dev, "userurb %pK, ep%d %s-%s, "
+			dev_info(&amp;udev-&gt;dev, "userurb %px, ep%d %s-%s, "
 					"length %u\n",
 					userurb, ep, t, d, length);
 		else
-			dev_info(&amp;udev-&gt;dev, "userurb %pK, ep%d %s-%s, "
+			dev_info(&amp;udev-&gt;dev, "userurb %px, ep%d %s-%s, "
 					"actual_length %u status %d\n",
 					userurb, ep, t, d, length,
 					timeout_or_status);
@@ -1997,7 +1997,7 @@ static int proc_reapurb(struct usb_dev_state *ps, void __user *arg)
 	if (as) {
 		int retval;
 
-		snoop(&amp;ps-&gt;dev-&gt;dev, "reap %pK\n", as-&gt;userurb);
+		snoop(&amp;ps-&gt;dev-&gt;dev, "reap %px\n", as-&gt;userurb);
 		retval = processcompl(as, (void __user * __user *)arg);
 		free_async(as);
 		return retval;
@@ -2014,7 +2014,7 @@ static int proc_reapurbnonblock(struct usb_dev_state *ps, void __user *arg)
 
 	as = async_getcompleted(ps);
 	if (as) {
-		snoop(&amp;ps-&gt;dev-&gt;dev, "reap %pK\n", as-&gt;userurb);
+		snoop(&amp;ps-&gt;dev-&gt;dev, "reap %px\n", as-&gt;userurb);
 		retval = processcompl(as, (void __user * __user *)arg);
 		free_async(as);
 	} else {
@@ -2142,7 +2142,7 @@ static int proc_reapurb_compat(struct usb_dev_state *ps, void __user *arg)
 	if (as) {
 		int retval;
 
-		snoop(&amp;ps-&gt;dev-&gt;dev, "reap %pK\n", as-&gt;userurb);
+		snoop(&amp;ps-&gt;dev-&gt;dev, "reap %px\n", as-&gt;userurb);
 		retval = processcompl_compat(as, (void __user * __user *)arg);
 		free_async(as);
 		return retval;
@@ -2159,7 +2159,7 @@ static int proc_reapurbnonblock_compat(struct usb_dev_state *ps, void __user *ar
 
 	as = async_getcompleted(ps);
 	if (as) {
-		snoop(&amp;ps-&gt;dev-&gt;dev, "reap %pK\n", as-&gt;userurb);
+		snoop(&amp;ps-&gt;dev-&gt;dev, "reap %px\n", as-&gt;userurb);
 		retval = processcompl_compat(as, (void __user * __user *)arg);
 		free_async(as);
 	} else {
@@ -2624,7 +2624,7 @@ static long usbdev_do_ioctl(struct file *file, unsigned int cmd,
 #endif
 
 	case USBDEVFS_DISCARDURB:
-		snoop(&amp;dev-&gt;dev, "%s: DISCARDURB %pK\n", __func__, p);
+		snoop(&amp;dev-&gt;dev, "%s: DISCARDURB %px\n", __func__, p);
 		ret = proc_unlinkurb(ps, p);
 		break;
 </pre><hr><pre>commit 184eead057cc7e803558269babc1f2cfb9113ad1
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Nov 19 12:00:40 2020 -0500

    USB: core: Fix regression in Hercules audio card
    
    Commit 3e4f8e21c4f2 ("USB: core: fix check for duplicate endpoints")
    aimed to make the USB stack more reliable by detecting and skipping
    over endpoints that are duplicated between interfaces.  This caused a
    regression for a Hercules audio card (reported as Bugzilla #208357),
    which contains such non-compliant duplications.  Although the
    duplications are harmless, skipping the valid endpoints prevented the
    device from working.
    
    This patch fixes the regression by adding ENDPOINT_IGNORE quirks for
    the Hercules card, telling the kernel to ignore the invalid duplicate
    endpoints and thereby allowing the valid endpoints to be used as
    intended.
    
    Fixes: 3e4f8e21c4f2 ("USB: core: fix check for duplicate endpoints")
    CC: &lt;stable@vger.kernel.org&gt;
    Reported-by: Alexander Chalikiopoulos &lt;bugzilla.kernel.org@mrtoasted.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/20201119170040.GA576844@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c
index f536ea9fe945..fad31ccd1fa8 100644
--- a/drivers/usb/core/quirks.c
+++ b/drivers/usb/core/quirks.c
@@ -348,6 +348,10 @@ static const struct usb_device_id usb_quirk_list[] = {
 	/* Guillemot Webcam Hercules Dualpix Exchange*/
 	{ USB_DEVICE(0x06f8, 0x3005), .driver_info = USB_QUIRK_RESET_RESUME },
 
+	/* Guillemot Hercules DJ Console audio card (BZ 208357) */
+	{ USB_DEVICE(0x06f8, 0xb000), .driver_info =
+			USB_QUIRK_ENDPOINT_IGNORE },
+
 	/* Midiman M-Audio Keystation 88es */
 	{ USB_DEVICE(0x0763, 0x0192), .driver_info = USB_QUIRK_RESET_RESUME },
 
@@ -525,6 +529,8 @@ static const struct usb_device_id usb_amd_resume_quirk_list[] = {
  * Matched for devices with USB_QUIRK_ENDPOINT_IGNORE.
  */
 static const struct usb_device_id usb_endpoint_ignore[] = {
+	{ USB_DEVICE_INTERFACE_NUMBER(0x06f8, 0xb000, 5), .driver_info = 0x01 },
+	{ USB_DEVICE_INTERFACE_NUMBER(0x06f8, 0xb000, 5), .driver_info = 0x81 },
 	{ USB_DEVICE_INTERFACE_NUMBER(0x0926, 0x0202, 1), .driver_info = 0x85 },
 	{ USB_DEVICE_INTERFACE_NUMBER(0x0926, 0x0208, 1), .driver_info = 0x85 },
 	{ }</pre><hr><pre>commit afaa2e745a246c5ab95103a65b1ed00101e1bc63
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Nov 2 09:58:21 2020 -0500

    USB: Add NO_LPM quirk for Kingston flash drive
    
    In Bugzilla #208257, Julien Humbert reports that a 32-GB Kingston
    flash drive spontaneously disconnects and reconnects, over and over.
    Testing revealed that disabling Link Power Management for the drive
    fixed the problem.
    
    This patch adds a quirk entry for that drive to turn off LPM permanently.
    
    CC: Hans de Goede &lt;jwrdegoede@fedoraproject.org&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Reported-and-tested-by: Julien Humbert &lt;julroy67@gmail.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/20201102145821.GA1478741@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c
index 10574fa3f927..a1e3a037a289 100644
--- a/drivers/usb/core/quirks.c
+++ b/drivers/usb/core/quirks.c
@@ -378,6 +378,9 @@ static const struct usb_device_id usb_quirk_list[] = {
 	{ USB_DEVICE(0x0926, 0x3333), .driver_info =
 			USB_QUIRK_CONFIG_INTF_STRINGS },
 
+	/* Kingston DataTraveler 3.0 */
+	{ USB_DEVICE(0x0951, 0x1666), .driver_info = USB_QUIRK_NO_LPM },
+
 	/* X-Rite/Gretag-Macbeth Eye-One Pro display colorimeter */
 	{ USB_DEVICE(0x0971, 0x2000), .driver_info = USB_QUIRK_NO_SET_INTF },
 </pre><hr><pre>commit 9270e1a744f8ed953009b0e94b26ed0912d9ec1c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Oct 3 21:40:22 2020 -0400

    tools: memory-model: Document that the LKMM can easily miss control dependencies
    
    Add a small section to the litmus-tests.txt documentation file for
    the Linux Kernel Memory Model explaining that the memory model often
    fails to recognize certain control dependencies.
    
    Suggested-by: Akira Yokosawa &lt;akiyks@gmail.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reviewed-by: Joel Fernandes (Google) &lt;joel@joelfernandes.org&gt;
    Signed-off-by: Paul E. McKenney &lt;paulmck@kernel.org&gt;

diff --git a/tools/memory-model/Documentation/litmus-tests.txt b/tools/memory-model/Documentation/litmus-tests.txt
index 2f840dcd15cf..8a9d5d2787f9 100644
--- a/tools/memory-model/Documentation/litmus-tests.txt
+++ b/tools/memory-model/Documentation/litmus-tests.txt
@@ -946,6 +946,23 @@ Limitations of the Linux-kernel memory model (LKMM) include:
 	carrying a dependency, then the compiler can break that dependency
 	by substituting a constant of that value.
 
+	Conversely, LKMM sometimes doesn't recognize that a particular
+	optimization is not allowed, and as a result, thinks that a
+	dependency is not present (because the optimization would break it).
+	The memory model misses some pretty obvious control dependencies
+	because of this limitation.  A simple example is:
+
+		r1 = READ_ONCE(x);
+		if (r1 == 0)
+			smp_mb();
+		WRITE_ONCE(y, 1);
+
+	There is a control dependency from the READ_ONCE to the WRITE_ONCE,
+	even when r1 is nonzero, but LKMM doesn't realize this and thinks
+	that the write may execute before the read if r1 != 0.  (Yes, that
+	doesn't make sense if you think about it, but the memory model's
+	intelligence is limited.)
+
 2.	Multiple access sizes for a single variable are not supported,
 	and neither are misaligned or partially overlapping accesses.
 </pre><hr><pre>commit fb6f076d543414cec709401ec65e5f8e6985d77a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Sep 28 11:22:17 2020 -0400

    USB: hub: Add Kconfig option to reduce number of port initialization retries
    
    Description based on one by Yasushi Asano:
    
    According to 6.7.22 A-UUT “Device No Response” for connection timeout
    of USB OTG and EH automated compliance plan v1.2, enumeration failure
    has to be detected within 30 seconds.  However, the old and new
    enumeration schemes each make a total of 12 attempts, and each attempt
    can take 5 seconds to time out, so the PET test fails.
    
    This patch adds a new Kconfig option (CONFIG_USB_FEW_INIT_RETRIES);
    when the option is set all the initialization retry loops except the
    outermost are reduced to a single iteration.  This reduces the total
    number of attempts to four, allowing Linux hosts to pass the PET test.
    
    The new option is disabled by default to preserve the existing
    behavior.  The reduced number of retries may fail to initialize a few
    devices that currently do work, but for the most part there should be
    no change.  And in cases where the initialization does fail, it will
    fail much more quickly.
    
    Reported-and-tested-by: yasushi asano &lt;yazzep@gmail.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/20200928152217.GB134701@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/Kconfig b/drivers/usb/core/Kconfig
index dfacc478a8fc..351ede4b5de2 100644
--- a/drivers/usb/core/Kconfig
+++ b/drivers/usb/core/Kconfig
@@ -32,6 +32,20 @@ config USB_DEFAULT_PERSIST
 	  If you have any questions about this, say Y here, only say N
 	  if you know exactly what you are doing.
 
+config USB_FEW_INIT_RETRIES
+	bool "Limit USB device initialization to only a few retries"
+	help
+	  When a new USB device is detected, the kernel tries very hard
+	  to initialize and enumerate it, with lots of nested retry loops.
+	  This almost always works, but when it fails it can take a long time.
+	  This option tells the kernel to make only a few retry attempts,
+	  so that the total time required for a failed initialization is
+	  no more than 30 seconds (as required by the USB OTG spec).
+
+	  Say N here unless you require new-device enumeration failure to
+	  occur within 30 seconds (as might be needed in an embedded
+	  application).
+
 config USB_DYNAMIC_MINORS
 	bool "Dynamic USB minor allocation"
 	help
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 70eaf4ab236f..17202b2ee063 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2705,10 +2705,20 @@ static unsigned hub_is_wusb(struct usb_hub *hub)
 }
 
 
+#ifdef CONFIG_USB_FEW_INIT_RETRIES
+#define PORT_RESET_TRIES	2
+#define SET_ADDRESS_TRIES	1
+#define GET_DESCRIPTOR_TRIES	1
+#define GET_MAXPACKET0_TRIES	1
+#define PORT_INIT_TRIES		4
+
+#else
 #define PORT_RESET_TRIES	5
 #define SET_ADDRESS_TRIES	2
 #define GET_DESCRIPTOR_TRIES	2
+#define GET_MAXPACKET0_TRIES	3
 #define PORT_INIT_TRIES		4
+#endif	/* CONFIG_USB_FEW_INIT_RETRIES */
 
 #define HUB_ROOT_RESET_TIME	60	/* times are in msec */
 #define HUB_SHORT_RESET_TIME	10
@@ -4691,7 +4701,8 @@ hub_port_init(struct usb_hub *hub, struct usb_device *udev, int port1,
 			 * 255 is for WUSB devices, we actually need to use
 			 * 512 (WUSB1.0[4.8.1]).
 			 */
-			for (operations = 0; operations &lt; 3; ++operations) {
+			for (operations = 0; operations &lt; GET_MAXPACKET0_TRIES;
+					++operations) {
 				buf-&gt;bMaxPacketSize0 = 0;
 				r = usb_control_msg(udev, usb_rcvaddr0pipe(),
 					USB_REQ_GET_DESCRIPTOR, USB_DIR_IN,</pre><hr><pre>commit 19502e6911e4ef4a036344eed36274bb18225033
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Sep 28 11:20:50 2020 -0400

    USB: hub: Clean up use of port initialization schemes and retries
    
    The SET_CONFIG_TRIES macro in hub.c is badly named; it controls the
    number of port-initialization retry attempts rather than the number of
    Set-Configuration attempts.  Furthermore, the USE_NEW_SCHEME macro and
    use_new_scheme() function are written in a very confusing manner,
    making it almost impossible to figure out exactly what they do or
    check that they are correct.
    
    This patch renames SET_CONFIG_TRIES to PORT_INIT_TRIES, removes
    USE_NEW_SCHEME entirely, and rewrites use_new_scheme() to be much more
    transparent, with added comments explaining how it works.  The patch
    also pulls the single call site of use_new_scheme() out from the
    Get-Descriptor retry loop (where it returns the same value each time)
    and renames the local variable used to store the result.
    
    The overall effect is a minor cleanup.  However, there is one
    functional change: If the "use_both_schemes" module parameter isn't
    set (by default it is set), the existing code does only two retry
    iterations.  After this patch it will always perform four, regardless
    of the parameter's value.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/20200928152050.GA134701@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 5b768b80d1ee..70eaf4ab236f 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2708,8 +2708,7 @@ static unsigned hub_is_wusb(struct usb_hub *hub)
 #define PORT_RESET_TRIES	5
 #define SET_ADDRESS_TRIES	2
 #define GET_DESCRIPTOR_TRIES	2
-#define SET_CONFIG_TRIES	(2 * (use_both_schemes + 1))
-#define USE_NEW_SCHEME(i, scheme)	((i) / 2 == (int)(scheme))
+#define PORT_INIT_TRIES		4
 
 #define HUB_ROOT_RESET_TIME	60	/* times are in msec */
 #define HUB_SHORT_RESET_TIME	10
@@ -2717,23 +2716,31 @@ static unsigned hub_is_wusb(struct usb_hub *hub)
 #define HUB_LONG_RESET_TIME	200
 #define HUB_RESET_TIMEOUT	800
 
-/*
- * "New scheme" enumeration causes an extra state transition to be
- * exposed to an xhci host and causes USB3 devices to receive control
- * commands in the default state.  This has been seen to cause
- * enumeration failures, so disable this enumeration scheme for USB3
- * devices.
- */
 static bool use_new_scheme(struct usb_device *udev, int retry,
 			   struct usb_port *port_dev)
 {
 	int old_scheme_first_port =
-		port_dev-&gt;quirks &amp; USB_PORT_QUIRK_OLD_SCHEME;
+		(port_dev-&gt;quirks &amp; USB_PORT_QUIRK_OLD_SCHEME) ||
+		old_scheme_first;
 
+	/*
+	 * "New scheme" enumeration causes an extra state transition to be
+	 * exposed to an xhci host and causes USB3 devices to receive control
+	 * commands in the default state.  This has been seen to cause
+	 * enumeration failures, so disable this enumeration scheme for USB3
+	 * devices.
+	 */
 	if (udev-&gt;speed &gt;= USB_SPEED_SUPER)
 		return false;
 
-	return USE_NEW_SCHEME(retry, old_scheme_first_port || old_scheme_first);
+	/*
+	 * If use_both_schemes is set, use the first scheme (whichever
+	 * it is) for the larger half of the retries, then use the other
+	 * scheme.  Otherwise, use the first scheme for all the retries.
+	 */
+	if (use_both_schemes &amp;&amp; retry &gt;= (PORT_INIT_TRIES + 1) / 2)
+		return old_scheme_first_port;	/* Second half */
+	return !old_scheme_first_port;		/* First half or all */
 }
 
 /* Is a USB 3.0 port in the Inactive or Compliance Mode state?
@@ -4545,6 +4552,7 @@ hub_port_init(struct usb_hub *hub, struct usb_device *udev, int port1,
 	const char		*speed;
 	int			devnum = udev-&gt;devnum;
 	const char		*driver_name;
+	bool			do_new_scheme;
 
 	/* root hub ports have a slightly longer reset period
 	 * (from USB 2.0 spec, section 7.1.7.5)
@@ -4657,14 +4665,13 @@ hub_port_init(struct usb_hub *hub, struct usb_device *udev, int port1,
 	 * first 8 bytes of the device descriptor to get the ep0 maxpacket
 	 * value.
 	 */
-	for (retries = 0; retries &lt; GET_DESCRIPTOR_TRIES; (++retries, msleep(100))) {
-		bool did_new_scheme = false;
+	do_new_scheme = use_new_scheme(udev, retry_counter, port_dev);
 
-		if (use_new_scheme(udev, retry_counter, port_dev)) {
+	for (retries = 0; retries &lt; GET_DESCRIPTOR_TRIES; (++retries, msleep(100))) {
+		if (do_new_scheme) {
 			struct usb_device_descriptor *buf;
 			int r = 0;
 
-			did_new_scheme = true;
 			retval = hub_enable_device(udev);
 			if (retval &lt; 0) {
 				dev_err(&amp;udev-&gt;dev,
@@ -4773,11 +4780,7 @@ hub_port_init(struct usb_hub *hub, struct usb_device *udev, int port1,
 			 *  - read ep0 maxpacket even for high and low speed,
 			 */
 			msleep(10);
-			/* use_new_scheme() checks the speed which may have
-			 * changed since the initial look so we cache the result
-			 * in did_new_scheme
-			 */
-			if (did_new_scheme)
+			if (do_new_scheme)
 				break;
 		}
 
@@ -5106,7 +5109,7 @@ static void hub_port_connect(struct usb_hub *hub, int port1, u16 portstatus,
 		unit_load = 100;
 
 	status = 0;
-	for (i = 0; i &lt; SET_CONFIG_TRIES; i++) {
+	for (i = 0; i &lt; PORT_INIT_TRIES; i++) {
 
 		/* reallocate for each attempt, since references
 		 * to the previous one can escape in various ways
@@ -5239,7 +5242,7 @@ static void hub_port_connect(struct usb_hub *hub, int port1, u16 portstatus,
 			break;
 
 		/* When halfway through our retry count, power-cycle the port */
-		if (i == (SET_CONFIG_TRIES / 2) - 1) {
+		if (i == (PORT_INIT_TRIES - 1) / 2) {
 			dev_info(&amp;port_dev-&gt;dev, "attempt power cycle\n");
 			usb_hub_set_port_power(hdev, hub, port1, false);
 			msleep(2 * hub_power_on_good_delay(hub));
@@ -5770,7 +5773,7 @@ static int usb_reset_and_verify_device(struct usb_device *udev)
 	bos = udev-&gt;bos;
 	udev-&gt;bos = NULL;
 
-	for (i = 0; i &lt; SET_CONFIG_TRIES; ++i) {
+	for (i = 0; i &lt; PORT_INIT_TRIES; ++i) {
 
 		/* ep0 maxpacket size may change; let the HCD know about it.
 		 * Other endpoints will be handled by re-enumeration. */</pre>
    <div class="pagination">
        <a href='2_7.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><span>[8]</span><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_9.html'>Next&gt;&gt;</a>
    <div>
</body>
