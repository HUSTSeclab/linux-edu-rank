<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_100.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><span>[101]</span><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_102.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 14c04c0f88f228fee1f412be91d6edcb935c78aa
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 24 15:40:19 2007 -0400

    USB: reorganize urb-&gt;status use in ehci-hcd
    
    This patch (as974) reorganizes the way ehci-hcd sets urb-&gt;status.  It
    now keeps the information in a local variable until the last moment.
    
    The patch also simplifies the handling of -EREMOTEIO, since the only
    use of that code is to set the do_status flag.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index a8f5408c161d..794d27e07807 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -139,63 +139,65 @@ qh_refresh (struct ehci_hcd *ehci, struct ehci_qh *qh)
 
 /*-------------------------------------------------------------------------*/
 
-static void qtd_copy_status (
+static int qtd_copy_status (
 	struct ehci_hcd *ehci,
 	struct urb *urb,
 	size_t length,
 	u32 token
 )
 {
+	int	status = -EINPROGRESS;
+
 	/* count IN/OUT bytes, not SETUP (even short packets) */
 	if (likely (QTD_PID (token) != 2))
 		urb-&gt;actual_length += length - QTD_LENGTH (token);
 
 	/* don't modify error codes */
 	if (unlikely(urb-&gt;unlinked))
-		return;
+		return status;
 
 	/* force cleanup after short read; not always an error */
 	if (unlikely (IS_SHORT_READ (token)))
-		urb-&gt;status = -EREMOTEIO;
+		status = -EREMOTEIO;
 
 	/* serious "can't proceed" faults reported by the hardware */
 	if (token &amp; QTD_STS_HALT) {
 		if (token &amp; QTD_STS_BABBLE) {
 			/* FIXME "must" disable babbling device's port too */
-			urb-&gt;status = -EOVERFLOW;
+			status = -EOVERFLOW;
 		} else if (token &amp; QTD_STS_MMF) {
 			/* fs/ls interrupt xfer missed the complete-split */
-			urb-&gt;status = -EPROTO;
+			status = -EPROTO;
 		} else if (token &amp; QTD_STS_DBE) {
-			urb-&gt;status = (QTD_PID (token) == 1) /* IN ? */
+			status = (QTD_PID (token) == 1) /* IN ? */
 				? -ENOSR  /* hc couldn't read data */
 				: -ECOMM; /* hc couldn't write data */
 		} else if (token &amp; QTD_STS_XACT) {
 			/* timeout, bad crc, wrong PID, etc; retried */
 			if (QTD_CERR (token))
-				urb-&gt;status = -EPIPE;
+				status = -EPIPE;
 			else {
 				ehci_dbg (ehci, "devpath %s ep%d%s 3strikes\n",
 					urb-&gt;dev-&gt;devpath,
 					usb_pipeendpoint (urb-&gt;pipe),
 					usb_pipein (urb-&gt;pipe) ? "in" : "out");
-				urb-&gt;status = -EPROTO;
+				status = -EPROTO;
 			}
 		/* CERR nonzero + no errors + halt --&gt; stall */
 		} else if (QTD_CERR (token))
-			urb-&gt;status = -EPIPE;
+			status = -EPIPE;
 		else	/* unknown */
-			urb-&gt;status = -EPROTO;
+			status = -EPROTO;
 
 		ehci_vdbg (ehci,
 			"dev%d ep%d%s qtd token %08x --&gt; status %d\n",
 			usb_pipedevice (urb-&gt;pipe),
 			usb_pipeendpoint (urb-&gt;pipe),
 			usb_pipein (urb-&gt;pipe) ? "in" : "out",
-			token, urb-&gt;status);
+			token, status);
 
 		/* if async CSPLIT failed, try cleaning out the TT buffer */
-		if (urb-&gt;status != -EPIPE
+		if (status != -EPIPE
 				&amp;&amp; urb-&gt;dev-&gt;tt &amp;&amp; !usb_pipeint (urb-&gt;pipe)
 				&amp;&amp; ((token &amp; QTD_STS_MMF) != 0
 					|| QTD_CERR(token) == 0)
@@ -212,10 +214,12 @@ static void qtd_copy_status (
 			usb_hub_tt_clear_buffer (urb-&gt;dev, urb-&gt;pipe);
 		}
 	}
+
+	return status;
 }
 
 static void
-ehci_urb_done (struct ehci_hcd *ehci, struct urb *urb)
+ehci_urb_done(struct ehci_hcd *ehci, struct urb *urb, int status)
 __releases(ehci-&gt;lock)
 __acquires(ehci-&gt;lock)
 {
@@ -231,17 +235,13 @@ __acquires(ehci-&gt;lock)
 		qh_put (qh);
 	}
 
-	spin_lock (&amp;urb-&gt;lock);
 	if (unlikely(urb-&gt;unlinked)) {
 		COUNT(ehci-&gt;stats.unlink);
 	} else {
-		if (likely(urb-&gt;status == -EINPROGRESS ||
-				(urb-&gt;status == -EREMOTEIO &amp;&amp;
-				 !(urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK))))
-			urb-&gt;status = 0;
+		if (likely(status == -EINPROGRESS))
+			status = 0;
 		COUNT(ehci-&gt;stats.complete);
 	}
-	spin_unlock (&amp;urb-&gt;lock);
 
 #ifdef EHCI_URB_TRACE
 	ehci_dbg (ehci,
@@ -249,13 +249,14 @@ __acquires(ehci-&gt;lock)
 		__FUNCTION__, urb-&gt;dev-&gt;devpath, urb,
 		usb_pipeendpoint (urb-&gt;pipe),
 		usb_pipein (urb-&gt;pipe) ? "in" : "out",
-		urb-&gt;status,
+		status,
 		urb-&gt;actual_length, urb-&gt;transfer_buffer_length);
 #endif
 
 	/* complete() can reenter this HCD */
 	usb_hcd_unlink_urb_from_ep(ehci_to_hcd(ehci), urb);
 	spin_unlock (&amp;ehci-&gt;lock);
+	urb-&gt;status = status;
 	usb_hcd_giveback_urb (ehci_to_hcd(ehci), urb);
 	spin_lock (&amp;ehci-&gt;lock);
 }
@@ -276,6 +277,7 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
 	struct ehci_qtd		*last = NULL, *end = qh-&gt;dummy;
 	struct list_head	*entry, *tmp;
+	int			last_status = -EINPROGRESS;
 	int			stopped;
 	unsigned		count = 0;
 	int			do_status = 0;
@@ -304,6 +306,7 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 		struct ehci_qtd	*qtd;
 		struct urb	*urb;
 		u32		token = 0;
+		int		qtd_status;
 
 		qtd = list_entry (entry, struct ehci_qtd, qtd_list);
 		urb = qtd-&gt;urb;
@@ -311,11 +314,12 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 		/* clean up any state from previous QTD ...*/
 		if (last) {
 			if (likely (last-&gt;urb != urb)) {
-				ehci_urb_done (ehci, last-&gt;urb);
+				ehci_urb_done(ehci, last-&gt;urb, last_status);
 				count++;
 			}
 			ehci_qtd_free (ehci, last);
 			last = NULL;
+			last_status = -EINPROGRESS;
 		}
 
 		/* ignore urbs submitted during completions we reported */
@@ -351,13 +355,13 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 			stopped = 1;
 
 			if (unlikely (!HC_IS_RUNNING (ehci_to_hcd(ehci)-&gt;state)))
-				urb-&gt;status = -ESHUTDOWN;
+				last_status = -ESHUTDOWN;
 
 			/* ignore active urbs unless some previous qtd
 			 * for the urb faulted (including short read) or
 			 * its urb was canceled.  we may patch qh or qtds.
 			 */
-			if (likely(urb-&gt;status == -EINPROGRESS &amp;&amp;
+			if (likely(last_status == -EINPROGRESS &amp;&amp;
 					!urb-&gt;unlinked))
 				continue;
 
@@ -386,14 +390,14 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 		}
 
 		/* remove it from the queue */
-		spin_lock (&amp;urb-&gt;lock);
-		qtd_copy_status (ehci, urb, qtd-&gt;length, token);
-		if (unlikely(urb-&gt;status == -EREMOTEIO)) {
+		qtd_status = qtd_copy_status(ehci, urb, qtd-&gt;length, token);
+		if (unlikely(qtd_status == -EREMOTEIO)) {
 			do_status = (!urb-&gt;unlinked &amp;&amp;
 					usb_pipecontrol(urb-&gt;pipe));
-			urb-&gt;status = 0;
+			qtd_status = 0;
 		}
-		spin_unlock (&amp;urb-&gt;lock);
+		if (likely(last_status == -EINPROGRESS))
+			last_status = qtd_status;
 
 		if (stopped &amp;&amp; qtd-&gt;qtd_list.prev != &amp;qh-&gt;qtd_list) {
 			last = list_entry (qtd-&gt;qtd_list.prev,
@@ -406,7 +410,7 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 
 	/* last urb's completion might still need calling */
 	if (likely (last != NULL)) {
-		ehci_urb_done (ehci, last-&gt;urb);
+		ehci_urb_done(ehci, last-&gt;urb, last_status);
 		count++;
 		ehci_qtd_free (ehci, last);
 	}
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 8b267b3fd2bb..80d99bce2b38 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -1627,7 +1627,7 @@ itd_complete (
 
 	/* give urb back to the driver ... can be out-of-order */
 	dev = urb-&gt;dev;
-	ehci_urb_done (ehci, urb);
+	ehci_urb_done(ehci, urb, 0);
 	urb = NULL;
 
 	/* defer stopping schedule; completion can submit */
@@ -2000,7 +2000,7 @@ sitd_complete (
 
 	/* give urb back to the driver */
 	dev = urb-&gt;dev;
-	ehci_urb_done (ehci, urb);
+	ehci_urb_done(ehci, urb, 0);
 	urb = NULL;
 
 	/* defer stopping schedule; completion can submit */</pre><hr><pre>commit 4d2f110c51eec853c50f68cf068888a77551c8d3
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 24 15:40:10 2007 -0400

    USB: reorganize urb-&gt;status use in dummy-hcd
    
    This patch (as973) reorganizes the way dummy-hcd sets urb-&gt;status.  It
    now keeps the information in a local variable until the last moment.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index f2b124cf3206..c1af7bab26f0 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -1026,16 +1026,10 @@ static int dummy_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 	return rc;
 }
 
-static void maybe_set_status (struct urb *urb, int status)
-{
-	spin_lock (&amp;urb-&gt;lock);
-	urb-&gt;status = status;
-	spin_unlock (&amp;urb-&gt;lock);
-}
-
 /* transfer up to a frame's worth; caller must own lock */
 static int
-transfer (struct dummy *dum, struct urb *urb, struct dummy_ep *ep, int limit)
+transfer(struct dummy *dum, struct urb *urb, struct dummy_ep *ep, int limit,
+		int *status)
 {
 	struct dummy_request	*req;
 
@@ -1103,15 +1097,15 @@ transfer (struct dummy *dum, struct urb *urb, struct dummy_ep *ep, int limit)
 		if (is_short) {
 			if (host_len == dev_len) {
 				req-&gt;req.status = 0;
-				maybe_set_status (urb, 0);
+				*status = 0;
 			} else if (to_host) {
 				req-&gt;req.status = 0;
 				if (dev_len &gt; host_len)
-					maybe_set_status (urb, -EOVERFLOW);
+					*status = -EOVERFLOW;
 				else
-					maybe_set_status (urb, 0);
+					*status = 0;
 			} else if (!to_host) {
-				maybe_set_status (urb, 0);
+				*status = 0;
 				if (host_len &gt; dev_len)
 					req-&gt;req.status = -EOVERFLOW;
 				else
@@ -1125,9 +1119,8 @@ transfer (struct dummy *dum, struct urb *urb, struct dummy_ep *ep, int limit)
 				req-&gt;req.status = 0;
 			if (urb-&gt;transfer_buffer_length == urb-&gt;actual_length
 					&amp;&amp; !(urb-&gt;transfer_flags
-						&amp; URB_ZERO_PACKET)) {
-				maybe_set_status (urb, 0);
-			}
+						&amp; URB_ZERO_PACKET))
+				*status = 0;
 		}
 
 		/* device side completion --&gt; continuable */
@@ -1143,7 +1136,7 @@ transfer (struct dummy *dum, struct urb *urb, struct dummy_ep *ep, int limit)
 		}
 
 		/* host side completion --&gt; terminate */
-		if (urb-&gt;status != -EINPROGRESS)
+		if (*status != -EINPROGRESS)
 			break;
 
 		/* rescan to continue with any other queued i/o */
@@ -1254,6 +1247,7 @@ static void dummy_timer (unsigned long _dum)
 		u8			address;
 		struct dummy_ep		*ep = NULL;
 		int			type;
+		int			status = -EINPROGRESS;
 
 		urb = urbp-&gt;urb;
 		if (urb-&gt;unlinked)
@@ -1279,7 +1273,7 @@ static void dummy_timer (unsigned long _dum)
 			dev_dbg (dummy_dev(dum),
 				"no ep configured for urb %p\n",
 				urb);
-			maybe_set_status (urb, -EPROTO);
+			status = -EPROTO;
 			goto return_urb;
 		}
 
@@ -1294,7 +1288,7 @@ static void dummy_timer (unsigned long _dum)
 			/* NOTE: must not be iso! */
 			dev_dbg (dummy_dev(dum), "ep %s halted, urb %p\n",
 					ep-&gt;ep.name, urb);
-			maybe_set_status (urb, -EPIPE);
+			status = -EPIPE;
 			goto return_urb;
 		}
 		/* FIXME make sure both ends agree on maxpacket */
@@ -1312,7 +1306,7 @@ static void dummy_timer (unsigned long _dum)
 			w_value = le16_to_cpu(setup.wValue);
 			if (le16_to_cpu(setup.wLength) !=
 					urb-&gt;transfer_buffer_length) {
-				maybe_set_status (urb, -EOVERFLOW);
+				status = -EOVERFLOW;
 				goto return_urb;
 			}
 
@@ -1342,7 +1336,7 @@ static void dummy_timer (unsigned long _dum)
 				if (setup.bRequestType != Dev_Request)
 					break;
 				dum-&gt;address = w_value;
-				maybe_set_status (urb, 0);
+				status = 0;
 				dev_dbg (udc_dev(dum), "set_address = %d\n",
 						w_value);
 				value = 0;
@@ -1369,7 +1363,7 @@ static void dummy_timer (unsigned long _dum)
 					if (value == 0) {
 						dum-&gt;devstatus |=
 							(1 &lt;&lt; w_value);
-						maybe_set_status (urb, 0);
+						status = 0;
 					}
 
 				} else if (setup.bRequestType == Ep_Request) {
@@ -1381,7 +1375,7 @@ static void dummy_timer (unsigned long _dum)
 					}
 					ep2-&gt;halted = 1;
 					value = 0;
-					maybe_set_status (urb, 0);
+					status = 0;
 				}
 				break;
 			case USB_REQ_CLEAR_FEATURE:
@@ -1391,7 +1385,7 @@ static void dummy_timer (unsigned long _dum)
 						dum-&gt;devstatus &amp;= ~(1 &lt;&lt;
 							USB_DEVICE_REMOTE_WAKEUP);
 						value = 0;
-						maybe_set_status (urb, 0);
+						status = 0;
 						break;
 					default:
 						value = -EOPNOTSUPP;
@@ -1406,7 +1400,7 @@ static void dummy_timer (unsigned long _dum)
 					}
 					ep2-&gt;halted = 0;
 					value = 0;
-					maybe_set_status (urb, 0);
+					status = 0;
 				}
 				break;
 			case USB_REQ_GET_STATUS:
@@ -1443,7 +1437,7 @@ static void dummy_timer (unsigned long _dum)
 					urb-&gt;actual_length = min (2,
 						urb-&gt;transfer_buffer_length);
 					value = 0;
-					maybe_set_status (urb, 0);
+					status = 0;
 				}
 				break;
 			}
@@ -1470,7 +1464,7 @@ static void dummy_timer (unsigned long _dum)
 					dev_dbg (udc_dev(dum),
 						"setup --&gt; %d\n",
 						value);
-				maybe_set_status (urb, -EPIPE);
+				status = -EPIPE;
 				urb-&gt;actual_length = 0;
 			}
 
@@ -1487,7 +1481,7 @@ static void dummy_timer (unsigned long _dum)
 			 * report random errors, to debug drivers.
 			 */
 			limit = max (limit, periodic_bytes (dum, ep));
-			maybe_set_status (urb, -ENOSYS);
+			status = -ENOSYS;
 			break;
 
 		case PIPE_INTERRUPT:
@@ -1501,12 +1495,12 @@ static void dummy_timer (unsigned long _dum)
 		default:
 		treat_control_like_bulk:
 			ep-&gt;last_io = jiffies;
-			total = transfer (dum, urb, ep, limit);
+			total = transfer(dum, urb, ep, limit, &amp;status);
 			break;
 		}
 
 		/* incomplete transfer? */
-		if (urb-&gt;status == -EINPROGRESS)
+		if (status == -EINPROGRESS)
 			continue;
 
 return_urb:
@@ -1517,6 +1511,7 @@ static void dummy_timer (unsigned long _dum)
 
 		usb_hcd_unlink_urb_from_ep(dummy_to_hcd(dum), urb);
 		spin_unlock (&amp;dum-&gt;lock);
+		urb-&gt;status = status;
 		usb_hcd_giveback_urb (dummy_to_hcd(dum), urb);
 		spin_lock (&amp;dum-&gt;lock);
 </pre><hr><pre>commit 12943f097e5a4a0550f52f98ab8f476435e2ce15
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 24 16:27:50 2007 -0400

    USB: less-restrictive command checking in g-file-storage
    
    This patch (as983) makes a test for minimum-length command sizes in
    g_file_storage less restrictive.  It doesn't matter because commands
    with bad lengths will be detected later on anyway, and doing it like
    this makes the driver interoperable with certain buggy hosts such as
    the JVC HiFi (reported by Samuel Hangouet).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/file_storage.c b/drivers/usb/gadget/file_storage.c
index 9998cd7af418..0551140010ee 100644
--- a/drivers/usb/gadget/file_storage.c
+++ b/drivers/usb/gadget/file_storage.c
@@ -2964,7 +2964,7 @@ static int received_cbw(struct fsg_dev *fsg, struct fsg_buffhd *bh)
 
 	/* Is the CBW meaningful? */
 	if (cbw-&gt;Lun &gt;= MAX_LUNS || cbw-&gt;Flags &amp; ~USB_BULK_IN_FLAG ||
-			cbw-&gt;Length &lt; 6 || cbw-&gt;Length &gt; MAX_COMMAND_SIZE) {
+			cbw-&gt;Length &lt;= 0 || cbw-&gt;Length &gt; MAX_COMMAND_SIZE) {
 		DBG(fsg, "non-meaningful CBW: lun = %u, flags = 0x%x, "
 				"cmdlen %u\n",
 				cbw-&gt;Lun, cbw-&gt;Flags, cbw-&gt;Length);</pre><hr><pre>commit 6e8fe43b26085a64327d1cbb751ab895f3ad3f5d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 22 13:08:40 2007 -0400

    USB: avoid the donelist after an error in ohci-hcd
    
    This patch (as972) changes ohci-hcd so that after an error occurs, the
    remaining TDs for the URB will be skipped over entirely instead of
    going through the donelist.  This enables the driver to give back the
    URB as soon as the error is detected, avoiding the need to store the
    error status in urb-&gt;status.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ohci-q.c b/drivers/usb/host/ohci-q.c
index 3c793fad178d..860e55ff67a1 100644
--- a/drivers/usb/host/ohci-q.c
+++ b/drivers/usb/host/ohci-q.c
@@ -783,10 +783,10 @@ static void td_done (struct ohci_hcd *ohci, struct urb *urb, struct td *td)
 
 /*-------------------------------------------------------------------------*/
 
-static inline struct td *
-ed_halted (struct ohci_hcd *ohci, struct td *td, int cc, struct td *rev)
+static void ed_halted(struct ohci_hcd *ohci, struct td *td, int cc)
 {
 	struct urb		*urb = td-&gt;urb;
+	urb_priv_t		*urb_priv = urb-&gt;hcpriv;
 	struct ed		*ed = td-&gt;ed;
 	struct list_head	*tmp = td-&gt;td_list.next;
 	__hc32			toggle = ed-&gt;hwHeadP &amp; cpu_to_hc32 (ohci, ED_C);
@@ -798,13 +798,12 @@ ed_halted (struct ohci_hcd *ohci, struct td *td, int cc, struct td *rev)
 	wmb ();
 	ed-&gt;hwHeadP &amp;= ~cpu_to_hc32 (ohci, ED_H);
 
-	/* put any later tds from this urb onto the donelist, after 'td',
-	 * order won't matter here: no errors, and nothing was transferred.
-	 * also patch the ed so it looks as if those tds completed normally.
+	/* Get rid of all later tds from this urb.  We don't have
+	 * to be careful: no errors and nothing was transferred.
+	 * Also patch the ed so it looks as if those tds completed normally.
 	 */
 	while (tmp != &amp;ed-&gt;td_list) {
 		struct td	*next;
-		__hc32		info;
 
 		next = list_entry (tmp, struct td, td_list);
 		tmp = next-&gt;td_list.next;
@@ -819,14 +818,9 @@ ed_halted (struct ohci_hcd *ohci, struct td *td, int cc, struct td *rev)
 		 * then we need to leave the control STATUS packet queued
 		 * and clear ED_SKIP.
 		 */
-		info = next-&gt;hwINFO;
-		info |= cpu_to_hc32 (ohci, TD_DONE);
-		info &amp;= ~cpu_to_hc32 (ohci, TD_CC);
-		next-&gt;hwINFO = info;
-
-		next-&gt;next_dl_td = rev;
-		rev = next;
 
+		list_del(&amp;next-&gt;td_list);
+		urb_priv-&gt;td_cnt++;
 		ed-&gt;hwHeadP = next-&gt;hwNextTD | toggle;
 	}
 
@@ -852,8 +846,6 @@ ed_halted (struct ohci_hcd *ohci, struct td *td, int cc, struct td *rev)
 			hc32_to_cpu (ohci, td-&gt;hwINFO),
 			cc, cc_to_error [cc]);
 	}
-
-	return rev;
 }
 
 /* replies to the request have to be on a FIFO basis so
@@ -890,7 +882,7 @@ static struct td *dl_reverse_done_list (struct ohci_hcd *ohci)
 		 */
 		if (cc != TD_CC_NOERROR
 				&amp;&amp; (td-&gt;ed-&gt;hwHeadP &amp; cpu_to_hc32 (ohci, ED_H)))
-			td_rev = ed_halted (ohci, td, cc, td_rev);
+			ed_halted(ohci, td, cc);
 
 		td-&gt;next_dl_td = td_rev;
 		td_rev = td;</pre><hr><pre>commit 1f5a3d0f34fd5719081c6b8f3dbbcbe328d4da31
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 22 13:06:53 2007 -0400

    USB: fix mistake in usb_hcd_giveback_urb
    
    This patch (as971) fixes a small mistake: The URB's completion status
    needs to be adjusted before the URB is passed to usmon_urb_complete(),
    not afterward.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index ec17fc4d2861..8b17babf5c55 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1266,9 +1266,6 @@ int usb_hcd_unlink_urb (struct urb *urb, int status)
  */
 void usb_hcd_giveback_urb (struct usb_hcd *hcd, struct urb *urb)
 {
-	unmap_urb_for_dma(hcd, urb);
-	usbmon_urb_complete (&amp;hcd-&gt;self, urb);
-	usb_unanchor_urb(urb);
 	urb-&gt;hcpriv = NULL;
 	if (unlikely(urb-&gt;unlinked))
 		urb-&gt;status = urb-&gt;unlinked;
@@ -1277,6 +1274,10 @@ void usb_hcd_giveback_urb (struct usb_hcd *hcd, struct urb *urb)
 			!urb-&gt;status))
 		urb-&gt;status = -EREMOTEIO;
 
+	unmap_urb_for_dma(hcd, urb);
+	usbmon_urb_complete(&amp;hcd-&gt;self, urb);
+	usb_unanchor_urb(urb);
+
 	/* pass ownership to the completion handler */
 	urb-&gt;complete (urb);
 	atomic_dec (&amp;urb-&gt;use_count);</pre><hr><pre>commit eb23105462304fd35571fd0cab1de7aec79a9ec5
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Aug 21 15:40:36 2007 -0400

    USB: add urb-&gt;unlinked field
    
    This patch (as970) adds a new urb-&gt;unlinked field, which is used to
    store the status of unlinked URBs since we can't use urb-&gt;status for
    that purpose any more.  To help simplify the HCDs, usbcore will check
    urb-&gt;unlinked before calling the completion handler; if the value is
    set it will automatically override the status reported by the HCD.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    CC: Olav Kongas &lt;ok@artecdesign.ee&gt;
    CC: Yoshihiro Shimoda &lt;shimoda.yoshihiro@renesas.com&gt;
    CC: Tony Olech &lt;tony.olech@elandigitalsystems.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 22a098b318c0..ec17fc4d2861 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -532,8 +532,7 @@ static int rh_call_control (struct usb_hcd *hcd, struct urb *urb)
 
 	/* any errors get returned through the urb completion */
 	spin_lock_irq(&amp;hcd_root_hub_lock);
-	if (urb-&gt;status == -EINPROGRESS)
-		urb-&gt;status = status;
+	urb-&gt;status = status;
 	usb_hcd_unlink_urb_from_ep(hcd, urb);
 
 	/* This peculiar use of spinlocks echoes what real HC drivers do.
@@ -1024,6 +1023,7 @@ int usb_hcd_link_urb_to_ep(struct usb_hcd *hcd, struct urb *urb)
 	switch (hcd-&gt;state) {
 	case HC_STATE_RUNNING:
 	case HC_STATE_RESUMING:
+		urb-&gt;unlinked = 0;
 		list_add_tail(&amp;urb-&gt;urb_list, &amp;urb-&gt;ep-&gt;urb_list);
 		break;
 	default:
@@ -1071,9 +1071,9 @@ int usb_hcd_check_unlink_urb(struct usb_hcd *hcd, struct urb *urb,
 	/* Any status except -EINPROGRESS means something already started to
 	 * unlink this URB from the hardware.  So there's no more work to do.
 	 */
-	if (urb-&gt;status != -EINPROGRESS)
+	if (urb-&gt;unlinked)
 		return -EBUSY;
-	urb-&gt;status = status;
+	urb-&gt;unlinked = status;
 
 	/* IRQ setup can easily be broken so that USB controllers
 	 * never get completion IRQs ... maybe even the ones we need to
@@ -1259,6 +1259,10 @@ int usb_hcd_unlink_urb (struct urb *urb, int status)
  * (and is done using urb-&gt;hcpriv).  It also released all HCD locks;
  * the device driver won't cause problems if it frees, modifies,
  * or resubmits this URB.
+ *
+ * If @urb was unlinked, the value of @urb-&gt;status will be overridden by
+ * @urb-&gt;unlinked.  Erroneous short transfers are detected in case
+ * the HCD hasn't checked for them.
  */
 void usb_hcd_giveback_urb (struct usb_hcd *hcd, struct urb *urb)
 {
@@ -1266,7 +1270,9 @@ void usb_hcd_giveback_urb (struct usb_hcd *hcd, struct urb *urb)
 	usbmon_urb_complete (&amp;hcd-&gt;self, urb);
 	usb_unanchor_urb(urb);
 	urb-&gt;hcpriv = NULL;
-	if (unlikely((urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK) &amp;&amp;
+	if (unlikely(urb-&gt;unlinked))
+		urb-&gt;status = urb-&gt;unlinked;
+	else if (unlikely((urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK) &amp;&amp;
 			urb-&gt;actual_length &lt; urb-&gt;transfer_buffer_length &amp;&amp;
 			!urb-&gt;status))
 		urb-&gt;status = -EREMOTEIO;
@@ -1305,8 +1311,7 @@ void usb_hcd_endpoint_disable (struct usb_device *udev,
 	list_for_each_entry (urb, &amp;ep-&gt;urb_list, urb_list) {
 		int	is_in;
 
-		/* the urb may already have been unlinked */
-		if (urb-&gt;status != -EINPROGRESS)
+		if (urb-&gt;unlinked)
 			continue;
 		usb_get_urb (urb);
 		is_in = usb_urb_dir_in(urb);
diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index 0cb032526ca2..f2b124cf3206 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -1029,8 +1029,7 @@ static int dummy_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 static void maybe_set_status (struct urb *urb, int status)
 {
 	spin_lock (&amp;urb-&gt;lock);
-	if (urb-&gt;status == -EINPROGRESS)
-		urb-&gt;status = status;
+	urb-&gt;status = status;
 	spin_unlock (&amp;urb-&gt;lock);
 }
 
@@ -1257,10 +1256,9 @@ static void dummy_timer (unsigned long _dum)
 		int			type;
 
 		urb = urbp-&gt;urb;
-		if (urb-&gt;status != -EINPROGRESS) {
-			/* likely it was just unlinked */
+		if (urb-&gt;unlinked)
 			goto return_urb;
-		} else if (dum-&gt;rh_state != DUMMY_RH_RUNNING)
+		else if (dum-&gt;rh_state != DUMMY_RH_RUNNING)
 			continue;
 		type = usb_pipetype (urb-&gt;pipe);
 
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index e80b5c417d74..a8f5408c161d 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -151,7 +151,7 @@ static void qtd_copy_status (
 		urb-&gt;actual_length += length - QTD_LENGTH (token);
 
 	/* don't modify error codes */
-	if (unlikely (urb-&gt;status != -EINPROGRESS))
+	if (unlikely(urb-&gt;unlinked))
 		return;
 
 	/* force cleanup after short read; not always an error */
@@ -232,21 +232,14 @@ __acquires(ehci-&gt;lock)
 	}
 
 	spin_lock (&amp;urb-&gt;lock);
-	switch (urb-&gt;status) {
-	case -EINPROGRESS:		/* success */
-		urb-&gt;status = 0;
-	default:			/* fault */
-		COUNT (ehci-&gt;stats.complete);
-		break;
-	case -EREMOTEIO:		/* fault or normal */
-		if (!(urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK))
+	if (unlikely(urb-&gt;unlinked)) {
+		COUNT(ehci-&gt;stats.unlink);
+	} else {
+		if (likely(urb-&gt;status == -EINPROGRESS ||
+				(urb-&gt;status == -EREMOTEIO &amp;&amp;
+				 !(urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK))))
 			urb-&gt;status = 0;
-		COUNT (ehci-&gt;stats.complete);
-		break;
-	case -ECONNRESET:		/* canceled */
-	case -ENOENT:
-		COUNT (ehci-&gt;stats.unlink);
-		break;
+		COUNT(ehci-&gt;stats.complete);
 	}
 	spin_unlock (&amp;urb-&gt;lock);
 
@@ -364,7 +357,8 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 			 * for the urb faulted (including short read) or
 			 * its urb was canceled.  we may patch qh or qtds.
 			 */
-			if (likely (urb-&gt;status == -EINPROGRESS))
+			if (likely(urb-&gt;status == -EINPROGRESS &amp;&amp;
+					!urb-&gt;unlinked))
 				continue;
 
 			/* issue status after short control reads */
@@ -395,7 +389,8 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 		spin_lock (&amp;urb-&gt;lock);
 		qtd_copy_status (ehci, urb, qtd-&gt;length, token);
 		if (unlikely(urb-&gt;status == -EREMOTEIO)) {
-			do_status = usb_pipecontrol(urb-&gt;pipe);
+			do_status = (!urb-&gt;unlinked &amp;&amp;
+					usb_pipecontrol(urb-&gt;pipe));
 			urb-&gt;status = 0;
 		}
 		spin_unlock (&amp;urb-&gt;lock);
diff --git a/drivers/usb/host/isp116x-hcd.c b/drivers/usb/host/isp116x-hcd.c
index c2919dbc3f54..35b3507ff401 100644
--- a/drivers/usb/host/isp116x-hcd.c
+++ b/drivers/usb/host/isp116x-hcd.c
@@ -455,11 +455,10 @@ static void postproc_atl_queue(struct isp116x *isp116x)
  done:
 		if (status != -EINPROGRESS) {
 			spin_lock(&amp;urb-&gt;lock);
-			if (urb-&gt;status == -EINPROGRESS)
-				urb-&gt;status = status;
+			urb-&gt;status = status;
 			spin_unlock(&amp;urb-&gt;lock);
 		}
-		if (urb-&gt;status != -EINPROGRESS)
+		if (urb-&gt;status != -EINPROGRESS || urb-&gt;unlinked)
 			finish_request(isp116x, ep, urb);
 	}
 }
diff --git a/drivers/usb/host/ohci-q.c b/drivers/usb/host/ohci-q.c
index 8aad6199cdcc..3c793fad178d 100644
--- a/drivers/usb/host/ohci-q.c
+++ b/drivers/usb/host/ohci-q.c
@@ -758,8 +758,7 @@ static void td_done (struct ohci_hcd *ohci, struct urb *urb, struct td *td)
 			cc = TD_CC_NOERROR;
 		if (cc != TD_CC_NOERROR &amp;&amp; cc &lt; 0x0E) {
 			spin_lock (&amp;urb-&gt;lock);
-			if (urb-&gt;status == -EINPROGRESS)
-				urb-&gt;status = cc_to_error [cc];
+			urb-&gt;status = cc_to_error[cc];
 			spin_unlock (&amp;urb-&gt;lock);
 		}
 
@@ -972,7 +971,7 @@ finish_unlinks (struct ohci_hcd *ohci, u16 tick)
 			urb = td-&gt;urb;
 			urb_priv = td-&gt;urb-&gt;hcpriv;
 
-			if (urb-&gt;status == -EINPROGRESS) {
+			if (!urb-&gt;unlinked) {
 				prev = &amp;td-&gt;hwNextTD;
 				continue;
 			}
diff --git a/drivers/usb/host/r8a66597-hcd.c b/drivers/usb/host/r8a66597-hcd.c
index 60248b01ce14..98b9e0547544 100644
--- a/drivers/usb/host/r8a66597-hcd.c
+++ b/drivers/usb/host/r8a66597-hcd.c
@@ -1118,7 +1118,7 @@ __releases(r8a66597-&gt;lock) __acquires(r8a66597-&gt;lock)
 	r8a66597-&gt;timeout_map &amp;= ~(1 &lt;&lt; pipenum);
 
 	if (likely(td)) {
-		if (td-&gt;set_address &amp;&amp; urb-&gt;status != 0)
+		if (td-&gt;set_address &amp;&amp; (urb-&gt;status != 0 || urb-&gt;unlinked))
 			r8a66597-&gt;address_map &amp;= ~(1 &lt;&lt; urb-&gt;setup_packet[2]);
 
 		pipe_toggle_save(r8a66597, td-&gt;pipe, urb);
@@ -1225,8 +1225,7 @@ static void packet_read(struct r8a66597 *r8a66597, u16 pipenum)
 	}
 
 	if (finish &amp;&amp; pipenum != 0) {
-		if (td-&gt;urb-&gt;status == -EINPROGRESS)
-			td-&gt;urb-&gt;status = status;
+		td-&gt;urb-&gt;status = status;
 		finish_request(r8a66597, td, pipenum, urb);
 	}
 }
@@ -1308,32 +1307,24 @@ static void check_next_phase(struct r8a66597 *r8a66597)
 	switch (td-&gt;type) {
 	case USB_PID_IN:
 	case USB_PID_OUT:
-		if (urb-&gt;status != -EINPROGRESS) {
-			finish = 1;
-			break;
-		}
 		if (check_transfer_finish(td, urb))
 			td-&gt;type = USB_PID_ACK;
 		break;
 	case USB_PID_SETUP:
-		if (urb-&gt;status != -EINPROGRESS)
-			finish = 1;
-		else if (urb-&gt;transfer_buffer_length == urb-&gt;actual_length) {
+		if (urb-&gt;transfer_buffer_length == urb-&gt;actual_length)
 			td-&gt;type = USB_PID_ACK;
-			urb-&gt;status = 0;
-		} else if (usb_pipeout(urb-&gt;pipe))
+		else if (usb_pipeout(urb-&gt;pipe))
 			td-&gt;type = USB_PID_OUT;
 		else
 			td-&gt;type = USB_PID_IN;
 		break;
 	case USB_PID_ACK:
 		finish = 1;
-		if (urb-&gt;status == -EINPROGRESS)
-			urb-&gt;status = 0;
+		urb-&gt;status = 0;
 		break;
 	}
 
-	if (finish)
+	if (finish || urb-&gt;unlinked)
 		finish_request(r8a66597, td, 0, urb);
 	else
 		start_transfer(r8a66597, td);
@@ -1418,8 +1409,7 @@ static void irq_pipe_empty(struct r8a66597 *r8a66597)
 			if ((tmp &amp; INBUFM) == 0) {
 				disable_irq_empty(r8a66597, pipenum);
 				pipe_irq_disable(r8a66597, pipenum);
-				if (td-&gt;urb-&gt;status == -EINPROGRESS)
-					td-&gt;urb-&gt;status = 0;
+				td-&gt;urb-&gt;status = 0;
 				finish_request(r8a66597, td, pipenum, td-&gt;urb);
 			}
 		}
diff --git a/drivers/usb/host/sl811-hcd.c b/drivers/usb/host/sl811-hcd.c
index e90953a9c9fb..f0fa94148d9d 100644
--- a/drivers/usb/host/sl811-hcd.c
+++ b/drivers/usb/host/sl811-hcd.c
@@ -436,8 +436,7 @@ static void finish_request(
 		ep-&gt;nextpid = USB_PID_SETUP;
 
 	spin_lock(&amp;urb-&gt;lock);
-	if (urb-&gt;status == -EINPROGRESS)
-		urb-&gt;status = status;
+	urb-&gt;status = status;
 	spin_unlock(&amp;urb-&gt;lock);
 
 	usb_hcd_unlink_urb_from_ep(sl811_to_hcd(sl811), urb);
@@ -598,7 +597,7 @@ done(struct sl811 *sl811, struct sl811h_ep *ep, u8 bank)
 				bank, status, ep, urbstat);
 	}
 
-	if (urb &amp;&amp; (urbstat != -EINPROGRESS || urb-&gt;status != -EINPROGRESS))
+	if (urb &amp;&amp; (urbstat != -EINPROGRESS || urb-&gt;unlinked))
 		finish_request(sl811, ep, urb, urbstat);
 }
 
diff --git a/drivers/usb/host/u132-hcd.c b/drivers/usb/host/u132-hcd.c
index 1381275d448f..db800a434b83 100644
--- a/drivers/usb/host/u132-hcd.c
+++ b/drivers/usb/host/u132-hcd.c
@@ -645,12 +645,12 @@ static void u132_hcd_interrupt_recv(void *data, struct urb *urb, u8 *buf,
                 u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
                 return;
         } else if (u132-&gt;going &gt; 0) {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed "
+				"urb=%p\n", urb);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
                 return;
-        } else if (urb-&gt;status == -EINPROGRESS) {
+	} else if (!urb-&gt;unlinked) {
                 struct u132_ring *ring = endp-&gt;ring;
                 u8 *u = urb-&gt;transfer_buffer + urb-&gt;actual_length;
                 u8 *b = buf;
@@ -716,8 +716,8 @@ static void u132_hcd_interrupt_recv(void *data, struct urb *urb, u8 *buf,
                         return;
                 }
         } else {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
+				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
                 return;
@@ -744,12 +744,12 @@ static void u132_hcd_bulk_output_sent(void *data, struct urb *urb, u8 *buf,
                 u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
                 return;
         } else if (u132-&gt;going &gt; 0) {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed "
+				"urb=%p\n", urb);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
                 return;
-        } else if (urb-&gt;status == -EINPROGRESS) {
+	} else if (!urb-&gt;unlinked) {
                 struct u132_ring *ring = endp-&gt;ring;
                 urb-&gt;actual_length += len;
                 endp-&gt;toggle_bits = toggle_bits;
@@ -768,8 +768,8 @@ static void u132_hcd_bulk_output_sent(void *data, struct urb *urb, u8 *buf,
                         return;
                 }
         } else {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
+				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
                 return;
@@ -797,12 +797,12 @@ static void u132_hcd_bulk_input_recv(void *data, struct urb *urb, u8 *buf,
                 u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
                 return;
         } else if (u132-&gt;going &gt; 0) {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed "
+				"urb=%p\n", urb);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
                 return;
-        } else if (urb-&gt;status == -EINPROGRESS) {
+	} else if (!urb-&gt;unlinked) {
                 struct u132_ring *ring = endp-&gt;ring;
                 u8 *u = urb-&gt;transfer_buffer + urb-&gt;actual_length;
                 u8 *b = buf;
@@ -871,8 +871,8 @@ static void u132_hcd_bulk_input_recv(void *data, struct urb *urb, u8 *buf,
                         return;
                 }
         } else {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
+				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
                 return;
@@ -898,18 +898,18 @@ static void u132_hcd_configure_empty_sent(void *data, struct urb *urb, u8 *buf,
                 u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
                 return;
         } else if (u132-&gt;going &gt; 0) {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed "
+				"urb=%p\n", urb);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
                 return;
-        } else if (urb-&gt;status == -EINPROGRESS) {
+	} else if (!urb-&gt;unlinked) {
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, 0);
                 return;
         } else {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
+				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
                 return;
@@ -936,12 +936,12 @@ static void u132_hcd_configure_input_recv(void *data, struct urb *urb, u8 *buf,
                 u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
                 return;
         } else if (u132-&gt;going &gt; 0) {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed "
+				"urb=%p\n", urb);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
                 return;
-        } else if (urb-&gt;status == -EINPROGRESS) {
+	} else if (!urb-&gt;unlinked) {
                 struct u132_ring *ring = endp-&gt;ring;
                 u8 *u = urb-&gt;transfer_buffer;
                 u8 *b = buf;
@@ -980,8 +980,8 @@ static void u132_hcd_configure_input_recv(void *data, struct urb *urb, u8 *buf,
                         return;
                 }
         } else {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
+				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
                 return;
@@ -1007,18 +1007,18 @@ static void u132_hcd_configure_empty_recv(void *data, struct urb *urb, u8 *buf,
                 u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
                 return;
         } else if (u132-&gt;going &gt; 0) {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed "
+				"urb=%p\n", urb);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
                 return;
-        } else if (urb-&gt;status == -EINPROGRESS) {
+	} else if (!urb-&gt;unlinked) {
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, 0);
                 return;
         } else {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
+				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
                 return;
@@ -1045,12 +1045,12 @@ static void u132_hcd_configure_setup_sent(void *data, struct urb *urb, u8 *buf,
                 u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
                 return;
         } else if (u132-&gt;going &gt; 0) {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed "
+				"urb=%p\n", urb);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
                 return;
-        } else if (urb-&gt;status == -EINPROGRESS) {
+	} else if (!urb-&gt;unlinked) {
                 if (usb_pipein(urb-&gt;pipe)) {
                         int retval;
                         struct u132_ring *ring = endp-&gt;ring;
@@ -1077,8 +1077,8 @@ static void u132_hcd_configure_setup_sent(void *data, struct urb *urb, u8 *buf,
                         return;
                 }
         } else {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
+				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
                 return;
@@ -1106,20 +1106,20 @@ static void u132_hcd_enumeration_empty_recv(void *data, struct urb *urb,
                 u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
                 return;
         } else if (u132-&gt;going &gt; 0) {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed "
+				"urb=%p\n", urb);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
                 return;
-        } else if (urb-&gt;status == -EINPROGRESS) {
+	} else if (!urb-&gt;unlinked) {
                 u132-&gt;addr[0].address = 0;
                 endp-&gt;usb_addr = udev-&gt;usb_addr;
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, 0);
                 return;
         } else {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
+				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
                 return;
@@ -1145,12 +1145,12 @@ static void u132_hcd_enumeration_address_sent(void *data, struct urb *urb,
                 u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
                 return;
         } else if (u132-&gt;going &gt; 0) {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed "
+				"urb=%p\n", urb);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
                 return;
-        } else if (urb-&gt;status == -EINPROGRESS) {
+	} else if (!urb-&gt;unlinked) {
                 int retval;
                 struct u132_ring *ring = endp-&gt;ring;
                 up(&amp;u132-&gt;scheduler_lock);
@@ -1162,8 +1162,8 @@ static void u132_hcd_enumeration_address_sent(void *data, struct urb *urb,
                         u132_hcd_giveback_urb(u132, endp, urb, retval);
                 return;
         } else {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
+				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
                 return;
@@ -1189,18 +1189,18 @@ static void u132_hcd_initial_empty_sent(void *data, struct urb *urb, u8 *buf,
                 u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
                 return;
         } else if (u132-&gt;going &gt; 0) {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed "
+				"urb=%p\n", urb);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
                 return;
-        } else if (urb-&gt;status == -EINPROGRESS) {
+	} else if (!urb-&gt;unlinked) {
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, 0);
                 return;
         } else {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
+				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
                 return;
@@ -1227,12 +1227,12 @@ static void u132_hcd_initial_input_recv(void *data, struct urb *urb, u8 *buf,
                 u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
                 return;
         } else if (u132-&gt;going &gt; 0) {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed "
+				"urb=%p\n", urb);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
                 return;
-        } else if (urb-&gt;status == -EINPROGRESS) {
+	} else if (!urb-&gt;unlinked) {
                 int retval;
                 struct u132_ring *ring = endp-&gt;ring;
                 u8 *u = urb-&gt;transfer_buffer;
@@ -1251,8 +1251,8 @@ static void u132_hcd_initial_input_recv(void *data, struct urb *urb, u8 *buf,
                         u132_hcd_giveback_urb(u132, endp, urb, retval);
                 return;
         } else {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
+				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
                 return;
@@ -1279,12 +1279,12 @@ static void u132_hcd_initial_setup_sent(void *data, struct urb *urb, u8 *buf,
                 u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
                 return;
         } else if (u132-&gt;going &gt; 0) {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed "
+				"urb=%p\n", urb);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
                 return;
-        } else if (urb-&gt;status == -EINPROGRESS) {
+	} else if (!urb-&gt;unlinked) {
                 int retval;
                 struct u132_ring *ring = endp-&gt;ring;
                 up(&amp;u132-&gt;scheduler_lock);
@@ -1296,8 +1296,8 @@ static void u132_hcd_initial_setup_sent(void *data, struct urb *urb, u8 *buf,
                         u132_hcd_giveback_urb(u132, endp, urb, retval);
                 return;
         } else {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
+				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
                 return;
@@ -2279,8 +2279,8 @@ static int u132_urb_enqueue(struct usb_hcd *hcd, struct urb *urb,
                         , u132-&gt;going);
                 return -ENODEV;
         } else if (u132-&gt;going &gt; 0) {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed "
+				"urb=%p\n", urb);
                 return -ESHUTDOWN;
         } else {
                 u8 usb_addr = usb_pipedevice(urb-&gt;pipe);
diff --git a/drivers/usb/host/uhci-debug.c b/drivers/usb/host/uhci-debug.c
index 1497371583b9..20cc58b97807 100644
--- a/drivers/usb/host/uhci-debug.c
+++ b/drivers/usb/host/uhci-debug.c
@@ -120,8 +120,8 @@ static int uhci_show_urbp(struct urb_priv *urbp, char *buf, int len, int space)
 	out += sprintf(out, "%s%s", ptype, (urbp-&gt;fsbr ? " FSBR" : ""));
 	out += sprintf(out, " Actlen=%d", urbp-&gt;urb-&gt;actual_length);
 
-	if (urbp-&gt;urb-&gt;status != -EINPROGRESS)
-		out += sprintf(out, " Status=%d", urbp-&gt;urb-&gt;status);
+	if (urbp-&gt;urb-&gt;unlinked)
+		out += sprintf(out, " Unlinked=%d", urbp-&gt;urb-&gt;unlinked);
 	out += sprintf(out, "\n");
 
 	i = nactive = ninactive = 0;
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index fbc3af392c26..bab567266559 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -1557,15 +1557,12 @@ static void uhci_scan_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
 			break;
 
 		spin_lock(&amp;urb-&gt;lock);
-		if (urb-&gt;status == -EINPROGRESS)	/* Not dequeued */
-			urb-&gt;status = status;
-		else
-			status = ECONNRESET;		/* Not -ECONNRESET */
+		urb-&gt;status = status;
 		spin_unlock(&amp;urb-&gt;lock);
 
 		/* Dequeued but completed URBs can't be given back unless
 		 * the QH is stopped or has finished unlinking. */
-		if (status == ECONNRESET) {
+		if (urb-&gt;unlinked) {
 			if (QH_FINISHED_UNLINKING(qh))
 				qh-&gt;is_stopped = 1;
 			else if (!qh-&gt;is_stopped)
@@ -1588,7 +1585,7 @@ static void uhci_scan_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
 restart:
 	list_for_each_entry(urbp, &amp;qh-&gt;queue, node) {
 		urb = urbp-&gt;urb;
-		if (urb-&gt;status != -EINPROGRESS) {
+		if (urb-&gt;unlinked) {
 
 			/* Fix up the TD links and save the toggles for
 			 * non-Isochronous queues.  For Isochronous queues,
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 92d63c6b6fc6..5c7b79088add 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1245,6 +1245,7 @@ struct urb
 	void *hcpriv;			/* private data for host controller */
 	atomic_t use_count;		/* concurrent submissions counter */
 	u8 reject;			/* submissions will fail */
+	int unlinked;			/* unlink error code */
 
 	/* public: documented fields in the urb that can be used by drivers */
 	struct list_head urb_list;	/* list head for use by the urb's</pre><hr><pre>commit b0d9efba3ec53468984aecef8eeaf079089f2e5a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Aug 21 15:39:21 2007 -0400

    USB: centralize -EREMOTEIO handling
    
    This patch (as969) continues the ongoing changes to the way HCDs
    report URB statuses.  The programming interface has been simplified by
    making usbcore responsible for clearing urb-&gt;hcpriv and for setting
    -EREMOTEIO status when an URB with the URB_SHORT_NOT_OK flag ends up
    as a short transfer.
    
    By moving the work out of the HCDs, this removes a fair amount of
    repeated code.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    CC: Olav Kongas &lt;ok@artecdesign.ee&gt;
    CC: Yoshihiro Shimoda &lt;shimoda.yoshihiro@renesas.com&gt;
    CC: Tony Olech &lt;tony.olech@elandigitalsystems.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index a853f63b9254..22a098b318c0 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -366,6 +366,7 @@ static int rh_call_control (struct usb_hcd *hcd, struct urb *urb)
 	spin_unlock_irq(&amp;hcd_root_hub_lock);
 	if (status)
 		return status;
+	urb-&gt;hcpriv = hcd;	/* Indicate it's queued */
 
 	cmd = (struct usb_ctrlrequest *) urb-&gt;setup_packet;
 	typeReq  = (cmd-&gt;bRequestType &lt;&lt; 8) | cmd-&gt;bRequest;
@@ -579,7 +580,6 @@ void usb_hcd_poll_rh_status(struct usb_hcd *hcd)
 			hcd-&gt;poll_pending = 0;
 			hcd-&gt;status_urb = NULL;
 			urb-&gt;status = 0;
-			urb-&gt;hcpriv = NULL;
 			urb-&gt;actual_length = length;
 			memcpy(urb-&gt;transfer_buffer, buffer, length);
 
@@ -675,7 +675,6 @@ static int usb_rh_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 			del_timer (&amp;hcd-&gt;rh_timer);
 		if (urb == hcd-&gt;status_urb) {
 			hcd-&gt;status_urb = NULL;
-			urb-&gt;hcpriv = NULL;
 			usb_hcd_unlink_urb_from_ep(hcd, urb);
 
 			spin_unlock(&amp;hcd_root_hub_lock);
@@ -1192,6 +1191,7 @@ int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
 	if (unlikely(status)) {
 		usbmon_urb_submit_error(&amp;hcd-&gt;self, urb, status);
 		unmap_urb_for_dma(hcd, urb);
+		urb-&gt;hcpriv = NULL;
 		INIT_LIST_HEAD(&amp;urb-&gt;urb_list);
 		atomic_dec(&amp;urb-&gt;use_count);
 		if (urb-&gt;reject)
@@ -1265,6 +1265,11 @@ void usb_hcd_giveback_urb (struct usb_hcd *hcd, struct urb *urb)
 	unmap_urb_for_dma(hcd, urb);
 	usbmon_urb_complete (&amp;hcd-&gt;self, urb);
 	usb_unanchor_urb(urb);
+	urb-&gt;hcpriv = NULL;
+	if (unlikely((urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK) &amp;&amp;
+			urb-&gt;actual_length &lt; urb-&gt;transfer_buffer_length &amp;&amp;
+			!urb-&gt;status))
+		urb-&gt;status = -EREMOTEIO;
 
 	/* pass ownership to the completion handler */
 	urb-&gt;complete (urb);
diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index c441d10c087e..0cb032526ca2 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -1099,8 +1099,7 @@ transfer (struct dummy *dum, struct urb *urb, struct dummy_ep *ep, int limit)
 		 *
 		 * partially filling a buffer optionally blocks queue advances
 		 * (so completion handlers can clean up the queue) but we don't
-		 * need to emulate such data-in-flight.  so we only show part
-		 * of the URB_SHORT_NOT_OK effect: completion status.
+		 * need to emulate such data-in-flight.
 		 */
 		if (is_short) {
 			if (host_len == dev_len) {
@@ -1111,10 +1110,7 @@ transfer (struct dummy *dum, struct urb *urb, struct dummy_ep *ep, int limit)
 				if (dev_len &gt; host_len)
 					maybe_set_status (urb, -EOVERFLOW);
 				else
-					maybe_set_status (urb,
-						(urb-&gt;transfer_flags
-							&amp; URB_SHORT_NOT_OK)
-						? -EREMOTEIO : 0);
+					maybe_set_status (urb, 0);
 			} else if (!to_host) {
 				maybe_set_status (urb, 0);
 				if (host_len &gt; dev_len)
@@ -1516,7 +1512,6 @@ static void dummy_timer (unsigned long _dum)
 			continue;
 
 return_urb:
-		urb-&gt;hcpriv = NULL;
 		list_del (&amp;urbp-&gt;urbp_list);
 		kfree (urbp);
 		if (ep)
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 1da2de4d34ed..e80b5c417d74 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -232,7 +232,6 @@ __acquires(ehci-&gt;lock)
 	}
 
 	spin_lock (&amp;urb-&gt;lock);
-	urb-&gt;hcpriv = NULL;
 	switch (urb-&gt;status) {
 	case -EINPROGRESS:		/* success */
 		urb-&gt;status = 0;
@@ -395,8 +394,10 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 		/* remove it from the queue */
 		spin_lock (&amp;urb-&gt;lock);
 		qtd_copy_status (ehci, urb, qtd-&gt;length, token);
-		do_status = (urb-&gt;status == -EREMOTEIO)
-				&amp;&amp; usb_pipecontrol (urb-&gt;pipe);
+		if (unlikely(urb-&gt;status == -EREMOTEIO)) {
+			do_status = usb_pipecontrol(urb-&gt;pipe);
+			urb-&gt;status = 0;
+		}
 		spin_unlock (&amp;urb-&gt;lock);
 
 		if (stopped &amp;&amp; qtd-&gt;qtd_list.prev != &amp;qh-&gt;qtd_list) {
diff --git a/drivers/usb/host/isp116x-hcd.c b/drivers/usb/host/isp116x-hcd.c
index f2b5d6281c5d..c2919dbc3f54 100644
--- a/drivers/usb/host/isp116x-hcd.c
+++ b/drivers/usb/host/isp116x-hcd.c
@@ -282,7 +282,6 @@ __releases(isp116x-&gt;lock) __acquires(isp116x-&gt;lock)
 {
 	unsigned i;
 
-	urb-&gt;hcpriv = NULL;
 	ep-&gt;error_count = 0;
 
 	if (usb_pipecontrol(urb-&gt;pipe))
@@ -446,12 +445,7 @@ static void postproc_atl_queue(struct isp116x *isp116x)
 			if (PTD_GET_ACTIVE(ptd)
 			    || (cc != TD_CC_NOERROR &amp;&amp; cc &lt; 0x0E))
 				break;
-			if ((urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK) &amp;&amp;
-					urb-&gt;actual_length &lt;
-						urb-&gt;transfer_buffer_length)
-				status = -EREMOTEIO;
-			else
-				status = 0;
+			status = 0;
 			ep-&gt;nextpid = 0;
 			break;
 		default:
diff --git a/drivers/usb/host/ohci-q.c b/drivers/usb/host/ohci-q.c
index 889c0720743b..8aad6199cdcc 100644
--- a/drivers/usb/host/ohci-q.c
+++ b/drivers/usb/host/ohci-q.c
@@ -43,21 +43,10 @@ __acquires(ohci-&gt;lock)
 	// ASSERT (urb-&gt;hcpriv != 0);
 
 	urb_free_priv (ohci, urb-&gt;hcpriv);
-	urb-&gt;hcpriv = NULL;
 
 	spin_lock (&amp;urb-&gt;lock);
 	if (likely (urb-&gt;status == -EINPROGRESS))
 		urb-&gt;status = 0;
-	/* report short control reads right even though the data TD always
-	 * has TD_R set.  (much simpler, but creates the 1-td limit.)
-	 */
-	if (unlikely (urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK)
-			&amp;&amp; unlikely (usb_pipecontrol (urb-&gt;pipe))
-			&amp;&amp; urb-&gt;actual_length &lt; urb-&gt;transfer_buffer_length
-			&amp;&amp; usb_pipein (urb-&gt;pipe)
-			&amp;&amp; urb-&gt;status == 0) {
-		urb-&gt;status = -EREMOTEIO;
-	}
 	spin_unlock (&amp;urb-&gt;lock);
 
 	switch (usb_pipetype (urb-&gt;pipe)) {
diff --git a/drivers/usb/host/r8a66597-hcd.c b/drivers/usb/host/r8a66597-hcd.c
index 49cf998c172a..60248b01ce14 100644
--- a/drivers/usb/host/r8a66597-hcd.c
+++ b/drivers/usb/host/r8a66597-hcd.c
@@ -783,7 +783,6 @@ static void force_dequeue(struct r8a66597 *r8a66597, u16 pipenum, u16 address)
 
 		if (urb) {
 			urb-&gt;status = -ENODEV;
-			urb-&gt;hcpriv = NULL;
 			usb_hcd_unlink_urb_from_ep(r8a66597_to_hcd(r8a66597),
 					urb);
 
@@ -1134,7 +1133,6 @@ __releases(r8a66597-&gt;lock) __acquires(r8a66597-&gt;lock)
 		if (usb_pipeisoc(urb-&gt;pipe))
 			urb-&gt;start_frame = r8a66597_get_frame(hcd);
 
-		urb-&gt;hcpriv = NULL;
 		usb_hcd_unlink_urb_from_ep(r8a66597_to_hcd(r8a66597), urb);
 
 		spin_unlock(&amp;r8a66597-&gt;lock);
@@ -1202,9 +1200,6 @@ static void packet_read(struct r8a66597 *r8a66597, u16 pipenum)
 		td-&gt;zero_packet = 1;
 	if (rcv_len &lt; bufsize) {
 		td-&gt;short_packet = 1;
-		if (urb-&gt;transfer_buffer_length != urb-&gt;actual_length &amp;&amp;
-		    urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK)
-			status = -EREMOTEIO;
 	}
 	if (usb_pipeisoc(urb-&gt;pipe)) {
 		urb-&gt;iso_frame_desc[td-&gt;iso_cnt].actual_length = size;
@@ -1214,7 +1209,7 @@ static void packet_read(struct r8a66597 *r8a66597, u16 pipenum)
 	}
 
 	/* check transfer finish */
-	if (check_transfer_finish(td, urb)) {
+	if (finish || check_transfer_finish(td, urb)) {
 		pipe_stop(r8a66597, td-&gt;pipe);
 		pipe_irq_disable(r8a66597, pipenum);
 		finish = 1;
diff --git a/drivers/usb/host/sl811-hcd.c b/drivers/usb/host/sl811-hcd.c
index 15a93f946afd..e90953a9c9fb 100644
--- a/drivers/usb/host/sl811-hcd.c
+++ b/drivers/usb/host/sl811-hcd.c
@@ -438,7 +438,6 @@ static void finish_request(
 	spin_lock(&amp;urb-&gt;lock);
 	if (urb-&gt;status == -EINPROGRESS)
 		urb-&gt;status = status;
-	urb-&gt;hcpriv = NULL;
 	spin_unlock(&amp;urb-&gt;lock);
 
 	usb_hcd_unlink_urb_from_ep(sl811_to_hcd(sl811), urb);
@@ -545,17 +544,10 @@ done(struct sl811 *sl811, struct sl811h_ep *ep, u8 bank)
 			sl811_read_buf(sl811, SL811HS_PACKET_BUF(bank == 0),
 					buf, len);
 			usb_dotoggle(udev, ep-&gt;epnum, 0);
-			if (urb-&gt;actual_length == urb-&gt;transfer_buffer_length)
+			if (urb-&gt;actual_length == urb-&gt;transfer_buffer_length
+					|| len &lt; ep-&gt;maxpacket)
 				urbstat = 0;
-			else if (len &lt; ep-&gt;maxpacket) {
-				if (urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK)
-					urbstat = -EREMOTEIO;
-				else
-					urbstat = 0;
-			}
-			if (usb_pipecontrol(urb-&gt;pipe)
-					&amp;&amp; (urbstat == -EREMOTEIO
-						|| urbstat == 0)) {
+			if (usb_pipecontrol(urb-&gt;pipe) &amp;&amp; urbstat == 0) {
 
 				/* NOTE if the status stage STALLs (why?),
 				 * this reports the wrong urb status.
diff --git a/drivers/usb/host/u132-hcd.c b/drivers/usb/host/u132-hcd.c
index c87660b5edc3..1381275d448f 100644
--- a/drivers/usb/host/u132-hcd.c
+++ b/drivers/usb/host/u132-hcd.c
@@ -519,7 +519,6 @@ static void u132_hcd_giveback_urb(struct u132 *u132, struct u132_endp *endp,
         struct usb_hcd *hcd = u132_to_hcd(u132);
         urb-&gt;error_count = 0;
         urb-&gt;status = status;
-        urb-&gt;hcpriv = NULL;
         spin_lock_irqsave(&amp;endp-&gt;queue_lock.slock, irqs);
 	usb_hcd_unlink_urb_from_ep(hcd, urb);
         endp-&gt;queue_next += 1;
@@ -560,7 +559,6 @@ static void u132_hcd_abandon_urb(struct u132 *u132, struct u132_endp *endp,
         struct usb_hcd *hcd = u132_to_hcd(u132);
         urb-&gt;error_count = 0;
         urb-&gt;status = status;
-        urb-&gt;hcpriv = NULL;
         spin_lock_irqsave(&amp;endp-&gt;queue_lock.slock, irqs);
 	usb_hcd_unlink_urb_from_ep(hcd, urb);
         endp-&gt;queue_next += 1;
@@ -2430,7 +2428,6 @@ static int dequeue_from_overflow_chain(struct u132 *u132,
                         list_del(scan);
                         endp-&gt;queue_size -= 1;
                         urb-&gt;error_count = 0;
-                        urb-&gt;hcpriv = NULL;
                         usb_hcd_giveback_urb(hcd, urb);
                         return 0;
                 } else
@@ -2472,7 +2469,6 @@ static int u132_endp_urb_dequeue(struct u132 *u132, struct u132_endp *endp,
                         endp-&gt;edset_flush = 1;
                         u132_endp_queue_work(u132, endp, 0);
                         spin_unlock_irqrestore(&amp;endp-&gt;queue_lock.slock, irqs);
-                        urb-&gt;hcpriv = NULL;
                         return 0;
                 } else {
                         spin_unlock_irqrestore(&amp;endp-&gt;queue_lock.slock, irqs);
@@ -2517,7 +2513,6 @@ static int u132_endp_urb_dequeue(struct u132 *u132, struct u132_endp *endp,
                                         irqs);
                                 kfree(urbq);
                         } urb-&gt;error_count = 0;
-                        urb-&gt;hcpriv = NULL;
                         usb_hcd_giveback_urb(hcd, urb);
                         return 0;
                 } else if (list_empty(&amp;endp-&gt;urb_more)) {
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 793a04685ef4..fbc3af392c26 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -757,7 +757,6 @@ static void uhci_free_urb_priv(struct uhci_hcd *uhci,
 		uhci_free_td(uhci, td);
 	}
 
-	urbp-&gt;urb-&gt;hcpriv = NULL;
 	kmem_cache_free(uhci_up_cachep, urbp);
 }
 
@@ -1494,13 +1493,6 @@ __acquires(uhci-&gt;lock)
 		 * unlinked first.  Regardless, don't confuse people with a
 		 * negative length. */
 		urb-&gt;actual_length = max(urb-&gt;actual_length, 0);
-
-		/* Report erroneous short transfers */
-		if (unlikely((urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK) &amp;&amp;
-				urb-&gt;actual_length &lt;
-					urb-&gt;transfer_buffer_length &amp;&amp;
-				urb-&gt;status == 0))
-			urb-&gt;status = -EREMOTEIO;
 	}
 
 	/* When giving back the first URB in an Isochronous queue,</pre><hr><pre>commit ee7d1f3f0c32d8abe9627aa73dc62ee5bf2daf7f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Aug 21 15:37:50 2007 -0400

    USB: remove Iso status value in uhci-hcd
    
    This patch (968) changes the way uhci-hcd reports status for
    Isochronous URBs.  Until now urb-&gt;status has been set to the last
    detected error code.  But other HCDs don't do this; they leave the
    status set to 0 and report errors only in the individual iso packet
    descriptors.  So this patch removes the extra computation and makes
    uhci-hcd behave like the others.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index 1b3d23406ac4..e46d2b0203cb 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -146,7 +146,6 @@ struct uhci_qh {
 	short phase;			/* Between 0 and period-1 */
 	short load;			/* Periodic time requirement, in us */
 	unsigned int iso_frame;		/* Frame # for iso_packet_desc */
-	int iso_status;			/* Status for Isochronous URBs */
 
 	int state;			/* QH_STATE_xxx; see above */
 	int type;			/* Queue type (control, bulk, etc) */
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index bff200cb3d2e..793a04685ef4 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -1324,7 +1324,6 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb,
 	if (list_empty(&amp;qh-&gt;queue)) {
 		qh-&gt;iso_packet_desc = &amp;urb-&gt;iso_frame_desc[0];
 		qh-&gt;iso_frame = urb-&gt;start_frame;
-		qh-&gt;iso_status = 0;
 	}
 
 	qh-&gt;skel = SKEL_ISO;
@@ -1361,18 +1360,15 @@ static int uhci_result_isochronous(struct uhci_hcd *uhci, struct urb *urb)
 			qh-&gt;iso_packet_desc-&gt;actual_length = actlength;
 			qh-&gt;iso_packet_desc-&gt;status = status;
 		}
-
-		if (status) {
+		if (status)
 			urb-&gt;error_count++;
-			qh-&gt;iso_status = status;
-		}
 
 		uhci_remove_td_from_urbp(td);
 		uhci_free_td(uhci, td);
 		qh-&gt;iso_frame += qh-&gt;period;
 		++qh-&gt;iso_packet_desc;
 	}
-	return qh-&gt;iso_status;
+	return 0;
 }
 
 static int uhci_urb_enqueue(struct usb_hcd *hcd,
@@ -1517,7 +1513,6 @@ __acquires(uhci-&gt;lock)
 
 		qh-&gt;iso_packet_desc = &amp;nurb-&gt;iso_frame_desc[0];
 		qh-&gt;iso_frame = nurb-&gt;start_frame;
-		qh-&gt;iso_status = 0;
 	}
 
 	/* Take the URB off the QH's queue.  If the queue is now empty,
@@ -1586,7 +1581,7 @@ static void uhci_scan_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
 		}
 
 		uhci_giveback_urb(uhci, qh, urb);
-		if (status &lt; 0 &amp;&amp; qh-&gt;type != USB_ENDPOINT_XFER_ISOC)
+		if (status &lt; 0)
 			break;
 	}
 </pre><hr><pre>commit dfd1e53777afe1050e3a0a3f0dd063a64242b818
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Aug 21 15:36:52 2007 -0400

    USB: minor fixes for r8a66597 driver
    
    This patch (as967) makes a few relatively minor changes to the
    r8a66597 driver:
    
            finish_request() does nothing but call done(), so merge the
            two routines.
    
            Detect and report -EOVERFLOW errors.
    
            Fix the calculation that checks for short packets.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Yoshihiro Shimoda &lt;shimoda.yoshihiro@renesas.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/r8a66597-hcd.c b/drivers/usb/host/r8a66597-hcd.c
index 94bb229df3bc..49cf998c172a 100644
--- a/drivers/usb/host/r8a66597-hcd.c
+++ b/drivers/usb/host/r8a66597-hcd.c
@@ -1109,8 +1109,9 @@ static void set_td_timer(struct r8a66597 *r8a66597, struct r8a66597_td *td)
 }
 
 /* this function must be called with interrupt disabled */
-static void done(struct r8a66597 *r8a66597, struct r8a66597_td *td,
-		 u16 pipenum, struct urb *urb)
+static void finish_request(struct r8a66597 *r8a66597, struct r8a66597_td *td,
+		u16 pipenum, struct urb *urb)
+__releases(r8a66597-&gt;lock) __acquires(r8a66597-&gt;lock)
 {
 	int restart = 0;
 	struct usb_hcd *hcd = r8a66597_to_hcd(r8a66597);
@@ -1151,14 +1152,6 @@ static void done(struct r8a66597 *r8a66597, struct r8a66597_td *td,
 	}
 }
 
-/* this function must be called with interrupt disabled */
-static void finish_request(struct r8a66597 *r8a66597, struct r8a66597_td *td,
-			   u16 pipenum, struct urb *urb)
-__releases(r8a66597-&gt;lock) __acquires(r8a66597-&gt;lock)
-{
-	done(r8a66597, td, pipenum, urb);
-}
-
 static void packet_read(struct r8a66597 *r8a66597, u16 pipenum)
 {
 	u16 tmp;
@@ -1167,6 +1160,7 @@ static void packet_read(struct r8a66597 *r8a66597, u16 pipenum)
 	struct r8a66597_td *td = r8a66597_get_td(r8a66597, pipenum);
 	struct urb *urb;
 	int finish = 0;
+	int status = 0;
 
 	if (unlikely(!td))
 		return;
@@ -1185,7 +1179,6 @@ static void packet_read(struct r8a66597 *r8a66597, u16 pipenum)
 
 	/* prepare parameters */
 	rcv_len = tmp &amp; DTLN;
-	bufsize = td-&gt;maxpacket;
 	if (usb_pipeisoc(urb-&gt;pipe)) {
 		buf = (u16 *)(urb-&gt;transfer_buffer +
 				urb-&gt;iso_frame_desc[td-&gt;iso_cnt].offset);
@@ -1194,25 +1187,30 @@ static void packet_read(struct r8a66597 *r8a66597, u16 pipenum)
 		buf = (void *)urb-&gt;transfer_buffer + urb-&gt;actual_length;
 		urb_len = urb-&gt;transfer_buffer_length - urb-&gt;actual_length;
 	}
-	if (rcv_len &lt; bufsize)
-		size = min(rcv_len, urb_len);
-	else
-		size = min(bufsize, urb_len);
+	bufsize = min(urb_len, (int) td-&gt;maxpacket);
+	if (rcv_len &lt;= bufsize) {
+		size = rcv_len;
+	} else {
+		size = bufsize;
+		status = -EOVERFLOW;
+		finish = 1;
+	}
 
 	/* update parameters */
 	urb-&gt;actual_length += size;
 	if (rcv_len == 0)
 		td-&gt;zero_packet = 1;
-	if ((size % td-&gt;maxpacket) &gt; 0) {
+	if (rcv_len &lt; bufsize) {
 		td-&gt;short_packet = 1;
 		if (urb-&gt;transfer_buffer_length != urb-&gt;actual_length &amp;&amp;
 		    urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK)
-			td-&gt;urb-&gt;status = -EREMOTEIO;
+			status = -EREMOTEIO;
 	}
 	if (usb_pipeisoc(urb-&gt;pipe)) {
 		urb-&gt;iso_frame_desc[td-&gt;iso_cnt].actual_length = size;
-		urb-&gt;iso_frame_desc[td-&gt;iso_cnt].status = 0;
+		urb-&gt;iso_frame_desc[td-&gt;iso_cnt].status = status;
 		td-&gt;iso_cnt++;
+		finish = 0;
 	}
 
 	/* check transfer finish */
@@ -1233,7 +1231,7 @@ static void packet_read(struct r8a66597 *r8a66597, u16 pipenum)
 
 	if (finish &amp;&amp; pipenum != 0) {
 		if (td-&gt;urb-&gt;status == -EINPROGRESS)
-			td-&gt;urb-&gt;status = 0;
+			td-&gt;urb-&gt;status = status;
 		finish_request(r8a66597, td, pipenum, urb);
 	}
 }
@@ -1807,7 +1805,7 @@ static int r8a66597_urb_dequeue(struct usb_hcd *hcd, struct urb *urb,
 		pipe_stop(r8a66597, td-&gt;pipe);
 		pipe_irq_disable(r8a66597, td-&gt;pipenum);
 		disable_irq_empty(r8a66597, td-&gt;pipenum);
-		done(r8a66597, td, td-&gt;pipenum, urb);
+		finish_request(r8a66597, td, td-&gt;pipenum, urb);
 	}
  done:
 	spin_unlock_irqrestore(&amp;r8a66597-&gt;lock, flags);
@@ -1841,7 +1839,7 @@ static void r8a66597_endpoint_disable(struct usb_hcd *hcd,
 	td = r8a66597_get_td(r8a66597, pipenum);
 	if (td)
 		urb = td-&gt;urb;
-	done(r8a66597, td, pipenum, urb);
+	finish_request(r8a66597, td, pipenum, urb);
 	kfree(hep-&gt;hcpriv);
 	hep-&gt;hcpriv = NULL;
 	spin_unlock_irqrestore(&amp;r8a66597-&gt;lock, flags);</pre><hr><pre>commit e39ab592f182cd0be48acc4ad49f93ef4100017c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Aug 16 16:17:49 2007 -0400

    USB: remove unnecessary tests in isp116x and sl811
    
    This patch (as962) cleans up some code I forgot to remove earlier in
    the isp116x and sl811 HCDs.  There is no longer any need to check for
    unlink-during-submit; it can't happen since the endpoint queues are
    now under the protection of the HCD-private spinlock.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    CC: Olav Kongas &lt;ok@artecdesign.ee&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/isp116x-hcd.c b/drivers/usb/host/isp116x-hcd.c
index d5027dc75a57..f2b5d6281c5d 100644
--- a/drivers/usb/host/isp116x-hcd.c
+++ b/drivers/usb/host/isp116x-hcd.c
@@ -815,12 +815,6 @@ static int isp116x_urb_enqueue(struct usb_hcd *hcd,
 		}
 	}
 
-	/* in case of unlink-during-submit */
-	if (urb-&gt;status != -EINPROGRESS) {
-		finish_request(isp116x, ep, urb);
-		ret = 0;
-		goto fail;
-	}
 	urb-&gt;hcpriv = hep;
 	start_atl_transfers(isp116x);
 
diff --git a/drivers/usb/host/sl811-hcd.c b/drivers/usb/host/sl811-hcd.c
index 3d3a63d002c5..15a93f946afd 100644
--- a/drivers/usb/host/sl811-hcd.c
+++ b/drivers/usb/host/sl811-hcd.c
@@ -957,17 +957,7 @@ static int sl811h_urb_enqueue(
 		sofirq_on(sl811);
 	}
 
-	/* in case of unlink-during-submit */
-	spin_lock(&amp;urb-&gt;lock);
-	if (urb-&gt;status != -EINPROGRESS) {
-		spin_unlock(&amp;urb-&gt;lock);
-		finish_request(sl811, ep, urb, 0);
-		retval = 0;
-		goto fail;
-	}
 	urb-&gt;hcpriv = hep;
-	spin_unlock(&amp;urb-&gt;lock);
-
 	start_transfer(sl811);
 	sl811_write(sl811, SL11H_IRQ_ENABLE, sl811-&gt;irq_enable);
 fail:</pre>
    <div class="pagination">
        <a href='2_100.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><span>[101]</span><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_102.html'>Next&gt;&gt;</a>
    <div>
</body>
