<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_27.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><span>[28]</span><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_29.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit b6089f19fe0cec625b5963a851a07c3e412c27c8
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 2 15:42:18 2014 -0400

    USB: document the 'u' flag for usb-storage quirks parameter
    
    Commit d24d481b7d36 (usb-storage: Modify and export adjust_quirks so
    that it can be used by uas) added the 'u' flag to the quirks module
    parameter for usb-storage, but neglected to update the
    documentation.  This patch adds the documentation.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;  # 3.15+
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt
index 5ae8608ca9f5..10d51c2f10d7 100644
--- a/Documentation/kernel-parameters.txt
+++ b/Documentation/kernel-parameters.txt
@@ -3541,6 +3541,7 @@ bytes respectively. Such letter suffixes can also be entirely omitted.
 					bogus residue values);
 				s = SINGLE_LUN (the device has only one
 					Logical Unit);
+				u = IGNORE_UAS (don't bind to the uas driver);
 				w = NO_WP_DETECT (don't test whether the
 					medium is write-protected).
 			Example: quirks=0419:aaf5:rl,0421:0433:rc</pre><hr><pre>commit 8f507ef522d55a6e2f9e11a1c1163a92756da044
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 2 11:39:15 2014 -0400

    HID: usbhid: improve handling of Clear-Halt and reset
    
    This patch changes the way usbhid carries out Clear-Halt and reset.
    
    Currently, after a Clear-Halt on the interrupt-IN endpoint, the driver
    immediately restarts the interrupt URB, even if the Clear-Halt failed.
    This doesn't work out well when the reason for the failure was that
    the device was disconnected (when a low- or full-speed device is
    connected through a hub to an EHCI controller, transfer errors caused
    by disconnection are reported as stalls by the hub).  Instead now the
    driver will attempt a reset after a failed Clear-Halt.
    
    The way resets are carried out is also changed.  Now the driver will
    call usb_queue_reset_device() instead of calling usb_reset_device()
    directly.  This avoids a deadlock that would arise when a device is
    unplugged: The hid_reset() routine runs as a workqueue item, a reset
    attempt after the device has been unplugged will fail, failure will
    cause usbhid to be unbound, and the disconnect routine will try to do
    cancel_work_sync().  The usb_queue_reset_device() implementation is
    carefully written to handle scenarios like this one properly.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c
index 79cf503e37bf..80c50763b3f8 100644
--- a/drivers/hid/usbhid/hid-core.c
+++ b/drivers/hid/usbhid/hid-core.c
@@ -116,40 +116,24 @@ static void hid_reset(struct work_struct *work)
 	struct usbhid_device *usbhid =
 		container_of(work, struct usbhid_device, reset_work);
 	struct hid_device *hid = usbhid-&gt;hid;
-	int rc = 0;
+	int rc;
 
 	if (test_bit(HID_CLEAR_HALT, &amp;usbhid-&gt;iofl)) {
 		dev_dbg(&amp;usbhid-&gt;intf-&gt;dev, "clear halt\n");
 		rc = usb_clear_halt(hid_to_usb_dev(hid), usbhid-&gt;urbin-&gt;pipe);
 		clear_bit(HID_CLEAR_HALT, &amp;usbhid-&gt;iofl);
-		hid_start_in(hid);
-	}
-
-	else if (test_bit(HID_RESET_PENDING, &amp;usbhid-&gt;iofl)) {
-		dev_dbg(&amp;usbhid-&gt;intf-&gt;dev, "resetting device\n");
-		rc = usb_lock_device_for_reset(hid_to_usb_dev(hid), usbhid-&gt;intf);
 		if (rc == 0) {
-			rc = usb_reset_device(hid_to_usb_dev(hid));
-			usb_unlock_device(hid_to_usb_dev(hid));
+			hid_start_in(hid);
+		} else {
+			dev_dbg(&amp;usbhid-&gt;intf-&gt;dev,
+					"clear-halt failed: %d\n", rc);
+			set_bit(HID_RESET_PENDING, &amp;usbhid-&gt;iofl);
 		}
-		clear_bit(HID_RESET_PENDING, &amp;usbhid-&gt;iofl);
 	}
 
-	switch (rc) {
-	case 0:
-		if (!test_bit(HID_IN_RUNNING, &amp;usbhid-&gt;iofl))
-			hid_io_error(hid);
-		break;
-	default:
-		hid_err(hid, "can't reset device, %s-%s/input%d, status %d\n",
-			hid_to_usb_dev(hid)-&gt;bus-&gt;bus_name,
-			hid_to_usb_dev(hid)-&gt;devpath,
-			usbhid-&gt;ifnum, rc);
-		/* FALLTHROUGH */
-	case -EHOSTUNREACH:
-	case -ENODEV:
-	case -EINTR:
-		break;
+	if (test_bit(HID_RESET_PENDING, &amp;usbhid-&gt;iofl)) {
+		dev_dbg(&amp;usbhid-&gt;intf-&gt;dev, "resetting device\n");
+		usb_queue_reset_device(usbhid-&gt;intf);
 	}
 }
 </pre><hr><pre>commit 499b3803d3e2f062f73bf22372b38393369ffcbf
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jul 18 16:26:17 2014 -0400

    USB: OHCI: add check for stopped frame counter
    
    This patch adds an extra check to ohci-hcd's I/O watchdog routine.  If
    the controller stops updating the frame counter, we will assume it is
    dead.  But there has to be an exception: Some controllers stop the
    frame counter when no ports are connected.  Check to make sure there
    is at least one active port before deciding the controller is dead.
    
    (This test may appear racy, but it isn't.  Enabling a newly connected
    port takes several milliseconds, during which time the frame counter
    must advance.)
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Dennis New &lt;dennisn@dennisn.linuxd.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index aba8f19eae4d..46987735a2e3 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -72,7 +72,7 @@
 static const char	hcd_name [] = "ohci_hcd";
 
 #define	STATECHANGE_DELAY	msecs_to_jiffies(300)
-#define IO_WATCHDOG_DELAY	msecs_to_jiffies(250)
+#define	IO_WATCHDOG_DELAY	msecs_to_jiffies(250)
 
 #include "ohci.h"
 #include "pci-quirks.h"
@@ -230,9 +230,11 @@ static int ohci_urb_enqueue (
 
 		/* Start up the I/O watchdog timer, if it's not running */
 		if (!timer_pending(&amp;ohci-&gt;io_watchdog) &amp;&amp;
-				list_empty(&amp;ohci-&gt;eds_in_use))
+				list_empty(&amp;ohci-&gt;eds_in_use)) {
+			ohci-&gt;prev_frame_no = ohci_frame_no(ohci);
 			mod_timer(&amp;ohci-&gt;io_watchdog,
 					jiffies + IO_WATCHDOG_DELAY);
+		}
 		list_add(&amp;ed-&gt;in_use_list, &amp;ohci-&gt;eds_in_use);
 
 		if (ed-&gt;type == PIPE_ISOCHRONOUS) {
@@ -727,6 +729,7 @@ static void io_watchdog_func(unsigned long _ohci)
 	u32		head;
 	struct ed	*ed;
 	struct td	*td, *td_start, *td_next;
+	unsigned	frame_no;
 	unsigned long	flags;
 
 	spin_lock_irqsave(&amp;ohci-&gt;lock, flags);
@@ -742,6 +745,7 @@ static void io_watchdog_func(unsigned long _ohci)
 	if (!(status &amp; OHCI_INTR_WDH) &amp;&amp; ohci-&gt;wdh_cnt == ohci-&gt;prev_wdh_cnt) {
 		if (ohci-&gt;prev_donehead) {
 			ohci_err(ohci, "HcDoneHead not written back; disabled\n");
+ died:
 			usb_hc_died(ohci_to_hcd(ohci));
 			ohci_dump(ohci);
 			ohci_shutdown(ohci_to_hcd(ohci));
@@ -802,7 +806,35 @@ static void io_watchdog_func(unsigned long _ohci)
 	ohci_work(ohci);
 
 	if (ohci-&gt;rh_state == OHCI_RH_RUNNING) {
+
+		/*
+		 * Sometimes a controller just stops working.  We can tell
+		 * by checking that the frame counter has advanced since
+		 * the last time we ran.
+		 *
+		 * But be careful: Some controllers violate the spec by
+		 * stopping their frame counter when no ports are active.
+		 */
+		frame_no = ohci_frame_no(ohci);
+		if (frame_no == ohci-&gt;prev_frame_no) {
+			int		active_cnt = 0;
+			int		i;
+			unsigned	tmp;
+
+			for (i = 0; i &lt; ohci-&gt;num_ports; ++i) {
+				tmp = roothub_portstatus(ohci, i);
+				/* Enabled and not suspended? */
+				if ((tmp &amp; RH_PS_PES) &amp;&amp; !(tmp &amp; RH_PS_PSS))
+					++active_cnt;
+			}
+
+			if (active_cnt &gt; 0) {
+				ohci_err(ohci, "frame counter not updating; disabled\n");
+				goto died;
+			}
+		}
 		if (!list_empty(&amp;ohci-&gt;eds_in_use)) {
+			ohci-&gt;prev_frame_no = frame_no;
 			ohci-&gt;prev_wdh_cnt = ohci-&gt;wdh_cnt;
 			ohci-&gt;prev_donehead = ohci_readl(ohci,
 					&amp;ohci-&gt;regs-&gt;donehead);
diff --git a/drivers/usb/host/ohci.h b/drivers/usb/host/ohci.h
index 0548f5ca18e2..59f424567a8d 100644
--- a/drivers/usb/host/ohci.h
+++ b/drivers/usb/host/ohci.h
@@ -421,6 +421,7 @@ struct ohci_hcd {
 
 	// there are also chip quirks/bugs in init logic
 
+	unsigned		prev_frame_no;
 	unsigned		wdh_cnt, prev_wdh_cnt;
 	u32			prev_donehead;
 	struct timer_list	io_watchdog;</pre><hr><pre>commit 81e38333513cec155c720432226dabe9f9f76a77
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jul 18 16:26:12 2014 -0400

    USB: OHCI: add I/O watchdog for orphan TDs
    
    Some OHCI controllers have a bug: They fail to add completed TDs to
    the done queue.  Examining this queue is the only method ohci-hcd has
    for telling when a transfer is complete; failure to add a TD can
    result in an URB that never completes and cannot be unlinked.
    
    This patch adds a watchdog routine to ohci-hcd.  The routine
    periodically scans the active ED and TD lists, looking for TDs which
    are finished but not on the done queue.  When one is found, and it is
    certain that the controller hardware will never add the TD to the done
    queue, the watchdog routine manually puts the TD on the done list so
    that it can be handled normally.
    
    The watchdog routine also checks for a condition indicating the
    controller has died.  If the done queue is non-empty but the
    HccaDoneHead pointer hasn't been updated for a few hundred
    milliseconds, we assume the controller will never update it and
    therefore is dead.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index ad588538e2e7..aba8f19eae4d 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -72,12 +72,14 @@
 static const char	hcd_name [] = "ohci_hcd";
 
 #define	STATECHANGE_DELAY	msecs_to_jiffies(300)
+#define IO_WATCHDOG_DELAY	msecs_to_jiffies(250)
 
 #include "ohci.h"
 #include "pci-quirks.h"
 
 static void ohci_dump(struct ohci_hcd *ohci);
 static void ohci_stop(struct usb_hcd *hcd);
+static void io_watchdog_func(unsigned long _ohci);
 
 #include "ohci-hub.c"
 #include "ohci-dbg.c"
@@ -225,6 +227,14 @@ static int ohci_urb_enqueue (
 			usb_hcd_unlink_urb_from_ep(hcd, urb);
 			goto fail;
 		}
+
+		/* Start up the I/O watchdog timer, if it's not running */
+		if (!timer_pending(&amp;ohci-&gt;io_watchdog) &amp;&amp;
+				list_empty(&amp;ohci-&gt;eds_in_use))
+			mod_timer(&amp;ohci-&gt;io_watchdog,
+					jiffies + IO_WATCHDOG_DELAY);
+		list_add(&amp;ed-&gt;in_use_list, &amp;ohci-&gt;eds_in_use);
+
 		if (ed-&gt;type == PIPE_ISOCHRONOUS) {
 			u16	frame = ohci_frame_no(ohci);
 
@@ -416,6 +426,7 @@ ohci_shutdown (struct usb_hcd *hcd)
 	udelay(10);
 
 	ohci_writel(ohci, ohci-&gt;fminterval, &amp;ohci-&gt;regs-&gt;fminterval);
+	ohci-&gt;rh_state = OHCI_RH_HALTED;
 }
 
 /*-------------------------------------------------------------------------*
@@ -484,6 +495,10 @@ static int ohci_init (struct ohci_hcd *ohci)
 	if (ohci-&gt;hcca)
 		return 0;
 
+	setup_timer(&amp;ohci-&gt;io_watchdog, io_watchdog_func,
+			(unsigned long) ohci);
+	set_timer_slack(&amp;ohci-&gt;io_watchdog, msecs_to_jiffies(20));
+
 	ohci-&gt;hcca = dma_alloc_coherent (hcd-&gt;self.controller,
 			sizeof(*ohci-&gt;hcca), &amp;ohci-&gt;hcca_dma, GFP_KERNEL);
 	if (!ohci-&gt;hcca)
@@ -694,6 +709,112 @@ static int ohci_start(struct usb_hcd *hcd)
 
 /*-------------------------------------------------------------------------*/
 
+/*
+ * Some OHCI controllers are known to lose track of completed TDs.  They
+ * don't add the TDs to the hardware done queue, which means we never see
+ * them as being completed.
+ *
+ * This watchdog routine checks for such problems.  Without some way to
+ * tell when those TDs have completed, we would never take their EDs off
+ * the unlink list.  As a result, URBs could never be dequeued and
+ * endpoints could never be released.
+ */
+static void io_watchdog_func(unsigned long _ohci)
+{
+	struct ohci_hcd	*ohci = (struct ohci_hcd *) _ohci;
+	bool		takeback_all_pending = false;
+	u32		status;
+	u32		head;
+	struct ed	*ed;
+	struct td	*td, *td_start, *td_next;
+	unsigned long	flags;
+
+	spin_lock_irqsave(&amp;ohci-&gt;lock, flags);
+
+	/*
+	 * One way to lose track of completed TDs is if the controller
+	 * never writes back the done queue head.  If it hasn't been
+	 * written back since the last time this function ran and if it
+	 * was non-empty at that time, something is badly wrong with the
+	 * hardware.
+	 */
+	status = ohci_readl(ohci, &amp;ohci-&gt;regs-&gt;intrstatus);
+	if (!(status &amp; OHCI_INTR_WDH) &amp;&amp; ohci-&gt;wdh_cnt == ohci-&gt;prev_wdh_cnt) {
+		if (ohci-&gt;prev_donehead) {
+			ohci_err(ohci, "HcDoneHead not written back; disabled\n");
+			usb_hc_died(ohci_to_hcd(ohci));
+			ohci_dump(ohci);
+			ohci_shutdown(ohci_to_hcd(ohci));
+			goto done;
+		} else {
+			/* No write back because the done queue was empty */
+			takeback_all_pending = true;
+		}
+	}
+
+	/* Check every ED which might have pending TDs */
+	list_for_each_entry(ed, &amp;ohci-&gt;eds_in_use, in_use_list) {
+		if (ed-&gt;pending_td) {
+			if (takeback_all_pending ||
+					OKAY_TO_TAKEBACK(ohci, ed)) {
+				unsigned tmp = hc32_to_cpu(ohci, ed-&gt;hwINFO);
+
+				ohci_dbg(ohci, "takeback pending TD for dev %d ep 0x%x\n",
+						0x007f &amp; tmp,
+						(0x000f &amp; (tmp &gt;&gt; 7)) +
+							((tmp &amp; ED_IN) &gt;&gt; 5));
+				add_to_done_list(ohci, ed-&gt;pending_td);
+			}
+		}
+
+		/* Starting from the latest pending TD, */
+		td = ed-&gt;pending_td;
+
+		/* or the last TD on the done list, */
+		if (!td) {
+			list_for_each_entry(td_next, &amp;ed-&gt;td_list, td_list) {
+				if (!td_next-&gt;next_dl_td)
+					break;
+				td = td_next;
+			}
+		}
+
+		/* find the last TD processed by the controller. */
+		head = hc32_to_cpu(ohci, ACCESS_ONCE(ed-&gt;hwHeadP)) &amp; TD_MASK;
+		td_start = td;
+		td_next = list_prepare_entry(td, &amp;ed-&gt;td_list, td_list);
+		list_for_each_entry_continue(td_next, &amp;ed-&gt;td_list, td_list) {
+			if (head == (u32) td_next-&gt;td_dma)
+				break;
+			td = td_next;	/* head pointer has passed this TD */
+		}
+		if (td != td_start) {
+			/*
+			 * In case a WDH cycle is in progress, we will wait
+			 * for the next two cycles to complete before assuming
+			 * this TD will never get on the done queue.
+			 */
+			ed-&gt;takeback_wdh_cnt = ohci-&gt;wdh_cnt + 2;
+			ed-&gt;pending_td = td;
+		}
+	}
+
+	ohci_work(ohci);
+
+	if (ohci-&gt;rh_state == OHCI_RH_RUNNING) {
+		if (!list_empty(&amp;ohci-&gt;eds_in_use)) {
+			ohci-&gt;prev_wdh_cnt = ohci-&gt;wdh_cnt;
+			ohci-&gt;prev_donehead = ohci_readl(ohci,
+					&amp;ohci-&gt;regs-&gt;donehead);
+			mod_timer(&amp;ohci-&gt;io_watchdog,
+					jiffies + IO_WATCHDOG_DELAY);
+		}
+	}
+
+ done:
+	spin_unlock_irqrestore(&amp;ohci-&gt;lock, flags);
+}
+
 /* an interrupt happens */
 
 static irqreturn_t ohci_irq (struct usb_hcd *hcd)
@@ -796,6 +917,9 @@ static irqreturn_t ohci_irq (struct usb_hcd *hcd)
 
 	if (ohci-&gt;rh_state == OHCI_RH_RUNNING) {
 		ohci_writel (ohci, ints, &amp;regs-&gt;intrstatus);
+		if (ints &amp; OHCI_INTR_WDH)
+			++ohci-&gt;wdh_cnt;
+
 		ohci_writel (ohci, OHCI_INTR_MIE, &amp;regs-&gt;intrenable);
 		// flush those writes
 		(void) ohci_readl (ohci, &amp;ohci-&gt;regs-&gt;control);
@@ -815,6 +939,7 @@ static void ohci_stop (struct usb_hcd *hcd)
 
 	if (quirk_nec(ohci))
 		flush_work(&amp;ohci-&gt;nec_work);
+	del_timer_sync(&amp;ohci-&gt;io_watchdog);
 
 	ohci_writel (ohci, OHCI_INTR_MIE, &amp;ohci-&gt;regs-&gt;intrdisable);
 	ohci_usb_reset(ohci);
diff --git a/drivers/usb/host/ohci-hub.c b/drivers/usb/host/ohci-hub.c
index 8991692bcfb8..17d32b0ea565 100644
--- a/drivers/usb/host/ohci-hub.c
+++ b/drivers/usb/host/ohci-hub.c
@@ -309,6 +309,9 @@ static int ohci_bus_suspend (struct usb_hcd *hcd)
 	else
 		rc = ohci_rh_suspend (ohci, 0);
 	spin_unlock_irq (&amp;ohci-&gt;lock);
+
+	if (rc == 0)
+		del_timer_sync(&amp;ohci-&gt;io_watchdog);
 	return rc;
 }
 
diff --git a/drivers/usb/host/ohci-mem.c b/drivers/usb/host/ohci-mem.c
index 2f20d3dc895b..c9e315c6808a 100644
--- a/drivers/usb/host/ohci-mem.c
+++ b/drivers/usb/host/ohci-mem.c
@@ -28,6 +28,7 @@ static void ohci_hcd_init (struct ohci_hcd *ohci)
 	ohci-&gt;next_statechange = jiffies;
 	spin_lock_init (&amp;ohci-&gt;lock);
 	INIT_LIST_HEAD (&amp;ohci-&gt;pending);
+	INIT_LIST_HEAD(&amp;ohci-&gt;eds_in_use);
 }
 
 /*-------------------------------------------------------------------------*/
diff --git a/drivers/usb/host/ohci-q.c b/drivers/usb/host/ohci-q.c
index 1974ddc68e45..1463c398d322 100644
--- a/drivers/usb/host/ohci-q.c
+++ b/drivers/usb/host/ohci-q.c
@@ -921,6 +921,11 @@ static void add_to_done_list(struct ohci_hcd *ohci, struct td *td)
 	 * that td is on the done list.
 	 */
 	ohci-&gt;dl_end = td-&gt;next_dl_td = td;
+
+	/* Did we just add the latest pending TD? */
+	td2 = ed-&gt;pending_td;
+	if (td2 &amp;&amp; td2-&gt;next_dl_td)
+		ed-&gt;pending_td = NULL;
 }
 
 /* Get the entries on the hardware done queue and put them on our list */
@@ -1082,6 +1087,7 @@ static void finish_unlinks(struct ohci_hcd *ohci)
 		if (list_empty(&amp;ed-&gt;td_list)) {
 			*last = ed-&gt;ed_next;
 			ed-&gt;ed_next = NULL;
+			list_del(&amp;ed-&gt;in_use_list);
 		} else if (ohci-&gt;rh_state == OHCI_RH_RUNNING) {
 			*last = ed-&gt;ed_next;
 			ed-&gt;ed_next = NULL;
diff --git a/drivers/usb/host/ohci.h b/drivers/usb/host/ohci.h
index ef348c2e1e4b..0548f5ca18e2 100644
--- a/drivers/usb/host/ohci.h
+++ b/drivers/usb/host/ohci.h
@@ -47,6 +47,7 @@ struct ed {
 	struct ed		*ed_next;	/* on schedule or rm_list */
 	struct ed		*ed_prev;	/* for non-interrupt EDs */
 	struct list_head	td_list;	/* "shadow list" of our TDs */
+	struct list_head	in_use_list;
 
 	/* create --&gt; IDLE --&gt; OPER --&gt; ... --&gt; IDLE --&gt; destroy
 	 * usually:  OPER --&gt; UNLINK --&gt; (IDLE | OPER) --&gt; ...
@@ -66,6 +67,13 @@ struct ed {
 
 	/* HC may see EDs on rm_list until next frame (frame_no == tick) */
 	u16			tick;
+
+	/* Detect TDs not added to the done queue */
+	unsigned		takeback_wdh_cnt;
+	struct td		*pending_td;
+#define	OKAY_TO_TAKEBACK(ohci, ed)			\
+		((int) (ohci-&gt;wdh_cnt - ed-&gt;takeback_wdh_cnt) &gt;= 0)
+
 } __attribute__ ((aligned(16)));
 
 #define ED_MASK	((u32)~0x0f)		/* strip hw status in low addr bits */
@@ -382,6 +390,7 @@ struct ohci_hcd {
 	struct td		*td_hash [TD_HASH_SIZE];
 	struct td		*dl_start, *dl_end;	/* the done list */
 	struct list_head	pending;
+	struct list_head	eds_in_use;	/* all EDs with at least 1 TD */
 
 	/*
 	 * driver state
@@ -412,6 +421,10 @@ struct ohci_hcd {
 
 	// there are also chip quirks/bugs in init logic
 
+	unsigned		wdh_cnt, prev_wdh_cnt;
+	u32			prev_donehead;
+	struct timer_list	io_watchdog;
+
 	struct work_struct	nec_work;	/* Worker for NEC quirk */
 
 	struct dentry		*debug_dir;</pre><hr><pre>commit cdb4dd15e62eb984d9461b520d15d00ff2b88d9d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jul 18 16:26:07 2014 -0400

    USB: OHCI: make URB completions single-threaded
    
    URBs for a particular endpoint should complete sequentially.  That is,
    we shouldn't call the completion handler for one URB until the handler
    for the previous URB has returned.
    
    When the OHCI watchdog routine is added, there will be two paths for
    completing URBs: interrupt handler and watchdog routine.  Their
    activities have to be synchronized so that completions don't occur in
    multiple threads concurrently.
    
    For that purpose, this patch creates an ohci_work() routine which will
    be responsible for calling process_done_list() and finish_unlinks(),
    the two routines that detect when an URB is complete.  Everything will
    funnel through ohci_work(), and it will be careful not to run in more
    than one thread at a time.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index 3112799bba7f..ad588538e2e7 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -316,7 +316,7 @@ static int ohci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 
 		if (ohci-&gt;rh_state != OHCI_RH_RUNNING) {
 			/* With HC dead, we can clean up right away */
-			finish_unlinks(ohci, 0);
+			ohci_work(ohci);
 		}
 	}
 	spin_unlock_irqrestore (&amp;ohci-&gt;lock, flags);
@@ -349,7 +349,7 @@ ohci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 	if (ohci-&gt;rh_state != OHCI_RH_RUNNING) {
 sanitize:
 		ed-&gt;state = ED_IDLE;
-		finish_unlinks (ohci, 0);
+		ohci_work(ohci);
 	}
 
 	switch (ed-&gt;state) {
@@ -789,9 +789,7 @@ static irqreturn_t ohci_irq (struct usb_hcd *hcd)
 	/* handle any pending URB/ED unlinks, leaving INTR_SF enabled
 	 * when there's still unlinking to be done (next frame).
 	 */
-	process_done_list(ohci);
-	if (ohci-&gt;ed_rm_list)
-		finish_unlinks (ohci, ohci_frame_no(ohci));
+	ohci_work(ohci);
 	if ((ints &amp; OHCI_INTR_SF) != 0 &amp;&amp; !ohci-&gt;ed_rm_list
 			&amp;&amp; ohci-&gt;rh_state == OHCI_RH_RUNNING)
 		ohci_writel (ohci, OHCI_INTR_SF, &amp;regs-&gt;intrdisable);
@@ -879,7 +877,7 @@ int ohci_restart(struct ohci_hcd *ohci)
 		if (!urb-&gt;unlinked)
 			urb-&gt;unlinked = -ESHUTDOWN;
 	}
-	finish_unlinks (ohci, 0);
+	ohci_work(ohci);
 	spin_unlock_irq(&amp;ohci-&gt;lock);
 
 	/* paranoia, in case that didn't work: */
diff --git a/drivers/usb/host/ohci-hub.c b/drivers/usb/host/ohci-hub.c
index dccb90edd66e..8991692bcfb8 100644
--- a/drivers/usb/host/ohci-hub.c
+++ b/drivers/usb/host/ohci-hub.c
@@ -40,8 +40,7 @@
 	(OHCI_CTRL_CLE|OHCI_CTRL_BLE|OHCI_CTRL_PLE|OHCI_CTRL_IE)
 
 static void update_done_list(struct ohci_hcd *);
-static void process_done_list(struct ohci_hcd *);
-static void finish_unlinks (struct ohci_hcd *, u16);
+static void ohci_work(struct ohci_hcd *);
 
 #ifdef	CONFIG_PM
 static int ohci_rh_suspend (struct ohci_hcd *ohci, int autostop)
@@ -89,8 +88,7 @@ __acquires(ohci-&gt;lock)
 		spin_lock_irq (&amp;ohci-&gt;lock);
 	}
 	update_done_list(ohci);
-	process_done_list(ohci);
-	finish_unlinks (ohci, ohci_frame_no(ohci));
+	ohci_work(ohci);
 
 	/*
 	 * Some controllers don't handle "global" suspend properly if
diff --git a/drivers/usb/host/ohci-q.c b/drivers/usb/host/ohci-q.c
index f36b2fa0ee2f..1974ddc68e45 100644
--- a/drivers/usb/host/ohci-q.c
+++ b/drivers/usb/host/ohci-q.c
@@ -964,9 +964,9 @@ static void update_done_list(struct ohci_hcd *ohci)
 /*-------------------------------------------------------------------------*/
 
 /* there are some urbs/eds to unlink; called in_irq(), with HCD locked */
-static void
-finish_unlinks (struct ohci_hcd *ohci, u16 tick)
+static void finish_unlinks(struct ohci_hcd *ohci)
 {
+	unsigned	tick = ohci_frame_no(ohci);
 	struct ed	*ed, **last;
 
 rescan_all:
@@ -1202,3 +1202,27 @@ static void process_done_list(struct ohci_hcd *ohci)
 		takeback_td(ohci, td);
 	}
 }
+
+/*
+ * TD takeback and URB giveback must be single-threaded.
+ * This routine takes care of it all.
+ */
+static void ohci_work(struct ohci_hcd *ohci)
+{
+	if (ohci-&gt;working) {
+		ohci-&gt;restart_work = 1;
+		return;
+	}
+	ohci-&gt;working = 1;
+
+ restart:
+	process_done_list(ohci);
+	if (ohci-&gt;ed_rm_list)
+		finish_unlinks(ohci);
+
+	if (ohci-&gt;restart_work) {
+		ohci-&gt;restart_work = 0;
+		goto restart;
+	}
+	ohci-&gt;working = 0;
+}
diff --git a/drivers/usb/host/ohci.h b/drivers/usb/host/ohci.h
index a8259bc6fd8b..ef348c2e1e4b 100644
--- a/drivers/usb/host/ohci.h
+++ b/drivers/usb/host/ohci.h
@@ -393,6 +393,8 @@ struct ohci_hcd {
 	unsigned long		next_statechange;	/* suspend/resume */
 	u32			fminterval;		/* saved register */
 	unsigned		autostop:1;	/* rh auto stopping/stopped */
+	unsigned		working:1;
+	unsigned		restart_work:1;
 
 	unsigned long		flags;		/* for HC bugs */
 #define	OHCI_QUIRK_AMD756	0x01			/* erratum #4 */</pre><hr><pre>commit c6fcb85ea22889527ee44aba42c3e3b479fd2d92
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jul 18 16:25:59 2014 -0400

    USB: OHCI: redesign the TD done list
    
    This patch changes the way ohci-hcd handles the TD done list.  In
    addition to relying on the TD pointers stored by the controller
    hardware, we need to handle TDs that the hardware has forgotten about.
    
    This means the list has to exist even while the dl_done_list() routine
    isn't running.  That function essentially gets split in two:
    update_done_list() reads the TD pointers stored by the hardware and
    adds the TDs to the done list, and process_done_list() scans through
    the list to handle URB completions.  When we detect a TD that the
    hardware forgot about, we will be able to add it to the done list
    manually and then process it normally.
    
    Since the list is really a queue, and because there can be a lot of
    TDs, keep the existing singly linked implementation.  To insure that
    URBs are given back in order of submission, whenever a TD is added to
    the done list, all the preceding TDs for the same endpoint must be
    added as well (going back to the first one that isn't already on the
    done list).
    
    The done list manipulations must all be protected by the private
    lock.  The scope of the lock is expanded in preparation for the
    watchdog routine to be added in a later patch.
    
    We have to be more careful about giving back unlinked URBs.  Since TDs
    may be added to the done list by the watchdog routine and not in
    response to a controller interrupt, we have to check explicitly to
    make sure all the URB's TDs that were added to the done list have been
    processed before giving back the URB.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index 52829276a44e..3112799bba7f 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -780,24 +780,21 @@ static irqreturn_t ohci_irq (struct usb_hcd *hcd)
 			usb_hcd_resume_root_hub(hcd);
 	}
 
-	if (ints &amp; OHCI_INTR_WDH) {
-		spin_lock (&amp;ohci-&gt;lock);
-		dl_done_list (ohci);
-		spin_unlock (&amp;ohci-&gt;lock);
-	}
+	spin_lock(&amp;ohci-&gt;lock);
+	if (ints &amp; OHCI_INTR_WDH)
+		update_done_list(ohci);
 
 	/* could track INTR_SO to reduce available PCI/... bandwidth */
 
 	/* handle any pending URB/ED unlinks, leaving INTR_SF enabled
 	 * when there's still unlinking to be done (next frame).
 	 */
-	spin_lock (&amp;ohci-&gt;lock);
+	process_done_list(ohci);
 	if (ohci-&gt;ed_rm_list)
 		finish_unlinks (ohci, ohci_frame_no(ohci));
 	if ((ints &amp; OHCI_INTR_SF) != 0 &amp;&amp; !ohci-&gt;ed_rm_list
 			&amp;&amp; ohci-&gt;rh_state == OHCI_RH_RUNNING)
 		ohci_writel (ohci, OHCI_INTR_SF, &amp;regs-&gt;intrdisable);
-	spin_unlock (&amp;ohci-&gt;lock);
 
 	if (ohci-&gt;rh_state == OHCI_RH_RUNNING) {
 		ohci_writel (ohci, ints, &amp;regs-&gt;intrstatus);
@@ -805,6 +802,7 @@ static irqreturn_t ohci_irq (struct usb_hcd *hcd)
 		// flush those writes
 		(void) ohci_readl (ohci, &amp;ohci-&gt;regs-&gt;control);
 	}
+	spin_unlock(&amp;ohci-&gt;lock);
 
 	return IRQ_HANDLED;
 }
diff --git a/drivers/usb/host/ohci-hub.c b/drivers/usb/host/ohci-hub.c
index b4940de1eba3..dccb90edd66e 100644
--- a/drivers/usb/host/ohci-hub.c
+++ b/drivers/usb/host/ohci-hub.c
@@ -39,7 +39,8 @@
 #define OHCI_SCHED_ENABLES \
 	(OHCI_CTRL_CLE|OHCI_CTRL_BLE|OHCI_CTRL_PLE|OHCI_CTRL_IE)
 
-static void dl_done_list (struct ohci_hcd *);
+static void update_done_list(struct ohci_hcd *);
+static void process_done_list(struct ohci_hcd *);
 static void finish_unlinks (struct ohci_hcd *, u16);
 
 #ifdef	CONFIG_PM
@@ -87,7 +88,8 @@ __acquires(ohci-&gt;lock)
 		msleep (8);
 		spin_lock_irq (&amp;ohci-&gt;lock);
 	}
-	dl_done_list (ohci);
+	update_done_list(ohci);
+	process_done_list(ohci);
 	finish_unlinks (ohci, ohci_frame_no(ohci));
 
 	/*
diff --git a/drivers/usb/host/ohci-q.c b/drivers/usb/host/ohci-q.c
index a9f4f04c3fad..f36b2fa0ee2f 100644
--- a/drivers/usb/host/ohci-q.c
+++ b/drivers/usb/host/ohci-q.c
@@ -892,13 +892,41 @@ static void ed_halted(struct ohci_hcd *ohci, struct td *td, int cc)
 	}
 }
 
-/* replies to the request have to be on a FIFO basis so
- * we unreverse the hc-reversed done-list
- */
-static struct td *dl_reverse_done_list (struct ohci_hcd *ohci)
+/* Add a TD to the done list */
+static void add_to_done_list(struct ohci_hcd *ohci, struct td *td)
+{
+	struct td	*td2, *td_prev;
+	struct ed	*ed;
+
+	if (td-&gt;next_dl_td)
+		return;		/* Already on the list */
+
+	/* Add all the TDs going back until we reach one that's on the list */
+	ed = td-&gt;ed;
+	td2 = td_prev = td;
+	list_for_each_entry_continue_reverse(td2, &amp;ed-&gt;td_list, td_list) {
+		if (td2-&gt;next_dl_td)
+			break;
+		td2-&gt;next_dl_td = td_prev;
+		td_prev = td2;
+	}
+
+	if (ohci-&gt;dl_end)
+		ohci-&gt;dl_end-&gt;next_dl_td = td_prev;
+	else
+		ohci-&gt;dl_start = td_prev;
+
+	/*
+	 * Make td-&gt;next_dl_td point to td itself, to mark the fact
+	 * that td is on the done list.
+	 */
+	ohci-&gt;dl_end = td-&gt;next_dl_td = td;
+}
+
+/* Get the entries on the hardware done queue and put them on our list */
+static void update_done_list(struct ohci_hcd *ohci)
 {
 	u32		td_dma;
-	struct td	*td_rev = NULL;
 	struct td	*td = NULL;
 
 	td_dma = hc32_to_cpup (ohci, &amp;ohci-&gt;hcca-&gt;done_head);
@@ -906,7 +934,7 @@ static struct td *dl_reverse_done_list (struct ohci_hcd *ohci)
 	wmb();
 
 	/* get TD from hc's singly linked list, and
-	 * prepend to ours.  ed-&gt;td_list changes later.
+	 * add to ours.  ed-&gt;td_list changes later.
 	 */
 	while (td_dma) {
 		int		cc;
@@ -928,11 +956,9 @@ static struct td *dl_reverse_done_list (struct ohci_hcd *ohci)
 				&amp;&amp; (td-&gt;ed-&gt;hwHeadP &amp; cpu_to_hc32 (ohci, ED_H)))
 			ed_halted(ohci, td, cc);
 
-		td-&gt;next_dl_td = td_rev;
-		td_rev = td;
 		td_dma = hc32_to_cpup (ohci, &amp;td-&gt;hwNextTD);
+		add_to_done_list(ohci, td);
 	}
-	return td_rev;
 }
 
 /*-------------------------------------------------------------------------*/
@@ -956,26 +982,27 @@ finish_unlinks (struct ohci_hcd *ohci, u16 tick)
 		/* only take off EDs that the HC isn't using, accounting for
 		 * frame counter wraps and EDs with partially retired TDs
 		 */
-		if (likely(ohci-&gt;rh_state == OHCI_RH_RUNNING)) {
-			if (tick_before (tick, ed-&gt;tick)) {
+		if (likely(ohci-&gt;rh_state == OHCI_RH_RUNNING) &amp;&amp;
+				tick_before(tick, ed-&gt;tick)) {
 skip_ed:
-				last = &amp;ed-&gt;ed_next;
-				continue;
-			}
+			last = &amp;ed-&gt;ed_next;
+			continue;
+		}
+		if (!list_empty(&amp;ed-&gt;td_list)) {
+			struct td	*td;
+			u32		head;
 
-			if (!list_empty (&amp;ed-&gt;td_list)) {
-				struct td	*td;
-				u32		head;
+			td = list_first_entry(&amp;ed-&gt;td_list, struct td, td_list);
 
-				td = list_entry (ed-&gt;td_list.next, struct td,
-							td_list);
-				head = hc32_to_cpu (ohci, ed-&gt;hwHeadP) &amp;
-								TD_MASK;
+			/* INTR_WDH may need to clean up first */
+			head = hc32_to_cpu(ohci, ed-&gt;hwHeadP) &amp; TD_MASK;
+			if (td-&gt;td_dma != head &amp;&amp;
+					ohci-&gt;rh_state == OHCI_RH_RUNNING)
+				goto skip_ed;
 
-				/* INTR_WDH may need to clean up first */
-				if (td-&gt;td_dma != head)
-					goto skip_ed;
-			}
+			/* Don't mess up anything already on the done list */
+			if (td-&gt;next_dl_td)
+				goto skip_ed;
 		}
 
 		/* ED's now officially unlinked, hc doesn't see */
@@ -1161,33 +1188,17 @@ static void takeback_td(struct ohci_hcd *ohci, struct td *td)
  * normal path is finish_unlinks(), which unlinks URBs using ed_rm_list,
  * instead of scanning the (re-reversed) donelist as this does.
  */
-static void
-dl_done_list (struct ohci_hcd *ohci)
+static void process_done_list(struct ohci_hcd *ohci)
 {
-	struct td	*td = dl_reverse_done_list (ohci);
-
-	while (td) {
-		struct td	*td_next = td-&gt;next_dl_td;
-		struct ed	*ed = td-&gt;ed;
+	struct td	*td;
 
-		/*
-		 * Some OHCI controllers (NVIDIA for sure, maybe others)
-		 * occasionally forget to add TDs to the done queue.  Since
-		 * TDs for a given endpoint are always processed in order,
-		 * if we find a TD on the donelist then all of its
-		 * predecessors must be finished as well.
-		 */
-		for (;;) {
-			struct td	*td2;
-
-			td2 = list_first_entry(&amp;ed-&gt;td_list, struct td,
-					td_list);
-			if (td2 == td)
-				break;
-			takeback_td(ohci, td2);
-		}
+	while (ohci-&gt;dl_start) {
+		td = ohci-&gt;dl_start;
+		if (td == ohci-&gt;dl_end)
+			ohci-&gt;dl_start = ohci-&gt;dl_end = NULL;
+		else
+			ohci-&gt;dl_start = td-&gt;next_dl_td;
 
 		takeback_td(ohci, td);
-		td = td_next;
 	}
 }
diff --git a/drivers/usb/host/ohci.h b/drivers/usb/host/ohci.h
index 392932dd6318..a8259bc6fd8b 100644
--- a/drivers/usb/host/ohci.h
+++ b/drivers/usb/host/ohci.h
@@ -380,6 +380,7 @@ struct ohci_hcd {
 	struct dma_pool		*td_cache;
 	struct dma_pool		*ed_cache;
 	struct td		*td_hash [TD_HASH_SIZE];
+	struct td		*dl_start, *dl_end;	/* the done list */
 	struct list_head	pending;
 
 	/*</pre><hr><pre>commit 8b3ab0edaf6acd281243bf974fac7e01c9574d08
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jul 18 16:25:49 2014 -0400

    USB: OHCI: no shortcut for unlinking URBS from a dead controller
    
    When an URB is unlinked from a dead controller, ohci-hcd gives back
    the URB with no regard for cleaning up the internal data structures.
    This won't play nicely with the upcoming changes to the TD done
    list.
    
    Therefore make ohci_urb_dequeue() call finish_unlinks(), which uses
    td_done() to do a proper cleanup, rather than calling finish_urb()
    directly.  Also, remove the checks that urb_priv is non-NULL; the
    driver guarantees that urb_priv will never be NULL for a valid URB.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index a8f0e1b00e7d..52829276a44e 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -300,30 +300,24 @@ static int ohci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
 	unsigned long		flags;
 	int			rc;
+	urb_priv_t		*urb_priv;
 
 	spin_lock_irqsave (&amp;ohci-&gt;lock, flags);
 	rc = usb_hcd_check_unlink_urb(hcd, urb, status);
-	if (rc) {
-		;	/* Do nothing */
-	} else if (ohci-&gt;rh_state == OHCI_RH_RUNNING) {
-		urb_priv_t  *urb_priv;
+	if (rc == 0) {
 
 		/* Unless an IRQ completed the unlink while it was being
 		 * handed to us, flag it for unlink and giveback, and force
 		 * some upcoming INTR_SF to call finish_unlinks()
 		 */
 		urb_priv = urb-&gt;hcpriv;
-		if (urb_priv) {
-			if (urb_priv-&gt;ed-&gt;state == ED_OPER)
-				start_ed_unlink (ohci, urb_priv-&gt;ed);
+		if (urb_priv-&gt;ed-&gt;state == ED_OPER)
+			start_ed_unlink(ohci, urb_priv-&gt;ed);
+
+		if (ohci-&gt;rh_state != OHCI_RH_RUNNING) {
+			/* With HC dead, we can clean up right away */
+			finish_unlinks(ohci, 0);
 		}
-	} else {
-		/*
-		 * with HC dead, we won't respect hc queue pointers
-		 * any more ... just clean up every urb's memory.
-		 */
-		if (urb-&gt;hcpriv)
-			finish_urb(ohci, urb, status);
 	}
 	spin_unlock_irqrestore (&amp;ohci-&gt;lock, flags);
 	return rc;</pre><hr><pre>commit 95d9a01d727fdb6d2b667ac374341c48777cc41e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jul 18 16:25:36 2014 -0400

    USB: OHCI: revert the ZF Micro orphan-TD quirk
    
    This patch reverts the important parts of commit 89a0fd18a96e (USB:
    OHCI handles more ZFMicro quirks), namely, the parts related to
    handling orphan TDs for interrupt endpoints.  A later patch in this
    series will introduce a more general mechanism that applies to all
    endpoint types and all controllers.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index 7570098b1cfa..a8f0e1b00e7d 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -355,8 +355,6 @@ ohci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 	if (ohci-&gt;rh_state != OHCI_RH_RUNNING) {
 sanitize:
 		ed-&gt;state = ED_IDLE;
-		if (quirk_zfmicro(ohci) &amp;&amp; ed-&gt;type == PIPE_INTERRUPT)
-			ohci-&gt;eds_scheduled--;
 		finish_unlinks (ohci, 0);
 	}
 
@@ -365,11 +363,6 @@ ohci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 		/* major IRQ delivery trouble loses INTR_SF too... */
 		if (limit-- == 0) {
 			ohci_warn(ohci, "ED unlink timeout\n");
-			if (quirk_zfmicro(ohci)) {
-				ohci_warn(ohci, "Attempting ZF TD recovery\n");
-				ohci-&gt;ed_to_check = ed;
-				ohci-&gt;zf_delay = 2;
-			}
 			goto sanitize;
 		}
 		spin_unlock_irqrestore (&amp;ohci-&gt;lock, flags);
@@ -431,93 +424,6 @@ ohci_shutdown (struct usb_hcd *hcd)
 	ohci_writel(ohci, ohci-&gt;fminterval, &amp;ohci-&gt;regs-&gt;fminterval);
 }
 
-static int check_ed(struct ohci_hcd *ohci, struct ed *ed)
-{
-	return (hc32_to_cpu(ohci, ed-&gt;hwINFO) &amp; ED_IN) != 0
-		&amp;&amp; (hc32_to_cpu(ohci, ed-&gt;hwHeadP) &amp; TD_MASK)
-			== (hc32_to_cpu(ohci, ed-&gt;hwTailP) &amp; TD_MASK)
-		&amp;&amp; !list_empty(&amp;ed-&gt;td_list);
-}
-
-/* ZF Micro watchdog timer callback. The ZF Micro chipset sometimes completes
- * an interrupt TD but neglects to add it to the donelist.  On systems with
- * this chipset, we need to periodically check the state of the queues to look
- * for such "lost" TDs.
- */
-static void unlink_watchdog_func(unsigned long _ohci)
-{
-	unsigned long	flags;
-	unsigned	max;
-	unsigned	seen_count = 0;
-	unsigned	i;
-	struct ed	**seen = NULL;
-	struct ohci_hcd	*ohci = (struct ohci_hcd *) _ohci;
-
-	spin_lock_irqsave(&amp;ohci-&gt;lock, flags);
-	max = ohci-&gt;eds_scheduled;
-	if (!max)
-		goto done;
-
-	if (ohci-&gt;ed_to_check)
-		goto out;
-
-	seen = kcalloc(max, sizeof *seen, GFP_ATOMIC);
-	if (!seen)
-		goto out;
-
-	for (i = 0; i &lt; NUM_INTS; i++) {
-		struct ed	*ed = ohci-&gt;periodic[i];
-
-		while (ed) {
-			unsigned	temp;
-
-			/* scan this branch of the periodic schedule tree */
-			for (temp = 0; temp &lt; seen_count; temp++) {
-				if (seen[temp] == ed) {
-					/* we've checked it and what's after */
-					ed = NULL;
-					break;
-				}
-			}
-			if (!ed)
-				break;
-			seen[seen_count++] = ed;
-			if (!check_ed(ohci, ed)) {
-				ed = ed-&gt;ed_next;
-				continue;
-			}
-
-			/* HC's TD list is empty, but HCD sees at least one
-			 * TD that's not been sent through the donelist.
-			 */
-			ohci-&gt;ed_to_check = ed;
-			ohci-&gt;zf_delay = 2;
-
-			/* The HC may wait until the next frame to report the
-			 * TD as done through the donelist and INTR_WDH.  (We
-			 * just *assume* it's not a multi-TD interrupt URB;
-			 * those could defer the IRQ more than one frame, using
-			 * DI...)  Check again after the next INTR_SF.
-			 */
-			ohci_writel(ohci, OHCI_INTR_SF,
-					&amp;ohci-&gt;regs-&gt;intrstatus);
-			ohci_writel(ohci, OHCI_INTR_SF,
-					&amp;ohci-&gt;regs-&gt;intrenable);
-
-			/* flush those writes */
-			(void) ohci_readl(ohci, &amp;ohci-&gt;regs-&gt;control);
-
-			goto out;
-		}
-	}
-out:
-	kfree(seen);
-	if (ohci-&gt;eds_scheduled)
-		mod_timer(&amp;ohci-&gt;unlink_watchdog, round_jiffies(jiffies + HZ));
-done:
-	spin_unlock_irqrestore(&amp;ohci-&gt;lock, flags);
-}
-
 /*-------------------------------------------------------------------------*
  * HC functions
  *-------------------------------------------------------------------------*/
@@ -761,15 +667,6 @@ static int ohci_run (struct ohci_hcd *ohci)
 	// POTPGT delay is bits 24-31, in 2 ms units.
 	mdelay ((val &gt;&gt; 23) &amp; 0x1fe);
 
-	if (quirk_zfmicro(ohci)) {
-		/* Create timer to watch for bad queue state on ZF Micro */
-		setup_timer(&amp;ohci-&gt;unlink_watchdog, unlink_watchdog_func,
-				(unsigned long) ohci);
-
-		ohci-&gt;eds_scheduled = 0;
-		ohci-&gt;ed_to_check = NULL;
-	}
-
 	ohci_dump(ohci);
 
 	return 0;
@@ -895,31 +792,6 @@ static irqreturn_t ohci_irq (struct usb_hcd *hcd)
 		spin_unlock (&amp;ohci-&gt;lock);
 	}
 
-	if (quirk_zfmicro(ohci) &amp;&amp; (ints &amp; OHCI_INTR_SF)) {
-		spin_lock(&amp;ohci-&gt;lock);
-		if (ohci-&gt;ed_to_check) {
-			struct ed *ed = ohci-&gt;ed_to_check;
-
-			if (check_ed(ohci, ed)) {
-				/* HC thinks the TD list is empty; HCD knows
-				 * at least one TD is outstanding
-				 */
-				if (--ohci-&gt;zf_delay == 0) {
-					struct td *td = list_entry(
-						ed-&gt;td_list.next,
-						struct td, td_list);
-					ohci_warn(ohci,
-						  "Reclaiming orphan TD %p\n",
-						  td);
-					takeback_td(ohci, td);
-					ohci-&gt;ed_to_check = NULL;
-				}
-			} else
-				ohci-&gt;ed_to_check = NULL;
-		}
-		spin_unlock(&amp;ohci-&gt;lock);
-	}
-
 	/* could track INTR_SO to reduce available PCI/... bandwidth */
 
 	/* handle any pending URB/ED unlinks, leaving INTR_SF enabled
@@ -928,9 +800,7 @@ static irqreturn_t ohci_irq (struct usb_hcd *hcd)
 	spin_lock (&amp;ohci-&gt;lock);
 	if (ohci-&gt;ed_rm_list)
 		finish_unlinks (ohci, ohci_frame_no(ohci));
-	if ((ints &amp; OHCI_INTR_SF) != 0
-			&amp;&amp; !ohci-&gt;ed_rm_list
-			&amp;&amp; !ohci-&gt;ed_to_check
+	if ((ints &amp; OHCI_INTR_SF) != 0 &amp;&amp; !ohci-&gt;ed_rm_list
 			&amp;&amp; ohci-&gt;rh_state == OHCI_RH_RUNNING)
 		ohci_writel (ohci, OHCI_INTR_SF, &amp;regs-&gt;intrdisable);
 	spin_unlock (&amp;ohci-&gt;lock);
@@ -961,8 +831,6 @@ static void ohci_stop (struct usb_hcd *hcd)
 	free_irq(hcd-&gt;irq, hcd);
 	hcd-&gt;irq = 0;
 
-	if (quirk_zfmicro(ohci))
-		del_timer(&amp;ohci-&gt;unlink_watchdog);
 	if (quirk_amdiso(ohci))
 		usb_amd_dev_put();
 
diff --git a/drivers/usb/host/ohci-q.c b/drivers/usb/host/ohci-q.c
index a6376f3e55cb..a9f4f04c3fad 100644
--- a/drivers/usb/host/ohci-q.c
+++ b/drivers/usb/host/ohci-q.c
@@ -187,10 +187,6 @@ static int ed_schedule (struct ohci_hcd *ohci, struct ed *ed)
 	ed-&gt;ed_prev = NULL;
 	ed-&gt;ed_next = NULL;
 	ed-&gt;hwNextED = 0;
-	if (quirk_zfmicro(ohci)
-			&amp;&amp; (ed-&gt;type == PIPE_INTERRUPT)
-			&amp;&amp; !(ohci-&gt;eds_scheduled++))
-		mod_timer(&amp;ohci-&gt;unlink_watchdog, round_jiffies(jiffies + HZ));
 	wmb ();
 
 	/* we care about rm_list when setting CLE/BLE in case the HC was at
@@ -977,19 +973,13 @@ finish_unlinks (struct ohci_hcd *ohci, u16 tick)
 								TD_MASK;
 
 				/* INTR_WDH may need to clean up first */
-				if (td-&gt;td_dma != head) {
-					if (ed == ohci-&gt;ed_to_check)
-						ohci-&gt;ed_to_check = NULL;
-					else
-						goto skip_ed;
-				}
+				if (td-&gt;td_dma != head)
+					goto skip_ed;
 			}
 		}
 
 		/* ED's now officially unlinked, hc doesn't see */
 		ed-&gt;state = ED_IDLE;
-		if (quirk_zfmicro(ohci) &amp;&amp; ed-&gt;type == PIPE_INTERRUPT)
-			ohci-&gt;eds_scheduled--;
 		ed-&gt;hwHeadP &amp;= ~cpu_to_hc32(ohci, ED_H);
 		ed-&gt;hwNextED = 0;
 		wmb();
@@ -1122,12 +1112,7 @@ finish_unlinks (struct ohci_hcd *ohci, u16 tick)
 
 /*-------------------------------------------------------------------------*/
 
-/*
- * Used to take back a TD from the host controller. This would normally be
- * called from within dl_done_list, however it may be called directly if the
- * HC no longer sees the TD and it has not appeared on the donelist (after
- * two frames).  This bug has been observed on ZF Micro systems.
- */
+/* Take back a TD from the host controller */
 static void takeback_td(struct ohci_hcd *ohci, struct td *td)
 {
 	struct urb	*urb = td-&gt;urb;
@@ -1174,9 +1159,7 @@ static void takeback_td(struct ohci_hcd *ohci, struct td *td)
  *
  * This is the main path for handing urbs back to drivers.  The only other
  * normal path is finish_unlinks(), which unlinks URBs using ed_rm_list,
- * instead of scanning the (re-reversed) donelist as this does.  There's
- * an abnormal path too, handling a quirk in some Compaq silicon:  URBs
- * with TDs that appear to be orphaned are directly reclaimed.
+ * instead of scanning the (re-reversed) donelist as this does.
  */
 static void
 dl_done_list (struct ohci_hcd *ohci)
diff --git a/drivers/usb/host/ohci.h b/drivers/usb/host/ohci.h
index 05e02a709d4f..392932dd6318 100644
--- a/drivers/usb/host/ohci.h
+++ b/drivers/usb/host/ohci.h
@@ -411,12 +411,6 @@ struct ohci_hcd {
 
 	struct work_struct	nec_work;	/* Worker for NEC quirk */
 
-	/* Needed for ZF Micro quirk */
-	struct timer_list	unlink_watchdog;
-	unsigned		eds_scheduled;
-	struct ed		*ed_to_check;
-	unsigned		zf_delay;
-
 	struct dentry		*debug_dir;
 	struct dentry		*debug_async;
 	struct dentry		*debug_periodic;</pre><hr><pre>commit 977dcfdc60311e7aa571cabf6f39c36dde13339e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jul 17 16:34:29 2014 -0400

    USB: OHCI: don't lose track of EDs when a controller dies
    
    This patch fixes a bug in ohci-hcd.  When an URB is unlinked, the
    corresponding Endpoint Descriptor is added to the ed_rm_list and taken
    off the hardware schedule.  Once the ED is no longer visible to the
    hardware, finish_unlinks() handles the URBs that were unlinked or have
    completed.  If any URBs remain attached to the ED, the ED is added
    back to the hardware schedule -- but only if the controller is
    running.
    
    This fails when a controller dies.  A non-empty ED does not get added
    back to the hardware schedule and does not remain on the ed_rm_list;
    ohci-hcd loses track of it.  The remaining URBs cannot be unlinked,
    which causes the USB stack to hang.
    
    The patch changes finish_unlinks() so that non-empty EDs remain on
    the ed_rm_list if the controller isn't running.  This requires moving
    some of the existing code around, to avoid modifying the ED's hardware
    fields more than once.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ohci-q.c b/drivers/usb/host/ohci-q.c
index 517d04d5c150..a6376f3e55cb 100644
--- a/drivers/usb/host/ohci-q.c
+++ b/drivers/usb/host/ohci-q.c
@@ -311,8 +311,7 @@ static void periodic_unlink (struct ohci_hcd *ohci, struct ed *ed)
  *  - ED_OPER: when there's any request queued, the ED gets rescheduled
  *    immediately.  HC should be working on them.
  *
- *  - ED_IDLE:  when there's no TD queue. there's no reason for the HC
- *    to care about this ED; safe to disable the endpoint.
+ *  - ED_IDLE: when there's no TD queue or the HC isn't running.
  *
  * When finish_unlinks() runs later, after SOF interrupt, it will often
  * complete one or more URB unlinks before making that state change.
@@ -954,6 +953,10 @@ finish_unlinks (struct ohci_hcd *ohci, u16 tick)
 		int			completed, modified;
 		__hc32			*prev;
 
+		/* Is this ED already invisible to the hardware? */
+		if (ed-&gt;state == ED_IDLE)
+			goto ed_idle;
+
 		/* only take off EDs that the HC isn't using, accounting for
 		 * frame counter wraps and EDs with partially retired TDs
 		 */
@@ -983,12 +986,20 @@ finish_unlinks (struct ohci_hcd *ohci, u16 tick)
 			}
 		}
 
+		/* ED's now officially unlinked, hc doesn't see */
+		ed-&gt;state = ED_IDLE;
+		if (quirk_zfmicro(ohci) &amp;&amp; ed-&gt;type == PIPE_INTERRUPT)
+			ohci-&gt;eds_scheduled--;
+		ed-&gt;hwHeadP &amp;= ~cpu_to_hc32(ohci, ED_H);
+		ed-&gt;hwNextED = 0;
+		wmb();
+		ed-&gt;hwINFO &amp;= ~cpu_to_hc32(ohci, ED_SKIP | ED_DEQUEUE);
+ed_idle:
+
 		/* reentrancy:  if we drop the schedule lock, someone might
 		 * have modified this list.  normally it's just prepending
 		 * entries (which we'd ignore), but paranoia won't hurt.
 		 */
-		*last = ed-&gt;ed_next;
-		ed-&gt;ed_next = NULL;
 		modified = 0;
 
 		/* unlink urbs as requested, but rescan the list after
@@ -1046,19 +1057,20 @@ finish_unlinks (struct ohci_hcd *ohci, u16 tick)
 		if (completed &amp;&amp; !list_empty (&amp;ed-&gt;td_list))
 			goto rescan_this;
 
-		/* ED's now officially unlinked, hc doesn't see */
-		ed-&gt;state = ED_IDLE;
-		if (quirk_zfmicro(ohci) &amp;&amp; ed-&gt;type == PIPE_INTERRUPT)
-			ohci-&gt;eds_scheduled--;
-		ed-&gt;hwHeadP &amp;= ~cpu_to_hc32(ohci, ED_H);
-		ed-&gt;hwNextED = 0;
-		wmb ();
-		ed-&gt;hwINFO &amp;= ~cpu_to_hc32 (ohci, ED_SKIP | ED_DEQUEUE);
-
-		/* but if there's work queued, reschedule */
-		if (!list_empty (&amp;ed-&gt;td_list)) {
-			if (ohci-&gt;rh_state == OHCI_RH_RUNNING)
-				ed_schedule (ohci, ed);
+		/*
+		 * If no TDs are queued, take ED off the ed_rm_list.
+		 * Otherwise, if the HC is running, reschedule.
+		 * If not, leave it on the list for further dequeues.
+		 */
+		if (list_empty(&amp;ed-&gt;td_list)) {
+			*last = ed-&gt;ed_next;
+			ed-&gt;ed_next = NULL;
+		} else if (ohci-&gt;rh_state == OHCI_RH_RUNNING) {
+			*last = ed-&gt;ed_next;
+			ed-&gt;ed_next = NULL;
+			ed_schedule(ohci, ed);
+		} else {
+			last = &amp;ed-&gt;ed_next;
 		}
 
 		if (modified)</pre><hr><pre>commit 256dbcd80f1ccf8abf421c1d72ba79a4e29941dd
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jul 17 16:32:26 2014 -0400

    USB: OHCI: fix bugs in debug routines
    
    The debug routine fill_async_buffer() in ohci-hcd is buggy: It never
    produces any output because it forgets to initialize the output buffer
    size.  Also, the debug routine ohci_dump() has an unused argument.
    
    This patch adds the correct initialization and removes the unused
    argument.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ohci-dbg.c b/drivers/usb/host/ohci-dbg.c
index 45032e933e18..04f2186939d2 100644
--- a/drivers/usb/host/ohci-dbg.c
+++ b/drivers/usb/host/ohci-dbg.c
@@ -236,7 +236,7 @@ ohci_dump_roothub (
 	}
 }
 
-static void ohci_dump (struct ohci_hcd *controller, int verbose)
+static void ohci_dump(struct ohci_hcd *controller)
 {
 	ohci_dbg (controller, "OHCI controller state\n");
 
@@ -464,15 +464,16 @@ show_list (struct ohci_hcd *ohci, char *buf, size_t count, struct ed *ed)
 static ssize_t fill_async_buffer(struct debug_buffer *buf)
 {
 	struct ohci_hcd		*ohci;
-	size_t			temp;
+	size_t			temp, size;
 	unsigned long		flags;
 
 	ohci = buf-&gt;ohci;
+	size = PAGE_SIZE;
 
 	/* display control and bulk lists together, for simplicity */
 	spin_lock_irqsave (&amp;ohci-&gt;lock, flags);
-	temp = show_list(ohci, buf-&gt;page, buf-&gt;count, ohci-&gt;ed_controltail);
-	temp += show_list(ohci, buf-&gt;page + temp, buf-&gt;count - temp,
+	temp = show_list(ohci, buf-&gt;page, size, ohci-&gt;ed_controltail);
+	temp += show_list(ohci, buf-&gt;page + temp, size - temp,
 			  ohci-&gt;ed_bulktail);
 	spin_unlock_irqrestore (&amp;ohci-&gt;lock, flags);
 
diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index 7f94c586c5dc..7570098b1cfa 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -76,8 +76,8 @@ static const char	hcd_name [] = "ohci_hcd";
 #include "ohci.h"
 #include "pci-quirks.h"
 
-static void ohci_dump (struct ohci_hcd *ohci, int verbose);
-static void ohci_stop (struct usb_hcd *hcd);
+static void ohci_dump(struct ohci_hcd *ohci);
+static void ohci_stop(struct usb_hcd *hcd);
 
 #include "ohci-hub.c"
 #include "ohci-dbg.c"
@@ -770,7 +770,7 @@ static int ohci_run (struct ohci_hcd *ohci)
 		ohci-&gt;ed_to_check = NULL;
 	}
 
-	ohci_dump (ohci, 1);
+	ohci_dump(ohci);
 
 	return 0;
 }
@@ -851,7 +851,7 @@ static irqreturn_t ohci_irq (struct usb_hcd *hcd)
 			usb_hc_died(hcd);
 		}
 
-		ohci_dump (ohci, 1);
+		ohci_dump(ohci);
 		ohci_usb_reset (ohci);
 	}
 
@@ -951,7 +951,7 @@ static void ohci_stop (struct usb_hcd *hcd)
 {
 	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
 
-	ohci_dump (ohci, 1);
+	ohci_dump(ohci);
 
 	if (quirk_nec(ohci))
 		flush_work(&amp;ohci-&gt;nec_work);</pre>
    <div class="pagination">
        <a href='2_27.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><span>[28]</span><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_29.html'>Next&gt;&gt;</a>
    <div>
</body>
