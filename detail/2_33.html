<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_32.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><span>[33]</span><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_34.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 232275a089dfd2e77377a85f11d0a4e3ca60e612
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 24 15:43:39 2013 -0400

    USB: fix substandard locking for the sysfs files
    
    This patch straightens out some locking issues in the USB sysfs
    interface:
    
            Deauthorization will destroy existing configurations.
            Attributes that read from udev-&gt;actconfig need to lock the
            device to prevent races.  Likewise for the rawdescriptor
            values.
    
            Attributes that access an interface's current alternate
            setting should use ACCESS_ONCE() to obtain the cur_altsetting
            pointer, to protect against concurrent altsetting changes.
    
            The supports_autosuspend() attribute routine accesses values
            from an interface's driver, so it should lock the interface
            (rather than the usb_device) to protect against concurrent
            unbinds.  Once this is done, the routine can be simplified
            considerably.
    
    Scalar values that are stored directly in the usb_device structure are
    always available.  They do not require any locking.  The same is true
    of the cached interface string descriptor, because it is not
    deallocated until the usb_host_interface structure is destroyed.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Hans de Goede &lt;hdegoede@redhat.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c
index 6d2c8edb1ffe..59cb5f99467a 100644
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -23,14 +23,16 @@ static ssize_t field##_show(struct device *dev,				\
 {									\
 	struct usb_device *udev;					\
 	struct usb_host_config *actconfig;				\
+	ssize_t rc = 0;							\
 									\
 	udev = to_usb_device(dev);					\
+	usb_lock_device(udev);						\
 	actconfig = udev-&gt;actconfig;					\
 	if (actconfig)							\
-		return sprintf(buf, format_string,			\
+		rc = sprintf(buf, format_string,			\
 				actconfig-&gt;desc.field);			\
-	else								\
-		return 0;						\
+	usb_unlock_device(udev);					\
+	return rc;							\
 }									\
 
 #define usb_actconfig_attr(field, format_string)		\
@@ -45,12 +47,15 @@ static ssize_t bMaxPower_show(struct device *dev,
 {
 	struct usb_device *udev;
 	struct usb_host_config *actconfig;
+	ssize_t rc = 0;
 
 	udev = to_usb_device(dev);
+	usb_lock_device(udev);
 	actconfig = udev-&gt;actconfig;
-	if (!actconfig)
-		return 0;
-	return sprintf(buf, "%dmA\n", usb_get_max_power(udev, actconfig));
+	if (actconfig)
+		rc = sprintf(buf, "%dmA\n", usb_get_max_power(udev, actconfig));
+	usb_unlock_device(udev);
+	return rc;
 }
 static DEVICE_ATTR_RO(bMaxPower);
 
@@ -59,12 +64,15 @@ static ssize_t configuration_show(struct device *dev,
 {
 	struct usb_device *udev;
 	struct usb_host_config *actconfig;
+	ssize_t rc = 0;
 
 	udev = to_usb_device(dev);
+	usb_lock_device(udev);
 	actconfig = udev-&gt;actconfig;
-	if ((!actconfig) || (!actconfig-&gt;string))
-		return 0;
-	return sprintf(buf, "%s\n", actconfig-&gt;string);
+	if (actconfig &amp;&amp; actconfig-&gt;string)
+		rc = sprintf(buf, "%s\n", actconfig-&gt;string);
+	usb_unlock_device(udev);
+	return rc;
 }
 static DEVICE_ATTR_RO(configuration);
 
@@ -764,6 +772,7 @@ read_descriptors(struct file *filp, struct kobject *kobj,
 	 * Following that are the raw descriptor entries for all the
 	 * configurations (config plus subsidiary descriptors).
 	 */
+	usb_lock_device(udev);
 	for (cfgno = -1; cfgno &lt; udev-&gt;descriptor.bNumConfigurations &amp;&amp;
 			nleft &gt; 0; ++cfgno) {
 		if (cfgno &lt; 0) {
@@ -784,6 +793,7 @@ read_descriptors(struct file *filp, struct kobject *kobj,
 			off -= srclen;
 		}
 	}
+	usb_unlock_device(udev);
 	return count - nleft;
 }
 
@@ -870,9 +880,7 @@ static ssize_t interface_show(struct device *dev, struct device_attribute *attr,
 	char *string;
 
 	intf = to_usb_interface(dev);
-	string = intf-&gt;cur_altsetting-&gt;string;
-	barrier();		/* The altsetting might change! */
-
+	string = ACCESS_ONCE(intf-&gt;cur_altsetting-&gt;string);
 	if (!string)
 		return 0;
 	return sprintf(buf, "%s\n", string);
@@ -888,7 +896,7 @@ static ssize_t modalias_show(struct device *dev, struct device_attribute *attr,
 
 	intf = to_usb_interface(dev);
 	udev = interface_to_usbdev(intf);
-	alt = intf-&gt;cur_altsetting;
+	alt = ACCESS_ONCE(intf-&gt;cur_altsetting);
 
 	return sprintf(buf, "usb:v%04Xp%04Xd%04Xdc%02Xdsc%02Xdp%02X"
 			"ic%02Xisc%02Xip%02Xin%02X\n",
@@ -909,23 +917,14 @@ static ssize_t supports_autosuspend_show(struct device *dev,
 					 struct device_attribute *attr,
 					 char *buf)
 {
-	struct usb_interface *intf;
-	struct usb_device *udev;
-	int ret;
+	int s;
 
-	intf = to_usb_interface(dev);
-	udev = interface_to_usbdev(intf);
-
-	usb_lock_device(udev);
+	device_lock(dev);
 	/* Devices will be autosuspended even when an interface isn't claimed */
-	if (!intf-&gt;dev.driver ||
-			to_usb_driver(intf-&gt;dev.driver)-&gt;supports_autosuspend)
-		ret = sprintf(buf, "%u\n", 1);
-	else
-		ret = sprintf(buf, "%u\n", 0);
-	usb_unlock_device(udev);
+	s = (!dev-&gt;driver || to_usb_driver(dev-&gt;driver)-&gt;supports_autosuspend);
+	device_unlock(dev);
 
-	return ret;
+	return sprintf(buf, "%u\n", s);
 }
 static DEVICE_ATTR_RO(supports_autosuspend);
 </pre><hr><pre>commit f875fdbf344b9fde207f66b392c40845dd7e5aa6
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 24 15:45:25 2013 -0400

    USB: fix PM config symbol in uhci-hcd, ehci-hcd, and xhci-hcd
    
    Since uhci-hcd, ehci-hcd, and xhci-hcd support runtime PM, the .pm
    field in their pci_driver structures should be protected by CONFIG_PM
    rather than CONFIG_PM_SLEEP.  The corresponding change has already
    been made for ohci-hcd.
    
    Without this change, controllers won't do runtime suspend if system
    suspend or hibernation isn't enabled.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Sarah Sharp &lt;sarah.a.sharp@linux.intel.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 6bd299e61f58..854c2ec7b699 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -361,7 +361,7 @@ static struct pci_driver ehci_pci_driver = {
 	.remove =	usb_hcd_pci_remove,
 	.shutdown = 	usb_hcd_pci_shutdown,
 
-#ifdef CONFIG_PM_SLEEP
+#ifdef CONFIG_PM
 	.driver =	{
 		.pm =	&amp;usb_hcd_pci_pm_ops
 	},
diff --git a/drivers/usb/host/uhci-pci.c b/drivers/usb/host/uhci-pci.c
index c300bd2f7d1c..0f228c46eeda 100644
--- a/drivers/usb/host/uhci-pci.c
+++ b/drivers/usb/host/uhci-pci.c
@@ -293,7 +293,7 @@ static struct pci_driver uhci_pci_driver = {
 	.remove =	usb_hcd_pci_remove,
 	.shutdown =	uhci_shutdown,
 
-#ifdef CONFIG_PM_SLEEP
+#ifdef CONFIG_PM
 	.driver =	{
 		.pm =	&amp;usb_hcd_pci_pm_ops
 	},
diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index c2d495057eb5..236c3aabe940 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -351,7 +351,7 @@ static struct pci_driver xhci_pci_driver = {
 	/* suspend and resume implemented later */
 
 	.shutdown = 	usb_hcd_pci_shutdown,
-#ifdef CONFIG_PM_SLEEP
+#ifdef CONFIG_PM
 	.driver = {
 		.pm = &amp;usb_hcd_pci_pm_ops
 	},</pre><hr><pre>commit a8693424c751b8247ee19bd8b857f1d4f432b972
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 24 15:46:45 2013 -0400

    USB: OHCI: accept very late isochronous URBs
    
    Commit 24f531371de1 (USB: EHCI: accept very late isochronous URBs)
    changed the isochronous API provided by ehci-hcd.  URBs submitted too
    late, so that the time slots for all their packets have already
    expired, are no longer rejected outright.  Instead the submission is
    accepted, and the URB completes normally with a -EXDEV error for each
    packet.  This is what client drivers expect.
    
    This patch implements the same policy in ohci-hcd.  The change is more
    complicated than it was in ehci-hcd, because ohci-hcd doesn't scan for
    isochronous completions in the same way as ehci-hcd does.  Rather, it
    depends on the hardware adding completed TDs to a "done queue".  Some
    OHCI controller don't handle this properly when a TD's time slot has
    already expired, so we have to avoid adding such TDs to the schedule
    in the first place.  As a result, if the URB was submitted too late
    then none of its TDs will get put on the schedule, so none of them
    will end up on the done queue, so the driver will never realize that
    the URB should be completed.
    
    To solve this problem, the patch adds one to urb_priv-&gt;td_cnt for such
    URBs, making it larger than urb_priv-&gt;length (td_cnt already gets set
    to the number of TD's that had to be skipped because their slots have
    expired).  Each time an URB is given back, the finish_urb() routine
    looks to see if urb_priv-&gt;td_cnt for the next URB on the same endpoint
    is marked in this way.  If so, it gives back the next URB right away.
    
    This should be applied to all kernels containing commit 815fa7b91761
    (USB: OHCI: fix logic for scheduling isochronous URBs).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index 8f6b695af6a4..604cad1bcf9c 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -216,31 +216,26 @@ static int ohci_urb_enqueue (
 			frame &amp;= ~(ed-&gt;interval - 1);
 			frame |= ed-&gt;branch;
 			urb-&gt;start_frame = frame;
+			ed-&gt;last_iso = frame + ed-&gt;interval * (size - 1);
 		}
 	} else if (ed-&gt;type == PIPE_ISOCHRONOUS) {
 		u16	next = ohci_frame_no(ohci) + 1;
 		u16	frame = ed-&gt;last_iso + ed-&gt;interval;
+		u16	length = ed-&gt;interval * (size - 1);
 
 		/* Behind the scheduling threshold? */
 		if (unlikely(tick_before(frame, next))) {
 
-			/* USB_ISO_ASAP: Round up to the first available slot */
+			/* URB_ISO_ASAP: Round up to the first available slot */
 			if (urb-&gt;transfer_flags &amp; URB_ISO_ASAP) {
 				frame += (next - frame + ed-&gt;interval - 1) &amp;
 						-ed-&gt;interval;
 
 			/*
-			 * Not ASAP: Use the next slot in the stream.  If
-			 * the entire URB falls before the threshold, fail.
+			 * Not ASAP: Use the next slot in the stream,
+			 * no matter what.
 			 */
 			} else {
-				if (tick_before(frame + ed-&gt;interval *
-					(urb-&gt;number_of_packets - 1), next)) {
-					retval = -EXDEV;
-					usb_hcd_unlink_urb_from_ep(hcd, urb);
-					goto fail;
-				}
-
 				/*
 				 * Some OHCI hardware doesn't handle late TDs
 				 * correctly.  After retiring them it proceeds
@@ -251,9 +246,16 @@ static int ohci_urb_enqueue (
 				urb_priv-&gt;td_cnt = DIV_ROUND_UP(
 						(u16) (next - frame),
 						ed-&gt;interval);
+				if (urb_priv-&gt;td_cnt &gt;= urb_priv-&gt;length) {
+					++urb_priv-&gt;td_cnt;	/* Mark it */
+					ohci_dbg(ohci, "iso underrun %p (%u+%u &lt; %u)\n",
+							urb, frame, length,
+							next);
+				}
 			}
 		}
 		urb-&gt;start_frame = frame;
+		ed-&gt;last_iso = frame + length;
 	}
 
 	/* fill the TDs and link them to the ed; and
diff --git a/drivers/usb/host/ohci-q.c b/drivers/usb/host/ohci-q.c
index df4a6707322d..e7f577e63624 100644
--- a/drivers/usb/host/ohci-q.c
+++ b/drivers/usb/host/ohci-q.c
@@ -41,9 +41,13 @@ finish_urb(struct ohci_hcd *ohci, struct urb *urb, int status)
 __releases(ohci-&gt;lock)
 __acquires(ohci-&gt;lock)
 {
-	 struct device *dev = ohci_to_hcd(ohci)-&gt;self.controller;
+	struct device *dev = ohci_to_hcd(ohci)-&gt;self.controller;
+	struct usb_host_endpoint *ep = urb-&gt;ep;
+	struct urb_priv *urb_priv;
+
 	// ASSERT (urb-&gt;hcpriv != 0);
 
+ restart:
 	urb_free_priv (ohci, urb-&gt;hcpriv);
 	urb-&gt;hcpriv = NULL;
 	if (likely(status == -EINPROGRESS))
@@ -80,6 +84,21 @@ __acquires(ohci-&gt;lock)
 		ohci-&gt;hc_control &amp;= ~(OHCI_CTRL_PLE|OHCI_CTRL_IE);
 		ohci_writel (ohci, ohci-&gt;hc_control, &amp;ohci-&gt;regs-&gt;control);
 	}
+
+	/*
+	 * An isochronous URB that is sumitted too late won't have any TDs
+	 * (marked by the fact that the td_cnt value is larger than the
+	 * actual number of TDs).  If the next URB on this endpoint is like
+	 * that, give it back now.
+	 */
+	if (!list_empty(&amp;ep-&gt;urb_list)) {
+		urb = list_first_entry(&amp;ep-&gt;urb_list, struct urb, urb_list);
+		urb_priv = urb-&gt;hcpriv;
+		if (urb_priv-&gt;td_cnt &gt; urb_priv-&gt;length) {
+			status = 0;
+			goto restart;
+		}
+	}
 }
 
 
@@ -546,7 +565,6 @@ td_fill (struct ohci_hcd *ohci, u32 info,
 		td-&gt;hwCBP = cpu_to_hc32 (ohci, data &amp; 0xFFFFF000);
 		*ohci_hwPSWp(ohci, td, 0) = cpu_to_hc16 (ohci,
 						(data &amp; 0x0FFF) | 0xE000);
-		td-&gt;ed-&gt;last_iso = info &amp; 0xffff;
 	} else {
 		td-&gt;hwCBP = cpu_to_hc32 (ohci, data);
 	}
@@ -996,7 +1014,7 @@ finish_unlinks (struct ohci_hcd *ohci, u16 tick)
 			urb_priv-&gt;td_cnt++;
 
 			/* if URB is done, clean up */
-			if (urb_priv-&gt;td_cnt == urb_priv-&gt;length) {
+			if (urb_priv-&gt;td_cnt &gt;= urb_priv-&gt;length) {
 				modified = completed = 1;
 				finish_urb(ohci, urb, 0);
 			}
@@ -1086,7 +1104,7 @@ static void takeback_td(struct ohci_hcd *ohci, struct td *td)
 	urb_priv-&gt;td_cnt++;
 
 	/* If all this urb's TDs are done, call complete() */
-	if (urb_priv-&gt;td_cnt == urb_priv-&gt;length)
+	if (urb_priv-&gt;td_cnt &gt;= urb_priv-&gt;length)
 		finish_urb(ohci, urb, status);
 
 	/* clean schedule:  unlink EDs that are no longer busy */</pre><hr><pre>commit bef073b067a7b1874a6b381e0035bb0516d71a77
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 24 15:47:20 2013 -0400

    USB: UHCI: accept very late isochronous URBs
    
    Commit 24f531371de1 (USB: EHCI: accept very late isochronous URBs)
    changed the isochronous API provided by ehci-hcd.  URBs submitted too
    late, so that the time slots for all their packets have already
    expired, are no longer rejected outright.  Instead the submission is
    accepted, and the URB completes normally with a -EXDEV error for each
    packet.  This is what client drivers expect.
    
    This patch implements the same policy in uhci-hcd.  It should be
    applied to all kernels containing commit c44b225077bb (UHCI: implement
    new semantics for URB_ISO_ASAP).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 041c6ddb695c..da6f56d996ce 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -1303,7 +1303,7 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb,
 		}
 
 		/* Fell behind? */
-		if (uhci_frame_before_eq(frame, next)) {
+		if (!uhci_frame_before_eq(next, frame)) {
 
 			/* USB_ISO_ASAP: Round up to the first available slot */
 			if (urb-&gt;transfer_flags &amp; URB_ISO_ASAP)
@@ -1311,13 +1311,17 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb,
 						-qh-&gt;period;
 
 			/*
-			 * Not ASAP: Use the next slot in the stream.  If
-			 * the entire URB falls before the threshold, fail.
+			 * Not ASAP: Use the next slot in the stream,
+			 * no matter what.
 			 */
 			else if (!uhci_frame_before_eq(next,
 					frame + (urb-&gt;number_of_packets - 1) *
 						qh-&gt;period))
-				return -EXDEV;
+				dev_dbg(uhci_dev(uhci), "iso underrun %p (%u+%u &lt; %u)\n",
+						urb, frame,
+						(urb-&gt;number_of_packets - 1) *
+							qh-&gt;period,
+						next);
 		}
 	}
 </pre><hr><pre>commit 8937669fd637e2edff05973cb1fdee5f910cbcc7
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 24 15:48:05 2013 -0400

    USB: iMX21: accept very late isochronous URBs
    
    Commit 24f531371de1 (USB: EHCI: accept very late isochronous URBs)
    changed the isochronous API provided by ehci-hcd.  URBs submitted too
    late, so that the time slots for all their packets have already
    expired, are no longer rejected outright.  Instead the submission is
    accepted, and the URB completes normally with a -EXDEV error for each
    packet.  This is what client drivers expect.
    
    The same policy should be implemented in imx21-hcd, but I don't know
    enough about the hardware to do it.  As a second-best substitute, this
    patch treats very late isochronous submissions as though the
    URB_ISO_ASAP flag were set.  I don't have any way to test this change,
    unfortunately.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Sascha Hauer &lt;kernel@pengutronix.de&gt;
    CC: Martin Fuzzey &lt;mfuzzey@gmail.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/imx21-hcd.c b/drivers/usb/host/imx21-hcd.c
index 60a5de505ca1..adb01d950a16 100644
--- a/drivers/usb/host/imx21-hcd.c
+++ b/drivers/usb/host/imx21-hcd.c
@@ -824,13 +824,13 @@ static int imx21_hc_urb_enqueue_isoc(struct usb_hcd *hcd,
 			i = DIV_ROUND_UP(wrap_frame(
 					cur_frame - urb-&gt;start_frame),
 					urb-&gt;interval);
-			if (urb-&gt;transfer_flags &amp; URB_ISO_ASAP) {
+
+			/* Treat underruns as if URB_ISO_ASAP was set */
+			if ((urb-&gt;transfer_flags &amp; URB_ISO_ASAP) ||
+					i &gt;= urb-&gt;number_of_packets) {
 				urb-&gt;start_frame = wrap_frame(urb-&gt;start_frame
 						+ i * urb-&gt;interval);
 				i = 0;
-			} else if (i &gt;= urb-&gt;number_of_packets) {
-				ret = -EXDEV;
-				goto alloc_dmem_failed;
 			}
 		}
 	}</pre><hr><pre>commit 46c73d1d3ebc38feed1d97c6980252a0a01f6a5b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 3 13:59:03 2013 -0400

    USB: EHCI: handle isochronous underruns with tasklets
    
    This patch updates the iso_stream_schedule() routine in ehci-sched.c
    to handle cases where an underrun causes an isochronous endpoint's
    queue to empty out, but the client driver wants to maintain
    synchronization with the device (i.e., the URB_ISO_ASAP flag is not
    set).  This could not happen until recently, when ehci-hcd switched
    over to completing URBs in a tasklet.
    
    (This may seem like an unlikely case to worry about, but underruns are
    all too common with the snd-usb-audio driver, which doesn't use
    URB_ISO_ASAP.)
    
    As part of the fix, some URBs may need to be given back when they are
    submitted.  This is necessary when the URB's scheduled slots all fall
    before the current value of ehci-&gt;last_iso_frame, and as an
    optimization we do it also when the slots all fall before the current
    frame number.
    
    As a second part of the fix, we may need to skip some but not all of
    an URB's packets.  This is necessary when some of the URB's scheduled
    slots fall before the current value of ehci-&gt;last_iso_frame and some
    of them fall after the current frame number.  A new field
    (first_packet) is added to struct ehci_iso_sched, to indicate how many
    packets should be skipped.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Ming Lei &lt;tom.leiming@gmail.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 208518bc6e36..dcbaad94d607 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -1370,10 +1370,12 @@ iso_stream_schedule (
 	struct ehci_iso_stream	*stream
 )
 {
-	u32			now, base, next, start, period, span;
-	int			status;
+	u32			now, base, next, start, period, span, now2;
+	u32			wrap = 0, skip = 0;
+	int			status = 0;
 	unsigned		mod = ehci-&gt;periodic_size &lt;&lt; 3;
 	struct ehci_iso_sched	*sched = urb-&gt;hcpriv;
+	bool			empty = list_empty(&amp;stream-&gt;td_list);
 
 	period = urb-&gt;interval;
 	span = sched-&gt;span;
@@ -1384,6 +1386,19 @@ iso_stream_schedule (
 
 	now = ehci_read_frame_index(ehci) &amp; (mod - 1);
 
+	/* Take the isochronous scheduling threshold into account */
+	if (ehci-&gt;i_thresh)
+		next = now + ehci-&gt;i_thresh;	/* uframe cache */
+	else
+		next = (now + 2 + 7) &amp; ~0x07;	/* full frame cache */
+
+	/*
+	 * Use ehci-&gt;last_iso_frame as the base.  There can't be any
+	 * TDs scheduled for earlier than that.
+	 */
+	base = ehci-&gt;last_iso_frame &lt;&lt; 3;
+	next = (next - base) &amp; (mod - 1);
+
 	/*
 	 * Need to schedule; when's the next (u)frame we could start?
 	 * This is bigger than ehci-&gt;i_thresh allows; scheduling itself
@@ -1391,11 +1406,11 @@ iso_stream_schedule (
 	 * can also help high bandwidth if the dma and irq loads don't
 	 * jump until after the queue is primed.
 	 */
-	if (unlikely(list_empty(&amp;stream-&gt;td_list))) {
+	if (unlikely(empty &amp;&amp; !hcd_periodic_completion_in_progress(
+			ehci_to_hcd(ehci), urb-&gt;ep))) {
 		int done = 0;
 
-		base = now &amp; ~0x07;
-		start = base + SCHEDULING_DELAY;
+		start = (now &amp; ~0x07) + SCHEDULING_DELAY;
 
 		/* find a uframe slot with enough bandwidth.
 		 * Early uframes are more precious because full-speed
@@ -1426,6 +1441,9 @@ iso_stream_schedule (
 			status = -ENOSPC;
 			goto fail;
 		}
+
+		start = (start - base) &amp; (mod - 1);
+		goto use_start;
 	}
 
 	/*
@@ -1434,72 +1452,85 @@ iso_stream_schedule (
 	 * (irq delays etc).  If there are, the behavior depends on
 	 * whether URB_ISO_ASAP is set.
 	 */
-	else {
+	start = (stream-&gt;next_uframe - base) &amp; (mod - 1);
+	now2 = (now - base) &amp; (mod - 1);
 
-		/* Take the isochronous scheduling threshold into account */
-		if (ehci-&gt;i_thresh)
-			next = now + ehci-&gt;i_thresh;	/* uframe cache */
-		else
-			next = (now + 2 + 7) &amp; ~0x07;	/* full frame cache */
+	/* Is the schedule already full? */
+	if (unlikely(!empty &amp;&amp; start &lt; period)) {
+		ehci_dbg(ehci, "iso sched full %p (%u-%u &lt; %u mod %u)\n",
+				urb, stream-&gt;next_uframe, base, period, mod);
+		status = -ENOSPC;
+		goto fail;
+	}
 
-		/*
-		 * Use ehci-&gt;last_iso_frame as the base.  There can't be any
-		 * TDs scheduled for earlier than that.
-		 */
-		base = ehci-&gt;last_iso_frame &lt;&lt; 3;
-		next = (next - base) &amp; (mod - 1);
-		start = (stream-&gt;next_uframe - base) &amp; (mod - 1);
-
-		/* Is the schedule already full? */
-		if (unlikely(start &lt; period)) {
-			ehci_dbg(ehci, "iso sched full %p (%u-%u &lt; %u mod %u)\n",
-					urb, stream-&gt;next_uframe, base,
-					period, mod);
-			status = -ENOSPC;
-			goto fail;
-		}
+	/* Is the next packet scheduled after the base time? */
+	if (likely(!empty || start &lt;= now2 + period)) {
 
-		/* Behind the scheduling threshold? */
-		if (unlikely(start &lt; next)) {
-			unsigned now2 = (now - base) &amp; (mod - 1);
+		/* URB_ISO_ASAP: make sure that start &gt;= next */
+		if (unlikely(start &lt; next &amp;&amp;
+				(urb-&gt;transfer_flags &amp; URB_ISO_ASAP)))
+			goto do_ASAP;
 
-			/* USB_ISO_ASAP: Round up to the first available slot */
-			if (urb-&gt;transfer_flags &amp; URB_ISO_ASAP)
-				start += (next - start + period - 1) &amp; -period;
+		/* Otherwise use start, if it's not in the past */
+		if (likely(start &gt;= now2))
+			goto use_start;
 
-			/*
-			 * Not ASAP: Use the next slot in the stream,
-			 * no matter what.
-			 */
-			else if (start + span - period &lt; now2) {
-				ehci_dbg(ehci, "iso underrun %p (%u+%u &lt; %u)\n",
-						urb, start + base,
-						span - period, now2 + base);
-			}
-		}
+	/* Otherwise we got an underrun while the queue was empty */
+	} else {
+		if (urb-&gt;transfer_flags &amp; URB_ISO_ASAP)
+			goto do_ASAP;
+		wrap = mod;
+		now2 += mod;
+	}
 
-		start += base;
+	/* How many uframes and packets do we need to skip? */
+	skip = (now2 - start + period - 1) &amp; -period;
+	if (skip &gt;= span) {		/* Entirely in the past? */
+		ehci_dbg(ehci, "iso underrun %p (%u+%u &lt; %u) [%u]\n",
+				urb, start + base, span - period, now2 + base,
+				base);
+
+		/* Try to keep the last TD intact for scanning later */
+		skip = span - period;
+
+		/* Will it come before the current scan position? */
+		if (empty) {
+			skip = span;	/* Skip the entire URB */
+			status = 1;	/* and give it back immediately */
+			iso_sched_free(stream, sched);
+			sched = NULL;
+		}
 	}
+	urb-&gt;error_count = skip / period;
+	if (sched)
+		sched-&gt;first_packet = urb-&gt;error_count;
+	goto use_start;
 
+ do_ASAP:
+	/* Use the first slot after "next" */
+	start = next + ((start - next) &amp; (period - 1));
+
+ use_start:
 	/* Tried to schedule too far into the future? */
-	if (unlikely(start - base + span - period &gt;= mod)) {
+	if (unlikely(start + span - period &gt;= mod + wrap)) {
 		ehci_dbg(ehci, "request %p would overflow (%u+%u &gt;= %u)\n",
-				urb, start - base, span - period, mod);
+				urb, start, span - period, mod + wrap);
 		status = -EFBIG;
 		goto fail;
 	}
 
-	stream-&gt;next_uframe = start &amp; (mod - 1);
+	start += base;
+	stream-&gt;next_uframe = (start + skip) &amp; (mod - 1);
 
 	/* report high speed start in uframes; full speed, in frames */
-	urb-&gt;start_frame = stream-&gt;next_uframe;
+	urb-&gt;start_frame = start &amp; (mod - 1);
 	if (!stream-&gt;highspeed)
 		urb-&gt;start_frame &gt;&gt;= 3;
 
 	/* Make sure scan_isoc() sees these */
 	if (ehci-&gt;isoc_count == 0)
 		ehci-&gt;last_iso_frame = now &gt;&gt; 3;
-	return 0;
+	return status;
 
  fail:
 	iso_sched_free(stream, sched);
@@ -1612,7 +1643,8 @@ static void itd_link_urb(
 	ehci_to_hcd(ehci)-&gt;self.bandwidth_isoc_reqs++;
 
 	/* fill iTDs uframe by uframe */
-	for (packet = 0, itd = NULL; packet &lt; urb-&gt;number_of_packets; ) {
+	for (packet = iso_sched-&gt;first_packet, itd = NULL;
+			packet &lt; urb-&gt;number_of_packets;) {
 		if (itd == NULL) {
 			/* ASSERT:  we have all necessary itds */
 			// BUG_ON (list_empty (&amp;iso_sched-&gt;td_list));
@@ -1806,10 +1838,14 @@ static int itd_submit (struct ehci_hcd *ehci, struct urb *urb,
 	if (unlikely(status))
 		goto done_not_linked;
 	status = iso_stream_schedule(ehci, urb, stream);
-	if (likely (status == 0))
+	if (likely(status == 0)) {
 		itd_link_urb (ehci, urb, ehci-&gt;periodic_size &lt;&lt; 3, stream);
-	else
+	} else if (status &gt; 0) {
+		status = 0;
+		ehci_urb_done(ehci, urb, 0);
+	} else {
 		usb_hcd_unlink_urb_from_ep(ehci_to_hcd(ehci), urb);
+	}
  done_not_linked:
 	spin_unlock_irqrestore (&amp;ehci-&gt;lock, flags);
  done:
@@ -2010,7 +2046,7 @@ static void sitd_link_urb(
 	ehci_to_hcd(ehci)-&gt;self.bandwidth_isoc_reqs++;
 
 	/* fill sITDs frame by frame */
-	for (packet = 0, sitd = NULL;
+	for (packet = sched-&gt;first_packet, sitd = NULL;
 			packet &lt; urb-&gt;number_of_packets;
 			packet++) {
 
@@ -2180,10 +2216,14 @@ static int sitd_submit (struct ehci_hcd *ehci, struct urb *urb,
 	if (unlikely(status))
 		goto done_not_linked;
 	status = iso_stream_schedule(ehci, urb, stream);
-	if (status == 0)
+	if (likely(status == 0)) {
 		sitd_link_urb (ehci, urb, ehci-&gt;periodic_size &lt;&lt; 3, stream);
-	else
+	} else if (status &gt; 0) {
+		status = 0;
+		ehci_urb_done(ehci, urb, 0);
+	} else {
 		usb_hcd_unlink_urb_from_ep(ehci_to_hcd(ehci), urb);
+	}
  done_not_linked:
 	spin_unlock_irqrestore (&amp;ehci-&gt;lock, flags);
  done:
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 291db7d09f22..2d401927e143 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -434,6 +434,7 @@ struct ehci_iso_packet {
 struct ehci_iso_sched {
 	struct list_head	td_list;
 	unsigned		span;
+	unsigned		first_packet;
 	struct ehci_iso_packet	packet [0];
 };
 </pre><hr><pre>commit e4e18cbd52c8efb0d73a66d0598dc887c0feefb7
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 3 13:58:59 2013 -0400

    USB: EHCI: code rearrangement in iso_stream_schedule()
    
    This patch interchanges the "if" and "else" branches of the big "if"
    statement in iso_stream_schedule(), in preparation for the next patch
    in this series.  That is, it changes
    
            if (likely(!...)) {
                    A
            } else {
                    B
            }
    
    to
    
            if (unlikely(...)) {
                    B
            } else {
                    A
            }
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 85dd24ed97a6..208518bc6e36 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -1384,12 +1384,57 @@ iso_stream_schedule (
 
 	now = ehci_read_frame_index(ehci) &amp; (mod - 1);
 
-	/* Typical case: reuse current schedule, stream is still active.
+	/*
+	 * Need to schedule; when's the next (u)frame we could start?
+	 * This is bigger than ehci-&gt;i_thresh allows; scheduling itself
+	 * isn't free, the delay should handle reasonably slow cpus.  It
+	 * can also help high bandwidth if the dma and irq loads don't
+	 * jump until after the queue is primed.
+	 */
+	if (unlikely(list_empty(&amp;stream-&gt;td_list))) {
+		int done = 0;
+
+		base = now &amp; ~0x07;
+		start = base + SCHEDULING_DELAY;
+
+		/* find a uframe slot with enough bandwidth.
+		 * Early uframes are more precious because full-speed
+		 * iso IN transfers can't use late uframes,
+		 * and therefore they should be allocated last.
+		 */
+		next = start;
+		start += period;
+		do {
+			start--;
+			/* check schedule: enough space? */
+			if (stream-&gt;highspeed) {
+				if (itd_slot_ok(ehci, mod, start,
+						stream-&gt;usecs, period))
+					done = 1;
+			} else {
+				if ((start % 8) &gt;= 6)
+					continue;
+				if (sitd_slot_ok(ehci, mod, stream,
+						start, sched, period))
+					done = 1;
+			}
+		} while (start &gt; next &amp;&amp; !done);
+
+		/* no room in the schedule */
+		if (!done) {
+			ehci_dbg(ehci, "iso sched full %p", urb);
+			status = -ENOSPC;
+			goto fail;
+		}
+	}
+
+	/*
+	 * Typical case: reuse current schedule, stream is still active.
 	 * Hopefully there are no gaps from the host falling behind
 	 * (irq delays etc).  If there are, the behavior depends on
 	 * whether URB_ISO_ASAP is set.
 	 */
-	if (likely (!list_empty (&amp;stream-&gt;td_list))) {
+	else {
 
 		/* Take the isochronous scheduling threshold into account */
 		if (ehci-&gt;i_thresh)
@@ -1436,49 +1481,6 @@ iso_stream_schedule (
 		start += base;
 	}
 
-	/* need to schedule; when's the next (u)frame we could start?
-	 * this is bigger than ehci-&gt;i_thresh allows; scheduling itself
-	 * isn't free, the delay should handle reasonably slow cpus.  it
-	 * can also help high bandwidth if the dma and irq loads don't
-	 * jump until after the queue is primed.
-	 */
-	else {
-		int done = 0;
-
-		base = now &amp; ~0x07;
-		start = base + SCHEDULING_DELAY;
-
-		/* find a uframe slot with enough bandwidth.
-		 * Early uframes are more precious because full-speed
-		 * iso IN transfers can't use late uframes,
-		 * and therefore they should be allocated last.
-		 */
-		next = start;
-		start += period;
-		do {
-			start--;
-			/* check schedule: enough space? */
-			if (stream-&gt;highspeed) {
-				if (itd_slot_ok(ehci, mod, start,
-						stream-&gt;usecs, period))
-					done = 1;
-			} else {
-				if ((start % 8) &gt;= 6)
-					continue;
-				if (sitd_slot_ok(ehci, mod, stream,
-						start, sched, period))
-					done = 1;
-			}
-		} while (start &gt; next &amp;&amp; !done);
-
-		/* no room in the schedule */
-		if (!done) {
-			ehci_dbg(ehci, "iso sched full %p", urb);
-			status = -ENOSPC;
-			goto fail;
-		}
-	}
-
 	/* Tried to schedule too far into the future? */
 	if (unlikely(start - base + span - period &gt;= mod)) {
 		ehci_dbg(ehci, "request %p would overflow (%u+%u &gt;= %u)\n",</pre><hr><pre>commit c7ccde6eac6d3c4bc6110cc3fd76ef3823bc0831
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 3 13:58:43 2013 -0400

    USB: see if URB comes from a completion handler
    
    Now that URBs can be completed inside tasklets, we need a way of
    determining whether a completion handler for a given endpoint is
    currently running.  Otherwise it's not possible to maintain the API
    guarantee about keeping isochronous streams synchronous when an
    underrun occurs.
    
    This patch adds a field and a routine to check whether a completion
    handler for a periodic endpoint is running.  At the moment no
    analogous routine appears to be necessary for async endpoints, but one
    can always be added.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Ming Lei &lt;tom.leiming@gmail.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index d6a8d23f047b..3a2e82a9c115 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1703,7 +1703,9 @@ static void usb_giveback_urb_bh(unsigned long param)
 
 		urb = list_entry(local_list.next, struct urb, urb_list);
 		list_del_init(&amp;urb-&gt;urb_list);
+		bh-&gt;completing_ep = urb-&gt;ep;
 		__usb_hcd_giveback_urb(urb);
+		bh-&gt;completing_ep = NULL;
 	}
 
 	/* check if there are new URBs to giveback */
diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 75efc45eaa2f..8c865134c881 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -73,6 +73,7 @@ struct giveback_urb_bh {
 	spinlock_t lock;
 	struct list_head  head;
 	struct tasklet_struct bh;
+	struct usb_host_endpoint *completing_ep;
 };
 
 struct usb_hcd {
@@ -378,6 +379,12 @@ static inline int hcd_giveback_urb_in_bh(struct usb_hcd *hcd)
 	return hcd-&gt;driver-&gt;flags &amp; HCD_BH;
 }
 
+static inline bool hcd_periodic_completion_in_progress(struct usb_hcd *hcd,
+		struct usb_host_endpoint *ep)
+{
+	return hcd-&gt;high_prio_bh.completing_ep == ep;
+}
+
 extern int usb_hcd_link_urb_to_ep(struct usb_hcd *hcd, struct urb *urb);
 extern int usb_hcd_check_unlink_urb(struct usb_hcd *hcd, struct urb *urb,
 		int status);</pre><hr><pre>commit 5f5610f69be3a925b1f79af27150bb7377bc9ad6
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jul 30 15:18:15 2013 -0400

    usb: gadget: fix a bug and a WARN_ON in dummy-hcd
    
    This patch fixes a NULL pointer dereference and a WARN_ON in
    dummy-hcd.  These things were the result of moving to the UDC core
    framework, and possibly of changes to that framework.
    
    Now unloading a gadget driver causes the UDC to be stopped after the
    gadget driver is unbound, not before.  Therefore the "driver" argument
    to dummy_udc_stop() can be NULL, so we must not try to print the
    driver's name without checking first.
    
    Also, the UDC framework automatically unregisters the gadget when the
    UDC is deleted.  Therefore a sysfs attribute file attached to the
    gadget must be removed before the UDC is deleted, not after.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Felipe Balbi &lt;balbi@ti.com&gt;

diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index 06ecd08fd57a..b8a2376971a4 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -923,8 +923,9 @@ static int dummy_udc_stop(struct usb_gadget *g,
 	struct dummy_hcd	*dum_hcd = gadget_to_dummy_hcd(g);
 	struct dummy		*dum = dum_hcd-&gt;dum;
 
-	dev_dbg(udc_dev(dum), "unregister gadget driver '%s'\n",
-			driver-&gt;driver.name);
+	if (driver)
+		dev_dbg(udc_dev(dum), "unregister gadget driver '%s'\n",
+				driver-&gt;driver.name);
 
 	dum-&gt;driver = NULL;
 
@@ -1000,8 +1001,8 @@ static int dummy_udc_remove(struct platform_device *pdev)
 {
 	struct dummy	*dum = platform_get_drvdata(pdev);
 
-	usb_del_gadget_udc(&amp;dum-&gt;gadget);
 	device_remove_file(&amp;dum-&gt;gadget.dev, &amp;dev_attr_function);
+	usb_del_gadget_udc(&amp;dum-&gt;gadget);
 	return 0;
 }
 </pre><hr><pre>commit 984f1733fcee3fbc78d47e26c5096921c5d9946a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Sep 6 11:49:51 2013 -0400

    [SCSI] sd: Fix potential out-of-bounds access
    
    This patch fixes an out-of-bounds error in sd_read_cache_type(), found
    by Google's AddressSanitizer tool.  When the loop ends, we know that
    "offset" lies beyond the end of the data in the buffer, so no Caching
    mode page was found.  In theory it may be present, but the buffer size
    is limited to 512 bytes.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Dmitry Vyukov &lt;dvyukov@google.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: James Bottomley &lt;JBottomley@Parallels.com&gt;

diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c
index b58e8f815a00..e62d17d41d4e 100644
--- a/drivers/scsi/sd.c
+++ b/drivers/scsi/sd.c
@@ -2420,14 +2420,9 @@ sd_read_cache_type(struct scsi_disk *sdkp, unsigned char *buffer)
 			}
 		}
 
-		if (modepage == 0x3F) {
-			sd_printk(KERN_ERR, sdkp, "No Caching mode page "
-				  "present\n");
-			goto defaults;
-		} else if ((buffer[offset] &amp; 0x3f) != modepage) {
-			sd_printk(KERN_ERR, sdkp, "Got wrong page\n");
-			goto defaults;
-		}
+		sd_printk(KERN_ERR, sdkp, "No Caching mode page found\n");
+		goto defaults;
+
 	Page_found:
 		if (modepage == 8) {
 			sdkp-&gt;WCE = ((buffer[offset + 2] &amp; 0x04) != 0);</pre>
    <div class="pagination">
        <a href='2_32.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><span>[33]</span><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_34.html'>Next&gt;&gt;</a>
    <div>
</body>
