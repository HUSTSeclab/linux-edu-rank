<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_131.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><span>[132]</span><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_133.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 42245e65f356ed54fdf7a1f9a0095e0bc40f73a3
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Dec 16 11:09:01 2005 -0800

    [PATCH] UHCI: add missing memory barriers
    
    This patch (as617) adds a couple of memory barriers that Ben H. forgot in
    his recent suspend/resume fix.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index ed550132db0b..79efaf7d86a3 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -717,6 +717,7 @@ static int uhci_suspend(struct usb_hcd *hcd, pm_message_t message)
 	 * at the source, so we must turn off PIRQ.
 	 */
 	pci_write_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP, 0);
+	mb();
 	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
 	uhci-&gt;hc_inaccessible = 1;
 	hcd-&gt;poll_rh = 0;
@@ -738,6 +739,7 @@ static int uhci_resume(struct usb_hcd *hcd)
 	 * really don't want to keep a stale HCD_FLAG_HW_ACCESSIBLE=0
 	 */
 	set_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
+	mb();
 
 	if (uhci-&gt;rh_state == UHCI_RH_RESET)	/* Dead */
 		return 0;</pre><hr><pre>commit 38d76df2f5483478dee803cb6e39da5e506a6643
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Dec 9 11:34:45 2005 -0500

    [SCSI] sd: Always do write-protect check
    
    Since nobody has offered an explanation for why the sd driver makes a
    write-protect check only for devices with removable media, I'm submitting
    this patch to get rid of the removable-media test.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c
index 8613a1317712..d82795455efb 100644
--- a/drivers/scsi/sd.c
+++ b/drivers/scsi/sd.c
@@ -1509,9 +1509,7 @@ static int sd_revalidate_disk(struct gendisk *disk)
 	 */
 	if (sdkp-&gt;media_present) {
 		sd_read_capacity(sdkp, disk-&gt;disk_name, buffer);
-		if (sdp-&gt;removable)
-			sd_read_write_protect_flag(sdkp, disk-&gt;disk_name,
-						   buffer);
+		sd_read_write_protect_flag(sdkp, disk-&gt;disk_name, buffer);
 		sd_read_cache_type(sdkp, disk-&gt;disk_name, buffer);
 	}
 		</pre><hr><pre>commit 620948a01c71060a32611bc2f792f58a88cf28b1
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Nov 28 15:22:55 2005 -0500

    [PATCH] USB: documentation update
    
    This patch (as611) fixes a minor mistake and misspelling in the USB
    documentation.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/Documentation/usb/error-codes.txt b/Documentation/usb/error-codes.txt
index 1e36f1661cd0..867f4c38f356 100644
--- a/Documentation/usb/error-codes.txt
+++ b/Documentation/usb/error-codes.txt
@@ -46,8 +46,9 @@ USB-specific:
 
 -EMSGSIZE	(a) endpoint maxpacket size is zero; it is not usable
 		    in the current interface altsetting.
-		(b) ISO packet is biger than endpoint maxpacket
-		(c) requested data transfer size is invalid (negative)
+		(b) ISO packet is larger than the endpoint maxpacket.
+		(c) requested data transfer length is invalid: negative
+		    or too large for the host controller.
 
 -ENOSPC		This request would overcommit the usb bandwidth reserved
 		for periodic transfers (interrupt, isochronous).</pre><hr><pre>commit e0f39591cc178026607fcbbe9a53be435fe8285d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Nov 28 13:43:44 2005 -0800

    [PATCH] Workaround for gcc 2.96 (undefined references)
    
      LD      .tmp_vmlinux1
    mm/built-in.o(.text+0x100d6): In function `copy_page_range':
    : undefined reference to `__pud_alloc'
    mm/built-in.o(.text+0x1010b): In function `copy_page_range':
    : undefined reference to `__pmd_alloc'
    mm/built-in.o(.text+0x11ef4): In function `__handle_mm_fault':
    : undefined reference to `__pud_alloc'
    fs/built-in.o(.text+0xc930): In function `install_arg_page':
    : undefined reference to `__pud_alloc'
    make: *** [.tmp_vmlinux1] Error 1
    
    Those missing references in mm/memory.c arise from this code in
    include/linux/mm.h, combined with the fact that __PGTABLE_PMD_FOLDED and
    __PGTABLE_PUD_FOLDED are both set and __ARCH_HAS_4LEVEL_HACK is not:
    
    /*
     * The following ifdef needed to get the 4level-fixup.h header to work.
     * Remove it when 4level-fixup.h has been removed.
     */
    #if defined(CONFIG_MMU) &amp;&amp; !defined(__ARCH_HAS_4LEVEL_HACK)
    static inline pud_t *pud_alloc(struct mm_struct *mm, pgd_t *pgd, unsigned long address)
    {
            return (unlikely(pgd_none(*pgd)) &amp;&amp; __pud_alloc(mm, pgd, address))?
                    NULL: pud_offset(pgd, address);
    }
    
    static inline pmd_t *pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)
    {
            return (unlikely(pud_none(*pud)) &amp;&amp; __pmd_alloc(mm, pud, address))?
                    NULL: pmd_offset(pud, address);
    }
    #endif /* CONFIG_MMU &amp;&amp; !__ARCH_HAS_4LEVEL_HACK */
    
    With my configuration the pgd_none and pud_none routines are inlines
    returning a constant 0.  Apparently the old compiler avoids generating
    calls to __pud_alloc and __pmd_alloc but still lists them as undefined
    references in the module's symbol table.
    
    I don't know which change caused this problem.  I think it was added
    somewhere between 2.6.14 and 2.6.15-rc1, because I remember building
    several 2.6.14-rc kernels without difficulty.  However I can't point to an
    individual culprit.
    
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/mm/memory.c b/mm/memory.c
index b57fbc636058..9ab206b829a2 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -2160,6 +2160,12 @@ int __pud_alloc(struct mm_struct *mm, pgd_t *pgd, unsigned long address)
 	spin_unlock(&amp;mm-&gt;page_table_lock);
 	return 0;
 }
+#else
+/* Workaround for gcc 2.96 */
+int __pud_alloc(struct mm_struct *mm, pgd_t *pgd, unsigned long address)
+{
+	return 0;
+}
 #endif /* __PAGETABLE_PUD_FOLDED */
 
 #ifndef __PAGETABLE_PMD_FOLDED
@@ -2188,6 +2194,12 @@ int __pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)
 	spin_unlock(&amp;mm-&gt;page_table_lock);
 	return 0;
 }
+#else
+/* Workaround for gcc 2.96 */
+int __pmd_alloc(struct mm_struct *mm, pud_t *pud, unsigned long address)
+{
+	return 0;
+}
 #endif /* __PAGETABLE_PMD_FOLDED */
 
 int make_pages_present(unsigned long addr, unsigned long end)</pre><hr><pre>commit 2b08c8d0468866f86da97f836c6ac14338cb81a9
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Nov 23 15:43:50 2005 -0800

    [PATCH] Small fixes to driver core
    
    This patch (as603) makes a few small fixes to the driver core:
    
    Change spin_lock_irq for a klist lock to spin_lock;
    
    Fix reference count leaks;
    
    Minor spelling and formatting changes.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by Patrick Mochel &lt;mochel@digitalimplant.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/drivers/base/bus.c b/drivers/base/bus.c
index 03204bfd17af..fa601b085eba 100644
--- a/drivers/base/bus.c
+++ b/drivers/base/bus.c
@@ -133,7 +133,7 @@ static struct kobj_type ktype_bus = {
 decl_subsys(bus, &amp;ktype_bus, NULL);
 
 
-/* Manually detach a device from it's associated driver. */
+/* Manually detach a device from its associated driver. */
 static int driver_helper(struct device *dev, void *data)
 {
 	const char *name = data;
@@ -151,14 +151,13 @@ static ssize_t driver_unbind(struct device_driver *drv,
 	int err = -ENODEV;
 
 	dev = bus_find_device(bus, NULL, (void *)buf, driver_helper);
-	if ((dev) &amp;&amp;
-	    (dev-&gt;driver == drv)) {
+	if (dev &amp;&amp; dev-&gt;driver == drv) {
 		device_release_driver(dev);
 		err = count;
 	}
-	if (err)
-		return err;
-	return count;
+	put_device(dev);
+	put_bus(bus);
+	return err;
 }
 static DRIVER_ATTR(unbind, S_IWUSR, NULL, driver_unbind);
 
@@ -175,16 +174,14 @@ static ssize_t driver_bind(struct device_driver *drv,
 	int err = -ENODEV;
 
 	dev = bus_find_device(bus, NULL, (void *)buf, driver_helper);
-	if ((dev) &amp;&amp;
-	    (dev-&gt;driver == NULL)) {
+	if (dev &amp;&amp; dev-&gt;driver == NULL) {
 		down(&amp;dev-&gt;sem);
 		err = driver_probe_device(drv, dev);
 		up(&amp;dev-&gt;sem);
-		put_device(dev);
 	}
-	if (err)
-		return err;
-	return count;
+	put_device(dev);
+	put_bus(bus);
+	return err;
 }
 static DRIVER_ATTR(bind, S_IWUSR, NULL, driver_bind);
 
diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 3565e9795301..3b419c9a1e7e 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -62,7 +62,6 @@ void device_bind_driver(struct device * dev)
  *	because we don't know the format of the ID structures, nor what
  *	is to be considered a match and what is not.
  *
- *
  *	This function returns 1 if a match is found, an error if one
  *	occurs (that is not -ENODEV or -ENXIO), and 0 otherwise.
  *
@@ -158,7 +157,6 @@ static int __driver_attach(struct device * dev, void * data)
 		driver_probe_device(drv, dev);
 	up(&amp;dev-&gt;sem);
 
-
 	return 0;
 }
 
@@ -225,15 +223,15 @@ void driver_detach(struct device_driver * drv)
 	struct device * dev;
 
 	for (;;) {
-		spin_lock_irq(&amp;drv-&gt;klist_devices.k_lock);
+		spin_lock(&amp;drv-&gt;klist_devices.k_lock);
 		if (list_empty(&amp;drv-&gt;klist_devices.k_list)) {
-			spin_unlock_irq(&amp;drv-&gt;klist_devices.k_lock);
+			spin_unlock(&amp;drv-&gt;klist_devices.k_lock);
 			break;
 		}
 		dev = list_entry(drv-&gt;klist_devices.k_list.prev,
 				struct device, knode_driver.n_node);
 		get_device(dev);
-		spin_unlock_irq(&amp;drv-&gt;klist_devices.k_lock);
+		spin_unlock(&amp;drv-&gt;klist_devices.k_lock);
 
 		down(&amp;dev-&gt;sem);
 		if (dev-&gt;driver == drv)</pre><hr><pre>commit 2ef8919830a262f10fb5e4a685e95f71a64bce6c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Nov 8 15:51:55 2005 -0500

    [SCSI] Fix refcount leak in scsi_report_lun_scan
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c
index 7eb3a2d40dc5..27bcc8fb8cbc 100644
--- a/drivers/scsi/scsi_scan.c
+++ b/drivers/scsi/scsi_scan.c
@@ -1074,6 +1074,7 @@ static int scsi_report_lun_scan(struct scsi_target *starget, int bflags,
 	struct scsi_sense_hdr sshdr;
 	struct scsi_device *sdev;
 	struct Scsi_Host *shost = dev_to_shost(&amp;starget-&gt;dev);
+	int ret = 0;
 
 	/*
 	 * Only support SCSI-3 and up devices if BLIST_NOREPORTLUN is not set.
@@ -1169,8 +1170,8 @@ static int scsi_report_lun_scan(struct scsi_target *starget, int bflags,
 		/*
 		 * The device probably does not support a REPORT LUN command
 		 */
-		kfree(lun_data);
-		return 1;
+		ret = 1;
+		goto out_err;
 	}
 
 	/*
@@ -1238,6 +1239,7 @@ static int scsi_report_lun_scan(struct scsi_target *starget, int bflags,
 		}
 	}
 
+ out_err:
 	kfree(lun_data);
  out:
 	scsi_device_put(sdev);
@@ -1246,7 +1248,7 @@ static int scsi_report_lun_scan(struct scsi_target *starget, int bflags,
 		 * the sdev we used didn't appear in the report luns scan
 		 */
 		scsi_destroy_sdev(sdev);
-	return 0;
+	return ret;
 }
 
 struct scsi_device *__scsi_add_device(struct Scsi_Host *shost, uint channel,</pre><hr><pre>commit 39b7f1e25a412b0ef31e516cfc2fa4f40235f263
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Nov 4 14:44:41 2005 -0500

    [SCSI] sd: Fix refcounting
    
    Currently the driver takes a reference only for requests coming by way
    of the gendisk, not for requests coming by way of the struct device or
    struct scsi_device.  Such requests can arrive in the rescan, flush,
    and shutdown pathways.
    
    The patch also makes the scsi_disk keep a reference to the underlying
    scsi_device, and it erases the scsi_device's pointer to the scsi_disk
    when the scsi_device is removed (since the pointer should no longer be
    used).
    
    This resolves Bugzilla entry #5237.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c
index 9de8e186cb69..bb5b242ac6b4 100644
--- a/drivers/scsi/sd.c
+++ b/drivers/scsi/sd.c
@@ -177,24 +177,38 @@ static inline struct scsi_disk *scsi_disk(struct gendisk *disk)
 	return container_of(disk-&gt;private_data, struct scsi_disk, driver);
 }
 
-static struct scsi_disk *scsi_disk_get(struct gendisk *disk)
+static struct scsi_disk *__scsi_disk_get(struct gendisk *disk)
 {
 	struct scsi_disk *sdkp = NULL;
 
+	if (disk-&gt;private_data) {
+		sdkp = scsi_disk(disk);
+		if (scsi_device_get(sdkp-&gt;device) == 0)
+			kref_get(&amp;sdkp-&gt;kref);
+		else
+			sdkp = NULL;
+	}
+	return sdkp;
+}
+
+static struct scsi_disk *scsi_disk_get(struct gendisk *disk)
+{
+	struct scsi_disk *sdkp;
+
 	down(&amp;sd_ref_sem);
-	if (disk-&gt;private_data == NULL)
-		goto out;
-	sdkp = scsi_disk(disk);
-	kref_get(&amp;sdkp-&gt;kref);
-	if (scsi_device_get(sdkp-&gt;device))
-		goto out_put;
+	sdkp = __scsi_disk_get(disk);
 	up(&amp;sd_ref_sem);
 	return sdkp;
+}
 
- out_put:
-	kref_put(&amp;sdkp-&gt;kref, scsi_disk_release);
-	sdkp = NULL;
- out:
+static struct scsi_disk *scsi_disk_get_from_dev(struct device *dev)
+{
+	struct scsi_disk *sdkp;
+
+	down(&amp;sd_ref_sem);
+	sdkp = dev_get_drvdata(dev);
+	if (sdkp)
+		sdkp = __scsi_disk_get(sdkp-&gt;disk);
 	up(&amp;sd_ref_sem);
 	return sdkp;
 }
@@ -716,16 +730,17 @@ static int sd_sync_cache(struct scsi_device *sdp)
 
 static int sd_issue_flush(struct device *dev, sector_t *error_sector)
 {
+	int ret = 0;
 	struct scsi_device *sdp = to_scsi_device(dev);
-	struct scsi_disk *sdkp = dev_get_drvdata(dev);
+	struct scsi_disk *sdkp = scsi_disk_get_from_dev(dev);
 
 	if (!sdkp)
                return -ENODEV;
 
-	if (!sdkp-&gt;WCE)
-		return 0;
-
-	return sd_sync_cache(sdp);
+	if (sdkp-&gt;WCE)
+		ret = sd_sync_cache(sdp);
+	scsi_disk_put(sdkp);
+	return ret;
 }
 
 static void sd_end_flush(request_queue_t *q, struct request *flush_rq)
@@ -754,23 +769,30 @@ static void sd_end_flush(request_queue_t *q, struct request *flush_rq)
 static int sd_prepare_flush(request_queue_t *q, struct request *rq)
 {
 	struct scsi_device *sdev = q-&gt;queuedata;
-	struct scsi_disk *sdkp = dev_get_drvdata(&amp;sdev-&gt;sdev_gendev);
-
-	if (sdkp-&gt;WCE) {
-		memset(rq-&gt;cmd, 0, sizeof(rq-&gt;cmd));
-		rq-&gt;flags |= REQ_BLOCK_PC | REQ_SOFTBARRIER;
-		rq-&gt;timeout = SD_TIMEOUT;
-		rq-&gt;cmd[0] = SYNCHRONIZE_CACHE;
-		return 1;
+	struct scsi_disk *sdkp = scsi_disk_get_from_dev(&amp;sdev-&gt;sdev_gendev);
+	int ret = 0;
+
+	if (sdkp) {
+		if (sdkp-&gt;WCE) {
+			memset(rq-&gt;cmd, 0, sizeof(rq-&gt;cmd));
+			rq-&gt;flags |= REQ_BLOCK_PC | REQ_SOFTBARRIER;
+			rq-&gt;timeout = SD_TIMEOUT;
+			rq-&gt;cmd[0] = SYNCHRONIZE_CACHE;
+			ret = 1;
+		}
+		scsi_disk_put(sdkp);
 	}
-
-	return 0;
+	return ret;
 }
 
 static void sd_rescan(struct device *dev)
 {
-	struct scsi_disk *sdkp = dev_get_drvdata(dev);
-	sd_revalidate_disk(sdkp-&gt;disk);
+	struct scsi_disk *sdkp = scsi_disk_get_from_dev(dev);
+
+	if (sdkp) {
+		sd_revalidate_disk(sdkp-&gt;disk);
+		scsi_disk_put(sdkp);
+	}
 }
 
 
@@ -1561,6 +1583,7 @@ static int sd_probe(struct device *dev)
 	if (error)
 		goto out_put;
 
+	get_device(&amp;sdp-&gt;sdev_gendev);
 	sdkp-&gt;device = sdp;
 	sdkp-&gt;driver = &amp;sd_template;
 	sdkp-&gt;disk = gd;
@@ -1637,7 +1660,9 @@ static int sd_remove(struct device *dev)
 
 	del_gendisk(sdkp-&gt;disk);
 	sd_shutdown(dev);
+
 	down(&amp;sd_ref_sem);
+	dev_set_drvdata(dev, NULL);
 	kref_put(&amp;sdkp-&gt;kref, scsi_disk_release);
 	up(&amp;sd_ref_sem);
 
@@ -1663,8 +1688,8 @@ static void scsi_disk_release(struct kref *kref)
 	spin_unlock(&amp;sd_index_lock);
 
 	disk-&gt;private_data = NULL;
-
 	put_disk(disk);
+	put_device(&amp;sdkp-&gt;device-&gt;sdev_gendev);
 
 	kfree(sdkp);
 }
@@ -1677,18 +1702,18 @@ static void scsi_disk_release(struct kref *kref)
 static void sd_shutdown(struct device *dev)
 {
 	struct scsi_device *sdp = to_scsi_device(dev);
-	struct scsi_disk *sdkp = dev_get_drvdata(dev);
+	struct scsi_disk *sdkp = scsi_disk_get_from_dev(dev);
 
 	if (!sdkp)
 		return;         /* this can happen */
 
-	if (!sdkp-&gt;WCE)
-		return;
-
-	printk(KERN_NOTICE "Synchronizing SCSI cache for disk %s: \n",
-			sdkp-&gt;disk-&gt;disk_name);
-	sd_sync_cache(sdp);
-}	
+	if (sdkp-&gt;WCE) {
+		printk(KERN_NOTICE "Synchronizing SCSI cache for disk %s: \n",
+				sdkp-&gt;disk-&gt;disk_name);
+		sd_sync_cache(sdp);
+	}
+	scsi_disk_put(sdkp);
+}
 
 /**
  *	init_sd - entry point for this driver (both when built in or when</pre><hr><pre>commit 61e1a9ea4b425eb8c3b4965c35fe953bd881728f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sun Oct 30 15:01:40 2005 -0800

    [PATCH] Add kthread_stop_sem()
    
    Enhance the kthread API by adding kthread_stop_sem, for use in stopping
    threads that spend their idle time waiting on a semaphore.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/include/linux/kthread.h b/include/linux/kthread.h
index 3fa786448db3..ebdd41fd1082 100644
--- a/include/linux/kthread.h
+++ b/include/linux/kthread.h
@@ -69,6 +69,18 @@ void kthread_bind(struct task_struct *k, unsigned int cpu);
  * was never called. */
 int kthread_stop(struct task_struct *k);
 
+/**
+ * kthread_stop_sem: stop a thread created by kthread_create().
+ * @k: thread created by kthread_create().
+ * @s: semaphore that @k waits on while idle.
+ *
+ * Does essentially the same thing as kthread_stop() above, but wakes
+ * @k by calling up(@s).
+ *
+ * Returns the result of threadfn(), or -EINTR if wake_up_process()
+ * was never called. */
+int kthread_stop_sem(struct task_struct *k, struct semaphore *s);
+
 /**
  * kthread_should_stop: should this kthread return now?
  *
diff --git a/kernel/kthread.c b/kernel/kthread.c
index f50f174e92da..e75950a1092c 100644
--- a/kernel/kthread.c
+++ b/kernel/kthread.c
@@ -164,6 +164,12 @@ void kthread_bind(struct task_struct *k, unsigned int cpu)
 EXPORT_SYMBOL(kthread_bind);
 
 int kthread_stop(struct task_struct *k)
+{
+	return kthread_stop_sem(k, NULL);
+}
+EXPORT_SYMBOL(kthread_stop);
+
+int kthread_stop_sem(struct task_struct *k, struct semaphore *s)
 {
 	int ret;
 
@@ -178,7 +184,10 @@ int kthread_stop(struct task_struct *k)
 
 	/* Now set kthread_should_stop() to true, and wake it up. */
 	kthread_stop_info.k = k;
-	wake_up_process(k);
+	if (s)
+		up(s);
+	else
+		wake_up_process(k);
 	put_task_struct(k);
 
 	/* Once it dies, reset stop ptr, gather result and we're done. */
@@ -189,7 +198,7 @@ int kthread_stop(struct task_struct *k)
 
 	return ret;
 }
-EXPORT_SYMBOL(kthread_stop);
+EXPORT_SYMBOL(kthread_stop_sem);
 
 static __init int helper_init(void)
 {</pre><hr><pre>commit 4f62efe67f077db17dad03a1d4c9665000a3eb45
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Oct 24 16:24:14 2005 -0400

    [PATCH] usbcore: Fix handling of sysfs strings and other attributes
    
    This patch (as592) makes a few small improvements to the way device
    strings are handled, and it fixes some bugs in a couple of other sysfs
    attribute routines.  (Look at show_configuration_string() to see what I
    mean.)
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c
index 63f374e62db2..993019500cc3 100644
--- a/drivers/usb/core/config.c
+++ b/drivers/usb/core/config.c
@@ -112,8 +112,12 @@ void usb_release_interface_cache(struct kref *ref)
 	struct usb_interface_cache *intfc = ref_to_usb_interface_cache(ref);
 	int j;
 
-	for (j = 0; j &lt; intfc-&gt;num_altsetting; j++)
-		kfree(intfc-&gt;altsetting[j].endpoint);
+	for (j = 0; j &lt; intfc-&gt;num_altsetting; j++) {
+		struct usb_host_interface *alt = &amp;intfc-&gt;altsetting[j];
+
+		kfree(alt-&gt;endpoint);
+		kfree(alt-&gt;string);
+	}
 	kfree(intfc);
 }
 
@@ -420,8 +424,6 @@ void usb_destroy_configuration(struct usb_device *dev)
 		struct usb_host_config *cf = &amp;dev-&gt;config[c];
 
 		kfree(cf-&gt;string);
-		cf-&gt;string = NULL;
-
 		for (i = 0; i &lt; cf-&gt;desc.bNumInterfaces; i++) {
 			if (cf-&gt;intf_cache[i])
 				kref_put(&amp;cf-&gt;intf_cache[i]-&gt;ref, 
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 8ba5854e5387..1bacb374b007 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1204,21 +1204,6 @@ static inline void show_string(struct usb_device *udev, char *id, char *string)
 {}
 #endif
 
-static void get_string(struct usb_device *udev, char **string, int index)
-{
-	char *buf;
-
-	if (!index)
-		return;
-	buf = kmalloc(256, GFP_KERNEL);
-	if (!buf)
-		return;
-	if (usb_string(udev, index, buf, 256) &gt; 0)
-		*string = buf;
-	else
-		kfree(buf);
-}
-
 
 #ifdef	CONFIG_USB_OTG
 #include "otg_whitelist.h"
@@ -1257,9 +1242,10 @@ int usb_new_device(struct usb_device *udev)
 	}
 
 	/* read the standard strings and cache them if present */
-	get_string(udev, &amp;udev-&gt;product, udev-&gt;descriptor.iProduct);
-	get_string(udev, &amp;udev-&gt;manufacturer, udev-&gt;descriptor.iManufacturer);
-	get_string(udev, &amp;udev-&gt;serial, udev-&gt;descriptor.iSerialNumber);
+	udev-&gt;product = usb_cache_string(udev, udev-&gt;descriptor.iProduct);
+	udev-&gt;manufacturer = usb_cache_string(udev,
+			udev-&gt;descriptor.iManufacturer);
+	udev-&gt;serial = usb_cache_string(udev, udev-&gt;descriptor.iSerialNumber);
 
 	/* Tell the world! */
 	dev_dbg(&amp;udev-&gt;dev, "new device strings: Mfr=%d, Product=%d, "
diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 3519f317898e..644a3d4f12aa 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -787,6 +787,31 @@ int usb_string(struct usb_device *dev, int index, char *buf, size_t size)
 	return err;
 }
 
+/**
+ * usb_cache_string - read a string descriptor and cache it for later use
+ * @udev: the device whose string descriptor is being read
+ * @index: the descriptor index
+ *
+ * Returns a pointer to a kmalloc'ed buffer containing the descriptor string,
+ * or NULL if the index is 0 or the string could not be read.
+ */
+char *usb_cache_string(struct usb_device *udev, int index)
+{
+	char *buf;
+	char *smallbuf = NULL;
+	int len;
+
+	if (index &gt; 0 &amp;&amp; (buf = kmalloc(256, GFP_KERNEL)) != NULL) {
+		if ((len = usb_string(udev, index, buf, 256)) &gt; 0) {
+			if ((smallbuf = kmalloc(++len, GFP_KERNEL)) == NULL)
+				return buf;
+			memcpy(smallbuf, buf, len);
+		}
+		kfree(buf);
+	}
+	return smallbuf;
+}
+
 /*
  * usb_get_device_descriptor - (re)reads the device descriptor (usbcore)
  * @dev: the device whose device descriptor is being updated
@@ -1008,8 +1033,6 @@ void usb_disable_device(struct usb_device *dev, int skip_ep0)
 			dev_dbg (&amp;dev-&gt;dev, "unregistering interface %s\n",
 				interface-&gt;dev.bus_id);
 			usb_remove_sysfs_intf_files(interface);
-			kfree(interface-&gt;cur_altsetting-&gt;string);
-			interface-&gt;cur_altsetting-&gt;string = NULL;
 			device_del (&amp;interface-&gt;dev);
 		}
 
@@ -1422,12 +1445,9 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 		}
 		kfree(new_interfaces);
 
-		if ((cp-&gt;desc.iConfiguration) &amp;&amp;
-		    (cp-&gt;string == NULL)) {
-			cp-&gt;string = kmalloc(256, GFP_KERNEL);
-			if (cp-&gt;string)
-				usb_string(dev, cp-&gt;desc.iConfiguration, cp-&gt;string, 256);
-		}
+		if (cp-&gt;string == NULL)
+			cp-&gt;string = usb_cache_string(dev,
+					cp-&gt;desc.iConfiguration);
 
 		/* Now that all the interfaces are set up, register them
 		 * to trigger binding of drivers to interfaces.  probe()
@@ -1437,13 +1457,12 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 		 */
 		for (i = 0; i &lt; nintf; ++i) {
 			struct usb_interface *intf = cp-&gt;interface[i];
-			struct usb_interface_descriptor *desc;
+			struct usb_host_interface *alt = intf-&gt;cur_altsetting;
 
-			desc = &amp;intf-&gt;altsetting [0].desc;
 			dev_dbg (&amp;dev-&gt;dev,
 				"adding %s (config #%d, interface %d)\n",
 				intf-&gt;dev.bus_id, configuration,
-				desc-&gt;bInterfaceNumber);
+				alt-&gt;desc.bInterfaceNumber);
 			ret = device_add (&amp;intf-&gt;dev);
 			if (ret != 0) {
 				dev_err(&amp;dev-&gt;dev,
@@ -1452,13 +1471,6 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 					ret);
 				continue;
 			}
-			if ((intf-&gt;cur_altsetting-&gt;desc.iInterface) &amp;&amp;
-			    (intf-&gt;cur_altsetting-&gt;string == NULL)) {
-				intf-&gt;cur_altsetting-&gt;string = kmalloc(256, GFP_KERNEL);
-				if (intf-&gt;cur_altsetting-&gt;string)
-					usb_string(dev, intf-&gt;cur_altsetting-&gt;desc.iInterface,
-						   intf-&gt;cur_altsetting-&gt;string, 256);
-			}
 			usb_create_sysfs_intf_files (intf);
 		}
 	}
diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c
index 4cca77cf0c48..edd83e014452 100644
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -249,18 +249,12 @@ static ssize_t show_configuration_string(struct device *dev,
 {
 	struct usb_device *udev;
 	struct usb_host_config *actconfig;
-	int len;
 
 	udev = to_usb_device (dev);
 	actconfig = udev-&gt;actconfig;
 	if ((!actconfig) || (!actconfig-&gt;string))
 		return 0;
-	len = sprintf(buf, actconfig-&gt;string, PAGE_SIZE);
-	if (len &lt; 0)
-		return 0;
-	buf[len] = '\n';
-	buf[len+1] = 0;
-	return len+1;
+	return sprintf(buf, "%s\n", actconfig-&gt;string);
 }
 static DEVICE_ATTR(configuration, S_IRUGO, show_configuration_string, NULL);
 
@@ -291,15 +285,9 @@ static ssize_t  show_##name(struct device *dev,				\
 		struct device_attribute *attr, char *buf)		\
 {									\
 	struct usb_device *udev;					\
-	int len;							\
 									\
 	udev = to_usb_device (dev);					\
-	len = snprintf(buf, 256, "%s", udev-&gt;name);			\
-	if (len &lt; 0)							\
-		return 0;						\
-	buf[len] = '\n';						\
-	buf[len+1] = 0;							\
-	return len+1;							\
+	return sprintf(buf, "%s\n", udev-&gt;name);			\
 }									\
 static DEVICE_ATTR(name, S_IRUGO, show_##name, NULL);
 
@@ -449,11 +437,11 @@ void usb_remove_sysfs_dev_files (struct usb_device *udev)
 	usb_remove_ep_files(&amp;udev-&gt;ep0);
 	sysfs_remove_group(&amp;dev-&gt;kobj, &amp;dev_attr_grp);
 
-	if (udev-&gt;descriptor.iManufacturer)
+	if (udev-&gt;manufacturer)
 		device_remove_file(dev, &amp;dev_attr_manufacturer);
-	if (udev-&gt;descriptor.iProduct)
+	if (udev-&gt;product)
 		device_remove_file(dev, &amp;dev_attr_product);
-	if (udev-&gt;descriptor.iSerialNumber)
+	if (udev-&gt;serial)
 		device_remove_file(dev, &amp;dev_attr_serial);
 	device_remove_file (dev, &amp;dev_attr_configuration);
 }
@@ -535,7 +523,8 @@ static struct attribute_group intf_attr_grp = {
 	.attrs = intf_attrs,
 };
 
-static inline void usb_create_intf_ep_files(struct usb_interface *intf)
+static inline void usb_create_intf_ep_files(struct usb_interface *intf,
+		struct usb_device *udev)
 {
 	struct usb_host_interface *iface_desc;
 	int i;
@@ -543,7 +532,7 @@ static inline void usb_create_intf_ep_files(struct usb_interface *intf)
 	iface_desc = intf-&gt;cur_altsetting;
 	for (i = 0; i &lt; iface_desc-&gt;desc.bNumEndpoints; ++i)
 		usb_create_ep_files(&amp;intf-&gt;dev.kobj, &amp;iface_desc-&gt;endpoint[i],
-				interface_to_usbdev(intf));
+				udev);
 }
 
 static inline void usb_remove_intf_ep_files(struct usb_interface *intf)
@@ -558,11 +547,16 @@ static inline void usb_remove_intf_ep_files(struct usb_interface *intf)
 
 void usb_create_sysfs_intf_files (struct usb_interface *intf)
 {
+	struct usb_device *udev = interface_to_usbdev(intf);
+	struct usb_host_interface *alt = intf-&gt;cur_altsetting;
+
 	sysfs_create_group(&amp;intf-&gt;dev.kobj, &amp;intf_attr_grp);
 
-	if (intf-&gt;cur_altsetting-&gt;string)
+	if (alt-&gt;string == NULL)
+		alt-&gt;string = usb_cache_string(udev, alt-&gt;desc.iInterface);
+	if (alt-&gt;string)
 		device_create_file(&amp;intf-&gt;dev, &amp;dev_attr_interface);
-	usb_create_intf_ep_files(intf);
+	usb_create_intf_ep_files(intf, udev);
 }
 
 void usb_remove_sysfs_intf_files (struct usb_interface *intf)
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 888dbe443695..1c4a68499dce 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -13,6 +13,7 @@ extern void usb_disable_device (struct usb_device *dev, int skip_ep0);
 
 extern int usb_get_device_descriptor(struct usb_device *dev,
 		unsigned int size);
+extern char *usb_cache_string(struct usb_device *udev, int index);
 extern int usb_set_configuration(struct usb_device *dev, int configuration);
 
 extern void usb_lock_all_devices(void);
diff --git a/include/linux/usb.h b/include/linux/usb.h
index c500d6b5a16d..748d04385256 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -231,7 +231,7 @@ struct usb_interface_cache {
 struct usb_host_config {
 	struct usb_config_descriptor	desc;
 
-	char *string;
+	char *string;		/* iConfiguration string, if present */
 	/* the interfaces associated with this configuration,
 	 * stored in no particular order */
 	struct usb_interface *interface[USB_MAXINTERFACES];
@@ -351,9 +351,11 @@ struct usb_device {
 	int have_langid;		/* whether string_langid is valid */
 	int string_langid;		/* language ID for strings */
 
-	char *product;
-	char *manufacturer;
-	char *serial;			/* static strings from the device */
+	/* static strings from the device */
+	char *product;			/* iProduct string, if present */
+	char *manufacturer;		/* iManufacturer string, if present */
+	char *serial;			/* iSerialNumber string, if present */
+
 	struct list_head filelist;
 	struct class_device *class_dev;
 	struct dentry *usbfs_dentry;	/* usbfs dentry entry for the device */</pre><hr><pre>commit 16f16d117c1eb99451e4c73c87546eef05c66790
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Oct 24 15:41:19 2005 -0400

    [PATCH] USB: Fix maxpacket length for ep0 on root hubs
    
    This patch (as591) fixes a rather innocuous bug that has been around for
    quite a long time: Virtual root hubs should have a maxpacket length of
    64 for endpoint 0.  I didn't realize it was wrong until I started
    looking through the endpoint attribute files.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 61ef9943757e..6c7ca5b08cd6 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -130,7 +130,7 @@ static const u8 usb2_rh_dev_descriptor [18] = {
 	0x09,	    /*  __u8  bDeviceClass; HUB_CLASSCODE */
 	0x00,	    /*  __u8  bDeviceSubClass; */
 	0x01,       /*  __u8  bDeviceProtocol; [ usb 2.0 single TT ]*/
-	0x08,       /*  __u8  bMaxPacketSize0; 8 Bytes */
+	0x40,       /*  __u8  bMaxPacketSize0; 64 Bytes */
 
 	0x00, 0x00, /*  __le16 idVendor; */
  	0x00, 0x00, /*  __le16 idProduct; */
@@ -153,7 +153,7 @@ static const u8 usb11_rh_dev_descriptor [18] = {
 	0x09,	    /*  __u8  bDeviceClass; HUB_CLASSCODE */
 	0x00,	    /*  __u8  bDeviceSubClass; */
 	0x00,       /*  __u8  bDeviceProtocol; [ low/full speeds only ] */
-	0x08,       /*  __u8  bMaxPacketSize0; 8 Bytes */
+	0x40,       /*  __u8  bMaxPacketSize0; 64 Bytes */
 
 	0x00, 0x00, /*  __le16 idVendor; */
  	0x00, 0x00, /*  __le16 idProduct; */</pre>
    <div class="pagination">
        <a href='2_131.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><span>[132]</span><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_133.html'>Next&gt;&gt;</a>
    <div>
</body>
