<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_44.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><span>[45]</span><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_46.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 43fe3a99d9caf10b25f9c596e9854cdae30db418
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 11 11:23:16 2012 -0400

    USB: EHCI: resolve some unlikely races
    
    This patch (as1589) resolves some unlikely races involving system
    shutdown or controller death in ehci-hcd:
    
            Shutdown races with both root-hub resume and controller
            resume.
    
            Controller death races with root-hub suspend.
    
    A new bitflag is added to indicate that the controller has been shut
    down (whether for system shutdown or because it died).  Tests are
    added in the suspend and resume pathways to avoid reactivating the
    controller after any sort of shutdown.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index ac4c8ddde20a..e44ca5453aa2 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -343,6 +343,7 @@ static void ehci_shutdown(struct usb_hcd *hcd)
 	struct ehci_hcd	*ehci = hcd_to_ehci(hcd);
 
 	spin_lock_irq(&amp;ehci-&gt;lock);
+	ehci-&gt;shutdown = true;
 	ehci-&gt;rh_state = EHCI_RH_STOPPING;
 	ehci-&gt;enabled_hrtimer_events = 0;
 	spin_unlock_irq(&amp;ehci-&gt;lock);
@@ -823,6 +824,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 		usb_hc_died(hcd);
 
 		/* Don't let the controller do anything more */
+		ehci-&gt;shutdown = true;
 		ehci-&gt;rh_state = EHCI_RH_STOPPING;
 		ehci-&gt;command &amp;= ~(CMD_RUN | CMD_ASE | CMD_PSE);
 		ehci_writel(ehci, ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
@@ -1129,6 +1131,9 @@ static int __maybe_unused ehci_resume(struct usb_hcd *hcd, bool hibernated)
 	/* Mark hardware accessible again as we are back to full power by now */
 	set_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
 
+	if (ehci-&gt;shutdown)
+		return 0;		/* Controller is dead */
+
 	/*
 	 * If CF is still set and we aren't resuming from hibernation
 	 * then we maintained suspend power.
@@ -1139,10 +1144,17 @@ static int __maybe_unused ehci_resume(struct usb_hcd *hcd, bool hibernated)
 		int	mask = INTR_MASK;
 
 		ehci_prepare_ports_for_controller_resume(ehci);
+
+		spin_lock_irq(&amp;ehci-&gt;lock);
+		if (ehci-&gt;shutdown)
+			goto skip;
+
 		if (!hcd-&gt;self.root_hub-&gt;do_remote_wakeup)
 			mask &amp;= ~STS_PCD;
 		ehci_writel(ehci, mask, &amp;ehci-&gt;regs-&gt;intr_enable);
 		ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;intr_enable);
+ skip:
+		spin_unlock_irq(&amp;ehci-&gt;lock);
 		return 0;
 	}
 
@@ -1154,14 +1166,20 @@ static int __maybe_unused ehci_resume(struct usb_hcd *hcd, bool hibernated)
 	(void) ehci_halt(ehci);
 	(void) ehci_reset(ehci);
 
+	spin_lock_irq(&amp;ehci-&gt;lock);
+	if (ehci-&gt;shutdown)
+		goto skip;
+
 	ehci_writel(ehci, ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
 	ehci_writel(ehci, FLAG_CF, &amp;ehci-&gt;regs-&gt;configured_flag);
 	ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);	/* unblock posted writes */
 
+	ehci-&gt;rh_state = EHCI_RH_SUSPENDED;
+	spin_unlock_irq(&amp;ehci-&gt;lock);
+
 	/* here we "know" root ports should always stay powered */
 	ehci_port_power(ehci, 1);
 
-	ehci-&gt;rh_state = EHCI_RH_SUSPENDED;
 	return 1;
 }
 
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index ffc5f27df725..c7880223738a 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -221,6 +221,8 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 	ehci_quiesce(ehci);
 
 	spin_lock_irq (&amp;ehci-&gt;lock);
+	if (ehci-&gt;rh_state &lt; EHCI_RH_RUNNING)
+		goto done;
 
 	/* Once the controller is stopped, port resumes that are already
 	 * in progress won't complete.  Hence if remote wakeup is enabled
@@ -306,6 +308,10 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 	ehci_halt (ehci);
 
 	spin_lock_irq(&amp;ehci-&gt;lock);
+	if (ehci-&gt;enabled_hrtimer_events &amp; BIT(EHCI_HRTIMER_POLL_DEAD))
+		ehci_handle_controller_death(ehci);
+	if (ehci-&gt;rh_state != EHCI_RH_RUNNING)
+		goto done;
 	ehci-&gt;rh_state = EHCI_RH_SUSPENDED;
 
 	end_unlink_async(ehci);
@@ -320,6 +326,7 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 	ehci_writel(ehci, mask, &amp;ehci-&gt;regs-&gt;intr_enable);
 	ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;intr_enable);
 
+ done:
 	ehci-&gt;next_statechange = jiffies + msecs_to_jiffies(10);
 	ehci-&gt;enabled_hrtimer_events = 0;
 	ehci-&gt;next_hrtimer_event = EHCI_HRTIMER_NO_EVENT;
@@ -342,10 +349,8 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 	if (time_before (jiffies, ehci-&gt;next_statechange))
 		msleep(5);
 	spin_lock_irq (&amp;ehci-&gt;lock);
-	if (!HCD_HW_ACCESSIBLE(hcd)) {
-		spin_unlock_irq(&amp;ehci-&gt;lock);
-		return -ESHUTDOWN;
-	}
+	if (!HCD_HW_ACCESSIBLE(hcd) || ehci-&gt;shutdown)
+		goto shutdown;
 
 	if (unlikely(ehci-&gt;debug)) {
 		if (!dbgp_reset_prep())
@@ -384,6 +389,8 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 	spin_unlock_irq(&amp;ehci-&gt;lock);
 	msleep(8);
 	spin_lock_irq(&amp;ehci-&gt;lock);
+	if (ehci-&gt;shutdown)
+		goto shutdown;
 
 	/* clear phy low-power mode before resume */
 	if (ehci-&gt;bus_suspended &amp;&amp; ehci-&gt;has_hostpc) {
@@ -401,6 +408,8 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 		spin_unlock_irq(&amp;ehci-&gt;lock);
 		msleep(5);
 		spin_lock_irq(&amp;ehci-&gt;lock);
+		if (ehci-&gt;shutdown)
+			goto shutdown;
 	}
 
 	/* manually resume the ports we suspended during bus_suspend() */
@@ -421,6 +430,8 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 		spin_unlock_irq(&amp;ehci-&gt;lock);
 		msleep(20);
 		spin_lock_irq(&amp;ehci-&gt;lock);
+		if (ehci-&gt;shutdown)
+			goto shutdown;
 	}
 
 	i = HCS_N_PORTS (ehci-&gt;hcs_params);
@@ -439,10 +450,18 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 	ehci_handover_companion_ports(ehci);
 
 	/* Now we can safely re-enable irqs */
+	spin_lock_irq(&amp;ehci-&gt;lock);
+	if (ehci-&gt;shutdown)
+		goto shutdown;
 	ehci_writel(ehci, INTR_MASK, &amp;ehci-&gt;regs-&gt;intr_enable);
 	(void) ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;intr_enable);
+	spin_unlock_irq(&amp;ehci-&gt;lock);
 
 	return 0;
+
+ shutdown:
+	spin_unlock_irq(&amp;ehci-&gt;lock);
+	return -ESHUTDOWN;
 }
 
 #else
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 7de58fe52d51..da07d98f7d1d 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -118,6 +118,7 @@ struct ehci_hcd {			/* one per controller */
 	bool			need_rescan:1;
 	bool			intr_unlinking:1;
 	bool			async_unlinking:1;
+	bool			shutdown:1;
 	struct ehci_qh		*qh_scan_next;
 
 	/* async schedule support */</pre><hr><pre>commit c4f3476436f7452b97c8accb5dd7d53219a11a3f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 11 11:23:10 2012 -0400

    USB: EHCI: fix up locking
    
    This patch (as1588) adjusts the locking in ehci-hcd's various halt,
    shutdown, and suspend/resume pathways.  We want to hold the spinlock
    while writing device registers and accessing shared variables, but not
    while polling in a loop.
    
    In addition, there's no need to call ehci_work() at times when no URBs
    can be active, i.e., in ehci_stop() and ehci_bus_suspend().
    
    Finally, ehci_adjust_port_wakeup_flags() is called only in situations
    where interrupts are enabled; therefore it can use spin_lock_irq
    rather than spin_lock_irqsave.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 340c9c4894bf..ac4c8ddde20a 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -167,21 +167,24 @@ static int tdi_in_host_mode (struct ehci_hcd *ehci)
 	return (tmp &amp; 3) == USBMODE_CM_HC;
 }
 
-/* force HC to halt state from unknown (EHCI spec section 2.3) */
+/*
+ * Force HC to halt state from unknown (EHCI spec section 2.3).
+ * Must be called with interrupts enabled and the lock not held.
+ */
 static int ehci_halt (struct ehci_hcd *ehci)
 {
-	u32	temp = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;status);
+	u32	temp;
+
+	spin_lock_irq(&amp;ehci-&gt;lock);
 
 	/* disable any irqs left enabled by previous code */
 	ehci_writel(ehci, 0, &amp;ehci-&gt;regs-&gt;intr_enable);
 
-	if (ehci_is_TDI(ehci) &amp;&amp; tdi_in_host_mode(ehci) == 0) {
+	if (ehci_is_TDI(ehci) &amp;&amp; !tdi_in_host_mode(ehci)) {
+		spin_unlock_irq(&amp;ehci-&gt;lock);
 		return 0;
 	}
 
-	if ((temp &amp; STS_HALT) != 0)
-		return 0;
-
 	/*
 	 * This routine gets called during probe before ehci-&gt;command
 	 * has been initialized, so we can't rely on its value.
@@ -190,7 +193,11 @@ static int ehci_halt (struct ehci_hcd *ehci)
 	temp = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
 	temp &amp;= ~(CMD_RUN | CMD_IAAD);
 	ehci_writel(ehci, temp, &amp;ehci-&gt;regs-&gt;command);
-	return handshake (ehci, &amp;ehci-&gt;regs-&gt;status,
+
+	spin_unlock_irq(&amp;ehci-&gt;lock);
+	synchronize_irq(ehci_to_hcd(ehci)-&gt;irq);
+
+	return handshake(ehci, &amp;ehci-&gt;regs-&gt;status,
 			  STS_HALT, STS_HALT, 16 * 125);
 }
 
@@ -210,7 +217,10 @@ static void tdi_reset (struct ehci_hcd *ehci)
 	ehci_writel(ehci, tmp, &amp;ehci-&gt;regs-&gt;usbmode);
 }
 
-/* reset a non-running (STS_HALT == 1) controller */
+/*
+ * Reset a non-running (STS_HALT == 1) controller.
+ * Must be called with interrupts enabled and the lock not held.
+ */
 static int ehci_reset (struct ehci_hcd *ehci)
 {
 	int	retval;
@@ -248,7 +258,10 @@ static int ehci_reset (struct ehci_hcd *ehci)
 	return retval;
 }
 
-/* idle the controller (from running) */
+/*
+ * Idle the controller (turn off the schedules).
+ * Must be called with interrupts enabled and the lock not held.
+ */
 static void ehci_quiesce (struct ehci_hcd *ehci)
 {
 	u32	temp;
@@ -261,8 +274,10 @@ static void ehci_quiesce (struct ehci_hcd *ehci)
 	handshake(ehci, &amp;ehci-&gt;regs-&gt;status, STS_ASS | STS_PSS, temp, 16 * 125);
 
 	/* then disable anything that's still active */
+	spin_lock_irq(&amp;ehci-&gt;lock);
 	ehci-&gt;command &amp;= ~(CMD_ASE | CMD_PSE);
 	ehci_writel(ehci, ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
+	spin_unlock_irq(&amp;ehci-&gt;lock);
 
 	/* hardware can take 16 microframes to turn off ... */
 	handshake(ehci, &amp;ehci-&gt;regs-&gt;status, STS_ASS | STS_PSS, 0, 16 * 125);
@@ -301,11 +316,14 @@ static void ehci_turn_off_all_ports(struct ehci_hcd *ehci)
 
 /*
  * Halt HC, turn off all ports, and let the BIOS use the companion controllers.
- * Should be called with ehci-&gt;lock held.
+ * Must be called with interrupts enabled and the lock not held.
  */
 static void ehci_silence_controller(struct ehci_hcd *ehci)
 {
 	ehci_halt(ehci);
+
+	spin_lock_irq(&amp;ehci-&gt;lock);
+	ehci-&gt;rh_state = EHCI_RH_HALTED;
 	ehci_turn_off_all_ports(ehci);
 
 	/* make BIOS/etc use companion controller during reboot */
@@ -313,6 +331,7 @@ static void ehci_silence_controller(struct ehci_hcd *ehci)
 
 	/* unblock posted writes */
 	ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;configured_flag);
+	spin_unlock_irq(&amp;ehci-&gt;lock);
 }
 
 /* ehci_shutdown kick in for silicon on any bus (not just pci, etc).
@@ -325,10 +344,11 @@ static void ehci_shutdown(struct usb_hcd *hcd)
 
 	spin_lock_irq(&amp;ehci-&gt;lock);
 	ehci-&gt;rh_state = EHCI_RH_STOPPING;
-	ehci_silence_controller(ehci);
 	ehci-&gt;enabled_hrtimer_events = 0;
 	spin_unlock_irq(&amp;ehci-&gt;lock);
 
+	ehci_silence_controller(ehci);
+
 	hrtimer_cancel(&amp;ehci-&gt;hrtimer);
 }
 
@@ -400,11 +420,11 @@ static void ehci_stop (struct usb_hcd *hcd)
 
 	spin_lock_irq(&amp;ehci-&gt;lock);
 	ehci-&gt;enabled_hrtimer_events = 0;
-	ehci_quiesce(ehci);
+	spin_unlock_irq(&amp;ehci-&gt;lock);
 
+	ehci_quiesce(ehci);
 	ehci_silence_controller(ehci);
 	ehci_reset (ehci);
-	spin_unlock_irq(&amp;ehci-&gt;lock);
 
 	hrtimer_cancel(&amp;ehci-&gt;hrtimer);
 	remove_sysfs_files(ehci);
@@ -412,8 +432,6 @@ static void ehci_stop (struct usb_hcd *hcd)
 
 	/* root hub is shut down separately (first, when possible) */
 	spin_lock_irq (&amp;ehci-&gt;lock);
-	if (ehci-&gt;async)
-		ehci_work (ehci);
 	end_free_itds(ehci);
 	spin_unlock_irq (&amp;ehci-&gt;lock);
 	ehci_mem_cleanup (ehci);
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 05490d387fd2..ffc5f27df725 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -59,6 +59,7 @@ static void ehci_handover_companion_ports(struct ehci_hcd *ehci)
 	/* Give the connections some time to appear */
 	msleep(20);
 
+	spin_lock_irq(&amp;ehci-&gt;lock);
 	port = HCS_N_PORTS(ehci-&gt;hcs_params);
 	while (port--) {
 		if (test_bit(port, &amp;ehci-&gt;owned_ports)) {
@@ -70,23 +71,30 @@ static void ehci_handover_companion_ports(struct ehci_hcd *ehci)
 				clear_bit(port, &amp;ehci-&gt;owned_ports);
 			else if (test_bit(port, &amp;ehci-&gt;companion_ports))
 				ehci_writel(ehci, status &amp; ~PORT_PE, reg);
-			else
+			else {
+				spin_unlock_irq(&amp;ehci-&gt;lock);
 				ehci_hub_control(hcd, SetPortFeature,
 						USB_PORT_FEAT_RESET, port + 1,
 						NULL, 0);
+				spin_lock_irq(&amp;ehci-&gt;lock);
+			}
 		}
 	}
+	spin_unlock_irq(&amp;ehci-&gt;lock);
 
 	if (!ehci-&gt;owned_ports)
 		return;
 	msleep(90);		/* Wait for resets to complete */
 
+	spin_lock_irq(&amp;ehci-&gt;lock);
 	port = HCS_N_PORTS(ehci-&gt;hcs_params);
 	while (port--) {
 		if (test_bit(port, &amp;ehci-&gt;owned_ports)) {
+			spin_unlock_irq(&amp;ehci-&gt;lock);
 			ehci_hub_control(hcd, GetPortStatus,
 					0, port + 1,
 					(char *) &amp;buf, sizeof(buf));
+			spin_lock_irq(&amp;ehci-&gt;lock);
 
 			/* The companion should now own the port,
 			 * but if something went wrong the port must not
@@ -105,6 +113,7 @@ static void ehci_handover_companion_ports(struct ehci_hcd *ehci)
 	}
 
 	ehci-&gt;owned_ports = 0;
+	spin_unlock_irq(&amp;ehci-&gt;lock);
 }
 
 static int ehci_port_change(struct ehci_hcd *ehci)
@@ -133,7 +142,6 @@ static void ehci_adjust_port_wakeup_flags(struct ehci_hcd *ehci,
 {
 	int		port;
 	u32		temp;
-	unsigned long	flags;
 
 	/* If remote wakeup is enabled for the root hub but disabled
 	 * for the controller, we must adjust all the port wakeup flags
@@ -143,7 +151,7 @@ static void ehci_adjust_port_wakeup_flags(struct ehci_hcd *ehci,
 	if (!ehci_to_hcd(ehci)-&gt;self.root_hub-&gt;do_remote_wakeup || do_wakeup)
 		return;
 
-	spin_lock_irqsave(&amp;ehci-&gt;lock, flags);
+	spin_lock_irq(&amp;ehci-&gt;lock);
 
 	/* clear phy low-power mode before changing wakeup flags */
 	if (ehci-&gt;has_hostpc) {
@@ -154,9 +162,9 @@ static void ehci_adjust_port_wakeup_flags(struct ehci_hcd *ehci,
 			temp = ehci_readl(ehci, hostpc_reg);
 			ehci_writel(ehci, temp &amp; ~HOSTPC_PHCD, hostpc_reg);
 		}
-		spin_unlock_irqrestore(&amp;ehci-&gt;lock, flags);
+		spin_unlock_irq(&amp;ehci-&gt;lock);
 		msleep(5);
-		spin_lock_irqsave(&amp;ehci-&gt;lock, flags);
+		spin_lock_irq(&amp;ehci-&gt;lock);
 	}
 
 	port = HCS_N_PORTS(ehci-&gt;hcs_params);
@@ -194,7 +202,7 @@ static void ehci_adjust_port_wakeup_flags(struct ehci_hcd *ehci,
 	if (!suspending &amp;&amp; ehci_port_change(ehci))
 		usb_hcd_resume_root_hub(ehci_to_hcd(ehci));
 
-	spin_unlock_irqrestore(&amp;ehci-&gt;lock, flags);
+	spin_unlock_irq(&amp;ehci-&gt;lock);
 }
 
 static int ehci_bus_suspend (struct usb_hcd *hcd)
@@ -209,6 +217,9 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 	if (time_before (jiffies, ehci-&gt;next_statechange))
 		msleep(5);
 
+	/* stop the schedules */
+	ehci_quiesce(ehci);
+
 	spin_lock_irq (&amp;ehci-&gt;lock);
 
 	/* Once the controller is stopped, port resumes that are already
@@ -224,10 +235,6 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 		}
 	}
 
-	/* stop schedules, clean any completed work */
-	ehci_quiesce(ehci);
-	ehci_work(ehci);
-
 	/* Unlike other USB host controller types, EHCI doesn't have
 	 * any notion of "global" or bus-wide suspend.  The driver has
 	 * to manually suspend all the active unsuspended ports, and
@@ -289,6 +296,7 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 					"succeeded" : "failed");
 		}
 	}
+	spin_unlock_irq(&amp;ehci-&gt;lock);
 
 	/* Apparently some devices need a &gt;= 1-uframe delay here */
 	if (ehci-&gt;bus_suspended)
@@ -296,6 +304,8 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 
 	/* turn off now-idle HC */
 	ehci_halt (ehci);
+
+	spin_lock_irq(&amp;ehci-&gt;lock);
 	ehci-&gt;rh_state = EHCI_RH_SUSPENDED;
 
 	end_unlink_async(ehci);
@@ -424,13 +434,14 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 	}
 
 	ehci-&gt;next_statechange = jiffies + msecs_to_jiffies(5);
+	spin_unlock_irq(&amp;ehci-&gt;lock);
+
+	ehci_handover_companion_ports(ehci);
 
 	/* Now we can safely re-enable irqs */
 	ehci_writel(ehci, INTR_MASK, &amp;ehci-&gt;regs-&gt;intr_enable);
 	(void) ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;intr_enable);
 
-	spin_unlock_irq (&amp;ehci-&gt;lock);
-	ehci_handover_companion_ports(ehci);
 	return 0;
 }
 
@@ -1018,7 +1029,9 @@ static int ehci_hub_control (
 		case USB_PORT_FEAT_TEST:
 			if (!selector || selector &gt; 5)
 				goto error;
+			spin_unlock_irqrestore(&amp;ehci-&gt;lock, flags);
 			ehci_quiesce(ehci);
+			spin_lock_irqsave(&amp;ehci-&gt;lock, flags);
 
 			/* Put all enabled ports into suspend */
 			while (ports--) {
@@ -1030,7 +1043,11 @@ static int ehci_hub_control (
 					ehci_writel(ehci, temp | PORT_SUSPEND,
 							sreg);
 			}
+
+			spin_unlock_irqrestore(&amp;ehci-&gt;lock, flags);
 			ehci_halt(ehci);
+			spin_lock_irqsave(&amp;ehci-&gt;lock, flags);
+
 			temp = ehci_readl(ehci, status_reg);
 			temp |= selector &lt;&lt; 16;
 			ehci_writel(ehci, temp, status_reg);
diff --git a/drivers/usb/host/ehci-tegra.c b/drivers/usb/host/ehci-tegra.c
index f7f3ce3275b8..65360945df78 100644
--- a/drivers/usb/host/ehci-tegra.c
+++ b/drivers/usb/host/ehci-tegra.c
@@ -445,12 +445,11 @@ static int controller_suspend(struct device *dev)
 	if (time_before(jiffies, ehci-&gt;next_statechange))
 		msleep(10);
 
-	spin_lock_irqsave(&amp;ehci-&gt;lock, flags);
+	ehci_halt(ehci);
 
+	spin_lock_irqsave(&amp;ehci-&gt;lock, flags);
 	tegra-&gt;port_speed = (readl(&amp;hw-&gt;port_status[0]) &gt;&gt; 26) &amp; 0x3;
-	ehci_halt(ehci);
 	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
-
 	spin_unlock_irqrestore(&amp;ehci-&gt;lock, flags);
 
 	tegra_ehci_power_down(hcd);</pre><hr><pre>commit f42890782241a60d107f23d08089a4a12b507a11
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 11 11:23:07 2012 -0400

    USB: EHCI: simplify isochronous scanning
    
    This patch (as1587) simplifies ehci-hcd's scan_isoc() routine by
    eliminating some local variables, declaring boolean-valued values as
    bool rather than unsigned, changing variable names to make more sense,
    and so on.
    
    The logic at the end of the routine is cut down significantly.  The
    scanning doesn't have to catch up all the way to where the hardware
    is; it merely has to catch up to where the hardware was when the last
    interrupt occurred.  If the hardware has made more progress since then
    and issued another interrupt, a rescan will catch up to it.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 9f26080889f5..340c9c4894bf 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -488,9 +488,6 @@ static int ehci_init(struct usb_hcd *hcd)
 	else					// N microframes cached
 		ehci-&gt;i_thresh = 2 + HCC_ISOC_THRES(hcc_params);
 
-	ehci-&gt;next_uframe = -1;
-	ehci-&gt;clock_frame = -1;
-
 	/*
 	 * dedicate a qh for the async ring head, since we couldn't unlink
 	 * a 'real' qh without stopping the async schedule [4.8].  use it
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 26ce8fef0e5b..7cf3da7babf0 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -497,8 +497,6 @@ static void disable_periodic(struct ehci_hcd *ehci)
 	if (--ehci-&gt;periodic_count)
 		return;
 
-	ehci-&gt;next_uframe = -1;		/* the periodic schedule is empty */
-
 	/* Don't turn off the schedule until PSS is 1 */
 	ehci_poll_PSS(ehci);
 }
@@ -1220,7 +1218,7 @@ itd_urb_transaction (
 		if (likely(!list_empty(&amp;stream-&gt;free_list))) {
 			itd = list_first_entry(&amp;stream-&gt;free_list,
 					struct ehci_itd, itd_list);
-			if (itd-&gt;frame == ehci-&gt;clock_frame)
+			if (itd-&gt;frame == ehci-&gt;now_frame)
 				goto alloc_itd;
 			list_del (&amp;itd-&gt;itd_list);
 			itd_dma = itd-&gt;itd_dma;
@@ -1492,7 +1490,7 @@ iso_stream_schedule (
 
 	/* Make sure scan_isoc() sees these */
 	if (ehci-&gt;isoc_count == 0)
-		ehci-&gt;next_uframe = now;
+		ehci-&gt;next_frame = now &gt;&gt; 3;
 	return 0;
 
  fail:
@@ -1666,11 +1664,8 @@ static void itd_link_urb(
  * (b) only this endpoint's completions submit URBs.  It seems some silicon
  * corrupts things if you reuse completed descriptors very quickly...
  */
-static unsigned
-itd_complete (
-	struct ehci_hcd	*ehci,
-	struct ehci_itd	*itd
-) {
+static bool itd_complete(struct ehci_hcd *ehci, struct ehci_itd *itd)
+{
 	struct urb				*urb = itd-&gt;urb;
 	struct usb_iso_packet_descriptor	*desc;
 	u32					t;
@@ -1678,7 +1673,7 @@ itd_complete (
 	int					urb_index = -1;
 	struct ehci_iso_stream			*stream = itd-&gt;stream;
 	struct usb_device			*dev;
-	unsigned				retval = false;
+	bool					retval = false;
 
 	/* for each uframe with a packet */
 	for (uframe = 0; uframe &lt; 8; uframe++) {
@@ -1917,7 +1912,7 @@ sitd_urb_transaction (
 		if (likely(!list_empty(&amp;stream-&gt;free_list))) {
 			sitd = list_first_entry(&amp;stream-&gt;free_list,
 					 struct ehci_sitd, sitd_list);
-			if (sitd-&gt;frame == ehci-&gt;clock_frame)
+			if (sitd-&gt;frame == ehci-&gt;now_frame)
 				goto alloc_sitd;
 			list_del (&amp;sitd-&gt;sitd_list);
 			sitd_dma = sitd-&gt;sitd_dma;
@@ -2071,18 +2066,15 @@ static void sitd_link_urb(
  * (b) only this endpoint's completions submit URBs.  It seems some silicon
  * corrupts things if you reuse completed descriptors very quickly...
  */
-static unsigned
-sitd_complete (
-	struct ehci_hcd		*ehci,
-	struct ehci_sitd	*sitd
-) {
+static bool sitd_complete(struct ehci_hcd *ehci, struct ehci_sitd *sitd)
+{
 	struct urb				*urb = sitd-&gt;urb;
 	struct usb_iso_packet_descriptor	*desc;
 	u32					t;
 	int					urb_index = -1;
 	struct ehci_iso_stream			*stream = sitd-&gt;stream;
 	struct usb_device			*dev;
-	unsigned				retval = false;
+	bool					retval = false;
 
 	urb_index = sitd-&gt;index;
 	desc = &amp;urb-&gt;iso_frame_desc [urb_index];
@@ -2214,34 +2206,29 @@ static int sitd_submit (struct ehci_hcd *ehci, struct urb *urb,
 
 static void scan_isoc(struct ehci_hcd *ehci)
 {
-	unsigned	now_uframe, frame, clock, clock_frame, mod;
-	unsigned	modified;
-
-	mod = ehci-&gt;periodic_size &lt;&lt; 3;
+	unsigned	uf, now_frame, frame;
+	unsigned	fmask = ehci-&gt;periodic_size - 1;
+	bool		modified, live;
 
 	/*
 	 * When running, scan from last scan point up to "now"
 	 * else clean up by scanning everything that's left.
 	 * Touches as few pages as possible:  cache-friendly.
 	 */
-	now_uframe = ehci-&gt;next_uframe;
 	if (ehci-&gt;rh_state &gt;= EHCI_RH_RUNNING) {
-		clock = ehci_read_frame_index(ehci);
-		clock_frame = (clock &gt;&gt; 3) &amp; (ehci-&gt;periodic_size - 1);
+		uf = ehci_read_frame_index(ehci);
+		now_frame = (uf &gt;&gt; 3) &amp; fmask;
+		live = true;
 	} else  {
-		clock = now_uframe + mod - 1;
-		clock_frame = -1;
+		now_frame = (ehci-&gt;next_frame - 1) &amp; fmask;
+		live = false;
 	}
-	ehci-&gt;clock_frame = clock_frame;
-	clock &amp;= mod - 1;
-	clock_frame = clock &gt;&gt; 3;
+	ehci-&gt;now_frame = now_frame;
 
+	frame = ehci-&gt;next_frame;
 	for (;;) {
 		union ehci_shadow	q, *q_p;
 		__hc32			type, *hw_p;
-		unsigned		incomplete = false;
-
-		frame = now_uframe &gt;&gt; 3;
 
 restart:
 		/* scan each element in frame's queue for completions */
@@ -2249,13 +2236,9 @@ static void scan_isoc(struct ehci_hcd *ehci)
 		hw_p = &amp;ehci-&gt;periodic [frame];
 		q.ptr = q_p-&gt;ptr;
 		type = Q_NEXT_TYPE(ehci, *hw_p);
-		modified = 0;
+		modified = false;
 
 		while (q.ptr != NULL) {
-			unsigned		uf;
-			int			live;
-
-			live = (ehci-&gt;rh_state &gt;= EHCI_RH_RUNNING);
 			switch (hc32_to_cpu(ehci, type)) {
 			case Q_TYPE_ITD:
 				/* If this ITD is still active, leave it for
@@ -2263,7 +2246,7 @@ static void scan_isoc(struct ehci_hcd *ehci)
 				 * No need to check for activity unless the
 				 * frame is current.
 				 */
-				if (frame == clock_frame &amp;&amp; live) {
+				if (frame == now_frame &amp;&amp; live) {
 					rmb();
 					for (uf = 0; uf &lt; 8; uf++) {
 						if (q.itd-&gt;hw_transaction[uf] &amp;
@@ -2271,7 +2254,6 @@ static void scan_isoc(struct ehci_hcd *ehci)
 							break;
 					}
 					if (uf &lt; 8) {
-						incomplete = true;
 						q_p = &amp;q.itd-&gt;itd_next;
 						hw_p = &amp;q.itd-&gt;hw_next;
 						type = Q_NEXT_TYPE(ehci,
@@ -2303,14 +2285,12 @@ static void scan_isoc(struct ehci_hcd *ehci)
 				 * No need to check for activity unless the
 				 * frame is current.
 				 */
-				if (((frame == clock_frame) ||
-				     (((frame + 1) &amp; (ehci-&gt;periodic_size - 1))
-				      == clock_frame))
+				if (((frame == now_frame) ||
+				     (((frame + 1) &amp; fmask) == now_frame))
 				    &amp;&amp; live
 				    &amp;&amp; (q.sitd-&gt;hw_results &amp;
 					SITD_ACTIVE(ehci))) {
 
-					incomplete = true;
 					q_p = &amp;q.sitd-&gt;sitd_next;
 					hw_p = &amp;q.sitd-&gt;hw_next;
 					type = Q_NEXT_TYPE(ehci,
@@ -2347,50 +2327,14 @@ static void scan_isoc(struct ehci_hcd *ehci)
 			}
 
 			/* assume completion callbacks modify the queue */
-			if (unlikely (modified)) {
-				if (likely(ehci-&gt;isoc_count &gt; 0))
-					goto restart;
-				/* short-circuit this scan */
-				now_uframe = clock;
-				break;
-			}
+			if (unlikely(modified &amp;&amp; ehci-&gt;isoc_count &gt; 0))
+				goto restart;
 		}
 
-		/* If we can tell we caught up to the hardware, stop now.
-		 * We can't advance our scan without collecting the ISO
-		 * transfers that are still pending in this frame.
-		 */
-		if (incomplete &amp;&amp; ehci-&gt;rh_state &gt;= EHCI_RH_RUNNING) {
-			ehci-&gt;next_uframe = now_uframe;
+		/* Stop when we have reached the current frame */
+		if (frame == now_frame)
 			break;
-		}
-
-		// FIXME:  this assumes we won't get lapped when
-		// latencies climb; that should be rare, but...
-		// detect it, and just go all the way around.
-		// FLR might help detect this case, so long as latencies
-		// don't exceed periodic_size msec (default 1.024 sec).
-
-		// FIXME:  likewise assumes HC doesn't halt mid-scan
-
-		if (now_uframe == clock) {
-			unsigned	now;
-
-			if (ehci-&gt;rh_state &lt; EHCI_RH_RUNNING
-					|| ehci-&gt;isoc_count == 0)
-				break;
-			ehci-&gt;next_uframe = now_uframe;
-			now = ehci_read_frame_index(ehci) &amp; (mod - 1);
-			if (now_uframe == now)
-				break;
-
-			/* rescan the rest of this frame, then ... */
-			clock = now;
-			clock_frame = clock &gt;&gt; 3;
-			ehci-&gt;clock_frame = clock_frame;
-		} else {
-			now_uframe++;
-			now_uframe &amp;= mod - 1;
-		}
+		frame = (frame + 1) &amp; fmask;
 	}
+	ehci-&gt;next_frame = now_frame;
 }
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 254f414bd0bd..7de58fe52d51 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -141,19 +141,19 @@ struct ehci_hcd {			/* one per controller */
 	struct ehci_qh		*intr_unlink;
 	struct ehci_qh		*intr_unlink_last;
 	unsigned		intr_unlink_cycle;
-	int			next_uframe;	/* scan periodic, start here */
+	unsigned		now_frame;	/* frame from HC hardware */
+	unsigned		next_frame;	/* scan periodic, start here */
 	unsigned		intr_count;	/* intr activity count */
 	unsigned		isoc_count;	/* isoc activity count */
 	unsigned		periodic_count;	/* periodic activity count */
 	unsigned		uframe_periodic_max; /* max periodic time per uframe */
 
 
-	/* list of itds &amp; sitds completed while clock_frame was still active */
+	/* list of itds &amp; sitds completed while now_frame was still active */
 	struct list_head	cached_itd_list;
 	struct ehci_itd		*last_itd_to_free;
 	struct list_head	cached_sitd_list;
 	struct ehci_sitd	*last_sitd_to_free;
-	unsigned		clock_frame;
 
 	/* per root hub port */
 	unsigned long		reset_done [EHCI_MAX_ROOT_PORTS];</pre><hr><pre>commit 18aafe64d75d0e27dae206cacf4171e4e485d285
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 11 11:23:04 2012 -0400

    USB: EHCI: use hrtimer for the I/O watchdog
    
    This patch (as1586) replaces the kernel timer used by ehci-hcd as an
    I/O watchdog with an hrtimer event.
    
    Unlike in the current code, the watchdog event is now always enabled
    whenever any isochronous URBs are active.  This will prevent bugs
    caused by the periodic schedule wrapping around with no completion
    interrupts; the watchdog handler is guaranteed to scan the isochronous
    transfers at least once during each iteration of the schedule.  The
    extra overhead will be negligible: one timer interrupt every 100 ms.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index c13dad8a8503..9f26080889f5 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -93,8 +93,6 @@ static const char	hcd_name [] = "ehci_hcd";
  */
 #define	EHCI_TUNE_FLS		1	/* (medium) 512-frame schedule */
 
-#define EHCI_IO_JIFFIES		(HZ/10)		/* io watchdog &gt; irq_thresh */
-
 /* Initial IRQ latency:  faster than hw default */
 static int log2_irq_thresh = 0;		// 0 to 6
 module_param (log2_irq_thresh, int, S_IRUGO);
@@ -125,25 +123,6 @@ MODULE_PARM_DESC(hird, "host initiated resume duration, +1 for each 75us");
 
 /*-------------------------------------------------------------------------*/
 
-static void
-timer_action(struct ehci_hcd *ehci, enum ehci_timer_action action)
-{
-	if (!test_and_set_bit(action, &amp;ehci-&gt;actions)) {
-		unsigned long t;
-
-		switch (action) {
-		case TIMER_IO_WATCHDOG:
-			if (!ehci-&gt;need_io_watchdog)
-				return;
-			t = EHCI_IO_JIFFIES;
-			break;
-		}
-		mod_timer(&amp;ehci-&gt;watchdog, t + jiffies);
-	}
-}
-
-/*-------------------------------------------------------------------------*/
-
 /*
  * handshake - spin reading hc until handshake completes or fails
  * @ptr: address of hc register to be read
@@ -307,19 +286,6 @@ static void end_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh);
 
 /*-------------------------------------------------------------------------*/
 
-static void ehci_watchdog(unsigned long param)
-{
-	struct ehci_hcd		*ehci = (struct ehci_hcd *) param;
-	unsigned long		flags;
-
-	spin_lock_irqsave(&amp;ehci-&gt;lock, flags);
-
-	/* ehci could run by timer, without IRQs ... */
-	ehci_work (ehci);
-
-	spin_unlock_irqrestore (&amp;ehci-&gt;lock, flags);
-}
-
 /* On some systems, leaving remote wakeup enabled prevents system shutdown.
  * The firmware seems to think that powering off is a wakeup event!
  * This routine turns off remote wakeup and everything else, on all ports.
@@ -357,8 +323,6 @@ static void ehci_shutdown(struct usb_hcd *hcd)
 {
 	struct ehci_hcd	*ehci = hcd_to_ehci(hcd);
 
-	del_timer_sync(&amp;ehci-&gt;watchdog);
-
 	spin_lock_irq(&amp;ehci-&gt;lock);
 	ehci-&gt;rh_state = EHCI_RH_STOPPING;
 	ehci_silence_controller(ehci);
@@ -394,8 +358,6 @@ static void ehci_port_power (struct ehci_hcd *ehci, int is_on)
  */
 static void ehci_work (struct ehci_hcd *ehci)
 {
-	timer_action_done (ehci, TIMER_IO_WATCHDOG);
-
 	/* another CPU may drop ehci-&gt;lock during a schedule scan while
 	 * it reports urb completions.  this flag guards against bogus
 	 * attempts at re-entrant schedule scanning.
@@ -422,10 +384,7 @@ static void ehci_work (struct ehci_hcd *ehci)
 	 * misplace IRQs, and should let us run completely without IRQs.
 	 * such lossage has been observed on both VT6202 and VT8235.
 	 */
-	if (ehci-&gt;rh_state == EHCI_RH_RUNNING &amp;&amp;
-			(ehci-&gt;async-&gt;qh_next.ptr != NULL ||
-			 ehci-&gt;periodic_count != 0))
-		timer_action (ehci, TIMER_IO_WATCHDOG);
+	turn_on_io_watchdog(ehci);
 }
 
 /*
@@ -438,7 +397,6 @@ static void ehci_stop (struct usb_hcd *hcd)
 	ehci_dbg (ehci, "stop\n");
 
 	/* no more interrupts ... */
-	del_timer_sync (&amp;ehci-&gt;watchdog);
 
 	spin_lock_irq(&amp;ehci-&gt;lock);
 	ehci-&gt;enabled_hrtimer_events = 0;
@@ -490,9 +448,6 @@ static int ehci_init(struct usb_hcd *hcd)
 	 * keep io watchdog by default, those good HCDs could turn off it later
 	 */
 	ehci-&gt;need_io_watchdog = 1;
-	init_timer(&amp;ehci-&gt;watchdog);
-	ehci-&gt;watchdog.function = ehci_watchdog;
-	ehci-&gt;watchdog.data = (unsigned long) ehci;
 
 	hrtimer_init(&amp;ehci-&gt;hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);
 	ehci-&gt;hrtimer.function = ehci_hrtimer_func;
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 5d84562e2716..05490d387fd2 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -208,7 +208,6 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 
 	if (time_before (jiffies, ehci-&gt;next_statechange))
 		msleep(5);
-	del_timer_sync(&amp;ehci-&gt;watchdog);
 
 	spin_lock_irq (&amp;ehci-&gt;lock);
 
@@ -316,10 +315,6 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 	ehci-&gt;next_hrtimer_event = EHCI_HRTIMER_NO_EVENT;
 	spin_unlock_irq (&amp;ehci-&gt;lock);
 
-	/* ehci_work() may have re-enabled the watchdog timer, which we do not
-	 * want, and so we must delete any pending watchdog timer events.
-	 */
-	del_timer_sync(&amp;ehci-&gt;watchdog);
 	hrtimer_cancel(&amp;ehci-&gt;hrtimer);
 	return 0;
 }
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index c9c7f7b3b7db..9bc39ca460c8 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -970,6 +970,7 @@ static void enable_async(struct ehci_hcd *ehci)
 
 	/* Don't start the schedule until ASS is 0 */
 	ehci_poll_ASS(ehci);
+	turn_on_io_watchdog(ehci);
 }
 
 static void disable_async(struct ehci_hcd *ehci)
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 263b542985c0..26ce8fef0e5b 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -489,6 +489,7 @@ static void enable_periodic(struct ehci_hcd *ehci)
 
 	/* Don't start the schedule until PSS is 0 */
 	ehci_poll_PSS(ehci);
+	turn_on_io_watchdog(ehci);
 }
 
 static void disable_periodic(struct ehci_hcd *ehci)
@@ -1649,7 +1650,6 @@ static void itd_link_urb(
 	iso_sched_free (stream, iso_sched);
 	urb-&gt;hcpriv = NULL;
 
-	timer_action (ehci, TIMER_IO_WATCHDOG);
 	++ehci-&gt;isoc_count;
 	enable_periodic(ehci);
 }
@@ -2052,7 +2052,6 @@ static void sitd_link_urb(
 	iso_sched_free (stream, sched);
 	urb-&gt;hcpriv = NULL;
 
-	timer_action (ehci, TIMER_IO_WATCHDOG);
 	++ehci-&gt;isoc_count;
 	enable_periodic(ehci);
 }
diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index 0e28bae78d18..eb896a2c8f2e 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -76,6 +76,7 @@ static unsigned event_delays_ns[] = {
 	10 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_IAA_WATCHDOG */
 	10 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_DISABLE_PERIODIC */
 	15 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_DISABLE_ASYNC */
+	100 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_IO_WATCHDOG */
 };
 
 /* Enable a pending hrtimer event */
@@ -332,6 +333,25 @@ static void ehci_iaa_watchdog(struct ehci_hcd *ehci)
 }
 
 
+/* Enable the I/O watchdog, if appropriate */
+static void turn_on_io_watchdog(struct ehci_hcd *ehci)
+{
+	/* Not needed if the controller isn't running or it's already enabled */
+	if (ehci-&gt;rh_state != EHCI_RH_RUNNING ||
+			(ehci-&gt;enabled_hrtimer_events &amp;
+				BIT(EHCI_HRTIMER_IO_WATCHDOG)))
+		return;
+
+	/*
+	 * Isochronous transfers always need the watchdog.
+	 * For other sorts we use it only if the flag is set.
+	 */
+	if (ehci-&gt;isoc_count &gt; 0 || (ehci-&gt;need_io_watchdog &amp;&amp;
+			ehci-&gt;async_count + ehci-&gt;intr_count &gt; 0))
+		ehci_enable_event(ehci, EHCI_HRTIMER_IO_WATCHDOG, true);
+}
+
+
 /*
  * Handler functions for the hrtimer event types.
  * Keep this array in the same order as the event types indexed by
@@ -347,6 +367,7 @@ static void (*event_handlers[])(struct ehci_hcd *) = {
 	ehci_iaa_watchdog,		/* EHCI_HRTIMER_IAA_WATCHDOG */
 	ehci_disable_PSE,		/* EHCI_HRTIMER_DISABLE_PERIODIC */
 	ehci_disable_ASE,		/* EHCI_HRTIMER_DISABLE_ASYNC */
+	ehci_work,			/* EHCI_HRTIMER_IO_WATCHDOG */
 };
 
 static enum hrtimer_restart ehci_hrtimer_func(struct hrtimer *t)
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 08637183aad0..254f414bd0bd 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -88,6 +88,7 @@ enum ehci_hrtimer_event {
 	EHCI_HRTIMER_IAA_WATCHDOG,	/* Handle lost IAA interrupts */
 	EHCI_HRTIMER_DISABLE_PERIODIC,	/* Wait to disable periodic sched */
 	EHCI_HRTIMER_DISABLE_ASYNC,	/* Wait to disable async sched */
+	EHCI_HRTIMER_IO_WATCHDOG,	/* Check for missing IRQs */
 	EHCI_HRTIMER_NUM_EVENTS		/* Must come last */
 };
 #define EHCI_HRTIMER_NO_EVENT	99
@@ -177,8 +178,6 @@ struct ehci_hcd {			/* one per controller */
 	struct dma_pool		*itd_pool;	/* itd per iso urb */
 	struct dma_pool		*sitd_pool;	/* sitd per split iso urb */
 
-	struct timer_list	watchdog;
-	unsigned long		actions;
 	unsigned		random_frame;
 	unsigned long		next_statechange;
 	ktime_t			last_periodic_enable;
@@ -235,16 +234,6 @@ static inline struct usb_hcd *ehci_to_hcd (struct ehci_hcd *ehci)
 	return container_of ((void *) ehci, struct usb_hcd, hcd_priv);
 }
 
-enum ehci_timer_action {
-	TIMER_IO_WATCHDOG,
-};
-
-static inline void
-timer_action_done (struct ehci_hcd *ehci, enum ehci_timer_action action)
-{
-	clear_bit (action, &amp;ehci-&gt;actions);
-}
-
 /*-------------------------------------------------------------------------*/
 
 #include &lt;linux/usb/ehci_def.h&gt;</pre><hr><pre>commit 569b394f53f0abd177cc665c9b4ace89e3f4c7fb
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 11 11:23:00 2012 -0400

    USB: EHCI: always scan each interrupt QH
    
    This patch (as1585) fixes a bug in ehci-hcd's scheme for scanning
    interrupt QHs.
    
    Currently a single routine takes care of scanning everything on the
    periodic schedule.  Whenever an interrupt occurs, it scans all
    isochronous and interrupt URBs scheduled for frames that have elapsed
    since the last scan.
    
    This has two disadvantages.  The first is relatively minor: An
    interrupt QH is likely to end up getting scanned multiple times,
    particularly if the last scan was not fairly recent.  (The current
    code avoids this by maintaining a periodic_stamp in each interrupt
    QH.)
    
    The second is more serious.  The periodic schedule wraps around.  If
    the last scan occurred during frame N, and the next scan occurs when
    the schedule has gone through an entire cycle and is back at frame N,
    the scanning code won't look at any frames other than N.  Consequently
    it won't see any QHs that completed during frame N-1 or earlier.
    
    The patch replaces the entire frame-based approach for scanning
    interrupt QHs with a new routine using a list-based approach, the same
    as for async QHs.  This has a slight disadvantage, because it means
    that all interrupt QHs have to be scanned every time.  But it is more
    robust than the current approach.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index f6cf1d178107..c13dad8a8503 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -410,8 +410,10 @@ static void ehci_work (struct ehci_hcd *ehci)
 	ehci-&gt;need_rescan = false;
 	if (ehci-&gt;async_count)
 		scan_async(ehci);
-	if (ehci-&gt;next_uframe != -1)
-		scan_periodic (ehci);
+	if (ehci-&gt;intr_count &gt; 0)
+		scan_intr(ehci);
+	if (ehci-&gt;isoc_count &gt; 0)
+		scan_isoc(ehci);
 	if (ehci-&gt;need_rescan)
 		goto rescan;
 	ehci-&gt;scanning = false;
@@ -509,6 +511,7 @@ static int ehci_init(struct usb_hcd *hcd)
 	 * periodic_size can shrink by USBCMD update if hcc_params allows.
 	 */
 	ehci-&gt;periodic_size = DEFAULT_I_TDPS;
+	INIT_LIST_HEAD(&amp;ehci-&gt;intr_qh_list);
 	INIT_LIST_HEAD(&amp;ehci-&gt;cached_itd_list);
 	INIT_LIST_HEAD(&amp;ehci-&gt;cached_sitd_list);
 
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index bae931767825..c9c7f7b3b7db 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -322,7 +322,7 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	 *
 	 * It's a bug for qh-&gt;qh_state to be anything other than
 	 * QH_STATE_IDLE, unless our caller is scan_async() or
-	 * scan_periodic().
+	 * scan_intr().
 	 */
 	state = qh-&gt;qh_state;
 	qh-&gt;qh_state = QH_STATE_COMPLETING;
@@ -832,7 +832,6 @@ qh_make (
 				is_input, 0,
 				hb_mult(maxp) * max_packet(maxp)));
 		qh-&gt;start = NO_FRAME;
-		qh-&gt;stamp = ehci-&gt;periodic_stamp;
 
 		if (urb-&gt;dev-&gt;speed == USB_SPEED_HIGH) {
 			qh-&gt;c_usecs = 0;
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 11b2f21d7ac1..263b542985c0 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -569,7 +569,10 @@ static void qh_link_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)
 		? ((qh-&gt;usecs + qh-&gt;c_usecs) / qh-&gt;period)
 		: (qh-&gt;usecs * 8);
 
+	list_add(&amp;qh-&gt;intr_node, &amp;ehci-&gt;intr_qh_list);
+
 	/* maybe enable periodic schedule processing */
+	++ehci-&gt;intr_count;
 	enable_periodic(ehci);
 }
 
@@ -614,6 +617,11 @@ static void qh_unlink_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)
 	/* qh-&gt;qh_next still "live" to HC */
 	qh-&gt;qh_state = QH_STATE_UNLINK;
 	qh-&gt;qh_next.ptr = NULL;
+
+	if (ehci-&gt;qh_scan_next == qh)
+		ehci-&gt;qh_scan_next = list_entry(qh-&gt;intr_node.next,
+				struct ehci_qh, intr_node);
+	list_del(&amp;qh-&gt;intr_node);
 }
 
 static void start_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh)
@@ -683,6 +691,7 @@ static void end_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh)
 	}
 
 	/* maybe turn off periodic schedule */
+	--ehci-&gt;intr_count;
 	disable_periodic(ehci);
 }
 
@@ -920,6 +929,35 @@ static int intr_submit (
 	return status;
 }
 
+static void scan_intr(struct ehci_hcd *ehci)
+{
+	struct ehci_qh		*qh;
+
+	list_for_each_entry_safe(qh, ehci-&gt;qh_scan_next, &amp;ehci-&gt;intr_qh_list,
+			intr_node) {
+ rescan:
+		/* clean any finished work for this qh */
+		if (!list_empty(&amp;qh-&gt;qtd_list)) {
+			int temp;
+
+			/*
+			 * Unlinks could happen here; completion reporting
+			 * drops the lock.  That's why ehci-&gt;qh_scan_next
+			 * always holds the next qh to scan; if the next qh
+			 * gets unlinked then ehci-&gt;qh_scan_next is adjusted
+			 * in qh_unlink_periodic().
+			 */
+			temp = qh_completions(ehci, qh);
+			if (unlikely(qh-&gt;needs_rescan ||
+					(list_empty(&amp;qh-&gt;qtd_list) &amp;&amp;
+						qh-&gt;qh_state == QH_STATE_LINKED)))
+				start_unlink_intr(ehci, qh);
+			else if (temp != 0)
+				goto rescan;
+		}
+	}
+}
+
 /*-------------------------------------------------------------------------*/
 
 /* ehci_iso_stream ops work with both ITD and SITD */
@@ -1450,6 +1488,10 @@ iso_stream_schedule (
 	urb-&gt;start_frame = stream-&gt;next_uframe;
 	if (!stream-&gt;highspeed)
 		urb-&gt;start_frame &gt;&gt;= 3;
+
+	/* Make sure scan_isoc() sees these */
+	if (ehci-&gt;isoc_count == 0)
+		ehci-&gt;next_uframe = now;
 	return 0;
 
  fail:
@@ -1608,6 +1650,7 @@ static void itd_link_urb(
 	urb-&gt;hcpriv = NULL;
 
 	timer_action (ehci, TIMER_IO_WATCHDOG);
+	++ehci-&gt;isoc_count;
 	enable_periodic(ehci);
 }
 
@@ -1688,9 +1731,11 @@ itd_complete (
 	ehci_urb_done(ehci, urb, 0);
 	retval = true;
 	urb = NULL;
+
+	--ehci-&gt;isoc_count;
 	disable_periodic(ehci);
-	ehci_to_hcd(ehci)-&gt;self.bandwidth_isoc_reqs--;
 
+	ehci_to_hcd(ehci)-&gt;self.bandwidth_isoc_reqs--;
 	if (ehci_to_hcd(ehci)-&gt;self.bandwidth_isoc_reqs == 0) {
 		if (ehci-&gt;amd_pll_fix == 1)
 			usb_amd_quirk_pll_enable();
@@ -2008,6 +2053,7 @@ static void sitd_link_urb(
 	urb-&gt;hcpriv = NULL;
 
 	timer_action (ehci, TIMER_IO_WATCHDOG);
+	++ehci-&gt;isoc_count;
 	enable_periodic(ehci);
 }
 
@@ -2074,9 +2120,11 @@ sitd_complete (
 	ehci_urb_done(ehci, urb, 0);
 	retval = true;
 	urb = NULL;
+
+	--ehci-&gt;isoc_count;
 	disable_periodic(ehci);
-	ehci_to_hcd(ehci)-&gt;self.bandwidth_isoc_reqs--;
 
+	ehci_to_hcd(ehci)-&gt;self.bandwidth_isoc_reqs--;
 	if (ehci_to_hcd(ehci)-&gt;self.bandwidth_isoc_reqs == 0) {
 		if (ehci-&gt;amd_pll_fix == 1)
 			usb_amd_quirk_pll_enable();
@@ -2165,8 +2213,7 @@ static int sitd_submit (struct ehci_hcd *ehci, struct urb *urb,
 
 /*-------------------------------------------------------------------------*/
 
-static void
-scan_periodic (struct ehci_hcd *ehci)
+static void scan_isoc(struct ehci_hcd *ehci)
 {
 	unsigned	now_uframe, frame, clock, clock_frame, mod;
 	unsigned	modified;
@@ -2189,7 +2236,6 @@ scan_periodic (struct ehci_hcd *ehci)
 	ehci-&gt;clock_frame = clock_frame;
 	clock &amp;= mod - 1;
 	clock_frame = clock &gt;&gt; 3;
-	++ehci-&gt;periodic_stamp;
 
 	for (;;) {
 		union ehci_shadow	q, *q_p;
@@ -2208,36 +2254,10 @@ scan_periodic (struct ehci_hcd *ehci)
 
 		while (q.ptr != NULL) {
 			unsigned		uf;
-			union ehci_shadow	temp;
 			int			live;
 
 			live = (ehci-&gt;rh_state &gt;= EHCI_RH_RUNNING);
 			switch (hc32_to_cpu(ehci, type)) {
-			case Q_TYPE_QH:
-				/* handle any completions */
-				temp.qh = q.qh;
-				type = Q_NEXT_TYPE(ehci, q.qh-&gt;hw-&gt;hw_next);
-				q = q.qh-&gt;qh_next;
-				if (temp.qh-&gt;stamp != ehci-&gt;periodic_stamp) {
-					modified = qh_completions(ehci, temp.qh);
-					if (!modified)
-						temp.qh-&gt;stamp = ehci-&gt;periodic_stamp;
-					if (unlikely(list_empty(&amp;temp.qh-&gt;qtd_list) ||
-							temp.qh-&gt;needs_rescan))
-						start_unlink_intr(ehci, temp.qh);
-				}
-				break;
-			case Q_TYPE_FSTN:
-				/* for "save place" FSTNs, look at QH entries
-				 * in the previous frame for completions.
-				 */
-				if (q.fstn-&gt;hw_prev != EHCI_LIST_END(ehci)) {
-					ehci_dbg(ehci,
-						"ignoring completions from FSTNs\n");
-				}
-				type = Q_NEXT_TYPE(ehci, q.fstn-&gt;hw_next);
-				q = q.fstn-&gt;fstn_next;
-				break;
 			case Q_TYPE_ITD:
 				/* If this ITD is still active, leave it for
 				 * later processing ... check the next entry.
@@ -2319,12 +2339,17 @@ scan_periodic (struct ehci_hcd *ehci)
 				ehci_dbg(ehci, "corrupt type %d frame %d shadow %p\n",
 					type, frame, q.ptr);
 				// BUG ();
+				/* FALL THROUGH */
+			case Q_TYPE_QH:
+			case Q_TYPE_FSTN:
+				/* End of the iTDs and siTDs */
 				q.ptr = NULL;
+				break;
 			}
 
 			/* assume completion callbacks modify the queue */
 			if (unlikely (modified)) {
-				if (likely(ehci-&gt;periodic_count &gt; 0))
+				if (likely(ehci-&gt;isoc_count &gt; 0))
 					goto restart;
 				/* short-circuit this scan */
 				now_uframe = clock;
@@ -2353,7 +2378,7 @@ scan_periodic (struct ehci_hcd *ehci)
 			unsigned	now;
 
 			if (ehci-&gt;rh_state &lt; EHCI_RH_RUNNING
-					|| ehci-&gt;periodic_count == 0)
+					|| ehci-&gt;isoc_count == 0)
 				break;
 			ehci-&gt;next_uframe = now_uframe;
 			now = ehci_read_frame_index(ehci) &amp; (mod - 1);
@@ -2363,10 +2388,7 @@ scan_periodic (struct ehci_hcd *ehci)
 			/* rescan the rest of this frame, then ... */
 			clock = now;
 			clock_frame = clock &gt;&gt; 3;
-			if (ehci-&gt;clock_frame != clock_frame) {
-				ehci-&gt;clock_frame = clock_frame;
-				++ehci-&gt;periodic_stamp;
-			}
+			ehci-&gt;clock_frame = clock_frame;
 		} else {
 			now_uframe++;
 			now_uframe &amp;= mod - 1;
diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index a823290b5139..0e28bae78d18 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -168,13 +168,8 @@ static void ehci_poll_PSS(struct ehci_hcd *ehci)
 
 	/* The status is up-to-date; restart or stop the schedule as needed */
 	if (want == 0) {	/* Stopped */
-		if (ehci-&gt;periodic_count &gt; 0) {
-
-			/* make sure ehci_work scans these */
-			ehci-&gt;next_uframe = ehci_read_frame_index(ehci)
-					&amp; ((ehci-&gt;periodic_size &lt;&lt; 3) - 1);
+		if (ehci-&gt;periodic_count &gt; 0)
 			ehci_set_command_bit(ehci, CMD_PSE);
-		}
 
 	} else {		/* Running */
 		if (ehci-&gt;periodic_count == 0) {
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index c462d52ac575..08637183aad0 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -117,6 +117,7 @@ struct ehci_hcd {			/* one per controller */
 	bool			need_rescan:1;
 	bool			intr_unlinking:1;
 	bool			async_unlinking:1;
+	struct ehci_qh		*qh_scan_next;
 
 	/* async schedule support */
 	struct ehci_qh		*async;
@@ -124,7 +125,6 @@ struct ehci_hcd {			/* one per controller */
 	struct ehci_qh		*async_unlink;
 	struct ehci_qh		*async_unlink_last;
 	struct ehci_qh		*async_iaa;
-	struct ehci_qh		*qh_scan_next;
 	unsigned		async_unlink_cycle;
 	unsigned		async_count;	/* async activity count */
 
@@ -133,6 +133,7 @@ struct ehci_hcd {			/* one per controller */
 	unsigned		periodic_size;
 	__hc32			*periodic;	/* hw periodic table */
 	dma_addr_t		periodic_dma;
+	struct list_head	intr_qh_list;
 	unsigned		i_thresh;	/* uframes HC might cache */
 
 	union ehci_shadow	*pshadow;	/* mirror hw periodic table */
@@ -140,6 +141,8 @@ struct ehci_hcd {			/* one per controller */
 	struct ehci_qh		*intr_unlink_last;
 	unsigned		intr_unlink_cycle;
 	int			next_uframe;	/* scan periodic, start here */
+	unsigned		intr_count;	/* intr activity count */
+	unsigned		isoc_count;	/* isoc activity count */
 	unsigned		periodic_count;	/* periodic activity count */
 	unsigned		uframe_periodic_max; /* max periodic time per uframe */
 
@@ -176,7 +179,6 @@ struct ehci_hcd {			/* one per controller */
 
 	struct timer_list	watchdog;
 	unsigned long		actions;
-	unsigned		periodic_stamp;
 	unsigned		random_frame;
 	unsigned long		next_statechange;
 	ktime_t			last_periodic_enable;
@@ -381,11 +383,11 @@ struct ehci_qh {
 	dma_addr_t		qh_dma;		/* address of qh */
 	union ehci_shadow	qh_next;	/* ptr to qh; or periodic */
 	struct list_head	qtd_list;	/* sw qtd list */
+	struct list_head	intr_node;	/* list of intr QHs */
 	struct ehci_qtd		*dummy;
 	struct ehci_qh		*unlink_next;	/* next on unlink list */
 
 	unsigned		unlink_cycle;
-	unsigned		stamp;
 
 	u8			needs_rescan;	/* Dequeue during giveback */
 	u8			qh_state;</pre><hr><pre>commit 361aabf395e4a23cf554cf4ec0c0c6963b8beb01
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 11 11:22:57 2012 -0400

    USB: EHCI: don't lose events during a scan
    
    This patch (as1584) fixes a minor bug that has been present in
    ehci-hcd since the beginning.
    
    Scanning the schedules for URB completions is single-threaded.  If a
    completion interrupt occurs while an URB is being given back, the
    interrupt handler realizes that a scan is in progress on another CPU
    and avoids starting a new one.
    
    This means that completion events can be lost.  If an URB completes
    after it has been scanned but while a scan is still in progress, the
    driver won't notice and won't rescan the completed URB.
    
    The patch fixes the problem by adding a new flag to indicate that
    another scan is needed after the current scan is done.  The flag gets
    set whenever a completion interrupt occurs while a scan is in
    progress.  The rescan will see the completion, thus preventing it from
    getting lost.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 74ffd20edff8..f6cf1d178107 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -400,14 +400,21 @@ static void ehci_work (struct ehci_hcd *ehci)
 	 * it reports urb completions.  this flag guards against bogus
 	 * attempts at re-entrant schedule scanning.
 	 */
-	if (ehci-&gt;scanning)
+	if (ehci-&gt;scanning) {
+		ehci-&gt;need_rescan = true;
 		return;
-	ehci-&gt;scanning = 1;
+	}
+	ehci-&gt;scanning = true;
+
+ rescan:
+	ehci-&gt;need_rescan = false;
 	if (ehci-&gt;async_count)
 		scan_async(ehci);
 	if (ehci-&gt;next_uframe != -1)
 		scan_periodic (ehci);
-	ehci-&gt;scanning = 0;
+	if (ehci-&gt;need_rescan)
+		goto rescan;
+	ehci-&gt;scanning = false;
 
 	/* the IO watchdog guards against hardware or driver bugs that
 	 * misplace IRQs, and should let us run completely without IRQs.
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 303c36cc99c9..c462d52ac575 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -113,7 +113,8 @@ struct ehci_hcd {			/* one per controller */
 	enum ehci_rh_state	rh_state;
 
 	/* general schedule support */
-	unsigned		scanning:1;
+	bool			scanning:1;
+	bool			need_rescan:1;
 	bool			intr_unlinking:1;
 	bool			async_unlinking:1;
 </pre><hr><pre>commit 32830f207691176234b4c4dd17f0d7ab6d87d94b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 11 11:22:53 2012 -0400

    USB: EHCI: use hrtimer for unlinking empty async QHs
    
    This patch (as1583) changes ehci-hcd to use an hrtimer event for
    unlinking empty (unused) async QHs instead of using a kernel timer.
    
    The check for empty QHs is moved to a new routine, where it doesn't
    require going through an entire scan of both the async and periodic
    schedules.  And it can unlink multiple QHs at once, unlike the current
    code.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 86e8ee169c67..74ffd20edff8 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -94,8 +94,6 @@ static const char	hcd_name [] = "ehci_hcd";
 #define	EHCI_TUNE_FLS		1	/* (medium) 512-frame schedule */
 
 #define EHCI_IO_JIFFIES		(HZ/10)		/* io watchdog &gt; irq_thresh */
-#define EHCI_SHRINK_JIFFIES	(DIV_ROUND_UP(HZ, 200) + 1)
-						/* 5-ms async qh unlink delay */
 
 /* Initial IRQ latency:  faster than hw default */
 static int log2_irq_thresh = 0;		// 0 to 6
@@ -130,15 +128,6 @@ MODULE_PARM_DESC(hird, "host initiated resume duration, +1 for each 75us");
 static void
 timer_action(struct ehci_hcd *ehci, enum ehci_timer_action action)
 {
-	/* Don't override timeouts which shrink or (later) disable
-	 * the async ring; just the I/O watchdog.  Note that if a
-	 * SHRINK were pending, OFF would never be requested.
-	 */
-	if (timer_pending(&amp;ehci-&gt;watchdog)
-			&amp;&amp; (BIT(TIMER_ASYNC_SHRINK)
-				&amp; ehci-&gt;actions))
-		return;
-
 	if (!test_and_set_bit(action, &amp;ehci-&gt;actions)) {
 		unsigned long t;
 
@@ -148,10 +137,6 @@ timer_action(struct ehci_hcd *ehci, enum ehci_timer_action action)
 				return;
 			t = EHCI_IO_JIFFIES;
 			break;
-		/* case TIMER_ASYNC_SHRINK: */
-		default:
-			t = EHCI_SHRINK_JIFFIES;
-			break;
 		}
 		mod_timer(&amp;ehci-&gt;watchdog, t + jiffies);
 	}
@@ -307,6 +292,7 @@ static void ehci_quiesce (struct ehci_hcd *ehci)
 /*-------------------------------------------------------------------------*/
 
 static void end_unlink_async(struct ehci_hcd *ehci);
+static void unlink_empty_async(struct ehci_hcd *ehci);
 static void ehci_work(struct ehci_hcd *ehci);
 static void start_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh);
 static void end_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh);
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index a3822700e496..5d84562e2716 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -300,6 +300,7 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 	ehci-&gt;rh_state = EHCI_RH_SUSPENDED;
 
 	end_unlink_async(ehci);
+	unlink_empty_async(ehci);
 	ehci_handle_intr_unlinks(ehci);
 	end_free_itds(ehci);
 
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 181832921c53..bae931767825 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -1205,7 +1205,7 @@ static void start_iaa_cycle(struct ehci_hcd *ehci, bool nested)
 			end_unlink_async(ehci);
 
 	/* Otherwise start a new IAA cycle */
-	} else {
+	} else if (likely(ehci-&gt;rh_state == EHCI_RH_RUNNING)) {
 		/* Make sure the unlinks are all visible to the hardware */
 		wmb();
 
@@ -1253,6 +1253,39 @@ static void end_unlink_async(struct ehci_hcd *ehci)
 	}
 }
 
+static void unlink_empty_async(struct ehci_hcd *ehci)
+{
+	struct ehci_qh		*qh, *next;
+	bool			stopped = (ehci-&gt;rh_state &lt; EHCI_RH_RUNNING);
+	bool			check_unlinks_later = false;
+
+	/* Unlink all the async QHs that have been empty for a timer cycle */
+	next = ehci-&gt;async-&gt;qh_next.qh;
+	while (next) {
+		qh = next;
+		next = qh-&gt;qh_next.qh;
+
+		if (list_empty(&amp;qh-&gt;qtd_list) &amp;&amp;
+				qh-&gt;qh_state == QH_STATE_LINKED) {
+			if (!stopped &amp;&amp; qh-&gt;unlink_cycle ==
+					ehci-&gt;async_unlink_cycle)
+				check_unlinks_later = true;
+			else
+				single_unlink_async(ehci, qh);
+		}
+	}
+
+	/* Start a new IAA cycle if any QHs are waiting for it */
+	if (ehci-&gt;async_unlink)
+		start_iaa_cycle(ehci, false);
+
+	/* QHs that haven't been empty for long enough will be handled later */
+	if (check_unlinks_later) {
+		ehci_enable_event(ehci, EHCI_HRTIMER_ASYNC_UNLINKS, true);
+		++ehci-&gt;async_unlink_cycle;
+	}
+}
+
 /* makes sure the async qh will become idle */
 /* caller must own ehci-&gt;lock */
 
@@ -1277,12 +1310,8 @@ static void start_unlink_async(struct ehci_hcd *ehci, struct ehci_qh *qh)
 
 static void scan_async (struct ehci_hcd *ehci)
 {
-	bool			stopped;
 	struct ehci_qh		*qh;
-	enum ehci_timer_action	action = TIMER_IO_WATCHDOG;
-
-	timer_action_done (ehci, TIMER_ASYNC_SHRINK);
-	stopped = (ehci-&gt;rh_state &lt; EHCI_RH_RUNNING);
+	bool			check_unlinks_later = false;
 
 	ehci-&gt;qh_scan_next = ehci-&gt;async-&gt;qh_next.qh;
 	while (ehci-&gt;qh_scan_next) {
@@ -1301,28 +1330,27 @@ static void scan_async (struct ehci_hcd *ehci)
 			 * in single_unlink_async().
 			 */
 			temp = qh_completions(ehci, qh);
-			if (qh-&gt;needs_rescan)
+			if (qh-&gt;needs_rescan) {
 				start_unlink_async(ehci, qh);
-			qh-&gt;unlink_time = jiffies + EHCI_SHRINK_JIFFIES;
-			if (temp != 0)
+			} else if (list_empty(&amp;qh-&gt;qtd_list)
+					&amp;&amp; qh-&gt;qh_state == QH_STATE_LINKED) {
+				qh-&gt;unlink_cycle = ehci-&gt;async_unlink_cycle;
+				check_unlinks_later = true;
+			} else if (temp != 0)
 				goto rescan;
 		}
+	}
 
-		/* unlink idle entries, reducing DMA usage as well
-		 * as HCD schedule-scanning costs.  delay for any qh
-		 * we just scanned, there's a not-unusual case that it
-		 * doesn't stay idle for long.
-		 * (plus, avoids some kind of re-activation race.)
-		 */
-		if (list_empty(&amp;qh-&gt;qtd_list)
-				&amp;&amp; qh-&gt;qh_state == QH_STATE_LINKED) {
-			if (!ehci-&gt;async_unlink &amp;&amp; (stopped ||
-					time_after_eq(jiffies, qh-&gt;unlink_time)))
-				start_unlink_async(ehci, qh);
-			else
-				action = TIMER_ASYNC_SHRINK;
-		}
+	/*
+	 * Unlink empty entries, reducing DMA usage as well
+	 * as HCD schedule-scanning costs.  Delay for any qh
+	 * we just scanned, there's a not-unusual case that it
+	 * doesn't stay idle for long.
+	 */
+	if (check_unlinks_later &amp;&amp; ehci-&gt;rh_state == EHCI_RH_RUNNING &amp;&amp;
+			!(ehci-&gt;enabled_hrtimer_events &amp;
+				BIT(EHCI_HRTIMER_ASYNC_UNLINKS))) {
+		ehci_enable_event(ehci, EHCI_HRTIMER_ASYNC_UNLINKS, true);
+		++ehci-&gt;async_unlink_cycle;
 	}
-	if (action == TIMER_ASYNC_SHRINK)
-		timer_action (ehci, TIMER_ASYNC_SHRINK);
 }
diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index 8ca5f152f5bd..a823290b5139 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -72,6 +72,7 @@ static unsigned event_delays_ns[] = {
 	1 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_POLL_DEAD */
 	1125 * NSEC_PER_USEC,	/* EHCI_HRTIMER_UNLINK_INTR */
 	2 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_FREE_ITDS */
+	6 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_ASYNC_UNLINKS */
 	10 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_IAA_WATCHDOG */
 	10 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_DISABLE_PERIODIC */
 	15 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_DISABLE_ASYNC */
@@ -347,6 +348,7 @@ static void (*event_handlers[])(struct ehci_hcd *) = {
 	ehci_handle_controller_death,	/* EHCI_HRTIMER_POLL_DEAD */
 	ehci_handle_intr_unlinks,	/* EHCI_HRTIMER_UNLINK_INTR */
 	end_free_itds,			/* EHCI_HRTIMER_FREE_ITDS */
+	unlink_empty_async,		/* EHCI_HRTIMER_ASYNC_UNLINKS */
 	ehci_iaa_watchdog,		/* EHCI_HRTIMER_IAA_WATCHDOG */
 	ehci_disable_PSE,		/* EHCI_HRTIMER_DISABLE_PERIODIC */
 	ehci_disable_ASE,		/* EHCI_HRTIMER_DISABLE_ASYNC */
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 1a782775881b..303c36cc99c9 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -84,6 +84,7 @@ enum ehci_hrtimer_event {
 	EHCI_HRTIMER_POLL_DEAD,		/* Wait for dead controller to stop */
 	EHCI_HRTIMER_UNLINK_INTR,	/* Wait for interrupt QH unlink */
 	EHCI_HRTIMER_FREE_ITDS,		/* Wait for unused iTDs and siTDs */
+	EHCI_HRTIMER_ASYNC_UNLINKS,	/* Unlink empty async QHs */
 	EHCI_HRTIMER_IAA_WATCHDOG,	/* Handle lost IAA interrupts */
 	EHCI_HRTIMER_DISABLE_PERIODIC,	/* Wait to disable periodic sched */
 	EHCI_HRTIMER_DISABLE_ASYNC,	/* Wait to disable async sched */
@@ -123,6 +124,7 @@ struct ehci_hcd {			/* one per controller */
 	struct ehci_qh		*async_unlink_last;
 	struct ehci_qh		*async_iaa;
 	struct ehci_qh		*qh_scan_next;
+	unsigned		async_unlink_cycle;
 	unsigned		async_count;	/* async activity count */
 
 	/* periodic schedule support */
@@ -232,7 +234,6 @@ static inline struct usb_hcd *ehci_to_hcd (struct ehci_hcd *ehci)
 
 enum ehci_timer_action {
 	TIMER_IO_WATCHDOG,
-	TIMER_ASYNC_SHRINK,
 };
 
 static inline void
@@ -382,7 +383,6 @@ struct ehci_qh {
 	struct ehci_qtd		*dummy;
 	struct ehci_qh		*unlink_next;	/* next on unlink list */
 
-	unsigned long		unlink_time;
 	unsigned		unlink_cycle;
 	unsigned		stamp;
 </pre><hr><pre>commit 3c273a056bf46167f0a1309c2ba72282a17d2541
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 11 11:22:49 2012 -0400

    USB: EHCI: unlink multiple async QHs together
    
    This patch (as1582) changes ehci-hcd's strategy for unlinking async
    QHs.  Currently the driver never unlinks more than one QH at a time.
    This can be inefficient and cause unnecessary delays, since a QH
    cannot be reused while it is waiting to be unlinked.
    
    The new strategy unlinks all the waiting QHs at once.  In practice the
    improvement won't be very big, because it's somewhat uncommon to have
    two or more QHs waiting to be unlinked at any time.  But it does
    happen, and in any case, doing things this way makes more sense IMO.
    
    The change requires the async unlinking code to be refactored
    slightly.  Now in addition to the routines for starting and ending an
    unlink, there are new routines for unlinking a single QH and starting
    an IAA cycle.  This approach is needed because there are two separate
    paths for unlinking async QHs:
    
            When a transfer error occurs or an URB is cancelled, the QH
            must be unlinked right away;
    
            When a QH has been idle sufficiently long, it is unlinked
            to avoid consuming DMA bandwidth uselessly.
    
    In the first case we want the unlink to proceed as quickly as
    possible, whereas in the second case we can afford to batch several
    QHs together and unlink them all at once.  Hence the division of
    labor.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index f74ba277c22d..86e8ee169c67 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -795,7 +795,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 		/* guard against (alleged) silicon errata */
 		if (cmd &amp; CMD_IAAD)
 			ehci_dbg(ehci, "IAA with IAAD still set?\n");
-		if (ehci-&gt;async_unlink) {
+		if (ehci-&gt;async_iaa) {
 			COUNT(ehci-&gt;stats.iaa);
 			end_unlink_async(ehci);
 		} else
@@ -926,33 +926,6 @@ static int ehci_urb_enqueue (
 	}
 }
 
-static void unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
-{
-	/* failfast */
-	if (ehci-&gt;rh_state &lt; EHCI_RH_RUNNING &amp;&amp; ehci-&gt;async_unlink)
-		end_unlink_async(ehci);
-
-	/* If the QH isn't linked then there's nothing we can do
-	 * unless we were called during a giveback, in which case
-	 * qh_completions() has to deal with it.
-	 */
-	if (qh-&gt;qh_state != QH_STATE_LINKED) {
-		if (qh-&gt;qh_state == QH_STATE_COMPLETING)
-			qh-&gt;needs_rescan = 1;
-		return;
-	}
-
-	/* defer till later if busy */
-	if (ehci-&gt;async_unlink) {
-		qh-&gt;qh_state = QH_STATE_UNLINK_WAIT;
-		ehci-&gt;async_unlink_last-&gt;unlink_next = qh;
-		ehci-&gt;async_unlink_last = qh;
-
-	/* start IAA cycle */
-	} else
-		start_unlink_async (ehci, qh);
-}
-
 /* remove from hardware lists
  * completions normally happen asynchronously
  */
@@ -979,7 +952,7 @@ static int ehci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 		switch (qh-&gt;qh_state) {
 		case QH_STATE_LINKED:
 		case QH_STATE_COMPLETING:
-			unlink_async(ehci, qh);
+			start_unlink_async(ehci, qh);
 			break;
 		case QH_STATE_UNLINK:
 		case QH_STATE_UNLINK_WAIT:
@@ -1070,7 +1043,7 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 		 * may already be unlinked.
 		 */
 		if (tmp)
-			unlink_async(ehci, qh);
+			start_unlink_async(ehci, qh);
 		/* FALL THROUGH */
 	case QH_STATE_UNLINK:		/* wait for hw to finish? */
 	case QH_STATE_UNLINK_WAIT:
@@ -1133,7 +1106,7 @@ ehci_endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 			 * re-linking will call qh_refresh().
 			 */
 			if (eptype == USB_ENDPOINT_XFER_BULK)
-				unlink_async(ehci, qh);
+				start_unlink_async(ehci, qh);
 			else
 				start_unlink_intr(ehci, qh);
 		}
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 3097872b1e74..a3822700e496 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -299,8 +299,7 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 	ehci_halt (ehci);
 	ehci-&gt;rh_state = EHCI_RH_SUSPENDED;
 
-	if (ehci-&gt;async_unlink)
-		end_unlink_async(ehci);
+	end_unlink_async(ehci);
 	ehci_handle_intr_unlinks(ehci);
 	end_free_itds(ehci);
 
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 7b35933d91a6..181832921c53 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -293,9 +293,6 @@ __acquires(ehci-&gt;lock)
 	spin_lock (&amp;ehci-&gt;lock);
 }
 
-static void start_unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh);
-static void unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh);
-
 static int qh_schedule (struct ehci_hcd *ehci, struct ehci_qh *qh);
 
 /*
@@ -1166,82 +1163,114 @@ submit_async (
 
 /*-------------------------------------------------------------------------*/
 
-/* the async qh for the qtds being unlinked are now gone from the HC */
-
-static void end_unlink_async (struct ehci_hcd *ehci)
+static void single_unlink_async(struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
-	struct ehci_qh		*qh = ehci-&gt;async_unlink;
-	struct ehci_qh		*next;
+	struct ehci_qh		*prev;
 
-	// qh-&gt;hw_next = cpu_to_hc32(qh-&gt;qh_dma);
-	qh-&gt;qh_state = QH_STATE_IDLE;
-	qh-&gt;qh_next.qh = NULL;
+	/* Add to the end of the list of QHs waiting for the next IAAD */
+	qh-&gt;qh_state = QH_STATE_UNLINK;
+	if (ehci-&gt;async_unlink)
+		ehci-&gt;async_unlink_last-&gt;unlink_next = qh;
+	else
+		ehci-&gt;async_unlink = qh;
+	ehci-&gt;async_unlink_last = qh;
+
+	/* Unlink it from the schedule */
+	prev = ehci-&gt;async;
+	while (prev-&gt;qh_next.qh != qh)
+		prev = prev-&gt;qh_next.qh;
+
+	prev-&gt;hw-&gt;hw_next = qh-&gt;hw-&gt;hw_next;
+	prev-&gt;qh_next = qh-&gt;qh_next;
+	if (ehci-&gt;qh_scan_next == qh)
+		ehci-&gt;qh_scan_next = qh-&gt;qh_next.qh;
+}
 
-	/* other unlink(s) may be pending (in QH_STATE_UNLINK_WAIT) */
-	next = qh-&gt;unlink_next;
-	ehci-&gt;async_unlink = next;
-	qh-&gt;unlink_next = NULL;
+static void start_iaa_cycle(struct ehci_hcd *ehci, bool nested)
+{
+	/*
+	 * Do nothing if an IAA cycle is already running or
+	 * if one will be started shortly.
+	 */
+	if (ehci-&gt;async_iaa || ehci-&gt;async_unlinking)
+		return;
 
-	qh_completions (ehci, qh);
+	/* Do all the waiting QHs at once */
+	ehci-&gt;async_iaa = ehci-&gt;async_unlink;
+	ehci-&gt;async_unlink = NULL;
 
-	if (!list_empty(&amp;qh-&gt;qtd_list) &amp;&amp; ehci-&gt;rh_state == EHCI_RH_RUNNING)
-		qh_link_async (ehci, qh);
+	/* If the controller isn't running, we don't have to wait for it */
+	if (unlikely(ehci-&gt;rh_state &lt; EHCI_RH_RUNNING)) {
+		if (!nested)		/* Avoid recursion */
+			end_unlink_async(ehci);
 
-	disable_async(ehci);
+	/* Otherwise start a new IAA cycle */
+	} else {
+		/* Make sure the unlinks are all visible to the hardware */
+		wmb();
 
-	if (next) {
-		ehci-&gt;async_unlink = NULL;
-		start_unlink_async (ehci, next);
+		ehci_writel(ehci, ehci-&gt;command | CMD_IAAD,
+				&amp;ehci-&gt;regs-&gt;command);
+		ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
+		ehci_enable_event(ehci, EHCI_HRTIMER_IAA_WATCHDOG, true);
 	}
+}
+
+/* the async qh for the qtds being unlinked are now gone from the HC */
+
+static void end_unlink_async(struct ehci_hcd *ehci)
+{
+	struct ehci_qh		*qh;
 
 	if (ehci-&gt;has_synopsys_hc_bug)
 		ehci_writel(ehci, (u32) ehci-&gt;async-&gt;qh_dma,
 			    &amp;ehci-&gt;regs-&gt;async_next);
+
+	/* Process the idle QHs */
+ restart:
+	ehci-&gt;async_unlinking = true;
+	while (ehci-&gt;async_iaa) {
+		qh = ehci-&gt;async_iaa;
+		ehci-&gt;async_iaa = qh-&gt;unlink_next;
+		qh-&gt;unlink_next = NULL;
+
+		qh-&gt;qh_state = QH_STATE_IDLE;
+		qh-&gt;qh_next.qh = NULL;
+
+		qh_completions(ehci, qh);
+		if (!list_empty(&amp;qh-&gt;qtd_list) &amp;&amp;
+				ehci-&gt;rh_state == EHCI_RH_RUNNING)
+			qh_link_async(ehci, qh);
+		disable_async(ehci);
+	}
+	ehci-&gt;async_unlinking = false;
+
+	/* Start a new IAA cycle if any QHs are waiting for it */
+	if (ehci-&gt;async_unlink) {
+		start_iaa_cycle(ehci, true);
+		if (unlikely(ehci-&gt;rh_state &lt; EHCI_RH_RUNNING))
+			goto restart;
+	}
 }
 
 /* makes sure the async qh will become idle */
 /* caller must own ehci-&gt;lock */
 
-static void start_unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
+static void start_unlink_async(struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
-	struct ehci_qh	*prev;
-
-#ifdef DEBUG
-	assert_spin_locked(&amp;ehci-&gt;lock);
-	if (ehci-&gt;async_unlink
-			|| (qh-&gt;qh_state != QH_STATE_LINKED
-				&amp;&amp; qh-&gt;qh_state != QH_STATE_UNLINK_WAIT)
-			)
-		BUG ();
-#endif
-
-	qh-&gt;qh_state = QH_STATE_UNLINK;
-	ehci-&gt;async_unlink = qh;
-	if (!qh-&gt;unlink_next)
-		ehci-&gt;async_unlink_last = qh;
-
-	prev = ehci-&gt;async;
-	while (prev-&gt;qh_next.qh != qh)
-		prev = prev-&gt;qh_next.qh;
-
-	prev-&gt;hw-&gt;hw_next = qh-&gt;hw-&gt;hw_next;
-	prev-&gt;qh_next = qh-&gt;qh_next;
-	if (ehci-&gt;qh_scan_next == qh)
-		ehci-&gt;qh_scan_next = qh-&gt;qh_next.qh;
-	wmb ();
-
-	/* If the controller isn't running, we don't have to wait for it */
-	if (unlikely(ehci-&gt;rh_state &lt; EHCI_RH_RUNNING)) {
-		/* if (unlikely (qh-&gt;unlink_next != 0))
-		 *	this will recurse, probably not much
-		 */
-		end_unlink_async (ehci);
+	/*
+	 * If the QH isn't linked then there's nothing we can do
+	 * unless we were called during a giveback, in which case
+	 * qh_completions() has to deal with it.
+	 */
+	if (qh-&gt;qh_state != QH_STATE_LINKED) {
+		if (qh-&gt;qh_state == QH_STATE_COMPLETING)
+			qh-&gt;needs_rescan = 1;
 		return;
 	}
 
-	ehci_writel(ehci, ehci-&gt;command | CMD_IAAD, &amp;ehci-&gt;regs-&gt;command);
-	(void)ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
-	ehci_enable_event(ehci, EHCI_HRTIMER_IAA_WATCHDOG, true);
+	single_unlink_async(ehci, qh);
+	start_iaa_cycle(ehci, false);
 }
 
 /*-------------------------------------------------------------------------*/
@@ -1269,11 +1298,11 @@ static void scan_async (struct ehci_hcd *ehci)
 			 * drops the lock.  That's why ehci-&gt;qh_scan_next
 			 * always holds the next qh to scan; if the next qh
 			 * gets unlinked then ehci-&gt;qh_scan_next is adjusted
-			 * in start_unlink_async().
+			 * in single_unlink_async().
 			 */
 			temp = qh_completions(ehci, qh);
 			if (qh-&gt;needs_rescan)
-				unlink_async(ehci, qh);
+				start_unlink_async(ehci, qh);
 			qh-&gt;unlink_time = jiffies + EHCI_SHRINK_JIFFIES;
 			if (temp != 0)
 				goto rescan;
diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index aab042064226..8ca5f152f5bd 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -211,6 +211,7 @@ static void ehci_handle_controller_death(struct ehci_hcd *ehci)
 	ehci_writel(ehci, 0, &amp;ehci-&gt;regs-&gt;configured_flag);
 	ehci_writel(ehci, 0, &amp;ehci-&gt;regs-&gt;intr_enable);
 	ehci_work(ehci);
+	end_unlink_async(ehci);
 
 	/* Not in process context, so don't try to reset the controller */
 }
@@ -304,7 +305,7 @@ static void ehci_iaa_watchdog(struct ehci_hcd *ehci)
 	 * (a) SMP races against real IAA firing and retriggering, and
 	 * (b) clean HC shutdown, when IAA watchdog was pending.
 	 */
-	if (ehci-&gt;async_unlink) {
+	if (ehci-&gt;async_iaa) {
 		u32 cmd, status;
 
 		/* If we get here, IAA is *REALLY* late.  It's barely
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index d9414aae610f..1a782775881b 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -114,12 +114,14 @@ struct ehci_hcd {			/* one per controller */
 	/* general schedule support */
 	unsigned		scanning:1;
 	bool			intr_unlinking:1;
+	bool			async_unlinking:1;
 
 	/* async schedule support */
 	struct ehci_qh		*async;
 	struct ehci_qh		*dummy;		/* For AMD quirk use */
 	struct ehci_qh		*async_unlink;
 	struct ehci_qh		*async_unlink_last;
+	struct ehci_qh		*async_iaa;
 	struct ehci_qh		*qh_scan_next;
 	unsigned		async_count;	/* async activity count */
 </pre><hr><pre>commit 9d9387475af261949f61a5ec465e1f762d7be08a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 11 11:22:44 2012 -0400

    USB: EHCI: use hrtimer for the IAA watchdog
    
    This patch (as1581) replaces the iaa_watchdog kernel timer used by
    ehci-hcd with an hrtimer event, in keeping with the general conversion
    to high-res timers.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index fb1966cf5649..f74ba277c22d 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -93,7 +93,6 @@ static const char	hcd_name [] = "ehci_hcd";
  */
 #define	EHCI_TUNE_FLS		1	/* (medium) 512-frame schedule */
 
-#define EHCI_IAA_MSECS		10		/* arbitrary */
 #define EHCI_IO_JIFFIES		(HZ/10)		/* io watchdog &gt; irq_thresh */
 #define EHCI_SHRINK_JIFFIES	(DIV_ROUND_UP(HZ, 200) + 1)
 						/* 5-ms async qh unlink delay */
@@ -322,51 +321,6 @@ static void end_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh);
 
 /*-------------------------------------------------------------------------*/
 
-static void ehci_iaa_watchdog(unsigned long param)
-{
-	struct ehci_hcd		*ehci = (struct ehci_hcd *) param;
-	unsigned long		flags;
-
-	spin_lock_irqsave (&amp;ehci-&gt;lock, flags);
-
-	/* Lost IAA irqs wedge things badly; seen first with a vt8235.
-	 * So we need this watchdog, but must protect it against both
-	 * (a) SMP races against real IAA firing and retriggering, and
-	 * (b) clean HC shutdown, when IAA watchdog was pending.
-	 */
-	if (ehci-&gt;async_unlink
-			&amp;&amp; !timer_pending(&amp;ehci-&gt;iaa_watchdog)
-			&amp;&amp; ehci-&gt;rh_state == EHCI_RH_RUNNING) {
-		u32 cmd, status;
-
-		/* If we get here, IAA is *REALLY* late.  It's barely
-		 * conceivable that the system is so busy that CMD_IAAD
-		 * is still legitimately set, so let's be sure it's
-		 * clear before we read STS_IAA.  (The HC should clear
-		 * CMD_IAAD when it sets STS_IAA.)
-		 */
-		cmd = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
-
-		/* If IAA is set here it either legitimately triggered
-		 * before we cleared IAAD above (but _way_ late, so we'll
-		 * still count it as lost) ... or a silicon erratum:
-		 * - VIA seems to set IAA without triggering the IRQ;
-		 * - IAAD potentially cleared without setting IAA.
-		 */
-		status = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;status);
-		if ((status &amp; STS_IAA) || !(cmd &amp; CMD_IAAD)) {
-			COUNT (ehci-&gt;stats.lost_iaa);
-			ehci_writel(ehci, STS_IAA, &amp;ehci-&gt;regs-&gt;status);
-		}
-
-		ehci_vdbg(ehci, "IAA watchdog: status %x cmd %x\n",
-				status, cmd);
-		end_unlink_async(ehci);
-	}
-
-	spin_unlock_irqrestore(&amp;ehci-&gt;lock, flags);
-}
-
 static void ehci_watchdog(unsigned long param)
 {
 	struct ehci_hcd		*ehci = (struct ehci_hcd *) param;
@@ -418,7 +372,6 @@ static void ehci_shutdown(struct usb_hcd *hcd)
 	struct ehci_hcd	*ehci = hcd_to_ehci(hcd);
 
 	del_timer_sync(&amp;ehci-&gt;watchdog);
-	del_timer_sync(&amp;ehci-&gt;iaa_watchdog);
 
 	spin_lock_irq(&amp;ehci-&gt;lock);
 	ehci-&gt;rh_state = EHCI_RH_STOPPING;
@@ -491,7 +444,6 @@ static void ehci_stop (struct usb_hcd *hcd)
 
 	/* no more interrupts ... */
 	del_timer_sync (&amp;ehci-&gt;watchdog);
-	del_timer_sync(&amp;ehci-&gt;iaa_watchdog);
 
 	spin_lock_irq(&amp;ehci-&gt;lock);
 	ehci-&gt;enabled_hrtimer_events = 0;
@@ -547,10 +499,6 @@ static int ehci_init(struct usb_hcd *hcd)
 	ehci-&gt;watchdog.function = ehci_watchdog;
 	ehci-&gt;watchdog.data = (unsigned long) ehci;
 
-	init_timer(&amp;ehci-&gt;iaa_watchdog);
-	ehci-&gt;iaa_watchdog.function = ehci_iaa_watchdog;
-	ehci-&gt;iaa_watchdog.data = (unsigned long) ehci;
-
 	hrtimer_init(&amp;ehci-&gt;hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);
 	ehci-&gt;hrtimer.function = ehci_hrtimer_func;
 	ehci-&gt;next_hrtimer_event = EHCI_HRTIMER_NO_EVENT;
@@ -830,6 +778,20 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 
 	/* complete the unlinking of some qh [4.15.2.3] */
 	if (status &amp; STS_IAA) {
+
+		/* Turn off the IAA watchdog */
+		ehci-&gt;enabled_hrtimer_events &amp;= ~BIT(EHCI_HRTIMER_IAA_WATCHDOG);
+
+		/*
+		 * Mild optimization: Allow another IAAD to reset the
+		 * hrtimer, if one occurs before the next expiration.
+		 * In theory we could always cancel the hrtimer, but
+		 * tests show that about half the time it will be reset
+		 * for some other event anyway.
+		 */
+		if (ehci-&gt;next_hrtimer_event == EHCI_HRTIMER_IAA_WATCHDOG)
+			++ehci-&gt;next_hrtimer_event;
+
 		/* guard against (alleged) silicon errata */
 		if (cmd &amp; CMD_IAAD)
 			ehci_dbg(ehci, "IAA with IAAD still set?\n");
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 6ad806bbe468..3097872b1e74 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -209,7 +209,6 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 	if (time_before (jiffies, ehci-&gt;next_statechange))
 		msleep(5);
 	del_timer_sync(&amp;ehci-&gt;watchdog);
-	del_timer_sync(&amp;ehci-&gt;iaa_watchdog);
 
 	spin_lock_irq (&amp;ehci-&gt;lock);
 
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index d68764ef4476..7b35933d91a6 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -1173,8 +1173,6 @@ static void end_unlink_async (struct ehci_hcd *ehci)
 	struct ehci_qh		*qh = ehci-&gt;async_unlink;
 	struct ehci_qh		*next;
 
-	iaa_watchdog_done(ehci);
-
 	// qh-&gt;hw_next = cpu_to_hc32(qh-&gt;qh_dma);
 	qh-&gt;qh_state = QH_STATE_IDLE;
 	qh-&gt;qh_next.qh = NULL;
@@ -1243,7 +1241,7 @@ static void start_unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 
 	ehci_writel(ehci, ehci-&gt;command | CMD_IAAD, &amp;ehci-&gt;regs-&gt;command);
 	(void)ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
-	iaa_watchdog_start(ehci);
+	ehci_enable_event(ehci, EHCI_HRTIMER_IAA_WATCHDOG, true);
 }
 
 /*-------------------------------------------------------------------------*/
diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index 8feb60ff4228..aab042064226 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -72,6 +72,7 @@ static unsigned event_delays_ns[] = {
 	1 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_POLL_DEAD */
 	1125 * NSEC_PER_USEC,	/* EHCI_HRTIMER_UNLINK_INTR */
 	2 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_FREE_ITDS */
+	10 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_IAA_WATCHDOG */
 	10 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_DISABLE_PERIODIC */
 	15 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_DISABLE_ASYNC */
 };
@@ -291,6 +292,49 @@ static void end_free_itds(struct ehci_hcd *ehci)
 }
 
 
+/* Handle lost (or very late) IAA interrupts */
+static void ehci_iaa_watchdog(struct ehci_hcd *ehci)
+{
+	if (ehci-&gt;rh_state != EHCI_RH_RUNNING)
+		return;
+
+	/*
+	 * Lost IAA irqs wedge things badly; seen first with a vt8235.
+	 * So we need this watchdog, but must protect it against both
+	 * (a) SMP races against real IAA firing and retriggering, and
+	 * (b) clean HC shutdown, when IAA watchdog was pending.
+	 */
+	if (ehci-&gt;async_unlink) {
+		u32 cmd, status;
+
+		/* If we get here, IAA is *REALLY* late.  It's barely
+		 * conceivable that the system is so busy that CMD_IAAD
+		 * is still legitimately set, so let's be sure it's
+		 * clear before we read STS_IAA.  (The HC should clear
+		 * CMD_IAAD when it sets STS_IAA.)
+		 */
+		cmd = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
+
+		/*
+		 * If IAA is set here it either legitimately triggered
+		 * after the watchdog timer expired (_way_ late, so we'll
+		 * still count it as lost) ... or a silicon erratum:
+		 * - VIA seems to set IAA without triggering the IRQ;
+		 * - IAAD potentially cleared without setting IAA.
+		 */
+		status = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;status);
+		if ((status &amp; STS_IAA) || !(cmd &amp; CMD_IAAD)) {
+			COUNT(ehci-&gt;stats.lost_iaa);
+			ehci_writel(ehci, STS_IAA, &amp;ehci-&gt;regs-&gt;status);
+		}
+
+		ehci_vdbg(ehci, "IAA watchdog: status %x cmd %x\n",
+				status, cmd);
+		end_unlink_async(ehci);
+	}
+}
+
+
 /*
  * Handler functions for the hrtimer event types.
  * Keep this array in the same order as the event types indexed by
@@ -302,6 +346,7 @@ static void (*event_handlers[])(struct ehci_hcd *) = {
 	ehci_handle_controller_death,	/* EHCI_HRTIMER_POLL_DEAD */
 	ehci_handle_intr_unlinks,	/* EHCI_HRTIMER_UNLINK_INTR */
 	end_free_itds,			/* EHCI_HRTIMER_FREE_ITDS */
+	ehci_iaa_watchdog,		/* EHCI_HRTIMER_IAA_WATCHDOG */
 	ehci_disable_PSE,		/* EHCI_HRTIMER_DISABLE_PERIODIC */
 	ehci_disable_ASE,		/* EHCI_HRTIMER_DISABLE_ASYNC */
 };
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 755e30b0000b..d9414aae610f 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -84,6 +84,7 @@ enum ehci_hrtimer_event {
 	EHCI_HRTIMER_POLL_DEAD,		/* Wait for dead controller to stop */
 	EHCI_HRTIMER_UNLINK_INTR,	/* Wait for interrupt QH unlink */
 	EHCI_HRTIMER_FREE_ITDS,		/* Wait for unused iTDs and siTDs */
+	EHCI_HRTIMER_IAA_WATCHDOG,	/* Handle lost IAA interrupts */
 	EHCI_HRTIMER_DISABLE_PERIODIC,	/* Wait to disable periodic sched */
 	EHCI_HRTIMER_DISABLE_ASYNC,	/* Wait to disable async sched */
 	EHCI_HRTIMER_NUM_EVENTS		/* Must come last */
@@ -168,7 +169,6 @@ struct ehci_hcd {			/* one per controller */
 	struct dma_pool		*itd_pool;	/* itd per iso urb */
 	struct dma_pool		*sitd_pool;	/* sitd per split iso urb */
 
-	struct timer_list	iaa_watchdog;
 	struct timer_list	watchdog;
 	unsigned long		actions;
 	unsigned		periodic_stamp;
@@ -228,20 +228,6 @@ static inline struct usb_hcd *ehci_to_hcd (struct ehci_hcd *ehci)
 	return container_of ((void *) ehci, struct usb_hcd, hcd_priv);
 }
 
-
-static inline void
-iaa_watchdog_start(struct ehci_hcd *ehci)
-{
-	WARN_ON(timer_pending(&amp;ehci-&gt;iaa_watchdog));
-	mod_timer(&amp;ehci-&gt;iaa_watchdog,
-			jiffies + msecs_to_jiffies(EHCI_IAA_MSECS));
-}
-
-static inline void iaa_watchdog_done(struct ehci_hcd *ehci)
-{
-	del_timer(&amp;ehci-&gt;iaa_watchdog);
-}
-
 enum ehci_timer_action {
 	TIMER_IO_WATCHDOG,
 	TIMER_ASYNC_SHRINK,</pre><hr><pre>commit 8c5bf7be56f1a8aecc1f802f132d53f556a9bc45
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 11 11:22:39 2012 -0400

    USB: EHCI: don't refcount iso_stream structures
    
    This patch (as1580) makes ehci_iso_stream structures behave more like
    QHs, in that they will remain allocated until their isochronous
    endpoint is disabled.  This will come in useful in the future, when
    periodic bandwidth gets allocated as an altsetting is installed rather
    than on-the-fly.
    
    For now, the change to the ehci_iso_stream lifetimes means that each
    structure is always deallocated at exactly one spot in
    ehci_endpoint_disable() and never used again.  As a result, it is no
    longer necessary to use reference counting on these things, and the
    patch removes it.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 98b945840c9e..fb1966cf5649 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1085,8 +1085,14 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 	 * accelerate iso completions ... so spin a while.
 	 */
 	if (qh-&gt;hw == NULL) {
-		ehci_vdbg (ehci, "iso delay\n");
-		goto idle_timeout;
+		struct ehci_iso_stream	*stream = ep-&gt;hcpriv;
+
+		if (!list_empty(&amp;stream-&gt;td_list))
+			goto idle_timeout;
+
+		/* BUG_ON(!list_empty(&amp;stream-&gt;free_list)); */
+		kfree(stream);
+		goto done;
 	}
 
 	if (ehci-&gt;rh_state &lt; EHCI_RH_RUNNING)
@@ -1127,8 +1133,8 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 			list_empty (&amp;qh-&gt;qtd_list) ? "" : "(has tds)");
 		break;
 	}
+ done:
 	ep-&gt;hcpriv = NULL;
-done:
 	spin_unlock_irqrestore (&amp;ehci-&gt;lock, flags);
 }
 
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 1e4f13c11b6a..11b2f21d7ac1 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -934,7 +934,6 @@ iso_stream_alloc (gfp_t mem_flags)
 		INIT_LIST_HEAD(&amp;stream-&gt;td_list);
 		INIT_LIST_HEAD(&amp;stream-&gt;free_list);
 		stream-&gt;next_uframe = -1;
-		stream-&gt;refcount = 1;
 	}
 	return stream;
 }
@@ -1034,32 +1033,6 @@ iso_stream_init (
 	stream-&gt;maxp = maxp;
 }
 
-static void
-iso_stream_put(struct ehci_hcd *ehci, struct ehci_iso_stream *stream)
-{
-	stream-&gt;refcount--;
-
-	/* free whenever just a dev-&gt;ep reference remains.
-	 * not like a QH -- no persistent state (toggle, halt)
-	 */
-	if (stream-&gt;refcount == 1) {
-		// BUG_ON (!list_empty(&amp;stream-&gt;td_list));
-
-		if (stream-&gt;ep)
-			stream-&gt;ep-&gt;hcpriv = NULL;
-
-		kfree(stream);
-	}
-}
-
-static inline struct ehci_iso_stream *
-iso_stream_get (struct ehci_iso_stream *stream)
-{
-	if (likely (stream != NULL))
-		stream-&gt;refcount++;
-	return stream;
-}
-
 static struct ehci_iso_stream *
 iso_stream_find (struct ehci_hcd *ehci, struct urb *urb)
 {
@@ -1080,7 +1053,6 @@ iso_stream_find (struct ehci_hcd *ehci, struct urb *urb)
 	if (unlikely (stream == NULL)) {
 		stream = iso_stream_alloc(GFP_ATOMIC);
 		if (likely (stream != NULL)) {
-			/* dev-&gt;ep owns the initial refcount */
 			ep-&gt;hcpriv = stream;
 			stream-&gt;ep = ep;
 			iso_stream_init(ehci, stream, urb-&gt;dev, urb-&gt;pipe,
@@ -1095,9 +1067,6 @@ iso_stream_find (struct ehci_hcd *ehci, struct urb *urb)
 		stream = NULL;
 	}
 
-	/* caller guarantees an eventual matching iso_stream_put */
-	stream = iso_stream_get (stream);
-
 	spin_unlock_irqrestore (&amp;ehci-&gt;lock, flags);
 	return stream;
 }
@@ -1611,7 +1580,7 @@ static void itd_link_urb(
 			itd = list_entry (iso_sched-&gt;td_list.next,
 					struct ehci_itd, itd_list);
 			list_move_tail (&amp;itd-&gt;itd_list, &amp;stream-&gt;td_list);
-			itd-&gt;stream = iso_stream_get (stream);
+			itd-&gt;stream = stream;
 			itd-&gt;urb = urb;
 			itd_init (ehci, stream, itd);
 		}
@@ -1735,7 +1704,6 @@ itd_complete (
 			dev-&gt;devpath, stream-&gt;bEndpointAddress &amp; 0x0f,
 			(stream-&gt;bEndpointAddress &amp; USB_DIR_IN) ? "in" : "out");
 	}
-	iso_stream_put (ehci, stream);
 
 done:
 	itd-&gt;urb = NULL;
@@ -1750,7 +1718,6 @@ itd_complete (
 		start_free_itds(ehci);
 	}
 
-	iso_stream_put(ehci, stream);
 	return retval;
 }
 
@@ -1807,12 +1774,9 @@ static int itd_submit (struct ehci_hcd *ehci, struct urb *urb,
 		itd_link_urb (ehci, urb, ehci-&gt;periodic_size &lt;&lt; 3, stream);
 	else
 		usb_hcd_unlink_urb_from_ep(ehci_to_hcd(ehci), urb);
-done_not_linked:
+ done_not_linked:
 	spin_unlock_irqrestore (&amp;ehci-&gt;lock, flags);
-
-done:
-	if (unlikely (status &lt; 0))
-		iso_stream_put (ehci, stream);
+ done:
 	return status;
 }
 
@@ -2028,7 +1992,7 @@ static void sitd_link_urb(
 		sitd = list_entry (sched-&gt;td_list.next,
 				struct ehci_sitd, sitd_list);
 		list_move_tail (&amp;sitd-&gt;sitd_list, &amp;stream-&gt;td_list);
-		sitd-&gt;stream = iso_stream_get (stream);
+		sitd-&gt;stream = stream;
 		sitd-&gt;urb = urb;
 
 		sitd_patch(ehci, stream, sitd, sched, packet);
@@ -2126,7 +2090,6 @@ sitd_complete (
 			dev-&gt;devpath, stream-&gt;bEndpointAddress &amp; 0x0f,
 			(stream-&gt;bEndpointAddress &amp; USB_DIR_IN) ? "in" : "out");
 	}
-	iso_stream_put (ehci, stream);
 
 done:
 	sitd-&gt;urb = NULL;
@@ -2141,7 +2104,6 @@ sitd_complete (
 		start_free_itds(ehci);
 	}
 
-	iso_stream_put(ehci, stream);
 	return retval;
 }
 
@@ -2195,12 +2157,9 @@ static int sitd_submit (struct ehci_hcd *ehci, struct urb *urb,
 		sitd_link_urb (ehci, urb, ehci-&gt;periodic_size &lt;&lt; 3, stream);
 	else
 		usb_hcd_unlink_urb_from_ep(ehci_to_hcd(ehci), urb);
-done_not_linked:
+ done_not_linked:
 	spin_unlock_irqrestore (&amp;ehci-&gt;lock, flags);
-
-done:
-	if (status &lt; 0)
-		iso_stream_put (ehci, stream);
+ done:
 	return status;
 }
 
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index bcfbb175e2b4..755e30b0000b 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -386,7 +386,7 @@ struct ehci_qh_hw {
 } __attribute__ ((aligned(32)));
 
 struct ehci_qh {
-	struct ehci_qh_hw	*hw;
+	struct ehci_qh_hw	*hw;		/* Must come first */
 	/* the rest is HCD-private */
 	dma_addr_t		qh_dma;		/* address of qh */
 	union ehci_shadow	qh_next;	/* ptr to qh; or periodic */
@@ -453,7 +453,6 @@ struct ehci_iso_stream {
 	/* first field matches ehci_hq, but is NULL */
 	struct ehci_qh_hw	*hw;
 
-	u32			refcount;
 	u8			bEndpointAddress;
 	u8			highspeed;
 	struct list_head	td_list;	/* queued itds/sitds */</pre>
    <div class="pagination">
        <a href='2_44.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><span>[45]</span><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_46.html'>Next&gt;&gt;</a>
    <div>
</body>
