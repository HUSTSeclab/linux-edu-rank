<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Zhejiang University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Zhejiang University</h1>
    <div class="pagination">
        <a href='6_11.html'>&lt;&lt;Prev</a><a href='6.html'>1</a><a href='6_2.html'>2</a><a href='6_3.html'>3</a><a href='6_4.html'>4</a><a href='6_5.html'>5</a><a href='6_6.html'>6</a><a href='6_7.html'>7</a><a href='6_8.html'>8</a><a href='6_9.html'>9</a><a href='6_10.html'>10</a><a href='6_11.html'>11</a><span>[12]</span><a href='6_13.html'>13</a><a href='6_14.html'>14</a><a href='6_15.html'>15</a><a href='6_16.html'>16</a><a href='6_17.html'>17</a><a href='6_18.html'>18</a><a href='6_19.html'>19</a><a href='6_20.html'>20</a><a href='6_21.html'>21</a><a href='6_22.html'>22</a><a href='6_23.html'>23</a><a href='6_24.html'>24</a><a href='6_25.html'>25</a><a href='6_26.html'>26</a><a href='6_27.html'>27</a><a href='6_28.html'>28</a><a href='6_29.html'>29</a><a href='6_30.html'>30</a><a href='6_31.html'>31</a><a href='6_32.html'>32</a><a href='6_33.html'>33</a><a href='6_34.html'>34</a><a href='6_13.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit f69b5e8f356e4e57e94b806ca1dcb9771933bb9c
Author: Jinlong Chen &lt;nickyc975@zju.edu.cn&gt;
Date:   Tue Nov 22 22:21:25 2022 +0800

    elevator: update the document of elevator_match
    
    elevator_match does not care about elevator_features any more. Remove
    related descriptions from its document.
    
    Fixes: ffb86425ee2c ("block: don't check for required features in elevator_match")
    Signed-off-by: Jinlong Chen &lt;nickyc975@zju.edu.cn&gt;
    Reviewed-by: Christoph Hellwig &lt;hch@lst.de&gt;
    Link: https://lore.kernel.org/r/a58424555202c07a9ccf7f60c3ad7e247da09e25.1669126766.git.nickyc975@zju.edu.cn
    Signed-off-by: Jens Axboe &lt;axboe@kernel.dk&gt;

diff --git a/block/elevator.c b/block/elevator.c
index 1fa45717b1d6..5287b39cd7a9 100644
--- a/block/elevator.c
+++ b/block/elevator.c
@@ -91,12 +91,11 @@ static inline bool elv_support_features(struct request_queue *q,
 }
 
 /**
- * elevator_match - Test an elevator name and features
+ * elevator_match - Check whether @e's name or alias matches @name
  * @e: Scheduler to test
  * @name: Elevator name to test
  *
- * Return true if the elevator @e name matches @name and if @e provides all
- * the features specified by @required_features.
+ * Return true if the elevator @e's name or alias matches @name.
  */
 static bool elevator_match(const struct elevator_type *e, const char *name)
 {</pre><hr><pre>commit e0cca8bc9cd8d6176921cb3f5f466d3ccfbc6b99
Author: Jinlong Chen &lt;nickyc975@zju.edu.cn&gt;
Date:   Tue Nov 22 22:21:24 2022 +0800

    elevator: printk a warning if switching to a new io scheduler fails
    
    printk a warning to indicate that the io scheduler has been set to none
    if switching to a new io scheduler fails.
    
    Suggested-by: Christoph Hellwig &lt;hch@lst.de&gt;
    Signed-off-by: Jinlong Chen &lt;nickyc975@zju.edu.cn&gt;
    Reviewed-by: Christoph Hellwig &lt;hch@lst.de&gt;
    Link: https://lore.kernel.org/r/d51ed0fb457db7a4f9cbb0dbce36d534e22be457.1669126766.git.nickyc975@zju.edu.cn
    Signed-off-by: Jens Axboe &lt;axboe@kernel.dk&gt;

diff --git a/block/elevator.c b/block/elevator.c
index 01aa9f38f22e..1fa45717b1d6 100644
--- a/block/elevator.c
+++ b/block/elevator.c
@@ -683,6 +683,12 @@ int elevator_switch(struct request_queue *q, struct elevator_type *new_e)
 out_unfreeze:
 	blk_mq_unquiesce_queue(q);
 	blk_mq_unfreeze_queue(q);
+
+	if (ret) {
+		pr_warn("elv: switch to \"%s\" failed, falling back to \"none\"\n",
+			new_e-&gt;elevator_name);
+	}
+
 	return ret;
 }
 </pre><hr><pre>commit ac1171bd2c7a3a32dfbdd3c347919fee32b745a1
Author: Jinlong Chen &lt;nickyc975@zju.edu.cn&gt;
Date:   Tue Nov 22 22:21:23 2022 +0800

    elevator: update the document of elevator_switch
    
    We no longer support falling back to the old io scheduler if switching to
    the new one fails. Update the document to indicate that.
    
    Fixes: a1ce35fa4985 ("block: remove dead elevator code")
    Signed-off-by: Jinlong Chen &lt;nickyc975@zju.edu.cn&gt;
    Reviewed-by: Christoph Hellwig &lt;hch@lst.de&gt;
    Link: https://lore.kernel.org/r/94250961689ba7d2e67a7d9e7995a11166fedb31.1669126766.git.nickyc975@zju.edu.cn
    Signed-off-by: Jens Axboe &lt;axboe@kernel.dk&gt;

diff --git a/block/elevator.c b/block/elevator.c
index a5bdc3b1e7e5..01aa9f38f22e 100644
--- a/block/elevator.c
+++ b/block/elevator.c
@@ -650,10 +650,10 @@ void elevator_init_mq(struct request_queue *q)
 }
 
 /*
- * switch to new_e io scheduler. be careful not to introduce deadlocks -
- * we don't free the old io scheduler, before we have allocated what we
- * need for the new one. this way we have a chance of going back to the old
- * one, if the new one fails init for some reason.
+ * Switch to new_e io scheduler.
+ *
+ * If switching fails, we are most likely running out of memory and not able
+ * to restore the old io scheduler, so leaving the io scheduler being none.
  */
 int elevator_switch(struct request_queue *q, struct elevator_type *new_e)
 {</pre><hr><pre>commit 23a6c9ac4dbd7cccf5b909e78aa84192b65f2833
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Thu Nov 10 20:21:03 2022 +0800

    io_uring: update outdated comment of callbacks
    
    Previous commit ebc11b6c6b87 ("io_uring: clean io-wq callbacks") rename
    io_free_work() into io_wq_free_work() for consistency. This patch also
    updates relevant comment to avoid misunderstanding.
    
    Fixes: ebc11b6c6b87 ("io_uring: clean io-wq callbacks")
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Link: https://lore.kernel.org/r/20221110122103.20120-1-linma@zju.edu.cn
    Signed-off-by: Jens Axboe &lt;axboe@kernel.dk&gt;

diff --git a/io_uring/io_uring.c b/io_uring/io_uring.c
index cf68d16255a0..c770eed4d717 100644
--- a/io_uring/io_uring.c
+++ b/io_uring/io_uring.c
@@ -1781,7 +1781,7 @@ void io_wq_submit_work(struct io_wq_work *work)
 	bool needs_poll = false;
 	int ret = 0, err = -ECANCELED;
 
-	/* one will be dropped by -&gt;io_free_work() after returning to io-wq */
+	/* one will be dropped by -&gt;io_wq_free_work() after returning to io-wq */
 	if (!(req-&gt;flags &amp; REQ_F_REFCOUNT))
 		__io_req_set_refcount(req, 2);
 	else</pre><hr><pre>commit cd42a53d25d489317b9ae5213da721cde8cb7071
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Thu Nov 10 14:03:13 2022 +0800

    io_uring/poll: remove outdated comments of caching
    
    Previous commit 13a99017ff19 ("io_uring: remove events caching
    atavisms") entirely removes the events caching optimization introduced
    by commit 81459350d581 ("io_uring: cache req-&gt;apoll-&gt;events in
    req-&gt;cflags"). Hence the related comment should also be removed to avoid
    misunderstanding.
    
    Fixes: 13a99017ff19 ("io_uring: remove events caching atavisms")
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Link: https://lore.kernel.org/r/20221110060313.16303-1-linma@zju.edu.cn
    Signed-off-by: Jens Axboe &lt;axboe@kernel.dk&gt;

diff --git a/io_uring/poll.c b/io_uring/poll.c
index 58e02d963961..8fb8e781c02d 100644
--- a/io_uring/poll.c
+++ b/io_uring/poll.c
@@ -324,12 +324,7 @@ static void io_apoll_task_func(struct io_kiocb *req, bool *locked)
 static void __io_poll_execute(struct io_kiocb *req, int mask)
 {
 	io_req_set_res(req, mask, 0);
-	/*
-	 * This is useful for poll that is armed on behalf of another
-	 * request, and where the wakeup path could be on a different
-	 * CPU. We want to avoid pulling in req-&gt;apoll-&gt;events for that
-	 * case.
-	 */
+
 	if (req-&gt;opcode == IORING_OP_POLL_ADD)
 		req-&gt;io_task_work.func = io_poll_task_func;
 	else</pre><hr><pre>commit 0ad6bded175e829c2ca261529c9dce39a32a042d
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Wed Nov 16 21:02:49 2022 +0800

    nfc/nci: fix race with opening and closing
    
    Previously we leverage NCI_UNREG and the lock inside nci_close_device to
    prevent the race condition between opening a device and closing a
    device. However, it still has problem because a failed opening command
    will erase the NCI_UNREG flag and allow another opening command to
    bypass the status checking.
    
    This fix corrects that by making sure the NCI_UNREG is held.
    
    Reported-by: syzbot+43475bf3cfbd6e41f5b7@syzkaller.appspotmail.com
    Fixes: 48b71a9e66c2 ("NFC: add NCI_UNREG flag to eliminate the race")
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/net/nfc/nci/core.c b/net/nfc/nci/core.c
index 6a193cce2a75..4ffdf2f45c44 100644
--- a/net/nfc/nci/core.c
+++ b/net/nfc/nci/core.c
@@ -542,7 +542,7 @@ static int nci_open_device(struct nci_dev *ndev)
 		skb_queue_purge(&amp;ndev-&gt;tx_q);
 
 		ndev-&gt;ops-&gt;close(ndev);
-		ndev-&gt;flags = 0;
+		ndev-&gt;flags &amp;= BIT(NCI_UNREG);
 	}
 
 done:</pre><hr><pre>commit ce8cc75c7419ad54cb99437543a54c97c7446db5
Author: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
Date:   Tue Oct 18 16:34:24 2022 +0800

    drivers: staging: r8188eu: Fix sleep-in-atomic-context bug in rtw_join_timeout_handler
    
    The rtw_join_timeout_handler() is a timer handler that
    runs in atomic context, but it could call msleep().
    As a result, the sleep-in-atomic-context bug will happen.
    The process is shown below:
    
         (atomic context)
    rtw_join_timeout_handler
     _rtw_join_timeout_handler
      rtw_do_join
       rtw_select_and_join_from_scanned_queue
        rtw_indicate_disconnect
         rtw_lps_ctrl_wk_cmd
          lps_ctrl_wk_hdl
           LPS_Leave
            LPS_RF_ON_check
             msleep //sleep in atomic context
    
    Fix by removing msleep() and replacing with mdelay().
    
    Fixes: 15865124feed ("staging: r8188eu: introduce new core dir for RTL8188eu driver")
    Signed-off-by: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
    Link: https://lore.kernel.org/r/20221018083424.79741-1-duoming@zju.edu.cn
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/r8188eu/core/rtw_pwrctrl.c b/drivers/staging/r8188eu/core/rtw_pwrctrl.c
index 870d81735b8d..5290ac36f08c 100644
--- a/drivers/staging/r8188eu/core/rtw_pwrctrl.c
+++ b/drivers/staging/r8188eu/core/rtw_pwrctrl.c
@@ -273,7 +273,7 @@ static s32 LPS_RF_ON_check(struct adapter *padapter, u32 delay_ms)
 			err = -1;
 			break;
 		}
-		msleep(1);
+		mdelay(1);
 	}
 
 	return err;</pre><hr><pre>commit 7a58b8d6021426b796eebfae80983374d9a80a75
Author: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
Date:   Sun Sep 18 11:33:12 2022 +0800

    usb: chipidea: fix deadlock in ci_otg_del_timer
    
    There is a deadlock in ci_otg_del_timer(), the process is
    shown below:
    
        (thread 1)                  |        (thread 2)
    ci_otg_del_timer()              | ci_otg_hrtimer_func()
      ...                           |
      spin_lock_irqsave() //(1)     |  ...
      ...                           |
      hrtimer_cancel()              |  spin_lock_irqsave() //(2)
      (block forever)
    
    We hold ci-&gt;lock in position (1) and use hrtimer_cancel() to
    wait ci_otg_hrtimer_func() to stop, but ci_otg_hrtimer_func()
    also need ci-&gt;lock in position (2). As a result, the
    hrtimer_cancel() in ci_otg_del_timer() will be blocked forever.
    
    This patch extracts hrtimer_cancel() from the protection of
    spin_lock_irqsave() in order that the ci_otg_hrtimer_func()
    could obtain the ci-&gt;lock.
    
    What`s more, there will be no race happen. Because the
    "next_timer" is always under the protection of
    spin_lock_irqsave() and we only check whether "next_timer"
    equals to NUM_OTG_FSM_TIMERS in the following code.
    
    Fixes: 3a316ec4c91c ("usb: chipidea: use hrtimer for otg fsm timers")
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
    Link: https://lore.kernel.org/r/20220918033312.94348-1-duoming@zju.edu.cn
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/chipidea/otg_fsm.c b/drivers/usb/chipidea/otg_fsm.c
index ada78daba6df..c17516c29b63 100644
--- a/drivers/usb/chipidea/otg_fsm.c
+++ b/drivers/usb/chipidea/otg_fsm.c
@@ -256,8 +256,10 @@ static void ci_otg_del_timer(struct ci_hdrc *ci, enum otg_fsm_timer t)
 	ci-&gt;enabled_otg_timer_bits &amp;= ~(1 &lt;&lt; t);
 	if (ci-&gt;next_otg_timer == t) {
 		if (ci-&gt;enabled_otg_timer_bits == 0) {
+			spin_unlock_irqrestore(&amp;ci-&gt;lock, flags);
 			/* No enabled timers after delete it */
 			hrtimer_cancel(&amp;ci-&gt;otg_fsm_hrtimer);
+			spin_lock_irqsave(&amp;ci-&gt;lock, flags);
 			ci-&gt;next_otg_timer = NUM_OTG_FSM_TIMERS;
 		} else {
 			/* Find the next timer */</pre><hr><pre>commit 7b7dfe4833c70a11cdfa51b38705103bd31eddaa
Author: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
Date:   Sun Oct 2 12:07:09 2022 +0800

    tty: n_gsm: fix sleep-in-atomic-context bug in gsm_control_send
    
    The function gsm_dlci_t1() is a timer handler that runs in an
    atomic context, but it calls "kzalloc(..., GFP_KERNEL)" that
    may sleep. As a result, the sleep-in-atomic-context bug will
    happen. The process is shown below:
    
    gsm_dlci_t1()
     gsm_dlci_open()
      gsm_modem_update()
       gsm_modem_upd_via_msc()
        gsm_control_send()
         kzalloc(sizeof(.., GFP_KERNEL) //may sleep
    
    This patch changes the gfp_t parameter of kzalloc() from GFP_KERNEL to
    GFP_ATOMIC in order to mitigate the bug.
    
    Fixes: e1eaea46bb40 ("tty: n_gsm line discipline")
    Signed-off-by: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
    Link: https://lore.kernel.org/r/20221002040709.27849-1-duoming@zju.edu.cn
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/tty/n_gsm.c b/drivers/tty/n_gsm.c
index 5c9f76073fcd..b6e0cc4571ea 100644
--- a/drivers/tty/n_gsm.c
+++ b/drivers/tty/n_gsm.c
@@ -1711,7 +1711,7 @@ static struct gsm_control *gsm_control_send(struct gsm_mux *gsm,
 		unsigned int command, u8 *data, int clen)
 {
 	struct gsm_control *ctrl = kzalloc(sizeof(struct gsm_control),
-						GFP_KERNEL);
+						GFP_ATOMIC);
 	unsigned long flags;
 	if (ctrl == NULL)
 		return NULL;</pre><hr><pre>commit 4046728253751adb41b05e85ebd686210efde1ad
Author: Jinlong Chen &lt;nickyc975@zju.edu.cn&gt;
Date:   Wed Nov 2 10:52:30 2022 +0800

    blk-mq: use if-else instead of goto in blk_mq_alloc_cached_request()
    
    if-else is more readable than goto here.
    
    Signed-off-by: Jinlong Chen &lt;nickyc975@zju.edu.cn&gt;
    Link: https://lore.kernel.org/r/d3306fa4e92dc9cc614edc8f1802686096bafef2.1667356813.git.nickyc975@zju.edu.cn
    Signed-off-by: Jens Axboe &lt;axboe@kernel.dk&gt;

diff --git a/block/blk-mq.c b/block/blk-mq.c
index d4824b53f6b2..fc9c400adf92 100644
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@ -575,25 +575,26 @@ static struct request *blk_mq_alloc_cached_request(struct request_queue *q,
 
 	if (!plug)
 		return NULL;
+
 	if (rq_list_empty(plug-&gt;cached_rq)) {
 		if (plug-&gt;nr_ios == 1)
 			return NULL;
 		rq = blk_mq_rq_cache_fill(q, plug, opf, flags);
-		if (rq)
-			goto got_it;
-		return NULL;
-	}
-	rq = rq_list_peek(&amp;plug-&gt;cached_rq);
-	if (!rq || rq-&gt;q != q)
-		return NULL;
+		if (!rq)
+			return NULL;
+	} else {
+		rq = rq_list_peek(&amp;plug-&gt;cached_rq);
+		if (!rq || rq-&gt;q != q)
+			return NULL;
 
-	if (blk_mq_get_hctx_type(opf) != rq-&gt;mq_hctx-&gt;type)
-		return NULL;
-	if (op_is_flush(rq-&gt;cmd_flags) != op_is_flush(opf))
-		return NULL;
+		if (blk_mq_get_hctx_type(opf) != rq-&gt;mq_hctx-&gt;type)
+			return NULL;
+		if (op_is_flush(rq-&gt;cmd_flags) != op_is_flush(opf))
+			return NULL;
+
+		plug-&gt;cached_rq = rq_list_next(rq);
+	}
 
-	plug-&gt;cached_rq = rq_list_next(rq);
-got_it:
 	rq-&gt;cmd_flags = opf;
 	INIT_LIST_HEAD(&amp;rq-&gt;queuelist);
 	return rq;</pre>
    <div class="pagination">
        <a href='6_11.html'>&lt;&lt;Prev</a><a href='6.html'>1</a><a href='6_2.html'>2</a><a href='6_3.html'>3</a><a href='6_4.html'>4</a><a href='6_5.html'>5</a><a href='6_6.html'>6</a><a href='6_7.html'>7</a><a href='6_8.html'>8</a><a href='6_9.html'>9</a><a href='6_10.html'>10</a><a href='6_11.html'>11</a><span>[12]</span><a href='6_13.html'>13</a><a href='6_14.html'>14</a><a href='6_15.html'>15</a><a href='6_16.html'>16</a><a href='6_17.html'>17</a><a href='6_18.html'>18</a><a href='6_19.html'>19</a><a href='6_20.html'>20</a><a href='6_21.html'>21</a><a href='6_22.html'>22</a><a href='6_23.html'>23</a><a href='6_24.html'>24</a><a href='6_25.html'>25</a><a href='6_26.html'>26</a><a href='6_27.html'>27</a><a href='6_28.html'>28</a><a href='6_29.html'>29</a><a href='6_30.html'>30</a><a href='6_31.html'>31</a><a href='6_32.html'>32</a><a href='6_33.html'>33</a><a href='6_34.html'>34</a><a href='6_13.html'>Next&gt;&gt;</a>
    <div>
</body>
