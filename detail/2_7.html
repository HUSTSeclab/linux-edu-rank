<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_6.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><span>[7]</span><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_8.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 87191ca9f90244d4e003fbe5c77390b5e585a5ef
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu May 20 16:22:06 2021 -0400

    USB: UDC: Implement udc_async_callbacks in net2272
    
    This patch adds a udc_async_callbacks handler to the net2272 UDC
    driver, which will prevent a theoretical race during gadget unbinding.
    
    The net2272 driver is sufficiently complicated that I didn't want to
    mess around with IRQ settings.  Instead, the patch simply adds a new
    flag to control async callbacks, and checks the flag before issuing
    any of them.
    
    Acked-by: Felipe Balbi &lt;balbi@kernel.org&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/20210520202206.GF1216852@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/gadget/udc/net2272.c b/drivers/usb/gadget/udc/net2272.c
index 89f479b78d80..7c38057dcb4a 100644
--- a/drivers/usb/gadget/udc/net2272.c
+++ b/drivers/usb/gadget/udc/net2272.c
@@ -1150,6 +1150,7 @@ net2272_pullup(struct usb_gadget *_gadget, int is_on)
 static int net2272_start(struct usb_gadget *_gadget,
 		struct usb_gadget_driver *driver);
 static int net2272_stop(struct usb_gadget *_gadget);
+static void net2272_async_callbacks(struct usb_gadget *_gadget, bool enable);
 
 static const struct usb_gadget_ops net2272_ops = {
 	.get_frame	= net2272_get_frame,
@@ -1158,6 +1159,7 @@ static const struct usb_gadget_ops net2272_ops = {
 	.pullup		= net2272_pullup,
 	.udc_start	= net2272_start,
 	.udc_stop	= net2272_stop,
+	.udc_async_callbacks = net2272_async_callbacks,
 };
 
 /*---------------------------------------------------------------------------*/
@@ -1476,7 +1478,7 @@ stop_activity(struct net2272 *dev, struct usb_gadget_driver *driver)
 		net2272_dequeue_all(&amp;dev-&gt;ep[i]);
 
 	/* report disconnect; the driver is already quiesced */
-	if (driver) {
+	if (dev-&gt;async_callbacks &amp;&amp; driver) {
 		spin_unlock(&amp;dev-&gt;lock);
 		driver-&gt;disconnect(&amp;dev-&gt;gadget);
 		spin_lock(&amp;dev-&gt;lock);
@@ -1501,6 +1503,15 @@ static int net2272_stop(struct usb_gadget *_gadget)
 	return 0;
 }
 
+static void net2272_async_callbacks(struct usb_gadget *_gadget, bool enable)
+{
+	struct net2272	*dev = container_of(_gadget, struct net2272, gadget);
+
+	spin_lock_irq(&amp;dev-&gt;lock);
+	dev-&gt;async_callbacks = enable;
+	spin_unlock_irq(&amp;dev-&gt;lock);
+}
+
 /*---------------------------------------------------------------------------*/
 /* handle ep-a/ep-b dma completions */
 static void
@@ -1910,9 +1921,11 @@ net2272_handle_stat0_irqs(struct net2272 *dev, u8 stat)
 				u.r.bRequestType, u.r.bRequest,
 				u.r.wValue, u.r.wIndex,
 				net2272_ep_read(ep, EP_CFG));
-			spin_unlock(&amp;dev-&gt;lock);
-			tmp = dev-&gt;driver-&gt;setup(&amp;dev-&gt;gadget, &amp;u.r);
-			spin_lock(&amp;dev-&gt;lock);
+			if (dev-&gt;async_callbacks) {
+				spin_unlock(&amp;dev-&gt;lock);
+				tmp = dev-&gt;driver-&gt;setup(&amp;dev-&gt;gadget, &amp;u.r);
+				spin_lock(&amp;dev-&gt;lock);
+			}
 		}
 
 		/* stall ep0 on error */
@@ -1994,14 +2007,14 @@ net2272_handle_stat1_irqs(struct net2272 *dev, u8 stat)
 			if (disconnect || reset) {
 				stop_activity(dev, dev-&gt;driver);
 				net2272_ep0_start(dev);
-				spin_unlock(&amp;dev-&gt;lock);
-				if (reset)
-					usb_gadget_udc_reset
-						(&amp;dev-&gt;gadget, dev-&gt;driver);
-				else
-					(dev-&gt;driver-&gt;disconnect)
-						(&amp;dev-&gt;gadget);
-				spin_lock(&amp;dev-&gt;lock);
+				if (dev-&gt;async_callbacks) {
+					spin_unlock(&amp;dev-&gt;lock);
+					if (reset)
+						usb_gadget_udc_reset(&amp;dev-&gt;gadget, dev-&gt;driver);
+					else
+						(dev-&gt;driver-&gt;disconnect)(&amp;dev-&gt;gadget);
+					spin_lock(&amp;dev-&gt;lock);
+				}
 				return;
 			}
 		}
@@ -2015,14 +2028,14 @@ net2272_handle_stat1_irqs(struct net2272 *dev, u8 stat)
 	if (stat &amp; tmp) {
 		net2272_write(dev, IRQSTAT1, tmp);
 		if (stat &amp; (1 &lt;&lt; SUSPEND_REQUEST_INTERRUPT)) {
-			if (dev-&gt;driver-&gt;suspend)
+			if (dev-&gt;async_callbacks &amp;&amp; dev-&gt;driver-&gt;suspend)
 				dev-&gt;driver-&gt;suspend(&amp;dev-&gt;gadget);
 			if (!enable_suspend) {
 				stat &amp;= ~(1 &lt;&lt; SUSPEND_REQUEST_INTERRUPT);
 				dev_dbg(dev-&gt;dev, "Suspend disabled, ignoring\n");
 			}
 		} else {
-			if (dev-&gt;driver-&gt;resume)
+			if (dev-&gt;async_callbacks &amp;&amp; dev-&gt;driver-&gt;resume)
 				dev-&gt;driver-&gt;resume(&amp;dev-&gt;gadget);
 		}
 		stat &amp;= ~tmp;
diff --git a/drivers/usb/gadget/udc/net2272.h b/drivers/usb/gadget/udc/net2272.h
index c669308111c2..a9994f737588 100644
--- a/drivers/usb/gadget/udc/net2272.h
+++ b/drivers/usb/gadget/udc/net2272.h
@@ -442,6 +442,7 @@ struct net2272 {
 	         softconnect:1,
 	         wakeup:1,
 		 added:1,
+		 async_callbacks:1,
 	         dma_eot_polarity:1,
 	         dma_dack_polarity:1,
 	         dma_dreq_polarity:1,</pre><hr><pre>commit b42e8090ba93526d6063108b25e5fc0f11f58770
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu May 20 16:22:00 2021 -0400

    USB: UDC: Implement udc_async_callbacks in net2280
    
    This patch adds a udc_async_callbacks handler to the net2280 UDC
    driver, which will prevent a theoretical race during gadget unbinding.
    
    The net2280 driver is sufficiently complicated that I didn't want to
    mess around with IRQ settings.  Instead, the patch simply adds a new
    flag to control async callbacks, and checks the flag before issuing
    any of them.
    
    Acked-by: Felipe Balbi &lt;balbi@kernel.org&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/20210520202200.GE1216852@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/gadget/udc/net2280.c b/drivers/usb/gadget/udc/net2280.c
index fc9f99fe7f37..0e0458e3662b 100644
--- a/drivers/usb/gadget/udc/net2280.c
+++ b/drivers/usb/gadget/udc/net2280.c
@@ -1617,6 +1617,7 @@ static struct usb_ep *net2280_match_ep(struct usb_gadget *_gadget,
 static int net2280_start(struct usb_gadget *_gadget,
 		struct usb_gadget_driver *driver);
 static int net2280_stop(struct usb_gadget *_gadget);
+static void net2280_async_callbacks(struct usb_gadget *_gadget, bool enable);
 
 static const struct usb_gadget_ops net2280_ops = {
 	.get_frame	= net2280_get_frame,
@@ -1625,6 +1626,7 @@ static const struct usb_gadget_ops net2280_ops = {
 	.pullup		= net2280_pullup,
 	.udc_start	= net2280_start,
 	.udc_stop	= net2280_stop,
+	.udc_async_callbacks = net2280_async_callbacks,
 	.match_ep	= net2280_match_ep,
 };
 
@@ -2472,7 +2474,7 @@ static void stop_activity(struct net2280 *dev, struct usb_gadget_driver *driver)
 		nuke(&amp;dev-&gt;ep[i]);
 
 	/* report disconnect; the driver is already quiesced */
-	if (driver) {
+	if (dev-&gt;async_callbacks &amp;&amp; driver) {
 		spin_unlock(&amp;dev-&gt;lock);
 		driver-&gt;disconnect(&amp;dev-&gt;gadget);
 		spin_lock(&amp;dev-&gt;lock);
@@ -2502,6 +2504,15 @@ static int net2280_stop(struct usb_gadget *_gadget)
 	return 0;
 }
 
+static void net2280_async_callbacks(struct usb_gadget *_gadget, bool enable)
+{
+	struct net2280	*dev = container_of(_gadget, struct net2280, gadget);
+
+	spin_lock_irq(&amp;dev-&gt;lock);
+	dev-&gt;async_callbacks = enable;
+	spin_unlock_irq(&amp;dev-&gt;lock);
+}
+
 /*-------------------------------------------------------------------------*/
 
 /* handle ep0, ep-e, ep-f with 64 byte packets: packet per irq.
@@ -3042,9 +3053,11 @@ static void handle_stat0_irqs_superspeed(struct net2280 *dev,
 				readl(&amp;ep-&gt;cfg-&gt;ep_cfg));
 
 		ep-&gt;responded = 0;
-		spin_unlock(&amp;dev-&gt;lock);
-		tmp = dev-&gt;driver-&gt;setup(&amp;dev-&gt;gadget, &amp;r);
-		spin_lock(&amp;dev-&gt;lock);
+		if (dev-&gt;async_callbacks) {
+			spin_unlock(&amp;dev-&gt;lock);
+			tmp = dev-&gt;driver-&gt;setup(&amp;dev-&gt;gadget, &amp;r);
+			spin_lock(&amp;dev-&gt;lock);
+		}
 	}
 do_stall3:
 	if (tmp &lt; 0) {
@@ -3284,9 +3297,11 @@ static void handle_stat0_irqs(struct net2280 *dev, u32 stat)
 				w_value, w_index, w_length,
 				readl(&amp;ep-&gt;cfg-&gt;ep_cfg));
 			ep-&gt;responded = 0;
-			spin_unlock(&amp;dev-&gt;lock);
-			tmp = dev-&gt;driver-&gt;setup(&amp;dev-&gt;gadget, &amp;u.r);
-			spin_lock(&amp;dev-&gt;lock);
+			if (dev-&gt;async_callbacks) {
+				spin_unlock(&amp;dev-&gt;lock);
+				tmp = dev-&gt;driver-&gt;setup(&amp;dev-&gt;gadget, &amp;u.r);
+				spin_lock(&amp;dev-&gt;lock);
+			}
 		}
 
 		/* stall ep0 on error */
@@ -3391,14 +3406,14 @@ __acquires(dev-&gt;lock)
 			if (disconnect || reset) {
 				stop_activity(dev, dev-&gt;driver);
 				ep0_start(dev);
-				spin_unlock(&amp;dev-&gt;lock);
-				if (reset)
-					usb_gadget_udc_reset
-						(&amp;dev-&gt;gadget, dev-&gt;driver);
-				else
-					(dev-&gt;driver-&gt;disconnect)
-						(&amp;dev-&gt;gadget);
-				spin_lock(&amp;dev-&gt;lock);
+				if (dev-&gt;async_callbacks) {
+					spin_unlock(&amp;dev-&gt;lock);
+					if (reset)
+						usb_gadget_udc_reset(&amp;dev-&gt;gadget, dev-&gt;driver);
+					else
+						(dev-&gt;driver-&gt;disconnect)(&amp;dev-&gt;gadget);
+					spin_lock(&amp;dev-&gt;lock);
+				}
 				return;
 			}
 		}
@@ -3419,12 +3434,12 @@ __acquires(dev-&gt;lock)
 		writel(tmp, &amp;dev-&gt;regs-&gt;irqstat1);
 		spin_unlock(&amp;dev-&gt;lock);
 		if (stat &amp; BIT(SUSPEND_REQUEST_INTERRUPT)) {
-			if (dev-&gt;driver-&gt;suspend)
+			if (dev-&gt;async_callbacks &amp;&amp; dev-&gt;driver-&gt;suspend)
 				dev-&gt;driver-&gt;suspend(&amp;dev-&gt;gadget);
 			if (!enable_suspend)
 				stat &amp;= ~BIT(SUSPEND_REQUEST_INTERRUPT);
 		} else {
-			if (dev-&gt;driver-&gt;resume)
+			if (dev-&gt;async_callbacks &amp;&amp; dev-&gt;driver-&gt;resume)
 				dev-&gt;driver-&gt;resume(&amp;dev-&gt;gadget);
 			/* at high speed, note erratum 0133 */
 		}
diff --git a/drivers/usb/gadget/udc/net2280.h b/drivers/usb/gadget/udc/net2280.h
index 7da3dc1e9729..34716a9f4926 100644
--- a/drivers/usb/gadget/udc/net2280.h
+++ b/drivers/usb/gadget/udc/net2280.h
@@ -162,6 +162,7 @@ struct net2280 {
 					ltm_enable:1,
 					wakeup_enable:1,
 					addressed_state:1,
+					async_callbacks:1,
 					bug7734_patched:1;
 	u16				chiprev;
 	int enhanced_mode;</pre><hr><pre>commit 04145a03db9d78469e0817ab3a767c76c0fb0947
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu May 20 16:21:52 2021 -0400

    USB: UDC: Implement udc_async_callbacks in dummy-hcd
    
    This patch adds a udc_async_callbacks handler to the dummy-hcd UDC
    driver, which will prevent a theoretical race during gadget unbinding.
    
    The implementation is simple, since dummy-hcd already has a flag to
    keep track of whether emulated IRQs are enabled.  All the handler has
    to do is store the enable value in the flag, and avoid setting the
    flag prematurely.
    
    Acked-by: Felipe Balbi &lt;balbi@kernel.org&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/20210520202152.GD1216852@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/gadget/udc/dummy_hcd.c b/drivers/usb/gadget/udc/dummy_hcd.c
index 7db773c87379..a2d956af42a2 100644
--- a/drivers/usb/gadget/udc/dummy_hcd.c
+++ b/drivers/usb/gadget/udc/dummy_hcd.c
@@ -934,6 +934,15 @@ static void dummy_udc_set_speed(struct usb_gadget *_gadget,
 	dummy_udc_update_ep0(dum);
 }
 
+static void dummy_udc_async_callbacks(struct usb_gadget *_gadget, bool enable)
+{
+	struct dummy	*dum = gadget_dev_to_dummy(&amp;_gadget-&gt;dev);
+
+	spin_lock_irq(&amp;dum-&gt;lock);
+	dum-&gt;ints_enabled = enable;
+	spin_unlock_irq(&amp;dum-&gt;lock);
+}
+
 static int dummy_udc_start(struct usb_gadget *g,
 		struct usb_gadget_driver *driver);
 static int dummy_udc_stop(struct usb_gadget *g);
@@ -946,6 +955,7 @@ static const struct usb_gadget_ops dummy_ops = {
 	.udc_start	= dummy_udc_start,
 	.udc_stop	= dummy_udc_stop,
 	.udc_set_speed	= dummy_udc_set_speed,
+	.udc_async_callbacks = dummy_udc_async_callbacks,
 };
 
 /*-------------------------------------------------------------------------*/
@@ -1005,7 +1015,6 @@ static int dummy_udc_start(struct usb_gadget *g,
 	spin_lock_irq(&amp;dum-&gt;lock);
 	dum-&gt;devstatus = 0;
 	dum-&gt;driver = driver;
-	dum-&gt;ints_enabled = 1;
 	spin_unlock_irq(&amp;dum-&gt;lock);
 
 	return 0;</pre><hr><pre>commit 7dc0c55e9f302e7048e040ee4437437bbea1e2cd
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu May 20 16:21:44 2021 -0400

    USB: UDC core: Add udc_async_callbacks gadget op
    
    The Gadget API has a theoretical race when a gadget driver is unbound.
    Although the pull-up is turned off before the driver's -&gt;unbind
    callback runs, if the USB cable were to be unplugged at just the wrong
    moment there would be nothing to prevent the UDC driver from invoking
    the -&gt;disconnect callback after the unbind has finished.  In theory,
    other asynchronous callbacks could also happen during the time before
    the UDC driver's udc_stop routine is called, and the gadget driver
    would not be prepared to handle any of them.
    
    We need a way to tell UDC drivers to stop issuing asynchronous (that is,
    -&gt;suspend, -&gt;resume, -&gt;disconnect, -&gt;reset, or -&gt;setup) callbacks at
    some point after the pull-up has been turned off and before the
    -&gt;unbind callback runs.  This patch adds a new -&gt;udc_async_callbacks
    callback to the usb_gadget_ops structure for precisely this purpose,
    and it adds the corresponding support to the UDC core.
    
    Later patches in this series add support for udc_async_callbacks to
    several UDC drivers.
    
    Acked-by: Felipe Balbi &lt;balbi@kernel.org&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/20210520202144.GC1216852@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/gadget/udc/core.c b/drivers/usb/gadget/udc/core.c
index 493ff93f7dda..b7f0b1ebaaa8 100644
--- a/drivers/usb/gadget/udc/core.c
+++ b/drivers/usb/gadget/udc/core.c
@@ -1147,6 +1147,53 @@ static inline void usb_gadget_udc_set_speed(struct usb_udc *udc,
 		gadget-&gt;ops-&gt;udc_set_speed(gadget, s);
 }
 
+/**
+ * usb_gadget_enable_async_callbacks - tell usb device controller to enable asynchronous callbacks
+ * @udc: The UDC which should enable async callbacks
+ *
+ * This routine is used when binding gadget drivers.  It undoes the effect
+ * of usb_gadget_disable_async_callbacks(); the UDC driver should enable IRQs
+ * (if necessary) and resume issuing callbacks.
+ *
+ * This routine will always be called in process context.
+ */
+static inline void usb_gadget_enable_async_callbacks(struct usb_udc *udc)
+{
+	struct usb_gadget *gadget = udc-&gt;gadget;
+
+	if (gadget-&gt;ops-&gt;udc_async_callbacks)
+		gadget-&gt;ops-&gt;udc_async_callbacks(gadget, true);
+}
+
+/**
+ * usb_gadget_disable_async_callbacks - tell usb device controller to disable asynchronous callbacks
+ * @udc: The UDC which should disable async callbacks
+ *
+ * This routine is used when unbinding gadget drivers.  It prevents a race:
+ * The UDC driver doesn't know when the gadget driver's -&gt;unbind callback
+ * runs, so unless it is told to disable asynchronous callbacks, it might
+ * issue a callback (such as -&gt;disconnect) after the unbind has completed.
+ *
+ * After this function runs, the UDC driver must suppress all -&gt;suspend,
+ * -&gt;resume, -&gt;disconnect, -&gt;reset, and -&gt;setup callbacks to the gadget driver
+ * until async callbacks are again enabled.  A simple-minded but effective
+ * way to accomplish this is to tell the UDC hardware not to generate any
+ * more IRQs.
+ *
+ * Request completion callbacks must still be issued.  However, it's okay
+ * to defer them until the request is cancelled, since the pull-up will be
+ * turned off during the time period when async callbacks are disabled.
+ *
+ * This routine will always be called in process context.
+ */
+static inline void usb_gadget_disable_async_callbacks(struct usb_udc *udc)
+{
+	struct usb_gadget *gadget = udc-&gt;gadget;
+
+	if (gadget-&gt;ops-&gt;udc_async_callbacks)
+		gadget-&gt;ops-&gt;udc_async_callbacks(gadget, false);
+}
+
 /**
  * usb_udc_release - release the usb_udc struct
  * @dev: the dev member within usb_udc
@@ -1361,6 +1408,7 @@ static void usb_gadget_remove_driver(struct usb_udc *udc)
 	kobject_uevent(&amp;udc-&gt;dev.kobj, KOBJ_CHANGE);
 
 	usb_gadget_disconnect(udc-&gt;gadget);
+	usb_gadget_disable_async_callbacks(udc);
 	if (udc-&gt;gadget-&gt;irq)
 		synchronize_irq(udc-&gt;gadget-&gt;irq);
 	udc-&gt;driver-&gt;unbind(udc-&gt;gadget);
@@ -1442,6 +1490,7 @@ static int udc_bind_to_driver(struct usb_udc *udc, struct usb_gadget_driver *dri
 		driver-&gt;unbind(udc-&gt;gadget);
 		goto err1;
 	}
+	usb_gadget_enable_async_callbacks(udc);
 	usb_udc_connect_control(udc);
 
 	kobject_uevent(&amp;udc-&gt;dev.kobj, KOBJ_CHANGE);
diff --git a/include/linux/usb/gadget.h b/include/linux/usb/gadget.h
index 8811eb96e5cc..75c7538e350a 100644
--- a/include/linux/usb/gadget.h
+++ b/include/linux/usb/gadget.h
@@ -325,6 +325,7 @@ struct usb_gadget_ops {
 	void	(*udc_set_speed)(struct usb_gadget *, enum usb_device_speed);
 	void	(*udc_set_ssp_rate)(struct usb_gadget *gadget,
 			enum usb_ssp_rate rate);
+	void	(*udc_async_callbacks)(struct usb_gadget *gadget, bool enable);
 	struct usb_ep *(*match_ep)(struct usb_gadget *,
 			struct usb_endpoint_descriptor *,
 			struct usb_ss_ep_comp_descriptor *);</pre><hr><pre>commit 7652dd2c5cb7b656471cc801d619fe24120643a3
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed May 26 11:32:44 2021 -0400

    USB: core: Check buffer length matches wLength for control transfers
    
    A type of inconsistency that can show up in control URBs is when the
    setup packet's wLength value does not match the URB's
    transfer_buffer_length field.  The two should always be equal;
    differences could lead to information leaks or undefined behavior for
    OUT transfers or overruns for IN transfers.
    
    This patch adds a test for such mismatches during URB submission.  If
    the test fails, the submission is rejected with a -EBADR error code
    (which is not used elsewhere in the USB core), and a debugging message
    is logged for people interested in tracking down these errors.
    
    Reviewed-by: Johan Hovold &lt;johan@kernel.org&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/20210526153244.GA1400430@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/Documentation/driver-api/usb/error-codes.rst b/Documentation/driver-api/usb/error-codes.rst
index a3e84bfac776..8f9790c2d6f8 100644
--- a/Documentation/driver-api/usb/error-codes.rst
+++ b/Documentation/driver-api/usb/error-codes.rst
@@ -61,6 +61,9 @@ USB-specific:
 			(c) requested data transfer length is invalid: negative
 			    or too large for the host controller.
 
+``-EBADR``		The wLength value in a control URB's setup packet does
+			not match the URB's transfer_buffer_length.
+
 ``-ENOSPC``		This request would overcommit the usb bandwidth reserved
 			for periodic transfers (interrupt, isochronous).
 
diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 279b3921ff8f..30727729a44c 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -410,6 +410,12 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 		dev_WARN_ONCE(&amp;dev-&gt;dev, (usb_pipeout(urb-&gt;pipe) != is_out),
 				"BOGUS control dir, pipe %x doesn't match bRequestType %x\n",
 				urb-&gt;pipe, setup-&gt;bRequestType);
+		if (le16_to_cpu(setup-&gt;wLength) != urb-&gt;transfer_buffer_length) {
+			dev_dbg(&amp;dev-&gt;dev, "BOGUS control len %d doesn't match transfer length %d\n",
+					le16_to_cpu(setup-&gt;wLength),
+					urb-&gt;transfer_buffer_length);
+			return -EBADR;
+		}
 	} else {
 		is_out = usb_endpoint_dir_out(&amp;ep-&gt;desc);
 	}</pre><hr><pre>commit 5cc59c418fde9d02859996707b9d5dfd2941c50b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 21 22:16:23 2021 -0400

    USB: core: WARN if pipe direction != setup packet direction
    
    When a control URB is submitted, the direction indicated by URB's pipe
    member is supposed to match the direction indicated by the setup
    packet's bRequestType member.  A mismatch could lead to trouble,
    depending on which field the host controller drivers use for
    determining the actual direction.
    
    This shouldn't ever happen; it would represent a careless bug in a
    kernel driver somewhere.  This patch adds a dev_WARN_ONCE to let
    people know about the potential problem.
    
    Suggested-by: "Geoffrey D. Bennett" &lt;g@b4.vu&gt;
    Reviewed-by: Johan Hovold &lt;johan@kernel.org&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/20210522021623.GB1260282@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 357b149b20d3..279b3921ff8f 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -407,6 +407,9 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 			return -ENOEXEC;
 		is_out = !(setup-&gt;bRequestType &amp; USB_DIR_IN) ||
 				!setup-&gt;wLength;
+		dev_WARN_ONCE(&amp;dev-&gt;dev, (usb_pipeout(urb-&gt;pipe) != is_out),
+				"BOGUS control dir, pipe %x doesn't match bRequestType %x\n",
+				urb-&gt;pipe, setup-&gt;bRequestType);
 	} else {
 		is_out = usb_endpoint_dir_out(&amp;ep-&gt;desc);
 	}</pre><hr><pre>commit 4f2629ea67e7225c3fd292c7fe4f5b3c9d6392de
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 18 16:18:35 2021 -0400

    USB: usbfs: Don't WARN about excessively large memory allocations
    
    Syzbot found that the kernel generates a WARNing if the user tries to
    submit a bulk transfer through usbfs with a buffer that is way too
    large.  This isn't a bug in the kernel; it's merely an invalid request
    from the user and the usbfs code does handle it correctly.
    
    In theory the same thing can happen with async transfers, or with the
    packet descriptor table for isochronous transfers.
    
    To prevent the MM subsystem from complaining about these bad
    allocation requests, add the __GFP_NOWARN flag to the kmalloc calls
    for these buffers.
    
    CC: Andrew Morton &lt;akpm@linux-foundation.org&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Reported-and-tested-by: syzbot+882a85c0c8ec4a3e2281@syzkaller.appspotmail.com
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/20210518201835.GA1140918@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 533236366a03..2218941d35a3 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -1218,7 +1218,12 @@ static int do_proc_bulk(struct usb_dev_state *ps,
 	ret = usbfs_increase_memory_usage(len1 + sizeof(struct urb));
 	if (ret)
 		return ret;
-	tbuf = kmalloc(len1, GFP_KERNEL);
+
+	/*
+	 * len1 can be almost arbitrarily large.  Don't WARN if it's
+	 * too big, just fail the request.
+	 */
+	tbuf = kmalloc(len1, GFP_KERNEL | __GFP_NOWARN);
 	if (!tbuf) {
 		ret = -ENOMEM;
 		goto done;
@@ -1696,7 +1701,7 @@ static int proc_do_submiturb(struct usb_dev_state *ps, struct usbdevfs_urb *uurb
 	if (num_sgs) {
 		as-&gt;urb-&gt;sg = kmalloc_array(num_sgs,
 					    sizeof(struct scatterlist),
-					    GFP_KERNEL);
+					    GFP_KERNEL | __GFP_NOWARN);
 		if (!as-&gt;urb-&gt;sg) {
 			ret = -ENOMEM;
 			goto error;
@@ -1731,7 +1736,7 @@ static int proc_do_submiturb(struct usb_dev_state *ps, struct usbdevfs_urb *uurb
 					(uurb_start - as-&gt;usbm-&gt;vm_start);
 		} else {
 			as-&gt;urb-&gt;transfer_buffer = kmalloc(uurb-&gt;buffer_length,
-					GFP_KERNEL);
+					GFP_KERNEL | __GFP_NOWARN);
 			if (!as-&gt;urb-&gt;transfer_buffer) {
 				ret = -ENOMEM;
 				goto error;</pre><hr><pre>commit 2c412337cfe655bcc6adff8904fc653a1678f70f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Apr 8 11:22:09 2021 -0400

    PM: runtime: Add documentation for pm_runtime_resume_and_get()
    
    Commit dd8088d5a896 ("PM: runtime: Add pm_runtime_resume_and_get to
    deal with usage counter") added a new runtime-PM API function without
    updating the documentation in runtime_pm.rst.
    
    Add the missing documentation.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Fixes: dd8088d5a896 ("PM: runtime: Add pm_runtime_resume_and_get to deal with usage counter")
    Signed-off-by: Rafael J. Wysocki &lt;rafael.j.wysocki@intel.com&gt;

diff --git a/Documentation/power/runtime_pm.rst b/Documentation/power/runtime_pm.rst
index d9c777b18f7a..18ae21bf7f92 100644
--- a/Documentation/power/runtime_pm.rst
+++ b/Documentation/power/runtime_pm.rst
@@ -339,6 +339,10 @@ drivers/base/power/runtime.c and include/linux/pm_runtime.h:
       checked additionally, and -EACCES means that 'power.disable_depth' is
       different from 0
 
+  `int pm_runtime_resume_and_get(struct device *dev);`
+    - run pm_runtime_resume(dev) and if successful, increment the device's
+      usage counter; return the result of pm_runtime_resume
+
   `int pm_request_idle(struct device *dev);`
     - submit a request to execute the subsystem-level idle callback for the
       device (the request is represented by a work item in pm_wq); returns 0 on</pre><hr><pre>commit 546aa0e4ea6ed81b6c51baeebc4364542fa3f3a7
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Mar 17 15:06:54 2021 -0400

    usb-storage: Add quirk to defeat Kindle's automatic unload
    
    Matthias reports that the Amazon Kindle automatically removes its
    emulated media if it doesn't receive another SCSI command within about
    one second after a SYNCHRONIZE CACHE.  It does so even when the host
    has sent a PREVENT MEDIUM REMOVAL command.  The reason for this
    behavior isn't clear, although it's not hard to make some guesses.
    
    At any rate, the results can be unexpected for anyone who tries to
    access the Kindle in an unusual fashion, and in theory they can lead
    to data loss (for example, if one file is closed and synchronized
    while other files are still in the middle of being written).
    
    To avoid such problems, this patch creates a new usb-storage quirks
    flag telling the driver always to issue a REQUEST SENSE following a
    SYNCHRONIZE CACHE command, and adds an unusual_devs entry for the
    Kindle with the flag set.  This is sufficient to prevent the Kindle
    from doing its automatic unload, without interfering with proper
    operation.
    
    Another possible way to deal with this would be to increase the
    frequency of TEST UNIT READY polling that the kernel normally carries
    out for removable-media storage devices.  However that would increase
    the overall load on the system and it is not as reliable, because the
    user can override the polling interval.  Changing the driver's
    behavior is safer and has minimal overhead.
    
    CC: &lt;stable@vger.kernel.org&gt;
    Reported-and-tested-by: Matthias Schwarzott &lt;zzam@gentoo.org&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/20210317190654.GA497856@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/storage/transport.c b/drivers/usb/storage/transport.c
index 5eb895b19c55..f4304ce69350 100644
--- a/drivers/usb/storage/transport.c
+++ b/drivers/usb/storage/transport.c
@@ -656,6 +656,13 @@ void usb_stor_invoke_transport(struct scsi_cmnd *srb, struct us_data *us)
 		need_auto_sense = 1;
 	}
 
+	/* Some devices (Kindle) require another command after SYNC CACHE */
+	if ((us-&gt;fflags &amp; US_FL_SENSE_AFTER_SYNC) &amp;&amp;
+			srb-&gt;cmnd[0] == SYNCHRONIZE_CACHE) {
+		usb_stor_dbg(us, "-- sense after SYNC CACHE\n");
+		need_auto_sense = 1;
+	}
+
 	/*
 	 * If we have a failure, we're going to do a REQUEST_SENSE 
 	 * automatically.  Note that we differentiate between a command
diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index 5732e9691f08..efa972be2ee3 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -2211,6 +2211,18 @@ UNUSUAL_DEV( 0x1908, 0x3335, 0x0200, 0x0200,
 		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
 		US_FL_NO_READ_DISC_INFO ),
 
+/*
+ * Reported by Matthias Schwarzott &lt;zzam@gentoo.org&gt;
+ * The Amazon Kindle treats SYNCHRONIZE CACHE as an indication that
+ * the host may be finished with it, and automatically ejects its
+ * emulated media unless it receives another command within one second.
+ */
+UNUSUAL_DEV( 0x1949, 0x0004, 0x0000, 0x9999,
+		"Amazon",
+		"Kindle",
+		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
+		US_FL_SENSE_AFTER_SYNC ),
+
 /*
  * Reported by Oliver Neukum &lt;oneukum@suse.com&gt;
  * This device morphes spontaneously into another device if the access
diff --git a/include/linux/usb_usual.h b/include/linux/usb_usual.h
index 6b03fdd69d27..712363c7a2e8 100644
--- a/include/linux/usb_usual.h
+++ b/include/linux/usb_usual.h
@@ -86,6 +86,8 @@
 		/* lies about caching, so always sync */	\
 	US_FLAG(NO_SAME, 0x40000000)				\
 		/* Cannot handle WRITE_SAME */			\
+	US_FLAG(SENSE_AFTER_SYNC, 0x80000000)			\
+		/* Do REQUEST_SENSE after SYNCHRONIZE_CACHE */	\
 
 #define US_FLAG(name, value)	US_FL_##name = value ,
 enum { US_DO_ALL_FLAGS };</pre><hr><pre>commit 6e6aa61d81194c01283880950df563b1b9abec46
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jan 13 14:45:10 2021 -0500

    USB: gadget: dummy-hcd: Fix errors in port-reset handling
    
    Commit c318840fb2a4 ("USB: Gadget: dummy-hcd: Fix shift-out-of-bounds
    bug") messed up the way dummy-hcd handles requests to turn on the
    RESET port feature (I didn't notice that the original switch case
    ended with a fallthrough).  The call to set_link_state() was
    inadvertently removed, as was the code to set the USB_PORT_STAT_RESET
    flag when the speed is USB2.
    
    In addition, the original code never checked whether the port was
    connected before handling the port-reset request.  There was a check
    for the port being powered, but it was removed by that commit!  In
    practice this doesn't matter much because the kernel doesn't try to
    reset disconnected ports, but it's still bad form.
    
    This patch fixes these problems by changing the fallthrough to break,
    adding back in the missing set_link_state() call, setting the
    port-reset status flag, adding a port-is-connected test, and removing
    a redundant assignment statement.
    
    Fixes: c318840fb2a4 ("USB: Gadget: dummy-hcd: Fix shift-out-of-bounds bug")
    CC: &lt;stable@vger.kernel.org&gt;
    Acked-by: Felipe Balbi &lt;balbi@kernel.org&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/20210113194510.GA1290698@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/gadget/udc/dummy_hcd.c b/drivers/usb/gadget/udc/dummy_hcd.c
index 1a953f44183a..57067763b100 100644
--- a/drivers/usb/gadget/udc/dummy_hcd.c
+++ b/drivers/usb/gadget/udc/dummy_hcd.c
@@ -2270,17 +2270,20 @@ static int dummy_hub_control(
 			}
 			fallthrough;
 		case USB_PORT_FEAT_RESET:
+			if (!(dum_hcd-&gt;port_status &amp; USB_PORT_STAT_CONNECTION))
+				break;
 			/* if it's already enabled, disable */
 			if (hcd-&gt;speed == HCD_USB3) {
-				dum_hcd-&gt;port_status = 0;
 				dum_hcd-&gt;port_status =
 					(USB_SS_PORT_STAT_POWER |
 					 USB_PORT_STAT_CONNECTION |
 					 USB_PORT_STAT_RESET);
-			} else
+			} else {
 				dum_hcd-&gt;port_status &amp;= ~(USB_PORT_STAT_ENABLE
 					| USB_PORT_STAT_LOW_SPEED
 					| USB_PORT_STAT_HIGH_SPEED);
+				dum_hcd-&gt;port_status |= USB_PORT_STAT_RESET;
+			}
 			/*
 			 * We want to reset device status. All but the
 			 * Self powered feature
@@ -2292,7 +2295,8 @@ static int dummy_hub_control(
 			 * interval? Is it still 50msec as for HS?
 			 */
 			dum_hcd-&gt;re_timeout = jiffies + msecs_to_jiffies(50);
-			fallthrough;
+			set_link_state(dum_hcd);
+			break;
 		case USB_PORT_FEAT_C_CONNECTION:
 		case USB_PORT_FEAT_C_RESET:
 		case USB_PORT_FEAT_C_ENABLE:</pre>
    <div class="pagination">
        <a href='2_6.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><span>[7]</span><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_8.html'>Next&gt;&gt;</a>
    <div>
</body>
