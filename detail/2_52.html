<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_51.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><span>[52]</span><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_53.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit fea6d607e154cf96ab22254ccb48addfd43d4cb5
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Feb 17 16:25:08 2012 -0500

    [SCSI] scsi_pm: Fix bug in the SCSI power management handler
    
    This patch (as1520) fixes a bug in the SCSI layer's power management
    implementation.
    
    LUN scanning can be carried out asynchronously in do_scan_async(), and
    sd uses an asynchronous thread for the time-consuming parts of disk
    probing in sd_probe_async().  Currently nothing coordinates these
    async threads with system sleep transitions; they can and do attempt
    to continue scanning/probing SCSI devices even after the host adapter
    has been suspended.  As one might expect, the outcome is not ideal.
    
    This is what the "prepare" stage of system suspend was created for.
    After the prepare callback has been called for a host, target, or
    device, drivers are not allowed to register any children underneath
    them.  Currently the SCSI prepare callback is not implemented; this
    patch rectifies that omission.
    
    For SCSI hosts, the prepare routine calls scsi_complete_async_scans()
    to wait until async scanning is finished.  It might be slightly more
    efficient to wait only until the host in question has been scanned,
    but there's currently no way to do that.  Besides, during a sleep
    transition we will ultimately have to wait until all the host scanning
    has finished anyway.
    
    For SCSI devices, the prepare routine calls async_synchronize_full()
    to wait until sd probing is finished.  The routine does nothing for
    SCSI targets, because asynchronous target scanning is done only as
    part of host scanning.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@kernel.org&gt;
    Signed-off-by: James Bottomley &lt;JBottomley@Parallels.com&gt;

diff --git a/drivers/scsi/scsi_pm.c b/drivers/scsi/scsi_pm.c
index bf8bf79e6a1f..c4670642d023 100644
--- a/drivers/scsi/scsi_pm.c
+++ b/drivers/scsi/scsi_pm.c
@@ -7,6 +7,7 @@
 
 #include &lt;linux/pm_runtime.h&gt;
 #include &lt;linux/export.h&gt;
+#include &lt;linux/async.h&gt;
 
 #include &lt;scsi/scsi.h&gt;
 #include &lt;scsi/scsi_device.h&gt;
@@ -92,6 +93,19 @@ static int scsi_bus_resume_common(struct device *dev)
 	return err;
 }
 
+static int scsi_bus_prepare(struct device *dev)
+{
+	if (scsi_is_sdev_device(dev)) {
+		/* sd probing uses async_schedule.  Wait until it finishes. */
+		async_synchronize_full();
+
+	} else if (scsi_is_host_device(dev)) {
+		/* Wait until async scanning is finished */
+		scsi_complete_async_scans();
+	}
+	return 0;
+}
+
 static int scsi_bus_suspend(struct device *dev)
 {
 	return scsi_bus_suspend_common(dev, PMSG_SUSPEND);
@@ -110,6 +124,7 @@ static int scsi_bus_poweroff(struct device *dev)
 #else /* CONFIG_PM_SLEEP */
 
 #define scsi_bus_resume_common		NULL
+#define scsi_bus_prepare		NULL
 #define scsi_bus_suspend		NULL
 #define scsi_bus_freeze			NULL
 #define scsi_bus_poweroff		NULL
@@ -218,6 +233,7 @@ void scsi_autopm_put_host(struct Scsi_Host *shost)
 #endif /* CONFIG_PM_RUNTIME */
 
 const struct dev_pm_ops scsi_bus_pm_ops = {
+	.prepare =		scsi_bus_prepare,
 	.suspend =		scsi_bus_suspend,
 	.resume =		scsi_bus_resume_common,
 	.freeze =		scsi_bus_freeze,
diff --git a/drivers/scsi/scsi_priv.h b/drivers/scsi/scsi_priv.h
index 68eadd1c67fd..be4fa6d179b1 100644
--- a/drivers/scsi/scsi_priv.h
+++ b/drivers/scsi/scsi_priv.h
@@ -109,6 +109,7 @@ extern void scsi_exit_procfs(void);
 #endif /* CONFIG_PROC_FS */
 
 /* scsi_scan.c */
+extern int scsi_complete_async_scans(void);
 extern int scsi_scan_host_selected(struct Scsi_Host *, unsigned int,
 				   unsigned int, unsigned int, int);
 extern void scsi_forget_host(struct Scsi_Host *);</pre><hr><pre>commit af74d2dae8f85a0e90a30594beb507f5d954fa3f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jan 10 13:43:40 2012 -0500

    usb-storage: reorganize target-specific code
    
    Now that usb-storage has a target_alloc() routine, this patch (as1508)
    moves some existing target-specific code out of the slave_alloc()
    routine to where it really belongs.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Matthew Dharm &lt;mdharm-usb@one-eyed-alien.net&gt;
    Cc: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index dc68cc9fef5d..a324a5d21e99 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -78,8 +78,6 @@ static const char* host_info(struct Scsi_Host *host)
 
 static int slave_alloc (struct scsi_device *sdev)
 {
-	struct us_data *us = host_to_us(sdev-&gt;host);
-
 	/*
 	 * Set the INQUIRY transfer length to 36.  We don't use any of
 	 * the extra data and many devices choke if asked for more or
@@ -104,18 +102,6 @@ static int slave_alloc (struct scsi_device *sdev)
 	 */
 	blk_queue_update_dma_alignment(sdev-&gt;request_queue, (512 - 1));
 
-	/*
-	 * The UFI spec treates the Peripheral Qualifier bits in an
-	 * INQUIRY result as reserved and requires devices to set them
-	 * to 0.  However the SCSI spec requires these bits to be set
-	 * to 3 to indicate when a LUN is not present.
-	 *
-	 * Let the scanning code know if this target merely sets
-	 * Peripheral Device Type to 0x1f to indicate no LUN.
-	 */
-	if (us-&gt;subclass == USB_SC_UFI)
-		sdev-&gt;sdev_target-&gt;pdt_1f_for_no_lun = 1;
-
 	return 0;
 }
 
@@ -278,6 +264,8 @@ static int slave_configure(struct scsi_device *sdev)
 
 static int target_alloc(struct scsi_target *starget)
 {
+	struct us_data *us = host_to_us(dev_to_shost(starget-&gt;dev.parent));
+
 	/*
 	 * Some USB drives don't support REPORT LUNS, even though they
 	 * report a SCSI revision level above 2.  Tell the SCSI layer
@@ -285,6 +273,19 @@ static int target_alloc(struct scsi_target *starget)
 	 * scan instead.
 	 */
 	starget-&gt;no_report_luns = 1;
+
+	/*
+	 * The UFI spec treats the Peripheral Qualifier bits in an
+	 * INQUIRY result as reserved and requires devices to set them
+	 * to 0.  However the SCSI spec requires these bits to be set
+	 * to 3 to indicate when a LUN is not present.
+	 *
+	 * Let the scanning code know if this target merely sets
+	 * Peripheral Device Type to 0x1f to indicate no LUN.
+	 */
+	if (us-&gt;subclass == USB_SC_UFI)
+		starget-&gt;pdt_1f_for_no_lun = 1;
+
 	return 0;
 }
 </pre><hr><pre>commit 09b6b51b0b6c1b9bb61815baf205e4d74c89ff04
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jan 10 13:43:30 2012 -0500

    SCSI &amp; usb-storage: add flags for VPD pages and REPORT LUNS
    
    This patch (as1507) adds a skip_vpd_pages flag to struct scsi_device
    and a no_report_luns flag to struct scsi_target.  The first is used to
    control whether sd will look at VPD pages for information on block
    provisioning, limits, and characteristics.  The second prevents
    scsi_report_lun_scan() from issuing a REPORT LUNS command.
    
    The patch also modifies usb-storage to set the new flag bits for all
    USB devices and targets, and to stop adjusting the scsi_level value.
    
    Historically we have seen that USB mass-storage devices often don't
    support VPD pages or REPORT LUNS properly.  Until now we have avoided
    these things by setting the scsi_level to SCSI_2 for all USB devices.
    But this has the side effect of storing the LUN bits into the second
    byte of each CDB, and now we have a report of a device which doesn't
    like that.  The best solution is to stop abusing scsi_level and
    instead have separate flags for VPD pages and REPORT LUNS.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Perry Wagle &lt;wagle@mac.com&gt;
    CC: Matthew Dharm &lt;mdharm-usb@one-eyed-alien.net&gt;
    Cc: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c
index 89da43f73c00..fd37bfbfbcdb 100644
--- a/drivers/scsi/scsi_scan.c
+++ b/drivers/scsi/scsi_scan.c
@@ -1295,6 +1295,7 @@ EXPORT_SYMBOL(int_to_scsilun);
  *   LUNs even if it's older than SCSI-3.
  *   If BLIST_NOREPORTLUN is set, return 1 always.
  *   If BLIST_NOLUN is set, return 0 always.
+ *   If starget-&gt;no_report_luns is set, return 1 always.
  *
  * Return:
  *     0: scan completed (or no memory, so further scanning is futile)
@@ -1321,6 +1322,7 @@ static int scsi_report_lun_scan(struct scsi_target *starget, int bflags,
 	 * Only support SCSI-3 and up devices if BLIST_NOREPORTLUN is not set.
 	 * Also allow SCSI-2 if BLIST_REPORTLUN2 is set and host adapter does
 	 * support more than 8 LUNs.
+	 * Don't attempt if the target doesn't support REPORT LUNS.
 	 */
 	if (bflags &amp; BLIST_NOREPORTLUN)
 		return 1;
@@ -1332,6 +1334,8 @@ static int scsi_report_lun_scan(struct scsi_target *starget, int bflags,
 		return 1;
 	if (bflags &amp; BLIST_NOLUN)
 		return 0;
+	if (starget-&gt;no_report_luns)
+		return 1;
 
 	if (!(sdev = scsi_device_lookup_by_target(starget, 0))) {
 		sdev = scsi_alloc_sdev(starget, 0, NULL);
diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c
index c691fb50e6cb..d173b90b25e9 100644
--- a/drivers/scsi/sd.c
+++ b/drivers/scsi/sd.c
@@ -2349,7 +2349,7 @@ static int sd_try_extended_inquiry(struct scsi_device *sdp)
 	 * some USB ones crash on receiving them, and the pages
 	 * we currently ask for are for SPC-3 and beyond
 	 */
-	if (sdp-&gt;scsi_level &gt; SCSI_SPC_2)
+	if (sdp-&gt;scsi_level &gt; SCSI_SPC_2 &amp;&amp; !sdp-&gt;skip_vpd_pages)
 		return 1;
 	return 0;
 }
diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 13b8bcdf3dba..dc68cc9fef5d 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -197,6 +197,9 @@ static int slave_configure(struct scsi_device *sdev)
 		 * page x08, so we will skip it. */
 		sdev-&gt;skip_ms_page_8 = 1;
 
+		/* Some devices don't handle VPD pages correctly */
+		sdev-&gt;skip_vpd_pages = 1;
+
 		/* Some disks return the total number of blocks in response
 		 * to READ CAPACITY rather than the highest block number.
 		 * If this device makes that mistake, tell the sd driver. */
@@ -217,16 +220,6 @@ static int slave_configure(struct scsi_device *sdev)
 		if (sdev-&gt;scsi_level &gt; SCSI_SPC_2)
 			us-&gt;fflags |= US_FL_SANE_SENSE;
 
-		/* Some devices report a SCSI revision level above 2 but are
-		 * unable to handle the REPORT LUNS command (for which
-		 * support is mandatory at level 3).  Since we already have
-		 * a Get-Max-LUN request, we won't lose much by setting the
-		 * revision level down to 2.  The only devices that would be
-		 * affected are those with sparse LUNs. */
-		if (sdev-&gt;scsi_level &gt; SCSI_2)
-			sdev-&gt;sdev_target-&gt;scsi_level =
-					sdev-&gt;scsi_level = SCSI_2;
-
 		/* USB-IDE bridges tend to report SK = 0x04 (Non-recoverable
 		 * Hardware Error) when any low-level error occurs,
 		 * recoverable or not.  Setting this flag tells the SCSI
@@ -283,6 +276,18 @@ static int slave_configure(struct scsi_device *sdev)
 	return 0;
 }
 
+static int target_alloc(struct scsi_target *starget)
+{
+	/*
+	 * Some USB drives don't support REPORT LUNS, even though they
+	 * report a SCSI revision level above 2.  Tell the SCSI layer
+	 * not to issue that command; it will perform a normal sequential
+	 * scan instead.
+	 */
+	starget-&gt;no_report_luns = 1;
+	return 0;
+}
+
 /* queue a command */
 /* This is always called with scsi_lock(host) held */
 static int queuecommand_lck(struct scsi_cmnd *srb,
@@ -546,6 +551,7 @@ struct scsi_host_template usb_stor_host_template = {
 
 	.slave_alloc =			slave_alloc,
 	.slave_configure =		slave_configure,
+	.target_alloc =			target_alloc,
 
 	/* lots of sg segments can be handled */
 	.sg_tablesize =			SCSI_MAX_SG_CHAIN_SEGMENTS,
diff --git a/include/scsi/scsi_device.h b/include/scsi/scsi_device.h
index 01cb3c4cb74d..b3a1c2daf6cc 100644
--- a/include/scsi/scsi_device.h
+++ b/include/scsi/scsi_device.h
@@ -136,6 +136,7 @@ struct scsi_device {
 	unsigned use_10_for_ms:1; /* first try 10-byte mode sense/select */
 	unsigned skip_ms_page_8:1;	/* do not use MODE SENSE page 0x08 */
 	unsigned skip_ms_page_3f:1;	/* do not use MODE SENSE page 0x3f */
+	unsigned skip_vpd_pages:1;	/* do not read VPD pages */
 	unsigned use_192_bytes_for_3f:1; /* ask for 192 bytes from page 0x3f */
 	unsigned no_start_on_add:1;	/* do not issue start on add */
 	unsigned allow_restart:1; /* issue START_UNIT in error handler */
@@ -248,6 +249,8 @@ struct scsi_target {
 						 * for the device at a time. */
 	unsigned int		pdt_1f_for_no_lun:1;	/* PDT = 0x1f
 						 * means no lun present. */
+	unsigned int		no_report_luns:1;	/* Don't use
+						 * REPORT LUNS for scanning. */
 	/* commands actually active on LLD. protected by host lock. */
 	unsigned int		target_busy;
 	/*</pre><hr><pre>commit de8c46bfc032fbdf490cfb67f534d2a0188ebeb0
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jan 10 13:43:04 2012 -0500

    SCSI: fix typo in definition of struct scsi_target
    
    This patch (as1506) corrects a typo in the definition of the
    scsi_target structure.  pdt_1f_for_no_lun is supposed to be a
    single-bit flag, not a full-sized integer.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/include/scsi/scsi_device.h b/include/scsi/scsi_device.h
index 77273f2fdd80..01cb3c4cb74d 100644
--- a/include/scsi/scsi_device.h
+++ b/include/scsi/scsi_device.h
@@ -246,8 +246,8 @@ struct scsi_target {
 	unsigned int		single_lun:1;	/* Indicates we should only
 						 * allow I/O to one of the luns
 						 * for the device at a time. */
-	unsigned int		pdt_1f_for_no_lun;	/* PDT = 0x1f */
-						/* means no lun present */
+	unsigned int		pdt_1f_for_no_lun:1;	/* PDT = 0x1f
+						 * means no lun present. */
 	/* commands actually active on LLD. protected by host lock. */
 	unsigned int		target_busy;
 	/*</pre><hr><pre>commit 0cb54a3e47cb4baf0bc7463f0a64cfeae5e35697
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Feb 2 15:38:14 2012 -0500

    USB: debugging code shouldn't alter control flow
    
    People have complained that debugging code shouldn't alter the flow of
    control; it should restrict itself to printing out warnings and error
    messages.  Bowing to popular opinion, this patch (as1518) changes the
    debugging checks in usb_submit_urb() to follow this guideline.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Keith Packard &lt;keithp@keithp.com&gt;
    CC: Pavel Machek &lt;pavel@ucw.cz&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 909625b91eb3..f4f20c7b7765 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -403,20 +403,17 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 	 * cause problems in HCDs if they get it wrong.
 	 */
 	{
-	unsigned int	orig_flags = urb-&gt;transfer_flags;
 	unsigned int	allowed;
 	static int pipetypes[4] = {
 		PIPE_CONTROL, PIPE_ISOCHRONOUS, PIPE_BULK, PIPE_INTERRUPT
 	};
 
 	/* Check that the pipe's type matches the endpoint's type */
-	if (usb_pipetype(urb-&gt;pipe) != pipetypes[xfertype]) {
-		dev_err(&amp;dev-&gt;dev, "BOGUS urb xfer, pipe %x != type %x\n",
+	if (usb_pipetype(urb-&gt;pipe) != pipetypes[xfertype])
+		dev_WARN(&amp;dev-&gt;dev, "BOGUS urb xfer, pipe %x != type %x\n",
 			usb_pipetype(urb-&gt;pipe), pipetypes[xfertype]);
-		return -EPIPE;		/* The most suitable error code :-) */
-	}
 
-	/* enforce simple/standard policy */
+	/* Check against a simple/standard policy */
 	allowed = (URB_NO_TRANSFER_DMA_MAP | URB_NO_INTERRUPT | URB_DIR_MASK |
 			URB_FREE_BUFFER);
 	switch (xfertype) {
@@ -435,14 +432,12 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 		allowed |= URB_ISO_ASAP;
 		break;
 	}
-	urb-&gt;transfer_flags &amp;= allowed;
+	allowed &amp;= urb-&gt;transfer_flags;
 
-	/* fail if submitter gave bogus flags */
-	if (urb-&gt;transfer_flags != orig_flags) {
-		dev_err(&amp;dev-&gt;dev, "BOGUS urb flags, %x --&gt; %x\n",
-			orig_flags, urb-&gt;transfer_flags);
-		return -EINVAL;
-	}
+	/* warn if submitter gave bogus flags */
+	if (allowed != urb-&gt;transfer_flags)
+		dev_WARN(&amp;dev-&gt;dev, "BOGUS urb flags, %x --&gt; %x\n",
+			urb-&gt;transfer_flags, allowed);
 	}
 #endif
 	/*</pre><hr><pre>commit 07d251460bbf9752c6532af8c1a68328c199dd70
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jan 27 10:24:40 2012 -0500

    PCI/XEN: Fix bug introduced by a recent change
    
    This patch (as1516) fixes a bug introduced during the removal of
    put_driver() and get_driver() from drivers/pci/xen-pcifront.c.
    
    Reported-by: Stephen Rothwell &lt;sfr@canb.auug.org.au&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/pci/xen-pcifront.c b/drivers/pci/xen-pcifront.c
index 6f819988a8da..98387caf59b3 100644
--- a/drivers/pci/xen-pcifront.c
+++ b/drivers/pci/xen-pcifront.c
@@ -593,7 +593,7 @@ static pci_ers_result_t pcifront_common_process(int cmd,
 	}
 	pdrv = pcidev-&gt;driver;
 
-	if (pdrv-&gt;driver) {
+	if (pdrv) {
 		if (pdrv-&gt;err_handler &amp;&amp; pdrv-&gt;err_handler-&gt;error_detected) {
 			dev_dbg(&amp;pcidev-&gt;dev,
 				"trying to call AER service\n");</pre><hr><pre>commit ed283e9f0a2cc0541870828c76c6c6997c51a318
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jan 24 14:35:13 2012 -0500

    USB/PCI/PCMCIA: Clean up new_id and remove_id sysfs attribute routines
    
    This patch (as1514) cleans up some places where new_id and remove_id
    sysfs attributes are created and deleted.  Handling both attributes in
    a single routine rather than a pair of routines makes the code
    smaller.  It also prevents certain kinds of errors, like one we
    currently have in the USB subsystem: The removeid attribute is often
    created even when newid isn't (because the driver's no_dynamid_id flag
    is set).
    
    In the case of the PCMCIA subsystem, the newid attribute is created
    but never explicitly deleted.  The patch adds a deletion routine.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Jesse Barnes &lt;jbarnes@virtuousgeek.org&gt;
    Acked-by: Dominik Brodowski &lt;linux@dominikbrodowski.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index ff540477fe8b..8d9616b821ca 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -188,43 +188,34 @@ store_remove_id(struct device_driver *driver, const char *buf, size_t count)
 static DRIVER_ATTR(remove_id, S_IWUSR, NULL, store_remove_id);
 
 static int
-pci_create_newid_file(struct pci_driver *drv)
+pci_create_newid_files(struct pci_driver *drv)
 {
 	int error = 0;
-	if (drv-&gt;probe != NULL)
-		error = driver_create_file(&amp;drv-&gt;driver, &amp;driver_attr_new_id);
-	return error;
-}
-
-static void pci_remove_newid_file(struct pci_driver *drv)
-{
-	driver_remove_file(&amp;drv-&gt;driver, &amp;driver_attr_new_id);
-}
 
-static int
-pci_create_removeid_file(struct pci_driver *drv)
-{
-	int error = 0;
-	if (drv-&gt;probe != NULL)
-		error = driver_create_file(&amp;drv-&gt;driver,&amp;driver_attr_remove_id);
+	if (drv-&gt;probe != NULL) {
+		error = driver_create_file(&amp;drv-&gt;driver, &amp;driver_attr_new_id);
+		if (error == 0) {
+			error = driver_create_file(&amp;drv-&gt;driver,
+					&amp;driver_attr_remove_id);
+			if (error)
+				driver_remove_file(&amp;drv-&gt;driver,
+						&amp;driver_attr_new_id);
+		}
+	}
 	return error;
 }
 
-static void pci_remove_removeid_file(struct pci_driver *drv)
+static void pci_remove_newid_files(struct pci_driver *drv)
 {
 	driver_remove_file(&amp;drv-&gt;driver, &amp;driver_attr_remove_id);
+	driver_remove_file(&amp;drv-&gt;driver, &amp;driver_attr_new_id);
 }
 #else /* !CONFIG_HOTPLUG */
-static inline int pci_create_newid_file(struct pci_driver *drv)
+static inline int pci_create_newid_files(struct pci_driver *drv)
 {
 	return 0;
 }
-static inline void pci_remove_newid_file(struct pci_driver *drv) {}
-static inline int pci_create_removeid_file(struct pci_driver *drv)
-{
-	return 0;
-}
-static inline void pci_remove_removeid_file(struct pci_driver *drv) {}
+static inline void pci_remove_newid_files(struct pci_driver *drv) {}
 #endif
 
 /**
@@ -1136,18 +1127,12 @@ int __pci_register_driver(struct pci_driver *drv, struct module *owner,
 	if (error)
 		goto out;
 
-	error = pci_create_newid_file(drv);
+	error = pci_create_newid_files(drv);
 	if (error)
 		goto out_newid;
-
-	error = pci_create_removeid_file(drv);
-	if (error)
-		goto out_removeid;
 out:
 	return error;
 
-out_removeid:
-	pci_remove_newid_file(drv);
 out_newid:
 	driver_unregister(&amp;drv-&gt;driver);
 	goto out;
@@ -1166,8 +1151,7 @@ int __pci_register_driver(struct pci_driver *drv, struct module *owner,
 void
 pci_unregister_driver(struct pci_driver *drv)
 {
-	pci_remove_removeid_file(drv);
-	pci_remove_newid_file(drv);
+	pci_remove_newid_files(drv);
 	driver_unregister(&amp;drv-&gt;driver);
 	pci_free_dynids(drv);
 }
diff --git a/drivers/pcmcia/ds.c b/drivers/pcmcia/ds.c
index 059699f6363d..249b8895807d 100644
--- a/drivers/pcmcia/ds.c
+++ b/drivers/pcmcia/ds.c
@@ -157,6 +157,11 @@ pcmcia_create_newid_file(struct pcmcia_driver *drv)
 	return error;
 }
 
+static void
+pcmcia_remove_newid_file(struct pcmcia_driver *drv)
+{
+	driver_remove_file(&amp;drv-&gt;drv, &amp;driver_attr_new_id);
+}
 
 /**
  * pcmcia_register_driver - register a PCMCIA driver with the bus core
@@ -201,6 +206,7 @@ EXPORT_SYMBOL(pcmcia_register_driver);
 void pcmcia_unregister_driver(struct pcmcia_driver *driver)
 {
 	pr_debug("unregistering driver %s\n", driver-&gt;name);
+	pcmcia_remove_newid_file(driver);
 	driver_unregister(&amp;driver-&gt;drv);
 	pcmcia_free_dynids(driver);
 }
diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 54c493b4226b..4fee024ecc9b 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -129,43 +129,39 @@ store_remove_id(struct device_driver *driver, const char *buf, size_t count)
 }
 static DRIVER_ATTR(remove_id, S_IWUSR, NULL, store_remove_id);
 
-static int usb_create_newid_file(struct usb_driver *usb_drv)
+static int usb_create_newid_files(struct usb_driver *usb_drv)
 {
 	int error = 0;
 
 	if (usb_drv-&gt;no_dynamic_id)
 		goto exit;
 
-	if (usb_drv-&gt;probe != NULL)
+	if (usb_drv-&gt;probe != NULL) {
 		error = driver_create_file(&amp;usb_drv-&gt;drvwrap.driver,
 					   &amp;driver_attr_new_id);
+		if (error == 0) {
+			error = driver_create_file(&amp;usb_drv-&gt;drvwrap.driver,
+					&amp;driver_attr_remove_id);
+			if (error)
+				driver_remove_file(&amp;usb_drv-&gt;drvwrap.driver,
+						&amp;driver_attr_new_id);
+		}
+	}
 exit:
 	return error;
 }
 
-static void usb_remove_newid_file(struct usb_driver *usb_drv)
+static void usb_remove_newid_files(struct usb_driver *usb_drv)
 {
 	if (usb_drv-&gt;no_dynamic_id)
 		return;
 
-	if (usb_drv-&gt;probe != NULL)
+	if (usb_drv-&gt;probe != NULL) {
 		driver_remove_file(&amp;usb_drv-&gt;drvwrap.driver,
-				   &amp;driver_attr_new_id);
-}
-
-static int
-usb_create_removeid_file(struct usb_driver *drv)
-{
-	int error = 0;
-	if (drv-&gt;probe != NULL)
-		error = driver_create_file(&amp;drv-&gt;drvwrap.driver,
 				&amp;driver_attr_remove_id);
-	return error;
-}
-
-static void usb_remove_removeid_file(struct usb_driver *drv)
-{
-	driver_remove_file(&amp;drv-&gt;drvwrap.driver, &amp;driver_attr_remove_id);
+		driver_remove_file(&amp;usb_drv-&gt;drvwrap.driver,
+				   &amp;driver_attr_new_id);
+	}
 }
 
 static void usb_free_dynids(struct usb_driver *usb_drv)
@@ -180,22 +176,12 @@ static void usb_free_dynids(struct usb_driver *usb_drv)
 	spin_unlock(&amp;usb_drv-&gt;dynids.lock);
 }
 #else
-static inline int usb_create_newid_file(struct usb_driver *usb_drv)
-{
-	return 0;
-}
-
-static void usb_remove_newid_file(struct usb_driver *usb_drv)
-{
-}
-
-static int
-usb_create_removeid_file(struct usb_driver *drv)
+static inline int usb_create_newid_files(struct usb_driver *usb_drv)
 {
 	return 0;
 }
 
-static void usb_remove_removeid_file(struct usb_driver *drv)
+static void usb_remove_newid_files(struct usb_driver *usb_drv)
 {
 }
 
@@ -872,22 +858,16 @@ int usb_register_driver(struct usb_driver *new_driver, struct module *owner,
 
 	usbfs_update_special();
 
-	retval = usb_create_newid_file(new_driver);
+	retval = usb_create_newid_files(new_driver);
 	if (retval)
 		goto out_newid;
 
-	retval = usb_create_removeid_file(new_driver);
-	if (retval)
-		goto out_removeid;
-
 	pr_info("%s: registered new interface driver %s\n",
 			usbcore_name, new_driver-&gt;name);
 
 out:
 	return retval;
 
-out_removeid:
-	usb_remove_newid_file(new_driver);
 out_newid:
 	driver_unregister(&amp;new_driver-&gt;drvwrap.driver);
 
@@ -914,10 +894,9 @@ void usb_deregister(struct usb_driver *driver)
 	pr_info("%s: deregistering interface driver %s\n",
 			usbcore_name, driver-&gt;name);
 
-	usb_remove_removeid_file(driver);
-	usb_remove_newid_file(driver);
-	usb_free_dynids(driver);
+	usb_remove_newid_files(driver);
 	driver_unregister(&amp;driver-&gt;drvwrap.driver);
+	usb_free_dynids(driver);
 
 	usbfs_update_special();
 }</pre><hr><pre>commit 9875bb480cc89d9b690f7028aadf7e58454f0dae
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jan 24 13:35:37 2012 -0500

    Eliminate get_driver() and put_driver()
    
    Now that there are no users of get_driver() or put_driver(), this
    patch (as1513) removes those routines completely.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Dmitry Torokhov &lt;dmitry.torokhov@gmail.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index e979cad75c6e..60e4f77ca662 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -153,34 +153,6 @@ int driver_add_kobj(struct device_driver *drv, struct kobject *kobj,
 }
 EXPORT_SYMBOL_GPL(driver_add_kobj);
 
-/**
- * get_driver - increment driver reference count.
- * @drv: driver.
- */
-struct device_driver *get_driver(struct device_driver *drv)
-{
-	if (drv) {
-		struct driver_private *priv;
-		struct kobject *kobj;
-
-		kobj = kobject_get(&amp;drv-&gt;p-&gt;kobj);
-		priv = to_driver(kobj);
-		return priv-&gt;driver;
-	}
-	return NULL;
-}
-EXPORT_SYMBOL_GPL(get_driver);
-
-/**
- * put_driver - decrement driver's refcount.
- * @drv: driver.
- */
-void put_driver(struct device_driver *drv)
-{
-	kobject_put(&amp;drv-&gt;p-&gt;kobj);
-}
-EXPORT_SYMBOL_GPL(put_driver);
-
 static int driver_add_groups(struct device_driver *drv,
 			     const struct attribute_group **groups)
 {
diff --git a/include/linux/device.h b/include/linux/device.h
index a782d7ff9e8b..d28bd8295677 100644
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@ -238,8 +238,6 @@ struct device_driver {
 extern int __must_check driver_register(struct device_driver *drv);
 extern void driver_unregister(struct device_driver *drv);
 
-extern struct device_driver *get_driver(struct device_driver *drv);
-extern void put_driver(struct device_driver *drv);
 extern struct device_driver *driver_find(const char *name,
 					 struct bus_type *bus);
 extern int driver_probe_done(void);</pre><hr><pre>commit f3ff9247088a0af0c192a28908dab76ff3d8871f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jan 24 13:35:24 2012 -0500

    Remove useless get_driver()/put_driver() calls
    
    As part of the removal of get_driver()/put_driver(), this patch
    (as1512) gets rid of various useless and unnecessary calls in several
    drivers.  In some cases it may be desirable to pin the driver by
    calling try_module_get(), but that can be done later.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: "David S. Miller" &lt;davem@davemloft.net&gt;
    CC: Konrad Rzeszutek Wilk &lt;konrad.wilk@oracle.com&gt;
    CC: Michael Buesch &lt;m@bues.ch&gt;
    CC: Joerg Roedel &lt;joerg.roedel@amd.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/net/phy/phy_device.c b/drivers/net/phy/phy_device.c
index f320f466f03b..e8c42d6a7d1c 100644
--- a/drivers/net/phy/phy_device.c
+++ b/drivers/net/phy/phy_device.c
@@ -915,9 +915,7 @@ static int phy_probe(struct device *dev)
 
 	phydev = to_phy_device(dev);
 
-	/* Make sure the driver is held.
-	 * XXX -- Is this correct? */
-	drv = get_driver(phydev-&gt;dev.driver);
+	drv = phydev-&gt;dev.driver;
 	phydrv = to_phy_driver(drv);
 	phydev-&gt;drv = phydrv;
 
@@ -957,8 +955,6 @@ static int phy_remove(struct device *dev)
 
 	if (phydev-&gt;drv-&gt;remove)
 		phydev-&gt;drv-&gt;remove(phydev);
-
-	put_driver(dev-&gt;driver);
 	phydev-&gt;drv = NULL;
 
 	return 0;
diff --git a/drivers/pci/xen-pcifront.c b/drivers/pci/xen-pcifront.c
index 7cf3d2fcf56a..6f819988a8da 100644
--- a/drivers/pci/xen-pcifront.c
+++ b/drivers/pci/xen-pcifront.c
@@ -593,7 +593,7 @@ static pci_ers_result_t pcifront_common_process(int cmd,
 	}
 	pdrv = pcidev-&gt;driver;
 
-	if (get_driver(&amp;pdrv-&gt;driver)) {
+	if (pdrv-&gt;driver) {
 		if (pdrv-&gt;err_handler &amp;&amp; pdrv-&gt;err_handler-&gt;error_detected) {
 			dev_dbg(&amp;pcidev-&gt;dev,
 				"trying to call AER service\n");
@@ -623,7 +623,6 @@ static pci_ers_result_t pcifront_common_process(int cmd,
 				}
 			}
 		}
-		put_driver(&amp;pdrv-&gt;driver);
 	}
 	if (!flag)
 		result = PCI_ERS_RESULT_NONE;
diff --git a/drivers/ssb/main.c b/drivers/ssb/main.c
index bb6317fb925c..ff109ae94767 100644
--- a/drivers/ssb/main.c
+++ b/drivers/ssb/main.c
@@ -140,19 +140,6 @@ static void ssb_device_put(struct ssb_device *dev)
 		put_device(dev-&gt;dev);
 }
 
-static inline struct ssb_driver *ssb_driver_get(struct ssb_driver *drv)
-{
-	if (drv)
-		get_driver(&amp;drv-&gt;drv);
-	return drv;
-}
-
-static inline void ssb_driver_put(struct ssb_driver *drv)
-{
-	if (drv)
-		put_driver(&amp;drv-&gt;drv);
-}
-
 static int ssb_device_resume(struct device *dev)
 {
 	struct ssb_device *ssb_dev = dev_to_ssb_dev(dev);
@@ -250,11 +237,9 @@ int ssb_devices_freeze(struct ssb_bus *bus, struct ssb_freeze_context *ctx)
 			ssb_device_put(sdev);
 			continue;
 		}
-		sdrv = ssb_driver_get(drv_to_ssb_drv(sdev-&gt;dev-&gt;driver));
-		if (!sdrv || SSB_WARN_ON(!sdrv-&gt;remove)) {
-			ssb_device_put(sdev);
+		sdrv = drv_to_ssb_drv(sdev-&gt;dev-&gt;driver);
+		if (SSB_WARN_ON(!sdrv-&gt;remove))
 			continue;
-		}
 		sdrv-&gt;remove(sdev);
 		ctx-&gt;device_frozen[i] = 1;
 	}
@@ -293,7 +278,6 @@ int ssb_devices_thaw(struct ssb_freeze_context *ctx)
 				   dev_name(sdev-&gt;dev));
 			result = err;
 		}
-		ssb_driver_put(sdrv);
 		ssb_device_put(sdev);
 	}
 
diff --git a/lib/dma-debug.c b/lib/dma-debug.c
index fea790a2b176..13ef2338be41 100644
--- a/lib/dma-debug.c
+++ b/lib/dma-debug.c
@@ -170,7 +170,7 @@ static bool driver_filter(struct device *dev)
 		return false;
 
 	/* driver filter on but not yet initialized */
-	drv = get_driver(dev-&gt;driver);
+	drv = dev-&gt;driver;
 	if (!drv)
 		return false;
 
@@ -185,7 +185,6 @@ static bool driver_filter(struct device *dev)
 	}
 
 	read_unlock_irqrestore(&amp;driver_name_lock, flags);
-	put_driver(drv);
 
 	return ret;
 }</pre><hr><pre>commit cef9bc56e1e944afd11f96de569657117a138c6d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jan 24 13:34:41 2012 -0500

    Dynamic ID addition doesn't need get_driver()
    
    As part of the removal of get_driver()/put_driver(), this patch
    (as1511) changes all the places that add dynamic IDs for drivers.
    Since these additions are done by writing to the drivers' sysfs
    attribute files, and the attributes are removed when the drivers are
    unregistered, there is no reason to take an extra reference to the
    drivers.
    
    The one exception is the pci-stub driver, which calls pci_add_dynid()
    as part of its registration.  But again, there's no reason to take an
    extra reference here, because the driver can't be unloaded while it is
    being registered.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Dmitry Torokhov &lt;dmitry.torokhov@gmail.com&gt;
    CC: Jiri Kosina &lt;jkosina@suse.cz&gt;
    CC: Jesse Barnes &lt;jbarnes@virtuousgeek.org&gt;
    CC: Dominik Brodowski &lt;linux@dominikbrodowski.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/hid/hid-core.c b/drivers/hid/hid-core.c
index af08ce7207d9..bce53fa0e166 100644
--- a/drivers/hid/hid-core.c
+++ b/drivers/hid/hid-core.c
@@ -1619,11 +1619,7 @@ static ssize_t store_new_id(struct device_driver *drv, const char *buf,
 	list_add_tail(&amp;dynid-&gt;list, &amp;hdrv-&gt;dyn_list);
 	spin_unlock(&amp;hdrv-&gt;dyn_lock);
 
-	ret = 0;
-	if (get_driver(&amp;hdrv-&gt;driver)) {
-		ret = driver_attach(&amp;hdrv-&gt;driver);
-		put_driver(&amp;hdrv-&gt;driver);
-	}
+	ret = driver_attach(&amp;hdrv-&gt;driver);
 
 	return ret ? : count;
 }
diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 3623d65f8b86..ff540477fe8b 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -72,9 +72,7 @@ int pci_add_dynid(struct pci_driver *drv,
 	list_add_tail(&amp;dynid-&gt;node, &amp;drv-&gt;dynids.list);
 	spin_unlock(&amp;drv-&gt;dynids.lock);
 
-	get_driver(&amp;drv-&gt;driver);
 	retval = driver_attach(&amp;drv-&gt;driver);
-	put_driver(&amp;drv-&gt;driver);
 
 	return retval;
 }
diff --git a/drivers/pcmcia/ds.c b/drivers/pcmcia/ds.c
index 749c2a16012c..059699f6363d 100644
--- a/drivers/pcmcia/ds.c
+++ b/drivers/pcmcia/ds.c
@@ -127,10 +127,7 @@ pcmcia_store_new_id(struct device_driver *driver, const char *buf, size_t count)
 	list_add_tail(&amp;dynid-&gt;node, &amp;pdrv-&gt;dynids.list);
 	mutex_unlock(&amp;pdrv-&gt;dynids.lock);
 
-	if (get_driver(&amp;pdrv-&gt;drv)) {
-		retval = driver_attach(&amp;pdrv-&gt;drv);
-		put_driver(&amp;pdrv-&gt;drv);
-	}
+	retval = driver_attach(&amp;pdrv-&gt;drv);
 
 	if (retval)
 		return retval;
diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index d40ff9568813..54c493b4226b 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -71,10 +71,7 @@ ssize_t usb_store_new_id(struct usb_dynids *dynids,
 	list_add_tail(&amp;dynid-&gt;node, &amp;dynids-&gt;list);
 	spin_unlock(&amp;dynids-&gt;lock);
 
-	if (get_driver(driver)) {
-		retval = driver_attach(driver);
-		put_driver(driver);
-	}
+	retval = driver_attach(driver);
 
 	if (retval)
 		return retval;</pre>
    <div class="pagination">
        <a href='2_51.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><span>[52]</span><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_53.html'>Next&gt;&gt;</a>
    <div>
</body>
