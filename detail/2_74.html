<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_73.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><span>[74]</span><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_75.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit e9238221d3fef990e2fd01702ebe5af90dda52a2
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 22 14:44:17 2009 -0400

    USB: dummy-hcd: accept mismatch between wLength and transfer length
    
    This patch (as1269) fixes a bug in the way dummy_hcd handles control
    URBs.  Currently it returns a -EOVERFLOW error if the wLength value in
    the setup packet is different from the URB's transfer_buffer_length.
    
    Other host controller drivers don't do this.  There's no reason the
    two length values have to be equal, and in fact they sometimes aren't
    -- a driver might set the transfer length to the maxpacket value in
    order to handle buggy devices that don't respect wLength.
    
    This patch simply removes the unnecessary check and error return.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index a56b24d305f8..5e0966485188 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -1306,11 +1306,6 @@ static void dummy_timer (unsigned long _dum)
 			setup = *(struct usb_ctrlrequest*) urb-&gt;setup_packet;
 			w_index = le16_to_cpu(setup.wIndex);
 			w_value = le16_to_cpu(setup.wValue);
-			if (le16_to_cpu(setup.wLength) !=
-					urb-&gt;transfer_buffer_length) {
-				status = -EOVERFLOW;
-				goto return_urb;
-			}
 
 			/* paranoia, in case of stale queued data */
 			list_for_each_entry (req, &amp;ep-&gt;queue, queue) {</pre><hr><pre>commit 527101ce6a96c037a2555aa43222faa6fdd21e97
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 22 14:42:54 2009 -0400

    USB: don't lose mode switch events on suspended devices
    
    This patch (as1268) changes the way usbcore handles child devices that
    undergo a disconnection and reconnection while the parent hub is
    suspended.  Currently, if the child isn't enabled for remote wakeup we
    leave it alone, figuring that it will go through a reset-resume when
    somebody tries to use it.
    
    However this isn't a good approach if the reason for the disconnection
    is that the child decided to switch modes or in some other way alter
    its descriptors.  In that case we want to re-enumerate it as soon as
    possible, not wait until somebody forces a reset-resume.
    
    To resolve the issue, this patch treats reconnected suspended child
    devices as though they had requested a remote wakeup, even if they
    weren't enabled for it.  The mode switch or descriptor change will be
    detected during the reset part of the reset-resume, and the device
    will be re-enumerated immediately.
    
    The disadvantage of this change is that it will cause autosuspended
    devices to be resumed when the computer wakes up from a system sleep
    during which the root hub was reset or lost power.  This shouldn't
    matter much; some people would even argue that autosuspended devices
    should _always_ be resumed when the system wakes up!
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: "Yang Fei-AFY095" &lt;fei.yang@motorola.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 645686a14214..a880516020f3 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2932,14 +2932,7 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 			/* For a suspended device, treat this as a
 			 * remote wakeup event.
 			 */
-			if (udev-&gt;do_remote_wakeup)
-				status = remote_wakeup(udev);
-
-			/* Otherwise leave it be; devices can't tell the
-			 * difference between suspended and disabled.
-			 */
-			else
-				status = 0;
+			status = remote_wakeup(udev);
 #endif
 
 		} else {</pre><hr><pre>commit 25118084ef03f4fc314ab33ef6a9d9271d0e616a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 22 14:41:18 2009 -0400

    USB: check for hub driver not bound to root hub device
    
    This patch (as1267) changes usb_kick_khubd() and hdev_to_hub() to make
    them more resilient against situations where a hub device isn't bound
    to the hub driver.  The code assumes that if a root hub was
    successfully registered then it must be bound to the hub driver.
    
    But this assumption can fail if the user manually unbinds the hub
    driver, or more importantly, if the host controller dies causing
    usb_set_configuration to fail.
    
    To protect against these possibilities, make hdev_to_hub() check that
    the hub device is configured before dereferencing the active
    configuration, and make usb_kick_khubd() check that the pointer to the
    hub's private data structure isn't NULL.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 69e3a966a4b7..645686a14214 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -163,8 +163,10 @@ static inline char *portspeed(int portstatus)
 }
 
 /* Note that hdev or one of its children must be locked! */
-static inline struct usb_hub *hdev_to_hub(struct usb_device *hdev)
+static struct usb_hub *hdev_to_hub(struct usb_device *hdev)
 {
+	if (!hdev || !hdev-&gt;actconfig)
+		return NULL;
 	return usb_get_intfdata(hdev-&gt;actconfig-&gt;interface[0]);
 }
 
@@ -385,8 +387,10 @@ static void kick_khubd(struct usb_hub *hub)
 
 void usb_kick_khubd(struct usb_device *hdev)
 {
-	/* FIXME: What if hdev isn't bound to the hub driver? */
-	kick_khubd(hdev_to_hub(hdev));
+	struct usb_hub *hub = hdev_to_hub(hdev);
+
+	if (hub)
+		kick_khubd(hub);
 }
 
 </pre><hr><pre>commit 4c6e8971cbe0148085fcf6fd30eaa3c39f8a8cce
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jun 29 11:02:04 2009 -0400

    USB: make the "usbfs_snoop" log more pertinent
    
    This patch (as1261) reduces the amount of detailed URB information
    logged by usbfs when the usbfs_snoop parameter is enabled.
    
    Currently we don't display the final status value for a completed URB.
    But we do display the entire data buffer twice: both before submission
    and after completion.  The after-completion display doesn't limit
    itself to the actual_length value.  But since usbmon is readily
    available in virtually all distributions, there's no reason for usbfs
    to print out any buffer contents at all!
    
    So this patch restricts the information to: userspace buffer pointer,
    endpoint number, type, and direction, length or actual_length, and
    timeout value or status.  Now everything fits neatly into a single
    line.
    
    Along with those changes, the patch also fixes the snoop output for
    the REAPURBNDELAY and REAPURBNDELAY32 ioctls.  The current version
    omits the 'N' from the names.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 165de5d59005..a1add776e89a 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -100,11 +100,15 @@ MODULE_PARM_DESC(usbfs_snoop, "true to log all usbfs traffic");
 			dev_info(dev , format , ## arg);	\
 	} while (0)
 
-#define USB_DEVICE_DEV		MKDEV(USB_DEVICE_MAJOR, 0)
+enum snoop_when {
+	SUBMIT, COMPLETE
+};
 
+#define USB_DEVICE_DEV		MKDEV(USB_DEVICE_MAJOR, 0)
 
 #define	MAX_USBFS_BUFFER_SIZE	16384
 
+
 static int connected(struct dev_state *ps)
 {
 	return (!list_empty(&amp;ps-&gt;list) &amp;&amp;
@@ -301,24 +305,42 @@ static struct async *async_getpending(struct dev_state *ps,
 	return NULL;
 }
 
-static void snoop_urb(struct urb *urb, void __user *userurb)
+static void snoop_urb(struct usb_device *udev,
+		void __user *userurb, int pipe, unsigned length,
+		int timeout_or_status, enum snoop_when when)
 {
-	unsigned j;
-	unsigned char *data = urb-&gt;transfer_buffer;
+	static const char *types[] = {"isoc", "int", "ctrl", "bulk"};
+	static const char *dirs[] = {"out", "in"};
+	int ep;
+	const char *t, *d;
 
 	if (!usbfs_snoop)
 		return;
 
-	dev_info(&amp;urb-&gt;dev-&gt;dev, "direction=%s\n",
-			usb_urb_dir_in(urb) ? "IN" : "OUT");
-	dev_info(&amp;urb-&gt;dev-&gt;dev, "userurb=%p\n", userurb);
-	dev_info(&amp;urb-&gt;dev-&gt;dev, "transfer_buffer_length=%u\n",
-		 urb-&gt;transfer_buffer_length);
-	dev_info(&amp;urb-&gt;dev-&gt;dev, "actual_length=%u\n", urb-&gt;actual_length);
-	dev_info(&amp;urb-&gt;dev-&gt;dev, "data: ");
-	for (j = 0; j &lt; urb-&gt;transfer_buffer_length; ++j)
-		printk("%02x ", data[j]);
-	printk("\n");
+	ep = usb_pipeendpoint(pipe);
+	t = types[usb_pipetype(pipe)];
+	d = dirs[!!usb_pipein(pipe)];
+
+	if (userurb) {		/* Async */
+		if (when == SUBMIT)
+			dev_info(&amp;udev-&gt;dev, "userurb %p, ep%d %s-%s, "
+					"length %u\n",
+					userurb, ep, t, d, length);
+		else
+			dev_info(&amp;udev-&gt;dev, "userurb %p, ep%d %s-%s, "
+					"actual_length %u status %d\n",
+					userurb, ep, t, d, length,
+					timeout_or_status);
+	} else {
+		if (when == SUBMIT)
+			dev_info(&amp;udev-&gt;dev, "ep%d %s-%s, length %u, "
+					"timeout %d\n",
+					ep, t, d, length, timeout_or_status);
+		else
+			dev_info(&amp;udev-&gt;dev, "ep%d %s-%s, actual_length %u, "
+					"status %d\n",
+					ep, t, d, length, timeout_or_status);
+	}
 }
 
 static void async_completed(struct urb *urb)
@@ -347,7 +369,8 @@ static void async_completed(struct urb *urb)
 		secid = as-&gt;secid;
 	}
 	snoop(&amp;urb-&gt;dev-&gt;dev, "urb complete\n");
-	snoop_urb(urb, as-&gt;userurb);
+	snoop_urb(urb-&gt;dev, as-&gt;userurb, urb-&gt;pipe, urb-&gt;actual_length,
+			as-&gt;status, COMPLETE);
 	spin_unlock(&amp;ps-&gt;lock);
 
 	if (signr)
@@ -690,7 +713,7 @@ static int proc_control(struct dev_state *ps, void __user *arg)
 	unsigned int tmo;
 	unsigned char *tbuf;
 	unsigned wLength;
-	int i, j, ret;
+	int i, pipe, ret;
 
 	if (copy_from_user(&amp;ctrl, arg, sizeof(ctrl)))
 		return -EFAULT;
@@ -710,24 +733,17 @@ static int proc_control(struct dev_state *ps, void __user *arg)
 			free_page((unsigned long)tbuf);
 			return -EINVAL;
 		}
-		snoop(&amp;dev-&gt;dev, "control read: bRequest=%02x "
-				"bRrequestType=%02x wValue=%04x "
-				"wIndex=%04x wLength=%04x\n",
-			ctrl.bRequest, ctrl.bRequestType, ctrl.wValue,
-				ctrl.wIndex, ctrl.wLength);
+		pipe = usb_rcvctrlpipe(dev, 0);
+		snoop_urb(dev, NULL, pipe, ctrl.wLength, tmo, SUBMIT);
 
 		usb_unlock_device(dev);
-		i = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), ctrl.bRequest,
+		i = usb_control_msg(dev, pipe, ctrl.bRequest,
 				    ctrl.bRequestType, ctrl.wValue, ctrl.wIndex,
 				    tbuf, ctrl.wLength, tmo);
 		usb_lock_device(dev);
+		snoop_urb(dev, NULL, pipe, max(i, 0), min(i, 0), COMPLETE);
+
 		if ((i &gt; 0) &amp;&amp; ctrl.wLength) {
-			if (usbfs_snoop) {
-				dev_info(&amp;dev-&gt;dev, "control read: data ");
-				for (j = 0; j &lt; i; ++j)
-					printk("%02x ", (u8)(tbuf)[j]);
-				printk("\n");
-			}
 			if (copy_to_user(ctrl.data, tbuf, i)) {
 				free_page((unsigned long)tbuf);
 				return -EFAULT;
@@ -740,22 +756,15 @@ static int proc_control(struct dev_state *ps, void __user *arg)
 				return -EFAULT;
 			}
 		}
-		snoop(&amp;dev-&gt;dev, "control write: bRequest=%02x "
-				"bRrequestType=%02x wValue=%04x "
-				"wIndex=%04x wLength=%04x\n",
-			ctrl.bRequest, ctrl.bRequestType, ctrl.wValue,
-				ctrl.wIndex, ctrl.wLength);
-		if (usbfs_snoop) {
-			dev_info(&amp;dev-&gt;dev, "control write: data: ");
-			for (j = 0; j &lt; ctrl.wLength; ++j)
-				printk("%02x ", (unsigned char)(tbuf)[j]);
-			printk("\n");
-		}
+		pipe = usb_sndctrlpipe(dev, 0);
+		snoop_urb(dev, NULL, pipe, ctrl.wLength, tmo, SUBMIT);
+
 		usb_unlock_device(dev);
 		i = usb_control_msg(dev, usb_sndctrlpipe(dev, 0), ctrl.bRequest,
 				    ctrl.bRequestType, ctrl.wValue, ctrl.wIndex,
 				    tbuf, ctrl.wLength, tmo);
 		usb_lock_device(dev);
+		snoop_urb(dev, NULL, pipe, max(i, 0), min(i, 0), COMPLETE);
 	}
 	free_page((unsigned long)tbuf);
 	if (i &lt; 0 &amp;&amp; i != -EPIPE) {
@@ -774,7 +783,7 @@ static int proc_bulk(struct dev_state *ps, void __user *arg)
 	unsigned int tmo, len1, pipe;
 	int len2;
 	unsigned char *tbuf;
-	int i, j, ret;
+	int i, ret;
 
 	if (copy_from_user(&amp;bulk, arg, sizeof(bulk)))
 		return -EFAULT;
@@ -801,18 +810,14 @@ static int proc_bulk(struct dev_state *ps, void __user *arg)
 			kfree(tbuf);
 			return -EINVAL;
 		}
-		snoop(&amp;dev-&gt;dev, "bulk read: len=0x%02x timeout=%04d\n",
-			bulk.len, bulk.timeout);
+		snoop_urb(dev, NULL, pipe, len1, tmo, SUBMIT);
+
 		usb_unlock_device(dev);
 		i = usb_bulk_msg(dev, pipe, tbuf, len1, &amp;len2, tmo);
 		usb_lock_device(dev);
+		snoop_urb(dev, NULL, pipe, len2, i, COMPLETE);
+
 		if (!i &amp;&amp; len2) {
-			if (usbfs_snoop) {
-				dev_info(&amp;dev-&gt;dev, "bulk read: data ");
-				for (j = 0; j &lt; len2; ++j)
-					printk("%02x ", (u8)(tbuf)[j]);
-				printk("\n");
-			}
 			if (copy_to_user(bulk.data, tbuf, len2)) {
 				kfree(tbuf);
 				return -EFAULT;
@@ -825,17 +830,12 @@ static int proc_bulk(struct dev_state *ps, void __user *arg)
 				return -EFAULT;
 			}
 		}
-		snoop(&amp;dev-&gt;dev, "bulk write: len=0x%02x timeout=%04d\n",
-			bulk.len, bulk.timeout);
-		if (usbfs_snoop) {
-			dev_info(&amp;dev-&gt;dev, "bulk write: data: ");
-			for (j = 0; j &lt; len1; ++j)
-				printk("%02x ", (unsigned char)(tbuf)[j]);
-			printk("\n");
-		}
+		snoop_urb(dev, NULL, pipe, len1, tmo, SUBMIT);
+
 		usb_unlock_device(dev);
 		i = usb_bulk_msg(dev, pipe, tbuf, len1, &amp;len2, tmo);
 		usb_lock_device(dev);
+		snoop_urb(dev, NULL, pipe, len2, i, COMPLETE);
 	}
 	kfree(tbuf);
 	if (i &lt; 0)
@@ -1053,13 +1053,6 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 			is_in = 0;
 			uurb-&gt;endpoint &amp;= ~USB_DIR_IN;
 		}
-		snoop(&amp;ps-&gt;dev-&gt;dev, "control urb: bRequest=%02x "
-			"bRrequestType=%02x wValue=%04x "
-			"wIndex=%04x wLength=%04x\n",
-			dr-&gt;bRequest, dr-&gt;bRequestType,
-			__le16_to_cpup(&amp;dr-&gt;wValue),
-			__le16_to_cpup(&amp;dr-&gt;wIndex),
-			__le16_to_cpup(&amp;dr-&gt;wLength));
 		break;
 
 	case USBDEVFS_URB_TYPE_BULK:
@@ -1072,7 +1065,6 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 		uurb-&gt;number_of_packets = 0;
 		if (uurb-&gt;buffer_length &gt; MAX_USBFS_BUFFER_SIZE)
 			return -EINVAL;
-		snoop(&amp;ps-&gt;dev-&gt;dev, "bulk urb\n");
 		break;
 
 	case USBDEVFS_URB_TYPE_ISO:
@@ -1104,7 +1096,6 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 			return -EINVAL;
 		}
 		uurb-&gt;buffer_length = totlen;
-		snoop(&amp;ps-&gt;dev-&gt;dev, "iso urb\n");
 		break;
 
 	case USBDEVFS_URB_TYPE_INTERRUPT:
@@ -1113,7 +1104,6 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 			return -EINVAL;
 		if (uurb-&gt;buffer_length &gt; MAX_USBFS_BUFFER_SIZE)
 			return -EINVAL;
-		snoop(&amp;ps-&gt;dev-&gt;dev, "interrupt urb\n");
 		break;
 
 	default:
@@ -1200,11 +1190,14 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 			return -EFAULT;
 		}
 	}
-	snoop_urb(as-&gt;urb, as-&gt;userurb);
+	snoop_urb(ps-&gt;dev, as-&gt;userurb, as-&gt;urb-&gt;pipe,
+			as-&gt;urb-&gt;transfer_buffer_length, 0, SUBMIT);
 	async_newpending(as);
 	if ((ret = usb_submit_urb(as-&gt;urb, GFP_KERNEL))) {
 		dev_printk(KERN_DEBUG, &amp;ps-&gt;dev-&gt;dev,
 			   "usbfs: usb_submit_urb returned %d\n", ret);
+		snoop_urb(ps-&gt;dev, as-&gt;userurb, as-&gt;urb-&gt;pipe,
+				0, ret, COMPLETE);
 		async_removepending(as);
 		free_async(as);
 		return ret;
@@ -1670,7 +1663,7 @@ static int usbdev_ioctl(struct inode *inode, struct file *file,
 		break;
 
 	case USBDEVFS_REAPURBNDELAY32:
-		snoop(&amp;dev-&gt;dev, "%s: REAPURBDELAY32\n", __func__);
+		snoop(&amp;dev-&gt;dev, "%s: REAPURBNDELAY32\n", __func__);
 		ret = proc_reapurbnonblock_compat(ps, p);
 		break;
 
@@ -1691,7 +1684,7 @@ static int usbdev_ioctl(struct inode *inode, struct file *file,
 		break;
 
 	case USBDEVFS_REAPURBNDELAY:
-		snoop(&amp;dev-&gt;dev, "%s: REAPURBDELAY\n", __func__);
+		snoop(&amp;dev-&gt;dev, "%s: REAPURBNDELAY\n", __func__);
 		ret = proc_reapurbnonblock(ps, p);
 		break;
 </pre><hr><pre>commit ccf5b801cef4f9e2d708d3b87e91e2bc6abd5206
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jun 29 11:00:01 2009 -0400

    USB: make intf.pm_usage an atomic_t
    
    This patch (as1260) changes the pm_usage_cnt field in struct
    usb_interface from an int to an atomic_t.  This is so that drivers can
    invoke the usb_autopm_get_interface_async() and
    usb_autopm_put_interface_async() routines without locking and without
    fear of corrupting the pm_usage_cnt value.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 1bad4e5a6abb..1c976c141f33 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -235,7 +235,7 @@ static int usb_probe_interface(struct device *dev)
 		/* The interface should always appear to be in use
 		 * unless the driver suports autosuspend.
 		 */
-		intf-&gt;pm_usage_cnt = !(driver-&gt;supports_autosuspend);
+		atomic_set(&amp;intf-&gt;pm_usage_cnt, !driver-&gt;supports_autosuspend);
 
 		/* Carry out a deferred switch to altsetting 0 */
 		if (intf-&gt;needs_altsetting0) {
@@ -347,7 +347,7 @@ int usb_driver_claim_interface(struct usb_driver *driver,
 	usb_pm_lock(udev);
 	iface-&gt;condition = USB_INTERFACE_BOUND;
 	mark_active(iface);
-	iface-&gt;pm_usage_cnt = !(driver-&gt;supports_autosuspend);
+	atomic_set(&amp;iface-&gt;pm_usage_cnt, !driver-&gt;supports_autosuspend);
 	usb_pm_unlock(udev);
 
 	/* if interface was already added, bind now; else let
@@ -1068,7 +1068,7 @@ static int autosuspend_check(struct usb_device *udev, int reschedule)
 			intf = udev-&gt;actconfig-&gt;interface[i];
 			if (!is_active(intf))
 				continue;
-			if (intf-&gt;pm_usage_cnt &gt; 0)
+			if (atomic_read(&amp;intf-&gt;pm_usage_cnt) &gt; 0)
 				return -EBUSY;
 			if (intf-&gt;needs_remote_wakeup &amp;&amp;
 					!udev-&gt;do_remote_wakeup) {
@@ -1464,17 +1464,19 @@ static int usb_autopm_do_interface(struct usb_interface *intf,
 		status = -ENODEV;
 	else {
 		udev-&gt;auto_pm = 1;
-		intf-&gt;pm_usage_cnt += inc_usage_cnt;
+		atomic_add(inc_usage_cnt, &amp;intf-&gt;pm_usage_cnt);
 		udev-&gt;last_busy = jiffies;
-		if (inc_usage_cnt &gt;= 0 &amp;&amp; intf-&gt;pm_usage_cnt &gt; 0) {
+		if (inc_usage_cnt &gt;= 0 &amp;&amp;
+				atomic_read(&amp;intf-&gt;pm_usage_cnt) &gt; 0) {
 			if (udev-&gt;state == USB_STATE_SUSPENDED)
 				status = usb_resume_both(udev,
 						PMSG_AUTO_RESUME);
 			if (status != 0)
-				intf-&gt;pm_usage_cnt -= inc_usage_cnt;
+				atomic_sub(inc_usage_cnt, &amp;intf-&gt;pm_usage_cnt);
 			else
 				udev-&gt;last_busy = jiffies;
-		} else if (inc_usage_cnt &lt;= 0 &amp;&amp; intf-&gt;pm_usage_cnt &lt;= 0) {
+		} else if (inc_usage_cnt &lt;= 0 &amp;&amp;
+				atomic_read(&amp;intf-&gt;pm_usage_cnt) &lt;= 0) {
 			status = usb_suspend_both(udev, PMSG_AUTO_SUSPEND);
 		}
 	}
@@ -1519,7 +1521,7 @@ void usb_autopm_put_interface(struct usb_interface *intf)
 
 	status = usb_autopm_do_interface(intf, -1);
 	dev_vdbg(&amp;intf-&gt;dev, "%s: status %d cnt %d\n",
-			__func__, status, intf-&gt;pm_usage_cnt);
+			__func__, status, atomic_read(&amp;intf-&gt;pm_usage_cnt));
 }
 EXPORT_SYMBOL_GPL(usb_autopm_put_interface);
 
@@ -1547,10 +1549,10 @@ void usb_autopm_put_interface_async(struct usb_interface *intf)
 		status = -ENODEV;
 	} else {
 		udev-&gt;last_busy = jiffies;
-		--intf-&gt;pm_usage_cnt;
+		atomic_dec(&amp;intf-&gt;pm_usage_cnt);
 		if (udev-&gt;autosuspend_disabled || udev-&gt;autosuspend_delay &lt; 0)
 			status = -EPERM;
-		else if (intf-&gt;pm_usage_cnt &lt;= 0 &amp;&amp;
+		else if (atomic_read(&amp;intf-&gt;pm_usage_cnt) &lt;= 0 &amp;&amp;
 				!timer_pending(&amp;udev-&gt;autosuspend.timer)) {
 			queue_delayed_work(ksuspend_usb_wq, &amp;udev-&gt;autosuspend,
 					round_jiffies_up_relative(
@@ -1558,7 +1560,7 @@ void usb_autopm_put_interface_async(struct usb_interface *intf)
 		}
 	}
 	dev_vdbg(&amp;intf-&gt;dev, "%s: status %d cnt %d\n",
-			__func__, status, intf-&gt;pm_usage_cnt);
+			__func__, status, atomic_read(&amp;intf-&gt;pm_usage_cnt));
 }
 EXPORT_SYMBOL_GPL(usb_autopm_put_interface_async);
 
@@ -1602,7 +1604,7 @@ int usb_autopm_get_interface(struct usb_interface *intf)
 
 	status = usb_autopm_do_interface(intf, 1);
 	dev_vdbg(&amp;intf-&gt;dev, "%s: status %d cnt %d\n",
-			__func__, status, intf-&gt;pm_usage_cnt);
+			__func__, status, atomic_read(&amp;intf-&gt;pm_usage_cnt));
 	return status;
 }
 EXPORT_SYMBOL_GPL(usb_autopm_get_interface);
@@ -1630,10 +1632,14 @@ int usb_autopm_get_interface_async(struct usb_interface *intf)
 		status = -ENODEV;
 	else if (udev-&gt;autoresume_disabled)
 		status = -EPERM;
-	else if (++intf-&gt;pm_usage_cnt &gt; 0 &amp;&amp; udev-&gt;state == USB_STATE_SUSPENDED)
-		queue_work(ksuspend_usb_wq, &amp;udev-&gt;autoresume);
+	else {
+		atomic_inc(&amp;intf-&gt;pm_usage_cnt);
+		if (atomic_read(&amp;intf-&gt;pm_usage_cnt) &gt; 0 &amp;&amp;
+				udev-&gt;state == USB_STATE_SUSPENDED)
+			queue_work(ksuspend_usb_wq, &amp;udev-&gt;autoresume);
+	}
 	dev_vdbg(&amp;intf-&gt;dev, "%s: status %d cnt %d\n",
-			__func__, status, intf-&gt;pm_usage_cnt);
+			__func__, status, atomic_read(&amp;intf-&gt;pm_usage_cnt));
 	return status;
 }
 EXPORT_SYMBOL_GPL(usb_autopm_get_interface_async);
@@ -1655,7 +1661,7 @@ int usb_autopm_set_interface(struct usb_interface *intf)
 
 	status = usb_autopm_do_interface(intf, 0);
 	dev_vdbg(&amp;intf-&gt;dev, "%s: status %d cnt %d\n",
-			__func__, status, intf-&gt;pm_usage_cnt);
+			__func__, status, atomic_read(&amp;intf-&gt;pm_usage_cnt));
 	return status;
 }
 EXPORT_SYMBOL_GPL(usb_autopm_set_interface);
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index cb54420ed583..69e3a966a4b7 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -373,7 +373,7 @@ static void kick_khubd(struct usb_hub *hub)
 	unsigned long	flags;
 
 	/* Suppress autosuspend until khubd runs */
-	to_usb_interface(hub-&gt;intfdev)-&gt;pm_usage_cnt = 1;
+	atomic_set(&amp;to_usb_interface(hub-&gt;intfdev)-&gt;pm_usage_cnt, 1);
 
 	spin_lock_irqsave(&amp;hub_event_lock, flags);
 	if (!hub-&gt;disconnected &amp;&amp; list_empty(&amp;hub-&gt;event_list)) {
@@ -678,7 +678,8 @@ static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)
 					msecs_to_jiffies(delay));
 
 			/* Suppress autosuspend until init is done */
-			to_usb_interface(hub-&gt;intfdev)-&gt;pm_usage_cnt = 1;
+			atomic_set(&amp;to_usb_interface(hub-&gt;intfdev)-&gt;
+					pm_usage_cnt, 1);
 			return;		/* Continues at init2: below */
 		} else {
 			hub_power_on(hub, true);
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 3b45a0d27b80..a34fa89f1474 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -195,7 +195,7 @@ struct usb_interface {
 
 	struct device dev;		/* interface specific device info */
 	struct device *usb_dev;
-	int pm_usage_cnt;		/* usage counter for autosuspend */
+	atomic_t pm_usage_cnt;		/* usage counter for autosuspend */
 	struct work_struct reset_ws;	/* for resets in atomic context */
 };
 #define	to_usb_interface(d) container_of(d, struct usb_interface, dev)
@@ -551,13 +551,13 @@ extern void usb_autopm_put_interface_async(struct usb_interface *intf);
 
 static inline void usb_autopm_enable(struct usb_interface *intf)
 {
-	intf-&gt;pm_usage_cnt = 0;
+	atomic_set(&amp;intf-&gt;pm_usage_cnt, 0);
 	usb_autopm_set_interface(intf);
 }
 
 static inline void usb_autopm_disable(struct usb_interface *intf)
 {
-	intf-&gt;pm_usage_cnt = 1;
+	atomic_set(&amp;intf-&gt;pm_usage_cnt, 1);
 	usb_autopm_set_interface(intf);
 }
 </pre><hr><pre>commit 7cbe5dca399a50ce8aa74314b1d276e2fb904e1b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jun 29 10:56:54 2009 -0400

    USB: add API for userspace drivers to "claim" ports
    
    This patch (as1258) implements a feature that users have been asking
    for: It gives programs the ability to "claim" a port on a hub, via a
    new usbfs ioctl.  A device plugged into a "claimed" port will not be
    touched by the kernel beyond the immediate necessities of
    initialization and enumeration.
    
    In particular, when a device is plugged into a "claimed" port, the
    kernel will not select and install a configuration.  And when a config
    is installed by usbfs or sysfs, the kernel will not probe any drivers
    for any of the interfaces.  (However the kernel will fetch various
    string descriptors during enumeration.  One could argue that this
    isn't really necessary, but the strings are exported in sysfs.)
    
    The patch does not guarantee exclusive access to these devices; it is
    still possible for more than one program to open the device file
    concurrently.  Programs are responsible for coordinating access among
    themselves.
    
    A demonstration program showing how to use the new interface can be
    found in an attachment to
    
            http://marc.info/?l=linux-usb&amp;m=124345857431452&amp;w=2
    
    The patch also makes a small simplification to the hub driver,
    replacing a bunch of more-or-less useless variants of "out of memory"
    with a single message.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 4247eccf858c..165de5d59005 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -52,6 +52,7 @@
 
 #include "hcd.h"	/* for usbcore internals */
 #include "usb.h"
+#include "hub.h"
 
 #define USB_MAXBUS			64
 #define USB_DEVICE_MAX			USB_MAXBUS * 128
@@ -655,6 +656,7 @@ static int usbdev_release(struct inode *inode, struct file *file)
 	struct async *as;
 
 	usb_lock_device(dev);
+	usb_hub_release_all_ports(dev, ps);
 
 	/* Protect against simultaneous open */
 	mutex_lock(&amp;usbfs_mutex);
@@ -1548,6 +1550,29 @@ static int proc_ioctl_compat(struct dev_state *ps, compat_uptr_t arg)
 }
 #endif
 
+static int proc_claim_port(struct dev_state *ps, void __user *arg)
+{
+	unsigned portnum;
+	int rc;
+
+	if (get_user(portnum, (unsigned __user *) arg))
+		return -EFAULT;
+	rc = usb_hub_claim_port(ps-&gt;dev, portnum, ps);
+	if (rc == 0)
+		snoop(&amp;ps-&gt;dev-&gt;dev, "port %d claimed by process %d: %s\n",
+			portnum, task_pid_nr(current), current-&gt;comm);
+	return rc;
+}
+
+static int proc_release_port(struct dev_state *ps, void __user *arg)
+{
+	unsigned portnum;
+
+	if (get_user(portnum, (unsigned __user *) arg))
+		return -EFAULT;
+	return usb_hub_release_port(ps-&gt;dev, portnum, ps);
+}
+
 /*
  * NOTE:  All requests here that have interface numbers as parameters
  * are assuming that somehow the configuration has been prevented from
@@ -1689,6 +1714,16 @@ static int usbdev_ioctl(struct inode *inode, struct file *file,
 		snoop(&amp;dev-&gt;dev, "%s: IOCTL\n", __func__);
 		ret = proc_ioctl_default(ps, p);
 		break;
+
+	case USBDEVFS_CLAIM_PORT:
+		snoop(&amp;dev-&gt;dev, "%s: CLAIM_PORT\n", __func__);
+		ret = proc_claim_port(ps, p);
+		break;
+
+	case USBDEVFS_RELEASE_PORT:
+		snoop(&amp;dev-&gt;dev, "%s: RELEASE_PORT\n", __func__);
+		ret = proc_release_port(ps, p);
+		break;
 	}
 	usb_unlock_device(dev);
 	if (ret &gt;= 0)
diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 69e5773abfce..1bad4e5a6abb 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -207,6 +207,9 @@ static int usb_probe_interface(struct device *dev)
 
 	intf-&gt;needs_binding = 0;
 
+	if (usb_device_is_owned(udev))
+		return -ENODEV;
+
 	if (udev-&gt;authorized == 0) {
 		dev_err(&amp;intf-&gt;dev, "Device is not authorized for usage\n");
 		return -ENODEV;
diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index 30ecac3af15a..05e6d313961e 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -158,7 +158,9 @@ static int generic_probe(struct usb_device *udev)
 	/* Choose and set the configuration.  This registers the interfaces
 	 * with the driver core and lets interface drivers bind to them.
 	 */
-	if (udev-&gt;authorized == 0)
+	if (usb_device_is_owned(udev))
+		;		/* Don't configure if the device is owned */
+	else if (udev-&gt;authorized == 0)
 		dev_err(&amp;udev-&gt;dev, "Device is not authorized for usage\n");
 	else {
 		c = usb_choose_configuration(udev);
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 71f86c60d83c..cb54420ed583 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -78,6 +78,7 @@ struct usb_hub {
 	u8			indicator[USB_MAXCHILDREN];
 	struct delayed_work	leds;
 	struct delayed_work	init_work;
+	void			**port_owners;
 };
 
 
@@ -860,19 +861,17 @@ static int hub_configure(struct usb_hub *hub,
 	u16 wHubCharacteristics;
 	unsigned int pipe;
 	int maxp, ret;
-	char *message;
+	char *message = "out of memory";
 
 	hub-&gt;buffer = usb_buffer_alloc(hdev, sizeof(*hub-&gt;buffer), GFP_KERNEL,
 			&amp;hub-&gt;buffer_dma);
 	if (!hub-&gt;buffer) {
-		message = "can't allocate hub irq buffer";
 		ret = -ENOMEM;
 		goto fail;
 	}
 
 	hub-&gt;status = kmalloc(sizeof(*hub-&gt;status), GFP_KERNEL);
 	if (!hub-&gt;status) {
-		message = "can't kmalloc hub status buffer";
 		ret = -ENOMEM;
 		goto fail;
 	}
@@ -880,7 +879,6 @@ static int hub_configure(struct usb_hub *hub,
 
 	hub-&gt;descriptor = kmalloc(sizeof(*hub-&gt;descriptor), GFP_KERNEL);
 	if (!hub-&gt;descriptor) {
-		message = "can't kmalloc hub descriptor";
 		ret = -ENOMEM;
 		goto fail;
 	}
@@ -904,6 +902,12 @@ static int hub_configure(struct usb_hub *hub,
 	dev_info (hub_dev, "%d port%s detected\n", hdev-&gt;maxchild,
 		(hdev-&gt;maxchild == 1) ? "" : "s");
 
+	hub-&gt;port_owners = kzalloc(hdev-&gt;maxchild * sizeof(void *), GFP_KERNEL);
+	if (!hub-&gt;port_owners) {
+		ret = -ENOMEM;
+		goto fail;
+	}
+
 	wHubCharacteristics = le16_to_cpu(hub-&gt;descriptor-&gt;wHubCharacteristics);
 
 	if (wHubCharacteristics &amp; HUB_CHAR_COMPOUND) {
@@ -1082,7 +1086,6 @@ static int hub_configure(struct usb_hub *hub,
 
 	hub-&gt;urb = usb_alloc_urb(0, GFP_KERNEL);
 	if (!hub-&gt;urb) {
-		message = "couldn't allocate interrupt urb";
 		ret = -ENOMEM;
 		goto fail;
 	}
@@ -1131,11 +1134,13 @@ static void hub_disconnect(struct usb_interface *intf)
 	hub_quiesce(hub, HUB_DISCONNECT);
 
 	usb_set_intfdata (intf, NULL);
+	hub-&gt;hdev-&gt;maxchild = 0;
 
 	if (hub-&gt;hdev-&gt;speed == USB_SPEED_HIGH)
 		highspeed_hubs--;
 
 	usb_free_urb(hub-&gt;urb);
+	kfree(hub-&gt;port_owners);
 	kfree(hub-&gt;descriptor);
 	kfree(hub-&gt;status);
 	usb_buffer_free(hub-&gt;hdev, sizeof(*hub-&gt;buffer), hub-&gt;buffer,
@@ -1250,6 +1255,79 @@ hub_ioctl(struct usb_interface *intf, unsigned int code, void *user_data)
 	}
 }
 
+/*
+ * Allow user programs to claim ports on a hub.  When a device is attached
+ * to one of these "claimed" ports, the program will "own" the device.
+ */
+static int find_port_owner(struct usb_device *hdev, unsigned port1,
+		void ***ppowner)
+{
+	if (hdev-&gt;state == USB_STATE_NOTATTACHED)
+		return -ENODEV;
+	if (port1 == 0 || port1 &gt; hdev-&gt;maxchild)
+		return -EINVAL;
+
+	/* This assumes that devices not managed by the hub driver
+	 * will always have maxchild equal to 0.
+	 */
+	*ppowner = &amp;(hdev_to_hub(hdev)-&gt;port_owners[port1 - 1]);
+	return 0;
+}
+
+/* In the following three functions, the caller must hold hdev's lock */
+int usb_hub_claim_port(struct usb_device *hdev, unsigned port1, void *owner)
+{
+	int rc;
+	void **powner;
+
+	rc = find_port_owner(hdev, port1, &amp;powner);
+	if (rc)
+		return rc;
+	if (*powner)
+		return -EBUSY;
+	*powner = owner;
+	return rc;
+}
+
+int usb_hub_release_port(struct usb_device *hdev, unsigned port1, void *owner)
+{
+	int rc;
+	void **powner;
+
+	rc = find_port_owner(hdev, port1, &amp;powner);
+	if (rc)
+		return rc;
+	if (*powner != owner)
+		return -ENOENT;
+	*powner = NULL;
+	return rc;
+}
+
+void usb_hub_release_all_ports(struct usb_device *hdev, void *owner)
+{
+	int n;
+	void **powner;
+
+	n = find_port_owner(hdev, 1, &amp;powner);
+	if (n == 0) {
+		for (; n &lt; hdev-&gt;maxchild; (++n, ++powner)) {
+			if (*powner == owner)
+				*powner = NULL;
+		}
+	}
+}
+
+/* The caller must hold udev's lock */
+bool usb_device_is_owned(struct usb_device *udev)
+{
+	struct usb_hub *hub;
+
+	if (udev-&gt;state == USB_STATE_NOTATTACHED || !udev-&gt;parent)
+		return false;
+	hub = hdev_to_hub(udev-&gt;parent);
+	return !!hub-&gt;port_owners[udev-&gt;portnum - 1];
+}
+
 
 static void recursively_mark_NOTATTACHED(struct usb_device *udev)
 {
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index c0e0ae2bb8e7..9a8b15e6377a 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -37,6 +37,13 @@ extern int usb_match_device(struct usb_device *dev,
 extern void usb_forced_unbind_intf(struct usb_interface *intf);
 extern void usb_rebind_intf(struct usb_interface *intf);
 
+extern int usb_hub_claim_port(struct usb_device *hdev, unsigned port,
+		void *owner);
+extern int usb_hub_release_port(struct usb_device *hdev, unsigned port,
+		void *owner);
+extern void usb_hub_release_all_ports(struct usb_device *hdev, void *owner);
+extern bool usb_device_is_owned(struct usb_device *udev);
+
 extern int  usb_hub_init(void);
 extern void usb_hub_cleanup(void);
 extern int usb_major_init(void);
diff --git a/include/linux/usbdevice_fs.h b/include/linux/usbdevice_fs.h
index 0044d9b4cb85..00ceebeb9e5c 100644
--- a/include/linux/usbdevice_fs.h
+++ b/include/linux/usbdevice_fs.h
@@ -175,4 +175,6 @@ struct usbdevfs_ioctl32 {
 #define USBDEVFS_CLEAR_HALT        _IOR('U', 21, unsigned int)
 #define USBDEVFS_DISCONNECT        _IO('U', 22)
 #define USBDEVFS_CONNECT           _IO('U', 23)
+#define USBDEVFS_CLAIM_PORT        _IOR('U', 24, unsigned int)
+#define USBDEVFS_RELEASE_PORT      _IOR('U', 25, unsigned int)
 #endif /* _LINUX_USBDEVICE_FS_H */</pre><hr><pre>commit 7bd032dc2793afcbaf4a350056768da84cdbd89b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Sep 4 15:29:59 2009 -0400

    USB serial: update the console driver
    
    This patch (as1292) modifies the USB serial console driver, to make it
    compatible with the recent changes to the USB serial core.  The most
    important change is that serial-&gt;disc_mutex now has to be unlocked
    following a successful call to usb_serial_get_by_index().
    
    Other less notable changes include:
    
            Use the requested port number instead of port 0 always.
    
            Prevent the serial device from being autosuspended.
    
            Use the ASYNCB_INITIALIZED flag bit to indicate when the
            port hardware has been initialized.
    
    In spite of these changes, there's no question that the USB serial
    console code is still a big hack.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/serial/console.c b/drivers/usb/serial/console.c
index be086e4c76b6..b22ac3258523 100644
--- a/drivers/usb/serial/console.c
+++ b/drivers/usb/serial/console.c
@@ -16,6 +16,7 @@
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/tty.h&gt;
 #include &lt;linux/console.h&gt;
+#include &lt;linux/serial.h&gt;
 #include &lt;linux/usb.h&gt;
 #include &lt;linux/usb/serial.h&gt;
 
@@ -63,7 +64,7 @@ static int usb_console_setup(struct console *co, char *options)
 	char *s;
 	struct usb_serial *serial;
 	struct usb_serial_port *port;
-	int retval = 0;
+	int retval;
 	struct tty_struct *tty = NULL;
 	struct ktermios *termios = NULL, dummy;
 
@@ -116,13 +117,17 @@ static int usb_console_setup(struct console *co, char *options)
 		return -ENODEV;
 	}
 
-	port = serial-&gt;port[0];
+	retval = usb_autopm_get_interface(serial-&gt;interface);
+	if (retval)
+		goto error_get_interface;
+
+	port = serial-&gt;port[co-&gt;index - serial-&gt;minor];
 	tty_port_tty_set(&amp;port-&gt;port, NULL);
 
 	info-&gt;port = port;
 
 	++port-&gt;port.count;
-	if (port-&gt;port.count == 1) {
+	if (!test_bit(ASYNCB_INITIALIZED, &amp;port-&gt;port.flags)) {
 		if (serial-&gt;type-&gt;set_termios) {
 			/*
 			 * allocate a fake tty so the driver can initialize
@@ -168,6 +173,7 @@ static int usb_console_setup(struct console *co, char *options)
 			kfree(termios);
 			kfree(tty);
 		}
+		set_bit(ASYNCB_INITIALIZED, &amp;port-&gt;port.flags);
 	}
 	/* Now that any required fake tty operations are completed restore
 	 * the tty port count */
@@ -175,18 +181,22 @@ static int usb_console_setup(struct console *co, char *options)
 	/* The console is special in terms of closing the device so
 	 * indicate this port is now acting as a system console. */
 	port-&gt;console = 1;
-	retval = 0;
 
-out:
+	mutex_unlock(&amp;serial-&gt;disc_mutex);
 	return retval;
-free_termios:
+
+ free_termios:
 	kfree(termios);
 	tty_port_tty_set(&amp;port-&gt;port, NULL);
-free_tty:
+ free_tty:
 	kfree(tty);
-reset_open_count:
+ reset_open_count:
 	port-&gt;port.count = 0;
-	goto out;
+	usb_autopm_put_interface(serial-&gt;interface);
+ error_get_interface:
+	usb_serial_put(serial);
+	mutex_unlock(&amp;serial-&gt;disc_mutex);
+	return retval;
 }
 
 static void usb_console_write(struct console *co,</pre><hr><pre>commit 320348c8d5c9b591282633ddb8959b42f7fc7a1c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 1 11:39:59 2009 -0400

    usb-serial: straighten out serial_open
    
    This patch (as1291) removes a bunch of code from serial_open(), things
    that were rendered unnecessary by earlier patches.  A missing spinlock
    is added to protect port-&gt;port.count, which needs to be incremented
    even if the open fails but not if the tty has gotten a hangup.  The
    test for whether the hardware has been initialized, based on the use
    count, is replaced by a more transparent test of the
    ASYNCB_INITIALIZED bit in the port flags.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/serial/usb-serial.c b/drivers/usb/serial/usb-serial.c
index 9a3258046c8c..9d7ca4868d37 100644
--- a/drivers/usb/serial/usb-serial.c
+++ b/drivers/usb/serial/usb-serial.c
@@ -245,55 +245,40 @@ static int serial_install(struct tty_driver *driver, struct tty_struct *tty)
 	return retval;
 }
 
-static int serial_open (struct tty_struct *tty, struct file *filp)
+static int serial_open(struct tty_struct *tty, struct file *filp)
 {
-	struct usb_serial *serial;
-	struct usb_serial_port *port;
-	int retval = 0;
-	int first = 0;
-
-	port = tty-&gt;driver_data;
-	serial = port-&gt;serial;
+	struct usb_serial_port *port = tty-&gt;driver_data;
+	struct usb_serial *serial = port-&gt;serial;
+	int retval;
 
 	dbg("%s - port %d", __func__, port-&gt;number);
 
-	if (mutex_lock_interruptible(&amp;port-&gt;mutex))
-		return -ERESTARTSYS;
-
-	++port-&gt;port.count;
+	spin_lock_irq(&amp;port-&gt;port.lock);
+	if (!tty_hung_up_p(filp))
+		++port-&gt;port.count;
+	spin_unlock_irq(&amp;port-&gt;port.lock);
 	tty_port_tty_set(&amp;port-&gt;port, tty);
 
-	/* If the console is attached, the device is already open */
-	if (port-&gt;port.count == 1 &amp;&amp; !port-&gt;console) {
-		first = 1;
+	/* Do the device-specific open only if the hardware isn't
+	 * already initialized.
+	 */
+	if (!test_bit(ASYNCB_INITIALIZED, &amp;port-&gt;port.flags)) {
+		if (mutex_lock_interruptible(&amp;port-&gt;mutex))
+			return -ERESTARTSYS;
 		mutex_lock(&amp;serial-&gt;disc_mutex);
-
-		/* only call the device specific open if this
-		 * is the first time the port is opened */
-		retval = serial-&gt;type-&gt;open(tty, port);
-		if (retval)
-			goto bailout_module_put;
+		if (serial-&gt;disconnected)
+			retval = -ENODEV;
+		else
+			retval = port-&gt;serial-&gt;type-&gt;open(tty, port);
 		mutex_unlock(&amp;serial-&gt;disc_mutex);
+		mutex_unlock(&amp;port-&gt;mutex);
+		if (retval)
+			return retval;
 		set_bit(ASYNCB_INITIALIZED, &amp;port-&gt;port.flags);
 	}
-	mutex_unlock(&amp;port-&gt;mutex);
+
 	/* Now do the correct tty layer semantics */
 	retval = tty_port_block_til_ready(&amp;port-&gt;port, tty, filp);
-	if (retval == 0) {
-		if (!first)
-			usb_serial_put(serial);
-		return 0;
-	}
-	mutex_lock(&amp;port-&gt;mutex);
-	if (first == 0)
-		goto bailout_mutex_unlock;
-	/* Undo the initial port actions */
-	mutex_lock(&amp;serial-&gt;disc_mutex);
-bailout_module_put:
-	mutex_unlock(&amp;serial-&gt;disc_mutex);
-bailout_mutex_unlock:
-	port-&gt;port.count = 0;
-	mutex_unlock(&amp;port-&gt;mutex);
 	return retval;
 }
 </pre><hr><pre>commit ff8324df1187b7280e507c976777df76c73a1ef1
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 1 11:39:51 2009 -0400

    usb-serial: add missing tests and debug lines
    
    This patch (as1290) adds some missing tests.  serial_down() isn't
    supposed to do anything if the hardware hasn't been initialized, and
    serial_close() isn't supposed to do anything if the tty has gotten a
    hangup (because serial_hangup() takes care of shutting down the
    hardware).
    
    The patch also updates and adds a few debugging lines.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/serial/usb-serial.c b/drivers/usb/serial/usb-serial.c
index 28125de7d902..9a3258046c8c 100644
--- a/drivers/usb/serial/usb-serial.c
+++ b/drivers/usb/serial/usb-serial.c
@@ -200,6 +200,8 @@ static int serial_install(struct tty_driver *driver, struct tty_struct *tty)
 	struct usb_serial_port *port;
 	int retval = -ENODEV;
 
+	dbg("%s", __func__);
+
 	serial = usb_serial_get_by_index(idx);
 	if (!serial)
 		return retval;
@@ -250,11 +252,11 @@ static int serial_open (struct tty_struct *tty, struct file *filp)
 	int retval = 0;
 	int first = 0;
 
-	dbg("%s", __func__);
-
 	port = tty-&gt;driver_data;
 	serial = port-&gt;serial;
 
+	dbg("%s - port %d", __func__, port-&gt;number);
+
 	if (mutex_lock_interruptible(&amp;port-&gt;mutex))
 		return -ERESTARTSYS;
 
@@ -315,6 +317,12 @@ static void serial_down(struct usb_serial_port *port)
 	if (port-&gt;console)
 		return;
 
+	/* Don't call the close method if the hardware hasn't been
+	 * initialized.
+	 */
+	if (!test_and_clear_bit(ASYNCB_INITIALIZED, &amp;port-&gt;port.flags))
+		return;
+
 	mutex_lock(&amp;port-&gt;mutex);
 	serial = port-&gt;serial;
 	owner = serial-&gt;type-&gt;driver.owner;
@@ -328,10 +336,11 @@ static void serial_down(struct usb_serial_port *port)
 static void serial_hangup(struct tty_struct *tty)
 {
 	struct usb_serial_port *port = tty-&gt;driver_data;
+
+	dbg("%s - port %d", __func__, port-&gt;number);
+
 	serial_down(port);
 	tty_port_hangup(&amp;port-&gt;port);
-	/* We must not free port yet - the USB serial layer depends on it's
-	   continued existence */
 }
 
 static void serial_close(struct tty_struct *tty, struct file *filp)
@@ -340,6 +349,8 @@ static void serial_close(struct tty_struct *tty, struct file *filp)
 
 	dbg("%s - port %d", __func__, port-&gt;number);
 
+	if (tty_hung_up_p(filp))
+		return;
 	if (tty_port_close_start(&amp;port-&gt;port, tty, filp) == 0)
 		return;
 	serial_down(port);
@@ -368,6 +379,8 @@ static void serial_release(struct tty_struct *tty)
 	if (port-&gt;console)
 		return;
 
+	dbg("%s - port %d", __func__, port-&gt;number);
+
 	/* Standard shutdown processing */
 	tty_shutdown(tty);
 </pre><hr><pre>commit 74556123e034c8337b69a3ebac2f3a5fc0a97032
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 1 11:39:40 2009 -0400

    usb-serial: rename subroutines
    
    This patch (as1289) renames serial_do_down() to serial_down() and
    serial_do_free() to serial_release().  It also adds a missing call to
    tty_shutdown() in serial_release().
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/serial/usb-serial.c b/drivers/usb/serial/usb-serial.c
index 1bc0a24b896b..28125de7d902 100644
--- a/drivers/usb/serial/usb-serial.c
+++ b/drivers/usb/serial/usb-serial.c
@@ -191,7 +191,7 @@ void usb_serial_put(struct usb_serial *serial)
  * This is the first place a new tty gets used.  Hence this is where we
  * acquire references to the usb_serial structure and the driver module,
  * where we store a pointer to the port, and where we do an autoresume.
- * All these actions are reversed in serial_do_free().
+ * All these actions are reversed in serial_release().
  */
 static int serial_install(struct tty_driver *driver, struct tty_struct *tty)
 {
@@ -296,13 +296,13 @@ static int serial_open (struct tty_struct *tty, struct file *filp)
 }
 
 /**
- * serial_do_down - shut down hardware
+ * serial_down - shut down hardware
  * @port: port to shut down
  *
  * Shut down a USB serial port unless it is the console.  We never
  * shut down the console hardware as it will always be in use.
  */
-static void serial_do_down(struct usb_serial_port *port)
+static void serial_down(struct usb_serial_port *port)
 {
 	struct usb_serial_driver *drv = port-&gt;serial-&gt;type;
 	struct usb_serial *serial;
@@ -328,7 +328,7 @@ static void serial_do_down(struct usb_serial_port *port)
 static void serial_hangup(struct tty_struct *tty)
 {
 	struct usb_serial_port *port = tty-&gt;driver_data;
-	serial_do_down(port);
+	serial_down(port);
 	tty_port_hangup(&amp;port-&gt;port);
 	/* We must not free port yet - the USB serial layer depends on it's
 	   continued existence */
@@ -342,13 +342,13 @@ static void serial_close(struct tty_struct *tty, struct file *filp)
 
 	if (tty_port_close_start(&amp;port-&gt;port, tty, filp) == 0)
 		return;
-	serial_do_down(port);
+	serial_down(port);
 	tty_port_close_end(&amp;port-&gt;port, tty);
 	tty_port_tty_set(&amp;port-&gt;port, NULL);
 }
 
 /**
- * serial_do_free - free resources post close/hangup
+ * serial_release - free resources post close/hangup
  * @port: port to free up
  *
  * Do the resource freeing and refcount dropping for the port.
@@ -356,7 +356,7 @@ static void serial_close(struct tty_struct *tty, struct file *filp)
  *
  * Called when the last tty kref is dropped.
  */
-static void serial_do_free(struct tty_struct *tty)
+static void serial_release(struct tty_struct *tty)
 {
 	struct usb_serial_port *port = tty-&gt;driver_data;
 	struct usb_serial *serial;
@@ -368,6 +368,9 @@ static void serial_do_free(struct tty_struct *tty)
 	if (port-&gt;console)
 		return;
 
+	/* Standard shutdown processing */
+	tty_shutdown(tty);
+
 	tty-&gt;driver_data = NULL;
 
 	serial = port-&gt;serial;
@@ -1204,7 +1207,7 @@ static const struct tty_operations serial_ops = {
 	.chars_in_buffer =	serial_chars_in_buffer,
 	.tiocmget =		serial_tiocmget,
 	.tiocmset =		serial_tiocmset,
-	.shutdown = 		serial_do_free,
+	.shutdown = 		serial_release,
 	.install = 		serial_install,
 	.proc_fops =		&amp;serial_proc_fops,
 };</pre>
    <div class="pagination">
        <a href='2_73.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><span>[74]</span><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_75.html'>Next&gt;&gt;</a>
    <div>
</body>
