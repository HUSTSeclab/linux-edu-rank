<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_123.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><span>[124]</span><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_125.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 9ea7290902abcf22f796e9aeae4dc2e71d3f7e67
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jun 23 14:25:34 2006 -0400

    [SCSI] SCSI core: Allow QUIESCE -&gt; CANCEL sdev transition
    
    We have to be able to remove SCSI devices even when they are suspended, so
    QUIESCE -&gt; CANCEL must be a legal state transition.  This patch (as727)
    adds the transition to the state machine.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
index 4c4add53d69b..68e0d7dbe6ce 100644
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@ -2026,6 +2026,7 @@ scsi_device_set_state(struct scsi_device *sdev, enum scsi_device_state state)
 		switch (oldstate) {
 		case SDEV_CREATED:
 		case SDEV_RUNNING:
+		case SDEV_QUIESCE:
 		case SDEV_OFFLINE:
 		case SDEV_BLOCK:
 			break;</pre><hr><pre>commit bbb1747d4e44ce49acc73daa8d66e5f6bd546f1b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sun Jun 25 05:47:15 2006 -0700

    [PATCH] Allow raw_notifier callouts to unregister themselves
    
    Since raw_notifier chains don't benefit from any centralized locking
    protections, they shouldn't suffer from the associated limitations.  Under
    some circumstances it might make sense for a raw_notifier callout routine
    to unregister itself from the notifier chain.  This patch (as678) changes
    the notifier core to allow for such things.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/kernel/sys.c b/kernel/sys.c
index 90930b28d2ca..7e0927bad713 100644
--- a/kernel/sys.c
+++ b/kernel/sys.c
@@ -137,14 +137,15 @@ static int __kprobes notifier_call_chain(struct notifier_block **nl,
 		unsigned long val, void *v)
 {
 	int ret = NOTIFY_DONE;
-	struct notifier_block *nb;
+	struct notifier_block *nb, *next_nb;
 
 	nb = rcu_dereference(*nl);
 	while (nb) {
+		next_nb = rcu_dereference(nb-&gt;next);
 		ret = nb-&gt;notifier_call(nb, val, v);
 		if ((ret &amp; NOTIFY_STOP_MASK) == NOTIFY_STOP_MASK)
 			break;
-		nb = rcu_dereference(nb-&gt;next);
+		nb = next_nb;
 	}
 	return ret;
 }</pre><hr><pre>commit d5681fe8110e1169902df37a8fd8bd01c2b7810e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jun 13 09:59:32 2006 -0400

    [PATCH] USB: unusual_devs entry for Nokia N80
    
    Here is a patch (as720) adding an unusual_devs entry for the Nokia N80
    mobile phone.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index 3ec17689b81c..543244d421c1 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -133,6 +133,14 @@ UNUSUAL_DEV(  0x0420, 0x0001, 0x0100, 0x0100,
 		US_SC_DEVICE, US_PR_DEVICE, NULL,
 		US_FL_IGNORE_RESIDUE ),
 
+/* Reported by Jiri Slaby &lt;jirislaby@gmail.com&gt; and
+ * Rene C. Castberg &lt;Rene@Castberg.org&gt; */
+UNUSUAL_DEV(  0x0421, 0x0446, 0x0100, 0x0100,
+		"Nokia",
+		"N80",
+		US_SC_DEVICE, US_PR_DEVICE, NULL,
+		US_FL_IGNORE_RESIDUE | US_FL_FIX_CAPACITY ),
+
 /* Reported by Olaf Hering &lt;olh@suse.de&gt; from novell bug #105878 */
 UNUSUAL_DEV(  0x0424, 0x0fdc, 0x0210, 0x0210,
 		"SMSC",</pre><hr><pre>commit c5e3b741a3fec6077a480aa65ded29d79ded8898
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jun 5 12:28:57 2006 -0400

    [PATCH] UHCI: Improve FSBR-off timing
    
    This patch (as707) improves the FSBR operation in uhci-hcd by turning it
    off more quickly when it isn't needed.  FSBR puts a noticeable load on a
    computer's PCI bus, so it should be disabled as soon as possible when it
    isn't in use.  The patch leaves it running for only 10 ms after the last
    URB stops using it, on the theory that this should be long enough for a
    driver to submit another URB if it wants keep FSBR going.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 025b969f95e8..7b48567622ef 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -497,9 +497,9 @@ static int uhci_start(struct usb_hcd *hcd)
 	hcd-&gt;uses_new_polling = 1;
 
 	spin_lock_init(&amp;uhci-&gt;lock);
-
+	setup_timer(&amp;uhci-&gt;fsbr_timer, uhci_fsbr_timeout,
+			(unsigned long) uhci);
 	INIT_LIST_HEAD(&amp;uhci-&gt;idle_qh_list);
-
 	init_waitqueue_head(&amp;uhci-&gt;waitqh);
 
 	if (DEBUG_CONFIGURED) {
@@ -675,6 +675,7 @@ static void uhci_stop(struct usb_hcd *hcd)
 	uhci_scan_schedule(uhci, NULL);
 	spin_unlock_irq(&amp;uhci-&gt;lock);
 
+	del_timer_sync(&amp;uhci-&gt;fsbr_timer);
 	release_uhci(uhci);
 }
 
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index 619d704f4e8f..108e3de2dc26 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -86,7 +86,7 @@
 
 /* When no queues need Full-Speed Bandwidth Reclamation,
  * delay this long before turning FSBR off */
-#define FSBR_OFF_DELAY		msecs_to_jiffies(400)
+#define FSBR_OFF_DELAY		msecs_to_jiffies(10)
 
 /* If a queue hasn't advanced after this much time, assume it is stuck */
 #define QH_WAIT_TIMEOUT		msecs_to_jiffies(200)
@@ -382,8 +382,6 @@ struct uhci_hcd {
 	__le32 *frame;
 	void **frame_cpu;		/* CPU's frame list */
 
-	unsigned long fsbr_jiffies;	/* Time when FSBR was last wanted */
-
 	enum uhci_rh_state rh_state;
 	unsigned long auto_stop_time;		/* When to AUTO_STOP */
 
@@ -400,6 +398,10 @@ struct uhci_hcd {
 						   need to be polled */
 	unsigned int is_initialized:1;		/* Data structure is usable */
 	unsigned int fsbr_is_on:1;		/* FSBR is turned on */
+	unsigned int fsbr_is_wanted:1;		/* Does any URB want FSBR? */
+	unsigned int fsbr_expiring:1;		/* FSBR is timing out */
+
+	struct timer_list fsbr_timer;		/* For turning off FBSR */
 
 	/* Support for port suspend/resume/reset */
 	unsigned long port_c_suspend;		/* Bit-arrays of ports */
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index b173d914d748..c9d72ac0a1d7 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -64,16 +64,30 @@ static void uhci_add_fsbr(struct uhci_hcd *uhci, struct urb *urb)
 		urbp-&gt;fsbr = 1;
 }
 
-static void uhci_qh_wants_fsbr(struct uhci_hcd *uhci, struct uhci_qh *qh)
+static void uhci_urbp_wants_fsbr(struct uhci_hcd *uhci, struct urb_priv *urbp)
 {
-	struct urb_priv *urbp =
-			list_entry(qh-&gt;queue.next, struct urb_priv, node);
-
 	if (urbp-&gt;fsbr) {
-		uhci-&gt;fsbr_jiffies = jiffies;
+		uhci-&gt;fsbr_is_wanted = 1;
 		if (!uhci-&gt;fsbr_is_on)
 			uhci_fsbr_on(uhci);
+		else if (uhci-&gt;fsbr_expiring) {
+			uhci-&gt;fsbr_expiring = 0;
+			del_timer(&amp;uhci-&gt;fsbr_timer);
+		}
+	}
+}
+
+static void uhci_fsbr_timeout(unsigned long _uhci)
+{
+	struct uhci_hcd *uhci = (struct uhci_hcd *) _uhci;
+	unsigned long flags;
+
+	spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
+	if (uhci-&gt;fsbr_expiring) {
+		uhci-&gt;fsbr_expiring = 0;
+		uhci_fsbr_off(uhci);
 	}
+	spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
 }
 
 
@@ -287,7 +301,7 @@ static int uhci_cleanup_queue(struct uhci_hcd *uhci, struct uhci_qh *qh,
 	if (qh-&gt;type == USB_ENDPOINT_XFER_ISOC) {
 		ret = (uhci-&gt;frame_number + uhci-&gt;is_stopped !=
 				qh-&gt;unlink_frame);
-		return ret;
+		goto done;
 	}
 
 	/* If the URB isn't first on its queue, adjust the link pointer
@@ -304,24 +318,26 @@ static int uhci_cleanup_queue(struct uhci_hcd *uhci, struct uhci_qh *qh,
 		td = list_entry(urbp-&gt;td_list.prev, struct uhci_td,
 				list);
 		ptd-&gt;link = td-&gt;link;
-		return ret;
+		goto done;
 	}
 
 	/* If the QH element pointer is UHCI_PTR_TERM then then currently
 	 * executing URB has already been unlinked, so this one isn't it. */
 	if (qh_element(qh) == UHCI_PTR_TERM)
-		return ret;
+		goto done;
 	qh-&gt;element = UHCI_PTR_TERM;
 
 	/* Control pipes have to worry about toggles */
 	if (qh-&gt;type == USB_ENDPOINT_XFER_CONTROL)
-		return ret;
+		goto done;
 
 	/* Save the next toggle value */
 	WARN_ON(list_empty(&amp;urbp-&gt;td_list));
 	td = list_entry(urbp-&gt;td_list.next, struct uhci_td, list);
 	qh-&gt;needs_fixup = 1;
 	qh-&gt;initial_toggle = uhci_toggle(td_token(td));
+
+done:
 	return ret;
 }
 
@@ -1175,7 +1191,7 @@ static int uhci_urb_enqueue(struct usb_hcd *hcd,
 	 * queue isn't stopped. */
 	if (qh-&gt;queue.next == &amp;urbp-&gt;node &amp;&amp; !qh-&gt;is_stopped) {
 		uhci_activate_qh(uhci, qh);
-		uhci_qh_wants_fsbr(uhci, qh);
+		uhci_urbp_wants_fsbr(uhci, urbp);
 	}
 	goto done;
 
@@ -1404,7 +1420,7 @@ static int uhci_advance_check(struct uhci_hcd *uhci, struct uhci_qh *qh)
 	unsigned status;
 
 	if (qh-&gt;type == USB_ENDPOINT_XFER_ISOC)
-		return ret;
+		goto done;
 
 	/* Treat an UNLINKING queue as though it hasn't advanced.
 	 * This is okay because reactivation will treat it as though
@@ -1427,21 +1443,24 @@ static int uhci_advance_check(struct uhci_hcd *uhci, struct uhci_qh *qh)
 			/* We're okay, the queue has advanced */
 			qh-&gt;wait_expired = 0;
 			qh-&gt;advance_jiffies = jiffies;
-			return ret;
+			goto done;
 		}
 		ret = 0;
 	}
 
 	/* The queue hasn't advanced; check for timeout */
-	if (!qh-&gt;wait_expired &amp;&amp; time_after(jiffies,
-			qh-&gt;advance_jiffies + QH_WAIT_TIMEOUT)) {
+	if (qh-&gt;wait_expired)
+		goto done;
+
+	if (time_after(jiffies, qh-&gt;advance_jiffies + QH_WAIT_TIMEOUT)) {
 
 		/* Detect the Intel bug and work around it */
 		if (qh-&gt;post_td &amp;&amp; qh_element(qh) ==
 				cpu_to_le32(qh-&gt;post_td-&gt;dma_handle)) {
 			qh-&gt;element = qh-&gt;post_td-&gt;link;
 			qh-&gt;advance_jiffies = jiffies;
-			return 1;
+			ret = 1;
+			goto done;
 		}
 
 		qh-&gt;wait_expired = 1;
@@ -1452,7 +1471,14 @@ static int uhci_advance_check(struct uhci_hcd *uhci, struct uhci_qh *qh)
 		 * starts moving again. */
 		if (urbp &amp;&amp; urbp-&gt;fsbr &amp;&amp; !(status &amp; TD_CTRL_IOC))
 			uhci_unlink_qh(uhci, qh);
+
+	} else {
+		/* Unmoving but not-yet-expired queues keep FSBR alive */
+		if (urbp)
+			uhci_urbp_wants_fsbr(uhci, urbp);
 	}
+
+done:
 	return ret;
 }
 
@@ -1472,6 +1498,7 @@ static void uhci_scan_schedule(struct uhci_hcd *uhci, struct pt_regs *regs)
 	uhci-&gt;scan_in_progress = 1;
 rescan:
 	uhci-&gt;need_rescan = 0;
+	uhci-&gt;fsbr_is_wanted = 0;
 
 	uhci_clear_next_interrupt(uhci);
 	uhci_get_current_frame_number(uhci);
@@ -1487,8 +1514,10 @@ static void uhci_scan_schedule(struct uhci_hcd *uhci, struct pt_regs *regs)
 
 			if (uhci_advance_check(uhci, qh)) {
 				uhci_scan_qh(uhci, qh, regs);
-				if (qh-&gt;state == QH_STATE_ACTIVE)
-					uhci_qh_wants_fsbr(uhci, qh);
+				if (qh-&gt;state == QH_STATE_ACTIVE) {
+					uhci_urbp_wants_fsbr(uhci,
+	list_entry(qh-&gt;queue.next, struct urb_priv, node));
+				}
 			}
 		}
 	}
@@ -1498,9 +1527,11 @@ static void uhci_scan_schedule(struct uhci_hcd *uhci, struct pt_regs *regs)
 		goto rescan;
 	uhci-&gt;scan_in_progress = 0;
 
-	if (uhci-&gt;fsbr_is_on &amp;&amp; time_after(jiffies,
-			uhci-&gt;fsbr_jiffies + FSBR_OFF_DELAY))
-		uhci_fsbr_off(uhci);
+	if (uhci-&gt;fsbr_is_on &amp;&amp; !uhci-&gt;fsbr_is_wanted &amp;&amp;
+			!uhci-&gt;fsbr_expiring) {
+		uhci-&gt;fsbr_expiring = 1;
+		mod_timer(&amp;uhci-&gt;fsbr_timer, jiffies + FSBR_OFF_DELAY);
+	}
 
 	if (list_empty(&amp;uhci-&gt;skel_unlink_qh-&gt;node))
 		uhci_clear_next_interrupt(uhci);</pre><hr><pre>commit e323de46e83b6df2f330651907ac823f8d53308a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jun 5 12:21:30 2006 -0400

    [PATCH] UHCI: remove hc_inaccessible flag
    
    This patch (as706) removes the private hc_inaccessible flag from
    uhci-hcd.  It's not needed because it conveys exactly the same
    information as the generic HCD_FLAG_HW_ACCESSIBLE bit.
    
    In its place goes a new flag recording whether the controller is dead.
    The new code allows a complete device reset to resurrect a dead
    controller (although usbcore doesn't yet implement such a facility).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index dc9ed29c6175..025b969f95e8 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -110,17 +110,23 @@ static void finish_reset(struct uhci_hcd *uhci)
 	uhci-&gt;is_stopped = UHCI_IS_STOPPED;
 	uhci_to_hcd(uhci)-&gt;state = HC_STATE_HALT;
 	uhci_to_hcd(uhci)-&gt;poll_rh = 0;
+
+	uhci-&gt;dead = 0;		/* Full reset resurrects the controller */
 }
 
 /*
  * Last rites for a defunct/nonfunctional controller
  * or one we don't want to use any more.
  */
-static void hc_died(struct uhci_hcd *uhci)
+static void uhci_hc_died(struct uhci_hcd *uhci)
 {
+	uhci_get_current_frame_number(uhci);
 	uhci_reset_hc(to_pci_dev(uhci_dev(uhci)), uhci-&gt;io_addr);
 	finish_reset(uhci);
-	uhci-&gt;hc_inaccessible = 1;
+	uhci-&gt;dead = 1;
+
+	/* The current frame may already be partway finished */
+	++uhci-&gt;frame_number;
 }
 
 /*
@@ -234,7 +240,7 @@ __acquires(uhci-&gt;lock)
 		spin_unlock_irq(&amp;uhci-&gt;lock);
 		msleep(1);
 		spin_lock_irq(&amp;uhci-&gt;lock);
-		if (uhci-&gt;hc_inaccessible)	/* Died */
+		if (uhci-&gt;dead)
 			return;
 	}
 	if (!(inw(uhci-&gt;io_addr + USBSTS) &amp; USBSTS_HCH))
@@ -287,7 +293,7 @@ __acquires(uhci-&gt;lock)
 		spin_unlock_irq(&amp;uhci-&gt;lock);
 		msleep(20);
 		spin_lock_irq(&amp;uhci-&gt;lock);
-		if (uhci-&gt;hc_inaccessible)	/* Died */
+		if (uhci-&gt;dead)
 			return;
 
 		/* End Global Resume and wait for EOP to be sent */
@@ -339,7 +345,7 @@ static irqreturn_t uhci_irq(struct usb_hcd *hcd, struct pt_regs *regs)
 							errbuf, ERRBUF_LEN);
 					lprintk(errbuf);
 				}
-				hc_died(uhci);
+				uhci_hc_died(uhci);
 
 				/* Force a callback in case there are
 				 * pending unlinks */
@@ -462,7 +468,7 @@ static void uhci_shutdown(struct pci_dev *pdev)
 {
 	struct usb_hcd *hcd = (struct usb_hcd *) pci_get_drvdata(pdev);
 
-	hc_died(hcd_to_uhci(hcd));
+	uhci_hc_died(hcd_to_uhci(hcd));
 }
 
 /*
@@ -664,8 +670,8 @@ static void uhci_stop(struct usb_hcd *hcd)
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 
 	spin_lock_irq(&amp;uhci-&gt;lock);
-	if (!uhci-&gt;hc_inaccessible)
-		hc_died(uhci);
+	if (test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags) &amp;&amp; !uhci-&gt;dead)
+		uhci_hc_died(uhci);
 	uhci_scan_schedule(uhci, NULL);
 	spin_unlock_irq(&amp;uhci-&gt;lock);
 
@@ -681,7 +687,7 @@ static int uhci_rh_suspend(struct usb_hcd *hcd)
 	spin_lock_irq(&amp;uhci-&gt;lock);
 	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags))
 		rc = -ESHUTDOWN;
-	else if (!uhci-&gt;hc_inaccessible)
+	else if (!uhci-&gt;dead)
 		suspend_rh(uhci, UHCI_RH_SUSPENDED);
 	spin_unlock_irq(&amp;uhci-&gt;lock);
 	return rc;
@@ -696,7 +702,7 @@ static int uhci_rh_resume(struct usb_hcd *hcd)
 	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags)) {
 		dev_warn(&amp;hcd-&gt;self.root_hub-&gt;dev, "HC isn't running!\n");
 		rc = -ESHUTDOWN;
-	} else if (!uhci-&gt;hc_inaccessible)
+	} else if (!uhci-&gt;dead)
 		wakeup_rh(uhci);
 	spin_unlock_irq(&amp;uhci-&gt;lock);
 	return rc;
@@ -710,8 +716,8 @@ static int uhci_suspend(struct usb_hcd *hcd, pm_message_t message)
 	dev_dbg(uhci_dev(uhci), "%s\n", __FUNCTION__);
 
 	spin_lock_irq(&amp;uhci-&gt;lock);
-	if (uhci-&gt;hc_inaccessible)	/* Dead or already suspended */
-		goto done;
+	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags) || uhci-&gt;dead)
+		goto done_okay;		/* Already suspended or dead */
 
 	if (uhci-&gt;rh_state &gt; UHCI_RH_SUSPENDED) {
 		dev_warn(uhci_dev(uhci), "Root hub isn't suspended!\n");
@@ -724,12 +730,12 @@ static int uhci_suspend(struct usb_hcd *hcd, pm_message_t message)
 	 */
 	pci_write_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP, 0);
 	mb();
-	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
-	uhci-&gt;hc_inaccessible = 1;
 	hcd-&gt;poll_rh = 0;
 
 	/* FIXME: Enable non-PME# remote wakeup? */
 
+done_okay:
+	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
 done:
 	spin_unlock_irq(&amp;uhci-&gt;lock);
 	return rc;
@@ -742,25 +748,22 @@ static int uhci_resume(struct usb_hcd *hcd)
 	dev_dbg(uhci_dev(uhci), "%s\n", __FUNCTION__);
 
 	/* Since we aren't in D3 any more, it's safe to set this flag
-	 * even if the controller was dead.  It might not even be dead
-	 * any more, if the firmware or quirks code has reset it.
+	 * even if the controller was dead.
 	 */
 	set_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
 	mb();
 
-	if (uhci-&gt;rh_state == UHCI_RH_RESET)	/* Dead */
-		return 0;
-
 	spin_lock_irq(&amp;uhci-&gt;lock);
 
 	/* FIXME: Disable non-PME# remote wakeup? */
 
-	uhci-&gt;hc_inaccessible = 0;
-
-	/* The BIOS may have changed the controller settings during a
-	 * system wakeup.  Check it and reconfigure to avoid problems.
+	/* The firmware or a boot kernel may have changed the controller
+	 * settings during a system wakeup.  Check it and reconfigure
+	 * to avoid problems.
 	 */
 	check_and_reset_hc(uhci);
+
+	/* If the controller was dead before, it's back alive now */
 	configure_hc(uhci);
 
 	if (uhci-&gt;rh_state == UHCI_RH_RESET) {
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index 469b4268b850..619d704f4e8f 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -395,7 +395,7 @@ struct uhci_hcd {
 
 	unsigned int scan_in_progress:1;	/* Schedule scan is running */
 	unsigned int need_rescan:1;		/* Redo the schedule scan */
-	unsigned int hc_inaccessible:1;		/* HC is suspended or dead */
+	unsigned int dead:1;			/* Controller has died */
 	unsigned int working_RD:1;		/* Suspended root hub doesn't
 						   need to be polled */
 	unsigned int is_initialized:1;		/* Data structure is usable */
diff --git a/drivers/usb/host/uhci-hub.c b/drivers/usb/host/uhci-hub.c
index f53c116e0dfd..c545ef92fe29 100644
--- a/drivers/usb/host/uhci-hub.c
+++ b/drivers/usb/host/uhci-hub.c
@@ -171,7 +171,7 @@ static int uhci_hub_status_data(struct usb_hcd *hcd, char *buf)
 	spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
 
 	uhci_scan_schedule(uhci, NULL);
-	if (uhci-&gt;hc_inaccessible)
+	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags) || uhci-&gt;dead)
 		goto done;
 	uhci_check_ports(uhci);
 
@@ -227,7 +227,7 @@ static int uhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 	u16 wPortChange, wPortStatus;
 	unsigned long flags;
 
-	if (uhci-&gt;hc_inaccessible)
+	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags) || uhci-&gt;dead)
 		return -ETIMEDOUT;
 
 	spin_lock_irqsave(&amp;uhci-&gt;lock, flags);</pre><hr><pre>commit ae671813affd947d2f21ff8e3cd329e466ee85b2
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jun 6 15:19:17 2006 -0400

    [PATCH] usb-storage: unusual_devs entry for Nikon DSC D70s
    
    This patch (as704) adds an unusual_devs entry for the Nikon DSC D70s,
    which uses a different Product ID from the D70.  It also moves the entry
    for the DSC E2000 up in the list, to preserve the numerical ordering.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index 9f72000a0064..3ec17689b81c 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -216,6 +216,14 @@ UNUSUAL_DEV(  0x04a4, 0x0004, 0x0001, 0x0001,
 		"DVD-CAM DZ-MV100A Camcorder",
 		US_SC_SCSI, US_PR_CB, NULL, US_FL_SINGLE_LUN),
 
+/* Patch for Nikon coolpix 2000
+ * Submitted by Fabien Cosse &lt;fabien.cosse@wanadoo.fr&gt;*/
+UNUSUAL_DEV(  0x04b0, 0x0301, 0x0010, 0x0010,
+		"NIKON",
+		"NIKON DSC E2000",
+		US_SC_DEVICE, US_PR_DEVICE,NULL,
+		US_FL_NOT_LOCKABLE ),
+
 /* Reported by Andreas Bockhold &lt;andreas@bockionline.de&gt; */
 UNUSUAL_DEV(  0x04b0, 0x0405, 0x0100, 0x0100,
 		"NIKON",
@@ -223,13 +231,12 @@ UNUSUAL_DEV(  0x04b0, 0x0405, 0x0100, 0x0100,
 		US_SC_DEVICE, US_PR_DEVICE, NULL,
 		US_FL_FIX_CAPACITY),
 
-/* Patch for Nikon coolpix 2000
- * Submitted by Fabien Cosse &lt;fabien.cosse@wanadoo.fr&gt;*/
-UNUSUAL_DEV(  0x04b0, 0x0301, 0x0010, 0x0010,
+/* Reported by Jamie Kitson &lt;jamie@staberinde.fsnet.co.uk&gt; */
+UNUSUAL_DEV(  0x04b0, 0x040d, 0x0100, 0x0100,
 		"NIKON",
-		"NIKON DSC E2000",
-		US_SC_DEVICE, US_PR_DEVICE,NULL,
-		US_FL_NOT_LOCKABLE ),
+		"NIKON DSC D70s",
+		US_SC_DEVICE, US_PR_DEVICE, NULL,
+		US_FL_FIX_CAPACITY),
 
 /* BENQ DC5330
  * Reported by Manuel Fombuena &lt;mfombuena@ya.com&gt; and</pre><hr><pre>commit 6ad07129a8ed2e13dcd7e6313c201c32bcf7cc32
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jun 1 13:59:16 2006 -0400

    [PATCH] usbcore: recovery from Set-Configuration failure
    
    This patch (as703) improves the error handling when a Set-Configuration
    request fails.  The old interfaces are all unregistered before the
    request is sent, and if the request fails then we don't know what config
    the device is using.  So it makes no sense to leave actconfig pointing
    to the old configuration with its invalid interfaces.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index b2f608b0538d..8569600f3130 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1411,15 +1411,7 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 				return ret;
 			}
 		}
-	}
 
-	/* if it's already configured, clear out old state first.
-	 * getting rid of old interfaces means unbinding their drivers.
-	 */
-	if (dev-&gt;state != USB_STATE_ADDRESS)
-		usb_disable_device (dev, 1);	// Skip ep0
-
-	if (cp) {
 		i = dev-&gt;bus_mA - cp-&gt;desc.bMaxPower * 2;
 		if (i &lt; 0)
 			dev_warn(&amp;dev-&gt;dev, "new config #%d exceeds power "
@@ -1427,84 +1419,91 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 					configuration, -i);
 	}
 
+	/* if it's already configured, clear out old state first.
+	 * getting rid of old interfaces means unbinding their drivers.
+	 */
+	if (dev-&gt;state != USB_STATE_ADDRESS)
+		usb_disable_device (dev, 1);	// Skip ep0
+
 	if ((ret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
 			USB_REQ_SET_CONFIGURATION, 0, configuration, 0,
-			NULL, 0, USB_CTRL_SET_TIMEOUT)) &lt; 0)
-		goto free_interfaces;
+			NULL, 0, USB_CTRL_SET_TIMEOUT)) &lt; 0) {
+
+		/* All the old state is gone, so what else can we do?
+		 * The device is probably useless now anyway.
+		 */
+		cp = NULL;
+	}
 
 	dev-&gt;actconfig = cp;
-	if (!cp)
+	if (!cp) {
 		usb_set_device_state(dev, USB_STATE_ADDRESS);
-	else {
-		usb_set_device_state(dev, USB_STATE_CONFIGURED);
+		goto free_interfaces;
+	}
+	usb_set_device_state(dev, USB_STATE_CONFIGURED);
 
-		/* Initialize the new interface structures and the
-		 * hc/hcd/usbcore interface/endpoint state.
-		 */
-		for (i = 0; i &lt; nintf; ++i) {
-			struct usb_interface_cache *intfc;
-			struct usb_interface *intf;
-			struct usb_host_interface *alt;
-
-			cp-&gt;interface[i] = intf = new_interfaces[i];
-			intfc = cp-&gt;intf_cache[i];
-			intf-&gt;altsetting = intfc-&gt;altsetting;
-			intf-&gt;num_altsetting = intfc-&gt;num_altsetting;
-			kref_get(&amp;intfc-&gt;ref);
-
-			alt = usb_altnum_to_altsetting(intf, 0);
-
-			/* No altsetting 0?  We'll assume the first altsetting.
-			 * We could use a GetInterface call, but if a device is
-			 * so non-compliant that it doesn't have altsetting 0
-			 * then I wouldn't trust its reply anyway.
-			 */
-			if (!alt)
-				alt = &amp;intf-&gt;altsetting[0];
-
-			intf-&gt;cur_altsetting = alt;
-			usb_enable_interface(dev, intf);
-			intf-&gt;dev.parent = &amp;dev-&gt;dev;
-			intf-&gt;dev.driver = NULL;
-			intf-&gt;dev.bus = &amp;usb_bus_type;
-			intf-&gt;dev.dma_mask = dev-&gt;dev.dma_mask;
-			intf-&gt;dev.release = release_interface;
-			device_initialize (&amp;intf-&gt;dev);
-			mark_quiesced(intf);
-			sprintf (&amp;intf-&gt;dev.bus_id[0], "%d-%s:%d.%d",
-				 dev-&gt;bus-&gt;busnum, dev-&gt;devpath,
-				 configuration,
-				 alt-&gt;desc.bInterfaceNumber);
-		}
-		kfree(new_interfaces);
+	/* Initialize the new interface structures and the
+	 * hc/hcd/usbcore interface/endpoint state.
+	 */
+	for (i = 0; i &lt; nintf; ++i) {
+		struct usb_interface_cache *intfc;
+		struct usb_interface *intf;
+		struct usb_host_interface *alt;
 
-		if (cp-&gt;string == NULL)
-			cp-&gt;string = usb_cache_string(dev,
-					cp-&gt;desc.iConfiguration);
+		cp-&gt;interface[i] = intf = new_interfaces[i];
+		intfc = cp-&gt;intf_cache[i];
+		intf-&gt;altsetting = intfc-&gt;altsetting;
+		intf-&gt;num_altsetting = intfc-&gt;num_altsetting;
+		kref_get(&amp;intfc-&gt;ref);
 
-		/* Now that all the interfaces are set up, register them
-		 * to trigger binding of drivers to interfaces.  probe()
-		 * routines may install different altsettings and may
-		 * claim() any interfaces not yet bound.  Many class drivers
-		 * need that: CDC, audio, video, etc.
+		alt = usb_altnum_to_altsetting(intf, 0);
+
+		/* No altsetting 0?  We'll assume the first altsetting.
+		 * We could use a GetInterface call, but if a device is
+		 * so non-compliant that it doesn't have altsetting 0
+		 * then I wouldn't trust its reply anyway.
 		 */
-		for (i = 0; i &lt; nintf; ++i) {
-			struct usb_interface *intf = cp-&gt;interface[i];
-
-			dev_dbg (&amp;dev-&gt;dev,
-				"adding %s (config #%d, interface %d)\n",
-				intf-&gt;dev.bus_id, configuration,
-				intf-&gt;cur_altsetting-&gt;desc.bInterfaceNumber);
-			ret = device_add (&amp;intf-&gt;dev);
-			if (ret != 0) {
-				dev_err(&amp;dev-&gt;dev,
-					"device_add(%s) --&gt; %d\n",
-					intf-&gt;dev.bus_id,
-					ret);
-				continue;
-			}
-			usb_create_sysfs_intf_files (intf);
+		if (!alt)
+			alt = &amp;intf-&gt;altsetting[0];
+
+		intf-&gt;cur_altsetting = alt;
+		usb_enable_interface(dev, intf);
+		intf-&gt;dev.parent = &amp;dev-&gt;dev;
+		intf-&gt;dev.driver = NULL;
+		intf-&gt;dev.bus = &amp;usb_bus_type;
+		intf-&gt;dev.dma_mask = dev-&gt;dev.dma_mask;
+		intf-&gt;dev.release = release_interface;
+		device_initialize (&amp;intf-&gt;dev);
+		mark_quiesced(intf);
+		sprintf (&amp;intf-&gt;dev.bus_id[0], "%d-%s:%d.%d",
+			 dev-&gt;bus-&gt;busnum, dev-&gt;devpath,
+			 configuration, alt-&gt;desc.bInterfaceNumber);
+	}
+	kfree(new_interfaces);
+
+	if (cp-&gt;string == NULL)
+		cp-&gt;string = usb_cache_string(dev, cp-&gt;desc.iConfiguration);
+
+	/* Now that all the interfaces are set up, register them
+	 * to trigger binding of drivers to interfaces.  probe()
+	 * routines may install different altsettings and may
+	 * claim() any interfaces not yet bound.  Many class drivers
+	 * need that: CDC, audio, video, etc.
+	 */
+	for (i = 0; i &lt; nintf; ++i) {
+		struct usb_interface *intf = cp-&gt;interface[i];
+
+		dev_dbg (&amp;dev-&gt;dev,
+			"adding %s (config #%d, interface %d)\n",
+			intf-&gt;dev.bus_id, configuration,
+			intf-&gt;cur_altsetting-&gt;desc.bInterfaceNumber);
+		ret = device_add (&amp;intf-&gt;dev);
+		if (ret != 0) {
+			dev_err(&amp;dev-&gt;dev, "device_add(%s) --&gt; %d\n",
+				intf-&gt;dev.bus_id, ret);
+			continue;
 		}
+		usb_create_sysfs_intf_files (intf);
 	}
 
 	return 0;</pre><hr><pre>commit df9a1f482d1252045210f50048911e2efba61e62
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jun 1 13:55:28 2006 -0400

    [PATCH] usbhid: use usb_reset_composite_device
    
    This patch (as702) makes usbhid use the new usb_reset_composite_device
    API.  Now HID interfaces can coexist with other interfaces on the same
    device, and a reset can safely be requested by any of the drivers.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/input/hid-core.c b/drivers/usb/input/hid-core.c
index c6051beeabdc..17b6e6ab3703 100644
--- a/drivers/usb/input/hid-core.c
+++ b/drivers/usb/input/hid-core.c
@@ -944,21 +944,28 @@ static void hid_reset(void *_hid)
 	dev_dbg(&amp;hid-&gt;intf-&gt;dev, "resetting device\n");
 	rc = rc_lock = usb_lock_device_for_reset(hid-&gt;dev, hid-&gt;intf);
 	if (rc_lock &gt;= 0) {
-		rc = usb_reset_device(hid-&gt;dev);
+		rc = usb_reset_composite_device(hid-&gt;dev, hid-&gt;intf);
 		if (rc_lock)
 			usb_unlock_device(hid-&gt;dev);
 	}
 	clear_bit(HID_RESET_PENDING, &amp;hid-&gt;iofl);
 
-	if (rc == 0) {
-		hid-&gt;retry_delay = 0;
-		if (hid_start_in(hid))
+	switch (rc) {
+	case 0:
+		if (!test_bit(HID_IN_RUNNING, &amp;hid-&gt;iofl))
 			hid_io_error(hid);
-	} else if (!(rc == -ENODEV || rc == -EHOSTUNREACH || rc == -EINTR))
+		break;
+	default:
 		err("can't reset device, %s-%s/input%d, status %d",
 				hid-&gt;dev-&gt;bus-&gt;bus_name,
 				hid-&gt;dev-&gt;devpath,
 				hid-&gt;ifnum, rc);
+		/* FALLTHROUGH */
+	case -EHOSTUNREACH:
+	case -ENODEV:
+	case -EINTR:
+		break;
+	}
 }
 
 /* Main I/O error handler */
@@ -2063,11 +2070,29 @@ static int hid_resume(struct usb_interface *intf)
 	int status;
 
 	clear_bit(HID_SUSPENDED, &amp;hid-&gt;iofl);
+	hid-&gt;retry_delay = 0;
 	status = hid_start_in(hid);
 	dev_dbg(&amp;intf-&gt;dev, "resume status %d\n", status);
 	return status;
 }
 
+/* Treat USB reset pretty much the same as suspend/resume */
+static void hid_pre_reset(struct usb_interface *intf)
+{
+	/* FIXME: What if the interface is already suspended? */
+	hid_suspend(intf, PMSG_ON);
+}
+
+static void hid_post_reset(struct usb_interface *intf)
+{
+	struct usb_device *dev = interface_to_usbdev (intf);
+
+	hid_set_idle(dev, intf-&gt;cur_altsetting-&gt;desc.bInterfaceNumber, 0, 0);
+	/* FIXME: Any more reinitialization needed? */
+
+	hid_resume(intf);
+}
+
 static struct usb_device_id hid_usb_ids [] = {
 	{ .match_flags = USB_DEVICE_ID_MATCH_INT_CLASS,
 		.bInterfaceClass = USB_INTERFACE_CLASS_HID },
@@ -2082,6 +2107,8 @@ static struct usb_driver hid_driver = {
 	.disconnect =	hid_disconnect,
 	.suspend =	hid_suspend,
 	.resume =	hid_resume,
+	.pre_reset =	hid_pre_reset,
+	.post_reset =	hid_post_reset,
 	.id_table =	hid_usb_ids,
 };
 </pre><hr><pre>commit 47104b0dd32cec467574822b0dc3517b3de3f0ad
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jun 1 13:52:56 2006 -0400

    [PATCH] usb-storage: use usb_reset_composite_device
    
    This patch (as701) modifies usb-storage to take advantage of the new
    usb_reset_composite_device() API.  Now we will be able to safely request
    port resets even if other drivers are bound to a mass-storage device.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 5f11e19eaae3..5715291ba540 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -286,11 +286,7 @@ static int bus_reset(struct scsi_cmnd *srb)
 	int result;
 
 	US_DEBUGP("%s called\n", __FUNCTION__);
-
-	mutex_lock(&amp;(us-&gt;dev_mutex));
 	result = usb_stor_port_reset(us);
-	mutex_unlock(&amp;us-&gt;dev_mutex);
-
 	return result &lt; 0 ? FAILED : SUCCESS;
 }
 
diff --git a/drivers/usb/storage/transport.c b/drivers/usb/storage/transport.c
index 038f4582ca0b..19b25c5cafd4 100644
--- a/drivers/usb/storage/transport.c
+++ b/drivers/usb/storage/transport.c
@@ -703,16 +703,19 @@ void usb_stor_invoke_transport(struct scsi_cmnd *srb, struct us_data *us)
 	 * device reset. */
   Handle_Errors:
 
-	/* Let the SCSI layer know we are doing a reset, set the
-	 * RESETTING bit, and clear the ABORTING bit so that the reset
-	 * may proceed. */
+	/* Set the RESETTING bit, and clear the ABORTING bit so that
+	 * the reset may proceed. */
 	scsi_lock(us_to_host(us));
-	usb_stor_report_bus_reset(us);
 	set_bit(US_FLIDX_RESETTING, &amp;us-&gt;flags);
 	clear_bit(US_FLIDX_ABORTING, &amp;us-&gt;flags);
 	scsi_unlock(us_to_host(us));
 
+	/* We must release the device lock because the pre_reset routine
+	 * will want to acquire it. */
+	mutex_unlock(&amp;us-&gt;dev_mutex);
 	result = usb_stor_port_reset(us);
+	mutex_lock(&amp;us-&gt;dev_mutex);
+
 	if (result &lt; 0) {
 		scsi_lock(us_to_host(us));
 		usb_stor_report_device_reset(us);
@@ -1196,31 +1199,30 @@ int usb_stor_Bulk_reset(struct us_data *us)
 				 0, us-&gt;ifnum, NULL, 0);
 }
 
-/* Issue a USB port reset to the device.  But don't do anything if
- * there's more than one interface in the device, so that other users
- * are not affected. */
+/* Issue a USB port reset to the device.  The caller must not hold
+ * us-&gt;dev_mutex.
+ */
 int usb_stor_port_reset(struct us_data *us)
 {
-	int result, rc;
+	int result, rc_lock;
 
-	if (test_bit(US_FLIDX_DISCONNECTING, &amp;us-&gt;flags)) {
-		result = -EIO;
-		US_DEBUGP("No reset during disconnect\n");
-	} else if (us-&gt;pusb_dev-&gt;actconfig-&gt;desc.bNumInterfaces != 1) {
-		result = -EBUSY;
-		US_DEBUGP("Refusing to reset a multi-interface device\n");
-	} else {
-		result = rc =
-			usb_lock_device_for_reset(us-&gt;pusb_dev, us-&gt;pusb_intf);
-		if (result &lt; 0) {
-			US_DEBUGP("unable to lock device for reset: %d\n",
-					result);
+	result = rc_lock =
+		usb_lock_device_for_reset(us-&gt;pusb_dev, us-&gt;pusb_intf);
+	if (result &lt; 0)
+		US_DEBUGP("unable to lock device for reset: %d\n", result);
+	else {
+		/* Were we disconnected while waiting for the lock? */
+		if (test_bit(US_FLIDX_DISCONNECTING, &amp;us-&gt;flags)) {
+			result = -EIO;
+			US_DEBUGP("No reset during disconnect\n");
 		} else {
-			result = usb_reset_device(us-&gt;pusb_dev);
-			if (rc)
-				usb_unlock_device(us-&gt;pusb_dev);
-			US_DEBUGP("usb_reset_device returns %d\n", result);
+			result = usb_reset_composite_device(
+					us-&gt;pusb_dev, us-&gt;pusb_intf);
+			US_DEBUGP("usb_reset_composite_device returns %d\n",
+					result);
 		}
+		if (rc_lock)
+			usb_unlock_device(us-&gt;pusb_dev);
 	}
 	return result;
 }
diff --git a/drivers/usb/storage/usb.c b/drivers/usb/storage/usb.c
index 0142fe82f6b8..e232c7c89909 100644
--- a/drivers/usb/storage/usb.c
+++ b/drivers/usb/storage/usb.c
@@ -220,6 +220,37 @@ static int storage_resume(struct usb_interface *iface)
 
 #endif /* CONFIG_PM */
 
+/*
+ * The next two routines get called just before and just after
+ * a USB port reset, whether from this driver or a different one.
+ */
+
+static void storage_pre_reset(struct usb_interface *iface)
+{
+	struct us_data *us = usb_get_intfdata(iface);
+
+	US_DEBUGP("%s\n", __FUNCTION__);
+
+	/* Make sure no command runs during the reset */
+	mutex_lock(&amp;us-&gt;dev_mutex);
+}
+
+static void storage_post_reset(struct usb_interface *iface)
+{
+	struct us_data *us = usb_get_intfdata(iface);
+
+	US_DEBUGP("%s\n", __FUNCTION__);
+
+	/* Report the reset to the SCSI core */
+	scsi_lock(us_to_host(us));
+	usb_stor_report_bus_reset(us);
+	scsi_unlock(us_to_host(us));
+
+	/* FIXME: Notify the subdrivers that they need to reinitialize
+	 * the device */
+	mutex_unlock(&amp;us-&gt;dev_mutex);
+}
+
 /*
  * fill_inquiry_response takes an unsigned char array (which must
  * be at least 36 characters) and populates the vendor name,
@@ -1002,6 +1033,8 @@ static struct usb_driver usb_storage_driver = {
 	.suspend =	storage_suspend,
 	.resume =	storage_resume,
 #endif
+	.pre_reset =	storage_pre_reset,
+	.post_reset =	storage_post_reset,
 	.id_table =	storage_usb_ids,
 };
 </pre><hr><pre>commit 7de18d8bf4b470752e799e219b38b6dff4b49993
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jun 1 13:37:24 2006 -0400

    [PATCH] USB hub: use usb_reset_composite_device
    
    This patch (as700) modifies the hub driver to take advantage of the new
    usb_reset_composite_device API.  The existing code had special-case
    calls stuck into usb_reset_device, just before and after the reset.
    With the new version there's no need for special-case stuff; it all
    happens naturally in the form of pre_reset and post_reset notifications.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 37c67d7e8b84..e1731ff8af4d 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -525,15 +525,16 @@ static int hub_port_disable(struct usb_hub *hub, int port1, int set_state)
 
 
 /* caller has locked the hub device */
-static void hub_pre_reset(struct usb_hub *hub, int disable_ports)
+static void hub_pre_reset(struct usb_interface *intf)
 {
+	struct usb_hub *hub = usb_get_intfdata(intf);
 	struct usb_device *hdev = hub-&gt;hdev;
 	int port1;
 
 	for (port1 = 1; port1 &lt;= hdev-&gt;maxchild; ++port1) {
 		if (hdev-&gt;children[port1 - 1]) {
 			usb_disconnect(&amp;hdev-&gt;children[port1 - 1]);
-			if (disable_ports)
+			if (hub-&gt;error == 0)
 				hub_port_disable(hub, port1, 0);
 		}
 	}
@@ -541,8 +542,10 @@ static void hub_pre_reset(struct usb_hub *hub, int disable_ports)
 }
 
 /* caller has locked the hub device */
-static void hub_post_reset(struct usb_hub *hub)
+static void hub_post_reset(struct usb_interface *intf)
 {
+	struct usb_hub *hub = usb_get_intfdata(intf);
+
 	hub_activate(hub);
 	hub_power_on(hub);
 }
@@ -802,15 +805,16 @@ static void hub_disconnect(struct usb_interface *intf)
 	struct usb_hub *hub = usb_get_intfdata (intf);
 	struct usb_device *hdev;
 
+	/* Disconnect all children and quiesce the hub */
+	hub-&gt;error = 0;
+	hub_pre_reset(intf);
+
 	usb_set_intfdata (intf, NULL);
 	hdev = hub-&gt;hdev;
 
 	if (hdev-&gt;speed == USB_SPEED_HIGH)
 		highspeed_hubs--;
 
-	/* Disconnect all children and quiesce the hub */
-	hub_pre_reset(hub, 1);
-
 	usb_free_urb(hub-&gt;urb);
 	hub-&gt;urb = NULL;
 
@@ -2747,7 +2751,8 @@ static void hub_events(void)
 
 		/* If the hub has died, clean up after it */
 		if (hdev-&gt;state == USB_STATE_NOTATTACHED) {
-			hub_pre_reset(hub, 0);
+			hub-&gt;error = -ENODEV;
+			hub_pre_reset(intf);
 			goto loop;
 		}
 
@@ -2759,7 +2764,7 @@ static void hub_events(void)
 			dev_dbg (hub_dev, "resetting for error %d\n",
 				hub-&gt;error);
 
-			ret = usb_reset_device(hdev);
+			ret = usb_reset_composite_device(hdev, intf);
 			if (ret) {
 				dev_dbg (hub_dev,
 					"error resetting hub: %d\n", ret);
@@ -2928,6 +2933,8 @@ static struct usb_driver hub_driver = {
 	.disconnect =	hub_disconnect,
 	.suspend =	hub_suspend,
 	.resume =	hub_resume,
+	.pre_reset =	hub_pre_reset,
+	.post_reset =	hub_post_reset,
 	.ioctl =	hub_ioctl,
 	.id_table =	hub_id_table,
 };
@@ -3033,7 +3040,6 @@ int usb_reset_device(struct usb_device *udev)
 	struct usb_device		*parent_hdev = udev-&gt;parent;
 	struct usb_hub			*parent_hub;
 	struct usb_device_descriptor	descriptor = udev-&gt;descriptor;
-	struct usb_hub			*hub = NULL;
 	int 				i, ret = 0;
 	int				port1 = udev-&gt;portnum;
 
@@ -3051,14 +3057,6 @@ int usb_reset_device(struct usb_device *udev)
 	}
 	parent_hub = hdev_to_hub(parent_hdev);
 
-	/* If we're resetting an active hub, take some special actions */
-	if (udev-&gt;actconfig &amp;&amp; udev-&gt;actconfig-&gt;desc.bNumInterfaces &gt; 0 &amp;&amp;
-			udev-&gt;actconfig-&gt;interface[0]-&gt;dev.driver ==
-				&amp;hub_driver.driver &amp;&amp;
-			(hub = hdev_to_hub(udev)) != NULL) {
-		hub_pre_reset(hub, 0);
-	}
-
 	set_bit(port1, parent_hub-&gt;busy_bits);
 	for (i = 0; i &lt; SET_CONFIG_TRIES; ++i) {
 
@@ -3117,8 +3115,6 @@ int usb_reset_device(struct usb_device *udev)
 	}
 
 done:
-	if (hub)
-		hub_post_reset(hub);
 	return 0;
  
 re_enumerate:</pre>
    <div class="pagination">
        <a href='2_123.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><span>[124]</span><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_125.html'>Next&gt;&gt;</a>
    <div>
</body>
