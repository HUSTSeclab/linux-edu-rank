<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_69.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><span>[70]</span><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_71.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 0534d46848990e8eed7cd0832d745d813e827261
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jan 8 12:56:30 2010 -0500

    USB: consolidate remote wakeup routines
    
    This patch (as1324) makes a small change to the code used for remote
    wakeup of root hubs.  hcd_resume_work() now calls the hub driver's
    remote-wakeup routine instead of implementing its own version.
    
    The patch is complicated by the need to rename remote_wakeup() to
    usb_remote_wakeup(), make it non-static, and declare it in a header
    file.  There's also the additional complication required to make
    everything work when CONFIG_PM isn't set; the do-nothing inline
    routine had to be moved into the header file.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index cf0a098a5432..fc4290b6691c 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1865,8 +1865,7 @@ static void hcd_resume_work(struct work_struct *work)
 	struct usb_device *udev = hcd-&gt;self.root_hub;
 
 	usb_lock_device(udev);
-	usb_mark_last_busy(udev);
-	usb_external_resume_device(udev, PMSG_REMOTE_RESUME);
+	usb_remote_wakeup(udev);
 	usb_unlock_device(udev);
 }
 
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 4986ff628465..bfa6123bbdb5 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2399,7 +2399,7 @@ int usb_port_resume(struct usb_device *udev, pm_message_t msg)
 }
 
 /* caller has locked udev */
-static int remote_wakeup(struct usb_device *udev)
+int usb_remote_wakeup(struct usb_device *udev)
 {
 	int	status = 0;
 
@@ -2443,7 +2443,7 @@ int usb_port_resume(struct usb_device *udev, pm_message_t msg)
 	return status;
 }
 
-static inline int remote_wakeup(struct usb_device *udev)
+int usb_remote_wakeup(struct usb_device *udev)
 {
 	return 0;
 }
@@ -2514,11 +2514,6 @@ EXPORT_SYMBOL_GPL(usb_root_hub_lost_power);
 
 #else	/* CONFIG_PM */
 
-static inline int remote_wakeup(struct usb_device *udev)
-{
-	return 0;
-}
-
 #define hub_suspend		NULL
 #define hub_resume		NULL
 #define hub_reset_resume	NULL
@@ -3017,7 +3012,7 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 			/* For a suspended device, treat this as a
 			 * remote wakeup event.
 			 */
-			status = remote_wakeup(udev);
+			status = usb_remote_wakeup(udev);
 #endif
 
 		} else {
@@ -3363,7 +3358,7 @@ static void hub_events(void)
 					msleep(10);
 
 					usb_lock_device(udev);
-					ret = remote_wakeup(hdev-&gt;
+					ret = usb_remote_wakeup(hdev-&gt;
 							children[i-1]);
 					usb_unlock_device(udev);
 					if (ret &lt; 0)
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 4c36c7f512a0..2b74a7f99c41 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -63,6 +63,7 @@ extern int usb_external_suspend_device(struct usb_device *udev,
 		pm_message_t msg);
 extern int usb_external_resume_device(struct usb_device *udev,
 		pm_message_t msg);
+extern int usb_remote_wakeup(struct usb_device *dev);
 
 static inline void usb_pm_lock(struct usb_device *udev)
 {
@@ -86,6 +87,11 @@ static inline int usb_port_resume(struct usb_device *udev, pm_message_t msg)
 	return 0;
 }
 
+static inline int usb_remote_wakeup(struct usb_device *udev)
+{
+	return 0;
+}
+
 static inline void usb_pm_lock(struct usb_device *udev) {}
 static inline void usb_pm_unlock(struct usb_device *udev) {}
 </pre><hr><pre>commit 62e299e61a6ffe8131fa85a984c3058b68586f5d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jan 8 12:56:19 2010 -0500

    USB: change locking for device-level autosuspend
    
    This patch (as1323) changes the locking requirements for
    usb_autosuspend_device(), usb_autoresume_device(), and
    usb_try_autosuspend_device().  This isn't a very important change;
    mainly it's meant to make the locking more uniform.
    
    The most tricky part of the patch involves changes to usbdev_open().
    To avoid an ABBA locking problem, it was necessary to reduce the
    region protected by usbfs_mutex.  Since that mutex now protects only
    against simultaneous open and remove, this posed no difficulty -- its
    scope was larger than necessary.
    
    And it turns out that usbfs_mutex is no longer needed in
    usbdev_release() at all.  The list of usbfs "ps" structures is now
    protected by the device lock instead of by usbfs_mutex.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 431d17287a86..825e0abfed0a 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -654,19 +654,21 @@ static int usbdev_open(struct inode *inode, struct file *file)
 	int ret;
 
 	lock_kernel();
-	/* Protect against simultaneous removal or release */
-	mutex_lock(&amp;usbfs_mutex);
 
 	ret = -ENOMEM;
 	ps = kmalloc(sizeof(struct dev_state), GFP_KERNEL);
 	if (!ps)
-		goto out;
+		goto out_free_ps;
 
 	ret = -ENODEV;
 
+	/* Protect against simultaneous removal or release */
+	mutex_lock(&amp;usbfs_mutex);
+
 	/* usbdev device-node */
 	if (imajor(inode) == USB_DEVICE_MAJOR)
 		dev = usbdev_lookup_by_devt(inode-&gt;i_rdev);
+
 #ifdef CONFIG_USB_DEVICEFS
 	/* procfs file */
 	if (!dev) {
@@ -678,13 +680,19 @@ static int usbdev_open(struct inode *inode, struct file *file)
 			dev = NULL;
 	}
 #endif
-	if (!dev || dev-&gt;state == USB_STATE_NOTATTACHED)
-		goto out;
+	mutex_unlock(&amp;usbfs_mutex);
+
+	if (!dev)
+		goto out_free_ps;
+
+	usb_lock_device(dev);
+	if (dev-&gt;state == USB_STATE_NOTATTACHED)
+		goto out_unlock_device;
+
 	ret = usb_autoresume_device(dev);
 	if (ret)
-		goto out;
+		goto out_unlock_device;
 
-	ret = 0;
 	ps-&gt;dev = dev;
 	ps-&gt;file = file;
 	spin_lock_init(&amp;ps-&gt;lock);
@@ -702,14 +710,17 @@ static int usbdev_open(struct inode *inode, struct file *file)
 	smp_wmb();
 	list_add_tail(&amp;ps-&gt;list, &amp;dev-&gt;filelist);
 	file-&gt;private_data = ps;
+	usb_unlock_device(dev);
 	snoop(&amp;dev-&gt;dev, "opened by process %d: %s\n", task_pid_nr(current),
 			current-&gt;comm);
- out:
-	if (ret) {
-		kfree(ps);
-		usb_put_dev(dev);
-	}
-	mutex_unlock(&amp;usbfs_mutex);
+	unlock_kernel();
+	return ret;
+
+ out_unlock_device:
+	usb_unlock_device(dev);
+	usb_put_dev(dev);
+ out_free_ps:
+	kfree(ps);
 	unlock_kernel();
 	return ret;
 }
@@ -724,10 +735,7 @@ static int usbdev_release(struct inode *inode, struct file *file)
 	usb_lock_device(dev);
 	usb_hub_release_all_ports(dev, ps);
 
-	/* Protect against simultaneous open */
-	mutex_lock(&amp;usbfs_mutex);
 	list_del_init(&amp;ps-&gt;list);
-	mutex_unlock(&amp;usbfs_mutex);
 
 	for (ifnum = 0; ps-&gt;ifclaimed &amp;&amp; ifnum &lt; 8*sizeof(ps-&gt;ifclaimed);
 			ifnum++) {
diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index fcafb2dce3ac..2b39583040d0 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -1478,8 +1478,7 @@ void usb_autoresume_work(struct work_struct *work)
  * driver requires remote-wakeup capability during autosuspend but remote
  * wakeup is disabled, the autosuspend will fail.
  *
- * Often the caller will hold @udev's device lock, but this is not
- * necessary.
+ * The caller must hold @udev's device lock.
  *
  * This routine can run only in process context.
  */
@@ -1503,6 +1502,8 @@ void usb_autosuspend_device(struct usb_device *udev)
  * for an active interface is greater than 0, or autosuspend is not allowed
  * for any other reason, no autosuspend request will be queued.
  *
+ * The caller must hold @udev's device lock.
+ *
  * This routine can run only in process context.
  */
 void usb_try_autosuspend_device(struct usb_device *udev)
@@ -1526,8 +1527,7 @@ void usb_try_autosuspend_device(struct usb_device *udev)
  * @udev's usage counter is incremented to prevent subsequent autosuspends.
  * However if the autoresume fails then the usage counter is re-decremented.
  *
- * Often the caller will hold @udev's device lock, but this is not
- * necessary (and attempting it might cause deadlock).
+ * The caller must hold @udev's device lock.
  *
  * This routine can run only in process context.
  */
diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c
index 1b3c00b3ca3f..d8f3bfe1559f 100644
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -352,6 +352,7 @@ set_autosuspend(struct device *dev, struct device_attribute *attr,
 		return -EINVAL;
 	value *= HZ;
 
+	usb_lock_device(udev);
 	udev-&gt;autosuspend_delay = value;
 	if (value &gt;= 0)
 		usb_try_autosuspend_device(udev);
@@ -359,6 +360,7 @@ set_autosuspend(struct device *dev, struct device_attribute *attr,
 		if (usb_autoresume_device(udev) == 0)
 			usb_autosuspend_device(udev);
 	}
+	usb_unlock_device(udev);
 	return count;
 }
 </pre><hr><pre>commit 0f3dda9f7ff2db8dbf4d6fbab4d4438251446002
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jan 8 12:56:04 2010 -0500

    USB: rearrange code in usb_probe_interface
    
    This patch (as1322) reverses the two outcomes of an "if" statement in
    usb_probe_interface(), to avoid an unnecessary level of indentation.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index f2f055eb6831..fcafb2dce3ac 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -274,56 +274,55 @@ static int usb_probe_interface(struct device *dev)
 	intf-&gt;needs_binding = 0;
 
 	if (usb_device_is_owned(udev))
-		return -ENODEV;
+		return error;
 
 	if (udev-&gt;authorized == 0) {
 		dev_err(&amp;intf-&gt;dev, "Device is not authorized for usage\n");
-		return -ENODEV;
+		return error;
 	}
 
 	id = usb_match_id(intf, driver-&gt;id_table);
 	if (!id)
 		id = usb_match_dynamic_id(intf, driver);
-	if (id) {
-		dev_dbg(dev, "%s - got id\n", __func__);
-
-		error = usb_autoresume_device(udev);
-		if (error)
-			return error;
+	if (!id)
+		return error;
 
-		/* Interface "power state" doesn't correspond to any hardware
-		 * state whatsoever.  We use it to record when it's bound to
-		 * a driver that may start I/0:  it's not frozen/quiesced.
-		 */
-		mark_active(intf);
-		intf-&gt;condition = USB_INTERFACE_BINDING;
+	dev_dbg(dev, "%s - got id\n", __func__);
 
-		/* The interface should always appear to be in use
-		 * unless the driver suports autosuspend.
-		 */
-		atomic_set(&amp;intf-&gt;pm_usage_cnt, !driver-&gt;supports_autosuspend);
+	error = usb_autoresume_device(udev);
+	if (error)
+		return error;
 
-		/* Carry out a deferred switch to altsetting 0 */
-		if (intf-&gt;needs_altsetting0) {
-			error = usb_set_interface(udev, intf-&gt;altsetting[0].
-					desc.bInterfaceNumber, 0);
-			if (error &lt; 0)
-				goto err;
+	/* Interface "power state" doesn't correspond to any hardware
+	 * state whatsoever.  We use it to record when it's bound to
+	 * a driver that may start I/0:  it's not frozen/quiesced.
+	 */
+	mark_active(intf);
+	intf-&gt;condition = USB_INTERFACE_BINDING;
 
-			intf-&gt;needs_altsetting0 = 0;
-		}
+	/* The interface should always appear to be in use
+	 * unless the driver suports autosuspend.
+	 */
+	atomic_set(&amp;intf-&gt;pm_usage_cnt, !driver-&gt;supports_autosuspend);
 
-		error = driver-&gt;probe(intf, id);
-		if (error)
+	/* Carry out a deferred switch to altsetting 0 */
+	if (intf-&gt;needs_altsetting0) {
+		error = usb_set_interface(udev, intf-&gt;altsetting[0].
+				desc.bInterfaceNumber, 0);
+		if (error &lt; 0)
 			goto err;
-
-		intf-&gt;condition = USB_INTERFACE_BOUND;
-		usb_autosuspend_device(udev);
+		intf-&gt;needs_altsetting0 = 0;
 	}
 
+	error = driver-&gt;probe(intf, id);
+	if (error)
+		goto err;
+
+	intf-&gt;condition = USB_INTERFACE_BOUND;
+	usb_autosuspend_device(udev);
 	return error;
 
-err:
+ err:
 	mark_quiesced(intf);
 	intf-&gt;needs_remote_wakeup = 0;
 	intf-&gt;condition = USB_INTERFACE_UNBOUND;</pre><hr><pre>commit f661c6f8c67bd55e93348f160d590ff9edf08904
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Dec 11 16:20:20 2009 -0500

    USB: check the endpoint type against the pipe type
    
    This patch (as1316) adds some error checking to usb_submit_urb().
    It's conditional on CONFIG_USB_DEBUG, so it won't affect normal users.
    The new check makes sure that the actual type of the endpoint
    described by urb-&gt;pipe agrees with the type encoded in the pipe value.
    
    The USB error code documentation is updated to include the code
    returned by the new check, and the usbfs SUBMITURB handler is updated
    to use the correct pipe type when legacy user code tries to submit a
    bulk transfer to an interrupt endpoint.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/Documentation/usb/error-codes.txt b/Documentation/usb/error-codes.txt
index 9cf83e8c27b8..d83703ea74b2 100644
--- a/Documentation/usb/error-codes.txt
+++ b/Documentation/usb/error-codes.txt
@@ -41,8 +41,8 @@ USB-specific:
 
 -EFBIG		Host controller driver can't schedule that many ISO frames.
 
--EPIPE		Specified endpoint is stalled.  For non-control endpoints,
-		reset this status with usb_clear_halt().
+-EPIPE		The pipe type specified in the URB doesn't match the
+		endpoint's actual type.
 
 -EMSGSIZE	(a) endpoint maxpacket size is zero; it is not usable
 		    in the current interface altsetting.
@@ -60,6 +60,8 @@ USB-specific:
 
 -EHOSTUNREACH	URB was rejected because the device is suspended.
 
+-ENOEXEC	A control URB doesn't contain a Setup packet.
+
 
 **************************************************************************
 *                   Error codes returned by in urb-&gt;status               *
diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index a678186f218f..431d17287a86 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -1104,13 +1104,25 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 		case USB_ENDPOINT_XFER_CONTROL:
 		case USB_ENDPOINT_XFER_ISOC:
 			return -EINVAL;
-		/* allow single-shot interrupt transfers, at bogus rates */
+		case USB_ENDPOINT_XFER_INT:
+			/* allow single-shot interrupt transfers */
+			uurb-&gt;type = USBDEVFS_URB_TYPE_INTERRUPT;
+			goto interrupt_urb;
 		}
 		uurb-&gt;number_of_packets = 0;
 		if (uurb-&gt;buffer_length &gt; MAX_USBFS_BUFFER_SIZE)
 			return -EINVAL;
 		break;
 
+	case USBDEVFS_URB_TYPE_INTERRUPT:
+		if (!usb_endpoint_xfer_int(&amp;ep-&gt;desc))
+			return -EINVAL;
+ interrupt_urb:
+		uurb-&gt;number_of_packets = 0;
+		if (uurb-&gt;buffer_length &gt; MAX_USBFS_BUFFER_SIZE)
+			return -EINVAL;
+		break;
+
 	case USBDEVFS_URB_TYPE_ISO:
 		/* arbitrary limit */
 		if (uurb-&gt;number_of_packets &lt; 1 ||
@@ -1143,14 +1155,6 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 		uurb-&gt;buffer_length = totlen;
 		break;
 
-	case USBDEVFS_URB_TYPE_INTERRUPT:
-		uurb-&gt;number_of_packets = 0;
-		if (!usb_endpoint_xfer_int(&amp;ep-&gt;desc))
-			return -EINVAL;
-		if (uurb-&gt;buffer_length &gt; MAX_USBFS_BUFFER_SIZE)
-			return -EINVAL;
-		break;
-
 	default:
 		return -EINVAL;
 	}
diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index e7cae1334693..e2bd153cbd89 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -387,6 +387,13 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 	{
 	unsigned int	orig_flags = urb-&gt;transfer_flags;
 	unsigned int	allowed;
+	static int pipetypes[4] = {
+		PIPE_CONTROL, PIPE_ISOCHRONOUS, PIPE_BULK, PIPE_INTERRUPT
+	};
+
+	/* Check that the pipe's type matches the endpoint's type */
+	if (usb_pipetype(urb-&gt;pipe) != pipetypes[xfertype])
+		return -EPIPE;		/* The most suitable error code :-) */
 
 	/* enforce simple/standard policy */
 	allowed = (URB_NO_TRANSFER_DMA_MAP | URB_NO_SETUP_DMA_MAP |</pre><hr><pre>commit 6d19c009cc780c63de25a046509ebc9473809fd6
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Feb 12 12:21:11 2010 +0100

    USB: implement non-tree resume ordering constraints for PCI host controllers
    
    This patch (as1331) adds non-tree ordering constraints needed for
    proper resume of PCI USB host controllers from hibernation.  The main
    issue is that non-high-speed devices must not be resumed before the
    high-speed root hub, because it is the ehci_bus_resume() routine which
    takes care of handing the device connection over to the companion
    controller.  If the device resume is attempted before the handover
    then the device won't be found and it will be treated as though it had
    disconnected.
    
    The patch adds a new field to the usb_bus structure; for each
    full/low-speed bus this field will contain a pointer to the companion
    high-speed bus (if one exists).  It is used during normal device
    resume; if the hs_companion pointer isn't NULL then we wait for the
    root-hub device on the hs_companion bus.
    
    A secondary issue is that an EHCI controlller shouldn't be resumed
    before any of its companions.  On some machines I have observed
    handovers failing if the companion controller is reinitialized after
    the handover.  Thus, the EHCI resume routine must wait for the
    companion controllers to be resumed.
    
    The patch also fixes a small bug in usb_hcd_pci_probe(); an error path
    jumps to the wrong label, causing a memory leak.
    
    [rjw: Fixed compilation for CONFIG_PM_SLEEP unset.]
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;
    Signed-off-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 60a45f1e3a67..f2f055eb6831 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -1022,6 +1022,14 @@ static int usb_resume_device(struct usb_device *udev, pm_message_t msg)
 		goto done;
 	}
 
+	/* Non-root devices on a full/low-speed bus must wait for their
+	 * companion high-speed root hub, in case a handoff is needed.
+	 */
+	if (!(msg.event &amp; PM_EVENT_AUTO) &amp;&amp; udev-&gt;parent &amp;&amp;
+			udev-&gt;bus-&gt;hs_companion)
+		device_pm_wait_for_dev(&amp;udev-&gt;dev,
+				&amp;udev-&gt;bus-&gt;hs_companion-&gt;root_hub-&gt;dev);
+
 	if (udev-&gt;quirks &amp; USB_QUIRK_RESET_RESUME)
 		udev-&gt;reset_resume = 1;
 
diff --git a/drivers/usb/core/hcd-pci.c b/drivers/usb/core/hcd-pci.c
index 2dcf906df569..15286533c15a 100644
--- a/drivers/usb/core/hcd-pci.c
+++ b/drivers/usb/core/hcd-pci.c
@@ -19,6 +19,7 @@
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/module.h&gt;
 #include &lt;linux/pci.h&gt;
+#include &lt;linux/pm_runtime.h&gt;
 #include &lt;linux/usb.h&gt;
 
 #include &lt;asm/io.h&gt;
@@ -37,6 +38,122 @@
 
 /* PCI-based HCs are common, but plenty of non-PCI HCs are used too */
 
+#ifdef CONFIG_PM_SLEEP
+
+/* Coordinate handoffs between EHCI and companion controllers
+ * during system resume
+ */
+
+static DEFINE_MUTEX(companions_mutex);
+
+#define CL_UHCI		PCI_CLASS_SERIAL_USB_UHCI
+#define CL_OHCI		PCI_CLASS_SERIAL_USB_OHCI
+#define CL_EHCI		PCI_CLASS_SERIAL_USB_EHCI
+
+enum companion_action {
+	SET_HS_COMPANION, CLEAR_HS_COMPANION, WAIT_FOR_COMPANIONS
+};
+
+static void companion_common(struct pci_dev *pdev, struct usb_hcd *hcd,
+		enum companion_action action)
+{
+	struct pci_dev		*companion;
+	struct usb_hcd		*companion_hcd;
+	unsigned int		slot = PCI_SLOT(pdev-&gt;devfn);
+
+	/* Iterate through other PCI functions in the same slot.
+	 * If pdev is OHCI or UHCI then we are looking for EHCI, and
+	 * vice versa.
+	 */
+	companion = NULL;
+	for (;;) {
+		companion = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, companion);
+		if (!companion)
+			break;
+		if (companion-&gt;bus != pdev-&gt;bus ||
+				PCI_SLOT(companion-&gt;devfn) != slot)
+			continue;
+
+		companion_hcd = pci_get_drvdata(companion);
+		if (!companion_hcd)
+			continue;
+
+		/* For SET_HS_COMPANION, store a pointer to the EHCI bus in
+		 * the OHCI/UHCI companion bus structure.
+		 * For CLEAR_HS_COMPANION, clear the pointer to the EHCI bus
+		 * in the OHCI/UHCI companion bus structure.
+		 * For WAIT_FOR_COMPANIONS, wait until the OHCI/UHCI
+		 * companion controllers have fully resumed.
+		 */
+
+		if ((pdev-&gt;class == CL_OHCI || pdev-&gt;class == CL_UHCI) &amp;&amp;
+				companion-&gt;class == CL_EHCI) {
+			/* action must be SET_HS_COMPANION */
+			dev_dbg(&amp;companion-&gt;dev, "HS companion for %s\n",
+					dev_name(&amp;pdev-&gt;dev));
+			hcd-&gt;self.hs_companion = &amp;companion_hcd-&gt;self;
+
+		} else if (pdev-&gt;class == CL_EHCI &amp;&amp;
+				(companion-&gt;class == CL_OHCI ||
+				companion-&gt;class == CL_UHCI)) {
+			switch (action) {
+			case SET_HS_COMPANION:
+				dev_dbg(&amp;pdev-&gt;dev, "HS companion for %s\n",
+						dev_name(&amp;companion-&gt;dev));
+				companion_hcd-&gt;self.hs_companion = &amp;hcd-&gt;self;
+				break;
+			case CLEAR_HS_COMPANION:
+				companion_hcd-&gt;self.hs_companion = NULL;
+				break;
+			case WAIT_FOR_COMPANIONS:
+				device_pm_wait_for_dev(&amp;pdev-&gt;dev,
+						&amp;companion-&gt;dev);
+				break;
+			}
+		}
+	}
+}
+
+static void set_hs_companion(struct pci_dev *pdev, struct usb_hcd *hcd)
+{
+	mutex_lock(&amp;companions_mutex);
+	dev_set_drvdata(&amp;pdev-&gt;dev, hcd);
+	companion_common(pdev, hcd, SET_HS_COMPANION);
+	mutex_unlock(&amp;companions_mutex);
+}
+
+static void clear_hs_companion(struct pci_dev *pdev, struct usb_hcd *hcd)
+{
+	mutex_lock(&amp;companions_mutex);
+	dev_set_drvdata(&amp;pdev-&gt;dev, NULL);
+
+	/* If pdev is OHCI or UHCI, just clear its hs_companion pointer */
+	if (pdev-&gt;class == CL_OHCI || pdev-&gt;class == CL_UHCI)
+		hcd-&gt;self.hs_companion = NULL;
+
+	/* Otherwise search for companion buses and clear their pointers */
+	else
+		companion_common(pdev, hcd, CLEAR_HS_COMPANION);
+	mutex_unlock(&amp;companions_mutex);
+}
+
+static void wait_for_companions(struct pci_dev *pdev, struct usb_hcd *hcd)
+{
+	/* Only EHCI controllers need to wait.
+	 * No locking is needed because a controller cannot be resumed
+	 * while one of its companions is getting unbound.
+	 */
+	if (pdev-&gt;class == CL_EHCI)
+		companion_common(pdev, hcd, WAIT_FOR_COMPANIONS);
+}
+
+#else /* !CONFIG_PM_SLEEP */
+
+static inline void set_hs_companion(struct pci_dev *d, struct usb_hcd *h) {}
+static inline void clear_hs_companion(struct pci_dev *d, struct usb_hcd *h) {}
+static inline void wait_for_companions(struct pci_dev *d, struct usb_hcd *h) {}
+
+#endif /* !CONFIG_PM_SLEEP */
 
 /*-------------------------------------------------------------------------*/
 
@@ -123,7 +240,7 @@ int usb_hcd_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
 		if (region == PCI_ROM_RESOURCE) {
 			dev_dbg(&amp;dev-&gt;dev, "no i/o regions available\n");
 			retval = -EBUSY;
-			goto err1;
+			goto err2;
 		}
 	}
 
@@ -132,6 +249,7 @@ int usb_hcd_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
 	retval = usb_add_hcd(hcd, dev-&gt;irq, IRQF_DISABLED | IRQF_SHARED);
 	if (retval != 0)
 		goto err4;
+	set_hs_companion(dev, hcd);
 	return retval;
 
  err4:
@@ -142,6 +260,7 @@ int usb_hcd_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
 	} else
 		release_region(hcd-&gt;rsrc_start, hcd-&gt;rsrc_len);
  err2:
+	clear_hs_companion(dev, hcd);
 	usb_put_hcd(hcd);
  err1:
 	pci_disable_device(dev);
@@ -180,6 +299,7 @@ void usb_hcd_pci_remove(struct pci_dev *dev)
 	} else {
 		release_region(hcd-&gt;rsrc_start, hcd-&gt;rsrc_len);
 	}
+	clear_hs_companion(dev, hcd);
 	usb_put_hcd(hcd);
 	pci_disable_device(dev);
 }
@@ -344,6 +464,11 @@ static int resume_common(struct device *dev, bool hibernated)
 	clear_bit(HCD_FLAG_SAW_IRQ, &amp;hcd-&gt;flags);
 
 	if (hcd-&gt;driver-&gt;pci_resume) {
+		/* This call should be made only during system resume,
+		 * not during runtime resume.
+		 */
+		wait_for_companions(pci_dev, hcd);
+
 		retval = hcd-&gt;driver-&gt;pci_resume(hcd, hibernated);
 		if (retval) {
 			dev_err(dev, "PCI post-resume error %d!\n", retval);
diff --git a/include/linux/usb.h b/include/linux/usb.h
index d7ace1b80f09..332eaea61021 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -339,6 +339,7 @@ struct usb_bus {
 
 	struct usb_devmap devmap;	/* device address allocation map */
 	struct usb_device *root_hub;	/* Root hub */
+	struct usb_bus *hs_companion;	/* Companion EHCI bus, if any */
 	struct list_head bus_list;	/* list of busses */
 
 	int bandwidth_allocated;	/* on this bus: how much of the time</pre><hr><pre>commit ee37e09d81a4acf328f68189af12f116401f8c0f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Feb 12 12:13:55 2010 -0500

    [SCSI] fix duplicate removal on error path in scsi_sysfs_add_sdev
    
    This patch (as1335) fixes a bug in scsi_sysfs_add_sdev().  Its callers
    always remove the device if anything goes wrong, so it should never
    remove the device.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/scsi_sysfs.c b/drivers/scsi/scsi_sysfs.c
index 5a065055e68a..a4936c4e2f46 100644
--- a/drivers/scsi/scsi_sysfs.c
+++ b/drivers/scsi/scsi_sysfs.c
@@ -878,7 +878,8 @@ int scsi_sysfs_add_sdev(struct scsi_device *sdev)
 	struct request_queue *rq = sdev-&gt;request_queue;
 	struct scsi_target *starget = sdev-&gt;sdev_target;
 
-	if ((error = scsi_device_set_state(sdev, SDEV_RUNNING)) != 0)
+	error = scsi_device_set_state(sdev, SDEV_RUNNING);
+	if (error)
 		return error;
 
 	error = scsi_target_add(starget);
@@ -889,13 +890,13 @@ int scsi_sysfs_add_sdev(struct scsi_device *sdev)
 	error = device_add(&amp;sdev-&gt;sdev_gendev);
 	if (error) {
 		printk(KERN_INFO "error 1\n");
-		goto out_remove;
+		return error;
 	}
 	error = device_add(&amp;sdev-&gt;sdev_dev);
 	if (error) {
 		printk(KERN_INFO "error 2\n");
 		device_del(&amp;sdev-&gt;sdev_gendev);
-		goto out_remove;
+		return error;
 	}
 	transport_add_device(&amp;sdev-&gt;sdev_gendev);
 	sdev-&gt;is_visible = 1;
@@ -910,14 +911,14 @@ int scsi_sysfs_add_sdev(struct scsi_device *sdev)
 	else
 		error = device_create_file(&amp;sdev-&gt;sdev_gendev, &amp;dev_attr_queue_depth);
 	if (error)
-		goto out_remove;
+		return error;
 
 	if (sdev-&gt;host-&gt;hostt-&gt;change_queue_type)
 		error = device_create_file(&amp;sdev-&gt;sdev_gendev, &amp;sdev_attr_queue_type_rw);
 	else
 		error = device_create_file(&amp;sdev-&gt;sdev_gendev, &amp;dev_attr_queue_type);
 	if (error)
-		goto out_remove;
+		return error;
 
 	error = bsg_register_queue(rq, &amp;sdev-&gt;sdev_gendev, NULL, NULL);
 
@@ -933,16 +934,11 @@ int scsi_sysfs_add_sdev(struct scsi_device *sdev)
 			error = device_create_file(&amp;sdev-&gt;sdev_gendev,
 					sdev-&gt;host-&gt;hostt-&gt;sdev_attrs[i]);
 			if (error)
-				goto out_remove;
+				return error;
 		}
 	}
 
-	return 0;
-
- out_remove:
-	__scsi_remove_device(sdev);
 	return error;
-
 }
 
 void __scsi_remove_device(struct scsi_device *sdev)</pre><hr><pre>commit d5469119f0098881ab7f991990ef4f81ef13a194
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Feb 12 12:13:39 2010 -0500

    [SCSI] fix refcounting bug in scsi_get_host_dev
    
    This patch (as1334) fixes a bug in scsi_get_host_dev().  It
    incorrectly calls get_device() on the new device's target.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c
index 60b262d66b5b..f697229ae5a9 100644
--- a/drivers/scsi/scsi_scan.c
+++ b/drivers/scsi/scsi_scan.c
@@ -1909,10 +1909,9 @@ struct scsi_device *scsi_get_host_dev(struct Scsi_Host *shost)
 		goto out;
 
 	sdev = scsi_alloc_sdev(starget, 0, NULL);
-	if (sdev) {
-		sdev-&gt;sdev_gendev.parent = get_device(&amp;starget-&gt;dev);
+	if (sdev)
 		sdev-&gt;borken = 0;
-	} else
+	else
 		scsi_target_reap(starget);
 	put_device(&amp;starget-&gt;dev);
  out:</pre><hr><pre>commit 75f8ee8e01a6c96652f27da40d4bdac9e2e485f0
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Feb 12 12:13:31 2010 -0500

    [SCSI] fix memory leak in scsi_report_lun_scan
    
    This patch (as1333) fixes a bug in scsi_report_lun_scan().  If a
    newly-allocated device can't be used, it should be deleted.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c
index 012f73a96880..60b262d66b5b 100644
--- a/drivers/scsi/scsi_scan.c
+++ b/drivers/scsi/scsi_scan.c
@@ -1339,8 +1339,10 @@ static int scsi_report_lun_scan(struct scsi_target *starget, int bflags,
 		sdev = scsi_alloc_sdev(starget, 0, NULL);
 		if (!sdev)
 			return 0;
-		if (scsi_device_get(sdev))
+		if (scsi_device_get(sdev)) {
+			__scsi_remove_device(sdev);
 			return 0;
+		}
 	}
 
 	sprintf(devname, "host %d channel %d id %d",</pre><hr><pre>commit 49d0f078f494b9d81e820a13dd8093a9bfb0b6b1
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jan 8 11:18:38 2010 -0500

    USB: add missing delay during remote wakeup
    
    This patch (as1330) fixes a bug in khbud's handling of remote
    wakeups.  When a device sends a remote-wakeup request, the parent hub
    (or the host controller driver, for directly attached devices) begins
    the resume sequence and notifies khubd when the sequence finishes.  At
    this point the port's SUSPEND feature is automatically turned off.
    
    However the device needs an additional 10-ms resume-recovery time
    (TRSMRCY in the USB spec).  Khubd does not wait for this delay if the
    SUSPEND feature is off, and as a result some devices fail to behave
    properly following a remote wakeup.  This patch adds the missing
    delay to the remote-wakeup path.
    
    It also extends the resume-signalling delay used by ehci-hcd and
    uhci-hcd from 20 ms (the value in the spec) to 25 ms (the value we use
    for non-remote-wakeup resumes).  The extra time appears to help some
    devices.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Cc: Rickard Bellini &lt;rickard.bellini@ericsson.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 0cec6caf6e9b..b9f5fcd713e2 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -3347,6 +3347,9 @@ static void hub_events(void)
 					USB_PORT_FEAT_C_SUSPEND);
 				udev = hdev-&gt;children[i-1];
 				if (udev) {
+					/* TRSMRCY = 10 msec */
+					msleep(10);
+
 					usb_lock_device(udev);
 					ret = remote_wakeup(hdev-&gt;
 							children[i-1]);
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 5859522d6edd..1ec3857f22e6 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -787,9 +787,10 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 
 			/* start 20 msec resume signaling from this port,
 			 * and make khubd collect PORT_STAT_C_SUSPEND to
-			 * stop that signaling.
+			 * stop that signaling.  Use 5 ms extra for safety,
+			 * like usb_port_resume() does.
 			 */
-			ehci-&gt;reset_done [i] = jiffies + msecs_to_jiffies (20);
+			ehci-&gt;reset_done[i] = jiffies + msecs_to_jiffies(25);
 			ehci_dbg (ehci, "port %d remote wakeup\n", i + 1);
 			mod_timer(&amp;hcd-&gt;rh_timer, ehci-&gt;reset_done[i]);
 		}
diff --git a/drivers/usb/host/uhci-hub.c b/drivers/usb/host/uhci-hub.c
index 885b585360b9..8270055848ca 100644
--- a/drivers/usb/host/uhci-hub.c
+++ b/drivers/usb/host/uhci-hub.c
@@ -167,7 +167,7 @@ static void uhci_check_ports(struct uhci_hcd *uhci)
 				/* Port received a wakeup request */
 				set_bit(port, &amp;uhci-&gt;resuming_ports);
 				uhci-&gt;ports_timeout = jiffies +
-						msecs_to_jiffies(20);
+						msecs_to_jiffies(25);
 
 				/* Make sure we see the port again
 				 * after the resuming period is over. */</pre><hr><pre>commit cec3a53c7fe794237b582e8e77fc0e48465e65ee
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jan 8 11:18:20 2010 -0500

    USB: EHCI &amp; UHCI: fix race between root-hub suspend and port resume
    
    This patch (as1321) fixes a problem with EHCI and UHCI root-hub
    suspends: If the suspend occurs while a port is trying to resume, the
    resume doesn't finish and simply gets lost.  When remote wakeup is
    enabled, this is undesirable behavior.
    
    The patch checks first to see if any port resumes are in progress, and
    if they are then it fails the root-hub suspend with -EBUSY.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 2c6571c05f35..c75d9270c752 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -120,9 +120,26 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 	del_timer_sync(&amp;ehci-&gt;watchdog);
 	del_timer_sync(&amp;ehci-&gt;iaa_watchdog);
 
-	port = HCS_N_PORTS (ehci-&gt;hcs_params);
 	spin_lock_irq (&amp;ehci-&gt;lock);
 
+	/* Once the controller is stopped, port resumes that are already
+	 * in progress won't complete.  Hence if remote wakeup is enabled
+	 * for the root hub and any ports are in the middle of a resume or
+	 * remote wakeup, we must fail the suspend.
+	 */
+	if (hcd-&gt;self.root_hub-&gt;do_remote_wakeup) {
+		port = HCS_N_PORTS(ehci-&gt;hcs_params);
+		while (port--) {
+			if (ehci-&gt;reset_done[port] != 0) {
+				spin_unlock_irq(&amp;ehci-&gt;lock);
+				ehci_dbg(ehci, "suspend failed because "
+						"port %d is resuming\n",
+						port + 1);
+				return -EBUSY;
+			}
+		}
+	}
+
 	/* stop schedules, clean any completed work */
 	if (HC_IS_RUNNING(hcd-&gt;state)) {
 		ehci_quiesce (ehci);
@@ -138,6 +155,7 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 	 */
 	ehci-&gt;bus_suspended = 0;
 	ehci-&gt;owned_ports = 0;
+	port = HCS_N_PORTS(ehci-&gt;hcs_params);
 	while (port--) {
 		u32 __iomem	*reg = &amp;ehci-&gt;regs-&gt;port_status [port];
 		u32		t1 = ehci_readl(ehci, reg) &amp; ~PORT_RWC_BITS;
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 5cd0e48f67fb..99cd00fd3514 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -749,7 +749,20 @@ static int uhci_rh_suspend(struct usb_hcd *hcd)
 	spin_lock_irq(&amp;uhci-&gt;lock);
 	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags))
 		rc = -ESHUTDOWN;
-	else if (!uhci-&gt;dead)
+	else if (uhci-&gt;dead)
+		;		/* Dead controllers tell no tales */
+
+	/* Once the controller is stopped, port resumes that are already
+	 * in progress won't complete.  Hence if remote wakeup is enabled
+	 * for the root hub and any ports are in the middle of a resume or
+	 * remote wakeup, we must fail the suspend.
+	 */
+	else if (hcd-&gt;self.root_hub-&gt;do_remote_wakeup &amp;&amp;
+			uhci-&gt;resuming_ports) {
+		dev_dbg(uhci_dev(uhci), "suspend failed because a port "
+				"is resuming\n");
+		rc = -EBUSY;
+	} else
 		suspend_rh(uhci, UHCI_RH_SUSPENDED);
 	spin_unlock_irq(&amp;uhci-&gt;lock);
 	return rc;</pre>
    <div class="pagination">
        <a href='2_69.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><span>[70]</span><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_71.html'>Next&gt;&gt;</a>
    <div>
</body>
