<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_134.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><span>[135]</span><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_136.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 8b4cd42134fbd3c9a9a5c3467d31717798219b1b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Sep 16 14:17:45 2005 -0400

    [PATCH] USB: UHCI: Remove unused fields and unneeded tests for NULL
    
    This patch (as562) removes from the uhci-hcd driver a few unused fields
    and some unnecessary tests against NULL and assignments to NULL.  In fact
    it wasn't until fairly recently that the tests became unnecessary.
    Before last winter it was possible that the driver's stop() routine would
    get called even if the start() routine returned an error, but now that
    can't happen.  Hence there's no longer any need to check for partial
    initialization.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-debug.c b/drivers/usb/host/uhci-debug.c
index 4538a98b6f9d..04eddd7995c3 100644
--- a/drivers/usb/host/uhci-debug.c
+++ b/drivers/usb/host/uhci-debug.c
@@ -348,7 +348,6 @@ static int uhci_show_urbp(struct uhci_hcd *uhci, struct urb_priv *urbp, char *bu
 
 	if (urbp-&gt;urb-&gt;status != -EINPROGRESS)
 		out += sprintf(out, "Status=%d ", urbp-&gt;urb-&gt;status);
-	//out += sprintf(out, "Inserttime=%lx ",urbp-&gt;inserttime);
 	//out += sprintf(out, "FSBRtime=%lx ",urbp-&gt;fsbrtime);
 
 	count = 0;
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 0c024898cbea..17de9ee910f6 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -437,36 +437,18 @@ static void release_uhci(struct uhci_hcd *uhci)
 	int i;
 
 	for (i = 0; i &lt; UHCI_NUM_SKELQH; i++)
-		if (uhci-&gt;skelqh[i]) {
-			uhci_free_qh(uhci, uhci-&gt;skelqh[i]);
-			uhci-&gt;skelqh[i] = NULL;
-		}
+		uhci_free_qh(uhci, uhci-&gt;skelqh[i]);
 
-	if (uhci-&gt;term_td) {
-		uhci_free_td(uhci, uhci-&gt;term_td);
-		uhci-&gt;term_td = NULL;
-	}
+	uhci_free_td(uhci, uhci-&gt;term_td);
 
-	if (uhci-&gt;qh_pool) {
-		dma_pool_destroy(uhci-&gt;qh_pool);
-		uhci-&gt;qh_pool = NULL;
-	}
+	dma_pool_destroy(uhci-&gt;qh_pool);
 
-	if (uhci-&gt;td_pool) {
-		dma_pool_destroy(uhci-&gt;td_pool);
-		uhci-&gt;td_pool = NULL;
-	}
+	dma_pool_destroy(uhci-&gt;td_pool);
 
-	if (uhci-&gt;fl) {
-		dma_free_coherent(uhci_dev(uhci), sizeof(*uhci-&gt;fl),
-				uhci-&gt;fl, uhci-&gt;fl-&gt;dma_handle);
-		uhci-&gt;fl = NULL;
-	}
+	dma_free_coherent(uhci_dev(uhci), sizeof(*uhci-&gt;fl),
+			uhci-&gt;fl, uhci-&gt;fl-&gt;dma_handle);
 
-	if (uhci-&gt;dentry) {
-		debugfs_remove(uhci-&gt;dentry);
-		uhci-&gt;dentry = NULL;
-	}
+	debugfs_remove(uhci-&gt;dentry);
 }
 
 static int uhci_reset(struct usb_hcd *hcd)
@@ -690,31 +672,25 @@ static int uhci_start(struct usb_hcd *hcd)
  * error exits:
  */
 err_alloc_skelqh:
-	for (i = 0; i &lt; UHCI_NUM_SKELQH; i++)
-		if (uhci-&gt;skelqh[i]) {
+	for (i = 0; i &lt; UHCI_NUM_SKELQH; i++) {
+		if (uhci-&gt;skelqh[i])
 			uhci_free_qh(uhci, uhci-&gt;skelqh[i]);
-			uhci-&gt;skelqh[i] = NULL;
-		}
+	}
 
 	uhci_free_td(uhci, uhci-&gt;term_td);
-	uhci-&gt;term_td = NULL;
 
 err_alloc_term_td:
 	dma_pool_destroy(uhci-&gt;qh_pool);
-	uhci-&gt;qh_pool = NULL;
 
 err_create_qh_pool:
 	dma_pool_destroy(uhci-&gt;td_pool);
-	uhci-&gt;td_pool = NULL;
 
 err_create_td_pool:
 	dma_free_coherent(uhci_dev(uhci), sizeof(*uhci-&gt;fl),
 			uhci-&gt;fl, uhci-&gt;fl-&gt;dma_handle);
-	uhci-&gt;fl = NULL;
 
 err_alloc_fl:
 	debugfs_remove(uhci-&gt;dentry);
-	uhci-&gt;dentry = NULL;
 
 err_create_debug_entry:
 	return retval;
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index 282f40b75881..1c161b4f5bcf 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -205,8 +205,6 @@ struct uhci_td {
 	/* Software fields */
 	dma_addr_t dma_handle;
 
-	struct urb *urb;
-
 	struct list_head list;		/* P: urb-&gt;lock */
 	struct list_head remove_list;	/* P: uhci-&gt;td_remove_list_lock */
 
@@ -434,7 +432,6 @@ struct urb_priv {
 						/*  a control transfer, retrigger */
 						/*  the status phase */
 
-	unsigned long inserttime;	/* In jiffies */
 	unsigned long fsbrtime;		/* In jiffies */
 
 	struct list_head queue_list;	/* P: uhci-&gt;frame_list_lock */
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 4e0fbe2c1a9a..d54038211ca6 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -443,7 +443,6 @@ static struct urb_priv *uhci_alloc_urb_priv(struct uhci_hcd *uhci, struct urb *u
 
 	memset((void *)urbp, 0, sizeof(*urbp));
 
-	urbp-&gt;inserttime = jiffies;
 	urbp-&gt;fsbrtime = jiffies;
 	urbp-&gt;urb = urb;
 	
@@ -462,8 +461,6 @@ static void uhci_add_td_to_urb(struct urb *urb, struct uhci_td *td)
 {
 	struct urb_priv *urbp = (struct urb_priv *)urb-&gt;hcpriv;
 
-	td-&gt;urb = urb;
-
 	list_add_tail(&amp;td-&gt;list, &amp;urbp-&gt;td_list);
 }
 
@@ -473,8 +470,6 @@ static void uhci_remove_td_from_urb(struct uhci_td *td)
 		return;
 
 	list_del_init(&amp;td-&gt;list);
-
-	td-&gt;urb = NULL;
 }
 
 static void uhci_destroy_urb_priv(struct uhci_hcd *uhci, struct urb *urb)</pre><hr><pre>commit d1209d049bbc3df66650f8417637be4f7b57b604
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Oct 19 21:23:51 2005 -0700

    [PATCH] Threads shouldn't inherit PF_NOFREEZE
    
    The PF_NOFREEZE process flag should not be inherited when a thread is
    forked.  This patch (as585) removes the flag from the child.
    
    This problem is starting to show up more and more as drivers turn to the
    kthread API instead of using kernel_thread().  As a result, their kernel
    threads are now children of the kthread worker instead of modprobe, and
    they inherit the PF_NOFREEZE flag.  This can cause problems during system
    suspend; the kernel threads are not getting frozen as they ought to be.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Pavel Machek &lt;pavel@ucw.cz&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/kernel/fork.c b/kernel/fork.c
index 533ce27f4b2c..280bd44ac441 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -848,7 +848,7 @@ static inline void copy_flags(unsigned long clone_flags, struct task_struct *p)
 {
 	unsigned long new_flags = p-&gt;flags;
 
-	new_flags &amp;= ~PF_SUPERPRIV;
+	new_flags &amp;= ~(PF_SUPERPRIV | PF_NOFREEZE);
 	new_flags |= PF_FORKNOEXEC;
 	if (!(clone_flags &amp; CLONE_PTRACE))
 		p-&gt;ptrace = 0;</pre><hr><pre>commit 7c72ce81870ded9365f4bc5caa98ef1591dd18dd
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Oct 14 11:23:27 2005 -0400

    [SCSI] Fix leak of Scsi_Cmnds
    
    When a request is deferred in scsi_init_io because the sg table could not
    be allocated, the associated scsi_cmnd is not released and the request is
    not marked with REQ_DONTPREP.  When the command is retried, if
    scsi_prep_fn decides to kill it then the scsi_cmnd will never be released.
    
    This patch (as573) changes scsi_init_io so that it calls scsi_put_command
    before deferring a request.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
index dc9c772bc874..0074f28c37b2 100644
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@ -97,7 +97,6 @@ int scsi_insert_special_req(struct scsi_request *sreq, int at_head)
 }
 
 static void scsi_run_queue(struct request_queue *q);
-static void scsi_release_buffers(struct scsi_cmnd *cmd);
 
 /*
  * Function:	scsi_unprep_request()
@@ -1040,8 +1039,10 @@ static int scsi_init_io(struct scsi_cmnd *cmd)
 	 * if sg table allocation fails, requeue request later.
 	 */
 	sgpnt = scsi_alloc_sgtable(cmd, GFP_ATOMIC);
-	if (unlikely(!sgpnt))
+	if (unlikely(!sgpnt)) {
+		scsi_unprep_request(req);
 		return BLKPREP_DEFER;
+	}
 
 	cmd-&gt;request_buffer = (char *) sgpnt;
 	cmd-&gt;request_bufflen = req-&gt;nr_sectors &lt;&lt; 9;
@@ -1245,8 +1246,8 @@ static int scsi_prep_fn(struct request_queue *q, struct request *req)
 		 */
 		ret = scsi_init_io(cmd);
 		switch(ret) {
+			/* For BLKPREP_KILL/DEFER the cmd was released */
 		case BLKPREP_KILL:
-			/* BLKPREP_KILL return also releases the command */
 			goto kill;
 		case BLKPREP_DEFER:
 			goto defer;</pre><hr><pre>commit 0fc084eaffe0a9a82a0c94da9ee9f7060ade8b04
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Sep 22 00:49:51 2005 -0700

    [PATCH] USB: Update Documentation/usb/URB.txt
    
    This patch (as564) updates Documentation/usb/URB.txt, bringing it roughly
    up to the current level.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/Documentation/usb/URB.txt b/Documentation/usb/URB.txt
index d59b95cc6f1b..a49e5f2c2b46 100644
--- a/Documentation/usb/URB.txt
+++ b/Documentation/usb/URB.txt
@@ -1,5 +1,6 @@
 Revised: 2000-Dec-05.
 Again:   2002-Jul-06
+Again:   2005-Sep-19
 
     NOTE:
 
@@ -18,8 +19,8 @@ called USB Request Block, or URB for short.
   and deliver the data and status back. 
 
 - Execution of an URB is inherently an asynchronous operation, i.e. the 
-  usb_submit_urb(urb) call returns immediately after it has successfully queued 
-  the requested action. 
+  usb_submit_urb(urb) call returns immediately after it has successfully
+  queued the requested action.
 
 - Transfers for one URB can be canceled with usb_unlink_urb(urb) at any time. 
 
@@ -94,8 +95,9 @@ To free an URB, use
 
 	void usb_free_urb(struct urb *urb)
 
-You may not free an urb that you've submitted, but which hasn't yet been
-returned to you in a completion callback.
+You may free an urb that you've submitted, but which hasn't yet been
+returned to you in a completion callback.  It will automatically be
+deallocated when it is no longer in use.
 
 
 1.4. What has to be filled in?
@@ -145,30 +147,36 @@ to get seamless ISO streaming.
 
 1.6. How to cancel an already running URB?
 
-For an URB which you've submitted, but which hasn't been returned to
-your driver by the host controller, call
+There are two ways to cancel an URB you've submitted but which hasn't
+been returned to your driver yet.  For an asynchronous cancel, call
 
 	int usb_unlink_urb(struct urb *urb)
 
 It removes the urb from the internal list and frees all allocated
-HW descriptors. The status is changed to reflect unlinking. After 
-usb_unlink_urb() returns with that status code, you can free the URB
-with usb_free_urb().
+HW descriptors. The status is changed to reflect unlinking.  Note
+that the URB will not normally have finished when usb_unlink_urb()
+returns; you must still wait for the completion handler to be called.
 
-There is also an asynchronous unlink mode.  To use this, set the
-the URB_ASYNC_UNLINK flag in urb-&gt;transfer flags before calling
-usb_unlink_urb().  When using async unlinking, the URB will not
-normally be unlinked when usb_unlink_urb() returns.  Instead, wait
-for the completion handler to be called.
+To cancel an URB synchronously, call
+
+	void usb_kill_urb(struct urb *urb)
+
+It does everything usb_unlink_urb does, and in addition it waits
+until after the URB has been returned and the completion handler
+has finished.  It also marks the URB as temporarily unusable, so
+that if the completion handler or anyone else tries to resubmit it
+they will get a -EPERM error.  Thus you can be sure that when
+usb_kill_urb() returns, the URB is totally idle.
 
 
 1.7. What about the completion handler?
 
 The handler is of the following type:
 
-	typedef void (*usb_complete_t)(struct urb *);
+	typedef void (*usb_complete_t)(struct urb *, struct pt_regs *)
 
-i.e. it gets just the URB that caused the completion call.
+I.e., it gets the URB that caused the completion call, plus the
+register values at the time of the corresponding interrupt (if any).
 In the completion handler, you should have a look at urb-&gt;status to
 detect any USB errors. Since the context parameter is included in the URB,
 you can pass information to the completion handler. 
@@ -176,17 +184,11 @@ you can pass information to the completion handler.
 Note that even when an error (or unlink) is reported, data may have been
 transferred.  That's because USB transfers are packetized; it might take
 sixteen packets to transfer your 1KByte buffer, and ten of them might
-have transferred succesfully before the completion is called.
+have transferred succesfully before the completion was called.
 
 
 NOTE:  ***** WARNING *****
-Don't use urb-&gt;dev field in your completion handler; it's cleared
-as part of giving urbs back to drivers.  (Addressing an issue with
-ownership of periodic URBs, which was otherwise ambiguous.) Instead,
-use urb-&gt;context to hold all the data your driver needs.
-
-NOTE:  ***** WARNING *****
-Also, NEVER SLEEP IN A COMPLETION HANDLER.  These are normally called
+NEVER SLEEP IN A COMPLETION HANDLER.  These are normally called
 during hardware interrupt processing.  If you can, defer substantial
 work to a tasklet (bottom half) to keep system latencies low.  You'll
 probably need to use spinlocks to protect data structures you manipulate
@@ -229,24 +231,10 @@ ISO data with some other event stream.
 Interrupt transfers, like isochronous transfers, are periodic, and happen
 in intervals that are powers of two (1, 2, 4 etc) units.  Units are frames
 for full and low speed devices, and microframes for high speed ones.
-
-Currently, after you submit one interrupt URB, that urb is owned by the
-host controller driver until you cancel it with usb_unlink_urb().  You
-may unlink interrupt urbs in their completion handlers, if you need to.
-
-After a transfer completion is called, the URB is automagically resubmitted.
-THIS BEHAVIOR IS EXPECTED TO BE REMOVED!!
-
-Interrupt transfers may only send (or receive) the "maxpacket" value for
-the given interrupt endpoint; if you need more data, you will need to
-copy that data out of (or into) another buffer.  Similarly, you can't
-queue interrupt transfers.
-THESE RESTRICTIONS ARE EXPECTED TO BE REMOVED!!
-
-Note that this automagic resubmission model does make it awkward to use
-interrupt OUT transfers.  The portable solution involves unlinking those
-OUT urbs after the data is transferred, and perhaps submitting a final
-URB for a short packet.
-
 The usb_submit_urb() call modifies urb-&gt;interval to the implemented interval
 value that is less than or equal to the requested interval value.
+
+In Linux 2.6, unlike earlier versions, interrupt URBs are not automagically
+restarted when they complete.  They end when the completion handler is
+called, just like other URBs.  If you want an interrupt URB to be restarted,
+your completion handler must resubmit it.</pre><hr><pre>commit a64358db1253b35d508a411e80a3ad23b859ec88
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jul 26 10:27:10 2005 -0400

    [SCSI] SCSI scanning and removal fixes
    
    This patch (as545) fixes the list traversals in __scsi_remove_target and
    scsi_forget_host.  In each case the existing code list_for_each_entry_safe
    in an _unsafe_ manner, because the list was not protected from outside
    modification while the iteration was running.
    
    The new scsi_forget_host routine takes the moderately controversial step
    of iterating over devices for removal rather than iterating over targets.
    This makes more sense to me because the current scheme treats targets as
    second-class citizens, created and removed on demand, rather than as
    objects corresponding to actual hardware.  (Also I couldn't figure out any
    safe way to iterate over the target list, since it's not so easy to tell
    when a target has already been removed.)
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c
index b86f170fa8ed..fcf9f6cbb142 100644
--- a/drivers/scsi/scsi_scan.c
+++ b/drivers/scsi/scsi_scan.c
@@ -1466,23 +1466,17 @@ EXPORT_SYMBOL(scsi_scan_single_target);
 
 void scsi_forget_host(struct Scsi_Host *shost)
 {
-	struct scsi_target *starget, *tmp;
+	struct scsi_device *sdev;
 	unsigned long flags;
 
-	/*
-	 * Ok, this look a bit strange.  We always look for the first device
-	 * on the list as scsi_remove_device removes them from it - thus we
-	 * also have to release the lock.
-	 * We don't need to get another reference to the device before
-	 * releasing the lock as we already own the reference from
-	 * scsi_register_device that's release in scsi_remove_device.  And
-	 * after that we don't look at sdev anymore.
-	 */
+ restart:
 	spin_lock_irqsave(shost-&gt;host_lock, flags);
-	list_for_each_entry_safe(starget, tmp, &amp;shost-&gt;__targets, siblings) {
+	list_for_each_entry(sdev, &amp;shost-&gt;__devices, siblings) {
+		if (sdev-&gt;sdev_state == SDEV_DEL)
+			continue;
 		spin_unlock_irqrestore(shost-&gt;host_lock, flags);
-		scsi_remove_target(&amp;starget-&gt;dev);
-		spin_lock_irqsave(shost-&gt;host_lock, flags);
+		__scsi_remove_device(sdev);
+		goto restart;
 	}
 	spin_unlock_irqrestore(shost-&gt;host_lock, flags);
 }
diff --git a/drivers/scsi/scsi_sysfs.c b/drivers/scsi/scsi_sysfs.c
index 83f87c41b18d..1e47b7eddef4 100644
--- a/drivers/scsi/scsi_sysfs.c
+++ b/drivers/scsi/scsi_sysfs.c
@@ -719,17 +719,20 @@ void __scsi_remove_target(struct scsi_target *starget)
 {
 	struct Scsi_Host *shost = dev_to_shost(starget-&gt;dev.parent);
 	unsigned long flags;
-	struct scsi_device *sdev, *tmp;
+	struct scsi_device *sdev;
 
 	spin_lock_irqsave(shost-&gt;host_lock, flags);
 	starget-&gt;reap_ref++;
-	list_for_each_entry_safe(sdev, tmp, &amp;shost-&gt;__devices, siblings) {
+ restart:
+	list_for_each_entry(sdev, &amp;shost-&gt;__devices, siblings) {
 		if (sdev-&gt;channel != starget-&gt;channel ||
-		    sdev-&gt;id != starget-&gt;id)
+		    sdev-&gt;id != starget-&gt;id ||
+		    sdev-&gt;sdev_state == SDEV_DEL)
 			continue;
 		spin_unlock_irqrestore(shost-&gt;host_lock, flags);
 		scsi_remove_device(sdev);
 		spin_lock_irqsave(shost-&gt;host_lock, flags);
+		goto restart;
 	}
 	spin_unlock_irqrestore(shost-&gt;host_lock, flags);
 	scsi_target_reap(starget);</pre><hr><pre>commit b95be99d52ce4f9db9ff0bd5f10e9e2066da6d2e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Sep 15 13:52:51 2005 -0400

    [SCSI] fix oops in scsi_release_buffers()
    
    I found one other thing that needs to be fixed.  The call to
    scsi_release_buffers in scsi_unprep_request causes an oops, because the
    sgtable has already been freed in scsi_io_completion.  The following patch
    is needed.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
index 0c6924eecf59..f065cbc1a6e5 100644
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@ -118,7 +118,6 @@ static void scsi_unprep_request(struct request *req)
 	req-&gt;flags &amp;= ~REQ_DONTPREP;
 	req-&gt;special = (req-&gt;flags &amp; REQ_SPECIAL) ? cmd-&gt;sc_request : NULL;
 
-	scsi_release_buffers(cmd);
 	scsi_put_command(cmd);
 }
 
@@ -1512,7 +1511,6 @@ static void scsi_request_fn(struct request_queue *q)
 	 * cases (host limits or settings) should run the queue at some
 	 * later time.
 	 */
-	scsi_unprep_request(req);
 	spin_lock_irq(q-&gt;queue_lock);
 	blk_requeue_request(q, req);
 	sdev-&gt;device_busy--;</pre><hr><pre>commit 541950027f8b7c96a639bc16e48930c590f1b98a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Sep 15 21:52:51 2005 -0400

    [SCSI] fix use after potential free in scsi_remove_device
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/scsi_sysfs.c b/drivers/scsi/scsi_sysfs.c
index b8052d5206cc..83f87c41b18d 100644
--- a/drivers/scsi/scsi_sysfs.c
+++ b/drivers/scsi/scsi_sysfs.c
@@ -707,9 +707,11 @@ void __scsi_remove_device(struct scsi_device *sdev)
  **/
 void scsi_remove_device(struct scsi_device *sdev)
 {
-	down(&amp;sdev-&gt;host-&gt;scan_mutex);
+	struct Scsi_Host *shost = sdev-&gt;host;
+
+	down(&amp;shost-&gt;scan_mutex);
 	__scsi_remove_device(sdev);
-	up(&amp;sdev-&gt;host-&gt;scan_mutex);
+	up(&amp;shost-&gt;scan_mutex);
 }
 EXPORT_SYMBOL(scsi_remove_device);
 </pre><hr><pre>commit 1f09df8bfe358994fcb5f3dc4f890694c4069621
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Sep 5 13:59:51 2005 -0400

    [PATCH] USB UHCI: remove the FSBR kernel timer
    
    This patch (as558) removes from the UHCI driver a kernel timer used for
    checking Full Speed Bandwidth Reclamation (FSBR).  The checking can be
    done during normal root-hub polling; it doesn't need a separate timer.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 0d5d2545bf07..0c024898cbea 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -97,14 +97,9 @@ static void uhci_get_current_frame_number(struct uhci_hcd *uhci);
 /* to make sure it doesn't hog all of the bandwidth */
 #define DEPTH_INTERVAL 5
 
-static inline void restart_timer(struct uhci_hcd *uhci)
-{
-	mod_timer(&amp;uhci-&gt;stall_timer, jiffies + msecs_to_jiffies(100));
-}
-
-#include "uhci-hub.c"
 #include "uhci-debug.c"
 #include "uhci-q.c"
+#include "uhci-hub.c"
 
 /*
  * Make sure the controller is completely inactive, unable to
@@ -160,7 +155,6 @@ static void hc_died(struct uhci_hcd *uhci)
 {
 	reset_hc(uhci);
 	uhci-&gt;hc_inaccessible = 1;
-	del_timer(&amp;uhci-&gt;stall_timer);
 }
 
 /*
@@ -287,8 +281,11 @@ __acquires(uhci-&gt;lock)
 	/* Enable resume-detect interrupts if they work.
 	 * Then enter Global Suspend mode, still configured.
 	 */
-	int_enable = (resume_detect_interrupts_are_broken(uhci) ?
-			0 : USBINTR_RESUME);
+	uhci-&gt;working_RD = 1;
+	int_enable = USBINTR_RESUME;
+	if (resume_detect_interrupts_are_broken(uhci)) {
+		uhci-&gt;working_RD = int_enable = 0;
+	}
 	outw(int_enable, uhci-&gt;io_addr + USBINTR);
 	outw(USBCMD_EGSM | USBCMD_CF, uhci-&gt;io_addr + USBCMD);
 	mb();
@@ -315,7 +312,6 @@ __acquires(uhci-&gt;lock)
 
 	uhci-&gt;rh_state = new_state;
 	uhci-&gt;is_stopped = UHCI_IS_STOPPED;
-	del_timer(&amp;uhci-&gt;stall_timer);
 	uhci_to_hcd(uhci)-&gt;poll_rh = !int_enable;
 
 	uhci_scan_schedule(uhci, NULL);
@@ -335,7 +331,6 @@ static void start_rh(struct uhci_hcd *uhci)
 	mb();
 	uhci-&gt;rh_state = UHCI_RH_RUNNING;
 	uhci_to_hcd(uhci)-&gt;poll_rh = 1;
-	restart_timer(uhci);
 }
 
 static void wakeup_rh(struct uhci_hcd *uhci)
@@ -374,20 +369,6 @@ __acquires(uhci-&gt;lock)
 	mod_timer(&amp;uhci_to_hcd(uhci)-&gt;rh_timer, jiffies);
 }
 
-static void stall_callback(unsigned long _uhci)
-{
-	struct uhci_hcd *uhci = (struct uhci_hcd *) _uhci;
-	unsigned long flags;
-
-	spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
-	uhci_scan_schedule(uhci, NULL);
-	check_fsbr(uhci);
-
-	if (!uhci-&gt;is_stopped)
-		restart_timer(uhci);
-	spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
-}
-
 static irqreturn_t uhci_irq(struct usb_hcd *hcd, struct pt_regs *regs)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
@@ -418,8 +399,10 @@ static irqreturn_t uhci_irq(struct usb_hcd *hcd, struct pt_regs *regs)
 					"host controller halted, "
 					"very bad!\n");
 				hc_died(uhci);
-				spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
-				return IRQ_HANDLED;
+
+				/* Force a callback in case there are
+				 * pending unlinks */
+				mod_timer(&amp;hcd-&gt;rh_timer, jiffies);
 			}
 			spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
 		}
@@ -427,10 +410,11 @@ static irqreturn_t uhci_irq(struct usb_hcd *hcd, struct pt_regs *regs)
 
 	if (status &amp; USBSTS_RD)
 		usb_hcd_poll_rh_status(hcd);
-
-	spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
-	uhci_scan_schedule(uhci, regs);
-	spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
+	else {
+		spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
+		uhci_scan_schedule(uhci, regs);
+		spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
+	}
 
 	return IRQ_HANDLED;
 }
@@ -595,10 +579,6 @@ static int uhci_start(struct usb_hcd *hcd)
 
 	init_waitqueue_head(&amp;uhci-&gt;waitqh);
 
-	init_timer(&amp;uhci-&gt;stall_timer);
-	uhci-&gt;stall_timer.function = stall_callback;
-	uhci-&gt;stall_timer.data = (unsigned long) uhci;
-
 	uhci-&gt;fl = dma_alloc_coherent(uhci_dev(uhci), sizeof(*uhci-&gt;fl),
 			&amp;dma_handle, 0);
 	if (!uhci-&gt;fl) {
@@ -745,11 +725,11 @@ static void uhci_stop(struct usb_hcd *hcd)
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 
 	spin_lock_irq(&amp;uhci-&gt;lock);
-	reset_hc(uhci);
+	if (!uhci-&gt;hc_inaccessible)
+		reset_hc(uhci);
 	uhci_scan_schedule(uhci, NULL);
 	spin_unlock_irq(&amp;uhci-&gt;lock);
 
-	del_timer_sync(&amp;uhci-&gt;stall_timer);
 	release_uhci(uhci);
 }
 
@@ -811,13 +791,12 @@ static int uhci_suspend(struct usb_hcd *hcd, pm_message_t message)
 	 */
 	pci_write_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP, 0);
 	uhci-&gt;hc_inaccessible = 1;
+	hcd-&gt;poll_rh = 0;
 
 	/* FIXME: Enable non-PME# remote wakeup? */
 
 done:
 	spin_unlock_irq(&amp;uhci-&gt;lock);
-	if (rc == 0)
-		del_timer_sync(&amp;hcd-&gt;rh_timer);
 	return rc;
 }
 
@@ -850,8 +829,11 @@ static int uhci_resume(struct usb_hcd *hcd)
 
 	spin_unlock_irq(&amp;uhci-&gt;lock);
 
-	if (hcd-&gt;poll_rh)
+	if (!uhci-&gt;working_RD) {
+		/* Suspended root hub needs to be polled */
+		hcd-&gt;poll_rh = 1;
 		usb_hcd_poll_rh_status(hcd);
+	}
 	return 0;
 }
 #endif
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index bf9c5f9b508b..282f40b75881 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -345,9 +345,6 @@ enum uhci_rh_state {
 
 /*
  * This describes the full uhci information.
- *
- * Note how the "proper" USB information is just
- * a subset of what the full implementation needs.
  */
 struct uhci_hcd {
 
@@ -360,8 +357,6 @@ struct uhci_hcd {
 	struct dma_pool *qh_pool;
 	struct dma_pool *td_pool;
 
-	struct usb_bus *bus;
-
 	struct uhci_td *term_td;	/* Terminating TD, see UHCI bug */
 	struct uhci_qh *skelqh[UHCI_NUM_SKELQH];	/* Skeleton QH's */
 
@@ -380,6 +375,8 @@ struct uhci_hcd {
 	unsigned int scan_in_progress:1;	/* Schedule scan is running */
 	unsigned int need_rescan:1;		/* Redo the schedule scan */
 	unsigned int hc_inaccessible:1;		/* HC is suspended or dead */
+	unsigned int working_RD:1;		/* Suspended root hub doesn't
+						   need to be polled */
 
 	/* Support for port suspend/resume/reset */
 	unsigned long port_c_suspend;		/* Bit-arrays of ports */
@@ -405,9 +402,7 @@ struct uhci_hcd {
 	/* List of URB's awaiting completion callback */
 	struct list_head complete_list;		/* P: uhci-&gt;lock */
 
-	int rh_numports;
-
-	struct timer_list stall_timer;
+	int rh_numports;			/* Number of root-hub ports */
 
 	wait_queue_head_t waitqh;		/* endpoint_disable waiters */
 };
diff --git a/drivers/usb/host/uhci-hub.c b/drivers/usb/host/uhci-hub.c
index 4eace2b19ddb..a71e48a66805 100644
--- a/drivers/usb/host/uhci-hub.c
+++ b/drivers/usb/host/uhci-hub.c
@@ -145,15 +145,16 @@ static int uhci_hub_status_data(struct usb_hcd *hcd, char *buf)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 	unsigned long flags;
-	int status;
+	int status = 0;
 
 	spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
-	if (uhci-&gt;hc_inaccessible) {
-		status = 0;
-		goto done;
-	}
 
+	uhci_scan_schedule(uhci, NULL);
+	if (uhci-&gt;hc_inaccessible)
+		goto done;
+	check_fsbr(uhci);
 	uhci_check_ports(uhci);
+
 	status = get_hub_status_data(uhci, buf);
 
 	switch (uhci-&gt;rh_state) {
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index bbb36cd6ed61..ea0d168a8c67 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -33,7 +33,7 @@ static void uhci_free_pending_tds(struct uhci_hcd *uhci);
 static inline void uhci_set_next_interrupt(struct uhci_hcd *uhci)
 {
 	if (uhci-&gt;is_stopped)
-		mod_timer(&amp;uhci-&gt;stall_timer, jiffies);
+		mod_timer(&amp;uhci_to_hcd(uhci)-&gt;rh_timer, jiffies);
 	uhci-&gt;term_td-&gt;status |= cpu_to_le32(TD_CTRL_IOC); 
 }
 </pre><hr><pre>commit f1a15606d5be8490a122f1c94c554bd0f07d8d26
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Sep 5 13:55:23 2005 -0400

    [PATCH] usbcore: small changes to HCD glue layer
    
    This patch (as549) introduces two small changes in the HCD glue layer.
    The first simply removes a redundant test.  The second allows root-hub
    polling to continue for a single iteration after a host controller dies;
    this is needed for the patch that follows.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 12ecdb03ee5f..1017a97a418b 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1606,7 +1606,7 @@ irqreturn_t usb_hcd_irq (int irq, void *__hcd, struct pt_regs * r)
 		return IRQ_NONE;
 
 	hcd-&gt;saw_irq = 1;
-	if (hcd-&gt;state != start &amp;&amp; hcd-&gt;state == HC_STATE_HALT)
+	if (hcd-&gt;state == HC_STATE_HALT)
 		usb_hc_died (hcd);
 	return IRQ_HANDLED;
 }
@@ -1630,7 +1630,6 @@ void usb_hc_died (struct usb_hcd *hcd)
 	spin_lock_irqsave (&amp;hcd_root_hub_lock, flags);
 	if (hcd-&gt;rh_registered) {
 		hcd-&gt;poll_rh = 0;
-		del_timer(&amp;hcd-&gt;rh_timer);
 
 		/* make khubd clean up old urbs and devices */
 		usb_set_device_state (hcd-&gt;self.root_hub,</pre><hr><pre>commit b70d37bf61f278f9d9adf17c52af6b2d0ae7800c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jul 26 10:30:40 2005 -0400

    [SCSI] Fix module removal/device add race
    
    This patch (as546) fixes an oops-causing failure to check the return code
    from scsi_device_get.  The call can return an error if the LLD is being
    unloaded from memory.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c
index 76577fae60fa..a0975c78b968 100644
--- a/drivers/scsi/scsi_scan.c
+++ b/drivers/scsi/scsi_scan.c
@@ -870,8 +870,12 @@ static int scsi_probe_and_add_lun(struct scsi_target *starget,
  out_free_sdev:
 	if (res == SCSI_SCAN_LUN_PRESENT) {
 		if (sdevp) {
-			scsi_device_get(sdev);
-			*sdevp = sdev;
+			if (scsi_device_get(sdev) == 0) {
+				*sdevp = sdev;
+			} else {
+				__scsi_remove_device(sdev);
+				res = SCSI_SCAN_NO_RESPONSE;
+			}
 		}
 	} else {
 		if (sdev-&gt;host-&gt;hostt-&gt;slave_destroy)</pre>
    <div class="pagination">
        <a href='2_134.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><span>[135]</span><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_136.html'>Next&gt;&gt;</a>
    <div>
</body>
