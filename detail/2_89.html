<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_88.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><span>[89]</span><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_90.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 1a21175a615ed346e8043f5e9d60a672266b84b4
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 30 11:31:50 2008 -0400

    USB: fix interface unregistration logic
    
    This patch (as1122) fixes a bug: When an interface is unregistered,
    its children (sysfs files and endpoint devices) are unregistered after
    it instead of before.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Kay Sievers &lt;kay.sievers@vrfy.org&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 586d6f1376cf..286b4431a097 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1091,8 +1091,8 @@ void usb_disable_device(struct usb_device *dev, int skip_ep0)
 				continue;
 			dev_dbg(&amp;dev-&gt;dev, "unregistering interface %s\n",
 				dev_name(&amp;interface-&gt;dev));
-			device_del(&amp;interface-&gt;dev);
 			usb_remove_sysfs_intf_files(interface);
+			device_del(&amp;interface-&gt;dev);
 		}
 
 		/* Now that the interfaces are unbound, nobody should</pre><hr><pre>commit 0282b7f2a874e72c18fcd5a112ccf67f71ba7f5c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jul 29 12:01:04 2008 -0400

    usb-serial: don't release unregistered minors
    
    This patch (as1121) fixes a bug in the USB serial core.  When a device
    is unregistered, the core will give back its minors -- even if the
    device hasn't been assigned any!
    
    The patch reserves the highest minor value (255) to mean that no minor
    was assigned.  It also removes some dead code and does a small style
    fixup.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/serial/usb-serial.c b/drivers/usb/serial/usb-serial.c
index 8c2d531eedea..b157c48e8b78 100644
--- a/drivers/usb/serial/usb-serial.c
+++ b/drivers/usb/serial/usb-serial.c
@@ -122,9 +122,6 @@ static void return_serial(struct usb_serial *serial)
 
 	dbg("%s", __func__);
 
-	if (serial == NULL)
-		return;
-
 	for (i = 0; i &lt; serial-&gt;num_ports; ++i)
 		serial_table[serial-&gt;minor + i] = NULL;
 }
@@ -142,7 +139,8 @@ static void destroy_serial(struct kref *kref)
 	serial-&gt;type-&gt;shutdown(serial);
 
 	/* return the minor range that this device had */
-	return_serial(serial);
+	if (serial-&gt;minor != SERIAL_TTY_NO_MINOR)
+		return_serial(serial);
 
 	for (i = 0; i &lt; serial-&gt;num_ports; ++i)
 		serial-&gt;port[i]-&gt;port.count = 0;
@@ -575,6 +573,7 @@ static struct usb_serial *create_serial(struct usb_device *dev,
 	serial-&gt;interface = interface;
 	kref_init(&amp;serial-&gt;kref);
 	mutex_init(&amp;serial-&gt;disc_mutex);
+	serial-&gt;minor = SERIAL_TTY_NO_MINOR;
 
 	return serial;
 }
diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index 09a3e6a7518f..655341d0f534 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -17,7 +17,8 @@
 #include &lt;linux/mutex.h&gt;
 
 #define SERIAL_TTY_MAJOR	188	/* Nice legal number now */
-#define SERIAL_TTY_MINORS	255	/* loads of devices :) */
+#define SERIAL_TTY_MINORS	254	/* loads of devices :) */
+#define SERIAL_TTY_NO_MINOR	255	/* No minor was assigned */
 
 /* The maximum number of ports one device can grab at once */
 #define MAX_NUM_PORTS		8</pre><hr><pre>commit 38b375d9610e2467cb793a84d17c6f65e44cdb39
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jul 21 09:56:26 2008 -0400

    USB: OHCI: fix system hang caused by earlier patch
    
    This patch (as1114) fixes a problem that was revealed by an earlier
    patch (as1069b).  Some broken controllers seem never to turn off their
    RHCS interrupt status bit, even when told to do so.  As a result they
    generate an interrupt storm and hang the system.
    
    The patch avoids enabling RHSC interrupt requests when the RHCS status
    bit is already set.  This should have no adverse affects on normal
    controllers, since they won't set the status bit until a root-hub
    status change actually occurs, in which case we wouldn't enable RHSC
    interrupt requests anyway -- we would wait until the status change had
    been processed and cleared.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested by: Andrey Borzenkov &lt;arvidjaar@mail.ru&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ohci-hub.c b/drivers/usb/host/ohci-hub.c
index b56739221d11..d54183f1d701 100644
--- a/drivers/usb/host/ohci-hub.c
+++ b/drivers/usb/host/ohci-hub.c
@@ -483,6 +483,13 @@ ohci_hub_status_data (struct usb_hcd *hcd, char *buf)
 		length++;
 	}
 
+	/* Some broken controllers never turn off RHCS in the interrupt
+	 * status register.  For their sake we won't re-enable RHSC
+	 * interrupts if the flag is already set.
+	 */
+	if (ohci_readl(ohci, &amp;ohci-&gt;regs-&gt;intrstatus) &amp; OHCI_INTR_RHSC)
+		changed = 1;
+
 	/* look at each port */
 	for (i = 0; i &lt; ohci-&gt;num_ports; i++) {
 		u32	status = roothub_portstatus (ohci, i);</pre><hr><pre>commit f4f4d58734916e816d4b4a7cf61b3fc22ce02683
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jul 28 10:39:28 2008 -0400

    USB: add missing kerneldoc line for "needs_binding"
    
    This patch (as1117) adds a kerneldoc line for the "needs_binding"
    field in struct usb_interface.  It was accidentally omitted when the
    field was added.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/include/linux/usb.h b/include/linux/usb.h
index 5811c5da69f9..0924cd9c30f6 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -110,6 +110,8 @@ enum usb_interface_condition {
  * @sysfs_files_created: sysfs attributes exist
  * @needs_remote_wakeup: flag set when the driver requires remote-wakeup
  *	capability during autosuspend.
+ * @needs_binding: flag set when the driver should be re-probed or unbound
+ *	following a reset or suspend operation it doesn't support.
  * @dev: driver model's view of this device
  * @usb_dev: if an interface is bound to the USB major, this will point
  *	to the sysfs representation for that device.</pre><hr><pre>commit 580da34847488b404218d1d7f53b156f245f5555
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Aug 5 13:05:17 2008 -0400

    Fix USB storage hang on command abort
    
    Okay, I found the cause of the hang.  It is a simple bug in the USB
    scatter-gather library, caused by changes added in response to the S-G
    chaining modification.
    
    This patch (as1125) fixes a bug in the USB scatter-gather library.
    Early exit from the S-G initialization loop does not reset the count of
    outstanding URBs.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: Matthew Dharm &lt;mdharm-usb@one-eyed-alien.net&gt;
    Cc: David Brownell &lt;david-b@pacbell.net&gt;
    Cc: Alan Jenkins &lt;alan-jenkins@tuffmail.co.uk&gt;
    Cc: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;
    Cc: Greg KH &lt;greg@kroah.com&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 2fcc06eb5e60..586d6f1376cf 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -389,7 +389,6 @@ int usb_sg_init(struct usb_sg_request *io, struct usb_device *dev,
 	if (io-&gt;entries &lt;= 0)
 		return io-&gt;entries;
 
-	io-&gt;count = io-&gt;entries;
 	io-&gt;urbs = kmalloc(io-&gt;entries * sizeof *io-&gt;urbs, mem_flags);
 	if (!io-&gt;urbs)
 		goto nomem;
@@ -458,6 +457,7 @@ int usb_sg_init(struct usb_sg_request *io, struct usb_device *dev,
 	io-&gt;urbs[--i]-&gt;transfer_flags &amp;= ~URB_NO_INTERRUPT;
 
 	/* transaction state */
+	io-&gt;count = io-&gt;entries;
 	io-&gt;status = 0;
 	io-&gt;bytes = 0;
 	init_completion(&amp;io-&gt;complete);</pre><hr><pre>commit 12265709ac6e197f4d40d9ec1fd3af97b4196a35
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jul 21 10:25:52 2008 -0400

    [SCSI] scsi_eh_prep_cmnd should save scmd-&gt;underflow
    
    This patch (as1116) fixes a bug in scsi_eh_prep_cmnd() and
    scsi_eh_restore_cmnd().  These routines are supposed to save any
    values they change and restore them later, but someone forgot to
    save &amp; restore scmd-&gt;underflow.
    
    This fixes part of the problem reported in Bugzilla #9638.
    
    [jejb: fix up rejections around DIF/DIX]
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/scsi/scsi_error.c b/drivers/scsi/scsi_error.c
index fc4b2d05f2e1..171b82d748cf 100644
--- a/drivers/scsi/scsi_error.c
+++ b/drivers/scsi/scsi_error.c
@@ -667,6 +667,7 @@ void scsi_eh_prep_cmnd(struct scsi_cmnd *scmd, struct scsi_eh_save *ses,
 	ses-&gt;sdb = scmd-&gt;sdb;
 	ses-&gt;next_rq = scmd-&gt;request-&gt;next_rq;
 	ses-&gt;result = scmd-&gt;result;
+	ses-&gt;underflow = scmd-&gt;underflow;
 	ses-&gt;prot_op = scmd-&gt;prot_op;
 
 	scmd-&gt;prot_op = SCSI_PROT_NORMAL;
@@ -727,6 +728,7 @@ void scsi_eh_restore_cmnd(struct scsi_cmnd* scmd, struct scsi_eh_save *ses)
 	scmd-&gt;sdb = ses-&gt;sdb;
 	scmd-&gt;request-&gt;next_rq = ses-&gt;next_rq;
 	scmd-&gt;result = ses-&gt;result;
+	scmd-&gt;underflow = ses-&gt;underflow;
 	scmd-&gt;prot_op = ses-&gt;prot_op;
 }
 EXPORT_SYMBOL(scsi_eh_restore_cmnd);
diff --git a/include/scsi/scsi_eh.h b/include/scsi/scsi_eh.h
index e5499ed0e376..06a8790893ef 100644
--- a/include/scsi/scsi_eh.h
+++ b/include/scsi/scsi_eh.h
@@ -74,6 +74,7 @@ struct scsi_eh_save {
 	/* saved state */
 	int result;
 	enum dma_data_direction data_direction;
+	unsigned underflow;
 	unsigned char cmd_len;
 	unsigned char prot_op;
 	unsigned char *cmnd;</pre><hr><pre>commit 8111d1b552349921aae1acf73e4e8cea98e80970
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 23 21:28:37 2008 -0700

    pm: add new PM_EVENT codes for runtime power transitions
    
    This patch (as1112) adds some new PM_EVENT_* codes for use by kernel
    subsystems.  They describe runtime power-state transitions of the sort already
    implemented by the USB subsystem.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;
    Acked-by: Pavel Machek &lt;pavel@ucw.cz&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;

diff --git a/include/linux/pm.h b/include/linux/pm.h
index ed98d967f9fb..4dcce54b6d76 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -245,6 +245,21 @@ struct pm_ext_ops {
  * RECOVER	Creation of a hibernation image or restoration of the main
  *		memory contents from a hibernation image has failed, call
  *		-&gt;thaw() and -&gt;complete() for all devices.
+ *
+ * The following PM_EVENT_ messages are defined for internal use by
+ * kernel subsystems.  They are never issued by the PM core.
+ *
+ * USER_SUSPEND		Manual selective suspend was issued by userspace.
+ *
+ * USER_RESUME		Manual selective resume was issued by userspace.
+ *
+ * REMOTE_WAKEUP	Remote-wakeup request was received from the device.
+ *
+ * AUTO_SUSPEND		Automatic (device idle) runtime suspend was
+ *			initiated by the subsystem.
+ *
+ * AUTO_RESUME		Automatic (device needed) runtime resume was
+ *			requested by a driver.
  */
 
 #define PM_EVENT_ON		0x0000
@@ -256,9 +271,18 @@ struct pm_ext_ops {
 #define PM_EVENT_THAW		0x0020
 #define PM_EVENT_RESTORE	0x0040
 #define PM_EVENT_RECOVER	0x0080
+#define PM_EVENT_USER		0x0100
+#define PM_EVENT_REMOTE		0x0200
+#define PM_EVENT_AUTO		0x0400
 
-#define PM_EVENT_SLEEP	(PM_EVENT_SUSPEND | PM_EVENT_HIBERNATE)
+#define PM_EVENT_SLEEP		(PM_EVENT_SUSPEND | PM_EVENT_HIBERNATE)
+#define PM_EVENT_USER_SUSPEND	(PM_EVENT_USER | PM_EVENT_SUSPEND)
+#define PM_EVENT_USER_RESUME	(PM_EVENT_USER | PM_EVENT_RESUME)
+#define PM_EVENT_REMOTE_WAKEUP	(PM_EVENT_REMOTE | PM_EVENT_RESUME)
+#define PM_EVENT_AUTO_SUSPEND	(PM_EVENT_AUTO | PM_EVENT_SUSPEND)
+#define PM_EVENT_AUTO_RESUME	(PM_EVENT_AUTO | PM_EVENT_RESUME)
 
+#define PMSG_ON		((struct pm_message){ .event = PM_EVENT_ON, })
 #define PMSG_FREEZE	((struct pm_message){ .event = PM_EVENT_FREEZE, })
 #define PMSG_QUIESCE	((struct pm_message){ .event = PM_EVENT_QUIESCE, })
 #define PMSG_SUSPEND	((struct pm_message){ .event = PM_EVENT_SUSPEND, })
@@ -267,7 +291,16 @@ struct pm_ext_ops {
 #define PMSG_THAW	((struct pm_message){ .event = PM_EVENT_THAW, })
 #define PMSG_RESTORE	((struct pm_message){ .event = PM_EVENT_RESTORE, })
 #define PMSG_RECOVER	((struct pm_message){ .event = PM_EVENT_RECOVER, })
-#define PMSG_ON		((struct pm_message){ .event = PM_EVENT_ON, })
+#define PMSG_USER_SUSPEND	((struct pm_messge) \
+					{ .event = PM_EVENT_USER_SUSPEND, })
+#define PMSG_USER_RESUME	((struct pm_messge) \
+					{ .event = PM_EVENT_USER_RESUME, })
+#define PMSG_REMOTE_RESUME	((struct pm_messge) \
+					{ .event = PM_EVENT_REMOTE_RESUME, })
+#define PMSG_AUTO_SUSPEND	((struct pm_messge) \
+					{ .event = PM_EVENT_AUTO_SUSPEND, })
+#define PMSG_AUTO_RESUME		((struct pm_messge) \
+					{ .event = PM_EVENT_AUTO_RESUME, })
 
 /**
  * Device power management states</pre><hr><pre>commit f756cbd458ab71c996a069cb3928fb1e2d7cd9cc
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jun 30 13:39:59 2008 -0400

    usb-storage: revert DMA-alignment change for Wireless USB
    
    This patch (as1110) reverts an earlier patch meant to help with
    Wireless USB host controllers.  These controllers can have bulk
    maxpacket values larger than 512, which puts unusual constraints on
    the sizes of scatter-gather list elements.  However it turns out that
    the block layer does not provide the support we need to enforce these
    constraints; merely changing the DMA alignment mask doesn't help.
    Hence there's no reason to keep the original patch.  The Wireless USB
    problem will have to be solved a different way.
    
    In addition, there is a reason to get rid of the earlier patch.  By
    dereferencing a pointer stored in the ep_in array of struct
    usb_device, the current code risks an invalid memory access when it
    runs concurrently with device removal.  The members of that array are
    cleared before the driver's disconnect method is called, so it should
    not try to use them.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index b4c9e0f18a82..09779f6a8179 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -71,7 +71,6 @@ static const char* host_info(struct Scsi_Host *host)
 static int slave_alloc (struct scsi_device *sdev)
 {
 	struct us_data *us = host_to_us(sdev-&gt;host);
-	struct usb_host_endpoint *bulk_in_ep;
 
 	/*
 	 * Set the INQUIRY transfer length to 36.  We don't use any of
@@ -80,16 +79,22 @@ static int slave_alloc (struct scsi_device *sdev)
 	 */
 	sdev-&gt;inquiry_len = 36;
 
-	/* Scatter-gather buffers (all but the last) must have a length
-	 * divisible by the bulk maxpacket size.  Otherwise a data packet
-	 * would end up being short, causing a premature end to the data
-	 * transfer.  We'll use the maxpacket value of the bulk-IN pipe
-	 * to set the SCSI device queue's DMA alignment mask.
+	/* USB has unusual DMA-alignment requirements: Although the
+	 * starting address of each scatter-gather element doesn't matter,
+	 * the length of each element except the last must be divisible
+	 * by the Bulk maxpacket value.  There's currently no way to
+	 * express this by block-layer constraints, so we'll cop out
+	 * and simply require addresses to be aligned at 512-byte
+	 * boundaries.  This is okay since most block I/O involves
+	 * hardware sectors that are multiples of 512 bytes in length,
+	 * and since host controllers up through USB 2.0 have maxpacket
+	 * values no larger than 512.
+	 *
+	 * But it doesn't suffice for Wireless USB, where Bulk maxpacket
+	 * values can be as large as 2048.  To make that work properly
+	 * will require changes to the block layer.
 	 */
-	bulk_in_ep = us-&gt;pusb_dev-&gt;ep_in[usb_pipeendpoint(us-&gt;recv_bulk_pipe)];
-	blk_queue_update_dma_alignment(sdev-&gt;request_queue,
-			le16_to_cpu(bulk_in_ep-&gt;desc.wMaxPacketSize) - 1);
-			/* wMaxPacketSize must be a power of 2 */
+	blk_queue_update_dma_alignment(sdev-&gt;request_queue, (512 - 1));
 
 	/*
 	 * The UFI spec treates the Peripheral Qualifier bits in an</pre><hr><pre>commit 86c57edf60f5c98adb496880f56cd0e5a3423153
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jun 30 11:14:43 2008 -0400

    USB: use reset_resume when normal resume fails
    
    This patch (as1109b) makes USB-Persist more resilient to errors.  With
    the current code, if a normal resume fails, it's an unrecoverable
    error.  With the patch, if a normal resume fails (and if the device is
    enabled for USB-Persist) then a reset-resume is tried.
    
    This fixes the problem reported in Bugzilla #10977.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/Documentation/usb/persist.txt b/Documentation/usb/persist.txt
index d56cb1a11550..074b159b77c2 100644
--- a/Documentation/usb/persist.txt
+++ b/Documentation/usb/persist.txt
@@ -81,8 +81,11 @@ re-enumeration shows that the device now attached to that port has the
 same descriptors as before, including the Vendor and Product IDs, then
 the kernel continues to use the same device structure.  In effect, the
 kernel treats the device as though it had merely been reset instead of
-unplugged.  The same thing happens if the host controller is in the
-expected state but a USB device was unplugged and then replugged.
+unplugged.
+
+The same thing happens if the host controller is in the expected state
+but a USB device was unplugged and then replugged, or if a USB device
+fails to carry out a normal resume.
 
 If no device is now attached to the port, or if the descriptors are
 different from what the kernel remembers, then the treatment is what
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index f1efabbc1ca2..107e1d25ddec 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1822,9 +1822,15 @@ static int check_port_resume_type(struct usb_device *udev,
 			status = -ENODEV;
 	}
 
-	/* Can't do a normal resume if the port isn't enabled */
-	else if (!(portstatus &amp; USB_PORT_STAT_ENABLE) &amp;&amp; !udev-&gt;reset_resume)
-		status = -ENODEV;
+	/* Can't do a normal resume if the port isn't enabled,
+	 * so try a reset-resume instead.
+	 */
+	else if (!(portstatus &amp; USB_PORT_STAT_ENABLE) &amp;&amp; !udev-&gt;reset_resume) {
+		if (udev-&gt;persist_enabled)
+			udev-&gt;reset_resume = 1;
+		else
+			status = -ENODEV;
+	}
 
 	if (status) {
 		dev_dbg(hub-&gt;intfdev,
@@ -1973,6 +1979,7 @@ static int finish_port_resume(struct usb_device *udev)
 	 * resumed.
 	 */
 	if (udev-&gt;reset_resume)
+ retry_reset_resume:
 		status = usb_reset_and_verify_device(udev);
 
  	/* 10.5.4.5 says be sure devices in the tree are still there.
@@ -1984,6 +1991,13 @@ static int finish_port_resume(struct usb_device *udev)
 		status = usb_get_status(udev, USB_RECIP_DEVICE, 0, &amp;devstatus);
 		if (status &gt;= 0)
 			status = (status &gt; 0 ? 0 : -ENODEV);
+
+		/* If a normal resume failed, try doing a reset-resume */
+		if (status &amp;&amp; !udev-&gt;reset_resume &amp;&amp; udev-&gt;persist_enabled) {
+			dev_dbg(&amp;udev-&gt;dev, "retry with reset-resume\n");
+			udev-&gt;reset_resume = 1;
+			goto retry_reset_resume;
+		}
 	}
 
 	if (status) {</pre><hr><pre>commit e04199b2167e88f0e2d0410fafaa2c35ff7ba8c1
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jun 24 14:47:29 2008 -0400

    usbfs: don't store bad pointers in registration
    
    This patch (as1107) fixes a small bug in the usbfs registration and
    unregistration code.  It avoids leaving an error value stored in the
    device's usb_classdev field and it avoids trying to unregister a NULL
    pointer.  (It also fixes a rather extreme overuse of whitespace.)
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index c44e98f6099e..5580c6e59bae 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -1726,20 +1726,21 @@ static struct class *usb_classdev_class;
 
 static int usb_classdev_add(struct usb_device *dev)
 {
-	int minor = ((dev-&gt;bus-&gt;busnum-1) * 128) + (dev-&gt;devnum-1);
-
-	dev-&gt;usb_classdev = device_create(usb_classdev_class, &amp;dev-&gt;dev,
-				MKDEV(USB_DEVICE_MAJOR, minor),
-				"usbdev%d.%d", dev-&gt;bus-&gt;busnum, dev-&gt;devnum);
-	if (IS_ERR(dev-&gt;usb_classdev))
-		return PTR_ERR(dev-&gt;usb_classdev);
-
+	struct device *cldev;
+
+	cldev = device_create(usb_classdev_class, &amp;dev-&gt;dev, dev-&gt;dev.devt,
+			      "usbdev%d.%d", dev-&gt;bus-&gt;busnum,
+			      dev-&gt;devnum);
+	if (IS_ERR(cldev))
+		return PTR_ERR(cldev);
+	dev-&gt;usb_classdev = cldev;
 	return 0;
 }
 
 static void usb_classdev_remove(struct usb_device *dev)
 {
-	device_unregister(dev-&gt;usb_classdev);
+	if (dev-&gt;usb_classdev)
+		device_unregister(dev-&gt;usb_classdev);
 	usb_fs_classdev_common_remove(dev);
 }
 </pre>
    <div class="pagination">
        <a href='2_88.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><span>[89]</span><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_90.html'>Next&gt;&gt;</a>
    <div>
</body>
