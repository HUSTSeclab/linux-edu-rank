<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_54.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><span>[55]</span><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_56.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 8f88893c05f2f677f18f2ce5591b4bed5d4a7535
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Sep 26 17:38:50 2011 +0200

    PM: Update the policy on default wakeup settings
    
    This patch (as1485) documents a change to the kernel's default wakeup
    policy.  Devices that forward wakeup requests between buses should be
    enabled for wakeup by default.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;

diff --git a/Documentation/power/devices.txt b/Documentation/power/devices.txt
index 3384d5996be2..29b7a9817f5a 100644
--- a/Documentation/power/devices.txt
+++ b/Documentation/power/devices.txt
@@ -152,7 +152,9 @@ try to use its wakeup mechanism.  device_set_wakeup_enable() affects this flag;
 for the most part drivers should not change its value.  The initial value of
 should_wakeup is supposed to be false for the majority of devices; the major
 exceptions are power buttons, keyboards, and Ethernet adapters whose WoL
-(wake-on-LAN) feature has been set up with ethtool.
+(wake-on-LAN) feature has been set up with ethtool.  It should also default
+to true for devices that don't generate wakeup requests on their own but merely
+forward wakeup requests from one bus to another (like PCI bridges).
 
 Whether or not a device is capable of issuing wakeup events is a hardware
 matter, and the kernel is responsible for keeping track of it.  By contrast,
diff --git a/drivers/base/power/wakeup.c b/drivers/base/power/wakeup.c
index 84f7c7d5a098..14ee07e9cc43 100644
--- a/drivers/base/power/wakeup.c
+++ b/drivers/base/power/wakeup.c
@@ -276,7 +276,9 @@ EXPORT_SYMBOL_GPL(device_set_wakeup_capable);
  *
  * By default, most devices should leave wakeup disabled.  The exceptions are
  * devices that everyone expects to be wakeup sources: keyboards, power buttons,
- * possibly network interfaces, etc.
+ * possibly network interfaces, etc.  Also, devices that don't generate their
+ * own wakeup requests but merely forward requests from one bus to another
+ * (like PCI bridges) should have wakeup enabled by default.
  */
 int device_init_wakeup(struct device *dev, bool enable)
 {</pre><hr><pre>commit 30b1a7a32ca48fd8758f8ca44d60deebc0aa3d72
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 27 21:54:22 2011 +0200

    USB: Add wakeup info to debugging messages
    
    This patch (as1487) improves the usbcore debugging output for port
    suspend and bus suspend, by stating whether or not remote wakeup is
    enabled.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;
    Signed-off-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index da582f4e486b..877e0e27b90a 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1959,8 +1959,9 @@ int hcd_bus_suspend(struct usb_device *rhdev, pm_message_t msg)
 	int		status;
 	int		old_state = hcd-&gt;state;
 
-	dev_dbg(&amp;rhdev-&gt;dev, "bus %s%s\n",
-			(PMSG_IS_AUTO(msg) ? "auto-" : ""), "suspend");
+	dev_dbg(&amp;rhdev-&gt;dev, "bus %ssuspend, wakeup %d\n",
+			(PMSG_IS_AUTO(msg) ? "auto-" : ""),
+			rhdev-&gt;do_remote_wakeup);
 	if (HCD_DEAD(hcd)) {
 		dev_dbg(&amp;rhdev-&gt;dev, "skipped %s of dead bus\n", "suspend");
 		return 0;
@@ -1995,8 +1996,8 @@ int hcd_bus_resume(struct usb_device *rhdev, pm_message_t msg)
 	int		status;
 	int		old_state = hcd-&gt;state;
 
-	dev_dbg(&amp;rhdev-&gt;dev, "usb %s%s\n",
-			(PMSG_IS_AUTO(msg) ? "auto-" : ""), "resume");
+	dev_dbg(&amp;rhdev-&gt;dev, "usb %sresume\n",
+			(PMSG_IS_AUTO(msg) ? "auto-" : ""));
 	if (HCD_DEAD(hcd)) {
 		dev_dbg(&amp;rhdev-&gt;dev, "skipped %s of dead bus\n", "resume");
 		return 0;
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index ee50e0bf84e8..13bc83240adb 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2324,8 +2324,6 @@ int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
 	int		port1 = udev-&gt;portnum;
 	int		status;
 
-	// dev_dbg(hub-&gt;intfdev, "suspend port %d\n", port1);
-
 	/* enable remote wakeup when appropriate; this lets the device
 	 * wake up the upstream hub (including maybe the root hub).
 	 *
@@ -2371,8 +2369,9 @@ int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
 			status = 0;
 	} else {
 		/* device has up to 10 msec to fully suspend */
-		dev_dbg(&amp;udev-&gt;dev, "usb %ssuspend\n",
-				(PMSG_IS_AUTO(msg) ? "auto-" : ""));
+		dev_dbg(&amp;udev-&gt;dev, "usb %ssuspend, wakeup %d\n",
+				(PMSG_IS_AUTO(msg) ? "auto-" : ""),
+				udev-&gt;do_remote_wakeup);
 		usb_set_device_state(udev, USB_STATE_SUSPENDED);
 		msleep(10);
 	}</pre><hr><pre>commit 5c12e7856d75f68c1ca8372d6cc76cdbc71763c0
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Sep 26 11:25:26 2011 -0400

    USB: UHCI: improve comments and logic for root-hub suspend
    
    This patch (as1488) improves the comments and logic in uhci-hcd's
    suspend routine.  The existing comments are hard to understand and
    don't give a good idea of what's really going on.
    
    The question of whether EGSM (Enter Global Suspend Mode) and RD
    (enable Resume Detect interrupts) can be useful when they're not both
    set is difficult.  The spec doesn't give any details on how they
    interact with system wakeup, although clearly they are meant to be
    used together.  To be safe, the patch changes the subroutine so that
    neither bit gets set unless they both do.  There shouldn't be any
    functional changes from this; only systems that are designed badly or
    broken in some way need to avoid using those bits.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index fba99b120588..c8ae199cfbb8 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -294,50 +294,50 @@ __acquires(uhci-&gt;lock)
 	 * and that remote wakeups should be enabled.
 	 */
 	egsm_enable = USBCMD_EGSM;
-	uhci-&gt;RD_enable = 1;
 	int_enable = USBINTR_RESUME;
 	wakeup_enable = 1;
 
-	/* In auto-stop mode wakeups must always be detected, but
-	 * Resume-Detect interrupts may be prohibited.  (In the absence
-	 * of CONFIG_PM, they are always disallowed.)
+	/*
+	 * In auto-stop mode, we must be able to detect new connections.
+	 * The user can force us to poll by disabling remote wakeup;
+	 * otherwise we will use the EGSM/RD mechanism.
 	 */
 	if (auto_stop) {
 		if (!device_may_wakeup(&amp;rhdev-&gt;dev))
-			int_enable = 0;
+			egsm_enable = int_enable = 0;
+	}
 
-	/* In bus-suspend mode wakeups may be disabled, but if they are
-	 * allowed then so are Resume-Detect interrupts.
-	 */
-	} else {
 #ifdef CONFIG_PM
+	/*
+	 * In bus-suspend mode, we use the wakeup setting specified
+	 * for the root hub.
+	 */
+	else {
 		if (!rhdev-&gt;do_remote_wakeup)
 			wakeup_enable = 0;
-#endif
 	}
+#endif
 
-	/* EGSM causes the root hub to echo a 'K' signal (resume) out any
-	 * port which requests a remote wakeup.  According to the USB spec,
-	 * every hub is supposed to do this.  But if we are ignoring
-	 * remote-wakeup requests anyway then there's no point to it.
-	 * We also shouldn't enable EGSM if it's broken.
-	 */
-	if (!wakeup_enable || global_suspend_mode_is_broken(uhci))
-		egsm_enable = 0;
-
-	/* If we're ignoring wakeup events then there's no reason to
-	 * enable Resume-Detect interrupts.  We also shouldn't enable
-	 * them if they are broken or disallowed.
+	/*
+	 * UHCI doesn't distinguish between wakeup requests from downstream
+	 * devices and local connect/disconnect events.  There's no way to
+	 * enable one without the other; both are controlled by EGSM.  Thus
+	 * if wakeups are disallowed then EGSM must be turned off -- in which
+	 * case remote wakeup requests from downstream during system sleep
+	 * will be lost.
+	 *
+	 * In addition, if EGSM is broken then we can't use it.  Likewise,
+	 * if Resume-Detect interrupts are broken then we can't use them.
 	 *
-	 * This logic may lead us to enabling RD but not EGSM.  The UHCI
-	 * spec foolishly says that RD works only when EGSM is on, but
-	 * there's no harm in enabling it anyway -- perhaps some chips
-	 * will implement it!
+	 * Finally, neither EGSM nor RD is useful by itself.  Without EGSM,
+	 * the RD status bit will never get set.  Without RD, the controller
+	 * won't generate interrupts to tell the system about wakeup events.
 	 */
-	if (!wakeup_enable || resume_detect_interrupts_are_broken(uhci) ||
-			!int_enable)
-		uhci-&gt;RD_enable = int_enable = 0;
+	if (!wakeup_enable || global_suspend_mode_is_broken(uhci) ||
+			resume_detect_interrupts_are_broken(uhci))
+		egsm_enable = int_enable = 0;
 
+	uhci-&gt;RD_enable = !!int_enable;
 	uhci_writew(uhci, int_enable, USBINTR);
 	uhci_writew(uhci, egsm_enable | USBCMD_CF, USBCMD);
 	mb();
@@ -364,10 +364,12 @@ __acquires(uhci-&gt;lock)
 	uhci-&gt;rh_state = new_state;
 	uhci-&gt;is_stopped = UHCI_IS_STOPPED;
 
-	/* If interrupts don't work and remote wakeup is enabled then
-	 * the suspended root hub needs to be polled.
+	/*
+	 * If remote wakeup is enabled but either EGSM or RD interrupts
+	 * doesn't work, then we won't get an interrupt when a wakeup event
+	 * occurs.  Thus the suspended root hub needs to be polled.
 	 */
-	if (!int_enable &amp;&amp; wakeup_enable)
+	if (wakeup_enable &amp;&amp; (!int_enable || !egsm_enable))
 		set_bit(HCD_FLAG_POLL_RH, &amp;uhci_to_hcd(uhci)-&gt;flags);
 	else
 		clear_bit(HCD_FLAG_POLL_RH, &amp;uhci_to_hcd(uhci)-&gt;flags);</pre><hr><pre>commit a6eeeb9f45b5a417f574f3bc799b7122270bf59b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Sep 26 11:23:38 2011 -0400

    USB: Update USB default wakeup settings
    
    This patch (as1486) implements the kernel's new wakeup policy for USB
    host controllers.  Since they don't generate wakeup requests on their
    but merely forward requests from their root hubs toward the CPU, they
    should be enabled for wakeup by default.
    
    Also, to be compliant with both the old and new policies, root hubs
    should not be enabled for remote wakeup by default.  Userspace must
    enable it explicitly if it is desired.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 73cbbd85219f..100d4b002642 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -2429,7 +2429,7 @@ int usb_add_hcd(struct usb_hcd *hcd,
 	 * but drivers can override it in reset() if needed, along with
 	 * recording the overall controller's system wakeup capability.
 	 */
-	device_init_wakeup(&amp;rhdev-&gt;dev, 1);
+	device_set_wakeup_capable(&amp;rhdev-&gt;dev, 1);
 
 	/* HCD_FLAG_RH_RUNNING doesn't matter until the root hub is
 	 * registered.  But since the controller can die at any time,
@@ -2478,6 +2478,13 @@ int usb_add_hcd(struct usb_hcd *hcd,
 	}
 	if (hcd-&gt;uses_new_polling &amp;&amp; HCD_POLL_RH(hcd))
 		usb_hcd_poll_rh_status(hcd);
+
+	/*
+	 * Host controllers don't generate their own wakeup requests;
+	 * they only forward requests from the root hub.  Therefore
+	 * controllers should always be enabled for remote wakeup.
+	 */
+	device_wakeup_enable(hcd-&gt;self.controller);
 	return retval;
 
 error_create_attr_group:</pre><hr><pre>commit 25aa55488c3644b19e33ba79c564191b8e33f477
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Sep 14 12:33:16 2011 -0400

    USB: document ehci-hcd's "companion" sysfs attribute
    
    This patch (as1484) adds documentation for ehci-hcd's "companion"
    sysfs attribute, which was added to the kernel over four years ago but
    never documented.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/Documentation/ABI/testing/sysfs-bus-pci-drivers-ehci_hcd b/Documentation/ABI/testing/sysfs-bus-pci-drivers-ehci_hcd
new file mode 100644
index 000000000000..60c60fa624b2
--- /dev/null
+++ b/Documentation/ABI/testing/sysfs-bus-pci-drivers-ehci_hcd
@@ -0,0 +1,46 @@
+What:		/sys/bus/pci/drivers/ehci_hcd/.../companion
+		/sys/bus/usb/devices/usbN/../companion
+Date:		January 2007
+KernelVersion:	2.6.21
+Contact:	Alan Stern &lt;stern@rowland.harvard.edu&gt;
+Description:
+		PCI-based EHCI USB controllers (i.e., high-speed USB-2.0
+		controllers) are often implemented along with a set of
+		"companion" full/low-speed USB-1.1 controllers.  When a
+		high-speed device is plugged in, the connection is routed
+		to the EHCI controller; when a full- or low-speed device
+		is plugged in, the connection is routed to the companion
+		controller.
+
+		Sometimes you want to force a high-speed device to connect
+		at full speed, which can be accomplished by forcing the
+		connection to be routed to the companion controller.
+		That's what this file does.  Writing a port number to the
+		file causes connections on that port to be routed to the
+		companion controller, and writing the negative of a port
+		number returns the port to normal operation.
+
+		For example: To force the high-speed device attached to
+		port 4 on bus 2 to run at full speed:
+
+			echo 4 &gt;/sys/bus/usb/devices/usb2/../companion
+
+		To return the port to high-speed operation:
+
+			echo -4 &gt;/sys/bus/usb/devices/usb2/../companion
+
+		Reading the file gives the list of ports currently forced
+		to the companion controller.
+
+		Note: Some EHCI controllers do not have companions; they
+		may contain an internal "transaction translator" or they
+		may be attached directly to a "rate-matching hub".  This
+		mechanism will not work with such controllers.  Also, it
+		cannot be used to force a port on a high-speed hub to
+		connect at full speed.
+
+		Note: When this file was first added, it appeared in a
+		different sysfs directory.  The location given above is
+		correct for 2.6.35 (and probably several earlier kernel
+		versions as well).
+</pre><hr><pre>commit 04eee25b1d754a837360504b7af426d1f86ffeb7
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Aug 18 14:29:00 2011 -0400

    USB: gadget: storage: remove alignment assumption
    
    This patch (as1481) fixes a problem affecting g_file_storage and
    g_mass_storage when running at SuperSpeed.  The two drivers currently
    assume that the bulk-out maxpacket size can evenly divide the SCSI
    block size, which is 512 bytes.  But SuperSpeed bulk endpoints have a
    maxpacket size of 1024, so the assumption is no longer true.
    
    This patch removes that assumption from the drivers, by getting rid of
    a small optimization (they try to align VFS reads and writes on page
    cache boundaries).  If a command's starting logical block address is
    512 bytes below the end of a page, it's not okay to issue a USB
    command for just those 512 bytes when the maxpacket size is 1024 -- it
    would result in either babble (for an OUT transfer) or a short packet
    (for an IN transfer).
    
    Also, for backward compatibility, the test for writes extending beyond
    the end of the backing storage has to be changed.  If the host tries
    to do this, we should accept the data that fits in the backing storage
    and ignore the rest.  Because the storage's end may not align with a
    USB packet boundary, this means we may have to accept a USB OUT
    transfer that extends beyond the end of the storage and then write out
    only the part of the data that fits.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Michal Nazarewicz &lt;mina86@mina86.com&gt;
    Signed-off-by: Felipe Balbi &lt;balbi@ti.com&gt;

diff --git a/drivers/usb/gadget/f_mass_storage.c b/drivers/usb/gadget/f_mass_storage.c
index 1cdb1fa1b158..4306a8339487 100644
--- a/drivers/usb/gadget/f_mass_storage.c
+++ b/drivers/usb/gadget/f_mass_storage.c
@@ -744,7 +744,6 @@ static int do_read(struct fsg_common *common)
 	u32			amount_left;
 	loff_t			file_offset, file_offset_tmp;
 	unsigned int		amount;
-	unsigned int		partial_page;
 	ssize_t			nread;
 
 	/*
@@ -783,18 +782,10 @@ static int do_read(struct fsg_common *common)
 		 * Try to read the remaining amount.
 		 * But don't read more than the buffer size.
 		 * And don't try to read past the end of the file.
-		 * Finally, if we're not at a page boundary, don't read past
-		 *	the next page.
-		 * If this means reading 0 then we were asked to read past
-		 *	the end of file.
 		 */
 		amount = min(amount_left, FSG_BUFLEN);
 		amount = min((loff_t)amount,
 			     curlun-&gt;file_length - file_offset);
-		partial_page = file_offset &amp; (PAGE_CACHE_SIZE - 1);
-		if (partial_page &gt; 0)
-			amount = min(amount, (unsigned int)PAGE_CACHE_SIZE -
-					     partial_page);
 
 		/* Wait for the next buffer to become available */
 		bh = common-&gt;next_buffhd_to_fill;
@@ -840,6 +831,12 @@ static int do_read(struct fsg_common *common)
 		file_offset  += nread;
 		amount_left  -= nread;
 		common-&gt;residue -= nread;
+
+		/*
+		 * Except at the end of the transfer, nread will be
+		 * equal to the buffer size, which is divisible by the
+		 * bulk-in maxpacket size.
+		 */
 		bh-&gt;inreq-&gt;length = nread;
 		bh-&gt;state = BUF_STATE_FULL;
 
@@ -878,7 +875,6 @@ static int do_write(struct fsg_common *common)
 	u32			amount_left_to_req, amount_left_to_write;
 	loff_t			usb_offset, file_offset, file_offset_tmp;
 	unsigned int		amount;
-	unsigned int		partial_page;
 	ssize_t			nwritten;
 	int			rc;
 
@@ -934,24 +930,13 @@ static int do_write(struct fsg_common *common)
 
 			/*
 			 * Figure out how much we want to get:
-			 * Try to get the remaining amount.
-			 * But don't get more than the buffer size.
-			 * And don't try to go past the end of the file.
-			 * If we're not at a page boundary,
-			 *	don't go past the next page.
-			 * If this means getting 0, then we were asked
-			 *	to write past the end of file.
-			 * Finally, round down to a block boundary.
+			 * Try to get the remaining amount,
+			 * but not more than the buffer size.
 			 */
 			amount = min(amount_left_to_req, FSG_BUFLEN);
-			amount = min((loff_t)amount,
-				     curlun-&gt;file_length - usb_offset);
-			partial_page = usb_offset &amp; (PAGE_CACHE_SIZE - 1);
-			if (partial_page &gt; 0)
-				amount = min(amount,
-	(unsigned int)PAGE_CACHE_SIZE - partial_page);
-
-			if (amount == 0) {
+
+			/* Beyond the end of the backing file? */
+			if (usb_offset &gt;= curlun-&gt;file_length) {
 				get_some_more = 0;
 				curlun-&gt;sense_data =
 					SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;
@@ -960,16 +945,6 @@ static int do_write(struct fsg_common *common)
 				curlun-&gt;info_valid = 1;
 				continue;
 			}
-			amount = round_down(amount, curlun-&gt;blksize);
-			if (amount == 0) {
-
-				/*
-				 * Why were we were asked to transfer a
-				 * partial block?
-				 */
-				get_some_more = 0;
-				continue;
-			}
 
 			/* Get the next buffer */
 			usb_offset += amount;
@@ -979,8 +954,9 @@ static int do_write(struct fsg_common *common)
 				get_some_more = 0;
 
 			/*
-			 * amount is always divisible by 512, hence by
-			 * the bulk-out maxpacket size
+			 * Except at the end of the transfer, amount will be
+			 * equal to the buffer size, which is divisible by
+			 * the bulk-out maxpacket size.
 			 */
 			bh-&gt;outreq-&gt;length = amount;
 			bh-&gt;bulk_out_intended_length = amount;
@@ -1019,6 +995,11 @@ static int do_write(struct fsg_common *common)
 				amount = curlun-&gt;file_length - file_offset;
 			}
 
+			/* Don't write a partial block */
+			amount = round_down(amount, curlun-&gt;blksize);
+			if (amount == 0)
+				goto empty_write;
+
 			/* Perform the write */
 			file_offset_tmp = file_offset;
 			nwritten = vfs_write(curlun-&gt;filp,
@@ -1051,6 +1032,7 @@ static int do_write(struct fsg_common *common)
 				break;
 			}
 
+ empty_write:
 			/* Did the host decide to stop early? */
 			if (bh-&gt;outreq-&gt;actual != bh-&gt;outreq-&gt;length) {
 				common-&gt;short_packet_received = 1;
@@ -1151,8 +1133,6 @@ static int do_verify(struct fsg_common *common)
 		 * Try to read the remaining amount, but not more than
 		 * the buffer size.
 		 * And don't try to read past the end of the file.
-		 * If this means reading 0 then we were asked to read
-		 * past the end of file.
 		 */
 		amount = min(amount_left, FSG_BUFLEN);
 		amount = min((loff_t)amount,
@@ -1628,7 +1608,8 @@ static int throw_away_data(struct fsg_common *common)
 			amount = min(common-&gt;usb_amount_left, FSG_BUFLEN);
 
 			/*
-			 * amount is always divisible by 512, hence by
+			 * Except at the end of the transfer, amount will be
+			 * equal to the buffer size, which is divisible by
 			 * the bulk-out maxpacket size.
 			 */
 			bh-&gt;outreq-&gt;length = amount;
diff --git a/drivers/usb/gadget/file_storage.c b/drivers/usb/gadget/file_storage.c
index 59d97750cecd..c6f96a2b3110 100644
--- a/drivers/usb/gadget/file_storage.c
+++ b/drivers/usb/gadget/file_storage.c
@@ -1135,7 +1135,6 @@ static int do_read(struct fsg_dev *fsg)
 	u32			amount_left;
 	loff_t			file_offset, file_offset_tmp;
 	unsigned int		amount;
-	unsigned int		partial_page;
 	ssize_t			nread;
 
 	/* Get the starting Logical Block Address and check that it's
@@ -1170,17 +1169,10 @@ static int do_read(struct fsg_dev *fsg)
 		 * Try to read the remaining amount.
 		 * But don't read more than the buffer size.
 		 * And don't try to read past the end of the file.
-		 * Finally, if we're not at a page boundary, don't read past
-		 *	the next page.
-		 * If this means reading 0 then we were asked to read past
-		 *	the end of file. */
+		 */
 		amount = min((unsigned int) amount_left, mod_data.buflen);
 		amount = min((loff_t) amount,
 				curlun-&gt;file_length - file_offset);
-		partial_page = file_offset &amp; (PAGE_CACHE_SIZE - 1);
-		if (partial_page &gt; 0)
-			amount = min(amount, (unsigned int) PAGE_CACHE_SIZE -
-					partial_page);
 
 		/* Wait for the next buffer to become available */
 		bh = fsg-&gt;next_buffhd_to_fill;
@@ -1225,6 +1217,11 @@ static int do_read(struct fsg_dev *fsg)
 		file_offset  += nread;
 		amount_left  -= nread;
 		fsg-&gt;residue -= nread;
+
+		/* Except at the end of the transfer, nread will be
+		 * equal to the buffer size, which is divisible by the
+		 * bulk-in maxpacket size.
+		 */
 		bh-&gt;inreq-&gt;length = nread;
 		bh-&gt;state = BUF_STATE_FULL;
 
@@ -1261,7 +1258,6 @@ static int do_write(struct fsg_dev *fsg)
 	u32			amount_left_to_req, amount_left_to_write;
 	loff_t			usb_offset, file_offset, file_offset_tmp;
 	unsigned int		amount;
-	unsigned int		partial_page;
 	ssize_t			nwritten;
 	int			rc;
 
@@ -1312,23 +1308,13 @@ static int do_write(struct fsg_dev *fsg)
 		if (bh-&gt;state == BUF_STATE_EMPTY &amp;&amp; get_some_more) {
 
 			/* Figure out how much we want to get:
-			 * Try to get the remaining amount.
-			 * But don't get more than the buffer size.
-			 * And don't try to go past the end of the file.
-			 * If we're not at a page boundary,
-			 *	don't go past the next page.
-			 * If this means getting 0, then we were asked
-			 *	to write past the end of file.
-			 * Finally, round down to a block boundary. */
+			 * Try to get the remaining amount,
+			 * but not more than the buffer size.
+			 */
 			amount = min(amount_left_to_req, mod_data.buflen);
-			amount = min((loff_t) amount, curlun-&gt;file_length -
-					usb_offset);
-			partial_page = usb_offset &amp; (PAGE_CACHE_SIZE - 1);
-			if (partial_page &gt; 0)
-				amount = min(amount,
-	(unsigned int) PAGE_CACHE_SIZE - partial_page);
-
-			if (amount == 0) {
+
+			/* Beyond the end of the backing file? */
+			if (usb_offset &gt;= curlun-&gt;file_length) {
 				get_some_more = 0;
 				curlun-&gt;sense_data =
 					SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;
@@ -1336,14 +1322,6 @@ static int do_write(struct fsg_dev *fsg)
 				curlun-&gt;info_valid = 1;
 				continue;
 			}
-			amount = round_down(amount, curlun-&gt;blksize);
-			if (amount == 0) {
-
-				/* Why were we were asked to transfer a
-				 * partial block? */
-				get_some_more = 0;
-				continue;
-			}
 
 			/* Get the next buffer */
 			usb_offset += amount;
@@ -1352,8 +1330,10 @@ static int do_write(struct fsg_dev *fsg)
 			if (amount_left_to_req == 0)
 				get_some_more = 0;
 
-			/* amount is always divisible by 512, hence by
-			 * the bulk-out maxpacket size */
+			/* Except at the end of the transfer, amount will be
+			 * equal to the buffer size, which is divisible by
+			 * the bulk-out maxpacket size.
+			 */
 			bh-&gt;outreq-&gt;length = bh-&gt;bulk_out_intended_length =
 					amount;
 			bh-&gt;outreq-&gt;short_not_ok = 1;
@@ -1389,6 +1369,11 @@ static int do_write(struct fsg_dev *fsg)
 				amount = curlun-&gt;file_length - file_offset;
 			}
 
+			/* Don't write a partial block */
+			amount = round_down(amount, curlun-&gt;blksize);
+			if (amount == 0)
+				goto empty_write;
+
 			/* Perform the write */
 			file_offset_tmp = file_offset;
 			nwritten = vfs_write(curlun-&gt;filp,
@@ -1421,6 +1406,7 @@ static int do_write(struct fsg_dev *fsg)
 				break;
 			}
 
+ empty_write:
 			/* Did the host decide to stop early? */
 			if (bh-&gt;outreq-&gt;actual != bh-&gt;outreq-&gt;length) {
 				fsg-&gt;short_packet_received = 1;
@@ -1517,8 +1503,7 @@ static int do_verify(struct fsg_dev *fsg)
 		 * Try to read the remaining amount, but not more than
 		 * the buffer size.
 		 * And don't try to read past the end of the file.
-		 * If this means reading 0 then we were asked to read
-		 * past the end of file. */
+		 */
 		amount = min((unsigned int) amount_left, mod_data.buflen);
 		amount = min((loff_t) amount,
 				curlun-&gt;file_length - file_offset);
@@ -1981,8 +1966,10 @@ static int throw_away_data(struct fsg_dev *fsg)
 			amount = min(fsg-&gt;usb_amount_left,
 					(u32) mod_data.buflen);
 
-			/* amount is always divisible by 512, hence by
-			 * the bulk-out maxpacket size */
+			/* Except at the end of the transfer, amount will be
+			 * equal to the buffer size, which is divisible by
+			 * the bulk-out maxpacket size.
+			 */
 			bh-&gt;outreq-&gt;length = bh-&gt;bulk_out_intended_length =
 					amount;
 			bh-&gt;outreq-&gt;short_not_ok = 1;</pre><hr><pre>commit e8799906045302776b35b66b16495c575db3b69c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Aug 18 16:31:30 2011 -0400

    USB: EHCI: remove usages of hcd-&gt;state
    
    This patch (as1483) improves the ehci-hcd driver family by getting rid
    of the reliance on the hcd-&gt;state variable.  It has no clear owner and
    it isn't protected by the usual HCD locks.  In its place, the patch
    adds a new, private ehci-&gt;rh_state field to record the state of the
    root hub.
    
    Along the way, the patch removes a couple of lines containing
    redundant assignments to the state variable.  Also, the QUIESCING
    state simply gets changed to the RUNNING state, because the driver
    doesn't make any distinction between them.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Jingoo Han &lt;jg1.han@samsung.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-au1xxx.c b/drivers/usb/host/ehci-au1xxx.c
index 42ae57409908..4363fea85151 100644
--- a/drivers/usb/host/ehci-au1xxx.c
+++ b/drivers/usb/host/ehci-au1xxx.c
@@ -293,7 +293,7 @@ static int ehci_hcd_au1xxx_drv_resume(struct device *dev)
 	/* here we "know" root ports should always stay powered */
 	ehci_port_power(ehci, 1);
 
-	hcd-&gt;state = HC_STATE_SUSPENDED;
+	ehci-&gt;rh_state = EHCI_RH_SUSPENDED;
 
 	return 0;
 }
diff --git a/drivers/usb/host/ehci-dbg.c b/drivers/usb/host/ehci-dbg.c
index 40a844c1dbb4..9952505d2357 100644
--- a/drivers/usb/host/ehci-dbg.c
+++ b/drivers/usb/host/ehci-dbg.c
@@ -697,6 +697,19 @@ static ssize_t fill_periodic_buffer(struct debug_buffer *buf)
 }
 #undef DBG_SCHED_LIMIT
 
+static const char *rh_state_string(struct ehci_hcd *ehci)
+{
+	switch (ehci-&gt;rh_state) {
+	case EHCI_RH_HALTED:
+		return "halted";
+	case EHCI_RH_SUSPENDED:
+		return "suspended";
+	case EHCI_RH_RUNNING:
+		return "running";
+	}
+	return "?";
+}
+
 static ssize_t fill_registers_buffer(struct debug_buffer *buf)
 {
 	struct usb_hcd		*hcd;
@@ -730,11 +743,11 @@ static ssize_t fill_registers_buffer(struct debug_buffer *buf)
 	temp = scnprintf (next, size,
 		"bus %s, device %s\n"
 		"%s\n"
-		"EHCI %x.%02x, hcd state %d\n",
+		"EHCI %x.%02x, rh state %s\n",
 		hcd-&gt;self.controller-&gt;bus-&gt;name,
 		dev_name(hcd-&gt;self.controller),
 		hcd-&gt;product_desc,
-		i &gt;&gt; 8, i &amp; 0x0ff, hcd-&gt;state);
+		i &gt;&gt; 8, i &amp; 0x0ff, rh_state_string(ehci));
 	size -= temp;
 	next += temp;
 
diff --git a/drivers/usb/host/ehci-fsl.c b/drivers/usb/host/ehci-fsl.c
index 34a3140d1e5f..3bf9f16b4fd8 100644
--- a/drivers/usb/host/ehci-fsl.c
+++ b/drivers/usb/host/ehci-fsl.c
@@ -392,7 +392,7 @@ static int ehci_fsl_mpc512x_drv_suspend(struct device *dev)
 
 	dev_dbg(dev, "suspending...\n");
 
-	hcd-&gt;state = HC_STATE_SUSPENDED;
+	ehci-&gt;rh_state = EHCI_RH_SUSPENDED;
 	dev-&gt;power.power_state = PMSG_SUSPEND;
 
 	/* ignore non-host interrupts */
@@ -481,7 +481,7 @@ static int ehci_fsl_mpc512x_drv_resume(struct device *dev)
 	ehci_writel(ehci, pdata-&gt;pm_portsc, &amp;ehci-&gt;regs-&gt;port_status[0]);
 
 	set_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
-	hcd-&gt;state = HC_STATE_RUNNING;
+	ehci-&gt;rh_state = EHCI_RH_RUNNING;
 	dev-&gt;power.power_state = PMSG_ON;
 
 	tmp = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 2af3e2a89efc..8696489cde56 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -238,7 +238,7 @@ static int handshake_on_error_set_halt(struct ehci_hcd *ehci, void __iomem *ptr,
 	error = handshake(ehci, ptr, mask, done, usec);
 	if (error) {
 		ehci_halt(ehci);
-		ehci_to_hcd(ehci)-&gt;state = HC_STATE_HALT;
+		ehci-&gt;rh_state = EHCI_RH_HALTED;
 		ehci_err(ehci, "force halt; handshake %p %08x %08x -&gt; %d\n",
 			ptr, mask, done, error);
 	}
@@ -278,7 +278,7 @@ static int ehci_reset (struct ehci_hcd *ehci)
 	command |= CMD_RESET;
 	dbg_cmd (ehci, "reset", command);
 	ehci_writel(ehci, command, &amp;ehci-&gt;regs-&gt;command);
-	ehci_to_hcd(ehci)-&gt;state = HC_STATE_HALT;
+	ehci-&gt;rh_state = EHCI_RH_HALTED;
 	ehci-&gt;next_statechange = jiffies;
 	retval = handshake (ehci, &amp;ehci-&gt;regs-&gt;command,
 			    CMD_RESET, 0, 250 * 1000);
@@ -307,7 +307,7 @@ static void ehci_quiesce (struct ehci_hcd *ehci)
 	u32	temp;
 
 #ifdef DEBUG
-	if (!HC_IS_RUNNING (ehci_to_hcd(ehci)-&gt;state))
+	if (ehci-&gt;rh_state != EHCI_RH_RUNNING)
 		BUG ();
 #endif
 
@@ -356,7 +356,7 @@ static void ehci_iaa_watchdog(unsigned long param)
 	 */
 	if (ehci-&gt;reclaim
 			&amp;&amp; !timer_pending(&amp;ehci-&gt;iaa_watchdog)
-			&amp;&amp; HC_IS_RUNNING(ehci_to_hcd(ehci)-&gt;state)) {
+			&amp;&amp; ehci-&gt;rh_state == EHCI_RH_RUNNING) {
 		u32 cmd, status;
 
 		/* If we get here, IAA is *REALLY* late.  It's barely
@@ -496,7 +496,7 @@ static void ehci_work (struct ehci_hcd *ehci)
 	 * misplace IRQs, and should let us run completely without IRQs.
 	 * such lossage has been observed on both VT6202 and VT8235.
 	 */
-	if (HC_IS_RUNNING (ehci_to_hcd(ehci)-&gt;state) &amp;&amp;
+	if (ehci-&gt;rh_state == EHCI_RH_RUNNING &amp;&amp;
 			(ehci-&gt;async-&gt;qh_next.ptr != NULL ||
 			 ehci-&gt;periodic_sched != 0))
 		timer_action (ehci, TIMER_IO_WATCHDOG);
@@ -516,7 +516,7 @@ static void ehci_stop (struct usb_hcd *hcd)
 	del_timer_sync(&amp;ehci-&gt;iaa_watchdog);
 
 	spin_lock_irq(&amp;ehci-&gt;lock);
-	if (HC_IS_RUNNING (hcd-&gt;state))
+	if (ehci-&gt;rh_state == EHCI_RH_RUNNING)
 		ehci_quiesce (ehci);
 
 	ehci_silence_controller(ehci);
@@ -741,7 +741,7 @@ static int ehci_run (struct usb_hcd *hcd)
 	 * be started before the port switching actions could complete.
 	 */
 	down_write(&amp;ehci_cf_port_reset_rwsem);
-	hcd-&gt;state = HC_STATE_RUNNING;
+	ehci-&gt;rh_state = EHCI_RH_RUNNING;
 	ehci_writel(ehci, FLAG_CF, &amp;ehci-&gt;regs-&gt;configured_flag);
 	ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);	/* unblock posted writes */
 	msleep(5);
@@ -788,7 +788,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 
 	/* Shared IRQ? */
 	masked_status = status &amp; INTR_MASK;
-	if (!masked_status || unlikely(hcd-&gt;state == HC_STATE_HALT)) {
+	if (!masked_status || unlikely(ehci-&gt;rh_state == EHCI_RH_HALTED)) {
 		spin_unlock(&amp;ehci-&gt;lock);
 		return IRQ_NONE;
 	}
@@ -952,7 +952,7 @@ static int ehci_urb_enqueue (
 static void unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
 	/* failfast */
-	if (!HC_IS_RUNNING(ehci_to_hcd(ehci)-&gt;state) &amp;&amp; ehci-&gt;reclaim)
+	if (ehci-&gt;rh_state != EHCI_RH_RUNNING &amp;&amp; ehci-&gt;reclaim)
 		end_unlink_async(ehci);
 
 	/* If the QH isn't linked then there's nothing we can do
@@ -1079,7 +1079,7 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 		goto idle_timeout;
 	}
 
-	if (!HC_IS_RUNNING (hcd-&gt;state))
+	if (ehci-&gt;rh_state != EHCI_RH_RUNNING)
 		qh-&gt;qh_state = QH_STATE_IDLE;
 	switch (qh-&gt;qh_state) {
 	case QH_STATE_LINKED:
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index e051b30c1847..c6104c4f1f38 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -236,10 +236,8 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 	}
 
 	/* stop schedules, clean any completed work */
-	if (HC_IS_RUNNING(hcd-&gt;state)) {
+	if (ehci-&gt;rh_state == EHCI_RH_RUNNING)
 		ehci_quiesce (ehci);
-		hcd-&gt;state = HC_STATE_QUIESCING;
-	}
 	ehci-&gt;command = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
 	ehci_work(ehci);
 
@@ -313,7 +311,7 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 
 	/* turn off now-idle HC */
 	ehci_halt (ehci);
-	hcd-&gt;state = HC_STATE_SUSPENDED;
+	ehci-&gt;rh_state = EHCI_RH_SUSPENDED;
 
 	if (ehci-&gt;reclaim)
 		end_unlink_async(ehci);
@@ -382,6 +380,7 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 
 	/* restore CMD_RUN, framelist size, and irq threshold */
 	ehci_writel(ehci, ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
+	ehci-&gt;rh_state = EHCI_RH_RUNNING;
 
 	/* Some controller/firmware combinations need a delay during which
 	 * they set up the port statuses.  See Bugzilla #8190. */
@@ -452,7 +451,6 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 	}
 
 	ehci-&gt;next_statechange = jiffies + msecs_to_jiffies(5);
-	hcd-&gt;state = HC_STATE_RUNNING;
 
 	/* Now we can safely re-enable irqs */
 	ehci_writel(ehci, INTR_MASK, &amp;ehci-&gt;regs-&gt;intr_enable);
@@ -564,7 +562,7 @@ ehci_hub_status_data (struct usb_hcd *hcd, char *buf)
 	u32		ppcd = 0;
 
 	/* if !USB_SUSPEND, root hub timers won't get shut down ... */
-	if (!HC_IS_RUNNING(hcd-&gt;state))
+	if (ehci-&gt;rh_state != EHCI_RH_RUNNING)
 		return 0;
 
 	/* init status to no-changes */
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 1102ce65a3a9..8311de7c0a75 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -439,7 +439,7 @@ static int ehci_pci_resume(struct usb_hcd *hcd, bool hibernated)
 	/* here we "know" root ports should always stay powered */
 	ehci_port_power(ehci, 1);
 
-	hcd-&gt;state = HC_STATE_SUSPENDED;
+	ehci-&gt;rh_state = EHCI_RH_SUSPENDED;
 	return 0;
 }
 #endif
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 0917e3a32465..6ce0b3a9a0f9 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -153,7 +153,7 @@ static void ehci_clear_tt_buffer_complete(struct usb_hcd *hcd,
 	spin_lock_irqsave(&amp;ehci-&gt;lock, flags);
 	qh-&gt;clearing_tt = 0;
 	if (qh-&gt;qh_state == QH_STATE_IDLE &amp;&amp; !list_empty(&amp;qh-&gt;qtd_list)
-			&amp;&amp; HC_IS_RUNNING(hcd-&gt;state))
+			&amp;&amp; ehci-&gt;rh_state == EHCI_RH_RUNNING)
 		qh_link_async(ehci, qh);
 	spin_unlock_irqrestore(&amp;ehci-&gt;lock, flags);
 }
@@ -425,7 +425,7 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 
 		/* stop scanning when we reach qtds the hc is using */
 		} else if (likely (!stopped
-				&amp;&amp; HC_IS_RUNNING (ehci_to_hcd(ehci)-&gt;state))) {
+				&amp;&amp; ehci-&gt;rh_state == EHCI_RH_RUNNING)) {
 			break;
 
 		/* scan the whole queue for unlinks whenever it stops */
@@ -433,7 +433,7 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 			stopped = 1;
 
 			/* cancel everything if we halt, suspend, etc */
-			if (!HC_IS_RUNNING(ehci_to_hcd(ehci)-&gt;state))
+			if (ehci-&gt;rh_state != EHCI_RH_RUNNING)
 				last_status = -ESHUTDOWN;
 
 			/* this qtd is active; skip it unless a previous qtd
@@ -977,9 +977,8 @@ static void qh_link_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 			/* in case a clear of CMD_ASE didn't take yet */
 			(void)handshake(ehci, &amp;ehci-&gt;regs-&gt;status,
 					STS_ASS, 0, 150);
-			cmd |= CMD_ASE | CMD_RUN;
+			cmd |= CMD_ASE;
 			ehci_writel(ehci, cmd, &amp;ehci-&gt;regs-&gt;command);
-			ehci_to_hcd(ehci)-&gt;state = HC_STATE_RUNNING;
 			/* posted write need not be known to HC yet ... */
 		}
 	}
@@ -1168,14 +1167,13 @@ static void end_unlink_async (struct ehci_hcd *ehci)
 
 	qh_completions (ehci, qh);
 
-	if (!list_empty (&amp;qh-&gt;qtd_list)
-			&amp;&amp; HC_IS_RUNNING (ehci_to_hcd(ehci)-&gt;state))
+	if (!list_empty(&amp;qh-&gt;qtd_list) &amp;&amp; ehci-&gt;rh_state == EHCI_RH_RUNNING) {
 		qh_link_async (ehci, qh);
-	else {
+	} else {
 		/* it's not free to turn the async schedule on/off; leave it
 		 * active but idle for a while once it empties.
 		 */
-		if (HC_IS_RUNNING (ehci_to_hcd(ehci)-&gt;state)
+		if (ehci-&gt;rh_state == EHCI_RH_RUNNING
 				&amp;&amp; ehci-&gt;async-&gt;qh_next.qh == NULL)
 			timer_action (ehci, TIMER_ASYNC_OFF);
 	}
@@ -1211,7 +1209,7 @@ static void start_unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	/* stop async schedule right now? */
 	if (unlikely (qh == ehci-&gt;async)) {
 		/* can't get here without STS_ASS set */
-		if (ehci_to_hcd(ehci)-&gt;state != HC_STATE_HALT
+		if (ehci-&gt;rh_state != EHCI_RH_HALTED
 				&amp;&amp; !ehci-&gt;reclaim) {
 			/* ... and CMD_IAAD clear */
 			ehci_writel(ehci, cmd &amp; ~CMD_ASE,
@@ -1237,7 +1235,7 @@ static void start_unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	wmb ();
 
 	/* If the controller isn't running, we don't have to wait for it */
-	if (unlikely(!HC_IS_RUNNING(ehci_to_hcd(ehci)-&gt;state))) {
+	if (unlikely(ehci-&gt;rh_state != EHCI_RH_RUNNING)) {
 		/* if (unlikely (qh-&gt;reclaim != 0))
 		 *	this will recurse, probably not much
 		 */
@@ -1260,7 +1258,7 @@ static void scan_async (struct ehci_hcd *ehci)
 	enum ehci_timer_action	action = TIMER_IO_WATCHDOG;
 
 	timer_action_done (ehci, TIMER_ASYNC_SHRINK);
-	stopped = !HC_IS_RUNNING(ehci_to_hcd(ehci)-&gt;state);
+	stopped = (ehci-&gt;rh_state != EHCI_RH_RUNNING);
 
 	ehci-&gt;qh_scan_next = ehci-&gt;async-&gt;qh_next.qh;
 	while (ehci-&gt;qh_scan_next) {
diff --git a/drivers/usb/host/ehci-s5p.c b/drivers/usb/host/ehci-s5p.c
index b3958b3d3163..318e0c6d0ab1 100644
--- a/drivers/usb/host/ehci-s5p.c
+++ b/drivers/usb/host/ehci-s5p.c
@@ -269,7 +269,7 @@ static int s5p_ehci_resume(struct device *dev)
 	/* here we "know" root ports should always stay powered */
 	ehci_port_power(ehci, 1);
 
-	hcd-&gt;state = HC_STATE_SUSPENDED;
+	ehci-&gt;rh_state = EHCI_RH_SUSPENDED;
 
 	return 0;
 }
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 2abf8543f083..488151bb45cb 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -479,7 +479,6 @@ static int enable_periodic (struct ehci_hcd *ehci)
 	cmd = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command) | CMD_PSE;
 	ehci_writel(ehci, cmd, &amp;ehci-&gt;regs-&gt;command);
 	/* posted write ... PSS happens later */
-	ehci_to_hcd(ehci)-&gt;state = HC_STATE_RUNNING;
 
 	/* make sure ehci_work scans these */
 	ehci-&gt;next_uframe = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;frame_index)
@@ -677,7 +676,7 @@ static void intr_deschedule (struct ehci_hcd *ehci, struct ehci_qh *qh)
 
 	/* reschedule QH iff another request is queued */
 	if (!list_empty(&amp;qh-&gt;qtd_list) &amp;&amp;
-			HC_IS_RUNNING(ehci_to_hcd(ehci)-&gt;state)) {
+			ehci-&gt;rh_state == EHCI_RH_RUNNING) {
 		rc = qh_schedule(ehci, qh);
 
 		/* An error here likely indicates handshake failure
@@ -2275,7 +2274,7 @@ scan_periodic (struct ehci_hcd *ehci)
 	 * Touches as few pages as possible:  cache-friendly.
 	 */
 	now_uframe = ehci-&gt;next_uframe;
-	if (HC_IS_RUNNING(ehci_to_hcd(ehci)-&gt;state)) {
+	if (ehci-&gt;rh_state == EHCI_RH_RUNNING) {
 		clock = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;frame_index);
 		clock_frame = (clock &gt;&gt; 3) &amp; (ehci-&gt;periodic_size - 1);
 	} else  {
@@ -2310,7 +2309,7 @@ scan_periodic (struct ehci_hcd *ehci)
 			union ehci_shadow	temp;
 			int			live;
 
-			live = HC_IS_RUNNING (ehci_to_hcd(ehci)-&gt;state);
+			live = (ehci-&gt;rh_state == EHCI_RH_RUNNING);
 			switch (hc32_to_cpu(ehci, type)) {
 			case Q_TYPE_QH:
 				/* handle any completions */
@@ -2435,7 +2434,7 @@ scan_periodic (struct ehci_hcd *ehci)
 		 * We can't advance our scan without collecting the ISO
 		 * transfers that are still pending in this frame.
 		 */
-		if (incomplete &amp;&amp; HC_IS_RUNNING(ehci_to_hcd(ehci)-&gt;state)) {
+		if (incomplete &amp;&amp; ehci-&gt;rh_state == EHCI_RH_RUNNING) {
 			ehci-&gt;next_uframe = now_uframe;
 			break;
 		}
@@ -2451,7 +2450,7 @@ scan_periodic (struct ehci_hcd *ehci)
 		if (now_uframe == clock) {
 			unsigned	now;
 
-			if (!HC_IS_RUNNING (ehci_to_hcd(ehci)-&gt;state)
+			if (ehci-&gt;rh_state != EHCI_RH_RUNNING
 					|| ehci-&gt;periodic_sched == 0)
 				break;
 			ehci-&gt;next_uframe = now_uframe;
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index cc7d337ec355..c161d97de7dd 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -62,6 +62,12 @@ struct ehci_stats {
 
 #define	EHCI_MAX_ROOT_PORTS	15		/* see HCS_N_PORTS */
 
+enum ehci_rh_state {
+	EHCI_RH_HALTED,
+	EHCI_RH_SUSPENDED,
+	EHCI_RH_RUNNING
+};
+
 struct ehci_hcd {			/* one per controller */
 	/* glue to PCI and HCD framework */
 	struct ehci_caps __iomem *caps;
@@ -70,6 +76,7 @@ struct ehci_hcd {			/* one per controller */
 
 	__u32			hcs_params;	/* cached register copy */
 	spinlock_t		lock;
+	enum ehci_rh_state	rh_state;
 
 	/* async schedule support */
 	struct ehci_qh		*async;</pre><hr><pre>commit 5b1b0b812a7b1a5b968c5d06d90d1cb88621b941
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 19 23:49:48 2011 +0200

    PM / Runtime: Add macro to test for runtime PM events
    
    This patch (as1482) adds a macro for testing whether or not a
    pm_message value represents an autosuspend or autoresume (i.e., a
    runtime PM) event.  Encapsulating this notion seems preferable to
    open-coding the test all over the place.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;
    Signed-off-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;

diff --git a/Documentation/usb/power-management.txt b/Documentation/usb/power-management.txt
index c9ffa9ced7ee..e8662a5fbc5d 100644
--- a/Documentation/usb/power-management.txt
+++ b/Documentation/usb/power-management.txt
@@ -439,10 +439,10 @@ cause autosuspends to fail with -EBUSY if the driver needs to use the
 device.
 
 External suspend calls should never be allowed to fail in this way,
-only autosuspend calls.  The driver can tell them apart by checking
-the PM_EVENT_AUTO bit in the message.event argument to the suspend
-method; this bit will be set for internal PM events (autosuspend) and
-clear for external PM events.
+only autosuspend calls.  The driver can tell them apart by applying
+the PMSG_IS_AUTO() macro to the message argument to the suspend
+method; it will return True for internal PM events (autosuspend) and
+False for external PM events.
 
 
 	Mutual exclusion
diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c
index 91d13a9e8c65..91b190c40497 100644
--- a/drivers/bluetooth/btusb.c
+++ b/drivers/bluetooth/btusb.c
@@ -1103,7 +1103,7 @@ static int btusb_suspend(struct usb_interface *intf, pm_message_t message)
 		return 0;
 
 	spin_lock_irq(&amp;data-&gt;txlock);
-	if (!((message.event &amp; PM_EVENT_AUTO) &amp;&amp; data-&gt;tx_in_flight)) {
+	if (!(PMSG_IS_AUTO(message) &amp;&amp; data-&gt;tx_in_flight)) {
 		set_bit(BTUSB_SUSPENDING, &amp;data-&gt;flags);
 		spin_unlock_irq(&amp;data-&gt;txlock);
 	} else {
diff --git a/drivers/hid/hid-picolcd.c b/drivers/hid/hid-picolcd.c
index 9d8710f8bc79..1782693819f3 100644
--- a/drivers/hid/hid-picolcd.c
+++ b/drivers/hid/hid-picolcd.c
@@ -2409,7 +2409,7 @@ static int picolcd_raw_event(struct hid_device *hdev,
 #ifdef CONFIG_PM
 static int picolcd_suspend(struct hid_device *hdev, pm_message_t message)
 {
-	if (message.event &amp; PM_EVENT_AUTO)
+	if (PMSG_IS_AUTO(message))
 		return 0;
 
 	picolcd_suspend_backlight(hid_get_drvdata(hdev));
diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c
index ad978f5748d3..a9fa294ee7d3 100644
--- a/drivers/hid/usbhid/hid-core.c
+++ b/drivers/hid/usbhid/hid-core.c
@@ -1332,7 +1332,7 @@ static int hid_suspend(struct usb_interface *intf, pm_message_t message)
 	struct usbhid_device *usbhid = hid-&gt;driver_data;
 	int status;
 
-	if (message.event &amp; PM_EVENT_AUTO) {
+	if (PMSG_IS_AUTO(message)) {
 		spin_lock_irq(&amp;usbhid-&gt;lock);	/* Sync with error handler */
 		if (!test_bit(HID_RESET_PENDING, &amp;usbhid-&gt;iofl)
 		    &amp;&amp; !test_bit(HID_CLEAR_HALT, &amp;usbhid-&gt;iofl)
@@ -1367,7 +1367,7 @@ static int hid_suspend(struct usb_interface *intf, pm_message_t message)
 			return -EIO;
 	}
 
-	if (!ignoreled &amp;&amp; (message.event &amp; PM_EVENT_AUTO)) {
+	if (!ignoreled &amp;&amp; PMSG_IS_AUTO(message)) {
 		spin_lock_irq(&amp;usbhid-&gt;lock);
 		if (test_bit(HID_LED_ON, &amp;usbhid-&gt;iofl)) {
 			spin_unlock_irq(&amp;usbhid-&gt;lock);
@@ -1380,8 +1380,7 @@ static int hid_suspend(struct usb_interface *intf, pm_message_t message)
 	hid_cancel_delayed_stuff(usbhid);
 	hid_cease_io(usbhid);
 
-	if ((message.event &amp; PM_EVENT_AUTO) &amp;&amp;
-			test_bit(HID_KEYS_PRESSED, &amp;usbhid-&gt;iofl)) {
+	if (PMSG_IS_AUTO(message) &amp;&amp; test_bit(HID_KEYS_PRESSED, &amp;usbhid-&gt;iofl)) {
 		/* lost race against keypresses */
 		status = hid_start_in(hid);
 		if (status &lt; 0)
diff --git a/drivers/net/usb/usbnet.c b/drivers/net/usb/usbnet.c
index ce395fe5de26..f1c435ba5284 100644
--- a/drivers/net/usb/usbnet.c
+++ b/drivers/net/usb/usbnet.c
@@ -1470,7 +1470,7 @@ int usbnet_suspend (struct usb_interface *intf, pm_message_t message)
 	if (!dev-&gt;suspend_count++) {
 		spin_lock_irq(&amp;dev-&gt;txq.lock);
 		/* don't autosuspend while transmitting */
-		if (dev-&gt;txq.qlen &amp;&amp; (message.event &amp; PM_EVENT_AUTO)) {
+		if (dev-&gt;txq.qlen &amp;&amp; PMSG_IS_AUTO(message)) {
 			spin_unlock_irq(&amp;dev-&gt;txq.lock);
 			return -EBUSY;
 		} else {
diff --git a/drivers/net/wimax/i2400m/usb.c b/drivers/net/wimax/i2400m/usb.c
index 298f2b0b6311..9a644d052f1e 100644
--- a/drivers/net/wimax/i2400m/usb.c
+++ b/drivers/net/wimax/i2400m/usb.c
@@ -599,7 +599,7 @@ void i2400mu_disconnect(struct usb_interface *iface)
  *
  *    As well, the device might refuse going to sleep for whichever
  *    reason. In this case we just fail. For system suspend/hibernate,
- *    we *can't* fail. We check PM_EVENT_AUTO to see if the
+ *    we *can't* fail. We check PMSG_IS_AUTO to see if the
  *    suspend call comes from the USB stack or from the system and act
  *    in consequence.
  *
@@ -615,7 +615,7 @@ int i2400mu_suspend(struct usb_interface *iface, pm_message_t pm_msg)
 	struct i2400m *i2400m = &amp;i2400mu-&gt;i2400m;
 
 #ifdef CONFIG_PM
-	if (pm_msg.event &amp; PM_EVENT_AUTO)
+	if (PMSG_IS_AUTO(pm_msg))
 		is_autosuspend = 1;
 #endif
 
diff --git a/drivers/usb/class/cdc-acm.c b/drivers/usb/class/cdc-acm.c
index dac7676ce21b..94e6c5c09dd8 100644
--- a/drivers/usb/class/cdc-acm.c
+++ b/drivers/usb/class/cdc-acm.c
@@ -1305,7 +1305,7 @@ static int acm_suspend(struct usb_interface *intf, pm_message_t message)
 	struct acm *acm = usb_get_intfdata(intf);
 	int cnt;
 
-	if (message.event &amp; PM_EVENT_AUTO) {
+	if (PMSG_IS_AUTO(message)) {
 		int b;
 
 		spin_lock_irq(&amp;acm-&gt;write_lock);
diff --git a/drivers/usb/class/cdc-wdm.c b/drivers/usb/class/cdc-wdm.c
index 2b9ff518b509..42f180aca3fb 100644
--- a/drivers/usb/class/cdc-wdm.c
+++ b/drivers/usb/class/cdc-wdm.c
@@ -798,11 +798,11 @@ static int wdm_suspend(struct usb_interface *intf, pm_message_t message)
 	dev_dbg(&amp;desc-&gt;intf-&gt;dev, "wdm%d_suspend\n", intf-&gt;minor);
 
 	/* if this is an autosuspend the caller does the locking */
-	if (!(message.event &amp; PM_EVENT_AUTO))
+	if (!PMSG_IS_AUTO(message))
 		mutex_lock(&amp;desc-&gt;lock);
 	spin_lock_irq(&amp;desc-&gt;iuspin);
 
-	if ((message.event &amp; PM_EVENT_AUTO) &amp;&amp;
+	if (PMSG_IS_AUTO(message) &amp;&amp;
 			(test_bit(WDM_IN_USE, &amp;desc-&gt;flags)
 			|| test_bit(WDM_RESPONDING, &amp;desc-&gt;flags))) {
 		spin_unlock_irq(&amp;desc-&gt;iuspin);
@@ -815,7 +815,7 @@ static int wdm_suspend(struct usb_interface *intf, pm_message_t message)
 		kill_urbs(desc);
 		cancel_work_sync(&amp;desc-&gt;rxwork);
 	}
-	if (!(message.event &amp; PM_EVENT_AUTO))
+	if (!PMSG_IS_AUTO(message))
 		mutex_unlock(&amp;desc-&gt;lock);
 
 	return rv;
diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 34e3da5aa72a..e03042883c68 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -1046,8 +1046,7 @@ static int usb_resume_device(struct usb_device *udev, pm_message_t msg)
 	/* Non-root devices on a full/low-speed bus must wait for their
 	 * companion high-speed root hub, in case a handoff is needed.
 	 */
-	if (!(msg.event &amp; PM_EVENT_AUTO) &amp;&amp; udev-&gt;parent &amp;&amp;
-			udev-&gt;bus-&gt;hs_companion)
+	if (!PMSG_IS_AUTO(msg) &amp;&amp; udev-&gt;parent &amp;&amp; udev-&gt;bus-&gt;hs_companion)
 		device_pm_wait_for_dev(&amp;udev-&gt;dev,
 				&amp;udev-&gt;bus-&gt;hs_companion-&gt;root_hub-&gt;dev);
 
@@ -1075,7 +1074,7 @@ static int usb_suspend_interface(struct usb_device *udev,
 
 	if (driver-&gt;suspend) {
 		status = driver-&gt;suspend(intf, msg);
-		if (status &amp;&amp; !(msg.event &amp; PM_EVENT_AUTO))
+		if (status &amp;&amp; !PMSG_IS_AUTO(msg))
 			dev_err(&amp;intf-&gt;dev, "%s error %d\n",
 					"suspend", status);
 	} else {
@@ -1189,7 +1188,7 @@ static int usb_suspend_both(struct usb_device *udev, pm_message_t msg)
 			status = usb_suspend_interface(udev, intf, msg);
 
 			/* Ignore errors during system sleep transitions */
-			if (!(msg.event &amp; PM_EVENT_AUTO))
+			if (!PMSG_IS_AUTO(msg))
 				status = 0;
 			if (status != 0)
 				break;
@@ -1199,7 +1198,7 @@ static int usb_suspend_both(struct usb_device *udev, pm_message_t msg)
 		status = usb_suspend_device(udev, msg);
 
 		/* Again, ignore errors during system sleep transitions */
-		if (!(msg.event &amp; PM_EVENT_AUTO))
+		if (!PMSG_IS_AUTO(msg))
 			status = 0;
 	}
 
diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 8669ba3fe794..da582f4e486b 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1960,7 +1960,7 @@ int hcd_bus_suspend(struct usb_device *rhdev, pm_message_t msg)
 	int		old_state = hcd-&gt;state;
 
 	dev_dbg(&amp;rhdev-&gt;dev, "bus %s%s\n",
-			(msg.event &amp; PM_EVENT_AUTO ? "auto-" : ""), "suspend");
+			(PMSG_IS_AUTO(msg) ? "auto-" : ""), "suspend");
 	if (HCD_DEAD(hcd)) {
 		dev_dbg(&amp;rhdev-&gt;dev, "skipped %s of dead bus\n", "suspend");
 		return 0;
@@ -1996,7 +1996,7 @@ int hcd_bus_resume(struct usb_device *rhdev, pm_message_t msg)
 	int		old_state = hcd-&gt;state;
 
 	dev_dbg(&amp;rhdev-&gt;dev, "usb %s%s\n",
-			(msg.event &amp; PM_EVENT_AUTO ? "auto-" : ""), "resume");
+			(PMSG_IS_AUTO(msg) ? "auto-" : ""), "resume");
 	if (HCD_DEAD(hcd)) {
 		dev_dbg(&amp;rhdev-&gt;dev, "skipped %s of dead bus\n", "resume");
 		return 0;
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index a428aa080a36..ee50e0bf84e8 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2342,7 +2342,7 @@ int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
 			dev_dbg(&amp;udev-&gt;dev, "won't remote wakeup, status %d\n",
 					status);
 			/* bail if autosuspend is requested */
-			if (msg.event &amp; PM_EVENT_AUTO)
+			if (PMSG_IS_AUTO(msg))
 				return status;
 		}
 	}
@@ -2367,12 +2367,12 @@ int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
 				USB_CTRL_SET_TIMEOUT);
 
 		/* System sleep transitions should never fail */
-		if (!(msg.event &amp; PM_EVENT_AUTO))
+		if (!PMSG_IS_AUTO(msg))
 			status = 0;
 	} else {
 		/* device has up to 10 msec to fully suspend */
 		dev_dbg(&amp;udev-&gt;dev, "usb %ssuspend\n",
-				(msg.event &amp; PM_EVENT_AUTO ? "auto-" : ""));
+				(PMSG_IS_AUTO(msg) ? "auto-" : ""));
 		usb_set_device_state(udev, USB_STATE_SUSPENDED);
 		msleep(10);
 	}
@@ -2523,7 +2523,7 @@ int usb_port_resume(struct usb_device *udev, pm_message_t msg)
 	} else {
 		/* drive resume for at least 20 msec */
 		dev_dbg(&amp;udev-&gt;dev, "usb %sresume\n",
-				(msg.event &amp; PM_EVENT_AUTO ? "auto-" : ""));
+				(PMSG_IS_AUTO(msg) ? "auto-" : ""));
 		msleep(25);
 
 		/* Virtual root hubs can trigger on GET_PORT_STATUS to
@@ -2625,7 +2625,7 @@ static int hub_suspend(struct usb_interface *intf, pm_message_t msg)
 		udev = hdev-&gt;children [port1-1];
 		if (udev &amp;&amp; udev-&gt;can_submit) {
 			dev_warn(&amp;intf-&gt;dev, "port %d nyet suspended\n", port1);
-			if (msg.event &amp; PM_EVENT_AUTO)
+			if (PMSG_IS_AUTO(msg))
 				return -EBUSY;
 		}
 	}
diff --git a/drivers/usb/serial/sierra.c b/drivers/usb/serial/sierra.c
index d5d136a53b61..b18179bda0d8 100644
--- a/drivers/usb/serial/sierra.c
+++ b/drivers/usb/serial/sierra.c
@@ -1009,7 +1009,7 @@ static int sierra_suspend(struct usb_serial *serial, pm_message_t message)
 	struct sierra_intf_private *intfdata;
 	int b;
 
-	if (message.event &amp; PM_EVENT_AUTO) {
+	if (PMSG_IS_AUTO(message)) {
 		intfdata = serial-&gt;private;
 		spin_lock_irq(&amp;intfdata-&gt;susp_lock);
 		b = intfdata-&gt;in_flight;
diff --git a/drivers/usb/serial/usb_wwan.c b/drivers/usb/serial/usb_wwan.c
index e4fad5e643d7..d555ca9567b8 100644
--- a/drivers/usb/serial/usb_wwan.c
+++ b/drivers/usb/serial/usb_wwan.c
@@ -651,7 +651,7 @@ int usb_wwan_suspend(struct usb_serial *serial, pm_message_t message)
 
 	dbg("%s entered", __func__);
 
-	if (message.event &amp; PM_EVENT_AUTO) {
+	if (PMSG_IS_AUTO(message)) {
 		spin_lock_irq(&amp;intfdata-&gt;susp_lock);
 		b = intfdata-&gt;in_flight;
 		spin_unlock_irq(&amp;intfdata-&gt;susp_lock);
diff --git a/include/linux/pm.h b/include/linux/pm.h
index f7c84c9abd30..18de9f893497 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -366,6 +366,8 @@ extern struct dev_pm_ops generic_subsys_pm_ops;
 #define PMSG_AUTO_RESUME	((struct pm_message) \
 					{ .event = PM_EVENT_AUTO_RESUME, })
 
+#define PMSG_IS_AUTO(msg)	(((msg).event &amp; PM_EVENT_AUTO) != 0)
+
 /**
  * Device run-time power management status.
  *
diff --git a/sound/usb/card.c b/sound/usb/card.c
index 781d9e61adfb..d5754fa5e551 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -628,7 +628,7 @@ static int usb_audio_suspend(struct usb_interface *intf, pm_message_t message)
 	if (chip == (void *)-1L)
 		return 0;
 
-	if (!(message.event &amp; PM_EVENT_AUTO)) {
+	if (!PMSG_IS_AUTO(message)) {
 		snd_power_change_state(chip-&gt;card, SNDRV_CTL_POWER_D3hot);
 		if (!chip-&gt;num_suspended_intf++) {
 			list_for_each(p, &amp;chip-&gt;pcm_list) {</pre><hr><pre>commit e04f5f7e423018bcec84c11af2058cdce87816f3
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jul 19 14:01:23 2011 -0400

    EHCI: fix direction handling for interrupt data toggles
    
    This patch (as1480) fixes a rather obscure bug in ehci-hcd.  The
    qh_update() routine needs to know the number and direction of the
    endpoint corresponding to its QH argument.  The number can be taken
    directly from the QH data structure, but the direction isn't stored
    there.  The direction is taken instead from the first qTD linked to
    the QH.
    
    However, it turns out that for interrupt transfers, qh_update() gets
    called before the qTDs are linked to the QH.  As a result, qh_update()
    computes a bogus direction value, which messes up the endpoint toggle
    handling.  Under the right combination of circumstances this causes
    usb_reset_endpoint() not to work correctly, which causes packets to be
    dropped and communications to fail.
    
    Now, it's silly for the QH structure not to have direct access to all
    the descriptor information for the corresponding endpoint.  Ultimately
    it may get a pointer to the usb_host_endpoint structure; for now,
    adding a copy of the direction flag solves the immediate problem.
    
    This allows the Spyder2 color-calibration system (a low-speed USB
    device that sends all its interrupt data packets with the toggle set
    to 0 and hance requires constant use of usb_reset_endpoint) to work
    when connected through a high-speed hub.  Thanks to Graeme Gill for
    supplying the hardware that allowed me to track down this bug.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Graeme Gill &lt;graeme@argyllcms.com&gt;
    CC: &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 9bf3c0d983c4..0917e3a32465 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -103,7 +103,7 @@ qh_update (struct ehci_hcd *ehci, struct ehci_qh *qh, struct ehci_qtd *qtd)
 	if (!(hw-&gt;hw_info1 &amp; cpu_to_hc32(ehci, 1 &lt;&lt; 14))) {
 		unsigned	is_out, epnum;
 
-		is_out = !(qtd-&gt;hw_token &amp; cpu_to_hc32(ehci, 1 &lt;&lt; 8));
+		is_out = qh-&gt;is_out;
 		epnum = (hc32_to_cpup(ehci, &amp;hw-&gt;hw_info1) &gt;&gt; 8) &amp; 0x0f;
 		if (unlikely (!usb_gettoggle (qh-&gt;dev, epnum, is_out))) {
 			hw-&gt;hw_token &amp;= ~cpu_to_hc32(ehci, QTD_TOGGLE);
@@ -946,6 +946,7 @@ qh_make (
 	hw = qh-&gt;hw;
 	hw-&gt;hw_info1 = cpu_to_hc32(ehci, info1);
 	hw-&gt;hw_info2 = cpu_to_hc32(ehci, info2);
+	qh-&gt;is_out = !is_input;
 	usb_settoggle (urb-&gt;dev, usb_pipeendpoint (urb-&gt;pipe), !is_input, 1);
 	qh_refresh (ehci, qh);
 	return qh;
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index e4feec3457fb..cc7d337ec355 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -377,6 +377,7 @@ struct ehci_qh {
 #define NO_FRAME ((unsigned short)~0)			/* pick new start */
 
 	struct usb_device	*dev;		/* access to TT */
+	unsigned		is_out:1;	/* bulk or intr OUT */
 	unsigned		clearing_tt:1;	/* Clear-TT-Buf in progress */
 };
 </pre><hr><pre>commit 6ea12a04d295235ed67010a09fdea58c949e3eb0
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jul 15 17:22:15 2011 -0400

    USB: OHCI: fix another regression for NVIDIA controllers
    
    The NVIDIA series of OHCI controllers continues to be troublesome.  A
    few people using the MCP67 chipset have reported that even with the
    most recent kernels, the OHCI controller fails to handle new
    connections and spams the system log with "unable to enumerate USB
    port" messages.  This is different from the other problems previously
    reported for NVIDIA OHCI controllers, although it is probably related.
    
    It turns out that the MCP67 controller does not like to be kept in the
    RESET state very long.  After only a few seconds, it decides not to
    work any more.  This patch (as1479) changes the PCI initialization
    quirk code so that NVIDIA controllers are switched into the SUSPEND
    state after 50 ms of RESET.  With no interrupts enabled and all the
    downstream devices reset, and thus unable to send wakeup requests,
    this should be perfectly safe (even for non-NVIDIA hardware).
    
    The removal code in ohci-hcd hasn't been changed; it will still leave
    the controller in the RESET state.  As a result, if someone unloads
    ohci-hcd and then reloads it, the controller won't work again until
    the system is rebooted.  If anybody complains about this, the removal
    code can be updated similarly.
    
    This fixes Bugzilla #22052.
    
    Tested-by: Larry Finger &lt;Larry.Finger@lwfinger.net&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/pci-quirks.c b/drivers/usb/host/pci-quirks.c
index b5a7304fcbef..a9d315906e3d 100644
--- a/drivers/usb/host/pci-quirks.c
+++ b/drivers/usb/host/pci-quirks.c
@@ -35,6 +35,8 @@
 #define OHCI_INTRSTATUS		0x0c
 #define OHCI_INTRENABLE		0x10
 #define OHCI_INTRDISABLE	0x14
+#define OHCI_FMINTERVAL		0x34
+#define OHCI_HCR		(1 &lt;&lt; 0)	/* host controller reset */
 #define OHCI_OCR		(1 &lt;&lt; 3)	/* ownership change request */
 #define OHCI_CTRL_RWC		(1 &lt;&lt; 9)	/* remote wakeup connected */
 #define OHCI_CTRL_IR		(1 &lt;&lt; 8)	/* interrupt routing */
@@ -497,6 +499,32 @@ static void __devinit quirk_usb_handoff_ohci(struct pci_dev *pdev)
 
 	/* reset controller, preserving RWC (and possibly IR) */
 	writel(control &amp; OHCI_CTRL_MASK, base + OHCI_CONTROL);
+	readl(base + OHCI_CONTROL);
+
+	/* Some NVIDIA controllers stop working if kept in RESET for too long */
+	if (pdev-&gt;vendor == PCI_VENDOR_ID_NVIDIA) {
+		u32 fminterval;
+		int cnt;
+
+		/* drive reset for at least 50 ms (7.1.7.5) */
+		msleep(50);
+
+		/* software reset of the controller, preserving HcFmInterval */
+		fminterval = readl(base + OHCI_FMINTERVAL);
+		writel(OHCI_HCR, base + OHCI_CMDSTATUS);
+
+		/* reset requires max 10 us delay */
+		for (cnt = 30; cnt &gt; 0; --cnt) {	/* ... allow extra time */
+			if ((readl(base + OHCI_CMDSTATUS) &amp; OHCI_HCR) == 0)
+				break;
+			udelay(1);
+		}
+		writel(fminterval, base + OHCI_FMINTERVAL);
+
+		/* Now we're in the SUSPEND state with all devices reset
+		 * and wakeups and interrupts disabled
+		 */
+	}
 
 	/*
 	 * disable interrupts</pre>
    <div class="pagination">
        <a href='2_54.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><span>[55]</span><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_56.html'>Next&gt;&gt;</a>
    <div>
</body>
