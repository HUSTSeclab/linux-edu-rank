<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_55.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><span>[56]</span><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_57.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 004c19682884d4f40000ce1ded53f4a1d0b18206
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jul 5 12:34:05 2011 -0400

    USB: EHCI: go back to using the system clock for QH unlinks
    
    This patch (as1477) fixes a problem affecting a few types of EHCI
    controller.  Contrary to what one might expect, these controllers
    automatically stop their internal frame counter when no ports are
    enabled.  Since ehci-hcd currently relies on the frame counter for
    determining when it should unlink QHs from the async schedule, those
    controllers run into trouble: The frame counter stops and the QHs
    never get unlinked.
    
    Some systems have also experienced other problems traced back to
    commit b963801164618e25fbdc0cd452ce49c3628b46c8 (USB: ehci-hcd unlink
    speedups), which made the original switch from using the system clock
    to using the frame counter.  It never became clear what the reason was
    for these problems, but evidently it is related to use of the frame
    counter.
    
    To fix all these problems, this patch more or less reverts that commit
    and goes back to using the system clock.  But this can't be done
    cleanly because other changes have since been made to the scan_async()
    subroutine.  One of these changes involved the tricky logic that tries
    to avoid rescanning QHs that have already been seen when the scanning
    loop is restarted, which happens whenever an URB is given back.
    Switching back to clock-based unlinks would make this logic even more
    complicated.
    
    Therefore the new code doesn't rescan the entire async list whenever a
    giveback occurs.  Instead it rescans only the current QH and continues
    on from there.  This requires the use of a separate pointer to keep
    track of the next QH to scan, since the current QH may be unlinked
    while the scanning is in progress.  That new pointer must be global,
    so that it can be adjusted forward whenever the _next_ QH gets
    unlinked.  (uhci-hcd uses this same trick.)
    
    Simplification of the scanning loop removes a level of indentation,
    which accounts for the size of the patch.  The amount of code changed
    is relatively small, and it isn't exactly a reversion of the
    b963801164 commit.
    
    This fixes Bugzilla #32432.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@kernel.org&gt;
    Tested-by: Matej Kenda &lt;matejken@gmail.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 4ee62bef3723..2902199fa8ff 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -90,7 +90,8 @@ static const char	hcd_name [] = "ehci_hcd";
 #define EHCI_IAA_MSECS		10		/* arbitrary */
 #define EHCI_IO_JIFFIES		(HZ/10)		/* io watchdog &gt; irq_thresh */
 #define EHCI_ASYNC_JIFFIES	(HZ/20)		/* async idle timeout */
-#define EHCI_SHRINK_FRAMES	5		/* async qh unlink delay */
+#define EHCI_SHRINK_JIFFIES	(DIV_ROUND_UP(HZ, 200) + 1)
+						/* 200-ms async qh unlink delay */
 
 /* Initial IRQ latency:  faster than hw default */
 static int log2_irq_thresh = 0;		// 0 to 6
@@ -148,10 +149,7 @@ timer_action(struct ehci_hcd *ehci, enum ehci_timer_action action)
 			break;
 		/* case TIMER_ASYNC_SHRINK: */
 		default:
-			/* add a jiffie since we synch against the
-			 * 8 KHz uframe counter.
-			 */
-			t = DIV_ROUND_UP(EHCI_SHRINK_FRAMES * HZ, 1000) + 1;
+			t = EHCI_SHRINK_JIFFIES;
 			break;
 		}
 		mod_timer(&amp;ehci-&gt;watchdog, t + jiffies);
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 5d6bc624c961..9bf3c0d983c4 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -1231,6 +1231,8 @@ static void start_unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 
 	prev-&gt;hw-&gt;hw_next = qh-&gt;hw-&gt;hw_next;
 	prev-&gt;qh_next = qh-&gt;qh_next;
+	if (ehci-&gt;qh_scan_next == qh)
+		ehci-&gt;qh_scan_next = qh-&gt;qh_next.qh;
 	wmb ();
 
 	/* If the controller isn't running, we don't have to wait for it */
@@ -1256,53 +1258,49 @@ static void scan_async (struct ehci_hcd *ehci)
 	struct ehci_qh		*qh;
 	enum ehci_timer_action	action = TIMER_IO_WATCHDOG;
 
-	ehci-&gt;stamp = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;frame_index);
 	timer_action_done (ehci, TIMER_ASYNC_SHRINK);
-rescan:
 	stopped = !HC_IS_RUNNING(ehci_to_hcd(ehci)-&gt;state);
-	qh = ehci-&gt;async-&gt;qh_next.qh;
-	if (likely (qh != NULL)) {
-		do {
-			/* clean any finished work for this qh */
-			if (!list_empty(&amp;qh-&gt;qtd_list) &amp;&amp; (stopped ||
-					qh-&gt;stamp != ehci-&gt;stamp)) {
-				int temp;
-
-				/* unlinks could happen here; completion
-				 * reporting drops the lock.  rescan using
-				 * the latest schedule, but don't rescan
-				 * qhs we already finished (no looping)
-				 * unless the controller is stopped.
-				 */
-				qh = qh_get (qh);
-				qh-&gt;stamp = ehci-&gt;stamp;
-				temp = qh_completions (ehci, qh);
-				if (qh-&gt;needs_rescan)
-					unlink_async(ehci, qh);
-				qh_put (qh);
-				if (temp != 0) {
-					goto rescan;
-				}
-			}
 
-			/* unlink idle entries, reducing DMA usage as well
-			 * as HCD schedule-scanning costs.  delay for any qh
-			 * we just scanned, there's a not-unusual case that it
-			 * doesn't stay idle for long.
-			 * (plus, avoids some kind of re-activation race.)
+	ehci-&gt;qh_scan_next = ehci-&gt;async-&gt;qh_next.qh;
+	while (ehci-&gt;qh_scan_next) {
+		qh = ehci-&gt;qh_scan_next;
+		ehci-&gt;qh_scan_next = qh-&gt;qh_next.qh;
+ rescan:
+		/* clean any finished work for this qh */
+		if (!list_empty(&amp;qh-&gt;qtd_list)) {
+			int temp;
+
+			/*
+			 * Unlinks could happen here; completion reporting
+			 * drops the lock.  That's why ehci-&gt;qh_scan_next
+			 * always holds the next qh to scan; if the next qh
+			 * gets unlinked then ehci-&gt;qh_scan_next is adjusted
+			 * in start_unlink_async().
 			 */
-			if (list_empty(&amp;qh-&gt;qtd_list)
-					&amp;&amp; qh-&gt;qh_state == QH_STATE_LINKED) {
-				if (!ehci-&gt;reclaim &amp;&amp; (stopped ||
-					((ehci-&gt;stamp - qh-&gt;stamp) &amp; 0x1fff)
-						&gt;= EHCI_SHRINK_FRAMES * 8))
-					start_unlink_async(ehci, qh);
-				else
-					action = TIMER_ASYNC_SHRINK;
-			}
+			qh = qh_get(qh);
+			temp = qh_completions(ehci, qh);
+			if (qh-&gt;needs_rescan)
+				unlink_async(ehci, qh);
+			qh-&gt;unlink_time = jiffies + EHCI_SHRINK_JIFFIES;
+			qh_put(qh);
+			if (temp != 0)
+				goto rescan;
+		}
 
-			qh = qh-&gt;qh_next.qh;
-		} while (qh);
+		/* unlink idle entries, reducing DMA usage as well
+		 * as HCD schedule-scanning costs.  delay for any qh
+		 * we just scanned, there's a not-unusual case that it
+		 * doesn't stay idle for long.
+		 * (plus, avoids some kind of re-activation race.)
+		 */
+		if (list_empty(&amp;qh-&gt;qtd_list)
+				&amp;&amp; qh-&gt;qh_state == QH_STATE_LINKED) {
+			if (!ehci-&gt;reclaim &amp;&amp; (stopped ||
+					time_after_eq(jiffies, qh-&gt;unlink_time)))
+				start_unlink_async(ehci, qh);
+			else
+				action = TIMER_ASYNC_SHRINK;
+		}
 	}
 	if (action == TIMER_ASYNC_SHRINK)
 		timer_action (ehci, TIMER_ASYNC_SHRINK);
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index fa3129fe1ee0..e4feec3457fb 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -75,6 +75,7 @@ struct ehci_hcd {			/* one per controller */
 	struct ehci_qh		*async;
 	struct ehci_qh		*dummy;		/* For AMD quirk use */
 	struct ehci_qh		*reclaim;
+	struct ehci_qh		*qh_scan_next;
 	unsigned		scanning : 1;
 
 	/* periodic schedule support */
@@ -119,7 +120,6 @@ struct ehci_hcd {			/* one per controller */
 	struct timer_list	iaa_watchdog;
 	struct timer_list	watchdog;
 	unsigned long		actions;
-	unsigned		stamp;
 	unsigned		periodic_stamp;
 	unsigned		random_frame;
 	unsigned long		next_statechange;
@@ -345,6 +345,7 @@ struct ehci_qh {
 	struct ehci_qh		*reclaim;	/* next to reclaim */
 
 	struct ehci_hcd		*ehci;
+	unsigned long		unlink_time;
 
 	/*
 	 * Do NOT use atomic operations for QH refcounting. On some CPUs</pre><hr><pre>commit ca5c485f55d326d9a23e4badd05890148aa53f74
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 6 17:03:45 2011 -0400

    USB: additional regression fix for device removal
    
    Commit e534c5b831c8b8e9f5edee5c8a37753c808b80dc (USB: fix regression
    occurring during device removal) didn't go far enough.  It failed to
    take into account that when a driver claims multiple interfaces, it may
    release them all at the same time.  As a result, some interfaces can
    get released before they are unregistered, and we deadlock trying to
    acquire the bandwidth_mutex that we already own.
    
    This patch (asl478) handles this case by setting the "unregistering"
    flag on all the interfaces before removing any of them.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Tested-by: Éric Piel &lt;eric.piel@tremplin-utc.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index e0719b4ee189..0b5ec234c787 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1147,6 +1147,14 @@ void usb_disable_device(struct usb_device *dev, int skip_ep0)
 	 * any drivers bound to them (a key side effect)
 	 */
 	if (dev-&gt;actconfig) {
+		/*
+		 * FIXME: In order to avoid self-deadlock involving the
+		 * bandwidth_mutex, we have to mark all the interfaces
+		 * before unregistering any of them.
+		 */
+		for (i = 0; i &lt; dev-&gt;actconfig-&gt;desc.bNumInterfaces; i++)
+			dev-&gt;actconfig-&gt;interface[i]-&gt;unregistering = 1;
+
 		for (i = 0; i &lt; dev-&gt;actconfig-&gt;desc.bNumInterfaces; i++) {
 			struct usb_interface	*interface;
 
@@ -1156,7 +1164,6 @@ void usb_disable_device(struct usb_device *dev, int skip_ep0)
 				continue;
 			dev_dbg(&amp;dev-&gt;dev, "unregistering interface %s\n",
 				dev_name(&amp;interface-&gt;dev));
-			interface-&gt;unregistering = 1;
 			remove_intf_ep_devs(interface);
 			device_del(&amp;interface-&gt;dev);
 		}</pre><hr><pre>commit 69c843b45eb3b8f267019e6a05860c9c48337419
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 6 10:52:23 2011 +0200

    PM / Runtime: Prevent runtime_resume from racing with probe
    
    This patch (as1475) adds device_lock() and device_unlock() calls to
    the store methods for the power/control and power/autosuspend_delay_ms
    sysfs attribute files.  We don't want badly timed writes to these
    files to cause runtime_resume callbacks to occur while a driver is
    being probed for a device.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;

diff --git a/drivers/base/power/sysfs.c b/drivers/base/power/sysfs.c
index a9f5b8979611..942d6a7c9ae1 100644
--- a/drivers/base/power/sysfs.c
+++ b/drivers/base/power/sysfs.c
@@ -116,12 +116,14 @@ static ssize_t control_store(struct device * dev, struct device_attribute *attr,
 	cp = memchr(buf, '\n', n);
 	if (cp)
 		len = cp - buf;
+	device_lock(dev);
 	if (len == sizeof ctrl_auto - 1 &amp;&amp; strncmp(buf, ctrl_auto, len) == 0)
 		pm_runtime_allow(dev);
 	else if (len == sizeof ctrl_on - 1 &amp;&amp; strncmp(buf, ctrl_on, len) == 0)
 		pm_runtime_forbid(dev);
 	else
-		return -EINVAL;
+		n = -EINVAL;
+	device_unlock(dev);
 	return n;
 }
 
@@ -205,7 +207,9 @@ static ssize_t autosuspend_delay_ms_store(struct device *dev,
 	if (strict_strtol(buf, 10, &amp;delay) != 0 || delay != (int) delay)
 		return -EINVAL;
 
+	device_lock(dev);
 	pm_runtime_set_autosuspend_delay(dev, delay);
+	device_unlock(dev);
 	return n;
 }
 </pre><hr><pre>commit e534c5b831c8b8e9f5edee5c8a37753c808b80dc
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jul 1 16:43:02 2011 -0400

    USB: fix regression occurring during device removal
    
    This patch (as1476) fixes a regression introduced by
    fccf4e86200b8f5edd9a65da26f150e32ba79808 (USB: Free bandwidth when
    usb_disable_device is called).  usb_disconnect() grabs the
    bandwidth_mutex before calling usb_disable_device(), which calls down
    indirectly to usb_set_interface(), which tries to acquire the
    bandwidth_mutex.
    
    The fix causes usb_set_interface() to return early when it is called
    for an interface that has already been unregistered, which is what
    happens in usb_disable_device().
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Sarah Sharp &lt;sarah.a.sharp@linux.intel.com&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 64c7ab4702df..e0719b4ee189 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1286,6 +1286,8 @@ int usb_set_interface(struct usb_device *dev, int interface, int alternate)
 			interface);
 		return -EINVAL;
 	}
+	if (iface-&gt;unregistering)
+		return -ENODEV;
 
 	alt = usb_altnum_to_altsetting(iface, alternate);
 	if (!alt) {</pre><hr><pre>commit 6d0e0e84f66d32c33511984dd3badd32364b863c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Jun 18 22:42:09 2011 +0200

    PM: Fix async resume following suspend failure
    
    The PM core doesn't handle suspend failures correctly when it comes to
    asynchronously suspended devices.  These devices are moved onto the
    dpm_suspended_list as soon as the corresponding async thread is
    started up, and they remain on the list even if they fail to suspend
    or the sleep transition is cancelled before they get suspended.  As a
    result, when the PM core unwinds the transition, it tries to resume
    the devices even though they were never suspended.
    
    This patch (as1474) fixes the problem by adding a new "is_suspended"
    flag to dev_pm_info.  Devices are resumed only if the flag is set.
    
    [rjw:
     * Moved the dev-&gt;power.is_suspended check into device_resume(),
       because we need to complete dev-&gt;power.completion and clear
       dev-&gt;power.is_prepared too for devices whose
       dev-&gt;power.is_suspended flags are unset.
     * Fixed __device_suspend() to avoid setting dev-&gt;power.is_suspended
       if async_error is different from zero.]
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;
    Cc: stable@kernel.org

diff --git a/drivers/base/power/main.c b/drivers/base/power/main.c
index bf5a59ac1957..06f09bf89cb2 100644
--- a/drivers/base/power/main.c
+++ b/drivers/base/power/main.c
@@ -58,6 +58,7 @@ static int async_error;
 void device_pm_init(struct device *dev)
 {
 	dev-&gt;power.is_prepared = false;
+	dev-&gt;power.is_suspended = false;
 	init_completion(&amp;dev-&gt;power.completion);
 	complete_all(&amp;dev-&gt;power.completion);
 	dev-&gt;power.wakeup = NULL;
@@ -517,6 +518,9 @@ static int device_resume(struct device *dev, pm_message_t state, bool async)
 	 */
 	dev-&gt;power.is_prepared = false;
 
+	if (!dev-&gt;power.is_suspended)
+		goto Unlock;
+
 	if (dev-&gt;pwr_domain) {
 		pm_dev_dbg(dev, state, "power domain ");
 		error = pm_op(dev, &amp;dev-&gt;pwr_domain-&gt;ops, state);
@@ -552,6 +556,9 @@ static int device_resume(struct device *dev, pm_message_t state, bool async)
 	}
 
  End:
+	dev-&gt;power.is_suspended = false;
+
+ Unlock:
 	device_unlock(dev);
 	complete_all(&amp;dev-&gt;power.completion);
 
@@ -839,11 +846,11 @@ static int __device_suspend(struct device *dev, pm_message_t state, bool async)
 	device_lock(dev);
 
 	if (async_error)
-		goto End;
+		goto Unlock;
 
 	if (pm_wakeup_pending()) {
 		async_error = -EBUSY;
-		goto End;
+		goto Unlock;
 	}
 
 	if (dev-&gt;pwr_domain) {
@@ -881,6 +888,9 @@ static int __device_suspend(struct device *dev, pm_message_t state, bool async)
 	}
 
  End:
+	dev-&gt;power.is_suspended = !error;
+
+ Unlock:
 	device_unlock(dev);
 	complete_all(&amp;dev-&gt;power.completion);
 
diff --git a/include/linux/pm.h b/include/linux/pm.h
index cc536bd80984..411e4f4be52b 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -426,6 +426,7 @@ struct dev_pm_info {
 	unsigned int		can_wakeup:1;
 	unsigned int		async_suspend:1;
 	bool			is_prepared:1;	/* Owned by the PM core */
+	bool			is_suspended:1;	/* Ditto */
 	spinlock_t		lock;
 #ifdef CONFIG_PM_SLEEP
 	struct list_head	entry;</pre><hr><pre>commit f76b168b6f117a49d36307053e1acbe30580ea5b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Jun 18 20:22:23 2011 +0200

    PM: Rename dev_pm_info.in_suspend to is_prepared
    
    This patch (as1473) renames the "in_suspend" field in struct
    dev_pm_info to "is_prepared", in preparation for an upcoming change.
    The new name is more descriptive of what the field really means.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;
    Cc: stable@kernel.org

diff --git a/drivers/base/power/main.c b/drivers/base/power/main.c
index aa6320207745..bf5a59ac1957 100644
--- a/drivers/base/power/main.c
+++ b/drivers/base/power/main.c
@@ -57,7 +57,7 @@ static int async_error;
  */
 void device_pm_init(struct device *dev)
 {
-	dev-&gt;power.in_suspend = false;
+	dev-&gt;power.is_prepared = false;
 	init_completion(&amp;dev-&gt;power.completion);
 	complete_all(&amp;dev-&gt;power.completion);
 	dev-&gt;power.wakeup = NULL;
@@ -91,7 +91,7 @@ void device_pm_add(struct device *dev)
 	pr_debug("PM: Adding info for %s:%s\n",
 		 dev-&gt;bus ? dev-&gt;bus-&gt;name : "No Bus", dev_name(dev));
 	mutex_lock(&amp;dpm_list_mtx);
-	if (dev-&gt;parent &amp;&amp; dev-&gt;parent-&gt;power.in_suspend)
+	if (dev-&gt;parent &amp;&amp; dev-&gt;parent-&gt;power.is_prepared)
 		dev_warn(dev, "parent %s should not be sleeping\n",
 			dev_name(dev-&gt;parent));
 	list_add_tail(&amp;dev-&gt;power.entry, &amp;dpm_list);
@@ -511,7 +511,11 @@ static int device_resume(struct device *dev, pm_message_t state, bool async)
 	dpm_wait(dev-&gt;parent, async);
 	device_lock(dev);
 
-	dev-&gt;power.in_suspend = false;
+	/*
+	 * This is a fib.  But we'll allow new children to be added below
+	 * a resumed device, even if the device hasn't been completed yet.
+	 */
+	dev-&gt;power.is_prepared = false;
 
 	if (dev-&gt;pwr_domain) {
 		pm_dev_dbg(dev, state, "power domain ");
@@ -670,7 +674,7 @@ void dpm_complete(pm_message_t state)
 		struct device *dev = to_device(dpm_prepared_list.prev);
 
 		get_device(dev);
-		dev-&gt;power.in_suspend = false;
+		dev-&gt;power.is_prepared = false;
 		list_move(&amp;dev-&gt;power.entry, &amp;list);
 		mutex_unlock(&amp;dpm_list_mtx);
 
@@ -1042,7 +1046,7 @@ int dpm_prepare(pm_message_t state)
 			put_device(dev);
 			break;
 		}
-		dev-&gt;power.in_suspend = true;
+		dev-&gt;power.is_prepared = true;
 		if (!list_empty(&amp;dev-&gt;power.entry))
 			list_move_tail(&amp;dev-&gt;power.entry, &amp;dpm_prepared_list);
 		put_device(dev);
diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index e35a17687c05..aa3cc465a601 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -375,7 +375,7 @@ static int usb_unbind_interface(struct device *dev)
 		 * Just re-enable it without affecting the endpoint toggles.
 		 */
 		usb_enable_interface(udev, intf, false);
-	} else if (!error &amp;&amp; !intf-&gt;dev.power.in_suspend) {
+	} else if (!error &amp;&amp; !intf-&gt;dev.power.is_prepared) {
 		r = usb_set_interface(udev, intf-&gt;altsetting[0].
 				desc.bInterfaceNumber, 0);
 		if (r &lt; 0)
@@ -960,7 +960,7 @@ void usb_rebind_intf(struct usb_interface *intf)
 	}
 
 	/* Try to rebind the interface */
-	if (!intf-&gt;dev.power.in_suspend) {
+	if (!intf-&gt;dev.power.is_prepared) {
 		intf-&gt;needs_binding = 0;
 		rc = device_attach(&amp;intf-&gt;dev);
 		if (rc &lt; 0)
@@ -1107,7 +1107,7 @@ static int usb_resume_interface(struct usb_device *udev,
 	if (intf-&gt;condition == USB_INTERFACE_UNBOUND) {
 
 		/* Carry out a deferred switch to altsetting 0 */
-		if (intf-&gt;needs_altsetting0 &amp;&amp; !intf-&gt;dev.power.in_suspend) {
+		if (intf-&gt;needs_altsetting0 &amp;&amp; !intf-&gt;dev.power.is_prepared) {
 			usb_set_interface(udev, intf-&gt;altsetting[0].
 					desc.bInterfaceNumber, 0);
 			intf-&gt;needs_altsetting0 = 0;
diff --git a/include/linux/device.h b/include/linux/device.h
index c66111affca9..553fd37b173b 100644
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@ -654,13 +654,13 @@ static inline int device_is_registered(struct device *dev)
 
 static inline void device_enable_async_suspend(struct device *dev)
 {
-	if (!dev-&gt;power.in_suspend)
+	if (!dev-&gt;power.is_prepared)
 		dev-&gt;power.async_suspend = true;
 }
 
 static inline void device_disable_async_suspend(struct device *dev)
 {
-	if (!dev-&gt;power.in_suspend)
+	if (!dev-&gt;power.is_prepared)
 		dev-&gt;power.async_suspend = false;
 }
 
diff --git a/include/linux/pm.h b/include/linux/pm.h
index 3160648ccdda..cc536bd80984 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -425,7 +425,7 @@ struct dev_pm_info {
 	pm_message_t		power_state;
 	unsigned int		can_wakeup:1;
 	unsigned int		async_suspend:1;
-	unsigned int		in_suspend:1;	/* Owned by the PM core */
+	bool			is_prepared:1;	/* Owned by the PM core */
 	spinlock_t		lock;
 #ifdef CONFIG_PM_SLEEP
 	struct list_head	entry;</pre><hr><pre>commit 664a51a81f6ba39db30cd7b7de61577ca0b2d20d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jun 15 16:31:37 2011 -0400

    USB: deprecate g_file_storage
    
    This patch (as1471) deprecates the File-backed Storage Driver and
    schedules its replacement for the 3.8 kernel release (about two years
    from now).  Users are advised to switch to the Mass Storage Gadget
    instead.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/Documentation/feature-removal-schedule.txt b/Documentation/feature-removal-schedule.txt
index 1a9446b59153..21f331d0473d 100644
--- a/Documentation/feature-removal-schedule.txt
+++ b/Documentation/feature-removal-schedule.txt
@@ -600,3 +600,10 @@ Why:	Superseded by the UVCIOC_CTRL_QUERY ioctl.
 Who:	Laurent Pinchart &lt;laurent.pinchart@ideasonboard.com&gt;
 
 ----------------------------
+
+What:	g_file_storage driver
+When:	3.8
+Why:	This driver has been superseded by g_mass_storage.
+Who:	Alan Stern &lt;stern@rowland.harvard.edu&gt;
+
+----------------------------
diff --git a/drivers/usb/gadget/Kconfig b/drivers/usb/gadget/Kconfig
index 9468adbe42bb..22e43fffbcc0 100644
--- a/drivers/usb/gadget/Kconfig
+++ b/drivers/usb/gadget/Kconfig
@@ -877,7 +877,7 @@ config USB_FUNCTIONFS_GENERIC
 	  no Ethernet interface.
 
 config USB_FILE_STORAGE
-	tristate "File-backed Storage Gadget"
+	tristate "File-backed Storage Gadget (DEPRECATED)"
 	depends on BLOCK
 	help
 	  The File-backed Storage Gadget acts as a USB Mass Storage
@@ -888,6 +888,9 @@ config USB_FILE_STORAGE
 	  Say "y" to link the driver statically, or "m" to build a
 	  dynamically linked module called "g_file_storage".
 
+	  NOTE: This driver is deprecated.  Its replacement is the
+	  Mass Storage Gadget.
+
 config USB_FILE_STORAGE_TEST
 	bool "File-backed Storage Gadget testing version"
 	depends on USB_FILE_STORAGE
@@ -907,14 +910,11 @@ config USB_MASS_STORAGE
 	  device (in much the same way as the "loop" device driver),
 	  specified as a module parameter or sysfs option.
 
-	  This is heavily based on File-backed Storage Gadget and in most
-	  cases you will want to use FSG instead.  This gadget is mostly
-	  here to test the functionality of the Mass Storage Function
-	  which may be used with composite framework.
+	  This driver is an updated replacement for the deprecated
+	  File-backed Storage Gadget (g_file_storage).
 
 	  Say "y" to link the driver statically, or "m" to build
-	  a dynamically linked module called "g_mass_storage".  If unsure,
-	  consider File-backed Storage Gadget.
+	  a dynamically linked module called "g_mass_storage".
 
 config USB_G_SERIAL
 	tristate "Serial Gadget (with CDC ACM and CDC OBEX support)"
diff --git a/drivers/usb/gadget/file_storage.c b/drivers/usb/gadget/file_storage.c
index 0360f56221ea..83bee30cdb94 100644
--- a/drivers/usb/gadget/file_storage.c
+++ b/drivers/usb/gadget/file_storage.c
@@ -3486,6 +3486,8 @@ static int __init fsg_bind(struct usb_gadget *gadget)
 	}
 
 	INFO(fsg, DRIVER_DESC ", version: " DRIVER_VERSION "\n");
+	INFO(fsg, "NOTE: This driver is deprecated.  "
+			"Consider using g_mass_storage instead.\n");
 	INFO(fsg, "Number of LUNs=%d\n", fsg-&gt;nluns);
 
 	pathbuf = kmalloc(PATH_MAX, GFP_KERNEL);</pre><hr><pre>commit 0af212ba8f123c2eba151af7726c34a50b127962
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jun 15 16:27:43 2011 -0400

    USB: don't let errors prevent system sleep
    
    This patch (as1464) implements the recommended policy that most errors
    during suspend or hibernation should not prevent the system from going
    to sleep.  In particular, failure to suspend a USB driver or a USB
    device should not prevent the sleep from succeeding:
    
    Failure to suspend a device won't matter, because the device will
    automatically go into suspend mode when the USB bus stops carrying
    packets.  (This might be less true for USB-3.0 devices, but let's not
    worry about them now.)
    
    Failure of a driver to suspend might lead to trouble later on when the
    system wakes up, but it isn't sufficient reason to prevent the system
    from going to sleep.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index e35a17687c05..81add81ab040 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -1187,13 +1187,22 @@ static int usb_suspend_both(struct usb_device *udev, pm_message_t msg)
 		for (i = n - 1; i &gt;= 0; --i) {
 			intf = udev-&gt;actconfig-&gt;interface[i];
 			status = usb_suspend_interface(udev, intf, msg);
+
+			/* Ignore errors during system sleep transitions */
+			if (!(msg.event &amp; PM_EVENT_AUTO))
+				status = 0;
 			if (status != 0)
 				break;
 		}
 	}
-	if (status == 0)
+	if (status == 0) {
 		status = usb_suspend_device(udev, msg);
 
+		/* Again, ignore errors during system sleep transitions */
+		if (!(msg.event &amp; PM_EVENT_AUTO))
+			status = 0;
+	}
+
 	/* If the suspend failed, resume interfaces that did get suspended */
 	if (status != 0) {
 		msg.event ^= (PM_EVENT_SUSPEND | PM_EVENT_RESUME);</pre><hr><pre>commit cbb330045e5df8f665ac60227ff898421fc8fb92
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jun 15 16:29:16 2011 -0400

    USB: don't let the hub driver prevent system sleep
    
    This patch (as1465) continues implementation of the policy that errors
    during suspend or hibernation should not prevent the system from going
    to sleep.
    
    In this case, failure to turn on the Suspend feature for a hub port
    shouldn't be reported as an error.  There are situations where this
    does actually occur (such as when the device plugged into that port
    was disconnected in the recent past), and it turns out to be harmless.
    There's no reason for it to prevent a system sleep.
    
    Also, don't allow the hub driver to fail a system suspend if the
    downstream ports aren't all suspended.  This is also harmless (and
    should never happen, given the change mentioned above); printing a
    warning message in the kernel log is all we really need to do.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 90ae1753dda1..c2ac08755f27 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2362,6 +2362,10 @@ int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
 				USB_DEVICE_REMOTE_WAKEUP, 0,
 				NULL, 0,
 				USB_CTRL_SET_TIMEOUT);
+
+		/* System sleep transitions should never fail */
+		if (!(msg.event &amp; PM_EVENT_AUTO))
+			status = 0;
 	} else {
 		/* device has up to 10 msec to fully suspend */
 		dev_dbg(&amp;udev-&gt;dev, "usb %ssuspend\n",
@@ -2611,16 +2615,15 @@ static int hub_suspend(struct usb_interface *intf, pm_message_t msg)
 	struct usb_device	*hdev = hub-&gt;hdev;
 	unsigned		port1;
 
-	/* fail if children aren't already suspended */
+	/* Warn if children aren't already suspended */
 	for (port1 = 1; port1 &lt;= hdev-&gt;maxchild; port1++) {
 		struct usb_device	*udev;
 
 		udev = hdev-&gt;children [port1-1];
 		if (udev &amp;&amp; udev-&gt;can_submit) {
-			if (!(msg.event &amp; PM_EVENT_AUTO))
-				dev_dbg(&amp;intf-&gt;dev, "port %d nyet suspended\n",
-						port1);
-			return -EBUSY;
+			dev_warn(&amp;intf-&gt;dev, "port %d nyet suspended\n", port1);
+			if (msg.event &amp; PM_EVENT_AUTO)
+				return -EBUSY;
 		}
 	}
 </pre><hr><pre>commit 578333ab95f70db13951d30a9ad6b565b61639a9
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jun 15 16:32:46 2011 -0400

    USB: change maintainership of ohci-hcd and ehci-hcd
    
    Following the loss of David Brownell, I volunteer to maintain the
    ohci-hcd and ehci-hcd drivers.  This patch (as1472) makes it official.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/MAINTAINERS b/MAINTAINERS
index e50fc6eb99e0..4307673415f7 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -6430,8 +6430,9 @@ S:	Maintained
 F:	drivers/usb/misc/rio500*
 
 USB EHCI DRIVER
+M:	Alan Stern &lt;stern@rowland.harvard.edu&gt;
 L:	linux-usb@vger.kernel.org
-S:	Orphan
+S:	Maintained
 F:	Documentation/usb/ehci.txt
 F:	drivers/usb/host/ehci*
 
@@ -6490,8 +6491,9 @@ S:	Maintained
 F:	sound/usb/midi.*
 
 USB OHCI DRIVER
+M:	Alan Stern &lt;stern@rowland.harvard.edu&gt;
 L:	linux-usb@vger.kernel.org
-S:	Orphan
+S:	Maintained
 F:	Documentation/usb/ohci.txt
 F:	drivers/usb/host/ohci*
 
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index b435ed67dd5c..f8030ee928e8 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1,4 +1,8 @@
 /*
+ * Enhanced Host Controller Interface (EHCI) driver for USB.
+ *
+ * Maintainer: Alan Stern &lt;stern@rowland.harvard.edu&gt;
+ *
  * Copyright (c) 2000-2004 by David Brownell
  *
  * This program is free software; you can redistribute it and/or modify it
diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index 9aa10bdf3918..f9cf3f04b742 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -1,5 +1,7 @@
 /*
- * OHCI HCD (Host Controller Driver) for USB.
+ * Open Host Controller Interface (OHCI) driver for USB.
+ *
+ * Maintainer: Alan Stern &lt;stern@rowland.harvard.edu&gt;
  *
  * (C) Copyright 1999 Roman Weissgaerber &lt;weissg@vienna.at&gt;
  * (C) Copyright 2000-2004 David Brownell &lt;dbrownell@users.sourceforge.net&gt;</pre>
    <div class="pagination">
        <a href='2_55.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><span>[56]</span><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_57.html'>Next&gt;&gt;</a>
    <div>
</body>
