<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Zhejiang University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Zhejiang University</h1>
    <div class="pagination">
        <a href='6_18.html'>&lt;&lt;Prev</a><a href='6.html'>1</a><a href='6_2.html'>2</a><a href='6_3.html'>3</a><a href='6_4.html'>4</a><a href='6_5.html'>5</a><a href='6_6.html'>6</a><a href='6_7.html'>7</a><a href='6_8.html'>8</a><a href='6_9.html'>9</a><a href='6_10.html'>10</a><a href='6_11.html'>11</a><a href='6_12.html'>12</a><a href='6_13.html'>13</a><a href='6_14.html'>14</a><a href='6_15.html'>15</a><a href='6_16.html'>16</a><a href='6_17.html'>17</a><a href='6_18.html'>18</a><span>[19]</span><a href='6_20.html'>20</a><a href='6_21.html'>21</a><a href='6_22.html'>22</a><a href='6_23.html'>23</a><a href='6_24.html'>24</a><a href='6_25.html'>25</a><a href='6_26.html'>26</a><a href='6_27.html'>27</a><a href='6_28.html'>28</a><a href='6_29.html'>29</a><a href='6_30.html'>30</a><a href='6_31.html'>31</a><a href='6_32.html'>32</a><a href='6_33.html'>33</a><a href='6_34.html'>34</a><a href='6_20.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit d01ffb9eee4af165d83b08dd73ebdf9fe94a519b
Author: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
Date:   Fri Jan 28 12:47:16 2022 +0800

    ax25: add refcount in ax25_dev to avoid UAF bugs
    
    If we dereference ax25_dev after we call kfree(ax25_dev) in
    ax25_dev_device_down(), it will lead to concurrency UAF bugs.
    There are eight syscall functions suffer from UAF bugs, include
    ax25_bind(), ax25_release(), ax25_connect(), ax25_ioctl(),
    ax25_getname(), ax25_sendmsg(), ax25_getsockopt() and
    ax25_info_show().
    
    One of the concurrency UAF can be shown as below:
    
      (USE)                       |    (FREE)
                                  |  ax25_device_event
                                  |    ax25_dev_device_down
    ax25_bind                     |    ...
      ...                         |      kfree(ax25_dev)
      ax25_fillin_cb()            |    ...
        ax25_fillin_cb_from_dev() |
      ...                         |
    
    The root cause of UAF bugs is that kfree(ax25_dev) in
    ax25_dev_device_down() is not protected by any locks.
    When ax25_dev, which there are still pointers point to,
    is released, the concurrency UAF bug will happen.
    
    This patch introduces refcount into ax25_dev in order to
    guarantee that there are no pointers point to it when ax25_dev
    is released.
    
    Signed-off-by: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/include/net/ax25.h b/include/net/ax25.h
index 526e49589197..50b417df6221 100644
--- a/include/net/ax25.h
+++ b/include/net/ax25.h
@@ -239,6 +239,7 @@ typedef struct ax25_dev {
 #if defined(CONFIG_AX25_DAMA_SLAVE) || defined(CONFIG_AX25_DAMA_MASTER)
 	ax25_dama_info		dama;
 #endif
+	refcount_t		refcount;
 } ax25_dev;
 
 typedef struct ax25_cb {
@@ -293,6 +294,15 @@ static __inline__ void ax25_cb_put(ax25_cb *ax25)
 	}
 }
 
+#define ax25_dev_hold(__ax25_dev) \
+	refcount_inc(&amp;((__ax25_dev)-&gt;refcount))
+
+static __inline__ void ax25_dev_put(ax25_dev *ax25_dev)
+{
+	if (refcount_dec_and_test(&amp;ax25_dev-&gt;refcount)) {
+		kfree(ax25_dev);
+	}
+}
 static inline __be16 ax25_type_trans(struct sk_buff *skb, struct net_device *dev)
 {
 	skb-&gt;dev      = dev;
diff --git a/net/ax25/af_ax25.c b/net/ax25/af_ax25.c
index 44a8730c26ac..32f61978ff29 100644
--- a/net/ax25/af_ax25.c
+++ b/net/ax25/af_ax25.c
@@ -91,6 +91,7 @@ static void ax25_kill_by_device(struct net_device *dev)
 			spin_unlock_bh(&amp;ax25_list_lock);
 			lock_sock(sk);
 			s-&gt;ax25_dev = NULL;
+			ax25_dev_put(ax25_dev);
 			release_sock(sk);
 			ax25_disconnect(s, ENETUNREACH);
 			spin_lock_bh(&amp;ax25_list_lock);
@@ -439,6 +440,7 @@ static int ax25_ctl_ioctl(const unsigned int cmd, void __user *arg)
 	  }
 
 out_put:
+	ax25_dev_put(ax25_dev);
 	ax25_cb_put(ax25);
 	return ret;
 
diff --git a/net/ax25/ax25_dev.c b/net/ax25/ax25_dev.c
index 256fadb94df3..770b787fb7bb 100644
--- a/net/ax25/ax25_dev.c
+++ b/net/ax25/ax25_dev.c
@@ -37,6 +37,7 @@ ax25_dev *ax25_addr_ax25dev(ax25_address *addr)
 	for (ax25_dev = ax25_dev_list; ax25_dev != NULL; ax25_dev = ax25_dev-&gt;next)
 		if (ax25cmp(addr, (const ax25_address *)ax25_dev-&gt;dev-&gt;dev_addr) == 0) {
 			res = ax25_dev;
+			ax25_dev_hold(ax25_dev);
 		}
 	spin_unlock_bh(&amp;ax25_dev_lock);
 
@@ -56,6 +57,7 @@ void ax25_dev_device_up(struct net_device *dev)
 		return;
 	}
 
+	refcount_set(&amp;ax25_dev-&gt;refcount, 1);
 	dev-&gt;ax25_ptr     = ax25_dev;
 	ax25_dev-&gt;dev     = dev;
 	dev_hold_track(dev, &amp;ax25_dev-&gt;dev_tracker, GFP_ATOMIC);
@@ -83,6 +85,7 @@ void ax25_dev_device_up(struct net_device *dev)
 	spin_lock_bh(&amp;ax25_dev_lock);
 	ax25_dev-&gt;next = ax25_dev_list;
 	ax25_dev_list  = ax25_dev;
+	ax25_dev_hold(ax25_dev);
 	spin_unlock_bh(&amp;ax25_dev_lock);
 
 	ax25_register_dev_sysctl(ax25_dev);
@@ -112,20 +115,22 @@ void ax25_dev_device_down(struct net_device *dev)
 
 	if ((s = ax25_dev_list) == ax25_dev) {
 		ax25_dev_list = s-&gt;next;
+		ax25_dev_put(ax25_dev);
 		spin_unlock_bh(&amp;ax25_dev_lock);
 		dev-&gt;ax25_ptr = NULL;
 		dev_put_track(dev, &amp;ax25_dev-&gt;dev_tracker);
-		kfree(ax25_dev);
+		ax25_dev_put(ax25_dev);
 		return;
 	}
 
 	while (s != NULL &amp;&amp; s-&gt;next != NULL) {
 		if (s-&gt;next == ax25_dev) {
 			s-&gt;next = ax25_dev-&gt;next;
+			ax25_dev_put(ax25_dev);
 			spin_unlock_bh(&amp;ax25_dev_lock);
 			dev-&gt;ax25_ptr = NULL;
 			dev_put_track(dev, &amp;ax25_dev-&gt;dev_tracker);
-			kfree(ax25_dev);
+			ax25_dev_put(ax25_dev);
 			return;
 		}
 
@@ -133,6 +138,7 @@ void ax25_dev_device_down(struct net_device *dev)
 	}
 	spin_unlock_bh(&amp;ax25_dev_lock);
 	dev-&gt;ax25_ptr = NULL;
+	ax25_dev_put(ax25_dev);
 }
 
 int ax25_fwd_ioctl(unsigned int cmd, struct ax25_fwd_struct *fwd)
@@ -149,6 +155,7 @@ int ax25_fwd_ioctl(unsigned int cmd, struct ax25_fwd_struct *fwd)
 		if (ax25_dev-&gt;forward != NULL)
 			return -EINVAL;
 		ax25_dev-&gt;forward = fwd_dev-&gt;dev;
+		ax25_dev_put(fwd_dev);
 		break;
 
 	case SIOCAX25DELFWD:
@@ -161,6 +168,7 @@ int ax25_fwd_ioctl(unsigned int cmd, struct ax25_fwd_struct *fwd)
 		return -EINVAL;
 	}
 
+	ax25_dev_put(ax25_dev);
 	return 0;
 }
 
diff --git a/net/ax25/ax25_route.c b/net/ax25/ax25_route.c
index d0b2e094bd55..1e32693833e5 100644
--- a/net/ax25/ax25_route.c
+++ b/net/ax25/ax25_route.c
@@ -116,6 +116,7 @@ static int __must_check ax25_rt_add(struct ax25_routes_struct *route)
 	ax25_rt-&gt;dev          = ax25_dev-&gt;dev;
 	ax25_rt-&gt;digipeat     = NULL;
 	ax25_rt-&gt;ip_mode      = ' ';
+	ax25_dev_put(ax25_dev);
 	if (route-&gt;digi_count != 0) {
 		if ((ax25_rt-&gt;digipeat = kmalloc(sizeof(ax25_digi), GFP_ATOMIC)) == NULL) {
 			write_unlock_bh(&amp;ax25_route_lock);
@@ -172,6 +173,7 @@ static int ax25_rt_del(struct ax25_routes_struct *route)
 			}
 		}
 	}
+	ax25_dev_put(ax25_dev);
 	write_unlock_bh(&amp;ax25_route_lock);
 
 	return 0;
@@ -214,6 +216,7 @@ static int ax25_rt_opt(struct ax25_route_opt_struct *rt_option)
 	}
 
 out:
+	ax25_dev_put(ax25_dev);
 	write_unlock_bh(&amp;ax25_route_lock);
 	return err;
 }</pre><hr><pre>commit 4e0f718daf97d47cf7dec122da1be970f145c809
Author: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
Date:   Fri Jan 28 12:47:15 2022 +0800

    ax25: improve the incomplete fix to avoid UAF and NPD bugs
    
    The previous commit 1ade48d0c27d ("ax25: NPD bug when detaching
    AX25 device") introduce lock_sock() into ax25_kill_by_device to
    prevent NPD bug. But the concurrency NPD or UAF bug will occur,
    when lock_sock() or release_sock() dereferences the ax25_cb-&gt;sock.
    
    The NULL pointer dereference bug can be shown as below:
    
    ax25_kill_by_device()        | ax25_release()
                                 |   ax25_destroy_socket()
                                 |     ax25_cb_del()
      ...                        |     ...
                                 |     ax25-&gt;sk=NULL;
      lock_sock(s-&gt;sk); //(1)    |
      s-&gt;ax25_dev = NULL;        |     ...
      release_sock(s-&gt;sk); //(2) |
      ...                        |
    
    The root cause is that the sock is set to null before dereference
    site (1) or (2). Therefore, this patch extracts the ax25_cb-&gt;sock
    in advance, and uses ax25_list_lock to protect it, which can synchronize
    with ax25_cb_del() and ensure the value of sock is not null before
    dereference sites.
    
    The concurrency UAF bug can be shown as below:
    
    ax25_kill_by_device()        | ax25_release()
                                 |   ax25_destroy_socket()
      ...                        |   ...
                                 |   sock_put(sk); //FREE
      lock_sock(s-&gt;sk); //(1)    |
      s-&gt;ax25_dev = NULL;        |   ...
      release_sock(s-&gt;sk); //(2) |
      ...                        |
    
    The root cause is that the sock is released before dereference
    site (1) or (2). Therefore, this patch uses sock_hold() to increase
    the refcount of sock and uses ax25_list_lock to protect it, which
    can synchronize with ax25_cb_del() in ax25_destroy_socket() and
    ensure the sock wil not be released before dereference sites.
    
    Signed-off-by: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/net/ax25/af_ax25.c b/net/ax25/af_ax25.c
index 02f43f3e2c56..44a8730c26ac 100644
--- a/net/ax25/af_ax25.c
+++ b/net/ax25/af_ax25.c
@@ -77,6 +77,7 @@ static void ax25_kill_by_device(struct net_device *dev)
 {
 	ax25_dev *ax25_dev;
 	ax25_cb *s;
+	struct sock *sk;
 
 	if ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)
 		return;
@@ -85,13 +86,15 @@ static void ax25_kill_by_device(struct net_device *dev)
 again:
 	ax25_for_each(s, &amp;ax25_list) {
 		if (s-&gt;ax25_dev == ax25_dev) {
+			sk = s-&gt;sk;
+			sock_hold(sk);
 			spin_unlock_bh(&amp;ax25_list_lock);
-			lock_sock(s-&gt;sk);
+			lock_sock(sk);
 			s-&gt;ax25_dev = NULL;
-			release_sock(s-&gt;sk);
+			release_sock(sk);
 			ax25_disconnect(s, ENETUNREACH);
 			spin_lock_bh(&amp;ax25_list_lock);
-
+			sock_put(sk);
 			/* The entry could have been deleted from the
 			 * list meanwhile and thus the next pointer is
 			 * no longer valid.  Play it safe and restart</pre><hr><pre>commit 1ade48d0c27d5da1ccf4b583d8c5fc8b534a3ac8
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Fri Dec 17 10:29:41 2021 +0800

    ax25: NPD bug when detaching AX25 device
    
    The existing cleanup routine implementation is not well synchronized
    with the syscall routine. When a device is detaching, below race could
    occur.
    
    static int ax25_sendmsg(...) {
      ...
      lock_sock()
      ax25 = sk_to_ax25(sk);
      if (ax25-&gt;ax25_dev == NULL) // CHECK
      ...
      ax25_queue_xmit(skb, ax25-&gt;ax25_dev-&gt;dev); // USE
      ...
    }
    
    static void ax25_kill_by_device(...) {
      ...
      if (s-&gt;ax25_dev == ax25_dev) {
        s-&gt;ax25_dev = NULL;
        ...
    }
    
    Other syscall functions like ax25_getsockopt, ax25_getname,
    ax25_info_show also suffer from similar races. To fix them, this patch
    introduce lock_sock() into ax25_kill_by_device in order to guarantee
    that the nullify action in cleanup routine cannot proceed when another
    socket request is pending.
    
    Signed-off-by: Hanjie Wu &lt;nagi@zju.edu.cn&gt;
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/net/ax25/af_ax25.c b/net/ax25/af_ax25.c
index 2f34bbdde0e8..cfca99e295b8 100644
--- a/net/ax25/af_ax25.c
+++ b/net/ax25/af_ax25.c
@@ -85,8 +85,10 @@ static void ax25_kill_by_device(struct net_device *dev)
 again:
 	ax25_for_each(s, &amp;ax25_list) {
 		if (s-&gt;ax25_dev == ax25_dev) {
-			s-&gt;ax25_dev = NULL;
 			spin_unlock_bh(&amp;ax25_list_lock);
+			lock_sock(s-&gt;sk);
+			s-&gt;ax25_dev = NULL;
+			release_sock(s-&gt;sk);
 			ax25_disconnect(s, ENETUNREACH);
 			spin_lock_bh(&amp;ax25_list_lock);
 </pre><hr><pre>commit b2f37aead1b82a770c48b5d583f35ec22aabb61e
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Fri Dec 17 10:13:56 2021 +0800

    hamradio: improve the incomplete fix to avoid NPD
    
    The previous commit 3e0588c291d6 ("hamradio: defer ax25 kfree after
    unregister_netdev") reorder the kfree operations and unregister_netdev
    operation to prevent UAF.
    
    This commit improves the previous one by also deferring the nullify of
    the ax-&gt;tty pointer. Otherwise, a NULL pointer dereference bug occurs.
    Partial of the stack trace is shown below.
    
    BUG: kernel NULL pointer dereference, address: 0000000000000538
    RIP: 0010:ax_xmit+0x1f9/0x400
    ...
    Call Trace:
     dev_hard_start_xmit+0xec/0x320
     sch_direct_xmit+0xea/0x240
     __qdisc_run+0x166/0x5c0
     __dev_queue_xmit+0x2c7/0xaf0
     ax25_std_establish_data_link+0x59/0x60
     ax25_connect+0x3a0/0x500
     ? security_socket_connect+0x2b/0x40
     __sys_connect+0x96/0xc0
     ? __hrtimer_init+0xc0/0xc0
     ? common_nsleep+0x2e/0x50
     ? switch_fpu_return+0x139/0x1a0
     __x64_sys_connect+0x11/0x20
     do_syscall_64+0x33/0x40
     entry_SYSCALL_64_after_hwframe+0x44/0xa9
    
    The crash point is shown as below
    
    static void ax_encaps(...) {
      ...
      set_bit(TTY_DO_WRITE_WAKEUP, &amp;ax-&gt;tty-&gt;flags); // ax-&gt;tty = NULL!
      ...
    }
    
    By placing the nullify action after the unregister_netdev, the ax-&gt;tty
    pointer won't be assigned as NULL net_device framework layer is well
    synchronized.
    
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/drivers/net/hamradio/mkiss.c b/drivers/net/hamradio/mkiss.c
index 7da2bb8a443c..edde9c3ae12b 100644
--- a/drivers/net/hamradio/mkiss.c
+++ b/drivers/net/hamradio/mkiss.c
@@ -794,14 +794,14 @@ static void mkiss_close(struct tty_struct *tty)
 	 */
 	netif_stop_queue(ax-&gt;dev);
 
-	ax-&gt;tty = NULL;
-
 	unregister_netdev(ax-&gt;dev);
 
 	/* Free all AX25 frame buffers after unreg. */
 	kfree(ax-&gt;rbuff);
 	kfree(ax-&gt;xbuff);
 
+	ax-&gt;tty = NULL;
+
 	free_netdev(ax-&gt;dev);
 }
 </pre><hr><pre>commit 48b71a9e66c2eab60564b1b1c85f4928ed04e406
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Tue Nov 16 23:27:32 2021 +0800

    NFC: add NCI_UNREG flag to eliminate the race
    
    There are two sites that calls queue_work() after the
    destroy_workqueue() and lead to possible UAF.
    
    The first site is nci_send_cmd(), which can happen after the
    nci_close_device as below
    
    nfcmrvl_nci_unregister_dev   |  nfc_genl_dev_up
      nci_close_device           |
        flush_workqueue          |
        del_timer_sync           |
      nci_unregister_device      |    nfc_get_device
        destroy_workqueue        |    nfc_dev_up
        nfc_unregister_device    |      nci_dev_up
          device_del             |        nci_open_device
                                 |          __nci_request
                                 |            nci_send_cmd
                                 |              queue_work !!!
    
    Another site is nci_cmd_timer, awaked by the nci_cmd_work from the
    nci_send_cmd.
    
      ...                        |  ...
      nci_unregister_device      |  queue_work
        destroy_workqueue        |
        nfc_unregister_device    |  ...
          device_del             |  nci_cmd_work
                                 |  mod_timer
                                 |  ...
                                 |  nci_cmd_timer
                                 |    queue_work !!!
    
    For the above two UAF, the root cause is that the nfc_dev_up can race
    between the nci_unregister_device routine. Therefore, this patch
    introduce NCI_UNREG flag to easily eliminate the possible race. In
    addition, the mutex_lock in nci_close_device can act as a barrier.
    
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Fixes: 6a2968aaf50c ("NFC: basic NCI protocol implementation")
    Reviewed-by: Jakub Kicinski &lt;kuba@kernel.org&gt;
    Reviewed-by: Krzysztof Kozlowski &lt;krzysztof.kozlowski@canonical.com&gt;
    Link: https://lore.kernel.org/r/20211116152732.19238-1-linma@zju.edu.cn
    Signed-off-by: Jakub Kicinski &lt;kuba@kernel.org&gt;

diff --git a/include/net/nfc/nci_core.h b/include/net/nfc/nci_core.h
index a964daedc17b..ea8595651c38 100644
--- a/include/net/nfc/nci_core.h
+++ b/include/net/nfc/nci_core.h
@@ -30,6 +30,7 @@ enum nci_flag {
 	NCI_UP,
 	NCI_DATA_EXCHANGE,
 	NCI_DATA_EXCHANGE_TO,
+	NCI_UNREG,
 };
 
 /* NCI device states */
diff --git a/net/nfc/nci/core.c b/net/nfc/nci/core.c
index 1dd0269c1a72..d2537383a3e8 100644
--- a/net/nfc/nci/core.c
+++ b/net/nfc/nci/core.c
@@ -476,6 +476,11 @@ static int nci_open_device(struct nci_dev *ndev)
 
 	mutex_lock(&amp;ndev-&gt;req_lock);
 
+	if (test_bit(NCI_UNREG, &amp;ndev-&gt;flags)) {
+		rc = -ENODEV;
+		goto done;
+	}
+
 	if (test_bit(NCI_UP, &amp;ndev-&gt;flags)) {
 		rc = -EALREADY;
 		goto done;
@@ -548,6 +553,10 @@ static int nci_open_device(struct nci_dev *ndev)
 static int nci_close_device(struct nci_dev *ndev)
 {
 	nci_req_cancel(ndev, ENODEV);
+
+	/* This mutex needs to be held as a barrier for
+	 * caller nci_unregister_device
+	 */
 	mutex_lock(&amp;ndev-&gt;req_lock);
 
 	if (!test_and_clear_bit(NCI_UP, &amp;ndev-&gt;flags)) {
@@ -585,8 +594,8 @@ static int nci_close_device(struct nci_dev *ndev)
 
 	del_timer_sync(&amp;ndev-&gt;cmd_timer);
 
-	/* Clear flags */
-	ndev-&gt;flags = 0;
+	/* Clear flags except NCI_UNREG */
+	ndev-&gt;flags &amp;= BIT(NCI_UNREG);
 
 	mutex_unlock(&amp;ndev-&gt;req_lock);
 
@@ -1269,6 +1278,12 @@ void nci_unregister_device(struct nci_dev *ndev)
 {
 	struct nci_conn_info *conn_info, *n;
 
+	/* This set_bit is not protected with specialized barrier,
+	 * However, it is fine because the mutex_lock(&amp;ndev-&gt;req_lock);
+	 * in nci_close_device() will help to emit one.
+	 */
+	set_bit(NCI_UNREG, &amp;ndev-&gt;flags);
+
 	nci_close_device(ndev);
 
 	destroy_workqueue(ndev-&gt;cmd_wq);</pre><hr><pre>commit 3e3b5dfcd16a3e254aab61bd1e8c417dd4503102
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Tue Nov 16 23:26:52 2021 +0800

    NFC: reorder the logic in nfc_{un,}register_device
    
    There is a potential UAF between the unregistration routine and the NFC
    netlink operations.
    
    The race that cause that UAF can be shown as below:
    
     (FREE)                      |  (USE)
    nfcmrvl_nci_unregister_dev   |  nfc_genl_dev_up
      nci_close_device           |
      nci_unregister_device      |    nfc_get_device
        nfc_unregister_device    |    nfc_dev_up
          rfkill_destory         |
          device_del             |      rfkill_blocked
      ...                        |    ...
    
    The root cause for this race is concluded below:
    1. The rfkill_blocked (USE) in nfc_dev_up is supposed to be placed after
    the device_is_registered check.
    2. Since the netlink operations are possible just after the device_add
    in nfc_register_device, the nfc_dev_up() can happen anywhere during the
    rfkill creation process, which leads to data race.
    
    This patch reorder these actions to permit
    1. Once device_del is finished, the nfc_dev_up cannot dereference the
    rfkill object.
    2. The rfkill_register need to be placed after the device_add of nfc_dev
    because the parent device need to be created first. So this patch keeps
    the order but inject device_lock to prevent the data race.
    
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Fixes: be055b2f89b5 ("NFC: RFKILL support")
    Reviewed-by: Jakub Kicinski &lt;kuba@kernel.org&gt;
    Reviewed-by: Krzysztof Kozlowski &lt;krzysztof.kozlowski@canonical.com&gt;
    Link: https://lore.kernel.org/r/20211116152652.19217-1-linma@zju.edu.cn
    Signed-off-by: Jakub Kicinski &lt;kuba@kernel.org&gt;

diff --git a/net/nfc/core.c b/net/nfc/core.c
index 3c645c1d99c9..dc7a2404efdf 100644
--- a/net/nfc/core.c
+++ b/net/nfc/core.c
@@ -94,13 +94,13 @@ int nfc_dev_up(struct nfc_dev *dev)
 
 	device_lock(&amp;dev-&gt;dev);
 
-	if (dev-&gt;rfkill &amp;&amp; rfkill_blocked(dev-&gt;rfkill)) {
-		rc = -ERFKILL;
+	if (!device_is_registered(&amp;dev-&gt;dev)) {
+		rc = -ENODEV;
 		goto error;
 	}
 
-	if (!device_is_registered(&amp;dev-&gt;dev)) {
-		rc = -ENODEV;
+	if (dev-&gt;rfkill &amp;&amp; rfkill_blocked(dev-&gt;rfkill)) {
+		rc = -ERFKILL;
 		goto error;
 	}
 
@@ -1125,11 +1125,7 @@ int nfc_register_device(struct nfc_dev *dev)
 	if (rc)
 		pr_err("Could not register llcp device\n");
 
-	rc = nfc_genl_device_added(dev);
-	if (rc)
-		pr_debug("The userspace won't be notified that the device %s was added\n",
-			 dev_name(&amp;dev-&gt;dev));
-
+	device_lock(&amp;dev-&gt;dev);
 	dev-&gt;rfkill = rfkill_alloc(dev_name(&amp;dev-&gt;dev), &amp;dev-&gt;dev,
 				   RFKILL_TYPE_NFC, &amp;nfc_rfkill_ops, dev);
 	if (dev-&gt;rfkill) {
@@ -1138,6 +1134,12 @@ int nfc_register_device(struct nfc_dev *dev)
 			dev-&gt;rfkill = NULL;
 		}
 	}
+	device_unlock(&amp;dev-&gt;dev);
+
+	rc = nfc_genl_device_added(dev);
+	if (rc)
+		pr_debug("The userspace won't be notified that the device %s was added\n",
+			 dev_name(&amp;dev-&gt;dev));
 
 	return 0;
 }
@@ -1154,10 +1156,17 @@ void nfc_unregister_device(struct nfc_dev *dev)
 
 	pr_debug("dev_name=%s\n", dev_name(&amp;dev-&gt;dev));
 
+	rc = nfc_genl_device_removed(dev);
+	if (rc)
+		pr_debug("The userspace won't be notified that the device %s "
+			 "was removed\n", dev_name(&amp;dev-&gt;dev));
+
+	device_lock(&amp;dev-&gt;dev);
 	if (dev-&gt;rfkill) {
 		rfkill_unregister(dev-&gt;rfkill);
 		rfkill_destroy(dev-&gt;rfkill);
 	}
+	device_unlock(&amp;dev-&gt;dev);
 
 	if (dev-&gt;ops-&gt;check_presence) {
 		device_lock(&amp;dev-&gt;dev);
@@ -1167,11 +1176,6 @@ void nfc_unregister_device(struct nfc_dev *dev)
 		cancel_work_sync(&amp;dev-&gt;check_pres_work);
 	}
 
-	rc = nfc_genl_device_removed(dev);
-	if (rc)
-		pr_debug("The userspace won't be notified that the device %s "
-			 "was removed\n", dev_name(&amp;dev-&gt;dev));
-
 	nfc_llcp_unregister_device(dev);
 
 	mutex_lock(&amp;nfc_devlist_mutex);</pre><hr><pre>commit 86cdf8e38792545161dbe3350a7eced558ba4d15
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Mon Nov 15 22:56:00 2021 +0800

    NFC: reorganize the functions in nci_request
    
    There is a possible data race as shown below:
    
    thread-A in nci_request()       | thread-B in nci_close_device()
                                    | mutex_lock(&amp;ndev-&gt;req_lock);
    test_bit(NCI_UP, &amp;ndev-&gt;flags); |
    ...                             | test_and_clear_bit(NCI_UP, &amp;ndev-&gt;flags)
    mutex_lock(&amp;ndev-&gt;req_lock);    |
                                    |
    
    This race will allow __nci_request() to be awaked while the device is
    getting removed.
    
    Similar to commit e2cb6b891ad2 ("bluetooth: eliminate the potential race
    condition when removing the HCI controller"). this patch alters the
    function sequence in nci_request() to prevent the data races between the
    nci_close_device().
    
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Fixes: 6a2968aaf50c ("NFC: basic NCI protocol implementation")
    Link: https://lore.kernel.org/r/20211115145600.8320-1-linma@zju.edu.cn
    Signed-off-by: Jakub Kicinski &lt;kuba@kernel.org&gt;

diff --git a/net/nfc/nci/core.c b/net/nfc/nci/core.c
index 6fd873aa86be..1dd0269c1a72 100644
--- a/net/nfc/nci/core.c
+++ b/net/nfc/nci/core.c
@@ -144,12 +144,15 @@ inline int nci_request(struct nci_dev *ndev,
 {
 	int rc;
 
-	if (!test_bit(NCI_UP, &amp;ndev-&gt;flags))
-		return -ENETDOWN;
-
 	/* Serialize all requests */
 	mutex_lock(&amp;ndev-&gt;req_lock);
-	rc = __nci_request(ndev, req, opt, timeout);
+	/* check the state after obtaing the lock against any races
+	 * from nci_close_device when the device gets removed.
+	 */
+	if (test_bit(NCI_UP, &amp;ndev-&gt;flags))
+		rc = __nci_request(ndev, req, opt, timeout);
+	else
+		rc = -ENETDOWN;
 	mutex_unlock(&amp;ndev-&gt;req_lock);
 
 	return rc;</pre><hr><pre>commit 81b1d548d00bcd028303c4f3150fa753b9b8aa71
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Thu Nov 11 22:14:02 2021 +0800

    hamradio: remove needs_free_netdev to avoid UAF
    
    The former patch "defer 6pack kfree after unregister_netdev" reorders
    the kfree of two buffer after the unregister_netdev to prevent the race
    condition. It also adds free_netdev() function in sixpack_close(), which
    is a direct copy from the similar code in mkiss_close().
    
    However, in sixpack driver, the flag needs_free_netdev is set to true in
    sp_setup(), hence the unregister_netdev() will free the netdev
    automatically. Therefore, as the sp is netdev_priv, use-after-free
    occurs.
    
    This patch removes the needs_free_netdev = true and just let the
    free_netdev to finish this deallocation task.
    
    Fixes: 0b9111922b1f ("hamradio: defer 6pack kfree after unregister_netdev")
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Link: https://lore.kernel.org/r/20211111141402.7551-1-linma@zju.edu.cn
    Signed-off-by: Jakub Kicinski &lt;kuba@kernel.org&gt;

diff --git a/drivers/net/hamradio/6pack.c b/drivers/net/hamradio/6pack.c
index bfdf89e54752..8a19a06b505d 100644
--- a/drivers/net/hamradio/6pack.c
+++ b/drivers/net/hamradio/6pack.c
@@ -306,7 +306,6 @@ static void sp_setup(struct net_device *dev)
 {
 	/* Finish setting up the DEVICE info. */
 	dev-&gt;netdev_ops		= &amp;sp_netdev_ops;
-	dev-&gt;needs_free_netdev	= true;
 	dev-&gt;mtu		= SIXP_MTU;
 	dev-&gt;hard_header_len	= AX25_MAX_HEADER_LEN;
 	dev-&gt;header_ops 	= &amp;ax25_header_ops;</pre><hr><pre>commit 0b9111922b1f399aba6ed1e1b8f2079c3da1aed8
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Mon Nov 8 18:37:59 2021 +0800

    hamradio: defer 6pack kfree after unregister_netdev
    
    There is a possible race condition (use-after-free) like below
    
     (USE)                       |  (FREE)
      dev_queue_xmit             |
       __dev_queue_xmit          |
        __dev_xmit_skb           |
         sch_direct_xmit         | ...
          xmit_one               |
           netdev_start_xmit     | tty_ldisc_kill
            __netdev_start_xmit  |  6pack_close
             sp_xmit             |   kfree
              sp_encaps          |
                                 |
    
    According to the patch "defer ax25 kfree after unregister_netdev", this
    patch reorder the kfree after the unregister_netdev to avoid the possible
    UAF as the unregister_netdev() is well synchronized and won't return if
    there is a running routine.
    
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/drivers/net/hamradio/6pack.c b/drivers/net/hamradio/6pack.c
index f4e8793e995d..fb0a3825edd0 100644
--- a/drivers/net/hamradio/6pack.c
+++ b/drivers/net/hamradio/6pack.c
@@ -672,11 +672,13 @@ static void sixpack_close(struct tty_struct *tty)
 	del_timer_sync(&amp;sp-&gt;tx_t);
 	del_timer_sync(&amp;sp-&gt;resync_t);
 
-	/* Free all 6pack frame buffers. */
+	unregister_netdev(sp-&gt;dev);
+
+	/* Free all 6pack frame buffers after unreg. */
 	kfree(sp-&gt;rbuff);
 	kfree(sp-&gt;xbuff);
 
-	unregister_netdev(sp-&gt;dev);
+	free_netdev(sp-&gt;dev);
 }
 
 /* Perform I/O control on an active 6pack channel. */</pre><hr><pre>commit 3e0588c291d6ce225f2b891753ca41d45ba42469
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Mon Nov 8 18:37:21 2021 +0800

    hamradio: defer ax25 kfree after unregister_netdev
    
    There is a possible race condition (use-after-free) like below
    
     (USE)                       |  (FREE)
    ax25_sendmsg                 |
     ax25_queue_xmit             |
      dev_queue_xmit             |
       __dev_queue_xmit          |
        __dev_xmit_skb           |
         sch_direct_xmit         | ...
          xmit_one               |
           netdev_start_xmit     | tty_ldisc_kill
            __netdev_start_xmit  |  mkiss_close
             ax_xmit             |   kfree
              ax_encaps          |
                                 |
    
    Even though there are two synchronization primitives before the kfree:
    1. wait_for_completion(&amp;ax-&gt;dead). This can prevent the race with
    routines from mkiss_ioctl. However, it cannot stop the routine coming
    from upper layer, i.e., the ax25_sendmsg.
    
    2. netif_stop_queue(ax-&gt;dev). It seems that this line of code aims to
    halt the transmit queue but it fails to stop the routine that already
    being xmit.
    
    This patch reorder the kfree after the unregister_netdev to avoid the
    possible UAF as the unregister_netdev() is well synchronized and won't
    return if there is a running routine.
    
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/drivers/net/hamradio/mkiss.c b/drivers/net/hamradio/mkiss.c
index 867252a0247b..e2b332b54f06 100644
--- a/drivers/net/hamradio/mkiss.c
+++ b/drivers/net/hamradio/mkiss.c
@@ -792,13 +792,14 @@ static void mkiss_close(struct tty_struct *tty)
 	 */
 	netif_stop_queue(ax-&gt;dev);
 
-	/* Free all AX25 frame buffers. */
-	kfree(ax-&gt;rbuff);
-	kfree(ax-&gt;xbuff);
-
 	ax-&gt;tty = NULL;
 
 	unregister_netdev(ax-&gt;dev);
+
+	/* Free all AX25 frame buffers after unreg. */
+	kfree(ax-&gt;rbuff);
+	kfree(ax-&gt;xbuff);
+
 	free_netdev(ax-&gt;dev);
 }
 </pre>
    <div class="pagination">
        <a href='6_18.html'>&lt;&lt;Prev</a><a href='6.html'>1</a><a href='6_2.html'>2</a><a href='6_3.html'>3</a><a href='6_4.html'>4</a><a href='6_5.html'>5</a><a href='6_6.html'>6</a><a href='6_7.html'>7</a><a href='6_8.html'>8</a><a href='6_9.html'>9</a><a href='6_10.html'>10</a><a href='6_11.html'>11</a><a href='6_12.html'>12</a><a href='6_13.html'>13</a><a href='6_14.html'>14</a><a href='6_15.html'>15</a><a href='6_16.html'>16</a><a href='6_17.html'>17</a><a href='6_18.html'>18</a><span>[19]</span><a href='6_20.html'>20</a><a href='6_21.html'>21</a><a href='6_22.html'>22</a><a href='6_23.html'>23</a><a href='6_24.html'>24</a><a href='6_25.html'>25</a><a href='6_26.html'>26</a><a href='6_27.html'>27</a><a href='6_28.html'>28</a><a href='6_29.html'>29</a><a href='6_30.html'>30</a><a href='6_31.html'>31</a><a href='6_32.html'>32</a><a href='6_33.html'>33</a><a href='6_34.html'>34</a><a href='6_20.html'>Next&gt;&gt;</a>
    <div>
</body>
