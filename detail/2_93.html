<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_92.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><span>[93]</span><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_94.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 1b7b61c5d4071b9a25f6a9aae6f0a1e0efdbb2ae
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Apr 22 10:50:18 2008 -0400

    USB: OHCI: work around bogus compiler warning
    
    The patch (as1086) works around a bogus "uninitialized variable"
    warning generated by some versions of GCC.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ohci-hub.c b/drivers/usb/host/ohci-hub.c
index 17dc2eccda83..79a78029f896 100644
--- a/drivers/usb/host/ohci-hub.c
+++ b/drivers/usb/host/ohci-hub.c
@@ -613,7 +613,7 @@ static void start_hnp(struct ohci_hcd *ohci);
 static inline int root_port_reset (struct ohci_hcd *ohci, unsigned port)
 {
 	__hc32 __iomem *portstat = &amp;ohci-&gt;regs-&gt;roothub.portstatus [port];
-	u32	temp;
+	u32	temp = 0;
 	u16	now = ohci_readl(ohci, &amp;ohci-&gt;regs-&gt;fmnumber);
 	u16	reset_done = now + PORT_RESET_MSEC;
 	int	limit_1 = DIV_ROUND_UP(PORT_RESET_MSEC, PORT_RESET_HW_MSEC);</pre><hr><pre>commit b28884c1729940df83d87c515a5e66e5afbe9dea
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Apr 28 10:26:13 2008 -0400

    usb-storage: add unusual_devs entry for Samsung YP-U3
    
    This patch (as1088) adds an unusual_devs entry for Samsung's YP-U3.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: Phil Dibowitz &lt;phil@ipom.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index 732bf52a775e..47f6dd7603ef 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -557,6 +557,13 @@ UNUSUAL_DEV(  0x04e6, 0x1010, 0x0000, 0x9999,
 		US_FL_SINGLE_LUN),
 #endif
 
+/* Reported by Dmitry Khlystov &lt;adminimus@gmail.com&gt; */
+UNUSUAL_DEV(  0x04e8, 0x507c, 0x0220, 0x0220,
+		"Samsung",
+		"YP-U3",
+		US_SC_DEVICE, US_PR_DEVICE, NULL,
+		US_FL_MAX_SECTORS_64),
+
 /* Reported by Bob Sass &lt;rls@vectordb.com&gt; -- only rev 1.33 tested */
 UNUSUAL_DEV(  0x050d, 0x0115, 0x0133, 0x0133,
 		"Belkin",</pre><hr><pre>commit 14722ef4acedc643f0b78b7165ceff2d300dae4d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Apr 17 10:18:11 2008 -0400

    USB: usbfs: export the URB_NO_INTERRUPT flag to userspace
    
    This patch (as1079) cleans up the way URB_* flags are exported in
    usbfs.
    
            The URB_NO_INTERRUPT flag is now exported (this is the
            only behavioral change).
    
            USBDEVFS_URB_* macros are added for URB_NO_FSBR,
            URB_ZERO_PACKET, and URB_NO_INTERRUPT, making explicit the
            fact that the kernel accepts them.
    
            The flag matching takes into account that the URB_* values
            may change as the kernel evolves, whereas the USBDEVFS_URB_*
            values must remain fixed since they are a user API.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 039ba23cc8b6..6c4cd82d7d14 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -948,8 +948,11 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 	int ret, ifnum = -1;
 	int is_in;
 
-	if (uurb-&gt;flags &amp; ~(USBDEVFS_URB_ISO_ASAP|USBDEVFS_URB_SHORT_NOT_OK|
-			   URB_NO_FSBR|URB_ZERO_PACKET))
+	if (uurb-&gt;flags &amp; ~(USBDEVFS_URB_ISO_ASAP |
+				USBDEVFS_URB_SHORT_NOT_OK |
+				USBDEVFS_URB_NO_FSBR |
+				USBDEVFS_URB_ZERO_PACKET |
+				USBDEVFS_URB_NO_INTERRUPT))
 		return -EINVAL;
 	if (!uurb-&gt;buffer)
 		return -EINVAL;
@@ -1104,8 +1107,24 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 	as-&gt;urb-&gt;pipe = (uurb-&gt;type &lt;&lt; 30) |
 			__create_pipe(ps-&gt;dev, uurb-&gt;endpoint &amp; 0xf) |
 			(uurb-&gt;endpoint &amp; USB_DIR_IN);
-	as-&gt;urb-&gt;transfer_flags = uurb-&gt;flags |
-			(is_in ? URB_DIR_IN : URB_DIR_OUT);
+
+	/* This tedious sequence is necessary because the URB_* flags
+	 * are internal to the kernel and subject to change, whereas
+	 * the USBDEVFS_URB_* flags are a user API and must not be changed.
+	 */
+	u = (is_in ? URB_DIR_IN : URB_DIR_OUT);
+	if (uurb-&gt;flags &amp; USBDEVFS_URB_ISO_ASAP)
+		u |= URB_ISO_ASAP;
+	if (uurb-&gt;flags &amp; USBDEVFS_URB_SHORT_NOT_OK)
+		u |= URB_SHORT_NOT_OK;
+	if (uurb-&gt;flags &amp; USBDEVFS_URB_NO_FSBR)
+		u |= URB_NO_FSBR;
+	if (uurb-&gt;flags &amp; USBDEVFS_URB_ZERO_PACKET)
+		u |= URB_ZERO_PACKET;
+	if (uurb-&gt;flags &amp; USBDEVFS_URB_NO_INTERRUPT)
+		u |= URB_NO_INTERRUPT;
+	as-&gt;urb-&gt;transfer_flags = u;
+
 	as-&gt;urb-&gt;transfer_buffer_length = uurb-&gt;buffer_length;
 	as-&gt;urb-&gt;setup_packet = (unsigned char *)dr;
 	as-&gt;urb-&gt;start_frame = uurb-&gt;start_frame;
diff --git a/include/linux/usbdevice_fs.h b/include/linux/usbdevice_fs.h
index 17cb108b7db0..3118ede2c67b 100644
--- a/include/linux/usbdevice_fs.h
+++ b/include/linux/usbdevice_fs.h
@@ -77,8 +77,11 @@ struct usbdevfs_connectinfo {
 	unsigned char slow;
 };
 
-#define USBDEVFS_URB_SHORT_NOT_OK          1
-#define USBDEVFS_URB_ISO_ASAP              2
+#define USBDEVFS_URB_SHORT_NOT_OK	0x01
+#define USBDEVFS_URB_ISO_ASAP		0x02
+#define USBDEVFS_URB_NO_FSBR		0x20
+#define USBDEVFS_URB_ZERO_PACKET	0x40
+#define USBDEVFS_URB_NO_INTERRUPT	0x80
 
 #define USBDEVFS_URB_TYPE_ISO		   0
 #define USBDEVFS_URB_TYPE_INTERRUPT	   1</pre><hr><pre>commit aff6d18f95bb81b2d07994372c8edcc2c2b41180
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Apr 18 11:11:26 2008 -0400

    USB: fix compile problems in ehci-hcd
    
    This patch (as1072) fixes some recently-introduced compile problems
    that show up in ehci-hcd when CONFIG_PM is turned off.
    
            PORT_WAKE_BITS needs to be defined always.
    
            ehci_port_power() is called during initialization by all the
            EHCI variants other than the PCI version, in which it is
            "defined but not used".  So add a call to it.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 536b433d24f7..efffef64f59d 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -28,10 +28,10 @@
 
 /*-------------------------------------------------------------------------*/
 
-#ifdef	CONFIG_PM
-
 #define	PORT_WAKE_BITS	(PORT_WKOC_E|PORT_WKDISC_E|PORT_WKCONN_E)
 
+#ifdef	CONFIG_PM
+
 static int ehci_hub_control(
 	struct usb_hcd	*hcd,
 	u16		typeReq,
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 88dad4b53131..5bb7f6bb13f3 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -222,6 +222,7 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		ehci_warn(ehci, "selective suspend/wakeup unavailable\n");
 #endif
 
+	ehci_port_power(ehci, 1);
 	retval = ehci_pci_reinit(ehci, pdev);
 done:
 	return retval;</pre><hr><pre>commit e872154921a6b5256a3c412dd69158ac0b135176
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Apr 14 12:17:56 2008 -0400

    USB: don't explicitly reenable root-hub status interrupts
    
    This patch (as1069b) changes the way OHCI root-hub status-change
    interrupts are enabled.  Currently a special HCD method,
    hub_irq_enable(), is called when the hub driver is finished using a
    root hub.  This approach turns out to be subject to races, resulting
    in unnecessary polling.
    
    The patch does away with the method entirely.  Instead, the driver
    automatically enables the RHSC interrupt when no more status changes
    are present.  This scheme is safe with controllers using
    level-triggered semantics for their interrupt flags.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index e68fef5361d2..bf10e9c4195e 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -924,15 +924,6 @@ static int register_root_hub(struct usb_hcd *hcd)
 	return retval;
 }
 
-void usb_enable_root_hub_irq (struct usb_bus *bus)
-{
-	struct usb_hcd *hcd;
-
-	hcd = container_of (bus, struct usb_hcd, self);
-	if (hcd-&gt;driver-&gt;hub_irq_enable &amp;&amp; hcd-&gt;state != HC_STATE_HALT)
-		hcd-&gt;driver-&gt;hub_irq_enable (hcd);
-}
-
 
 /*-------------------------------------------------------------------------*/
 
diff --git a/drivers/usb/core/hcd.h b/drivers/usb/core/hcd.h
index 3ba258eb05de..1e4b81e9eb50 100644
--- a/drivers/usb/core/hcd.h
+++ b/drivers/usb/core/hcd.h
@@ -210,8 +210,6 @@ struct hc_driver {
 	int	(*bus_suspend)(struct usb_hcd *);
 	int	(*bus_resume)(struct usb_hcd *);
 	int	(*start_port_reset)(struct usb_hcd *, unsigned port_num);
-	void	(*hub_irq_enable)(struct usb_hcd *);
-		/* Needed only if port-change IRQs are level-triggered */
 
 		/* force handover of high-speed port to full-speed companion */
 	void	(*relinquish_port)(struct usb_hcd *, int);
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 1e23e360ea91..5a338a5d4fe7 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2001,8 +2001,6 @@ int usb_port_resume(struct usb_device *udev)
 	}
 
 	clear_bit(port1, hub-&gt;busy_bits);
-	if (!hub-&gt;hdev-&gt;parent &amp;&amp; !hub-&gt;busy_bits[0])
-		usb_enable_root_hub_irq(hub-&gt;hdev-&gt;bus);
 
 	if (status == 0)
 		status = finish_port_resume(udev);
@@ -2918,11 +2916,6 @@ static void hub_events(void)
 
 		hub-&gt;activating = 0;
 
-		/* If this is a root hub, tell the HCD it's okay to
-		 * re-enable port-change interrupts now. */
-		if (!hdev-&gt;parent &amp;&amp; !hub-&gt;busy_bits[0])
-			usb_enable_root_hub_irq(hdev-&gt;bus);
-
 loop_autopm:
 		/* Allow autosuspend if we're not going to run again */
 		if (list_empty(&amp;hub-&gt;event_list))
@@ -3148,8 +3141,6 @@ int usb_reset_device(struct usb_device *udev)
 			break;
 	}
 	clear_bit(port1, parent_hub-&gt;busy_bits);
-	if (!parent_hdev-&gt;parent &amp;&amp; !parent_hub-&gt;busy_bits[0])
-		usb_enable_root_hub_irq(parent_hdev-&gt;bus);
 
 	if (ret &lt; 0)
 		goto re_enumerate;
diff --git a/drivers/usb/host/ohci-at91.c b/drivers/usb/host/ohci-at91.c
index e534f9de0f05..c96db1153dcf 100644
--- a/drivers/usb/host/ohci-at91.c
+++ b/drivers/usb/host/ohci-at91.c
@@ -261,7 +261,6 @@ static const struct hc_driver ohci_at91_hc_driver = {
 	 */
 	.hub_status_data =	ohci_hub_status_data,
 	.hub_control =		ohci_hub_control,
-	.hub_irq_enable =	ohci_rhsc_enable,
 #ifdef CONFIG_PM
 	.bus_suspend =		ohci_bus_suspend,
 	.bus_resume =		ohci_bus_resume,
diff --git a/drivers/usb/host/ohci-au1xxx.c b/drivers/usb/host/ohci-au1xxx.c
index f90fe0c7373f..1b9abdba920b 100644
--- a/drivers/usb/host/ohci-au1xxx.c
+++ b/drivers/usb/host/ohci-au1xxx.c
@@ -288,7 +288,6 @@ static const struct hc_driver ohci_au1xxx_hc_driver = {
 	 */
 	.hub_status_data =	ohci_hub_status_data,
 	.hub_control =		ohci_hub_control,
-	.hub_irq_enable =	ohci_rhsc_enable,
 #ifdef	CONFIG_PM
 	.bus_suspend =		ohci_bus_suspend,
 	.bus_resume =		ohci_bus_resume,
diff --git a/drivers/usb/host/ohci-ep93xx.c b/drivers/usb/host/ohci-ep93xx.c
index 5adaf36e47d0..06aadfb0ec29 100644
--- a/drivers/usb/host/ohci-ep93xx.c
+++ b/drivers/usb/host/ohci-ep93xx.c
@@ -135,7 +135,6 @@ static struct hc_driver ohci_ep93xx_hc_driver = {
 	.get_frame_number	= ohci_get_frame,
 	.hub_status_data	= ohci_hub_status_data,
 	.hub_control		= ohci_hub_control,
-	.hub_irq_enable		= ohci_rhsc_enable,
 #ifdef CONFIG_PM
 	.bus_suspend		= ohci_bus_suspend,
 	.bus_resume		= ohci_bus_resume,
diff --git a/drivers/usb/host/ohci-hub.c b/drivers/usb/host/ohci-hub.c
index 355a82f25274..5be3bb3e6a9d 100644
--- a/drivers/usb/host/ohci-hub.c
+++ b/drivers/usb/host/ohci-hub.c
@@ -36,18 +36,6 @@
 
 /*-------------------------------------------------------------------------*/
 
-/* hcd-&gt;hub_irq_enable() */
-static void ohci_rhsc_enable (struct usb_hcd *hcd)
-{
-	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
-
-	spin_lock_irq(&amp;ohci-&gt;lock);
-	if (!ohci-&gt;autostop)
-		del_timer(&amp;hcd-&gt;rh_timer);	/* Prevent next poll */
-	ohci_writel(ohci, OHCI_INTR_RHSC, &amp;ohci-&gt;regs-&gt;intrenable);
-	spin_unlock_irq(&amp;ohci-&gt;lock);
-}
-
 #define OHCI_SCHED_ENABLES \
 	(OHCI_CTRL_CLE|OHCI_CTRL_BLE|OHCI_CTRL_PLE|OHCI_CTRL_IE)
 
@@ -374,18 +362,28 @@ static int ohci_root_hub_state_changes(struct ohci_hcd *ohci, int changed,
 		int any_connected)
 {
 	int	poll_rh = 1;
+	int	rhsc;
 
+	rhsc = ohci_readl(ohci, &amp;ohci-&gt;regs-&gt;intrenable) &amp; OHCI_INTR_RHSC;
 	switch (ohci-&gt;hc_control &amp; OHCI_CTRL_HCFS) {
 
 	case OHCI_USB_OPER:
-		/* keep on polling until we know a device is connected
-		 * and RHSC is enabled */
+		/* If no status changes are pending, enable status-change
+		 * interrupts.
+		 */
+		if (!rhsc &amp;&amp; !changed) {
+			rhsc = OHCI_INTR_RHSC;
+			ohci_writel(ohci, rhsc, &amp;ohci-&gt;regs-&gt;intrenable);
+		}
+
+		/* Keep on polling until we know a device is connected
+		 * and RHSC is enabled, or until we autostop.
+		 */
 		if (!ohci-&gt;autostop) {
 			if (any_connected ||
 					!device_may_wakeup(&amp;ohci_to_hcd(ohci)
 						-&gt;self.root_hub-&gt;dev)) {
-				if (ohci_readl(ohci, &amp;ohci-&gt;regs-&gt;intrenable) &amp;
-						OHCI_INTR_RHSC)
+				if (rhsc)
 					poll_rh = 0;
 			} else {
 				ohci-&gt;autostop = 1;
@@ -398,12 +396,13 @@ static int ohci_root_hub_state_changes(struct ohci_hcd *ohci, int changed,
 				ohci-&gt;autostop = 0;
 				ohci-&gt;next_statechange = jiffies +
 						STATECHANGE_DELAY;
-			} else if (time_after_eq(jiffies,
+			} else if (rhsc &amp;&amp; time_after_eq(jiffies,
 						ohci-&gt;next_statechange)
 					&amp;&amp; !ohci-&gt;ed_rm_list
 					&amp;&amp; !(ohci-&gt;hc_control &amp;
 						OHCI_SCHED_ENABLES)) {
 				ohci_rh_suspend(ohci, 1);
+				poll_rh = 0;
 			}
 		}
 		break;
@@ -417,6 +416,12 @@ static int ohci_root_hub_state_changes(struct ohci_hcd *ohci, int changed,
 			else
 				usb_hcd_resume_root_hub(ohci_to_hcd(ohci));
 		} else {
+			if (!rhsc &amp;&amp; (ohci-&gt;autostop ||
+					ohci_to_hcd(ohci)-&gt;self.root_hub-&gt;
+						do_remote_wakeup))
+				ohci_writel(ohci, OHCI_INTR_RHSC,
+						&amp;ohci-&gt;regs-&gt;intrenable);
+
 			/* everything is idle, no need for polling */
 			poll_rh = 0;
 		}
@@ -438,12 +443,16 @@ static inline int ohci_rh_resume(struct ohci_hcd *ohci)
 static int ohci_root_hub_state_changes(struct ohci_hcd *ohci, int changed,
 		int any_connected)
 {
-	int	poll_rh = 1;
-
-	/* keep on polling until RHSC is enabled */
+	/* If RHSC is enabled, don't poll */
 	if (ohci_readl(ohci, &amp;ohci-&gt;regs-&gt;intrenable) &amp; OHCI_INTR_RHSC)
-		poll_rh = 0;
-	return poll_rh;
+		return 0;
+
+	/* If no status changes are pending, enable status-change interrupts */
+	if (!changed) {
+		ohci_writel(ohci, OHCI_INTR_RHSC, &amp;ohci-&gt;regs-&gt;intrenable);
+		return 0;
+	}
+	return 1;
 }
 
 #endif	/* CONFIG_PM */
diff --git a/drivers/usb/host/ohci-lh7a404.c b/drivers/usb/host/ohci-lh7a404.c
index 13c12ed22252..96d14fa1d833 100644
--- a/drivers/usb/host/ohci-lh7a404.c
+++ b/drivers/usb/host/ohci-lh7a404.c
@@ -193,7 +193,6 @@ static const struct hc_driver ohci_lh7a404_hc_driver = {
 	 */
 	.hub_status_data =	ohci_hub_status_data,
 	.hub_control =		ohci_hub_control,
-	.hub_irq_enable =	ohci_rhsc_enable,
 #ifdef	CONFIG_PM
 	.bus_suspend =		ohci_bus_suspend,
 	.bus_resume =		ohci_bus_resume,
diff --git a/drivers/usb/host/ohci-omap.c b/drivers/usb/host/ohci-omap.c
index 3a7c24c03671..6859fb5f1d6f 100644
--- a/drivers/usb/host/ohci-omap.c
+++ b/drivers/usb/host/ohci-omap.c
@@ -466,7 +466,6 @@ static const struct hc_driver ohci_omap_hc_driver = {
 	 */
 	.hub_status_data =	ohci_hub_status_data,
 	.hub_control =		ohci_hub_control,
-	.hub_irq_enable =	ohci_rhsc_enable,
 #ifdef	CONFIG_PM
 	.bus_suspend =		ohci_bus_suspend,
 	.bus_resume =		ohci_bus_resume,
diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 4696cc912e16..3bf175d95a23 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -327,7 +327,6 @@ static const struct hc_driver ohci_pci_hc_driver = {
 	 */
 	.hub_status_data =	ohci_hub_status_data,
 	.hub_control =		ohci_hub_control,
-	.hub_irq_enable =	ohci_rhsc_enable,
 #ifdef	CONFIG_PM
 	.bus_suspend =		ohci_bus_suspend,
 	.bus_resume =		ohci_bus_resume,
diff --git a/drivers/usb/host/ohci-pnx4008.c b/drivers/usb/host/ohci-pnx4008.c
index 28b458f20cc3..664f07ee8732 100644
--- a/drivers/usb/host/ohci-pnx4008.c
+++ b/drivers/usb/host/ohci-pnx4008.c
@@ -280,7 +280,6 @@ static const struct hc_driver ohci_pnx4008_hc_driver = {
 	 */
 	.hub_status_data = ohci_hub_status_data,
 	.hub_control = ohci_hub_control,
-	.hub_irq_enable = ohci_rhsc_enable,
 #ifdef	CONFIG_PM
 	.bus_suspend = ohci_bus_suspend,
 	.bus_resume = ohci_bus_resume,
diff --git a/drivers/usb/host/ohci-pnx8550.c b/drivers/usb/host/ohci-pnx8550.c
index 605d59cba28e..28467e288a93 100644
--- a/drivers/usb/host/ohci-pnx8550.c
+++ b/drivers/usb/host/ohci-pnx8550.c
@@ -201,7 +201,6 @@ static const struct hc_driver ohci_pnx8550_hc_driver = {
 	 */
 	.hub_status_data =	ohci_hub_status_data,
 	.hub_control =		ohci_hub_control,
-	.hub_irq_enable =	ohci_rhsc_enable,
 #ifdef	CONFIG_PM
 	.bus_suspend =		ohci_bus_suspend,
 	.bus_resume =		ohci_bus_resume,
diff --git a/drivers/usb/host/ohci-ppc-of.c b/drivers/usb/host/ohci-ppc-of.c
index a67252791223..50e55db13636 100644
--- a/drivers/usb/host/ohci-ppc-of.c
+++ b/drivers/usb/host/ohci-ppc-of.c
@@ -72,7 +72,6 @@ static const struct hc_driver ohci_ppc_of_hc_driver = {
 	 */
 	.hub_status_data =	ohci_hub_status_data,
 	.hub_control =		ohci_hub_control,
-	.hub_irq_enable =	ohci_rhsc_enable,
 #ifdef	CONFIG_PM
 	.bus_suspend =		ohci_bus_suspend,
 	.bus_resume =		ohci_bus_resume,
diff --git a/drivers/usb/host/ohci-ppc-soc.c b/drivers/usb/host/ohci-ppc-soc.c
index 523c30125577..cd3398b675b2 100644
--- a/drivers/usb/host/ohci-ppc-soc.c
+++ b/drivers/usb/host/ohci-ppc-soc.c
@@ -172,7 +172,6 @@ static const struct hc_driver ohci_ppc_soc_hc_driver = {
 	 */
 	.hub_status_data =	ohci_hub_status_data,
 	.hub_control =		ohci_hub_control,
-	.hub_irq_enable =	ohci_rhsc_enable,
 #ifdef	CONFIG_PM
 	.bus_suspend =		ohci_bus_suspend,
 	.bus_resume =		ohci_bus_resume,
diff --git a/drivers/usb/host/ohci-ps3.c b/drivers/usb/host/ohci-ps3.c
index c1935ae537f8..bfdeb0d22d05 100644
--- a/drivers/usb/host/ohci-ps3.c
+++ b/drivers/usb/host/ohci-ps3.c
@@ -68,7 +68,6 @@ static const struct hc_driver ps3_ohci_hc_driver = {
 	.get_frame_number	= ohci_get_frame,
 	.hub_status_data	= ohci_hub_status_data,
 	.hub_control		= ohci_hub_control,
-	.hub_irq_enable		= ohci_rhsc_enable,
 	.start_port_reset	= ohci_start_port_reset,
 #if defined(CONFIG_PM)
 	.bus_suspend 		= ohci_bus_suspend,
diff --git a/drivers/usb/host/ohci-pxa27x.c b/drivers/usb/host/ohci-pxa27x.c
index d4ee27d92be8..70b0d4b459e7 100644
--- a/drivers/usb/host/ohci-pxa27x.c
+++ b/drivers/usb/host/ohci-pxa27x.c
@@ -298,7 +298,6 @@ static const struct hc_driver ohci_pxa27x_hc_driver = {
 	 */
 	.hub_status_data =	ohci_hub_status_data,
 	.hub_control =		ohci_hub_control,
-	.hub_irq_enable =	ohci_rhsc_enable,
 #ifdef  CONFIG_PM
 	.bus_suspend =		ohci_bus_suspend,
 	.bus_resume =		ohci_bus_resume,
diff --git a/drivers/usb/host/ohci-s3c2410.c b/drivers/usb/host/ohci-s3c2410.c
index ead4772f0f27..a73d2ff322e2 100644
--- a/drivers/usb/host/ohci-s3c2410.c
+++ b/drivers/usb/host/ohci-s3c2410.c
@@ -466,7 +466,6 @@ static const struct hc_driver ohci_s3c2410_hc_driver = {
 	 */
 	.hub_status_data =	ohci_s3c2410_hub_status_data,
 	.hub_control =		ohci_s3c2410_hub_control,
-	.hub_irq_enable =	ohci_rhsc_enable,
 #ifdef	CONFIG_PM
 	.bus_suspend =		ohci_bus_suspend,
 	.bus_resume =		ohci_bus_resume,
diff --git a/drivers/usb/host/ohci-sa1111.c b/drivers/usb/host/ohci-sa1111.c
index 0f48f2d99226..99438c65981b 100644
--- a/drivers/usb/host/ohci-sa1111.c
+++ b/drivers/usb/host/ohci-sa1111.c
@@ -231,7 +231,6 @@ static const struct hc_driver ohci_sa1111_hc_driver = {
 	 */
 	.hub_status_data =	ohci_hub_status_data,
 	.hub_control =		ohci_hub_control,
-	.hub_irq_enable =	ohci_rhsc_enable,
 #ifdef	CONFIG_PM
 	.bus_suspend =		ohci_bus_suspend,
 	.bus_resume =		ohci_bus_resume,
diff --git a/drivers/usb/host/ohci-sh.c b/drivers/usb/host/ohci-sh.c
index e7ee607278fe..60f03cc7ec4f 100644
--- a/drivers/usb/host/ohci-sh.c
+++ b/drivers/usb/host/ohci-sh.c
@@ -68,7 +68,6 @@ static const struct hc_driver ohci_sh_hc_driver = {
 	 */
 	.hub_status_data =	ohci_hub_status_data,
 	.hub_control =		ohci_hub_control,
-	.hub_irq_enable =	ohci_rhsc_enable,
 #ifdef	CONFIG_PM
 	.bus_suspend =		ohci_bus_suspend,
 	.bus_resume =		ohci_bus_resume,
diff --git a/drivers/usb/host/ohci-sm501.c b/drivers/usb/host/ohci-sm501.c
index 4a11e1816017..77204f001b9a 100644
--- a/drivers/usb/host/ohci-sm501.c
+++ b/drivers/usb/host/ohci-sm501.c
@@ -75,7 +75,6 @@ static const struct hc_driver ohci_sm501_hc_driver = {
 	 */
 	.hub_status_data =	ohci_hub_status_data,
 	.hub_control =		ohci_hub_control,
-	.hub_irq_enable =	ohci_rhsc_enable,
 #ifdef	CONFIG_PM
 	.bus_suspend =		ohci_bus_suspend,
 	.bus_resume =		ohci_bus_resume,
diff --git a/drivers/usb/host/ohci-ssb.c b/drivers/usb/host/ohci-ssb.c
index 7275186db315..c4265caec780 100644
--- a/drivers/usb/host/ohci-ssb.c
+++ b/drivers/usb/host/ohci-ssb.c
@@ -81,7 +81,6 @@ static const struct hc_driver ssb_ohci_hc_driver = {
 
 	.hub_status_data	= ohci_hub_status_data,
 	.hub_control		= ohci_hub_control,
-	.hub_irq_enable		= ohci_rhsc_enable,
 #ifdef	CONFIG_PM
 	.bus_suspend		= ohci_bus_suspend,
 	.bus_resume		= ohci_bus_resume,
diff --git a/drivers/usb/host/u132-hcd.c b/drivers/usb/host/u132-hcd.c
index 9b6323f768b2..f29307405bb3 100644
--- a/drivers/usb/host/u132-hcd.c
+++ b/drivers/usb/host/u132-hcd.c
@@ -2934,16 +2934,6 @@ static int u132_start_port_reset(struct usb_hcd *hcd, unsigned port_num)
 		return 0;
 }
 
-static void u132_hub_irq_enable(struct usb_hcd *hcd)
-{
-	struct u132 *u132 = hcd_to_u132(hcd);
-	if (u132-&gt;going &gt; 1) {
-		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device has been removed %d\n"
-			, u132-&gt;going);
-	} else if (u132-&gt;going &gt; 0)
-		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed\n");
-}
-
 
 #ifdef CONFIG_PM
 static int u132_bus_suspend(struct usb_hcd *hcd)
@@ -2995,7 +2985,6 @@ static struct hc_driver u132_hc_driver = {
 	.bus_suspend = u132_bus_suspend,
 	.bus_resume = u132_bus_resume,
 	.start_port_reset = u132_start_port_reset,
-	.hub_irq_enable = u132_hub_irq_enable,
 };
 
 /*</pre><hr><pre>commit 5f47493cdf90b8afe5353e59de30e449e775ea8b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Apr 14 12:17:49 2008 -0400

    USB: OHCI: turn off RD when remote wakeup is disabled
    
    This patch (as1068b) disables the RD interrupt flag when an OHCI root
    hub is suspended with remote wakeup disabled.  Although the spec
    clearly states that this flag permits the controller to issue an
    interrupt when a resume request from downstream is detected and not
    when a local status change occurs, some controllers mistakenly use it
    for both types of event.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ohci-hub.c b/drivers/usb/host/ohci-hub.c
index cf3e1d255639..355a82f25274 100644
--- a/drivers/usb/host/ohci-hub.c
+++ b/drivers/usb/host/ohci-hub.c
@@ -106,7 +106,8 @@ __acquires(ohci-&gt;lock)
 	if (ohci_to_hcd(ohci)-&gt;self.root_hub-&gt;do_remote_wakeup || autostop) {
 		ohci-&gt;hc_control |= OHCI_CTRL_RWE;
 	} else {
-		ohci_writel (ohci, OHCI_INTR_RHSC, &amp;ohci-&gt;regs-&gt;intrdisable);
+		ohci_writel(ohci, OHCI_INTR_RHSC | OHCI_INTR_RD,
+				&amp;ohci-&gt;regs-&gt;intrdisable);
 		ohci-&gt;hc_control &amp;= ~OHCI_CTRL_RWE;
 	}
 </pre><hr><pre>commit 58a97ffeb2297f154659f339d77eb3f32c4d8b3e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Apr 14 12:17:10 2008 -0400

    USB: HCDs use the do_remote_wakeup flag
    
    When a USB device is suspended, whether or not it is enabled for
    remote wakeup depends on the device_may_wakeup() setting.  The setting
    is then saved in the do_remote_wakeup flag.
    
    Later on, however, the device_may_wakeup() value can change because of
    user activity.  So when testing whether a suspended device is or
    should be enabled for remote wakeup, we should always test
    do_remote_wakeup instead of device_may_wakeup().  This patch (as1076)
    makes that change for root hubs in several places.
    
    The patch also adjusts uhci-hcd so that when an autostopped controller
    is suspended, the remote wakeup setting agrees with the value recorded
    in the root hub's do_remote_wakeup flag.
    
    And the patch adjusts ehci-hcd so that wakeup events on selectively
    suspended ports (i.e., the bus itself isn't suspended) don't turn on
    the PME# wakeup signal.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 2ea333a43d65..edc31e13e95e 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -932,7 +932,6 @@ static int autosuspend_check(struct usb_device *udev, int reschedule)
 	 * is disabled.  Also fail if any interfaces require remote wakeup
 	 * but it isn't available.
 	 */
-	udev-&gt;do_remote_wakeup = device_may_wakeup(&amp;udev-&gt;dev);
 	if (udev-&gt;pm_usage_cnt &gt; 0)
 		return -EBUSY;
 	if (udev-&gt;autosuspend_delay &lt; 0 || udev-&gt;autosuspend_disabled)
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 21ac3781f21a..536b433d24f7 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -30,6 +30,8 @@
 
 #ifdef	CONFIG_PM
 
+#define	PORT_WAKE_BITS	(PORT_WKOC_E|PORT_WKDISC_E|PORT_WKCONN_E)
+
 static int ehci_hub_control(
 	struct usb_hcd	*hcd,
 	u16		typeReq,
@@ -149,10 +151,10 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 		}
 
 		/* enable remote wakeup on all ports */
-		if (device_may_wakeup(&amp;hcd-&gt;self.root_hub-&gt;dev))
-			t2 |= PORT_WKOC_E|PORT_WKDISC_E|PORT_WKCONN_E;
+		if (hcd-&gt;self.root_hub-&gt;do_remote_wakeup)
+			t2 |= PORT_WAKE_BITS;
 		else
-			t2 &amp;= ~(PORT_WKOC_E|PORT_WKDISC_E|PORT_WKCONN_E);
+			t2 &amp;= ~PORT_WAKE_BITS;
 
 		if (t1 != t2) {
 			ehci_vdbg (ehci, "port %d, %08x -&gt; %08x\n",
@@ -174,7 +176,7 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 
 	/* allow remote wakeup */
 	mask = INTR_MASK;
-	if (!device_may_wakeup(&amp;hcd-&gt;self.root_hub-&gt;dev))
+	if (!hcd-&gt;self.root_hub-&gt;do_remote_wakeup)
 		mask &amp;= ~STS_PCD;
 	ehci_writel(ehci, mask, &amp;ehci-&gt;regs-&gt;intr_enable);
 	ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;intr_enable);
@@ -232,8 +234,7 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 	i = HCS_N_PORTS (ehci-&gt;hcs_params);
 	while (i--) {
 		temp = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;port_status [i]);
-		temp &amp;= ~(PORT_RWC_BITS
-			| PORT_WKOC_E | PORT_WKDISC_E | PORT_WKCONN_E);
+		temp &amp;= ~(PORT_RWC_BITS | PORT_WAKE_BITS);
 		if (test_bit(i, &amp;ehci-&gt;bus_suspended) &amp;&amp;
 				(temp &amp; PORT_SUSPEND)) {
 			ehci-&gt;reset_done [i] = jiffies + msecs_to_jiffies (20);
@@ -534,8 +535,6 @@ ehci_hub_descriptor (
 
 /*-------------------------------------------------------------------------*/
 
-#define	PORT_WAKE_BITS	(PORT_WKOC_E|PORT_WKDISC_E|PORT_WKCONN_E)
-
 static int ehci_hub_control (
 	struct usb_hcd	*hcd,
 	u16		typeReq,
@@ -801,8 +800,6 @@ static int ehci_hub_control (
 			if ((temp &amp; PORT_PE) == 0
 					|| (temp &amp; PORT_RESET) != 0)
 				goto error;
-			if (device_may_wakeup(&amp;hcd-&gt;self.root_hub-&gt;dev))
-				temp |= PORT_WAKE_BITS;
 			ehci_writel(ehci, temp | PORT_SUSPEND, status_reg);
 			break;
 		case USB_PORT_FEAT_POWER:
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index a0afc78b273e..88dad4b53131 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -300,7 +300,7 @@ static int ehci_pci_resume(struct usb_hcd *hcd)
 	if (ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;configured_flag) == FLAG_CF) {
 		int	mask = INTR_MASK;
 
-		if (!device_may_wakeup(&amp;hcd-&gt;self.root_hub-&gt;dev))
+		if (!hcd-&gt;self.root_hub-&gt;do_remote_wakeup)
 			mask &amp;= ~STS_PCD;
 		ehci_writel(ehci, mask, &amp;ehci-&gt;regs-&gt;intr_enable);
 		ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;intr_enable);
diff --git a/drivers/usb/host/isp116x-hcd.c b/drivers/usb/host/isp116x-hcd.c
index 66d773c726f6..20b9a0d07420 100644
--- a/drivers/usb/host/isp116x-hcd.c
+++ b/drivers/usb/host/isp116x-hcd.c
@@ -1400,7 +1400,7 @@ static int isp116x_bus_suspend(struct usb_hcd *hcd)
 		spin_unlock_irqrestore(&amp;isp116x-&gt;lock, flags);
 		val &amp;= (~HCCONTROL_HCFS &amp; ~HCCONTROL_RWE);
 		val |= HCCONTROL_USB_SUSPEND;
-		if (device_may_wakeup(&amp;hcd-&gt;self.root_hub-&gt;dev))
+		if (hcd-&gt;self.root_hub-&gt;do_remote_wakeup)
 			val |= HCCONTROL_RWE;
 		/* Wait for usb transfers to finish */
 		msleep(2);
diff --git a/drivers/usb/host/ohci-hub.c b/drivers/usb/host/ohci-hub.c
index 28d6d775eb5f..cf3e1d255639 100644
--- a/drivers/usb/host/ohci-hub.c
+++ b/drivers/usb/host/ohci-hub.c
@@ -103,10 +103,9 @@ __acquires(ohci-&gt;lock)
 	finish_unlinks (ohci, ohci_frame_no(ohci));
 
 	/* maybe resume can wake root hub */
-	if (device_may_wakeup(&amp;ohci_to_hcd(ohci)-&gt;self.root_hub-&gt;dev) ||
-			autostop)
+	if (ohci_to_hcd(ohci)-&gt;self.root_hub-&gt;do_remote_wakeup || autostop) {
 		ohci-&gt;hc_control |= OHCI_CTRL_RWE;
-	else {
+	} else {
 		ohci_writel (ohci, OHCI_INTR_RHSC, &amp;ohci-&gt;regs-&gt;intrdisable);
 		ohci-&gt;hc_control &amp;= ~OHCI_CTRL_RWE;
 	}
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index fec9872dd9dc..f65d5a858733 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -262,20 +262,12 @@ __acquires(uhci-&gt;lock)
 {
 	int auto_stop;
 	int int_enable, egsm_enable;
+	struct usb_device *rhdev = uhci_to_hcd(uhci)-&gt;self.root_hub;
 
 	auto_stop = (new_state == UHCI_RH_AUTO_STOPPED);
-	dev_dbg(&amp;uhci_to_hcd(uhci)-&gt;self.root_hub-&gt;dev,
-			"%s%s\n", __FUNCTION__,
+	dev_dbg(&amp;rhdev-&gt;dev, "%s%s\n", __func__,
 			(auto_stop ? " (auto-stop)" : ""));
 
-	/* If we get a suspend request when we're already auto-stopped
-	 * then there's nothing to do.
-	 */
-	if (uhci-&gt;rh_state == UHCI_RH_AUTO_STOPPED) {
-		uhci-&gt;rh_state = new_state;
-		return;
-	}
-
 	/* Enable resume-detect interrupts if they work.
 	 * Then enter Global Suspend mode if _it_ works, still configured.
 	 */
@@ -285,8 +277,10 @@ __acquires(uhci-&gt;lock)
 	if (remote_wakeup_is_broken(uhci))
 		egsm_enable = 0;
 	if (resume_detect_interrupts_are_broken(uhci) || !egsm_enable ||
-			!device_may_wakeup(
-				&amp;uhci_to_hcd(uhci)-&gt;self.root_hub-&gt;dev))
+#ifdef CONFIG_PM
+			(!auto_stop &amp;&amp; !rhdev-&gt;do_remote_wakeup) ||
+#endif
+			(auto_stop &amp;&amp; !device_may_wakeup(&amp;rhdev-&gt;dev)))
 		uhci-&gt;working_RD = int_enable = 0;
 
 	outw(int_enable, uhci-&gt;io_addr + USBINTR);
@@ -308,8 +302,7 @@ __acquires(uhci-&gt;lock)
 			return;
 	}
 	if (!(inw(uhci-&gt;io_addr + USBSTS) &amp; USBSTS_HCH))
-		dev_warn(&amp;uhci_to_hcd(uhci)-&gt;self.root_hub-&gt;dev,
-			"Controller not stopped yet!\n");
+		dev_warn(uhci_dev(uhci), "Controller not stopped yet!\n");
 
 	uhci_get_current_frame_number(uhci);
 </pre><hr><pre>commit b950bdbc67041412cb042e404938667204c7902c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Apr 14 11:45:29 2008 -0400

    USB: g_file_storage: ignore bulk-out data after invalid CBW
    
    This patch (as1061) makes g_file_storage more compliant with the
    Bulk-Only Transport specification.  After an invalid CBW is received,
    the gadget must ignore any further bulk-OUT data until it is reset.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/file_storage.c b/drivers/usb/gadget/file_storage.c
index 017a196d041f..0a726e106ccd 100644
--- a/drivers/usb/gadget/file_storage.c
+++ b/drivers/usb/gadget/file_storage.c
@@ -644,7 +644,7 @@ struct fsg_dev {
 
 	unsigned long		atomic_bitflags;
 #define REGISTERED		0
-#define CLEAR_BULK_HALTS	1
+#define IGNORE_BULK_OUT		1
 #define SUSPENDED		2
 
 	struct usb_ep		*bulk_in;
@@ -2936,8 +2936,8 @@ static int received_cbw(struct fsg_dev *fsg, struct fsg_buffhd *bh)
 	struct usb_request	*req = bh-&gt;outreq;
 	struct bulk_cb_wrap	*cbw = req-&gt;buf;
 
-	/* Was this a real packet? */
-	if (req-&gt;status)
+	/* Was this a real packet?  Should it be ignored? */
+	if (req-&gt;status || test_bit(IGNORE_BULK_OUT, &amp;fsg-&gt;atomic_bitflags))
 		return -EINVAL;
 
 	/* Is the CBW valid? */
@@ -2948,13 +2948,17 @@ static int received_cbw(struct fsg_dev *fsg, struct fsg_buffhd *bh)
 				req-&gt;actual,
 				le32_to_cpu(cbw-&gt;Signature));
 
-		/* The Bulk-only spec says we MUST stall the bulk pipes!
-		 * If we want to avoid stalls, set a flag so that we will
-		 * clear the endpoint halts at the next reset. */
-		if (!mod_data.can_stall)
-			set_bit(CLEAR_BULK_HALTS, &amp;fsg-&gt;atomic_bitflags);
-		fsg_set_halt(fsg, fsg-&gt;bulk_out);
+		/* The Bulk-only spec says we MUST stall the IN endpoint
+		 * (6.6.1), so it's unavoidable.  It also says we must
+		 * retain this state until the next reset, but there's
+		 * no way to tell the controller driver it should ignore
+		 * Clear-Feature(HALT) requests.
+		 *
+		 * We aren't required to halt the OUT endpoint; instead
+		 * we can simply accept and discard any data received
+		 * until the next reset. */
 		halt_bulk_in_endpoint(fsg);
+		set_bit(IGNORE_BULK_OUT, &amp;fsg-&gt;atomic_bitflags);
 		return -EINVAL;
 	}
 
@@ -3140,6 +3144,7 @@ static int do_set_interface(struct fsg_dev *fsg, int altsetting)
 		goto reset;
 	fsg-&gt;bulk_out_enabled = 1;
 	fsg-&gt;bulk_out_maxpacket = le16_to_cpu(d-&gt;wMaxPacketSize);
+	clear_bit(IGNORE_BULK_OUT, &amp;fsg-&gt;atomic_bitflags);
 
 	if (transport_is_cbi()) {
 		d = ep_desc(fsg-&gt;gadget, &amp;fs_intr_in_desc, &amp;hs_intr_in_desc);
@@ -3321,11 +3326,8 @@ static void handle_exception(struct fsg_dev *fsg)
 		/* In case we were forced against our will to halt a
 		 * bulk endpoint, clear the halt now.  (The SuperH UDC
 		 * requires this.) */
-		if (test_and_clear_bit(CLEAR_BULK_HALTS,
-				&amp;fsg-&gt;atomic_bitflags)) {
+		if (test_and_clear_bit(IGNORE_BULK_OUT, &amp;fsg-&gt;atomic_bitflags))
 			usb_ep_clear_halt(fsg-&gt;bulk_in);
-			usb_ep_clear_halt(fsg-&gt;bulk_out);
-		}
 
 		if (transport_is_bbb()) {
 			if (fsg-&gt;ep0_req_tag == exception_req_tag)</pre><hr><pre>commit 6427f7995338387ddded92f98adec19ddbf0ae5e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Apr 10 12:45:34 2008 -0400

    USB: log an error message when USB enumeration fails
    
    This patch (as1077) logs an error message whenever the kernel is
    unable to enumerate a new USB device.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 9fc5179dfc60..1e23e360ea91 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2708,6 +2708,7 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 		if ((status == -ENOTCONN) || (status == -ENOTSUPP))
 			break;
 	}
+	dev_err(hub_dev, "unable to enumerate USB device on port %d\n", port1);
  
 done:
 	hub_port_disable(hub, port1, 1);</pre><hr><pre>commit a89a2cd396b20c46a37fa8db4b652fb00f29d0a4
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Apr 7 15:03:25 2008 -0400

    USB: dummy-hcd: use dynamic allocation for platform_devices
    
    This patch (as1075) changes dummy-hcd to dynamically allocate its
    platform_device structures, using the core platform_device_alloc()
    interface.  This is what it should have done all along, because the
    dynamically-allocated structures have a release method in the driver
    core and are therefore immune to being released after the module has
    been unloaded.
    
    Thanks to Richard Purdie for pointing out the need for this change.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: Richard Purdie &lt;rpurdie@rpsys.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index 433f8c47cce5..74f51a703b42 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -1933,69 +1933,57 @@ static struct platform_driver dummy_hcd_driver = {
 
 /*-------------------------------------------------------------------------*/
 
-/* These don't need to do anything because the pdev structures are
- * statically allocated. */
-static void
-dummy_udc_release (struct device *dev) {}
-
-static void
-dummy_hcd_release (struct device *dev) {}
-
-static struct platform_device		the_udc_pdev = {
-	.name		= (char *) gadget_name,
-	.id		= -1,
-	.dev		= {
-		.release	= dummy_udc_release,
-	},
-};
-
-static struct platform_device		the_hcd_pdev = {
-	.name		= (char *) driver_name,
-	.id		= -1,
-	.dev		= {
-		.release	= dummy_hcd_release,
-	},
-};
+static struct platform_device *the_udc_pdev;
+static struct platform_device *the_hcd_pdev;
 
 static int __init init (void)
 {
-	int	retval;
+	int	retval = -ENOMEM;
 
 	if (usb_disabled ())
 		return -ENODEV;
 
-	retval = platform_driver_register (&amp;dummy_hcd_driver);
-	if (retval &lt; 0)
+	the_hcd_pdev = platform_device_alloc(driver_name, -1);
+	if (!the_hcd_pdev)
 		return retval;
+	the_udc_pdev = platform_device_alloc(gadget_name, -1);
+	if (!the_udc_pdev)
+		goto err_alloc_udc;
 
-	retval = platform_driver_register (&amp;dummy_udc_driver);
+	retval = platform_driver_register(&amp;dummy_hcd_driver);
+	if (retval &lt; 0)
+		goto err_register_hcd_driver;
+	retval = platform_driver_register(&amp;dummy_udc_driver);
 	if (retval &lt; 0)
 		goto err_register_udc_driver;
 
-	retval = platform_device_register (&amp;the_hcd_pdev);
+	retval = platform_device_add(the_hcd_pdev);
 	if (retval &lt; 0)
-		goto err_register_hcd;
-
-	retval = platform_device_register (&amp;the_udc_pdev);
+		goto err_add_hcd;
+	retval = platform_device_add(the_udc_pdev);
 	if (retval &lt; 0)
-		goto err_register_udc;
+		goto err_add_udc;
 	return retval;
 
-err_register_udc:
-	platform_device_unregister (&amp;the_hcd_pdev);
-err_register_hcd:
-	platform_driver_unregister (&amp;dummy_udc_driver);
+err_add_udc:
+	platform_device_del(the_hcd_pdev);
+err_add_hcd:
+	platform_driver_unregister(&amp;dummy_udc_driver);
 err_register_udc_driver:
-	platform_driver_unregister (&amp;dummy_hcd_driver);
+	platform_driver_unregister(&amp;dummy_hcd_driver);
+err_register_hcd_driver:
+	platform_device_put(the_udc_pdev);
+err_alloc_udc:
+	platform_device_put(the_hcd_pdev);
 	return retval;
 }
 module_init (init);
 
 static void __exit cleanup (void)
 {
-	platform_device_unregister (&amp;the_udc_pdev);
-	platform_device_unregister (&amp;the_hcd_pdev);
-	platform_driver_unregister (&amp;dummy_udc_driver);
-	platform_driver_unregister (&amp;dummy_hcd_driver);
+	platform_device_unregister(the_udc_pdev);
+	platform_device_unregister(the_hcd_pdev);
+	platform_driver_unregister(&amp;dummy_udc_driver);
+	platform_driver_unregister(&amp;dummy_hcd_driver);
 }
 module_exit (cleanup);</pre>
    <div class="pagination">
        <a href='2_92.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><span>[93]</span><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_94.html'>Next&gt;&gt;</a>
    <div>
</body>
