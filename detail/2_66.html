<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_65.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><span>[66]</span><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_67.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit ffa156590f98b750161757a16c37ac8e152a7859
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Mar 8 16:46:19 2010 -0500

    Driver core: don't initialize wakeup flags
    
    This patch (as1351) removes an unnecessary and unwanted assignment
    from device_initialize().  The wakeup flags are set to 0 along with
    everything else when the device structure is allocated, so we don't
    need to do it again.  Furthermore, the subsystem might already have
    set these flags to their correct values; we don't want to override it.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/base/core.c b/drivers/base/core.c
index b56a0ba31d4a..e11c8c3e7416 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -562,7 +562,6 @@ void device_initialize(struct device *dev)
 	init_MUTEX(&amp;dev-&gt;sem);
 	spin_lock_init(&amp;dev-&gt;devres_lock);
 	INIT_LIST_HEAD(&amp;dev-&gt;devres_head);
-	device_init_wakeup(dev, 0);
 	device_pm_init(dev);
 	set_dev_node(dev, -1);
 }</pre><hr><pre>commit 16032c4f5b291af541e9114a09ea20ff5a0dc474
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed May 12 18:21:35 2010 -0400

    USB: EHCI: fix controller wakeup flag settings during suspend
    
    This patch (as1380) fixes a bug in the wakeup settings for EHCI host
    controllers.  When the controller is suspended, if it isn't enabled
    for remote wakeup then we have to turn off all the port wakeup flags.
    Disabling PCI PME# isn't good enough, because some systems (Intel)
    evidently use alternate wakeup signalling paths.
    
    In addition, the patch improves the handling of the Intel Moorestown
    hardware by performing various power-up and power-down delays just
    once instead of once for each port (i.e., the delays are moved outside
    of the port loops).  This requires extra code, but the total delay
    time is reduced.
    
    There are also a few additional minor cleanups.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Ondrej Zary &lt;linux@rainbow-software.org&gt;
    CC: Alek Du &lt;alek.du@intel.com&gt;
    CC: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-au1xxx.c b/drivers/usb/host/ehci-au1xxx.c
index 7a27b7c4ee84..faa61748db70 100644
--- a/drivers/usb/host/ehci-au1xxx.c
+++ b/drivers/usb/host/ehci-au1xxx.c
@@ -224,26 +224,17 @@ static int ehci_hcd_au1xxx_drv_suspend(struct device *dev)
 		msleep(10);
 
 	/* Root hub was already suspended. Disable irq emission and
-	 * mark HW unaccessible, bail out if RH has been resumed. Use
-	 * the spinlock to properly synchronize with possible pending
-	 * RH suspend or resume activity.
-	 *
-	 * This is still racy as hcd-&gt;state is manipulated outside of
-	 * any locks =P But that will be a different fix.
+	 * mark HW unaccessible.  The PM and USB cores make sure that
+	 * the root hub is either suspended or stopped.
 	 */
 	spin_lock_irqsave(&amp;ehci-&gt;lock, flags);
-	if (hcd-&gt;state != HC_STATE_SUSPENDED) {
-		rc = -EINVAL;
-		goto bail;
-	}
+	ehci_prepare_ports_for_controller_suspend(ehci);
 	ehci_writel(ehci, 0, &amp;ehci-&gt;regs-&gt;intr_enable);
 	(void)ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;intr_enable);
 
 	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
 
 	au1xxx_stop_ehc();
-
-bail:
 	spin_unlock_irqrestore(&amp;ehci-&gt;lock, flags);
 
 	// could save FLADJ in case of Vaux power loss
@@ -273,6 +264,7 @@ static int ehci_hcd_au1xxx_drv_resume(struct device *dev)
 	if (ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;configured_flag) == FLAG_CF) {
 		int	mask = INTR_MASK;
 
+		ehci_prepare_ports_for_controller_resume(ehci);
 		if (!hcd-&gt;self.root_hub-&gt;do_remote_wakeup)
 			mask &amp;= ~STS_PCD;
 		ehci_writel(ehci, mask, &amp;ehci-&gt;regs-&gt;intr_enable);
diff --git a/drivers/usb/host/ehci-fsl.c b/drivers/usb/host/ehci-fsl.c
index 0e26aa13f158..5cd967d28938 100644
--- a/drivers/usb/host/ehci-fsl.c
+++ b/drivers/usb/host/ehci-fsl.c
@@ -313,6 +313,7 @@ static int ehci_fsl_drv_suspend(struct device *dev)
 	struct ehci_fsl *ehci_fsl = hcd_to_ehci_fsl(hcd);
 	void __iomem *non_ehci = hcd-&gt;regs;
 
+	ehci_prepare_ports_for_controller_suspend(hcd_to_ehci(hcd));
 	if (!fsl_deep_sleep())
 		return 0;
 
@@ -327,6 +328,7 @@ static int ehci_fsl_drv_resume(struct device *dev)
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
 	void __iomem *non_ehci = hcd-&gt;regs;
 
+	ehci_prepare_ports_for_controller_resume(ehci);
 	if (!fsl_deep_sleep())
 		return 0;
 
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index ef956220f854..e7d3d8def282 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -106,12 +106,75 @@ static void ehci_handover_companion_ports(struct ehci_hcd *ehci)
 	ehci-&gt;owned_ports = 0;
 }
 
+static void ehci_adjust_port_wakeup_flags(struct ehci_hcd *ehci,
+		bool suspending)
+{
+	int		port;
+	u32		temp;
+
+	/* If remote wakeup is enabled for the root hub but disabled
+	 * for the controller, we must adjust all the port wakeup flags
+	 * when the controller is suspended or resumed.  In all other
+	 * cases they don't need to be changed.
+	 */
+	if (!ehci_to_hcd(ehci)-&gt;self.root_hub-&gt;do_remote_wakeup ||
+			device_may_wakeup(ehci_to_hcd(ehci)-&gt;self.controller))
+		return;
+
+	/* clear phy low-power mode before changing wakeup flags */
+	if (ehci-&gt;has_hostpc) {
+		port = HCS_N_PORTS(ehci-&gt;hcs_params);
+		while (port--) {
+			u32 __iomem	*hostpc_reg;
+
+			hostpc_reg = (u32 __iomem *)((u8 *) ehci-&gt;regs
+					+ HOSTPC0 + 4 * port);
+			temp = ehci_readl(ehci, hostpc_reg);
+			ehci_writel(ehci, temp &amp; ~HOSTPC_PHCD, hostpc_reg);
+		}
+		msleep(5);
+	}
+
+	port = HCS_N_PORTS(ehci-&gt;hcs_params);
+	while (port--) {
+		u32 __iomem	*reg = &amp;ehci-&gt;regs-&gt;port_status[port];
+		u32		t1 = ehci_readl(ehci, reg) &amp; ~PORT_RWC_BITS;
+		u32		t2 = t1 &amp; ~PORT_WAKE_BITS;
+
+		/* If we are suspending the controller, clear the flags.
+		 * If we are resuming the controller, set the wakeup flags.
+		 */
+		if (!suspending) {
+			if (t1 &amp; PORT_CONNECT)
+				t2 |= PORT_WKOC_E | PORT_WKDISC_E;
+			else
+				t2 |= PORT_WKOC_E | PORT_WKCONN_E;
+		}
+		ehci_vdbg(ehci, "port %d, %08x -&gt; %08x\n",
+				port + 1, t1, t2);
+		ehci_writel(ehci, t2, reg);
+	}
+
+	/* enter phy low-power mode again */
+	if (ehci-&gt;has_hostpc) {
+		port = HCS_N_PORTS(ehci-&gt;hcs_params);
+		while (port--) {
+			u32 __iomem	*hostpc_reg;
+
+			hostpc_reg = (u32 __iomem *)((u8 *) ehci-&gt;regs
+					+ HOSTPC0 + 4 * port);
+			temp = ehci_readl(ehci, hostpc_reg);
+			ehci_writel(ehci, temp | HOSTPC_PHCD, hostpc_reg);
+		}
+	}
+}
+
 static int ehci_bus_suspend (struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
 	int			port;
 	int			mask;
-	u32 __iomem		*hostpc_reg = NULL;
+	int			changed;
 
 	ehci_dbg(ehci, "suspend root hub\n");
 
@@ -155,15 +218,13 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 	 */
 	ehci-&gt;bus_suspended = 0;
 	ehci-&gt;owned_ports = 0;
+	changed = 0;
 	port = HCS_N_PORTS(ehci-&gt;hcs_params);
 	while (port--) {
 		u32 __iomem	*reg = &amp;ehci-&gt;regs-&gt;port_status [port];
 		u32		t1 = ehci_readl(ehci, reg) &amp; ~PORT_RWC_BITS;
-		u32		t2 = t1;
+		u32		t2 = t1 &amp; ~PORT_WAKE_BITS;
 
-		if (ehci-&gt;has_hostpc)
-			hostpc_reg = (u32 __iomem *)((u8 *)ehci-&gt;regs
-				+ HOSTPC0 + 4 * (port &amp; 0xff));
 		/* keep track of which ports we suspend */
 		if (t1 &amp; PORT_OWNER)
 			set_bit(port, &amp;ehci-&gt;owned_ports);
@@ -172,40 +233,45 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 			set_bit(port, &amp;ehci-&gt;bus_suspended);
 		}
 
-		/* enable remote wakeup on all ports */
+		/* enable remote wakeup on all ports, if told to do so */
 		if (hcd-&gt;self.root_hub-&gt;do_remote_wakeup) {
 			/* only enable appropriate wake bits, otherwise the
 			 * hardware can not go phy low power mode. If a race
 			 * condition happens here(connection change during bits
 			 * set), the port change detection will finally fix it.
 			 */
-			if (t1 &amp; PORT_CONNECT) {
+			if (t1 &amp; PORT_CONNECT)
 				t2 |= PORT_WKOC_E | PORT_WKDISC_E;
-				t2 &amp;= ~PORT_WKCONN_E;
-			} else {
+			else
 				t2 |= PORT_WKOC_E | PORT_WKCONN_E;
-				t2 &amp;= ~PORT_WKDISC_E;
-			}
-		} else
-			t2 &amp;= ~PORT_WAKE_BITS;
+		}
 
 		if (t1 != t2) {
 			ehci_vdbg (ehci, "port %d, %08x -&gt; %08x\n",
 				port + 1, t1, t2);
 			ehci_writel(ehci, t2, reg);
-			if (hostpc_reg) {
-				u32	t3;
+			changed = 1;
+		}
+	}
 
-				spin_unlock_irq(&amp;ehci-&gt;lock);
-				msleep(5);/* 5ms for HCD enter low pwr mode */
-				spin_lock_irq(&amp;ehci-&gt;lock);
-				t3 = ehci_readl(ehci, hostpc_reg);
-				ehci_writel(ehci, t3 | HOSTPC_PHCD, hostpc_reg);
-				t3 = ehci_readl(ehci, hostpc_reg);
-				ehci_dbg(ehci, "Port%d phy low pwr mode %s\n",
+	if (changed &amp;&amp; ehci-&gt;has_hostpc) {
+		spin_unlock_irq(&amp;ehci-&gt;lock);
+		msleep(5);	/* 5 ms for HCD to enter low-power mode */
+		spin_lock_irq(&amp;ehci-&gt;lock);
+
+		port = HCS_N_PORTS(ehci-&gt;hcs_params);
+		while (port--) {
+			u32 __iomem	*hostpc_reg;
+			u32		t3;
+
+			hostpc_reg = (u32 __iomem *)((u8 *) ehci-&gt;regs
+					+ HOSTPC0 + 4 * port);
+			t3 = ehci_readl(ehci, hostpc_reg);
+			ehci_writel(ehci, t3 | HOSTPC_PHCD, hostpc_reg);
+			t3 = ehci_readl(ehci, hostpc_reg);
+			ehci_dbg(ehci, "Port %d phy low-power mode %s\n",
 					port, (t3 &amp; HOSTPC_PHCD) ?
 					"succeeded" : "failed");
-			}
 		}
 	}
 
@@ -291,19 +357,28 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 	msleep(8);
 	spin_lock_irq(&amp;ehci-&gt;lock);
 
+	/* clear phy low-power mode before resume */
+	if (ehci-&gt;bus_suspended &amp;&amp; ehci-&gt;has_hostpc) {
+		i = HCS_N_PORTS(ehci-&gt;hcs_params);
+		while (i--) {
+			if (test_bit(i, &amp;ehci-&gt;bus_suspended)) {
+				u32 __iomem	*hostpc_reg;
+
+				hostpc_reg = (u32 __iomem *)((u8 *) ehci-&gt;regs
+						+ HOSTPC0 + 4 * i);
+				temp = ehci_readl(ehci, hostpc_reg);
+				ehci_writel(ehci, temp &amp; ~HOSTPC_PHCD,
+						hostpc_reg);
+			}
+		}
+		spin_unlock_irq(&amp;ehci-&gt;lock);
+		msleep(5);
+		spin_lock_irq(&amp;ehci-&gt;lock);
+	}
+
 	/* manually resume the ports we suspended during bus_suspend() */
 	i = HCS_N_PORTS (ehci-&gt;hcs_params);
 	while (i--) {
-		/* clear phy low power mode before resume */
-		if (ehci-&gt;has_hostpc) {
-			u32 __iomem	*hostpc_reg =
-				(u32 __iomem *)((u8 *)ehci-&gt;regs
-				+ HOSTPC0 + 4 * (i &amp; 0xff));
-			temp = ehci_readl(ehci, hostpc_reg);
-			ehci_writel(ehci, temp &amp; ~HOSTPC_PHCD,
-				hostpc_reg);
-			mdelay(5);
-		}
 		temp = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;port_status [i]);
 		temp &amp;= ~(PORT_RWC_BITS | PORT_WAKE_BITS);
 		if (test_bit(i, &amp;ehci-&gt;bus_suspended) &amp;&amp;
@@ -685,23 +760,25 @@ static int ehci_hub_control (
 				goto error;
 			if (ehci-&gt;no_selective_suspend)
 				break;
-			if (temp &amp; PORT_SUSPEND) {
-				if ((temp &amp; PORT_PE) == 0)
-					goto error;
-				/* clear phy low power mode before resume */
-				if (hostpc_reg) {
-					temp1 = ehci_readl(ehci, hostpc_reg);
-					ehci_writel(ehci, temp1 &amp; ~HOSTPC_PHCD,
+			if (!(temp &amp; PORT_SUSPEND))
+				break;
+			if ((temp &amp; PORT_PE) == 0)
+				goto error;
+
+			/* clear phy low-power mode before resume */
+			if (hostpc_reg) {
+				temp1 = ehci_readl(ehci, hostpc_reg);
+				ehci_writel(ehci, temp1 &amp; ~HOSTPC_PHCD,
 						hostpc_reg);
-					mdelay(5);
-				}
-				/* resume signaling for 20 msec */
-				temp &amp;= ~(PORT_RWC_BITS | PORT_WAKE_BITS);
-				ehci_writel(ehci, temp | PORT_RESUME,
-						status_reg);
-				ehci-&gt;reset_done [wIndex] = jiffies
-						+ msecs_to_jiffies (20);
+				spin_unlock_irqrestore(&amp;ehci-&gt;lock, flags);
+				msleep(5);/* wait to leave low-power mode */
+				spin_lock_irqsave(&amp;ehci-&gt;lock, flags);
 			}
+			/* resume signaling for 20 msec */
+			temp &amp;= ~(PORT_RWC_BITS | PORT_WAKE_BITS);
+			ehci_writel(ehci, temp | PORT_RESUME, status_reg);
+			ehci-&gt;reset_done[wIndex] = jiffies
+					+ msecs_to_jiffies(20);
 			break;
 		case USB_PORT_FEAT_C_SUSPEND:
 			clear_bit(wIndex, &amp;ehci-&gt;port_c_suspend);
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index d120059bbbf7..d43d176161aa 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -287,23 +287,15 @@ static int ehci_pci_suspend(struct usb_hcd *hcd)
 		msleep(10);
 
 	/* Root hub was already suspended. Disable irq emission and
-	 * mark HW unaccessible, bail out if RH has been resumed. Use
-	 * the spinlock to properly synchronize with possible pending
-	 * RH suspend or resume activity.
-	 *
-	 * This is still racy as hcd-&gt;state is manipulated outside of
-	 * any locks =P But that will be a different fix.
+	 * mark HW unaccessible.  The PM and USB cores make sure that
+	 * the root hub is either suspended or stopped.
 	 */
 	spin_lock_irqsave (&amp;ehci-&gt;lock, flags);
-	if (hcd-&gt;state != HC_STATE_SUSPENDED) {
-		rc = -EINVAL;
-		goto bail;
-	}
+	ehci_prepare_ports_for_controller_suspend(ehci);
 	ehci_writel(ehci, 0, &amp;ehci-&gt;regs-&gt;intr_enable);
 	(void)ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;intr_enable);
 
 	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
- bail:
 	spin_unlock_irqrestore (&amp;ehci-&gt;lock, flags);
 
 	// could save FLADJ in case of Vaux power loss
@@ -333,6 +325,7 @@ static int ehci_pci_resume(struct usb_hcd *hcd, bool hibernated)
 				!hibernated) {
 		int	mask = INTR_MASK;
 
+		ehci_prepare_ports_for_controller_resume(ehci);
 		if (!hcd-&gt;self.root_hub-&gt;do_remote_wakeup)
 			mask &amp;= ~STS_PCD;
 		ehci_writel(ehci, mask, &amp;ehci-&gt;regs-&gt;intr_enable);
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 4ebe9ad209e4..650a687f2854 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -536,6 +536,16 @@ struct ehci_fstn {
 
 /*-------------------------------------------------------------------------*/
 
+/* Prepare the PORTSC wakeup flags during controller suspend/resume */
+
+#define ehci_prepare_ports_for_controller_suspend(ehci)		\
+		ehci_adjust_port_wakeup_flags(ehci, true);
+
+#define ehci_prepare_ports_for_controller_resume(ehci)		\
+		ehci_adjust_port_wakeup_flags(ehci, false);
+
+/*-------------------------------------------------------------------------*/
+
 #ifdef CONFIG_USB_EHCI_ROOT_HUB_TT
 
 /*</pre><hr><pre>commit 89842ae6515c49405e20c0629a6442b6885ad49d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 11 11:44:06 2010 -0400

    USB: fix interface runtime-PM settings
    
    This patch (as1379) reworks the logic for handling USB interface
    runtime-PM settings -- hopefully it's right this time!  The problem is
    that when a driver is unbound or binding fails, runtime PM for the
    interface always gets disabled.  But pm_runtime_disable() nests, so it
    shouldn't be called unless the interface was previously enabled for
    runtime PM.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Rob Duncan &lt;Robert.Duncan@exar.com&gt;
    Tested-by: Rob Duncan &lt;Robert.Duncan@exar.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 207146743ea7..ded550eda5d9 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -334,7 +334,8 @@ static int usb_probe_interface(struct device *dev)
 	usb_cancel_queued_reset(intf);
 
 	/* Unbound interfaces are always runtime-PM-disabled and -suspended */
-	pm_runtime_disable(dev);
+	if (driver-&gt;supports_autosuspend)
+		pm_runtime_disable(dev);
 	pm_runtime_set_suspended(dev);
 
 	usb_autosuspend_device(udev);
@@ -389,7 +390,8 @@ static int usb_unbind_interface(struct device *dev)
 	intf-&gt;needs_remote_wakeup = 0;
 
 	/* Unbound interfaces are always runtime-PM-disabled and -suspended */
-	pm_runtime_disable(dev);
+	if (driver-&gt;supports_autosuspend)
+		pm_runtime_disable(dev);
 	pm_runtime_set_suspended(dev);
 
 	/* Undo any residual pm_autopm_get_interface_* calls */
@@ -438,14 +440,17 @@ int usb_driver_claim_interface(struct usb_driver *driver,
 
 	iface-&gt;condition = USB_INTERFACE_BOUND;
 
-	/* Claimed interfaces are initially inactive (suspended).  They are
-	 * runtime-PM-enabled only if the driver has autosuspend support.
-	 * They are sensitive to their children's power states.
+	/* Claimed interfaces are initially inactive (suspended) and
+	 * runtime-PM-enabled, but only if the driver has autosuspend
+	 * support.  Otherwise they are marked active, to prevent the
+	 * device from being autosuspended, but left disabled.  In either
+	 * case they are sensitive to their children's power states.
 	 */
-	pm_runtime_set_suspended(dev);
 	pm_suspend_ignore_children(dev, false);
 	if (driver-&gt;supports_autosuspend)
 		pm_runtime_enable(dev);
+	else
+		pm_runtime_set_active(dev);
 
 	/* if interface was already added, bind now; else let
 	 * the future device_add() bind it, bypassing probe()</pre><hr><pre>commit 0ba169aff9181389f30f225ad92e113eeb2290b9
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed May 5 15:26:17 2010 -0400

    USB: simplify usb_sg_init()
    
    This patch (as1377) simplifies the code in usb_sg_init(), without
    changing its functionality.  It also removes a couple of unused fields
    from the usb_sg_request structure.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 63919b8abee1..a73e08fdab36 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -371,79 +371,64 @@ int usb_sg_init(struct usb_sg_request *io, struct usb_device *dev,
 	spin_lock_init(&amp;io-&gt;lock);
 	io-&gt;dev = dev;
 	io-&gt;pipe = pipe;
-	io-&gt;sg = sg;
-	io-&gt;nents = nents;
-	io-&gt;entries = nents;
 
-	/* initialize all the urbs we'll use */
 	if (dev-&gt;bus-&gt;sg_tablesize &gt; 0) {
-		io-&gt;urbs = kmalloc(sizeof *io-&gt;urbs, mem_flags);
 		use_sg = true;
+		io-&gt;entries = 1;
 	} else {
-		io-&gt;urbs = kmalloc(io-&gt;entries * sizeof *io-&gt;urbs, mem_flags);
 		use_sg = false;
+		io-&gt;entries = nents;
 	}
+
+	/* initialize all the urbs we'll use */
+	io-&gt;urbs = kmalloc(io-&gt;entries * sizeof *io-&gt;urbs, mem_flags);
 	if (!io-&gt;urbs)
 		goto nomem;
 
-	urb_flags = 0;
+	urb_flags = URB_NO_INTERRUPT;
 	if (usb_pipein(pipe))
 		urb_flags |= URB_SHORT_NOT_OK;
 
-	if (use_sg) {
-		io-&gt;urbs[0] = usb_alloc_urb(0, mem_flags);
-		if (!io-&gt;urbs[0]) {
-			io-&gt;entries = 0;
-			goto nomem;
-		}
-
-		io-&gt;urbs[0]-&gt;dev = NULL;
-		io-&gt;urbs[0]-&gt;pipe = pipe;
-		io-&gt;urbs[0]-&gt;interval = period;
-		io-&gt;urbs[0]-&gt;transfer_flags = urb_flags;
+	for_each_sg(sg, sg, io-&gt;entries, i) {
+		struct urb *urb;
+		unsigned len;
 
-		io-&gt;urbs[0]-&gt;complete = sg_complete;
-		io-&gt;urbs[0]-&gt;context = io;
-
-		/* A length of zero means transfer the whole sg list */
-		io-&gt;urbs[0]-&gt;transfer_buffer_length = length;
-		if (length == 0) {
-			for_each_sg(sg, sg, io-&gt;entries, i) {
-				io-&gt;urbs[0]-&gt;transfer_buffer_length +=
-					sg-&gt;length;
-			}
+		urb = usb_alloc_urb(0, mem_flags);
+		if (!urb) {
+			io-&gt;entries = i;
+			goto nomem;
 		}
-		io-&gt;urbs[0]-&gt;sg = sg;
-		io-&gt;urbs[0]-&gt;num_sgs = io-&gt;entries;
-		io-&gt;entries = 1;
-	} else {
-		urb_flags |= URB_NO_INTERRUPT;
-		for_each_sg(sg, sg, io-&gt;entries, i) {
-			unsigned len;
-
-			io-&gt;urbs[i] = usb_alloc_urb(0, mem_flags);
-			if (!io-&gt;urbs[i]) {
-				io-&gt;entries = i;
-				goto nomem;
+		io-&gt;urbs[i] = urb;
+
+		urb-&gt;dev = NULL;
+		urb-&gt;pipe = pipe;
+		urb-&gt;interval = period;
+		urb-&gt;transfer_flags = urb_flags;
+		urb-&gt;complete = sg_complete;
+		urb-&gt;context = io;
+		urb-&gt;sg = sg;
+
+		if (use_sg) {
+			/* There is no single transfer buffer */
+			urb-&gt;transfer_buffer = NULL;
+			urb-&gt;num_sgs = nents;
+
+			/* A length of zero means transfer the whole sg list */
+			len = length;
+			if (len == 0) {
+				for_each_sg(sg, sg, nents, i)
+					len += sg-&gt;length;
 			}
-
-			io-&gt;urbs[i]-&gt;dev = NULL;
-			io-&gt;urbs[i]-&gt;pipe = pipe;
-			io-&gt;urbs[i]-&gt;interval = period;
-			io-&gt;urbs[i]-&gt;transfer_flags = urb_flags;
-
-			io-&gt;urbs[i]-&gt;complete = sg_complete;
-			io-&gt;urbs[i]-&gt;context = io;
-
+		} else {
 			/*
 			 * Some systems can't use DMA; they use PIO instead.
 			 * For their sakes, transfer_buffer is set whenever
 			 * possible.
 			 */
 			if (!PageHighMem(sg_page(sg)))
-				io-&gt;urbs[i]-&gt;transfer_buffer = sg_virt(sg);
+				urb-&gt;transfer_buffer = sg_virt(sg);
 			else
-				io-&gt;urbs[i]-&gt;transfer_buffer = NULL;
+				urb-&gt;transfer_buffer = NULL;
 
 			len = sg-&gt;length;
 			if (length) {
@@ -452,12 +437,10 @@ int usb_sg_init(struct usb_sg_request *io, struct usb_device *dev,
 				if (length == 0)
 					io-&gt;entries = i + 1;
 			}
-			io-&gt;urbs[i]-&gt;transfer_buffer_length = len;
-
-			io-&gt;urbs[i]-&gt;sg = sg;
 		}
-		io-&gt;urbs[--i]-&gt;transfer_flags &amp;= ~URB_NO_INTERRUPT;
+		urb-&gt;transfer_buffer_length = len;
 	}
+	io-&gt;urbs[--i]-&gt;transfer_flags &amp;= ~URB_NO_INTERRUPT;
 
 	/* transaction state */
 	io-&gt;count = io-&gt;entries;
diff --git a/include/linux/usb.h b/include/linux/usb.h
index eec9e74f332f..ce07062ebc28 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1469,8 +1469,6 @@ struct usb_sg_request {
 
 	struct usb_device	*dev;
 	int			pipe;
-	struct scatterlist	*sg;
-	int			nents;
 
 	int			entries;
 	struct urb		**urbs;</pre><hr><pre>commit 85bcb5ee889e0ebb9154718939e049de265fcdfb
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Apr 30 16:35:37 2010 -0400

    USB: remove URB_NO_SETUP_DMA_MAP
    
    Now that URB_NO_SETUP_DMA_MAP is no longer in use, this patch (as1376)
    removes all references to it.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/Documentation/usb/dma.txt b/Documentation/usb/dma.txt
index a37e59cf2786..84ef865237db 100644
--- a/Documentation/usb/dma.txt
+++ b/Documentation/usb/dma.txt
@@ -16,11 +16,11 @@ OR:  they can now be DMA-aware.
   manage dma mappings for existing dma-ready buffers (see below).
 
 - URBs have an additional "transfer_dma" field, as well as a transfer_flags
-  bit saying if it's valid.  (Control requests also have "setup_dma" and a
-  corresponding transfer_flags bit.)
+  bit saying if it's valid.  (Control requests also have "setup_dma", but
+  drivers must not use it.)
 
-- "usbcore" will map those DMA addresses, if a DMA-aware driver didn't do
-  it first and set URB_NO_TRANSFER_DMA_MAP or URB_NO_SETUP_DMA_MAP.  HCDs
+- "usbcore" will map this DMA address, if a DMA-aware driver didn't do
+  it first and set URB_NO_TRANSFER_DMA_MAP.  HCDs
   don't manage dma mappings for URBs.
 
 - There's a new "generic DMA API", parts of which are usable by USB device
@@ -53,12 +53,6 @@ and effects like cache-trashing can impose subtle penalties.
   to use this type of memory ("dma-coherent"), and memory returned from
   kmalloc() will work just fine.
 
-  For control transfers you can use the buffer primitives or not for each
-  of the transfer buffer and setup buffer independently.  Set the flag bits
-  URB_NO_TRANSFER_DMA_MAP and URB_NO_SETUP_DMA_MAP to indicate which
-  buffers you have prepared.  For non-control transfers URB_NO_SETUP_DMA_MAP
-  is ignored.
-
   The memory buffer returned is "dma-coherent"; sometimes you might need to
   force a consistent memory access ordering by using memory barriers.  It's
   not using a streaming DMA mapping, so it's good for small transfers on
@@ -130,8 +124,8 @@ of Documentation/PCI/PCI-DMA-mapping.txt, titled "What memory is DMA-able?")
 	void usb_buffer_unmap (struct urb *urb);
 
   The calls manage urb-&gt;transfer_dma for you, and set URB_NO_TRANSFER_DMA_MAP
-  so that usbcore won't map or unmap the buffer.  The same goes for
-  urb-&gt;setup_dma and URB_NO_SETUP_DMA_MAP for control requests.
+  so that usbcore won't map or unmap the buffer.  They cannot be used for
+  setup_packet buffers in control requests.
 
 Note that several of those interfaces are currently commented out, since
 they don't have current users.  See the source code.  Other than the dmasync
diff --git a/drivers/staging/usbip/usbip_common.c b/drivers/staging/usbip/usbip_common.c
index e3fa4216c1cd..52408164036f 100644
--- a/drivers/staging/usbip/usbip_common.c
+++ b/drivers/staging/usbip/usbip_common.c
@@ -562,7 +562,7 @@ EXPORT_SYMBOL_GPL(sockfd_to_socket);
 /* there may be more cases to tweak the flags. */
 static unsigned int tweak_transfer_flags(unsigned int flags)
 {
-	flags &amp;= ~(URB_NO_TRANSFER_DMA_MAP|URB_NO_SETUP_DMA_MAP);
+	flags &amp;= ~URB_NO_TRANSFER_DMA_MAP;
 	return flags;
 }
 
diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 3aaee2811f01..0abc5c537f39 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1316,8 +1316,7 @@ static int map_urb_for_dma(struct usb_hcd *hcd, struct urb *urb,
 	 * or uses the provided scatter gather list for bulk.
 	 */
 
-	if (usb_endpoint_xfer_control(&amp;urb-&gt;ep-&gt;desc)
-	    &amp;&amp; !(urb-&gt;transfer_flags &amp; URB_NO_SETUP_DMA_MAP)) {
+	if (usb_endpoint_xfer_control(&amp;urb-&gt;ep-&gt;desc)) {
 		if (hcd-&gt;self.uses_dma) {
 			urb-&gt;setup_dma = dma_map_single(
 					hcd-&gt;self.controller,
diff --git a/include/linux/usb.h b/include/linux/usb.h
index a748815ee629..1eb4762d9ea8 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -953,7 +953,6 @@ extern int usb_disabled(void);
 #define URB_ISO_ASAP		0x0002	/* iso-only, urb-&gt;start_frame
 					 * ignored */
 #define URB_NO_TRANSFER_DMA_MAP	0x0004	/* urb-&gt;transfer_dma valid on submit */
-#define URB_NO_SETUP_DMA_MAP	0x0008	/* urb-&gt;setup_dma valid on submit */
 #define URB_NO_FSBR		0x0020	/* UHCI-specific */
 #define URB_ZERO_PACKET		0x0040	/* Finish bulk OUT with short packet */
 #define URB_NO_INTERRUPT	0x0080	/* HINT: no non-error interrupt
@@ -1049,12 +1048,8 @@ typedef void (*usb_complete_t)(struct urb *);
  * @setup_packet: Only used for control transfers, this points to eight bytes
  *	of setup data.  Control transfers always start by sending this data
  *	to the device.  Then transfer_buffer is read or written, if needed.
- * @setup_dma: For control transfers with URB_NO_SETUP_DMA_MAP set, the
- *	device driver has provided this DMA address for the setup packet.
- *	The host controller driver should use this in preference to
- *	setup_packet, but the HCD may chose to ignore the address if it must
- *	copy the setup packet into internal structures.  Therefore, setup_packet
- *	must always point to a valid buffer.
+ * @setup_dma: DMA pointer for the setup packet.  The caller must not use
+ *	this field; setup_packet must point to a valid buffer.
  * @start_frame: Returns the initial frame for isochronous transfers.
  * @number_of_packets: Lists the number of ISO transfer buffers.
  * @interval: Specifies the polling interval for interrupt or isochronous
@@ -1086,13 +1081,14 @@ typedef void (*usb_complete_t)(struct urb *);
  * bounce buffer or talking to an IOMMU),
  * although they're cheap on commodity x86 and ppc hardware.
  *
- * Alternatively, drivers may pass the URB_NO_xxx_DMA_MAP transfer flags,
- * which tell the host controller driver that no such mapping is needed since
+ * Alternatively, drivers may pass the URB_NO_TRANSFER_DMA_MAP transfer flag,
+ * which tells the host controller driver that no such mapping is needed for
+ * the transfer_buffer since
  * the device driver is DMA-aware.  For example, a device driver might
  * allocate a DMA buffer with usb_alloc_coherent() or call usb_buffer_map().
- * When these transfer flags are provided, host controller drivers will
- * attempt to use the dma addresses found in the transfer_dma and/or
- * setup_dma fields rather than determining a dma address themselves.
+ * When this transfer flag is provided, host controller drivers will
+ * attempt to use the dma address found in the transfer_dma
+ * field rather than determining a dma address themselves.
  *
  * Note that transfer_buffer must still be set if the controller
  * does not support DMA (as indicated by bus.uses_dma) and when talking
@@ -1115,11 +1111,9 @@ typedef void (*usb_complete_t)(struct urb *);
  * should always terminate with a short packet, even if it means adding an
  * extra zero length packet.
  *
- * Control URBs must provide a setup_packet.  The setup_packet and
- * transfer_buffer may each be mapped for DMA or not, independently of
- * the other.  The transfer_flags bits URB_NO_TRANSFER_DMA_MAP and
- * URB_NO_SETUP_DMA_MAP indicate which buffers have already been mapped.
- * URB_NO_SETUP_DMA_MAP is ignored for non-control URBs.
+ * Control URBs must provide a valid pointer in the setup_packet field.
+ * Unlike the transfer_buffer, the setup_packet may not be mapped for DMA
+ * beforehand.
  *
  * Interrupt URBs must provide an interval, saying how often (in milliseconds
  * or, for highspeed devices, 125 microsecond units)</pre><hr><pre>commit 842f16905dfc6743c1dd80c3d29b49ba3ab7f7c8
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Apr 30 12:44:46 2010 -0400

    USB: remove the usb_host_ss_ep_comp structure
    
    This patch (as1375) eliminates the usb_host_ss_ep_comp structure used
    for storing a dynamically-allocated copy of the SuperSpeed endpoint
    companion descriptor.  The SuperSpeed descriptor is placed directly in
    the usb_host_endpoint structure, alongside the standard endpoint
    descriptor.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Sarah Sharp &lt;sarah.a.sharp@linux.intel.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c
index e4909c26becb..83126b03e7cf 100644
--- a/drivers/usb/core/config.c
+++ b/drivers/usb/core/config.c
@@ -21,32 +21,6 @@ static inline const char *plural(int n)
 	return (n == 1 ? "" : "s");
 }
 
-/* FIXME: this is a kludge */
-static int find_next_descriptor_more(unsigned char *buffer, int size,
-    int dt1, int dt2, int dt3, int *num_skipped)
-{
-	struct usb_descriptor_header *h;
-	int n = 0;
-	unsigned char *buffer0 = buffer;
-
-	/* Find the next descriptor of type dt1 or dt2 or dt3 */
-	while (size &gt; 0) {
-		h = (struct usb_descriptor_header *) buffer;
-		if (h-&gt;bDescriptorType == dt1 || h-&gt;bDescriptorType == dt2 ||
-				h-&gt;bDescriptorType == dt3)
-			break;
-		buffer += h-&gt;bLength;
-		size -= h-&gt;bLength;
-		++n;
-	}
-
-	/* Store the number of descriptors skipped and return the
-	 * number of bytes skipped */
-	if (num_skipped)
-		*num_skipped = n;
-	return buffer - buffer0;
-}
-
 static int find_next_descriptor(unsigned char *buffer, int size,
     int dt1, int dt2, int *num_skipped)
 {
@@ -71,47 +45,41 @@ static int find_next_descriptor(unsigned char *buffer, int size,
 	return buffer - buffer0;
 }
 
-static int usb_parse_ss_endpoint_companion(struct device *ddev, int cfgno,
+static void usb_parse_ss_endpoint_companion(struct device *ddev, int cfgno,
 		int inum, int asnum, struct usb_host_endpoint *ep,
-		int num_ep, unsigned char *buffer, int size)
+		unsigned char *buffer, int size)
 {
-	unsigned char *buffer_start = buffer;
-	struct usb_ss_ep_comp_descriptor	*desc;
-	int retval;
-	int num_skipped;
+	struct usb_ss_ep_comp_descriptor *desc;
 	int max_tx;
-	int i;
 
+	/* The SuperSpeed endpoint companion descriptor is supposed to
+	 * be the first thing immediately following the endpoint descriptor.
+	 */
 	desc = (struct usb_ss_ep_comp_descriptor *) buffer;
-	if (desc-&gt;bDescriptorType != USB_DT_SS_ENDPOINT_COMP) {
+	if (desc-&gt;bDescriptorType != USB_DT_SS_ENDPOINT_COMP ||
+			size &lt; USB_DT_SS_EP_COMP_SIZE) {
 		dev_warn(ddev, "No SuperSpeed endpoint companion for config %d "
 				" interface %d altsetting %d ep %d: "
 				"using minimum values\n",
 				cfgno, inum, asnum, ep-&gt;desc.bEndpointAddress);
-		/*
-		 * The next descriptor is for an Endpoint or Interface,
-		 * no extra descriptors to copy into the companion structure,
-		 * and we didn't eat up any of the buffer.
+
+		/* Fill in some default values.
+		 * Leave bmAttributes as zero, which will mean no streams for
+		 * bulk, and isoc won't support multiple bursts of packets.
+		 * With bursts of only one packet, and a Mult of 1, the max
+		 * amount of data moved per endpoint service interval is one
+		 * packet.
 		 */
-		return 0;
+		ep-&gt;ss_ep_comp.bLength = USB_DT_SS_EP_COMP_SIZE;
+		ep-&gt;ss_ep_comp.bDescriptorType = USB_DT_SS_ENDPOINT_COMP;
+		if (usb_endpoint_xfer_isoc(&amp;ep-&gt;desc) ||
+				usb_endpoint_xfer_int(&amp;ep-&gt;desc))
+			ep-&gt;ss_ep_comp.wBytesPerInterval =
+					ep-&gt;desc.wMaxPacketSize;
+		return;
 	}
-	memcpy(&amp;ep-&gt;ss_ep_comp-&gt;desc, desc, USB_DT_SS_EP_COMP_SIZE);
-	desc = &amp;ep-&gt;ss_ep_comp-&gt;desc;
-	buffer += desc-&gt;bLength;
-	size -= desc-&gt;bLength;
 
-	/* Eat up the other descriptors we don't care about */
-	ep-&gt;ss_ep_comp-&gt;extra = buffer;
-	i = find_next_descriptor(buffer, size, USB_DT_ENDPOINT,
-			USB_DT_INTERFACE, &amp;num_skipped);
-	ep-&gt;ss_ep_comp-&gt;extralen = i;
-	buffer += i;
-	size -= i;
-	retval = buffer - buffer_start;
-	if (num_skipped &gt; 0)
-		dev_dbg(ddev, "skipped %d descriptor%s after %s\n",
-				num_skipped, plural(num_skipped),
-				"SuperSpeed endpoint companion");
+	memcpy(&amp;ep-&gt;ss_ep_comp, desc, USB_DT_SS_EP_COMP_SIZE);
 
 	/* Check the various values */
 	if (usb_endpoint_xfer_control(&amp;ep-&gt;desc) &amp;&amp; desc-&gt;bMaxBurst != 0) {
@@ -119,47 +87,48 @@ static int usb_parse_ss_endpoint_companion(struct device *ddev, int cfgno,
 				"config %d interface %d altsetting %d ep %d: "
 				"setting to zero\n", desc-&gt;bMaxBurst,
 				cfgno, inum, asnum, ep-&gt;desc.bEndpointAddress);
-		desc-&gt;bMaxBurst = 0;
-	}
-	if (desc-&gt;bMaxBurst &gt; 15) {
+		ep-&gt;ss_ep_comp.bMaxBurst = 0;
+	} else if (desc-&gt;bMaxBurst &gt; 15) {
 		dev_warn(ddev, "Endpoint with bMaxBurst = %d in "
 				"config %d interface %d altsetting %d ep %d: "
 				"setting to 15\n", desc-&gt;bMaxBurst,
 				cfgno, inum, asnum, ep-&gt;desc.bEndpointAddress);
-		desc-&gt;bMaxBurst = 15;
+		ep-&gt;ss_ep_comp.bMaxBurst = 15;
 	}
-	if ((usb_endpoint_xfer_control(&amp;ep-&gt;desc) || usb_endpoint_xfer_int(&amp;ep-&gt;desc))
-			&amp;&amp; desc-&gt;bmAttributes != 0) {
+
+	if ((usb_endpoint_xfer_control(&amp;ep-&gt;desc) ||
+			usb_endpoint_xfer_int(&amp;ep-&gt;desc)) &amp;&amp;
+				desc-&gt;bmAttributes != 0) {
 		dev_warn(ddev, "%s endpoint with bmAttributes = %d in "
 				"config %d interface %d altsetting %d ep %d: "
 				"setting to zero\n",
 				usb_endpoint_xfer_control(&amp;ep-&gt;desc) ? "Control" : "Bulk",
 				desc-&gt;bmAttributes,
 				cfgno, inum, asnum, ep-&gt;desc.bEndpointAddress);
-		desc-&gt;bmAttributes = 0;
-	}
-	if (usb_endpoint_xfer_bulk(&amp;ep-&gt;desc) &amp;&amp; desc-&gt;bmAttributes &gt; 16) {
+		ep-&gt;ss_ep_comp.bmAttributes = 0;
+	} else if (usb_endpoint_xfer_bulk(&amp;ep-&gt;desc) &amp;&amp;
+			desc-&gt;bmAttributes &gt; 16) {
 		dev_warn(ddev, "Bulk endpoint with more than 65536 streams in "
 				"config %d interface %d altsetting %d ep %d: "
 				"setting to max\n",
 				cfgno, inum, asnum, ep-&gt;desc.bEndpointAddress);
-		desc-&gt;bmAttributes = 16;
-	}
-	if (usb_endpoint_xfer_isoc(&amp;ep-&gt;desc) &amp;&amp; desc-&gt;bmAttributes &gt; 2) {
+		ep-&gt;ss_ep_comp.bmAttributes = 16;
+	} else if (usb_endpoint_xfer_isoc(&amp;ep-&gt;desc) &amp;&amp;
+			desc-&gt;bmAttributes &gt; 2) {
 		dev_warn(ddev, "Isoc endpoint has Mult of %d in "
 				"config %d interface %d altsetting %d ep %d: "
 				"setting to 3\n", desc-&gt;bmAttributes + 1,
 				cfgno, inum, asnum, ep-&gt;desc.bEndpointAddress);
-		desc-&gt;bmAttributes = 2;
+		ep-&gt;ss_ep_comp.bmAttributes = 2;
 	}
-	if (usb_endpoint_xfer_isoc(&amp;ep-&gt;desc)) {
+
+	if (usb_endpoint_xfer_isoc(&amp;ep-&gt;desc))
 		max_tx = ep-&gt;desc.wMaxPacketSize * (desc-&gt;bMaxBurst + 1) *
 			(desc-&gt;bmAttributes + 1);
-	} else if (usb_endpoint_xfer_int(&amp;ep-&gt;desc)) {
+	else if (usb_endpoint_xfer_int(&amp;ep-&gt;desc))
 		max_tx = ep-&gt;desc.wMaxPacketSize * (desc-&gt;bMaxBurst + 1);
-	} else {
-		goto valid;
-	}
+	else
+		max_tx = 999999;
 	if (desc-&gt;wBytesPerInterval &gt; max_tx) {
 		dev_warn(ddev, "%s endpoint with wBytesPerInterval of %d in "
 				"config %d interface %d altsetting %d ep %d: "
@@ -168,10 +137,8 @@ static int usb_parse_ss_endpoint_companion(struct device *ddev, int cfgno,
 				desc-&gt;wBytesPerInterval,
 				cfgno, inum, asnum, ep-&gt;desc.bEndpointAddress,
 				max_tx);
-		desc-&gt;wBytesPerInterval = max_tx;
+		ep-&gt;ss_ep_comp.wBytesPerInterval = max_tx;
 	}
-valid:
-	return retval;
 }
 
 static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,
@@ -293,61 +260,19 @@ static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,
 				cfgno, inum, asnum, d-&gt;bEndpointAddress,
 				maxp);
 	}
-	/* Allocate room for and parse any SS endpoint companion descriptors */
-	if (to_usb_device(ddev)-&gt;speed == USB_SPEED_SUPER) {
-		endpoint-&gt;extra = buffer;
-		i = find_next_descriptor_more(buffer, size, USB_DT_SS_ENDPOINT_COMP,
-				USB_DT_ENDPOINT, USB_DT_INTERFACE, &amp;n);
-		endpoint-&gt;extralen = i;
-		buffer += i;
-		size -= i;
-
-		/* Allocate space for the SS endpoint companion descriptor */
-		endpoint-&gt;ss_ep_comp = kzalloc(sizeof(struct usb_host_ss_ep_comp),
-				GFP_KERNEL);
-		if (!endpoint-&gt;ss_ep_comp)
-			return -ENOMEM;
 
-		/* Fill in some default values (may be overwritten later) */
-		endpoint-&gt;ss_ep_comp-&gt;desc.bLength = USB_DT_SS_EP_COMP_SIZE;
-		endpoint-&gt;ss_ep_comp-&gt;desc.bDescriptorType = USB_DT_SS_ENDPOINT_COMP;
-		endpoint-&gt;ss_ep_comp-&gt;desc.bMaxBurst = 0;
-		/*
-		 * Leave bmAttributes as zero, which will mean no streams for
-		 * bulk, and isoc won't support multiple bursts of packets.
-		 * With bursts of only one packet, and a Mult of 1, the max
-		 * amount of data moved per endpoint service interval is one
-		 * packet.
-		 */
-		if (usb_endpoint_xfer_isoc(&amp;endpoint-&gt;desc) ||
-				usb_endpoint_xfer_int(&amp;endpoint-&gt;desc))
-			endpoint-&gt;ss_ep_comp-&gt;desc.wBytesPerInterval =
-				endpoint-&gt;desc.wMaxPacketSize;
-
-		if (size &gt; 0) {
-			retval = usb_parse_ss_endpoint_companion(ddev, cfgno,
-					inum, asnum, endpoint, num_ep, buffer,
-					size);
-			if (retval &gt;= 0) {
-				buffer += retval;
-				retval = buffer - buffer0;
-			}
-		} else {
-			dev_warn(ddev, "config %d interface %d altsetting %d "
-				"endpoint 0x%X has no "
-				"SuperSpeed companion descriptor\n",
-				cfgno, inum, asnum, d-&gt;bEndpointAddress);
-			retval = buffer - buffer0;
-		}
-	} else {
-		/* Skip over any Class Specific or Vendor Specific descriptors;
-		 * find the next endpoint or interface descriptor */
-		endpoint-&gt;extra = buffer;
-		i = find_next_descriptor(buffer, size, USB_DT_ENDPOINT,
-				USB_DT_INTERFACE, &amp;n);
-		endpoint-&gt;extralen = i;
-		retval = buffer - buffer0 + i;
-	}
+	/* Parse a possible SuperSpeed endpoint companion descriptor */
+	if (to_usb_device(ddev)-&gt;speed == USB_SPEED_SUPER)
+		usb_parse_ss_endpoint_companion(ddev, cfgno,
+				inum, asnum, endpoint, buffer, size);
+
+	/* Skip over any Class Specific or Vendor Specific descriptors;
+	 * find the next endpoint or interface descriptor */
+	endpoint-&gt;extra = buffer;
+	i = find_next_descriptor(buffer, size, USB_DT_ENDPOINT,
+			USB_DT_INTERFACE, &amp;n);
+	endpoint-&gt;extralen = i;
+	retval = buffer - buffer0 + i;
 	if (n &gt; 0)
 		dev_dbg(ddev, "skipped %d descriptor%s after %s\n",
 		    n, plural(n), "endpoint");
diff --git a/drivers/usb/host/xhci-mem.c b/drivers/usb/host/xhci-mem.c
index 4df752cb0f78..fd9e03afd91c 100644
--- a/drivers/usb/host/xhci-mem.c
+++ b/drivers/usb/host/xhci-mem.c
@@ -1010,9 +1010,9 @@ static inline unsigned int xhci_get_endpoint_interval(struct usb_device *udev,
 static inline u32 xhci_get_endpoint_mult(struct usb_device *udev,
 		struct usb_host_endpoint *ep)
 {
-	if (udev-&gt;speed != USB_SPEED_SUPER || !ep-&gt;ss_ep_comp)
+	if (udev-&gt;speed != USB_SPEED_SUPER)
 		return 0;
-	return ep-&gt;ss_ep_comp-&gt;desc.bmAttributes;
+	return ep-&gt;ss_ep_comp.bmAttributes;
 }
 
 static inline u32 xhci_get_endpoint_type(struct usb_device *udev,
@@ -1061,13 +1061,8 @@ static inline u32 xhci_get_max_esit_payload(struct xhci_hcd *xhci,
 			usb_endpoint_xfer_bulk(&amp;ep-&gt;desc))
 		return 0;
 
-	if (udev-&gt;speed == USB_SPEED_SUPER) {
-		if (ep-&gt;ss_ep_comp)
-			return ep-&gt;ss_ep_comp-&gt;desc.wBytesPerInterval;
-		xhci_warn(xhci, "WARN no SS endpoint companion descriptor.\n");
-		/* Assume no bursts, no multiple opportunities to send. */
-		return ep-&gt;desc.wMaxPacketSize;
-	}
+	if (udev-&gt;speed == USB_SPEED_SUPER)
+		return ep-&gt;ss_ep_comp.wBytesPerInterval;
 
 	max_packet = ep-&gt;desc.wMaxPacketSize &amp; 0x3ff;
 	max_burst = (ep-&gt;desc.wMaxPacketSize &amp; 0x1800) &gt;&gt; 11;
@@ -1131,12 +1126,9 @@ int xhci_endpoint_init(struct xhci_hcd *xhci,
 		max_packet = ep-&gt;desc.wMaxPacketSize;
 		ep_ctx-&gt;ep_info2 |= MAX_PACKET(max_packet);
 		/* dig out max burst from ep companion desc */
-		if (!ep-&gt;ss_ep_comp) {
-			xhci_warn(xhci, "WARN no SS endpoint companion descriptor.\n");
-			max_packet = 0;
-		} else {
-			max_packet = ep-&gt;ss_ep_comp-&gt;desc.bMaxBurst;
-		}
+		max_packet = ep-&gt;ss_ep_comp.bMaxBurst;
+		if (!max_packet)
+			xhci_warn(xhci, "WARN no SS endpoint bMaxBurst\n");
 		ep_ctx-&gt;ep_info2 |= MAX_BURST(max_packet);
 		break;
 	case USB_SPEED_HIGH:
diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c
index 3cac2ff8b50a..59f38a5f2fe6 100644
--- a/drivers/usb/host/xhci.c
+++ b/drivers/usb/host/xhci.c
@@ -1476,13 +1476,7 @@ static int xhci_check_streams_endpoint(struct xhci_hcd *xhci,
 	ret = xhci_check_args(xhci_to_hcd(xhci), udev, ep, 1, __func__);
 	if (ret &lt;= 0)
 		return -EINVAL;
-	if (!ep-&gt;ss_ep_comp) {
-		xhci_warn(xhci, "WARN: No SuperSpeed Endpoint Companion"
-				" descriptor for ep 0x%x\n",
-				ep-&gt;desc.bEndpointAddress);
-		return -EINVAL;
-	}
-	if (ep-&gt;ss_ep_comp-&gt;desc.bmAttributes == 0) {
+	if (ep-&gt;ss_ep_comp.bmAttributes == 0) {
 		xhci_warn(xhci, "WARN: SuperSpeed Endpoint Companion"
 				" descriptor for ep 0x%x does not support streams\n",
 				ep-&gt;desc.bEndpointAddress);
@@ -1540,7 +1534,6 @@ static int xhci_calculate_streams_and_bitmask(struct xhci_hcd *xhci,
 		struct usb_host_endpoint **eps, unsigned int num_eps,
 		unsigned int *num_streams, u32 *changed_ep_bitmask)
 {
-	struct usb_host_ss_ep_comp *ss_ep_comp;
 	unsigned int max_streams;
 	unsigned int endpoint_flag;
 	int i;
@@ -1552,8 +1545,8 @@ static int xhci_calculate_streams_and_bitmask(struct xhci_hcd *xhci,
 		if (ret &lt; 0)
 			return ret;
 
-		ss_ep_comp = eps[i]-&gt;ss_ep_comp;
-		max_streams = USB_SS_MAX_STREAMS(ss_ep_comp-&gt;desc.bmAttributes);
+		max_streams = USB_SS_MAX_STREAMS(
+				eps[i]-&gt;ss_ep_comp.bmAttributes);
 		if (max_streams &lt; (*num_streams - 1)) {
 			xhci_dbg(xhci, "Ep 0x%x only supports %u stream IDs.\n",
 					eps[i]-&gt;desc.bEndpointAddress,
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 1ea25377ca0d..a748815ee629 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -45,27 +45,14 @@ struct wusb_dev;
 
 struct ep_device;
 
-/* For SS devices */
-/**
- * struct usb_host_ss_ep_comp - Valid for SuperSpeed devices only
- * @desc: endpoint companion descriptor, wMaxPacketSize in native byteorder
- * @extra: descriptors following this endpoint companion descriptor
- * @extralen: how many bytes of "extra" are valid
- */
-struct usb_host_ss_ep_comp {
-	struct usb_ss_ep_comp_descriptor	desc;
-	unsigned char				*extra;   /* Extra descriptors */
-	int					extralen;
-};
-
 /**
  * struct usb_host_endpoint - host-side endpoint descriptor and queue
  * @desc: descriptor for this endpoint, wMaxPacketSize in native byteorder
+ * @ss_ep_comp: SuperSpeed companion descriptor for this endpoint
  * @urb_list: urbs queued to this endpoint; maintained by usbcore
  * @hcpriv: for use by HCD; typically holds hardware dma queue head (QH)
  *	with one or more transfer descriptors (TDs) per urb
  * @ep_dev: ep_device for sysfs info
- * @ss_ep_comp: companion descriptor information for this endpoint
  * @extra: descriptors following this endpoint in the configuration
  * @extralen: how many bytes of "extra" are valid
  * @enabled: URBs may be submitted to this endpoint
@@ -74,11 +61,11 @@ struct usb_host_ss_ep_comp {
  * descriptor within an active interface in a given USB configuration.
  */
 struct usb_host_endpoint {
-	struct usb_endpoint_descriptor	desc;
+	struct usb_endpoint_descriptor		desc;
+	struct usb_ss_ep_comp_descriptor	ss_ep_comp;
 	struct list_head		urb_list;
 	void				*hcpriv;
 	struct ep_device 		*ep_dev;	/* For sysfs info */
-	struct usb_host_ss_ep_comp	*ss_ep_comp;	/* For SS devices */
 
 	unsigned char *extra;   /* Extra descriptors */
 	int extralen;</pre><hr><pre>commit 3b02ca3218cf878e206545041aa811073e4f6c79
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Apr 30 12:42:23 2010 -0400

    USB: export the new ch11.h file to userspce
    
    This patch (as1374) cleans up a few loose ends in the
    include/linux/usb/ch11.h header file and exports it to userspace.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: Eric Lescouet &lt;Eric.Lescouet@virtuallogix.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/include/linux/usb/Kbuild b/include/linux/usb/Kbuild
index 29fd73b0bffc..51410e0200cf 100644
--- a/include/linux/usb/Kbuild
+++ b/include/linux/usb/Kbuild
@@ -1,6 +1,7 @@
 header-y += audio.h
 header-y += cdc.h
 header-y += ch9.h
+header-y += ch11.h
 header-y += gadgetfs.h
 header-y += midi.h
 header-y += g_printer.h
diff --git a/include/linux/usb/ch11.h b/include/linux/usb/ch11.h
index bd3185aba4ee..119194c85d10 100644
--- a/include/linux/usb/ch11.h
+++ b/include/linux/usb/ch11.h
@@ -6,12 +6,10 @@
  * drivers.
  */
 
-#ifndef __LINUX_HUB_H
-#define __LINUX_HUB_H
+#ifndef __LINUX_CH11_H
+#define __LINUX_CH11_H
 
-#include &lt;linux/list.h&gt;
-#include &lt;linux/workqueue.h&gt;
-#include &lt;linux/compiler.h&gt;	/* likely()/unlikely() */
+#include &lt;linux/types.h&gt;	/* __u8 etc */
 
 /*
  * Hub request types
@@ -166,4 +164,4 @@ enum hub_led_mode {
 #define HUB_TTTT_24_BITS	0x40
 #define HUB_TTTT_32_BITS	0x60
 
-#endif /* __LINUX_HUB_H */
+#endif /* __LINUX_CH11_H */</pre><hr><pre>commit beb7b04a09a9da8b12417f7b74fbcceedb087fc3
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Apr 30 12:14:04 2010 -0400

    USB: remove leftover references to udev-&gt;autosuspend_disabled
    
    This patch (as1373) fixes a couple of drivers outside the USB
    subtree.  Devices are now disabled or enabled for autosuspend by
    calling a core function instead of setting a flag.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: Stephen Rothwell &lt;sfr@canb.auug.org.au&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/media/video/tlg2300/pd-main.c b/drivers/media/video/tlg2300/pd-main.c
index 2cf0ebf9f28b..a6400dad12ae 100644
--- a/drivers/media/video/tlg2300/pd-main.c
+++ b/drivers/media/video/tlg2300/pd-main.c
@@ -455,8 +455,8 @@ static int poseidon_probe(struct usb_interface *interface,
 
 	device_init_wakeup(&amp;udev-&gt;dev, 1);
 #ifdef CONFIG_PM
-	pd-&gt;udev-&gt;autosuspend_disabled = 0;
 	pd-&gt;udev-&gt;autosuspend_delay = HZ * PM_SUSPEND_DELAY;
+	usb_enable_autosuspend(pd-&gt;udev);
 
 	if (in_hibernation(pd)) {
 		INIT_WORK(&amp;pd-&gt;pm_work, hibernation_resume);
diff --git a/drivers/net/wimax/i2400m/usb.c b/drivers/net/wimax/i2400m/usb.c
index d8c4d6497fdf..d555e37a665c 100644
--- a/drivers/net/wimax/i2400m/usb.c
+++ b/drivers/net/wimax/i2400m/usb.c
@@ -505,7 +505,7 @@ int i2400mu_probe(struct usb_interface *iface,
 	iface-&gt;needs_remote_wakeup = 1;		/* autosuspend (15s delay) */
 	device_init_wakeup(dev, 1);
 	usb_dev-&gt;autosuspend_delay = 15 * HZ;
-	usb_dev-&gt;autosuspend_disabled = 0;
+	usb_enable_autosuspend(usb_dev);
 #endif
 
 	result = i2400m_setup(i2400m, I2400M_BRI_MAC_REINIT);</pre><hr><pre>commit a90309860b0935805d49e75499fb8dc59fea8e94
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Apr 2 13:22:16 2010 -0400

    USB: deprecate the power/level sysfs attribute
    
    This patch (as1367) deprecates USB's power/level sysfs attribute in
    favor of the power/control attribute provided by the runtime PM core.
    The two attributes do the same thing.
    
    It would be nice to replace power/level with a symlink to
    power/control, but at the moment sysfs doesn't offer any way to do so.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/Documentation/ABI/obsolete/sysfs-bus-usb b/Documentation/ABI/obsolete/sysfs-bus-usb
new file mode 100644
index 000000000000..bd096d33fbc7
--- /dev/null
+++ b/Documentation/ABI/obsolete/sysfs-bus-usb
@@ -0,0 +1,31 @@
+What:		/sys/bus/usb/devices/.../power/level
+Date:		March 2007
+KernelVersion:	2.6.21
+Contact:	Alan Stern &lt;stern@rowland.harvard.edu&gt;
+Description:
+		Each USB device directory will contain a file named
+		power/level.  This file holds a power-level setting for
+		the device, either "on" or "auto".
+
+		"on" means that the device is not allowed to autosuspend,
+		although normal suspends for system sleep will still
+		be honored.  "auto" means the device will autosuspend
+		and autoresume in the usual manner, according to the
+		capabilities of its driver.
+
+		During normal use, devices should be left in the "auto"
+		level.  The "on" level is meant for administrative uses.
+		If you want to suspend a device immediately but leave it
+		free to wake up in response to I/O requests, you should
+		write "0" to power/autosuspend.
+
+		Device not capable of proper suspend and resume should be
+		left in the "on" level.  Although the USB spec requires
+		devices to support suspend/resume, many of them do not.
+		In fact so many don't that by default, the USB core
+		initializes all non-hub devices in the "on" level.  Some
+		drivers may change this setting when they are bound.
+
+		This file is deprecated and will be removed after 2010.
+		Use the power/control file instead; it does exactly the
+		same thing.
diff --git a/Documentation/ABI/testing/sysfs-bus-usb b/Documentation/ABI/testing/sysfs-bus-usb
index bcebb9eaedce..294aa864a60a 100644
--- a/Documentation/ABI/testing/sysfs-bus-usb
+++ b/Documentation/ABI/testing/sysfs-bus-usb
@@ -14,34 +14,6 @@ Description:
 		The autosuspend delay for newly-created devices is set to
 		the value of the usbcore.autosuspend module parameter.
 
-What:		/sys/bus/usb/devices/.../power/level
-Date:		March 2007
-KernelVersion:	2.6.21
-Contact:	Alan Stern &lt;stern@rowland.harvard.edu&gt;
-Description:
-		Each USB device directory will contain a file named
-		power/level.  This file holds a power-level setting for
-		the device, either "on" or "auto".
-
-		"on" means that the device is not allowed to autosuspend,
-		although normal suspends for system sleep will still
-		be honored.  "auto" means the device will autosuspend
-		and autoresume in the usual manner, according to the
-		capabilities of its driver.
-
-		During normal use, devices should be left in the "auto"
-		level.  The "on" level is meant for administrative uses.
-		If you want to suspend a device immediately but leave it
-		free to wake up in response to I/O requests, you should
-		write "0" to power/autosuspend.
-
-		Device not capable of proper suspend and resume should be
-		left in the "on" level.  Although the USB spec requires
-		devices to support suspend/resume, many of them do not.
-		In fact so many don't that by default, the USB core
-		initializes all non-hub devices in the "on" level.  Some
-		drivers may change this setting when they are bound.
-
 What:		/sys/bus/usb/devices/.../power/persist
 Date:		May 2007
 KernelVersion:	2.6.23
diff --git a/Documentation/usb/power-management.txt b/Documentation/usb/power-management.txt
index 2790ad48cfc2..b29d8e56cf28 100644
--- a/Documentation/usb/power-management.txt
+++ b/Documentation/usb/power-management.txt
@@ -107,7 +107,9 @@ allowed to issue dynamic suspends.
 The user interface for controlling dynamic PM is located in the power/
 subdirectory of each USB device's sysfs directory, that is, in
 /sys/bus/usb/devices/.../power/ where "..." is the device's ID.  The
-relevant attribute files are: wakeup, level, and autosuspend.
+relevant attribute files are: wakeup, control, and autosuspend.
+(There may also be a file named "level"; this file was deprecated
+as of the 2.6.35 kernel and replaced by the "control" file.)
 
 	power/wakeup
 
@@ -120,7 +122,7 @@ relevant attribute files are: wakeup, level, and autosuspend.
 		while the device is suspended, the change won't take
 		effect until the following suspend.)
 
-	power/level
+	power/control
 
 		This file contains one of two words: "on" or "auto".
 		You can write those words to the file to change the
@@ -148,14 +150,15 @@ relevant attribute files are: wakeup, level, and autosuspend.
 		never to autosuspend.  You can write a number to the
 		file to change the autosuspend idle-delay time.
 
-Writing "-1" to power/autosuspend and writing "on" to power/level do
+Writing "-1" to power/autosuspend and writing "on" to power/control do
 essentially the same thing -- they both prevent the device from being
 autosuspended.  Yes, this is a redundancy in the API.
 
 (In 2.6.21 writing "0" to power/autosuspend would prevent the device
 from being autosuspended; the behavior was changed in 2.6.22.  The
 power/autosuspend attribute did not exist prior to 2.6.21, and the
-power/level attribute did not exist prior to 2.6.22.)
+power/level attribute did not exist prior to 2.6.22.  power/control
+was added in 2.6.34.)
 
 
 	Changing the default idle-delay time
@@ -212,7 +215,7 @@ among printers and scanners, but plenty of other types of device have
 the same deficiency.
 
 For this reason, by default the kernel disables autosuspend (the
-power/level attribute is initialized to "on") for all devices other
+power/control attribute is initialized to "on") for all devices other
 than hubs.  Hubs, at least, appear to be reasonably well-behaved in
 this regard.
 
@@ -373,7 +376,7 @@ usb_autopm_put_interface() in its close or release routine.  But other
 patterns are possible.
 
 The autosuspend attempts mentioned above will often fail for one
-reason or another.  For example, the power/level attribute might be
+reason or another.  For example, the power/control attribute might be
 set to "on", or another interface in the same device might not be
 idle.  This is perfectly normal.  If the reason for failure was that
 the device hasn't been idle for long enough, a timer is scheduled to
@@ -394,12 +397,12 @@ Drivers can enable autosuspend for their devices by calling
 
 in their probe() routine, if they know that the device is capable of
 suspending and resuming correctly.  This is exactly equivalent to
-writing "auto" to the device's power/level attribute.  Likewise,
+writing "auto" to the device's power/control attribute.  Likewise,
 drivers can disable autosuspend by calling
 
 	usb_disable_autosuspend(struct usb_device *udev);
 
-This is exactly the same as writing "on" to the power/level attribute.
+This is exactly the same as writing "on" to the power/control attribute.
 
 Sometimes a driver needs to make sure that remote wakeup is enabled
 during autosuspend.  For example, there's not much point
diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c
index b65c1eaf3aba..06863befaf3a 100644
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -383,12 +383,23 @@ static DEVICE_ATTR(autosuspend, S_IRUGO | S_IWUSR,
 static const char on_string[] = "on";
 static const char auto_string[] = "auto";
 
+static void warn_level(void) {
+	static int level_warned;
+
+	if (!level_warned) {
+		level_warned = 1;
+		printk(KERN_WARNING "WARNING! power/level is deprecated; "
+				"use power/control instead\n");
+	}
+}
+
 static ssize_t
 show_level(struct device *dev, struct device_attribute *attr, char *buf)
 {
 	struct usb_device *udev = to_usb_device(dev);
 	const char *p = auto_string;
 
+	warn_level();
 	if (udev-&gt;state != USB_STATE_SUSPENDED &amp;&amp; !udev-&gt;dev.power.runtime_auto)
 		p = on_string;
 	return sprintf(buf, "%s\n", p);
@@ -403,6 +414,7 @@ set_level(struct device *dev, struct device_attribute *attr,
 	char *cp;
 	int rc = count;
 
+	warn_level();
 	cp = memchr(buf, '\n', count);
 	if (cp)
 		len = cp - buf;</pre><hr><pre>commit 9e18c821659d836bd63f88df3c19729327728496
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Apr 2 13:22:09 2010 -0400

    USB: use PM core routines to enable/disable autosuspend
    
    This patch (as1366) replaces the private routines
    usb_enable_autosuspend() and usb_disable_autosuspend() with calls to
    the standard pm_runtime_allow() and pm_runtime_forbid() functions in
    the runtime PM framework.  They do the same thing.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 271e857be0fa..207146743ea7 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -1356,13 +1356,9 @@ int usb_resume(struct device *dev, pm_message_t msg)
  *
  * The caller must hold @udev's device lock.
  */
-int usb_enable_autosuspend(struct usb_device *udev)
+void usb_enable_autosuspend(struct usb_device *udev)
 {
-	if (udev-&gt;autosuspend_disabled) {
-		udev-&gt;autosuspend_disabled = 0;
-		usb_autosuspend_device(udev);
-	}
-	return 0;
+	pm_runtime_allow(&amp;udev-&gt;dev);
 }
 EXPORT_SYMBOL_GPL(usb_enable_autosuspend);
 
@@ -1375,16 +1371,9 @@ EXPORT_SYMBOL_GPL(usb_enable_autosuspend);
  *
  * The caller must hold @udev's device lock.
  */
-int usb_disable_autosuspend(struct usb_device *udev)
+void usb_disable_autosuspend(struct usb_device *udev)
 {
-	int rc = 0;
-
-	if (!udev-&gt;autosuspend_disabled) {
-		rc = usb_autoresume_device(udev);
-		if (rc == 0)
-			udev-&gt;autosuspend_disabled = 1;
-	}
-	return rc;
+	pm_runtime_forbid(&amp;udev-&gt;dev);
 }
 EXPORT_SYMBOL_GPL(usb_disable_autosuspend);
 
@@ -1528,7 +1517,7 @@ void usb_autopm_put_interface_async(struct usb_interface *intf)
 	atomic_dec(&amp;intf-&gt;pm_usage_cnt);
 	pm_runtime_put_noidle(&amp;intf-&gt;dev);
 
-	if (!udev-&gt;autosuspend_disabled) {
+	if (udev-&gt;dev.power.runtime_auto) {
 		/* Optimization: Don't schedule a delayed autosuspend if
 		 * the timer is already running and the expiration time
 		 * wouldn't change.
diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c
index 43c002e3a9aa..b65c1eaf3aba 100644
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -389,7 +389,7 @@ show_level(struct device *dev, struct device_attribute *attr, char *buf)
 	struct usb_device *udev = to_usb_device(dev);
 	const char *p = auto_string;
 
-	if (udev-&gt;state != USB_STATE_SUSPENDED &amp;&amp; udev-&gt;autosuspend_disabled)
+	if (udev-&gt;state != USB_STATE_SUSPENDED &amp;&amp; !udev-&gt;dev.power.runtime_auto)
 		p = on_string;
 	return sprintf(buf, "%s\n", p);
 }
@@ -401,7 +401,7 @@ set_level(struct device *dev, struct device_attribute *attr,
 	struct usb_device *udev = to_usb_device(dev);
 	int len = count;
 	char *cp;
-	int rc;
+	int rc = count;
 
 	cp = memchr(buf, '\n', count);
 	if (cp)
@@ -411,17 +411,17 @@ set_level(struct device *dev, struct device_attribute *attr,
 
 	if (len == sizeof on_string - 1 &amp;&amp;
 			strncmp(buf, on_string, len) == 0)
-		rc = usb_disable_autosuspend(udev);
+		usb_disable_autosuspend(udev);
 
 	else if (len == sizeof auto_string - 1 &amp;&amp;
 			strncmp(buf, auto_string, len) == 0)
-		rc = usb_enable_autosuspend(udev);
+		usb_enable_autosuspend(udev);
 
 	else
 		rc = -EINVAL;
 
 	usb_unlock_device(udev);
-	return (rc &lt; 0 ? rc : count);
+	return rc;
 }
 
 static DEVICE_ATTR(level, S_IRUGO | S_IWUSR, show_level, set_level);
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 99833029e5a8..e32a849f81ce 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -425,7 +425,6 @@ struct usb_tt;
  * @connect_time: time device was first connected
  * @do_remote_wakeup:  remote wakeup should be enabled
  * @reset_resume: needs reset instead of resume
- * @autosuspend_disabled: autosuspend disabled by the user
  * @wusb_dev: if this is a Wireless USB device, link to the WUSB
  *	specific data for the device.
  * @slot_id: Slot ID assigned by xHCI
@@ -501,7 +500,6 @@ struct usb_device {
 
 	unsigned do_remote_wakeup:1;
 	unsigned reset_resume:1;
-	unsigned autosuspend_disabled:1;
 #endif
 	struct wusb_dev *wusb_dev;
 	int slot_id;
@@ -526,8 +524,8 @@ extern struct usb_device *usb_find_device(u16 vendor_id, u16 product_id);
 
 /* USB autosuspend and autoresume */
 #ifdef CONFIG_USB_SUSPEND
-extern int usb_enable_autosuspend(struct usb_device *udev);
-extern int usb_disable_autosuspend(struct usb_device *udev);
+extern void usb_enable_autosuspend(struct usb_device *udev);
+extern void usb_disable_autosuspend(struct usb_device *udev);
 
 extern int usb_autopm_get_interface(struct usb_interface *intf);
 extern void usb_autopm_put_interface(struct usb_interface *intf);</pre>
    <div class="pagination">
        <a href='2_65.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><span>[66]</span><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_67.html'>Next&gt;&gt;</a>
    <div>
</body>
