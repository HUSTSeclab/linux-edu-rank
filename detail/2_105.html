<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_104.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><span>[105]</span><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_106.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit d8fbba2f59c0c131a1babf5a66f003faee02e01a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jul 16 15:30:20 2007 -0400

    USB: usb-storage: unusual_devs entry for Nikon D100
    
    This patch (as938) adds an unusual_devs entry for the Nikon DSC D100.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: Phil Dibowitz &lt;phil@ipom.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index 26fd196869b9..a624e72f81dc 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -313,6 +313,13 @@ UNUSUAL_DEV(  0x04b0, 0x0301, 0x0010, 0x0010,
 		US_SC_DEVICE, US_PR_DEVICE,NULL,
 		US_FL_NOT_LOCKABLE ),
 
+/* Reported by Stefan de Konink &lt;skinkie@xs4all.nl&gt; */
+UNUSUAL_DEV(  0x04b0, 0x0401, 0x0200, 0x0200,
+		"NIKON",
+		"NIKON DSC D100",
+		US_SC_DEVICE, US_PR_DEVICE, NULL,
+		US_FL_FIX_CAPACITY),
+
 /* Reported by Andreas Bockhold &lt;andreas@bockionline.de&gt; */
 UNUSUAL_DEV(  0x04b0, 0x0405, 0x0100, 0x0100,
 		"NIKON",</pre><hr><pre>commit beafef072af10bc8497c9ee51ce2804aa7da26be
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jul 13 15:47:16 2007 -0400

    USB: documentation update for usb_unlink_urb
    
    This patch (as936) updates the kerneldoc for usb_unlink_urb.  The
    explanation of how endpoint queues are meant to work is now clearer
    and in better agreement with reality.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 52ec44b828f3..be630228461c 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -440,55 +440,57 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
  * @urb: pointer to urb describing a previously submitted request,
  *	may be NULL
  *
- * This routine cancels an in-progress request.  URBs complete only
- * once per submission, and may be canceled only once per submission.
- * Successful cancellation means the requests's completion handler will
- * be called with a status code indicating that the request has been
- * canceled (rather than any other code) and will quickly be removed
- * from host controller data structures.
- *
- * This request is always asynchronous.
- * Success is indicated by returning -EINPROGRESS,
- * at which time the URB will normally have been unlinked but not yet
- * given back to the device driver.  When it is called, the completion
- * function will see urb-&gt;status == -ECONNRESET.  Failure is indicated
- * by any other return value.  Unlinking will fail when the URB is not
- * currently "linked" (i.e., it was never submitted, or it was unlinked
- * before, or the hardware is already finished with it), even if the
- * completion handler has not yet run.
+ * This routine cancels an in-progress request.  URBs complete only once
+ * per submission, and may be canceled only once per submission.
+ * Successful cancellation means termination of @urb will be expedited
+ * and the completion handler will be called with a status code
+ * indicating that the request has been canceled (rather than any other
+ * code).
+ *
+ * This request is always asynchronous.  Success is indicated by
+ * returning -EINPROGRESS, at which time the URB will probably not yet
+ * have been given back to the device driver.  When it is eventually
+ * called, the completion function will see @urb-&gt;status == -ECONNRESET.
+ * Failure is indicated by usb_unlink_urb() returning any other value.
+ * Unlinking will fail when @urb is not currently "linked" (i.e., it was
+ * never submitted, or it was unlinked before, or the hardware is already
+ * finished with it), even if the completion handler has not yet run.
  *
  * Unlinking and Endpoint Queues:
  *
+ * [The behaviors and guarantees described below do not apply to virtual
+ * root hubs but only to endpoint queues for physical USB devices.]
+ *
  * Host Controller Drivers (HCDs) place all the URBs for a particular
  * endpoint in a queue.  Normally the queue advances as the controller
  * hardware processes each request.  But when an URB terminates with an
- * error its queue stops, at least until that URB's completion routine
- * returns.  It is guaranteed that the queue will not restart until all
- * its unlinked URBs have been fully retired, with their completion
- * routines run, even if that's not until some time after the original
- * completion handler returns.  Normally the same behavior and guarantees
- * apply when an URB terminates because it was unlinked; however if an
- * URB is unlinked before the hardware has started to execute it, then
- * its queue is not guaranteed to stop until all the preceding URBs have
- * completed.
- *
- * This means that USB device drivers can safely build deep queues for
- * large or complex transfers, and clean them up reliably after any sort
- * of aborted transfer by unlinking all pending URBs at the first fault.
- *
- * Note that an URB terminating early because a short packet was received
- * will count as an error if and only if the URB_SHORT_NOT_OK flag is set.
- * Also, that all unlinks performed in any URB completion handler must
- * be asynchronous.
- *
- * Queues for isochronous endpoints are treated differently, because they
- * advance at fixed rates.  Such queues do not stop when an URB is unlinked.
- * An unlinked URB may leave a gap in the stream of packets.  It is undefined
- * whether such gaps can be filled in.
- *
- * When a control URB terminates with an error, it is likely that the
- * status stage of the transfer will not take place, even if it is merely
- * a soft error resulting from a short-packet with URB_SHORT_NOT_OK set.
+ * error its queue generally stops (see below), at least until that URB's
+ * completion routine returns.  It is guaranteed that a stopped queue
+ * will not restart until all its unlinked URBs have been fully retired,
+ * with their completion routines run, even if that's not until some time
+ * after the original completion handler returns.  The same behavior and
+ * guarantee apply when an URB terminates because it was unlinked.
+ *
+ * Bulk and interrupt endpoint queues are guaranteed to stop whenever an
+ * URB terminates with any sort of error, including -ECONNRESET, -ENOENT,
+ * and -EREMOTEIO.  Control endpoint queues behave the same way except
+ * that they are not guaranteed to stop for -EREMOTEIO errors.  Queues
+ * for isochronous endpoints are treated differently, because they must
+ * advance at fixed rates.  Such queues do not stop when an URB
+ * encounters an error or is unlinked.  An unlinked isochronous URB may
+ * leave a gap in the stream of packets; it is undefined whether such
+ * gaps can be filled in.
+ *
+ * Note that early termination of an URB because a short packet was
+ * received will generate a -EREMOTEIO error if and only if the
+ * URB_SHORT_NOT_OK flag is set.  By setting this flag, USB device
+ * drivers can build deep queues for large or complex bulk transfers
+ * and clean them up reliably after any sort of aborted transfer by
+ * unlinking all pending URBs at the first fault.
+ *
+ * When a control URB terminates with an error other than -EREMOTEIO, it
+ * is quite likely that the status stage of the transfer will not take
+ * place.
  */
 int usb_unlink_urb(struct urb *urb)
 {</pre><hr><pre>commit e7e7c360fb07020b24652843aec442325baad0ce
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jul 13 15:46:29 2007 -0400

    UHCI: short control URBs get a status stage
    
    It has recently been pointed out that short control transfers should
    have a status stage, even if they generate an error because
    URB_SHORT_NOT_OK was set.  This patch (as935) changes uhci-hcd to
    enable the status stage when this happens.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 4aed305982ec..3bb908ca38e9 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -827,8 +827,10 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb,
 	 * If direction is "send", change the packet ID from SETUP (0x2D)
 	 * to OUT (0xE1).  Else change it from SETUP to IN (0x69) and
 	 * set Short Packet Detect (SPD) for all data packets.
+	 *
+	 * 0-length transfers always get treated as "send".
 	 */
-	if (usb_pipeout(urb-&gt;pipe))
+	if (usb_pipeout(urb-&gt;pipe) || len == 0)
 		destination ^= (USB_PID_SETUP ^ USB_PID_OUT);
 	else {
 		destination ^= (USB_PID_SETUP ^ USB_PID_IN);
@@ -839,7 +841,12 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb,
 	 * Build the DATA TDs
 	 */
 	while (len &gt; 0) {
-		int pktsze = min(len, maxsze);
+		int pktsze = maxsze;
+
+		if (len &lt;= pktsze) {		/* The last data packet */
+			pktsze = len;
+			status &amp;= ~TD_CTRL_SPD;
+		}
 
 		td = uhci_alloc_td(uhci);
 		if (!td)
@@ -866,20 +873,10 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb,
 		goto nomem;
 	*plink = LINK_TO_TD(td);
 
-	/*
-	 * It's IN if the pipe is an output pipe or we're not expecting
-	 * data back.
-	 */
-	destination &amp;= ~TD_TOKEN_PID_MASK;
-	if (usb_pipeout(urb-&gt;pipe) || !urb-&gt;transfer_buffer_length)
-		destination |= USB_PID_IN;
-	else
-		destination |= USB_PID_OUT;
-
+	/* Change direction for the status transaction */
+	destination ^= (USB_PID_IN ^ USB_PID_OUT);
 	destination |= TD_TOKEN_TOGGLE;		/* End in Data1 */
 
-	status &amp;= ~TD_CTRL_SPD;
-
 	uhci_add_td_to_urbp(td, urbp);
 	uhci_fill_td(td, status | TD_CTRL_IOC,
 			destination | uhci_explen(0), 0);
@@ -1185,10 +1182,18 @@ static int uhci_result_common(struct uhci_hcd *uhci, struct urb *urb)
 				}
 			}
 
+		/* Did we receive a short packet? */
 		} else if (len &lt; uhci_expected_length(td_token(td))) {
 
-			/* We received a short packet */
-			if (urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK)
+			/* For control transfers, go to the status TD if
+			 * this isn't already the last data TD */
+			if (qh-&gt;type == USB_ENDPOINT_XFER_CONTROL) {
+				if (td-&gt;list.next != urbp-&gt;td_list.prev)
+					ret = 1;
+			}
+
+			/* For bulk and interrupt, this may be an error */
+			else if (urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK)
 				ret = -EREMOTEIO;
 
 			/* Fixup needed only if this isn't the URB's last TD */
@@ -1208,10 +1213,6 @@ static int uhci_result_common(struct uhci_hcd *uhci, struct urb *urb)
 
 err:
 	if (ret &lt; 0) {
-		/* In case a control transfer gets an error
-		 * during the setup stage */
-		urb-&gt;actual_length = max(urb-&gt;actual_length, 0);
-
 		/* Note that the queue has stopped and save
 		 * the next toggle value */
 		qh-&gt;element = UHCI_PTR_TERM;
@@ -1489,9 +1490,25 @@ __acquires(uhci-&gt;lock)
 {
 	struct urb_priv *urbp = (struct urb_priv *) urb-&gt;hcpriv;
 
+	if (qh-&gt;type == USB_ENDPOINT_XFER_CONTROL) {
+
+		/* urb-&gt;actual_length &lt; 0 means the setup transaction didn't
+		 * complete successfully.  Either it failed or the URB was
+		 * unlinked first.  Regardless, don't confuse people with a
+		 * negative length. */
+		urb-&gt;actual_length = max(urb-&gt;actual_length, 0);
+
+		/* Report erroneous short transfers */
+		if (unlikely((urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK) &amp;&amp;
+				urb-&gt;actual_length &lt;
+					urb-&gt;transfer_buffer_length &amp;&amp;
+				urb-&gt;status == 0))
+			urb-&gt;status = -EREMOTEIO;
+	}
+
 	/* When giving back the first URB in an Isochronous queue,
 	 * reinitialize the QH's iso-related members for the next URB. */
-	if (qh-&gt;type == USB_ENDPOINT_XFER_ISOC &amp;&amp;
+	else if (qh-&gt;type == USB_ENDPOINT_XFER_ISOC &amp;&amp;
 			urbp-&gt;node.prev == &amp;qh-&gt;queue &amp;&amp;
 			urbp-&gt;node.next != &amp;qh-&gt;queue) {
 		struct urb *nurb = list_entry(urbp-&gt;node.next,</pre><hr><pre>commit 195af2cce5ff81c4609c7ba585b6698a7771cbfc
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jul 16 15:28:19 2007 -0400

    USB: fix warning caused by autosuspend counter going negative
    
    This patch (as937) fixes a minor bug in the autosuspend usage-counting
    code.  Each hub's usage counter keeps track of the number of
    unsuspended children.  However the current driver increments the
    counter after registering a new child, by which time the child may
    already have been suspended and caused the counter to go negative.
    The obvious solution is to increment the counter before registering
    the child.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index fd74c50b1804..e341a1da517f 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1335,6 +1335,10 @@ int usb_new_device(struct usb_device *udev)
 	udev-&gt;dev.devt = MKDEV(USB_DEVICE_MAJOR,
 			(((udev-&gt;bus-&gt;busnum-1) * 128) + (udev-&gt;devnum-1)));
 
+	/* Increment the parent's count of unsuspended children */
+	if (udev-&gt;parent)
+		usb_autoresume_device(udev-&gt;parent);
+
 	/* Register the device.  The device driver is responsible
 	 * for adding the device files to sysfs and for configuring
 	 * the device.
@@ -1342,13 +1346,11 @@ int usb_new_device(struct usb_device *udev)
 	err = device_add(&amp;udev-&gt;dev);
 	if (err) {
 		dev_err(&amp;udev-&gt;dev, "can't device_add, error %d\n", err);
+		if (udev-&gt;parent)
+			usb_autosuspend_device(udev-&gt;parent);
 		goto fail;
 	}
 
-	/* Increment the parent's count of unsuspended children */
-	if (udev-&gt;parent)
-		usb_autoresume_device(udev-&gt;parent);
-
 exit:
 	return err;
 </pre><hr><pre>commit 69d42a78f935d19384d1f6e4f94b65bb162b36df
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jul 12 17:06:23 2007 -0400

    USB: add "descriptors" binary sysfs attribute
    
    This patch (as934) adds a new readonly binary sysfs attribute file
    called "descriptors" for each USB device.  The attribute contains the
    device descriptor followed by the raw descriptor entry (config plug
    subsidiary descriptors) for the current configuration.
    
    Having this information available in fixed-format binary makes life a
    lot easier for user programs by avoiding the need to open, read, and
    parse multiple sysfs text files.
    
    The information in this attribute file is much like that in usbfs's
    device file, but there are some significant differences:
    
            The 2-byte fields in the device descriptor are left in
            little-endian byte order, as they appear on the bus and
            in the kernel.
    
            Only one raw descriptor set is presented, that of the
            current configuration.
    
            Opening this file will not cause a suspended device to be
            autoresumed.
    
    The last item in particular should be a big selling point for libusb,
    which currently forces all USB devices to be resumed as it scans the
    device tree.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: Dave Mielke &lt;dave@mielke.cc&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c
index d47ae89154a7..2ab222be8fd1 100644
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -441,6 +441,54 @@ static struct attribute_group dev_attr_grp = {
 	.attrs = dev_attrs,
 };
 
+/* Binary descriptors */
+
+static ssize_t
+read_descriptors(struct kobject *kobj, struct bin_attribute *attr,
+		char *buf, loff_t off, size_t count)
+{
+	struct usb_device *udev = to_usb_device(
+			container_of(kobj, struct device, kobj));
+	size_t nleft = count;
+	size_t srclen, n;
+
+	usb_lock_device(udev);
+
+	/* The binary attribute begins with the device descriptor */
+	srclen = sizeof(struct usb_device_descriptor);
+	if (off &lt; srclen) {
+		n = min_t(size_t, nleft, srclen - off);
+		memcpy(buf, off + (char *) &amp;udev-&gt;descriptor, n);
+		nleft -= n;
+		buf += n;
+		off = 0;
+	} else {
+		off -= srclen;
+	}
+
+	/* Then follows the raw descriptor entry for the current
+	 * configuration (config plus subsidiary descriptors).
+	 */
+	if (udev-&gt;actconfig) {
+		int cfgno = udev-&gt;actconfig - udev-&gt;config;
+
+		srclen = __le16_to_cpu(udev-&gt;actconfig-&gt;desc.wTotalLength);
+		if (off &lt; srclen) {
+			n = min_t(size_t, nleft, srclen - off);
+			memcpy(buf, off + udev-&gt;rawdescriptors[cfgno], n);
+			nleft -= n;
+		}
+	}
+	usb_unlock_device(udev);
+	return count - nleft;
+}
+
+static struct bin_attribute dev_bin_attr_descriptors = {
+	.attr = {.name = "descriptors", .mode = 0444},
+	.read = read_descriptors,
+	.size = 18 + 65535,	/* dev descr + max-size raw descriptor */
+};
+
 int usb_create_sysfs_dev_files(struct usb_device *udev)
 {
 	struct device *dev = &amp;udev-&gt;dev;
@@ -450,6 +498,10 @@ int usb_create_sysfs_dev_files(struct usb_device *udev)
 	if (retval)
 		return retval;
 
+	retval = device_create_bin_file(dev, &amp;dev_bin_attr_descriptors);
+	if (retval)
+		goto error;
+
 	retval = add_persist_attributes(dev);
 	if (retval)
 		goto error;
@@ -492,6 +544,7 @@ void usb_remove_sysfs_dev_files(struct usb_device *udev)
 	device_remove_file(dev, &amp;dev_attr_serial);
 	remove_power_attributes(dev);
 	remove_persist_attributes(dev);
+	device_remove_bin_file(dev, &amp;dev_bin_attr_descriptors);
 	sysfs_remove_group(&amp;dev-&gt;kobj, &amp;dev_attr_grp);
 }
 </pre><hr><pre>commit 1b4cd43bd3f9aa7a794e29b80b0d984a8e144df4
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jul 12 17:03:01 2007 -0400

    isp116x-hcd: prepare for urb-&gt;status
    
    This patch (as931b), adapted from a patch by Olav Kongas, makes a small
    set of conservative changes to the isp116x-hcd driver in preparation
    for the removal of urb-&gt;status.
    
            finish_request() is moved up in the source and is called
            as soon as the URB is known to have completed, rather than
            after all the active endpoints have been scanned.
    
            The status of a completed URB is kept in a local variable
            and copied to urb-&gt;status only when the URB is about to be
            given back.
    
            -EREMOTEIO error status for control transfers is set after
            the status stage rather than when the short packet arrives.
    
            Some unnecessary uses of urb-&gt;lock are removed.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: Olav Kongas &lt;ok@artecdesign.ee&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/isp116x-hcd.c b/drivers/usb/host/isp116x-hcd.c
index 46873f2534b5..5c851a36de72 100644
--- a/drivers/usb/host/isp116x-hcd.c
+++ b/drivers/usb/host/isp116x-hcd.c
@@ -228,7 +228,6 @@ static void preproc_atl_queue(struct isp116x *isp116x)
 				   struct urb, urb_list);
 		ptd = &amp;ep-&gt;ptd;
 		len = ep-&gt;length;
-		spin_lock(&amp;urb-&gt;lock);
 		ep-&gt;data = (unsigned char *)urb-&gt;transfer_buffer
 		    + urb-&gt;actual_length;
 
@@ -264,7 +263,6 @@ static void preproc_atl_queue(struct isp116x *isp116x)
 		    | PTD_EP(ep-&gt;epnum);
 		ptd-&gt;len = PTD_LEN(len) | PTD_DIR(dir);
 		ptd-&gt;faddr = PTD_FA(usb_pipedevice(urb-&gt;pipe));
-		spin_unlock(&amp;urb-&gt;lock);
 		if (!ep-&gt;active) {
 			ptd-&gt;mps |= PTD_LAST_MSK;
 			isp116x-&gt;atl_last_dir = dir;
@@ -274,6 +272,61 @@ static void preproc_atl_queue(struct isp116x *isp116x)
 	}
 }
 
+/*
+  Take done or failed requests out of schedule. Give back
+  processed urbs.
+*/
+static void finish_request(struct isp116x *isp116x, struct isp116x_ep *ep,
+			   struct urb *urb)
+__releases(isp116x-&gt;lock) __acquires(isp116x-&gt;lock)
+{
+	unsigned i;
+
+	urb-&gt;hcpriv = NULL;
+	ep-&gt;error_count = 0;
+
+	if (usb_pipecontrol(urb-&gt;pipe))
+		ep-&gt;nextpid = USB_PID_SETUP;
+
+	urb_dbg(urb, "Finish");
+
+	spin_unlock(&amp;isp116x-&gt;lock);
+	usb_hcd_giveback_urb(isp116x_to_hcd(isp116x), urb);
+	spin_lock(&amp;isp116x-&gt;lock);
+
+	/* take idle endpoints out of the schedule */
+	if (!list_empty(&amp;ep-&gt;hep-&gt;urb_list))
+		return;
+
+	/* async deschedule */
+	if (!list_empty(&amp;ep-&gt;schedule)) {
+		list_del_init(&amp;ep-&gt;schedule);
+		return;
+	}
+
+	/* periodic deschedule */
+	DBG("deschedule qh%d/%p branch %d\n", ep-&gt;period, ep, ep-&gt;branch);
+	for (i = ep-&gt;branch; i &lt; PERIODIC_SIZE; i += ep-&gt;period) {
+		struct isp116x_ep *temp;
+		struct isp116x_ep **prev = &amp;isp116x-&gt;periodic[i];
+
+		while (*prev &amp;&amp; ((temp = *prev) != ep))
+			prev = &amp;temp-&gt;next;
+		if (*prev)
+			*prev = ep-&gt;next;
+		isp116x-&gt;load[i] -= ep-&gt;load;
+	}
+	ep-&gt;branch = PERIODIC_SIZE;
+	isp116x_to_hcd(isp116x)-&gt;self.bandwidth_allocated -=
+	    ep-&gt;load / ep-&gt;period;
+
+	/* switch irq type? */
+	if (!--isp116x-&gt;periodic_count) {
+		isp116x-&gt;irqenb &amp;= ~HCuPINT_SOF;
+		isp116x-&gt;irqenb |= HCuPINT_ATL;
+	}
+}
+
 /*
   Analyze transfer results, handle partial transfers and errors
 */
@@ -284,6 +337,7 @@ static void postproc_atl_queue(struct isp116x *isp116x)
 	struct usb_device *udev;
 	struct ptd *ptd;
 	int short_not_ok;
+	int status;
 	u8 cc;
 
 	for (ep = isp116x-&gt;atl_active; ep; ep = ep-&gt;active) {
@@ -294,7 +348,7 @@ static void postproc_atl_queue(struct isp116x *isp116x)
 		ptd = &amp;ep-&gt;ptd;
 		cc = PTD_GET_CC(ptd);
 		short_not_ok = 1;
-		spin_lock(&amp;urb-&gt;lock);
+		status = -EINPROGRESS;
 
 		/* Data underrun is special. For allowed underrun
 		   we clear the error and continue as normal. For
@@ -302,47 +356,36 @@ static void postproc_atl_queue(struct isp116x *isp116x)
 		   immediately while for control transfer,
 		   we do a STATUS stage. */
 		if (cc == TD_DATAUNDERRUN) {
-			if (!(urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK)) {
-				DBG("Allowed data underrun\n");
+			if (!(urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK) ||
+					usb_pipecontrol(urb-&gt;pipe)) {
+				DBG("Allowed or control data underrun\n");
 				cc = TD_CC_NOERROR;
 				short_not_ok = 0;
 			} else {
 				ep-&gt;error_count = 1;
-				if (usb_pipecontrol(urb-&gt;pipe))
-					ep-&gt;nextpid = USB_PID_ACK;
-				else
-					usb_settoggle(udev, ep-&gt;epnum,
-						      ep-&gt;nextpid ==
-						      USB_PID_OUT,
-						      PTD_GET_TOGGLE(ptd));
+				usb_settoggle(udev, ep-&gt;epnum,
+					      ep-&gt;nextpid == USB_PID_OUT,
+					      PTD_GET_TOGGLE(ptd));
 				urb-&gt;actual_length += PTD_GET_COUNT(ptd);
-				urb-&gt;status = cc_to_error[TD_DATAUNDERRUN];
-				spin_unlock(&amp;urb-&gt;lock);
-				continue;
+				status = cc_to_error[TD_DATAUNDERRUN];
+				goto done;
 			}
 		}
-		/* Keep underrun error through the STATUS stage */
-		if (urb-&gt;status == cc_to_error[TD_DATAUNDERRUN])
-			cc = TD_DATAUNDERRUN;
 
 		if (cc != TD_CC_NOERROR &amp;&amp; cc != TD_NOTACCESSED
 		    &amp;&amp; (++ep-&gt;error_count &gt;= 3 || cc == TD_CC_STALL
 			|| cc == TD_DATAOVERRUN)) {
-			if (urb-&gt;status == -EINPROGRESS)
-				urb-&gt;status = cc_to_error[cc];
+			status = cc_to_error[cc];
 			if (ep-&gt;nextpid == USB_PID_ACK)
 				ep-&gt;nextpid = 0;
-			spin_unlock(&amp;urb-&gt;lock);
-			continue;
+			goto done;
 		}
 		/* According to usb spec, zero-length Int transfer signals
 		   finishing of the urb. Hey, does this apply only
 		   for IN endpoints? */
 		if (usb_pipeint(urb-&gt;pipe) &amp;&amp; !PTD_GET_LEN(ptd)) {
-			if (urb-&gt;status == -EINPROGRESS)
-				urb-&gt;status = 0;
-			spin_unlock(&amp;urb-&gt;lock);
-			continue;
+			status = 0;
+			goto done;
 		}
 
 		/* Relax after previously failed, but later succeeded
@@ -381,8 +424,8 @@ static void postproc_atl_queue(struct isp116x *isp116x)
 			/* All data for this URB is transferred, let's finish */
 			if (usb_pipecontrol(urb-&gt;pipe))
 				ep-&gt;nextpid = USB_PID_ACK;
-			else if (urb-&gt;status == -EINPROGRESS)
-				urb-&gt;status = 0;
+			else
+				status = 0;
 			break;
 		case USB_PID_SETUP:
 			if (PTD_GET_ACTIVE(ptd)
@@ -402,69 +445,27 @@ static void postproc_atl_queue(struct isp116x *isp116x)
 			if (PTD_GET_ACTIVE(ptd)
 			    || (cc != TD_CC_NOERROR &amp;&amp; cc &lt; 0x0E))
 				break;
-			if (urb-&gt;status == -EINPROGRESS)
-				urb-&gt;status = 0;
+			if ((urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK) &amp;&amp;
+					urb-&gt;actual_length &lt;
+						urb-&gt;transfer_buffer_length)
+				status = -EREMOTEIO;
+			else
+				status = 0;
 			ep-&gt;nextpid = 0;
 			break;
 		default:
 			BUG();
 		}
-		spin_unlock(&amp;urb-&gt;lock);
-	}
-}
-
-/*
-  Take done or failed requests out of schedule. Give back
-  processed urbs.
-*/
-static void finish_request(struct isp116x *isp116x, struct isp116x_ep *ep,
-			   struct urb *urb)
-__releases(isp116x-&gt;lock) __acquires(isp116x-&gt;lock)
-{
-	unsigned i;
-
-	urb-&gt;hcpriv = NULL;
-	ep-&gt;error_count = 0;
-
-	if (usb_pipecontrol(urb-&gt;pipe))
-		ep-&gt;nextpid = USB_PID_SETUP;
-
-	urb_dbg(urb, "Finish");
-
-	spin_unlock(&amp;isp116x-&gt;lock);
-	usb_hcd_giveback_urb(isp116x_to_hcd(isp116x), urb);
-	spin_lock(&amp;isp116x-&gt;lock);
-
-	/* take idle endpoints out of the schedule */
-	if (!list_empty(&amp;ep-&gt;hep-&gt;urb_list))
-		return;
-
-	/* async deschedule */
-	if (!list_empty(&amp;ep-&gt;schedule)) {
-		list_del_init(&amp;ep-&gt;schedule);
-		return;
-	}
 
-	/* periodic deschedule */
-	DBG("deschedule qh%d/%p branch %d\n", ep-&gt;period, ep, ep-&gt;branch);
-	for (i = ep-&gt;branch; i &lt; PERIODIC_SIZE; i += ep-&gt;period) {
-		struct isp116x_ep *temp;
-		struct isp116x_ep **prev = &amp;isp116x-&gt;periodic[i];
-
-		while (*prev &amp;&amp; ((temp = *prev) != ep))
-			prev = &amp;temp-&gt;next;
-		if (*prev)
-			*prev = ep-&gt;next;
-		isp116x-&gt;load[i] -= ep-&gt;load;
-	}
-	ep-&gt;branch = PERIODIC_SIZE;
-	isp116x_to_hcd(isp116x)-&gt;self.bandwidth_allocated -=
-	    ep-&gt;load / ep-&gt;period;
-
-	/* switch irq type? */
-	if (!--isp116x-&gt;periodic_count) {
-		isp116x-&gt;irqenb &amp;= ~HCuPINT_SOF;
-		isp116x-&gt;irqenb |= HCuPINT_ATL;
+ done:
+		if (status != -EINPROGRESS) {
+			spin_lock(&amp;urb-&gt;lock);
+			if (urb-&gt;status == -EINPROGRESS)
+				urb-&gt;status = status;
+			spin_unlock(&amp;urb-&gt;lock);
+		}
+		if (urb-&gt;status != -EINPROGRESS)
+			finish_request(isp116x, ep, urb);
 	}
 }
 
@@ -570,9 +571,6 @@ static void start_atl_transfers(struct isp116x *isp116x)
 */
 static void finish_atl_transfers(struct isp116x *isp116x)
 {
-	struct isp116x_ep *ep;
-	struct urb *urb;
-
 	if (!isp116x-&gt;atl_active)
 		return;
 	/* Fifo not ready? */
@@ -582,16 +580,6 @@ static void finish_atl_transfers(struct isp116x *isp116x)
 	atomic_inc(&amp;isp116x-&gt;atl_finishing);
 	unpack_fifo(isp116x);
 	postproc_atl_queue(isp116x);
-	for (ep = isp116x-&gt;atl_active; ep; ep = ep-&gt;active) {
-		urb =
-		    container_of(ep-&gt;hep-&gt;urb_list.next, struct urb, urb_list);
-		/* USB_PID_ACK check here avoids finishing of
-		   control transfers, for which TD_DATAUNDERRUN
-		   occured, while URB_SHORT_NOT_OK was set */
-		if (urb &amp;&amp; urb-&gt;status != -EINPROGRESS
-		    &amp;&amp; ep-&gt;nextpid != USB_PID_ACK)
-			finish_request(isp116x, ep, urb);
-	}
 	atomic_dec(&amp;isp116x-&gt;atl_finishing);
 }
 
@@ -821,15 +809,12 @@ static int isp116x_urb_enqueue(struct usb_hcd *hcd,
 	}
 
 	/* in case of unlink-during-submit */
-	spin_lock(&amp;urb-&gt;lock);
 	if (urb-&gt;status != -EINPROGRESS) {
-		spin_unlock(&amp;urb-&gt;lock);
 		finish_request(isp116x, ep, urb);
 		ret = 0;
 		goto fail;
 	}
 	urb-&gt;hcpriv = hep;
-	spin_unlock(&amp;urb-&gt;lock);
 	start_atl_transfers(isp116x);
 
       fail:</pre><hr><pre>commit 3f8df781fc5f9ee5253a54ba669e1c8872844b86
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jul 12 16:57:22 2007 -0400

    PM: remove deprecated dpm_runtime_* routines
    
    This patch (as933) removes the deprecated dpm_runtime_suspend() and
    dpm_runtime_resume() routines from the PM core.  The only user of
    those routines is the PCMCIA ds driver; local replacements are added.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Dominik Brodowski &lt;linux@dominikbrodowski.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/Documentation/feature-removal-schedule.txt b/Documentation/feature-removal-schedule.txt
index 9cf9d8346289..1b5c70758a1a 100644
--- a/Documentation/feature-removal-schedule.txt
+++ b/Documentation/feature-removal-schedule.txt
@@ -27,7 +27,6 @@ Who:	Hans Verkuil &lt;hverkuil@xs4all.nl&gt; and
 ---------------------------
 
 What:	dev-&gt;power.power_state
-	dpm_runtime_{suspend,resume)()
 When:	July 2007
 Why:	Broken design for runtime control over driver power states, confusing
 	driver-internal runtime power management with:  mechanisms to support
diff --git a/drivers/base/power/Makefile b/drivers/base/power/Makefile
index 91f230939c1e..fff178007208 100644
--- a/drivers/base/power/Makefile
+++ b/drivers/base/power/Makefile
@@ -1,5 +1,5 @@
 obj-y			:= shutdown.o
-obj-$(CONFIG_PM)	+= main.o suspend.o resume.o runtime.o sysfs.o
+obj-$(CONFIG_PM)	+= main.o suspend.o resume.o sysfs.o
 obj-$(CONFIG_PM_TRACE)	+= trace.o
 
 ifeq ($(CONFIG_DEBUG_DRIVER),y)
diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index 2760f25b3ac5..591a0dd5deee 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -62,11 +62,6 @@ extern int resume_device(struct device *);
  */
 extern int suspend_device(struct device *, pm_message_t);
 
-
-/*
- * runtime.c
- */
-
 #else /* CONFIG_PM */
 
 
diff --git a/drivers/base/power/runtime.c b/drivers/base/power/runtime.c
deleted file mode 100644
index df6174d85866..000000000000
--- a/drivers/base/power/runtime.c
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- * drivers/base/power/runtime.c - Handling dynamic device power management.
- *
- * Copyright (c) 2003 Patrick Mochel
- * Copyright (c) 2003 Open Source Development Lab
- *
- */
-
-#include &lt;linux/device.h&gt;
-#include "power.h"
-
-
-static void runtime_resume(struct device * dev)
-{
-	dev_dbg(dev, "resuming\n");
-	if (!dev-&gt;power.power_state.event)
-		return;
-	if (!resume_device(dev))
-		dev-&gt;power.power_state = PMSG_ON;
-}
-
-
-/**
- *	dpm_runtime_resume - Power one device back on.
- *	@dev:	Device.
- *
- *	Bring one device back to the on state by first powering it
- *	on, then restoring state. We only operate on devices that aren't
- *	already on.
- *	FIXME: We need to handle devices that are in an unknown state.
- */
-
-void dpm_runtime_resume(struct device * dev)
-{
-	mutex_lock(&amp;dpm_mtx);
-	runtime_resume(dev);
-	mutex_unlock(&amp;dpm_mtx);
-}
-EXPORT_SYMBOL(dpm_runtime_resume);
-
-
-/**
- *	dpm_runtime_suspend - Put one device in low-power state.
- *	@dev:	Device.
- *	@state:	State to enter.
- */
-
-int dpm_runtime_suspend(struct device * dev, pm_message_t state)
-{
-	int error = 0;
-
-	mutex_lock(&amp;dpm_mtx);
-	if (dev-&gt;power.power_state.event == state.event)
-		goto Done;
-
-	if (dev-&gt;power.power_state.event)
-		runtime_resume(dev);
-
-	if (!(error = suspend_device(dev, state)))
-		dev-&gt;power.power_state = state;
- Done:
-	mutex_unlock(&amp;dpm_mtx);
-	return error;
-}
-EXPORT_SYMBOL(dpm_runtime_suspend);
-
-
-#if 0
-/**
- *	dpm_set_power_state - Update power_state field.
- *	@dev:	Device.
- *	@state:	Power state device is in.
- *
- *	This is an update mechanism for drivers to notify the core
- *	what power state a device is in. Device probing code may not
- *	always be able to tell, but we need accurate information to
- *	work reliably.
- */
-void dpm_set_power_state(struct device * dev, pm_message_t state)
-{
-	mutex_lock(&amp;dpm_mtx);
-	dev-&gt;power.power_state = state;
-	mutex_unlock(&amp;dpm_mtx);
-}
-#endif  /*  0  */
diff --git a/drivers/pcmcia/ds.c b/drivers/pcmcia/ds.c
index 143c6efc478a..a99607142fc8 100644
--- a/drivers/pcmcia/ds.c
+++ b/drivers/pcmcia/ds.c
@@ -1127,6 +1127,34 @@ static int pcmcia_bus_uevent(struct device *dev, char **envp, int num_envp,
 
 #endif
 
+/************************ runtime PM support ***************************/
+
+static int pcmcia_dev_suspend(struct device *dev, pm_message_t state);
+static int pcmcia_dev_resume(struct device *dev);
+
+static int runtime_suspend(struct device *dev)
+{
+	int rc;
+
+	down(&amp;dev-&gt;sem);
+	rc = pcmcia_dev_suspend(dev, PMSG_SUSPEND);
+	up(&amp;dev-&gt;sem);
+	if (!rc)
+		dev-&gt;power.power_state.event = PM_EVENT_SUSPEND;
+	return rc;
+}
+
+static void runtime_resume(struct device *dev)
+{
+	int rc;
+
+	down(&amp;dev-&gt;sem);
+	rc = pcmcia_dev_resume(dev);
+	up(&amp;dev-&gt;sem);
+	if (!rc)
+		dev-&gt;power.power_state.event = PM_EVENT_ON;
+}
+
 /************************ per-device sysfs output ***************************/
 
 #define pcmcia_device_attr(field, test, format)				\
@@ -1173,9 +1201,9 @@ static ssize_t pcmcia_store_pm_state(struct device *dev, struct device_attribute
                 return -EINVAL;
 
 	if ((!p_dev-&gt;suspended) &amp;&amp; !strncmp(buf, "off", 3))
-		ret = dpm_runtime_suspend(dev, PMSG_SUSPEND);
+		ret = runtime_suspend(dev);
 	else if (p_dev-&gt;suspended &amp;&amp; !strncmp(buf, "on", 2))
-		dpm_runtime_resume(dev);
+		runtime_resume(dev);
 
 	return ret ? ret : count;
 }
@@ -1312,10 +1340,10 @@ static int pcmcia_bus_suspend_callback(struct device *dev, void * _data)
 	struct pcmcia_socket *skt = _data;
 	struct pcmcia_device *p_dev = to_pcmcia_dev(dev);
 
-	if (p_dev-&gt;socket != skt)
+	if (p_dev-&gt;socket != skt || p_dev-&gt;suspended)
 		return 0;
 
-	return dpm_runtime_suspend(dev, PMSG_SUSPEND);
+	return runtime_suspend(dev);
 }
 
 static int pcmcia_bus_resume_callback(struct device *dev, void * _data)
@@ -1323,10 +1351,10 @@ static int pcmcia_bus_resume_callback(struct device *dev, void * _data)
 	struct pcmcia_socket *skt = _data;
 	struct pcmcia_device *p_dev = to_pcmcia_dev(dev);
 
-	if (p_dev-&gt;socket != skt)
+	if (p_dev-&gt;socket != skt || !p_dev-&gt;suspended)
 		return 0;
 
-	dpm_runtime_resume(dev);
+	runtime_resume(dev);
 
 	return 0;
 }
diff --git a/include/linux/pm.h b/include/linux/pm.h
index 273781c82e4d..2735b7cadd20 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -284,8 +284,6 @@ extern int device_prepare_suspend(pm_message_t state);
 #define device_may_wakeup(dev) \
 	(device_can_wakeup(dev) &amp;&amp; (dev)-&gt;power.should_wakeup)
 
-extern int dpm_runtime_suspend(struct device *, pm_message_t);
-extern void dpm_runtime_resume(struct device *);
 extern void __suspend_report_result(const char *function, void *fn, int ret);
 
 #define suspend_report_result(fn, ret)					\
@@ -317,15 +315,6 @@ static inline int device_suspend(pm_message_t state)
 #define device_set_wakeup_enable(dev,val)	do{}while(0)
 #define device_may_wakeup(dev)			(0)
 
-static inline int dpm_runtime_suspend(struct device * dev, pm_message_t state)
-{
-	return 0;
-}
-
-static inline void dpm_runtime_resume(struct device * dev)
-{
-}
-
 #define suspend_report_result(fn, ret) do { } while (0)
 
 static inline int call_platform_enable_wakeup(struct device *dev, int is_on)</pre><hr><pre>commit 471d0558045fe35f8c5f291c1ee63815eb9c2dcd
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jul 12 16:55:07 2007 -0400

    PM: Remove deprecated sysfs files
    
    This patch (as932) removes the deprecated sysfs .../power/state
    attribute files.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Pavel Machek &lt;pavel@ucw.cz&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/Documentation/feature-removal-schedule.txt b/Documentation/feature-removal-schedule.txt
index d05e6243b4df..9cf9d8346289 100644
--- a/Documentation/feature-removal-schedule.txt
+++ b/Documentation/feature-removal-schedule.txt
@@ -26,8 +26,7 @@ Who:	Hans Verkuil &lt;hverkuil@xs4all.nl&gt; and
 
 ---------------------------
 
-What:	/sys/devices/.../power/state
-	dev-&gt;power.power_state
+What:	dev-&gt;power.power_state
 	dpm_runtime_{suspend,resume)()
 When:	July 2007
 Why:	Broken design for runtime control over driver power states, confusing
diff --git a/drivers/base/power/sysfs.c b/drivers/base/power/sysfs.c
index 2d47517dbe32..f2ed179cd695 100644
--- a/drivers/base/power/sysfs.c
+++ b/drivers/base/power/sysfs.c
@@ -7,69 +7,6 @@
 #include "power.h"
 
 
-#ifdef	CONFIG_PM_SYSFS_DEPRECATED
-
-/**
- *	state - Control current power state of device
- *
- *	show() returns the current power state of the device. '0' indicates
- *	the device is on. Other values (2) indicate the device is in some low
- *	power state.
- *
- *	store() sets the current power state, which is an integer valued
- *	0, 2, or 3.  Devices with bus.suspend_late(), or bus.resume_early()
- *	methods fail this operation; those methods couldn't be called.
- *	Otherwise,
- *
- *	- If the recorded dev-&gt;power.power_state.event matches the
- *	  target value, nothing is done.
- *	- If the recorded event code is nonzero, the device is reactivated
- *	  by calling bus.resume() and/or class.resume().
- *	- If the target value is nonzero, the device is suspended by
- *	  calling class.suspend() and/or bus.suspend() with event code
- *	  PM_EVENT_SUSPEND.
- *
- *	This mechanism is DEPRECATED and should only be used for testing.
- */
-
-static ssize_t state_show(struct device * dev, struct device_attribute *attr, char * buf)
-{
-	if (dev-&gt;power.power_state.event)
-		return sprintf(buf, "2\n");
-	else
-		return sprintf(buf, "0\n");
-}
-
-static ssize_t state_store(struct device * dev, struct device_attribute *attr, const char * buf, size_t n)
-{
-	pm_message_t state;
-	int error = -EINVAL;
-
-	/* disallow incomplete suspend sequences */
-	if (dev-&gt;bus &amp;&amp; (dev-&gt;bus-&gt;suspend_late || dev-&gt;bus-&gt;resume_early))
-		return error;
-
-	state.event = PM_EVENT_SUSPEND;
-	/* Older apps expected to write "3" here - confused with PCI D3 */
-	if ((n == 1) &amp;&amp; !strcmp(buf, "3"))
-		error = dpm_runtime_suspend(dev, state);
-
-	if ((n == 1) &amp;&amp; !strcmp(buf, "2"))
-		error = dpm_runtime_suspend(dev, state);
-
-	if ((n == 1) &amp;&amp; !strcmp(buf, "0")) {
-		dpm_runtime_resume(dev);
-		error = 0;
-	}
-
-	return error ? error : n;
-}
-
-static DEVICE_ATTR(state, 0644, state_show, state_store);
-
-
-#endif	/* CONFIG_PM_SYSFS_DEPRECATED */
-
 /*
  *	wakeup - Report/change current wakeup option for device
  *
@@ -143,9 +80,6 @@ static DEVICE_ATTR(wakeup, 0644, wake_show, wake_store);
 
 
 static struct attribute * power_attrs[] = {
-#ifdef	CONFIG_PM_SYSFS_DEPRECATED
-	&amp;dev_attr_state.attr,
-#endif
 	&amp;dev_attr_wakeup.attr,
 	NULL,
 };
diff --git a/kernel/power/Kconfig b/kernel/power/Kconfig
index 495b7d4dd330..73328476761c 100644
--- a/kernel/power/Kconfig
+++ b/kernel/power/Kconfig
@@ -65,18 +65,6 @@ config PM_TRACE
 	CAUTION: this option will cause your machine's real-time clock to be
 	set to an invalid time after a resume.
 
-config PM_SYSFS_DEPRECATED
-	bool "Driver model /sys/devices/.../power/state files (DEPRECATED)"
-	depends on PM &amp;&amp; SYSFS
-	default n
-	help
-	  The driver model started out with a sysfs file intended to provide
-	  a userspace hook for device power management.  This feature has never
-	  worked very well, except for limited testing purposes, and so it will
-	  be removed.   It's not clear that a generic mechanism could really
-	  handle the wide variability of device power states; any replacements
-	  are likely to be bus or driver specific.
-
 config SOFTWARE_SUSPEND
 	bool "Software Suspend (Hibernation)"
 	depends on PM &amp;&amp; SWAP &amp;&amp; (((X86 || PPC64_SWSUSP) &amp;&amp; (!SMP || SUSPEND_SMP)) || ((FRV || PPC32) &amp;&amp; !SMP))</pre><hr><pre>commit 8dfe4b14869fd185ca25ee88b02ada58a3005eaf
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jul 6 14:24:27 2007 -0400

    usb-storage: implement autosuspend
    
    This patch (as930) implements autosuspend for usb-storage.  It is
    adapted from a patch by Oliver Neukum.  Autosuspend is allowed except
    during LUN scanning, resets, and command execution.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 1ba19eaa1970..47e56079925d 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -285,10 +285,15 @@ static int device_reset(struct scsi_cmnd *srb)
 
 	US_DEBUGP("%s called\n", __FUNCTION__);
 
-	/* lock the device pointers and do the reset */
-	mutex_lock(&amp;(us-&gt;dev_mutex));
-	result = us-&gt;transport_reset(us);
-	mutex_unlock(&amp;us-&gt;dev_mutex);
+	result = usb_autopm_get_interface(us-&gt;pusb_intf);
+	if (result == 0) {
+
+		/* lock the device pointers and do the reset */
+		mutex_lock(&amp;(us-&gt;dev_mutex));
+		result = us-&gt;transport_reset(us);
+		mutex_unlock(&amp;us-&gt;dev_mutex);
+		usb_autopm_put_interface(us-&gt;pusb_intf);
+	}
 
 	return result &lt; 0 ? FAILED : SUCCESS;
 }
diff --git a/drivers/usb/storage/usb.c b/drivers/usb/storage/usb.c
index cf3fc91234e7..bef8bcd9bd98 100644
--- a/drivers/usb/storage/usb.c
+++ b/drivers/usb/storage/usb.c
@@ -191,16 +191,14 @@ static int storage_suspend(struct usb_interface *iface, pm_message_t message)
 {
 	struct us_data *us = usb_get_intfdata(iface);
 
+	US_DEBUGP("%s\n", __FUNCTION__);
+
 	/* Wait until no command is running */
 	mutex_lock(&amp;us-&gt;dev_mutex);
 
-	US_DEBUGP("%s\n", __FUNCTION__);
 	if (us-&gt;suspend_resume_hook)
 		(us-&gt;suspend_resume_hook)(us, US_SUSPEND);
 
-	/* When runtime PM is working, we'll set a flag to indicate
-	 * whether we should autoresume when a SCSI request arrives. */
-
 	mutex_unlock(&amp;us-&gt;dev_mutex);
 	return 0;
 }
@@ -209,13 +207,11 @@ static int storage_resume(struct usb_interface *iface)
 {
 	struct us_data *us = usb_get_intfdata(iface);
 
-	mutex_lock(&amp;us-&gt;dev_mutex);
-
 	US_DEBUGP("%s\n", __FUNCTION__);
+
 	if (us-&gt;suspend_resume_hook)
 		(us-&gt;suspend_resume_hook)(us, US_RESUME);
 
-	mutex_unlock(&amp;us-&gt;dev_mutex);
 	return 0;
 }
 
@@ -313,6 +309,7 @@ static int usb_stor_control_thread(void * __us)
 {
 	struct us_data *us = (struct us_data *)__us;
 	struct Scsi_Host *host = us_to_host(us);
+	int autopm_rc;
 
 	current-&gt;flags |= PF_NOFREEZE;
 
@@ -323,6 +320,9 @@ static int usb_stor_control_thread(void * __us)
 			
 		US_DEBUGP("*** thread awakened.\n");
 
+		/* Autoresume the device */
+		autopm_rc = usb_autopm_get_interface(us-&gt;pusb_intf);
+
 		/* lock the device pointers */
 		mutex_lock(&amp;(us-&gt;dev_mutex));
 
@@ -381,6 +381,12 @@ static int usb_stor_control_thread(void * __us)
 			us-&gt;srb-&gt;result = SAM_STAT_GOOD;
 		}
 
+		/* Did the autoresume fail? */
+		else if (autopm_rc &lt; 0) {
+			US_DEBUGP("Could not wake device\n");
+			us-&gt;srb-&gt;result = DID_ERROR &lt;&lt; 16;
+		}
+
 		/* we've got a command, let's do it! */
 		else {
 			US_DEBUG(usb_stor_show_command(us-&gt;srb));
@@ -423,6 +429,10 @@ static int usb_stor_control_thread(void * __us)
 
 		/* unlock the device pointers */
 		mutex_unlock(&amp;us-&gt;dev_mutex);
+
+		/* Start an autosuspend */
+		if (autopm_rc == 0)
+			usb_autopm_put_interface(us-&gt;pusb_intf);
 	} /* for (;;) */
 
 	/* Wait until we are told to stop */
@@ -939,6 +949,7 @@ static int usb_stor_scan_thread(void * __us)
 	}
 
 	scsi_host_put(us_to_host(us));
+	usb_autopm_put_interface(us-&gt;pusb_intf);
 	complete_and_exit(&amp;threads_gone, 0);
 }
 
@@ -1028,6 +1039,7 @@ static int storage_probe(struct usb_interface *intf,
 	 * start it up. */
 	scsi_host_get(us_to_host(us));
 	atomic_inc(&amp;total_threads);
+	usb_autopm_get_interface(intf); /* dropped in the scanning thread */
 	wake_up_process(th);
 
 	return 0;
@@ -1065,6 +1077,7 @@ static struct usb_driver usb_storage_driver = {
 	.pre_reset =	storage_pre_reset,
 	.post_reset =	storage_post_reset,
 	.id_table =	storage_usb_ids,
+	.supports_autosuspend = 1,
 };
 
 static int __init usb_stor_init(void)</pre><hr><pre>commit 8ccef0df54642f0f72f922d8aa57e8b290e31671
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jun 21 16:26:46 2007 -0400

    USB: Fix off-by-1 error in the scatter-gather library
    
    The loop in usb_sg_wait() is structured in a way that makes it hard to
    tell, when the loop exits, whether or not the last URB submission
    succeeded.  This patch (as928) changes it from a "for" loop to a
    "while" loop and keeps "i" always equal to the number of successful
    submissions.  This fixes an off-by-one error which can show up when
    the first URB submission fails.
    
    The patch also removes a couple of lines that initialize fields which
    don't need to be initialized.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index f9fed34bf7d8..4c1432314711 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -404,8 +404,6 @@ int usb_sg_init (
 
 		io-&gt;urbs [i]-&gt;complete = sg_complete;
 		io-&gt;urbs [i]-&gt;context = io;
-		io-&gt;urbs [i]-&gt;status = -EINPROGRESS;
-		io-&gt;urbs [i]-&gt;actual_length = 0;
 
 		/*
 		 * Some systems need to revert to PIO when DMA is temporarily
@@ -499,7 +497,8 @@ void usb_sg_wait (struct usb_sg_request *io)
 
 	/* queue the urbs.  */
 	spin_lock_irq (&amp;io-&gt;lock);
-	for (i = 0; i &lt; entries &amp;&amp; !io-&gt;status; i++) {
+	i = 0;
+	while (i &lt; entries &amp;&amp; !io-&gt;status) {
 		int	retval;
 
 		io-&gt;urbs [i]-&gt;dev = io-&gt;dev;
@@ -516,7 +515,6 @@ void usb_sg_wait (struct usb_sg_request *io)
 		case -ENOMEM:
 			io-&gt;urbs[i]-&gt;dev = NULL;
 			retval = 0;
-			i--;
 			yield ();
 			break;
 
@@ -527,6 +525,7 @@ void usb_sg_wait (struct usb_sg_request *io)
 			 * URBs are queued at once; N milliseconds?
 			 */
 		case 0:
+			++i;
 			cpu_relax ();
 			break;
 </pre>
    <div class="pagination">
        <a href='2_104.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><span>[105]</span><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_106.html'>Next&gt;&gt;</a>
    <div>
</body>
