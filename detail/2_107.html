<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_106.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><span>[107]</span><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_108.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 4956eccdd6101c5abb71966079e8183d12796d6c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed May 30 16:51:28 2007 -0400

    USB: remove __usb_port_suspend
    
    This patch (as915b) combines the public routine usb_port_suspend() and
    the private routine __usb_port_suspend() into a single function.
    
    By removing the explicit mention of otg_port in the call to
    __usb_port_suspend(), we prevent a possible error in which the system
    tries to perform HNP on the wrong port when a non-targeted device is
    plugged into a non-OTG port.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 7946d7b6c71a..04d6fde57d88 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1333,7 +1333,6 @@ static inline void show_string(struct usb_device *udev, char *id, char *string)
 
 #ifdef	CONFIG_USB_OTG
 #include "otg_whitelist.h"
-static int __usb_port_suspend(struct usb_device *, int port1);
 #endif
 
 /**
@@ -1439,7 +1438,7 @@ int usb_new_device(struct usb_device *udev)
 		 * (Includes HNP test device.)
 		 */
 		if (udev-&gt;bus-&gt;b_hnp_enable || udev-&gt;bus-&gt;is_b_host) {
-			err = __usb_port_suspend(udev, udev-&gt;bus-&gt;otg_port);
+			err = usb_port_suspend(udev);
 			if (err &lt; 0)
 				dev_dbg(&amp;udev-&gt;dev, "HNP fail, %d\n", err);
 		}
@@ -1683,6 +1682,23 @@ static int hub_port_suspend(struct usb_hub *hub, int port1,
 }
 
 /*
+ * usb_port_suspend - suspend a usb device's upstream port
+ * @udev: device that's no longer in active use
+ * Context: must be able to sleep; device not locked; pm locks held
+ *
+ * Suspends a USB device that isn't in active use, conserving power.
+ * Devices may wake out of a suspend, if anything important happens,
+ * using the remote wakeup mechanism.  They may also be taken out of
+ * suspend by the host, using usb_port_resume().  It's also routine
+ * to disconnect devices while they are suspended.
+ *
+ * This only affects the USB hardware for a device; its interfaces
+ * (and, for hubs, child devices) must already have been suspended.
+ *
+ * Suspending OTG devices may trigger HNP, if that's been enabled
+ * between a pair of dual-role devices.  That will change roles, such
+ * as from A-Host to A-Peripheral or from B-Host back to B-Peripheral.
+ *
  * Devices on USB hub ports have only one "suspend" state, corresponding
  * to ACPI D2, "may cause the device to lose some context".
  * State transitions include:
@@ -1699,21 +1715,19 @@ static int hub_port_suspend(struct usb_hub *hub, int port1,
  * If CONFIG_USB_SUSPEND isn't enabled, devices only really suspend when
  * the root hub for their bus goes into global suspend ... so we don't
  * (falsely) update the device power state to say it suspended.
+ *
+ * Returns 0 on success, else negative errno.
  */
-static int __usb_port_suspend (struct usb_device *udev, int port1)
+int usb_port_suspend(struct usb_device *udev)
 {
 	int	status = 0;
 
-	/* caller owns the udev device lock */
-	if (port1 &lt; 0)
-		return port1;
-
 	/* we change the device's upstream USB link,
 	 * but root hubs have no upstream USB link.
 	 */
 	if (udev-&gt;parent)
-		status = hub_port_suspend(hdev_to_hub(udev-&gt;parent), port1,
-				udev);
+		status = hub_port_suspend(hdev_to_hub(udev-&gt;parent),
+				udev-&gt;portnum, udev);
 	else {
 		dev_dbg(&amp;udev-&gt;dev, "usb %ssuspend\n",
 				udev-&gt;auto_pm ? "auto-" : "");
@@ -1722,31 +1736,6 @@ static int __usb_port_suspend (struct usb_device *udev, int port1)
 	return status;
 }
 
-/*
- * usb_port_suspend - suspend a usb device's upstream port
- * @udev: device that's no longer in active use
- * Context: must be able to sleep; device not locked; pm locks held
- *
- * Suspends a USB device that isn't in active use, conserving power.
- * Devices may wake out of a suspend, if anything important happens,
- * using the remote wakeup mechanism.  They may also be taken out of
- * suspend by the host, using usb_port_resume().  It's also routine
- * to disconnect devices while they are suspended.
- *
- * This only affects the USB hardware for a device; its interfaces
- * (and, for hubs, child devices) must already have been suspended.
- *
- * Suspending OTG devices may trigger HNP, if that's been enabled
- * between a pair of dual-role devices.  That will change roles, such
- * as from A-Host to A-Peripheral or from B-Host back to B-Peripheral.
- *
- * Returns 0 on success, else negative errno.
- */
-int usb_port_suspend(struct usb_device *udev)
-{
-	return __usb_port_suspend(udev, udev-&gt;portnum);
-}
-
 /*
  * If the USB "suspend" state is in use (rather than "global suspend"),
  * many devices will be individually taken out of suspend state using
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 1a4862886733..a547499c45f4 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -53,8 +53,16 @@ static inline void usb_pm_unlock(struct usb_device *udev)
 
 #else
 
-#define usb_port_suspend(dev)		0
-#define usb_port_resume(dev)		0
+static inline int usb_port_suspend(struct usb_device *udev)
+{
+	return 0;
+}
+
+static inline int usb_port_resume(struct usb_device *udev)
+{
+	return 0;
+}
+
 static inline void usb_pm_lock(struct usb_device *udev) {}
 static inline void usb_pm_unlock(struct usb_device *udev) {}
 </pre><hr><pre>commit 20dfdad74a2baabeecc2896c770efcbf698b9b8d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 22 11:50:17 2007 -0400

    USB: rework C++-style comments
    
    This patch (as911) replaces some C++-style commented-out debugging
    lines in driver.c with a new "verbose debugging" macro.  It makes the
    code look cleaner, and it's easier to turn the debugging on or off.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 02d6db61c940..6c62a6d91484 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -29,6 +29,14 @@
 #include "hcd.h"
 #include "usb.h"
 
+#define VERBOSE_DEBUG	0
+
+#if VERBOSE_DEBUG
+#define dev_vdbg	dev_dbg
+#else
+#define dev_vdbg(dev, fmt, args...)	do { } while (0)
+#endif
+
 #ifdef CONFIG_HOTPLUG
 
 /*
@@ -812,8 +820,8 @@ static int usb_suspend_device(struct usb_device *udev, pm_message_t msg)
 	}
 	status = udriver-&gt;suspend(udev, msg);
 
-done:
-	// dev_dbg(&amp;udev-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
+ done:
+	dev_vdbg(&amp;udev-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
 	if (status == 0)
 		udev-&gt;dev.power.power_state.event = msg.event;
 	return status;
@@ -842,8 +850,8 @@ static int usb_resume_device(struct usb_device *udev)
 	udriver = to_usb_device_driver(udev-&gt;dev.driver);
 	status = udriver-&gt;resume(udev);
 
-done:
-	// dev_dbg(&amp;udev-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
+ done:
+	dev_vdbg(&amp;udev-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
 	if (status == 0) {
 		udev-&gt;autoresume_disabled = 0;
 		udev-&gt;dev.power.power_state.event = PM_EVENT_ON;
@@ -881,8 +889,8 @@ static int usb_suspend_interface(struct usb_interface *intf, pm_message_t msg)
 		mark_quiesced(intf);
 	}
 
-done:
-	// dev_dbg(&amp;intf-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
+ done:
+	dev_vdbg(&amp;intf-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
 	return status;
 }
 
@@ -919,7 +927,7 @@ static int usb_resume_interface(struct usb_interface *intf, int reset_resume)
 				driver-&gt;name);
 
 done:
-	// dev_dbg(&amp;intf-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
+	dev_vdbg(&amp;intf-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
 	if (status == 0)
 		mark_active(intf);
 	return status;
@@ -1083,7 +1091,7 @@ static int usb_suspend_both(struct usb_device *udev, pm_message_t msg)
 	}
 
  done:
-	// dev_dbg(&amp;udev-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
+	dev_vdbg(&amp;udev-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
 	return status;
 }
 
@@ -1180,7 +1188,7 @@ static int usb_resume_both(struct usb_device *udev)
 	}
 
  done:
-	// dev_dbg(&amp;udev-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
+	dev_vdbg(&amp;udev-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
 	udev-&gt;reset_resume = 0;
 	return status;
 }
@@ -1248,8 +1256,8 @@ void usb_autosuspend_device(struct usb_device *udev)
 	int	status;
 
 	status = usb_autopm_do_device(udev, -1);
-	// dev_dbg(&amp;udev-&gt;dev, "%s: cnt %d\n",
-	//		__FUNCTION__, udev-&gt;pm_usage_cnt);
+	dev_vdbg(&amp;udev-&gt;dev, "%s: cnt %d\n",
+			__FUNCTION__, udev-&gt;pm_usage_cnt);
 }
 
 /**
@@ -1268,8 +1276,8 @@ void usb_autosuspend_device(struct usb_device *udev)
 void usb_try_autosuspend_device(struct usb_device *udev)
 {
 	usb_autopm_do_device(udev, 0);
-	// dev_dbg(&amp;udev-&gt;dev, "%s: cnt %d\n",
-	// 		__FUNCTION__, udev-&gt;pm_usage_cnt);
+	dev_vdbg(&amp;udev-&gt;dev, "%s: cnt %d\n",
+			__FUNCTION__, udev-&gt;pm_usage_cnt);
 }
 
 /**
@@ -1296,8 +1304,8 @@ int usb_autoresume_device(struct usb_device *udev)
 	int	status;
 
 	status = usb_autopm_do_device(udev, 1);
-	// dev_dbg(&amp;udev-&gt;dev, "%s: status %d cnt %d\n",
-	//		__FUNCTION__, status, udev-&gt;pm_usage_cnt);
+	dev_vdbg(&amp;udev-&gt;dev, "%s: status %d cnt %d\n",
+			__FUNCTION__, status, udev-&gt;pm_usage_cnt);
 	return status;
 }
 
@@ -1369,8 +1377,8 @@ void usb_autopm_put_interface(struct usb_interface *intf)
 	int	status;
 
 	status = usb_autopm_do_interface(intf, -1);
-	// dev_dbg(&amp;intf-&gt;dev, "%s: status %d cnt %d\n",
-	//		__FUNCTION__, status, intf-&gt;pm_usage_cnt);
+	dev_vdbg(&amp;intf-&gt;dev, "%s: status %d cnt %d\n",
+			__FUNCTION__, status, intf-&gt;pm_usage_cnt);
 }
 EXPORT_SYMBOL_GPL(usb_autopm_put_interface);
 
@@ -1413,8 +1421,8 @@ int usb_autopm_get_interface(struct usb_interface *intf)
 	int	status;
 
 	status = usb_autopm_do_interface(intf, 1);
-	// dev_dbg(&amp;intf-&gt;dev, "%s: status %d cnt %d\n",
-	//		__FUNCTION__, status, intf-&gt;pm_usage_cnt);
+	dev_vdbg(&amp;intf-&gt;dev, "%s: status %d cnt %d\n",
+			__FUNCTION__, status, intf-&gt;pm_usage_cnt);
 	return status;
 }
 EXPORT_SYMBOL_GPL(usb_autopm_get_interface);
@@ -1435,8 +1443,8 @@ int usb_autopm_set_interface(struct usb_interface *intf)
 	int	status;
 
 	status = usb_autopm_do_interface(intf, 0);
-	// dev_dbg(&amp;intf-&gt;dev, "%s: status %d cnt %d\n",
-	//		__FUNCTION__, status, intf-&gt;pm_usage_cnt);
+	dev_vdbg(&amp;intf-&gt;dev, "%s: status %d cnt %d\n",
+			__FUNCTION__, status, intf-&gt;pm_usage_cnt);
 	return status;
 }
 EXPORT_SYMBOL_GPL(usb_autopm_set_interface);</pre><hr><pre>commit d4ead16f50f9ad30bdc7276ec8fee7a24c72f294
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 22 11:46:41 2007 -0400

    USB: prevent char device open/deregister race
    
    This patch (as908) adds central protection in usbcore for the
    prototypical race between opening and unregistering a char device.
    The spinlock used to protect the minor-numbers array is replaced with
    an rwsem, which can remain locked across a call to a driver's open()
    method.  This guarantees that open() and deregister() will be mutually
    exclusive.
    
    The private locks currently used in several individual drivers for
    this purpose are no longer necessary, and the patch removes them.  The
    following USB drivers are affected: usblcd, idmouse, auerswald,
    legousbtower, sisusbvga/sisusb, ldusb, adutux, iowarrior, and
    usb-skeleton.
    
    As a side effect of this change, usb_deregister_dev() must not be
    called while holding a lock that is acquired by open().  Unfortunately
    a number of drivers do this, but luckily the solution is simple: call
    usb_deregister_dev() before acquiring the lock.
    
    In addition to these changes (and their consequent code
    simplifications), the patch fixes a use-after-free bug in adutux and a
    race between open() and release() in iowarrior.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/file.c b/drivers/usb/core/file.c
index 01c857ac27af..5d860bc9b421 100644
--- a/drivers/usb/core/file.c
+++ b/drivers/usb/core/file.c
@@ -16,15 +16,15 @@
  */
 
 #include &lt;linux/module.h&gt;
-#include &lt;linux/spinlock.h&gt;
 #include &lt;linux/errno.h&gt;
+#include &lt;linux/rwsem.h&gt;
 #include &lt;linux/usb.h&gt;
 
 #include "usb.h"
 
 #define MAX_USB_MINORS	256
 static const struct file_operations *usb_minors[MAX_USB_MINORS];
-static DEFINE_SPINLOCK(minor_lock);
+static DECLARE_RWSEM(minor_rwsem);
 
 static int usb_open(struct inode * inode, struct file * file)
 {
@@ -33,14 +33,11 @@ static int usb_open(struct inode * inode, struct file * file)
 	int err = -ENODEV;
 	const struct file_operations *old_fops, *new_fops = NULL;
 
-	spin_lock (&amp;minor_lock);
+	down_read(&amp;minor_rwsem);
 	c = usb_minors[minor];
 
-	if (!c || !(new_fops = fops_get(c))) {
-		spin_unlock(&amp;minor_lock);
-		return err;
-	}
-	spin_unlock(&amp;minor_lock);
+	if (!c || !(new_fops = fops_get(c)))
+		goto done;
 
 	old_fops = file-&gt;f_op;
 	file-&gt;f_op = new_fops;
@@ -52,6 +49,8 @@ static int usb_open(struct inode * inode, struct file * file)
 		file-&gt;f_op = fops_get(old_fops);
 	}
 	fops_put(old_fops);
+ done:
+	up_read(&amp;minor_rwsem);
 	return err;
 }
 
@@ -166,7 +165,7 @@ int usb_register_dev(struct usb_interface *intf,
 	if (class_driver-&gt;fops == NULL)
 		goto exit;
 
-	spin_lock (&amp;minor_lock);
+	down_write(&amp;minor_rwsem);
 	for (minor = minor_base; minor &lt; MAX_USB_MINORS; ++minor) {
 		if (usb_minors[minor])
 			continue;
@@ -176,7 +175,7 @@ int usb_register_dev(struct usb_interface *intf,
 		retval = 0;
 		break;
 	}
-	spin_unlock (&amp;minor_lock);
+	up_write(&amp;minor_rwsem);
 
 	if (retval)
 		goto exit;
@@ -197,9 +196,9 @@ int usb_register_dev(struct usb_interface *intf,
 	intf-&gt;usb_dev = device_create(usb_class-&gt;class, &amp;intf-&gt;dev,
 				      MKDEV(USB_MAJOR, minor), "%s", temp);
 	if (IS_ERR(intf-&gt;usb_dev)) {
-		spin_lock (&amp;minor_lock);
+		down_write(&amp;minor_rwsem);
 		usb_minors[intf-&gt;minor] = NULL;
-		spin_unlock (&amp;minor_lock);
+		up_write(&amp;minor_rwsem);
 		retval = PTR_ERR(intf-&gt;usb_dev);
 	}
 exit:
@@ -236,9 +235,9 @@ void usb_deregister_dev(struct usb_interface *intf,
 
 	dbg ("removing %d minor", intf-&gt;minor);
 
-	spin_lock (&amp;minor_lock);
+	down_write(&amp;minor_rwsem);
 	usb_minors[intf-&gt;minor] = NULL;
-	spin_unlock (&amp;minor_lock);
+	up_write(&amp;minor_rwsem);
 
 	snprintf(name, BUS_ID_SIZE, class_driver-&gt;name, intf-&gt;minor - minor_base);
 	device_destroy(usb_class-&gt;class, MKDEV(USB_MAJOR, intf-&gt;minor));
@@ -247,5 +246,3 @@ void usb_deregister_dev(struct usb_interface *intf,
 	destroy_usb_class();
 }
 EXPORT_SYMBOL(usb_deregister_dev);
-
-
diff --git a/drivers/usb/misc/adutux.c b/drivers/usb/misc/adutux.c
index 77145f9db043..d72c42e5f22d 100644
--- a/drivers/usb/misc/adutux.c
+++ b/drivers/usb/misc/adutux.c
@@ -108,8 +108,6 @@ struct adu_device {
 	struct urb*		interrupt_out_urb;
 };
 
-/* prevent races between open() and disconnect */
-static DEFINE_MUTEX(disconnect_mutex);
 static struct usb_driver adu_driver;
 
 static void adu_debug_data(int level, const char *function, int size,
@@ -256,8 +254,6 @@ static int adu_open(struct inode *inode, struct file *file)
 
 	subminor = iminor(inode);
 
-	mutex_lock(&amp;disconnect_mutex);
-
 	interface = usb_find_interface(&amp;adu_driver, subminor);
 	if (!interface) {
 		err("%s - error, can't find device for minor %d",
@@ -306,7 +302,6 @@ static int adu_open(struct inode *inode, struct file *file)
 	up(&amp;dev-&gt;sem);
 
 exit_no_device:
-	mutex_unlock(&amp;disconnect_mutex);
 	dbg(2,"%s : leave, return value %d ", __FUNCTION__, retval);
 
 	return retval;
@@ -318,12 +313,6 @@ static int adu_release_internal(struct adu_device *dev)
 
 	dbg(2," %s : enter", __FUNCTION__);
 
-	if (dev-&gt;udev == NULL) {
-		/* the device was unplugged before the file was released */
-		adu_delete(dev);
-		goto exit;
-	}
-
 	/* decrement our usage count for the device */
 	--dev-&gt;open_count;
 	dbg(2," %s : open count %d", __FUNCTION__, dev-&gt;open_count);
@@ -332,7 +321,6 @@ static int adu_release_internal(struct adu_device *dev)
 		dev-&gt;open_count = 0;
 	}
 
-exit:
 	dbg(2," %s : leave", __FUNCTION__);
 	return retval;
 }
@@ -367,8 +355,15 @@ static int adu_release(struct inode *inode, struct file *file)
 		goto exit;
 	}
 
-	/* do the work */
-	retval = adu_release_internal(dev);
+	if (dev-&gt;udev == NULL) {
+		/* the device was unplugged before the file was released */
+		up(&amp;dev-&gt;sem);
+		adu_delete(dev);
+		dev = NULL;
+	} else {
+		/* do the work */
+		retval = adu_release_internal(dev);
+	}
 
 exit:
 	if (dev)
@@ -831,19 +826,17 @@ static void adu_disconnect(struct usb_interface *interface)
 
 	dbg(2," %s : enter", __FUNCTION__);
 
-	mutex_lock(&amp;disconnect_mutex); /* not interruptible */
-
 	dev = usb_get_intfdata(interface);
 	usb_set_intfdata(interface, NULL);
 
-	down(&amp;dev-&gt;sem); /* not interruptible */
-
 	minor = dev-&gt;minor;
 
 	/* give back our minor */
 	usb_deregister_dev(interface, &amp;adu_class);
 	dev-&gt;minor = 0;
 
+	down(&amp;dev-&gt;sem); /* not interruptible */
+
 	/* if the device is not opened, then we clean up right now */
 	dbg(2," %s : open count %d", __FUNCTION__, dev-&gt;open_count);
 	if (!dev-&gt;open_count) {
@@ -854,8 +847,6 @@ static void adu_disconnect(struct usb_interface *interface)
 		up(&amp;dev-&gt;sem);
 	}
 
-	mutex_unlock(&amp;disconnect_mutex);
-
 	dev_info(&amp;interface-&gt;dev, "ADU device adutux%d now disconnected",
 		 (minor - ADU_MINOR_BASE));
 
diff --git a/drivers/usb/misc/auerswald.c b/drivers/usb/misc/auerswald.c
index cac1500cba62..1fd5fc220cd7 100644
--- a/drivers/usb/misc/auerswald.c
+++ b/drivers/usb/misc/auerswald.c
@@ -2034,12 +2034,12 @@ static void auerswald_disconnect (struct usb_interface *intf)
 	if (!cp)
 		return;
 
-	down (&amp;cp-&gt;mutex);
-	info ("device /dev/%s now disconnecting", cp-&gt;name);
-
 	/* give back our USB minor number */
 	usb_deregister_dev(intf, &amp;auerswald_class);
 
+	down (&amp;cp-&gt;mutex);
+	info ("device /dev/%s now disconnecting", cp-&gt;name);
+
 	/* Stop the interrupt endpoint */
 	auerswald_int_release (cp);
 
diff --git a/drivers/usb/misc/idmouse.c b/drivers/usb/misc/idmouse.c
index 8d0e360636e6..e6fd024024f5 100644
--- a/drivers/usb/misc/idmouse.c
+++ b/drivers/usb/misc/idmouse.c
@@ -119,9 +119,6 @@ static struct usb_driver idmouse_driver = {
 	.id_table = idmouse_table,
 };
 
-/* prevent races between open() and disconnect() */
-static DEFINE_MUTEX(disconnect_mutex);
-
 static int idmouse_create_image(struct usb_idmouse *dev)
 {
 	int bytes_read;
@@ -211,21 +208,15 @@ static int idmouse_open(struct inode *inode, struct file *file)
 	struct usb_interface *interface;
 	int result;
 
-	/* prevent disconnects */
-	mutex_lock(&amp;disconnect_mutex);
-
 	/* get the interface from minor number and driver information */
 	interface = usb_find_interface (&amp;idmouse_driver, iminor (inode));
-	if (!interface) {
-		mutex_unlock(&amp;disconnect_mutex);
+	if (!interface)
 		return -ENODEV;
-	}
+
 	/* get the device information block from the interface */
 	dev = usb_get_intfdata(interface);
-	if (!dev) {
-		mutex_unlock(&amp;disconnect_mutex);
+	if (!dev)
 		return -ENODEV;
-	}
 
 	/* lock this device */
 	down(&amp;dev-&gt;sem);
@@ -255,9 +246,6 @@ static int idmouse_open(struct inode *inode, struct file *file)
 
 	/* unlock this device */
 	up(&amp;dev-&gt;sem);
-
-	/* unlock the disconnect semaphore */
-	mutex_unlock(&amp;disconnect_mutex);
 	return result;
 }
 
@@ -265,15 +253,10 @@ static int idmouse_release(struct inode *inode, struct file *file)
 {
 	struct usb_idmouse *dev;
 
-	/* prevent a race condition with open() */
-	mutex_lock(&amp;disconnect_mutex);
-
 	dev = file-&gt;private_data;
 
-	if (dev == NULL) {
-		mutex_unlock(&amp;disconnect_mutex);
+	if (dev == NULL)
 		return -ENODEV;
-	}
 
 	/* lock our device */
 	down(&amp;dev-&gt;sem);
@@ -281,7 +264,6 @@ static int idmouse_release(struct inode *inode, struct file *file)
 	/* are we really open? */
 	if (dev-&gt;open &lt;= 0) {
 		up(&amp;dev-&gt;sem);
-		mutex_unlock(&amp;disconnect_mutex);
 		return -ENODEV;
 	}
 
@@ -291,12 +273,9 @@ static int idmouse_release(struct inode *inode, struct file *file)
 		/* the device was unplugged before the file was released */
 		up(&amp;dev-&gt;sem);
 		idmouse_delete(dev);
-		mutex_unlock(&amp;disconnect_mutex);
-		return 0;
+	} else {
+		up(&amp;dev-&gt;sem);
 	}
-
-	up(&amp;dev-&gt;sem);
-	mutex_unlock(&amp;disconnect_mutex);
 	return 0;
 }
 
@@ -391,30 +370,27 @@ static void idmouse_disconnect(struct usb_interface *interface)
 {
 	struct usb_idmouse *dev;
 
-	/* prevent races with open() */
-	mutex_lock(&amp;disconnect_mutex);
-
 	/* get device structure */
 	dev = usb_get_intfdata(interface);
 	usb_set_intfdata(interface, NULL);
 
-	/* lock it */
-	down(&amp;dev-&gt;sem);
-
 	/* give back our minor */
 	usb_deregister_dev(interface, &amp;idmouse_class);
 
+	/* lock it */
+	down(&amp;dev-&gt;sem);
+
 	/* prevent device read, write and ioctl */
 	dev-&gt;present = 0;
 
-	/* unlock */
-	up(&amp;dev-&gt;sem);
-
 	/* if the device is opened, idmouse_release will clean this up */
-	if (!dev-&gt;open)
+	if (!dev-&gt;open) {
+		up(&amp;dev-&gt;sem);
 		idmouse_delete(dev);
-
-	mutex_unlock(&amp;disconnect_mutex);
+	} else {
+		/* unlock */
+		up(&amp;dev-&gt;sem);
+	}
 
 	info("%s disconnected", DRIVER_DESC);
 }
diff --git a/drivers/usb/misc/iowarrior.c b/drivers/usb/misc/iowarrior.c
index 3bb33f7bfa36..28548d186712 100644
--- a/drivers/usb/misc/iowarrior.c
+++ b/drivers/usb/misc/iowarrior.c
@@ -100,8 +100,6 @@ struct iowarrior {
 /*--------------*/
 /*    globals   */
 /*--------------*/
-/* prevent races between open() and disconnect() */
-static DECLARE_MUTEX(disconnect_sem);
 
 /*
  *  USB spec identifies 5 second timeouts.
@@ -600,22 +598,18 @@ static int iowarrior_open(struct inode *inode, struct file *file)
 
 	subminor = iminor(inode);
 
-	/* prevent disconnects */
-	down(&amp;disconnect_sem);
-
 	interface = usb_find_interface(&amp;iowarrior_driver, subminor);
 	if (!interface) {
 		err("%s - error, can't find device for minor %d", __FUNCTION__,
 		    subminor);
-		retval = -ENODEV;
-		goto out;
+		return -ENODEV;
 	}
 
 	dev = usb_get_intfdata(interface);
-	if (!dev) {
-		retval = -ENODEV;
-		goto out;
-	}
+	if (!dev)
+		return -ENODEV;
+
+	mutex_lock(&amp;dev-&gt;mutex);
 
 	/* Only one process can open each device, no sharing. */
 	if (dev-&gt;opened) {
@@ -636,7 +630,7 @@ static int iowarrior_open(struct inode *inode, struct file *file)
 	retval = 0;
 
 out:
-	up(&amp;disconnect_sem);
+	mutex_unlock(&amp;dev-&gt;mutex);
 	return retval;
 }
 
@@ -868,19 +862,16 @@ static void iowarrior_disconnect(struct usb_interface *interface)
 	struct iowarrior *dev;
 	int minor;
 
-	/* prevent races with open() */
-	down(&amp;disconnect_sem);
-
 	dev = usb_get_intfdata(interface);
 	usb_set_intfdata(interface, NULL);
 
-	mutex_lock(&amp;dev-&gt;mutex);
-
 	minor = dev-&gt;minor;
 
 	/* give back our minor */
 	usb_deregister_dev(interface, &amp;iowarrior_class);
 
+	mutex_lock(&amp;dev-&gt;mutex);
+
 	/* prevent device read, write and ioctl */
 	dev-&gt;present = 0;
 
@@ -898,7 +889,6 @@ static void iowarrior_disconnect(struct usb_interface *interface)
 		/* no process is using the device, cleanup now */
 		iowarrior_delete(dev);
 	}
-	up(&amp;disconnect_sem);
 
 	dev_info(&amp;interface-&gt;dev, "I/O-Warror #%d now disconnected\n",
 		 minor - IOWARRIOR_MINOR_BASE);
diff --git a/drivers/usb/misc/ldusb.c b/drivers/usb/misc/ldusb.c
index 7bad49404762..5e950b90c541 100644
--- a/drivers/usb/misc/ldusb.c
+++ b/drivers/usb/misc/ldusb.c
@@ -176,9 +176,6 @@ struct ld_usb {
 	int			interrupt_out_busy;
 };
 
-/* prevent races between open() and disconnect() */
-static DEFINE_MUTEX(disconnect_mutex);
-
 static struct usb_driver ld_usb_driver;
 
 /**
@@ -298,35 +295,28 @@ static int ld_usb_open(struct inode *inode, struct file *file)
 {
 	struct ld_usb *dev;
 	int subminor;
-	int retval = 0;
+	int retval;
 	struct usb_interface *interface;
 
 	nonseekable_open(inode, file);
 	subminor = iminor(inode);
 
-	mutex_lock(&amp;disconnect_mutex);
-
 	interface = usb_find_interface(&amp;ld_usb_driver, subminor);
 
 	if (!interface) {
 		err("%s - error, can't find device for minor %d\n",
 		     __FUNCTION__, subminor);
-		retval = -ENODEV;
-		goto unlock_disconnect_exit;
+		return -ENODEV;
 	}
 
 	dev = usb_get_intfdata(interface);
 
-	if (!dev) {
-		retval = -ENODEV;
-		goto unlock_disconnect_exit;
-	}
+	if (!dev)
+		return -ENODEV;
 
 	/* lock this device */
-	if (down_interruptible(&amp;dev-&gt;sem)) {
-		retval = -ERESTARTSYS;
-		goto unlock_disconnect_exit;
-	}
+	if (down_interruptible(&amp;dev-&gt;sem))
+		return -ERESTARTSYS;
 
 	/* allow opening only once */
 	if (dev-&gt;open_count) {
@@ -366,9 +356,6 @@ static int ld_usb_open(struct inode *inode, struct file *file)
 unlock_exit:
 	up(&amp;dev-&gt;sem);
 
-unlock_disconnect_exit:
-	mutex_unlock(&amp;disconnect_mutex);
-
 	return retval;
 }
 
@@ -766,18 +753,16 @@ static void ld_usb_disconnect(struct usb_interface *intf)
 	struct ld_usb *dev;
 	int minor;
 
-	mutex_lock(&amp;disconnect_mutex);
-
 	dev = usb_get_intfdata(intf);
 	usb_set_intfdata(intf, NULL);
 
-	down(&amp;dev-&gt;sem);
-
 	minor = intf-&gt;minor;
 
 	/* give back our minor */
 	usb_deregister_dev(intf, &amp;ld_usb_class);
 
+	down(&amp;dev-&gt;sem);
+
 	/* if the device is not opened, then we clean up right now */
 	if (!dev-&gt;open_count) {
 		up(&amp;dev-&gt;sem);
@@ -787,8 +772,6 @@ static void ld_usb_disconnect(struct usb_interface *intf)
 		up(&amp;dev-&gt;sem);
 	}
 
-	mutex_unlock(&amp;disconnect_mutex);
-
 	dev_info(&amp;intf-&gt;dev, "LD USB Device #%d now disconnected\n",
 		 (minor - USB_LD_MINOR_BASE));
 }
diff --git a/drivers/usb/misc/legousbtower.c b/drivers/usb/misc/legousbtower.c
index 1713e19a7899..2ed0daea894c 100644
--- a/drivers/usb/misc/legousbtower.c
+++ b/drivers/usb/misc/legousbtower.c
@@ -254,9 +254,6 @@ static int  tower_probe	(struct usb_interface *interface, const struct usb_devic
 static void tower_disconnect	(struct usb_interface *interface);
 
 
-/* prevent races between open() and disconnect */
-static DEFINE_MUTEX (disconnect_mutex);
-
 /* file operations needed when we register this driver */
 static const struct file_operations tower_fops = {
 	.owner =	THIS_MODULE,
@@ -344,28 +341,26 @@ static int tower_open (struct inode *inode, struct file *file)
 	nonseekable_open(inode, file);
 	subminor = iminor(inode);
 
-	mutex_lock (&amp;disconnect_mutex);
-
 	interface = usb_find_interface (&amp;tower_driver, subminor);
 
 	if (!interface) {
 		err ("%s - error, can't find device for minor %d",
 		     __FUNCTION__, subminor);
 		retval = -ENODEV;
-		goto unlock_disconnect_exit;
+		goto exit;
 	}
 
 	dev = usb_get_intfdata(interface);
 
 	if (!dev) {
 		retval = -ENODEV;
-		goto unlock_disconnect_exit;
+		goto exit;
 	}
 
 	/* lock this device */
 	if (down_interruptible (&amp;dev-&gt;sem)) {
 	        retval = -ERESTARTSYS;
-		goto unlock_disconnect_exit;
+		goto exit;
 	}
 
 	/* allow opening only once */
@@ -421,9 +416,7 @@ static int tower_open (struct inode *inode, struct file *file)
 unlock_exit:
 	up (&amp;dev-&gt;sem);
 
-unlock_disconnect_exit:
-	mutex_unlock (&amp;disconnect_mutex);
-
+exit:
 	dbg(2, "%s: leave, return value %d ", __FUNCTION__, retval);
 
 	return retval;
@@ -993,19 +986,16 @@ static void tower_disconnect (struct usb_interface *interface)
 
 	dbg(2, "%s: enter", __FUNCTION__);
 
-	mutex_lock (&amp;disconnect_mutex);
-
 	dev = usb_get_intfdata (interface);
 	usb_set_intfdata (interface, NULL);
 
-
-	down (&amp;dev-&gt;sem);
-
 	minor = dev-&gt;minor;
 
 	/* give back our minor */
 	usb_deregister_dev (interface, &amp;tower_class);
 
+	down (&amp;dev-&gt;sem);
+
 	/* if the device is not opened, then we clean up right now */
 	if (!dev-&gt;open_count) {
 		up (&amp;dev-&gt;sem);
@@ -1015,8 +1005,6 @@ static void tower_disconnect (struct usb_interface *interface)
 		up (&amp;dev-&gt;sem);
 	}
 
-	mutex_unlock (&amp;disconnect_mutex);
-
 	info("LEGO USB Tower #%d now disconnected", (minor - LEGO_USB_TOWER_MINOR_BASE));
 
 	dbg(2, "%s: leave", __FUNCTION__);
diff --git a/drivers/usb/misc/sisusbvga/sisusb.c b/drivers/usb/misc/sisusbvga/sisusb.c
index 6f8b134a79cb..9f37ba44c132 100644
--- a/drivers/usb/misc/sisusbvga/sisusb.c
+++ b/drivers/usb/misc/sisusbvga/sisusb.c
@@ -72,8 +72,6 @@ MODULE_PARM_DESC(last, "Number of last console to take over (1 - MAX_NR_CONSOLES
 
 static struct usb_driver sisusb_driver;
 
-DEFINE_MUTEX(disconnect_mutex);
-
 static void
 sisusb_free_buffers(struct sisusb_usb_data *sisusb)
 {
@@ -2511,31 +2509,24 @@ sisusb_open(struct inode *inode, struct file *file)
 	struct usb_interface *interface;
 	int subminor = iminor(inode);
 
-	mutex_lock(&amp;disconnect_mutex);
-
 	if (!(interface = usb_find_interface(&amp;sisusb_driver, subminor))) {
 		printk(KERN_ERR "sisusb[%d]: Failed to find interface\n",
 				subminor);
-		mutex_unlock(&amp;disconnect_mutex);
 		return -ENODEV;
 	}
 
-	if (!(sisusb = usb_get_intfdata(interface))) {
-		mutex_unlock(&amp;disconnect_mutex);
+	if (!(sisusb = usb_get_intfdata(interface)))
 		return -ENODEV;
-	}
 
 	mutex_lock(&amp;sisusb-&gt;lock);
 
 	if (!sisusb-&gt;present || !sisusb-&gt;ready) {
 		mutex_unlock(&amp;sisusb-&gt;lock);
-		mutex_unlock(&amp;disconnect_mutex);
 		return -ENODEV;
 	}
 
 	if (sisusb-&gt;isopen) {
 		mutex_unlock(&amp;sisusb-&gt;lock);
-		mutex_unlock(&amp;disconnect_mutex);
 		return -EBUSY;
 	}
 
@@ -2543,7 +2534,6 @@ sisusb_open(struct inode *inode, struct file *file)
 		if (sisusb-&gt;sisusb_dev-&gt;speed == USB_SPEED_HIGH) {
 			if (sisusb_init_gfxdevice(sisusb, 0)) {
 				mutex_unlock(&amp;sisusb-&gt;lock);
-				mutex_unlock(&amp;disconnect_mutex);
 				printk(KERN_ERR
 					"sisusbvga[%d]: Failed to initialize "
 					"device\n",
@@ -2552,7 +2542,6 @@ sisusb_open(struct inode *inode, struct file *file)
 			}
 		} else {
 			mutex_unlock(&amp;sisusb-&gt;lock);
-			mutex_unlock(&amp;disconnect_mutex);
 			printk(KERN_ERR
 				"sisusbvga[%d]: Device not attached to "
 				"USB 2.0 hub\n",
@@ -2570,8 +2559,6 @@ sisusb_open(struct inode *inode, struct file *file)
 
 	mutex_unlock(&amp;sisusb-&gt;lock);
 
-	mutex_unlock(&amp;disconnect_mutex);
-
 	return 0;
 }
 
@@ -2601,12 +2588,8 @@ sisusb_release(struct inode *inode, struct file *file)
 	struct sisusb_usb_data *sisusb;
 	int myminor;
 
-	mutex_lock(&amp;disconnect_mutex);
-
-	if (!(sisusb = (struct sisusb_usb_data *)file-&gt;private_data)) {
-		mutex_unlock(&amp;disconnect_mutex);
+	if (!(sisusb = (struct sisusb_usb_data *)file-&gt;private_data))
 		return -ENODEV;
-	}
 
 	mutex_lock(&amp;sisusb-&gt;lock);
 
@@ -2626,8 +2609,6 @@ sisusb_release(struct inode *inode, struct file *file)
 	/* decrement the usage count on our device */
 	kref_put(&amp;sisusb-&gt;kref, sisusb_delete);
 
-	mutex_unlock(&amp;disconnect_mutex);
-
 	return 0;
 }
 
@@ -3383,12 +3364,9 @@ static void sisusb_disconnect(struct usb_interface *intf)
 	sisusb_console_exit(sisusb);
 #endif
 
-	/* The above code doesn't need the disconnect
-	 * semaphore to be down; its meaning is to
-	 * protect all other routines from the disconnect
-	 * case, not the other way round.
-	 */
-	mutex_lock(&amp;disconnect_mutex);
+	minor = sisusb-&gt;minor;
+
+	usb_deregister_dev(intf, &amp;usb_sisusb_class);
 
 	mutex_lock(&amp;sisusb-&gt;lock);
 
@@ -3396,12 +3374,8 @@ static void sisusb_disconnect(struct usb_interface *intf)
 	if (!sisusb_wait_all_out_complete(sisusb))
 		sisusb_kill_all_busy(sisusb);
 
-	minor = sisusb-&gt;minor;
-
 	usb_set_intfdata(intf, NULL);
 
-	usb_deregister_dev(intf, &amp;usb_sisusb_class);
-
 #ifdef SISUSB_OLD_CONFIG_COMPAT
 	if (sisusb-&gt;ioctl32registered) {
 		int ret;
@@ -3426,8 +3400,6 @@ static void sisusb_disconnect(struct usb_interface *intf)
 	/* decrement our usage count */
 	kref_put(&amp;sisusb-&gt;kref, sisusb_delete);
 
-	mutex_unlock(&amp;disconnect_mutex);
-
 	printk(KERN_INFO "sisusbvga[%d]: Disconnected\n", minor);
 }
 
diff --git a/drivers/usb/misc/sisusbvga/sisusb_con.c b/drivers/usb/misc/sisusbvga/sisusb_con.c
index 5947afb0017e..8d0edc867f33 100644
--- a/drivers/usb/misc/sisusbvga/sisusb_con.c
+++ b/drivers/usb/misc/sisusbvga/sisusb_con.c
@@ -214,18 +214,13 @@ sisusbcon_init(struct vc_data *c, int init)
 	 * are set up/restored.
 	 */
 
-	mutex_lock(&amp;disconnect_mutex);
-
-	if (!(sisusb = sisusb_get_sisusb(c-&gt;vc_num))) {
-		mutex_unlock(&amp;disconnect_mutex);
+	if (!(sisusb = sisusb_get_sisusb(c-&gt;vc_num)))
 		return;
-	}
 
 	mutex_lock(&amp;sisusb-&gt;lock);
 
 	if (!sisusb_sisusb_valid(sisusb)) {
 		mutex_unlock(&amp;sisusb-&gt;lock);
-		mutex_unlock(&amp;disconnect_mutex);
 		return;
 	}
 
@@ -264,8 +259,6 @@ sisusbcon_init(struct vc_data *c, int init)
 
 	mutex_unlock(&amp;sisusb-&gt;lock);
 
-	mutex_unlock(&amp;disconnect_mutex);
-
 	if (init) {
 		c-&gt;vc_cols = cols;
 		c-&gt;vc_rows = rows;
@@ -284,12 +277,8 @@ sisusbcon_deinit(struct vc_data *c)
 	 * and others, ie not under our control.
 	 */
 
-	mutex_lock(&amp;disconnect_mutex);
-
-	if (!(sisusb = sisusb_get_sisusb(c-&gt;vc_num))) {
-		mutex_unlock(&amp;disconnect_mutex);
+	if (!(sisusb = sisusb_get_sisusb(c-&gt;vc_num)))
 		return;
-	}
 
 	mutex_lock(&amp;sisusb-&gt;lock);
 
@@ -314,8 +303,6 @@ sisusbcon_deinit(struct vc_data *c)
 
 	/* decrement the usage count on our sisusb */
 	kref_put(&amp;sisusb-&gt;kref, sisusb_delete);
-
-	mutex_unlock(&amp;disconnect_mutex);
 }
 
 /* interface routine */
@@ -1490,14 +1477,11 @@ sisusb_console_init(struct sisusb_usb_data *sisusb, int first, int last)
 {
 	int i, ret, minor = sisusb-&gt;minor;
 
-	mutex_lock(&amp;disconnect_mutex);
-
 	mutex_lock(&amp;sisusb-&gt;lock);
 
 	/* Erm.. that should not happen */
 	if (sisusb-&gt;haveconsole || !sisusb-&gt;SiS_Pr) {
 		mutex_unlock(&amp;sisusb-&gt;lock);
-		mutex_unlock(&amp;disconnect_mutex);
 		return 1;
 	}
 
@@ -1508,14 +1492,12 @@ sisusb_console_init(struct sisusb_usb_data *sisusb, int first, int last)
 	    first &gt; MAX_NR_CONSOLES ||
 	    last &gt; MAX_NR_CONSOLES) {
 		mutex_unlock(&amp;sisusb-&gt;lock);
-		mutex_unlock(&amp;disconnect_mutex);
 		return 1;
 	}
 
 	/* If gfxcore not initialized or no consoles given, quit graciously */
 	if (!sisusb-&gt;gfxinit || first &lt; 1 || last &lt; 1) {
 		mutex_unlock(&amp;sisusb-&gt;lock);
-		mutex_unlock(&amp;disconnect_mutex);
 		return 0;
 	}
 
@@ -1526,7 +1508,6 @@ sisusb_console_init(struct sisusb_usb_data *sisusb, int first, int last)
 	/* Set up text mode (and upload  default font) */
 	if (sisusb_reset_text_mode(sisusb, 1)) {
 		mutex_unlock(&amp;sisusb-&gt;lock);
-		mutex_unlock(&amp;disconnect_mutex);
 		printk(KERN_ERR
 			"sisusbvga[%d]: Failed to set up text mode\n",
 			minor);
@@ -1550,7 +1531,6 @@ sisusb_console_init(struct sisusb_usb_data *sisusb, int first, int last)
 	/* Allocate screen buffer */
 	if (!(sisusb-&gt;scrbuf = (unsigned long)vmalloc(sisusb-&gt;scrbuf_size))) {
 		mutex_unlock(&amp;sisusb-&gt;lock);
-		mutex_unlock(&amp;disconnect_mutex);
 		printk(KERN_ERR
 			"sisusbvga[%d]: Failed to allocate screen buffer\n",
 			minor);
@@ -1558,7 +1538,6 @@ sisusb_console_init(struct sisusb_usb_data *sisusb, int first, int last)
 	}
 
 	mutex_unlock(&amp;sisusb-&gt;lock);
-	mutex_unlock(&amp;disconnect_mutex);
 
 	/* Now grab the desired console(s) */
 	ret = take_over_console(&amp;sisusb_con, first - 1, last - 1, 0);
diff --git a/drivers/usb/misc/sisusbvga/sisusb_init.h b/drivers/usb/misc/sisusbvga/sisusb_init.h
index f05f83268af4..864bc0e96591 100644
--- a/drivers/usb/misc/sisusbvga/sisusb_init.h
+++ b/drivers/usb/misc/sisusbvga/sisusb_init.h
@@ -808,8 +808,6 @@ static const struct SiS_VCLKData SiSUSB_VCLKData[] =
 	{ 0x2b,0xc2, 35}  /* 0x71 768@576@60 */
 };
 
-extern struct mutex disconnect_mutex;
-
 int		SiSUSBSetMode(struct SiS_Private *SiS_Pr, unsigned short ModeNo);
 int		SiSUSBSetVESAMode(struct SiS_Private *SiS_Pr, unsigned short VModeNo);
 
diff --git a/drivers/usb/misc/usblcd.c b/drivers/usb/misc/usblcd.c
index 12bad8a205a7..6e093c2aac2c 100644
--- a/drivers/usb/misc/usblcd.c
+++ b/drivers/usb/misc/usblcd.c
@@ -51,7 +51,6 @@ struct usb_lcd {
 #define USB_LCD_CONCURRENT_WRITES	5
 
 static struct usb_driver lcd_driver;
-static DEFINE_MUTEX(usb_lcd_open_mutex);
 
 
 static void lcd_delete(struct kref *kref)
@@ -69,24 +68,19 @@ static int lcd_open(struct inode *inode, struct file *file)
 	struct usb_lcd *dev;
 	struct usb_interface *interface;
 	int subminor;
-	int retval = 0;
 
 	subminor = iminor(inode);
 
-	mutex_lock(&amp;usb_lcd_open_mutex);
 	interface = usb_find_interface(&amp;lcd_driver, subminor);
 	if (!interface) {
 		err ("USBLCD: %s - error, can't find device for minor %d",
 		     __FUNCTION__, subminor);
-		retval = -ENODEV;
-		goto exit;
+		return -ENODEV;
 	}
 
 	dev = usb_get_intfdata(interface);
-	if (!dev) {
-		retval = -ENODEV;
-		goto exit;
-	}
+	if (!dev)
+		return -ENODEV;
 
 	/* increment our usage count for the device */
 	kref_get(&amp;dev-&gt;kref);
@@ -94,9 +88,7 @@ static int lcd_open(struct inode *inode, struct file *file)
 	/* save our object in the file's private structure */
 	file-&gt;private_data = dev;
 
-exit:
-	mutex_unlock(&amp;usb_lcd_open_mutex);
-	return retval;
+	return 0;
 }
 
 static int lcd_release(struct inode *inode, struct file *file)
@@ -363,17 +355,12 @@ static void lcd_disconnect(struct usb_interface *interface)
 	struct usb_lcd *dev;
         int minor = interface-&gt;minor;
 
-        /* prevent skel_open() from racing skel_disconnect() */
-        mutex_lock(&amp;usb_lcd_open_mutex);
-
         dev = usb_get_intfdata(interface);
         usb_set_intfdata(interface, NULL);
 
         /* give back our minor */
         usb_deregister_dev(interface, &amp;lcd_class);
  
-	mutex_unlock(&amp;usb_lcd_open_mutex);
-
 	/* decrement our usage count */
 	kref_put(&amp;dev-&gt;kref, lcd_delete);
 
diff --git a/drivers/usb/usb-skeleton.c b/drivers/usb/usb-skeleton.c
index 8432bf171d2e..38f8e4df9dd6 100644
--- a/drivers/usb/usb-skeleton.c
+++ b/drivers/usb/usb-skeleton.c
@@ -34,9 +34,6 @@ static struct usb_device_id skel_table [] = {
 };
 MODULE_DEVICE_TABLE(usb, skel_table);
 
-/* to prevent a race between open and disconnect */
-static DEFINE_MUTEX(skel_open_lock);
-
 
 /* Get a minor range for your devices from the usb maintainer */
 #define USB_SKEL_MINOR_BASE	192
@@ -83,10 +80,8 @@ static int skel_open(struct inode *inode, struct file *file)
 
 	subminor = iminor(inode);
 
-	mutex_lock(&amp;skel_open_lock);
 	interface = usb_find_interface(&amp;skel_driver, subminor);
 	if (!interface) {
-		mutex_unlock(&amp;skel_open_lock);
 		err ("%s - error, can't find device for minor %d",
 		     __FUNCTION__, subminor);
 		retval = -ENODEV;
@@ -95,15 +90,12 @@ static int skel_open(struct inode *inode, struct file *file)
 
 	dev = usb_get_intfdata(interface);
 	if (!dev) {
-		mutex_unlock(&amp;skel_open_lock);
 		retval = -ENODEV;
 		goto exit;
 	}
 
 	/* increment our usage count for the device */
 	kref_get(&amp;dev-&gt;kref);
-	/* now we can drop the lock */
-	mutex_unlock(&amp;skel_open_lock);
 
 	/* prevent the device from being autosuspended */
 	retval = usb_autopm_get_interface(interface);
@@ -368,23 +360,17 @@ static void skel_disconnect(struct usb_interface *interface)
 	struct usb_skel *dev;
 	int minor = interface-&gt;minor;
 
-	/* prevent skel_open() from racing skel_disconnect() */
-	mutex_lock(&amp;skel_open_lock);
-
 	dev = usb_get_intfdata(interface);
 	usb_set_intfdata(interface, NULL);
 
 	/* give back our minor */
 	usb_deregister_dev(interface, &amp;skel_class);
-	mutex_unlock(&amp;skel_open_lock);
 
 	/* prevent more I/O from starting */
 	mutex_lock(&amp;dev-&gt;io_mutex);
 	dev-&gt;interface = NULL;
 	mutex_unlock(&amp;dev-&gt;io_mutex);
 
-
-
 	/* decrement our usage count */
 	kref_put(&amp;dev-&gt;kref, skel_delete);
 </pre><hr><pre>commit dd4dd19e8d13e1e9bf8295bf71f132b511b130bf
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 4 11:55:54 2007 -0400

    USB: Make device reset stop retrying after disconnect
    
    This patch (as898) changes the port reset code in the hub driver.  If
    a connect change occurs, it is reported the same way as a disconnect
    (which of course is what it really is).
    
    It also changes usb_reset_device(), to prevent the routine from futilely
    retrying the reset after a disconnect has occurred.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index d37ad083d5ef..f4ef7c25096e 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1539,9 +1539,9 @@ static int hub_port_wait_reset(struct usb_hub *hub, int port1,
 		if (!(portstatus &amp; USB_PORT_STAT_CONNECTION))
 			return -ENOTCONN;
 
-		/* bomb out completely if something weird happened */
+		/* bomb out completely if the connection bounced */
 		if ((portchange &amp; USB_PORT_STAT_C_CONNECTION))
-			return -EINVAL;
+			return -ENOTCONN;
 
 		/* if we`ve finished resetting, then break out of the loop */
 		if (!(portstatus &amp; USB_PORT_STAT_RESET) &amp;&amp;
@@ -2974,7 +2974,7 @@ int usb_reset_device(struct usb_device *udev)
 		 * Other endpoints will be handled by re-enumeration. */
 		ep0_reinit(udev);
 		ret = hub_port_init(parent_hub, udev, port1, i);
-		if (ret &gt;= 0)
+		if (ret &gt;= 0 || ret == -ENOTCONN || ret == -ENODEV)
 			break;
 	}
 	clear_bit(port1, parent_hub-&gt;busy_bits);</pre><hr><pre>commit 3c519b846c4d5edf7c94d1eede42445a815bf65c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 4 11:55:31 2007 -0400

    USB: EHCI: fix handover for designated full-speed ports
    
    This patch (as895) fixes up a loose end in the port-handover code for
    the USB-Persist facility.  A special case occurs when a high-speed
    device is attached to a port which the user has designated to run at
    full-speed only; the port must be disabled before the handover can
    take place.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 3e80de7c7f5b..27291f502651 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -60,11 +60,13 @@ static void ehci_handover_companion_ports(struct ehci_hcd *ehci)
 	while (port--) {
 		if (test_bit(port, &amp;ehci-&gt;owned_ports)) {
 			reg = &amp;ehci-&gt;regs-&gt;port_status[port];
-			status = ehci_readl(ehci, reg);
+			status = ehci_readl(ehci, reg) &amp; ~PORT_RWC_BITS;
 
 			/* Port already owned by companion? */
 			if (status &amp; PORT_OWNER)
 				clear_bit(port, &amp;ehci-&gt;owned_ports);
+			else if (test_bit(port, &amp;ehci-&gt;companion_ports))
+				ehci_writel(ehci, status &amp; ~PORT_PE, reg);
 			else
 				ehci_hub_control(hcd, SetPortFeature,
 						USB_PORT_FEAT_RESET, port + 1,</pre><hr><pre>commit 6bc6cff52e0c4c4c876b1b8a5750041da61ad42b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 4 11:53:03 2007 -0400

    USB: add RESET_RESUME device quirk
    
    This patch (as888) adds a new USB device quirk for devices which are
    unable to resume correctly.  By using the new code added for the
    USB-persist facility, it is a simple matter to reset these devices
    instead of resuming them.  To get things kicked off, a quirk entry is
    added for the Philips PSC805.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 12dd986bdffd..02d6db61c940 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -24,6 +24,7 @@
 
 #include &lt;linux/device.h&gt;
 #include &lt;linux/usb.h&gt;
+#include &lt;linux/usb/quirks.h&gt;
 #include &lt;linux/workqueue.h&gt;
 #include "hcd.h"
 #include "usb.h"
@@ -835,6 +836,9 @@ static int usb_resume_device(struct usb_device *udev)
 		goto done;
 	}
 
+	if (udev-&gt;quirks &amp; USB_QUIRK_RESET_RESUME)
+		udev-&gt;reset_resume = 1;
+
 	udriver = to_usb_device_driver(udev-&gt;dev.driver);
 	status = udriver-&gt;resume(udev);
 
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 51d2d304568b..d37ad083d5ef 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2939,6 +2939,11 @@ static int config_descriptors_changed(struct usb_device *udev)
  * this from a driver probe() routine after downloading new firmware.
  * For calls that might not occur during probe(), drivers should lock
  * the device using usb_lock_device_for_reset().
+ *
+ * Locking exception: This routine may also be called from within an
+ * autoresume handler.  Such usage won't conflict with other tasks
+ * holding the device lock because these tasks should always call
+ * usb_autopm_resume_device(), thereby preventing any unwanted autoresume.
  */
 int usb_reset_device(struct usb_device *udev)
 {
diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c
index 739f520908aa..f37fa012f329 100644
--- a/drivers/usb/core/quirks.c
+++ b/drivers/usb/core/quirks.c
@@ -35,6 +35,9 @@ static const struct usb_device_id usb_quirk_list[] = {
 	/* Elsa MicroLink 56k (V.250) */
 	{ USB_DEVICE(0x05cc, 0x2267), .driver_info = USB_QUIRK_NO_AUTOSUSPEND },
 
+	/* Philips PSC805 audio device */
+	{ USB_DEVICE(0x0471, 0x0155), .driver_info = USB_QUIRK_RESET_RESUME },
+
 	{ }  /* terminating entry must be last */
 };
 
diff --git a/include/linux/usb/quirks.h b/include/linux/usb/quirks.h
index 6bac8faacbc6..8da374caf582 100644
--- a/include/linux/usb/quirks.h
+++ b/include/linux/usb/quirks.h
@@ -9,3 +9,6 @@
 
 /* string descriptors must not be fetched using a 255-byte read */
 #define USB_QUIRK_STRING_FETCH_255	0x00000002
+
+/* device can't resume correctly so reset it instead */
+#define USB_QUIRK_RESET_RESUME		0x00000004</pre><hr><pre>commit 383975d765523a56dc43a6cd6d52e9b376800cf2
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 4 11:52:40 2007 -0400

    USB: EHCI, OHCI: handover changes
    
    This patch (as887) changes the way ehci-hcd and ohci-hcd handle a loss
    of VBUS power during suspend.  In order for the USB-persist facility
    to work correctly, it is necessary for low- and full-speed devices
    attached to a high-speed port to be handed back to the companion
    controller during resume processing.
    
    This entails three changes: adding code to ehci-hcd to perform the
    handover, removing code from ohci-hcd to turn off ports during
    root-hub reinit, and adding code to ohci-hcd to turn on ports during
    PCI controller resume.  (Other bus glue resume methods for platforms
    supporting high-speed controllers would need a similar change, if any
    existed.)
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 99ab31e9778b..b5a7aa90209a 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -399,6 +399,8 @@ static void ehci_port_power (struct ehci_hcd *ehci, int is_on)
 				is_on ? SetPortFeature : ClearPortFeature,
 				USB_PORT_FEAT_POWER,
 				port--, NULL, 0);
+	/* Flush those writes */
+	ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
 	msleep(20);
 }
 
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index f4d301bc83b9..3e80de7c7f5b 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -28,6 +28,87 @@
 
 /*-------------------------------------------------------------------------*/
 
+#ifdef	CONFIG_USB_PERSIST
+
+static int ehci_hub_control(
+	struct usb_hcd	*hcd,
+	u16		typeReq,
+	u16		wValue,
+	u16		wIndex,
+	char		*buf,
+	u16		wLength
+);
+
+/* After a power loss, ports that were owned by the companion must be
+ * reset so that the companion can still own them.
+ */
+static void ehci_handover_companion_ports(struct ehci_hcd *ehci)
+{
+	u32 __iomem	*reg;
+	u32		status;
+	int		port;
+	__le32		buf;
+	struct usb_hcd	*hcd = ehci_to_hcd(ehci);
+
+	if (!ehci-&gt;owned_ports)
+		return;
+
+	/* Give the connections some time to appear */
+	msleep(20);
+
+	port = HCS_N_PORTS(ehci-&gt;hcs_params);
+	while (port--) {
+		if (test_bit(port, &amp;ehci-&gt;owned_ports)) {
+			reg = &amp;ehci-&gt;regs-&gt;port_status[port];
+			status = ehci_readl(ehci, reg);
+
+			/* Port already owned by companion? */
+			if (status &amp; PORT_OWNER)
+				clear_bit(port, &amp;ehci-&gt;owned_ports);
+			else
+				ehci_hub_control(hcd, SetPortFeature,
+						USB_PORT_FEAT_RESET, port + 1,
+						NULL, 0);
+		}
+	}
+
+	if (!ehci-&gt;owned_ports)
+		return;
+	msleep(90);		/* Wait for resets to complete */
+
+	port = HCS_N_PORTS(ehci-&gt;hcs_params);
+	while (port--) {
+		if (test_bit(port, &amp;ehci-&gt;owned_ports)) {
+			ehci_hub_control(hcd, GetPortStatus,
+					0, port + 1,
+					(char *) &amp;buf, sizeof(buf));
+
+			/* The companion should now own the port,
+			 * but if something went wrong the port must not
+			 * remain enabled.
+			 */
+			reg = &amp;ehci-&gt;regs-&gt;port_status[port];
+			status = ehci_readl(ehci, reg) &amp; ~PORT_RWC_BITS;
+			if (status &amp; PORT_OWNER)
+				ehci_writel(ehci, status | PORT_CSC, reg);
+			else {
+				ehci_dbg(ehci, "failed handover port %d: %x\n",
+						port + 1, status);
+				ehci_writel(ehci, status &amp; ~PORT_PE, reg);
+			}
+		}
+	}
+
+	ehci-&gt;owned_ports = 0;
+}
+
+#else	/* CONFIG_USB_PERSIST */
+
+static inline void ehci_handover_companion_ports(struct ehci_hcd *ehci)
+{ }
+
+#endif
+
 #ifdef	CONFIG_PM
 
 static int ehci_bus_suspend (struct usb_hcd *hcd)
@@ -60,14 +141,16 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 	 * then manually resume them in the bus_resume() routine.
 	 */
 	ehci-&gt;bus_suspended = 0;
+	ehci-&gt;owned_ports = 0;
 	while (port--) {
 		u32 __iomem	*reg = &amp;ehci-&gt;regs-&gt;port_status [port];
 		u32		t1 = ehci_readl(ehci, reg) &amp; ~PORT_RWC_BITS;
 		u32		t2 = t1;
 
 		/* keep track of which ports we suspend */
-		if ((t1 &amp; PORT_PE) &amp;&amp; !(t1 &amp; PORT_OWNER) &amp;&amp;
-				!(t1 &amp; PORT_SUSPEND)) {
+		if (t1 &amp; PORT_OWNER)
+			set_bit(port, &amp;ehci-&gt;owned_ports);
+		else if ((t1 &amp; PORT_PE) &amp;&amp; !(t1 &amp; PORT_SUSPEND)) {
 			t2 |= PORT_SUSPEND;
 			set_bit(port, &amp;ehci-&gt;bus_suspended);
 		}
@@ -108,6 +191,7 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
 	u32			temp;
+	u32			power_okay;
 	int			i;
 
 	if (time_before (jiffies, ehci-&gt;next_statechange))
@@ -120,8 +204,9 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 	 * the last user of the controller, not reset/pm hardware keeping
 	 * state we gave to it.
 	 */
-	temp = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;intr_enable);
-	ehci_dbg(ehci, "resume root hub%s\n", temp ? "" : " after power loss");
+	power_okay = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;intr_enable);
+	ehci_dbg(ehci, "resume root hub%s\n",
+			power_okay ? "" : " after power loss");
 
 	/* at least some APM implementations will try to deliver
 	 * IRQs right away, so delay them until we're ready.
@@ -184,6 +269,9 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 	ehci_writel(ehci, INTR_MASK, &amp;ehci-&gt;regs-&gt;intr_enable);
 
 	spin_unlock_irq (&amp;ehci-&gt;lock);
+
+	if (!power_okay)
+		ehci_handover_companion_ports(ehci);
 	return 0;
 }
 
@@ -448,7 +536,8 @@ static int ehci_hub_control (
 ) {
 	struct ehci_hcd	*ehci = hcd_to_ehci (hcd);
 	int		ports = HCS_N_PORTS (ehci-&gt;hcs_params);
-	u32 __iomem	*status_reg = &amp;ehci-&gt;regs-&gt;port_status[wIndex - 1];
+	u32 __iomem	*status_reg = &amp;ehci-&gt;regs-&gt;port_status[
+				(wIndex &amp; 0xff) - 1];
 	u32		temp, status;
 	unsigned long	flags;
 	int		retval = 0;
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 966965f72338..a7816e392a85 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -312,13 +312,14 @@ static int ehci_pci_resume(struct usb_hcd *hcd)
 	ehci_work(ehci);
 	spin_unlock_irq(&amp;ehci-&gt;lock);
 
-	/* here we "know" root ports should always stay powered */
-	ehci_port_power(ehci, 1);
-
 	ehci_writel(ehci, ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
 	ehci_writel(ehci, FLAG_CF, &amp;ehci-&gt;regs-&gt;configured_flag);
 	ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);	/* unblock posted writes */
 
+	/* here we "know" root ports should always stay powered */
+	ehci_port_power(ehci, 1);
+	ehci_handover_companion_ports(ehci);
+
 	hcd-&gt;state = HC_STATE_SUSPENDED;
 	return 0;
 }
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 6ef9d775775b..4d617108f552 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -96,11 +96,14 @@ struct ehci_hcd {			/* one per controller */
 
 	/* per root hub port */
 	unsigned long		reset_done [EHCI_MAX_ROOT_PORTS];
+
 	/* bit vectors (one bit per port) */
 	unsigned long		bus_suspended;		/* which ports were
 			already suspended at the start of a bus suspend */
 	unsigned long		companion_ports;	/* which ports are
 			dedicated to the companion controller */
+	unsigned long		owned_ports;		/* which ports are
+			owned by the companion during a bus suspend */
 
 	/* per-HC memory pools (could be per-bus, but ...) */
 	struct dma_pool		*qh_pool;	/* qh per active urb */
diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index a66637e725f3..ce05e5f7bed6 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -510,15 +510,7 @@ static int ohci_run (struct ohci_hcd *ohci)
 	// flush the writes
 	(void) ohci_readl (ohci, &amp;ohci-&gt;regs-&gt;control);
 	msleep(temp);
-	temp = roothub_a (ohci);
-	if (!(temp &amp; RH_A_NPS)) {
-		/* power down each port */
-		for (temp = 0; temp &lt; ohci-&gt;num_ports; temp++)
-			ohci_writel (ohci, RH_PS_LSDA,
-				&amp;ohci-&gt;regs-&gt;roothub.portstatus [temp]);
-	}
-	// flush those writes
-	(void) ohci_readl (ohci, &amp;ohci-&gt;regs-&gt;control);
+
 	memset (ohci-&gt;hcca, 0, sizeof (struct ohci_hcca));
 
 	/* 2msec timelimit here means no irqs/preempt */
@@ -826,17 +818,8 @@ static int ohci_restart (struct ohci_hcd *ohci)
 	if ((temp = ohci_run (ohci)) &lt; 0) {
 		ohci_err (ohci, "can't restart, %d\n", temp);
 		return temp;
-	} else {
-		/* here we "know" root ports should always stay powered,
-		 * and that if we try to turn them back on the root hub
-		 * will respond to CSC processing.
-		 */
-		i = ohci-&gt;num_ports;
-		while (i--)
-			ohci_writel (ohci, RH_PS_PSS,
-				&amp;ohci-&gt;regs-&gt;roothub.portstatus [i]);
-		ohci_dbg (ohci, "restart complete\n");
 	}
+	ohci_dbg(ohci, "restart complete\n");
 	return 0;
 }
 #endif
diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index ca62cb583221..15013f4519ad 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -202,6 +202,42 @@ static int __devinit ohci_pci_start (struct usb_hcd *hcd)
 	return ret;
 }
 
+#if	defined(CONFIG_USB_PERSIST) &amp;&amp; (defined(CONFIG_USB_EHCI_HCD) || \
+		defined(CONFIG_USB_EHCI_HCD_MODULE))
+
+/* Following a power loss, we must prepare to regain control of the ports
+ * we used to own.  This means turning on the port power before ehci-hcd
+ * tries to switch ownership.
+ *
+ * This isn't a 100% perfect solution.  On most systems the OHCI controllers
+ * lie at lower PCI addresses than the EHCI controller, so they will be
+ * discovered (and hence resumed) first.  But there is no guarantee things
+ * will always work this way.  If the EHCI controller is resumed first and
+ * the OHCI ports are unpowered, then the handover will fail.
+ */
+static void prepare_for_handover(struct usb_hcd *hcd)
+{
+	struct ohci_hcd	*ohci = hcd_to_ohci(hcd);
+	int		port;
+
+	/* Here we "know" root ports should always stay powered */
+	ohci_dbg(ohci, "powerup ports\n");
+	for (port = 0; port &lt; ohci-&gt;num_ports; port++)
+		ohci_writel(ohci, RH_PS_PPS,
+				&amp;ohci-&gt;regs-&gt;roothub.portstatus[port]);
+
+	/* Flush those writes */
+	ohci_readl(ohci, &amp;ohci-&gt;regs-&gt;control);
+	msleep(20);
+}
+
+#else
+
+static inline void prepare_for_handover(struct usb_hcd *hcd)
+{ }
+
+#endif	/* CONFIG_USB_PERSIST etc. */
+
 #ifdef	CONFIG_PM
 
 static int ohci_pci_suspend (struct usb_hcd *hcd, pm_message_t message)
@@ -241,7 +277,10 @@ static int ohci_pci_suspend (struct usb_hcd *hcd, pm_message_t message)
 static int ohci_pci_resume (struct usb_hcd *hcd)
 {
 	set_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
-	usb_hcd_resume_root_hub(hcd);
+
+	/* FIXME: we should try to detect loss of VBUS power here */
+	prepare_for_handover(hcd);
+
 	return 0;
 }
 </pre><hr><pre>commit 0458d5b4c9cc4ca0f62625d0144ddc4b4bc97a3c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 4 11:52:20 2007 -0400

    USB: add USB-Persist facility
    
    This patch (as886) adds the controversial USB-persist facility,
    allowing USB devices to persist across a power loss during system
    suspend.
    
    The facility is controlled by a new Kconfig option (with appropriate
    warnings about the potential dangers); when the option is off the
    behavior will remain the same as it is now.  But when the option is
    on, people will be able to use suspend-to-disk and keep their USB
    filesystems intact -- something particularly valuable for small
    machines where the root filesystem is on a USB device!
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/Documentation/power/swsusp.txt b/Documentation/power/swsusp.txt
index 5b8d6953f05e..152b510d1bbb 100644
--- a/Documentation/power/swsusp.txt
+++ b/Documentation/power/swsusp.txt
@@ -393,6 +393,9 @@ safest thing is to unmount all filesystems on removable media (such USB,
 Firewire, CompactFlash, MMC, external SATA, or even IDE hotplug bays)
 before suspending; then remount them after resuming.
 
+There is a work-around for this problem.  For more information, see
+Documentation/usb/persist.txt.
+
 Q: I upgraded the kernel from 2.6.15 to 2.6.16. Both kernels were
 compiled with the similar configuration files. Anyway I found that
 suspend to disk (and resume) is much slower on 2.6.16 compared to
diff --git a/Documentation/usb/persist.txt b/Documentation/usb/persist.txt
new file mode 100644
index 000000000000..6dcd5f884795
--- /dev/null
+++ b/Documentation/usb/persist.txt
@@ -0,0 +1,144 @@
+		USB device persistence during system suspend
+
+		   Alan Stern &lt;stern@rowland.harvard.edu&gt;
+
+		 September 2, 2006 (Updated March 27, 2007)
+
+
+	What is the problem?
+
+According to the USB specification, when a USB bus is suspended the
+bus must continue to supply suspend current (around 1-5 mA).  This
+is so that devices can maintain their internal state and hubs can
+detect connect-change events (devices being plugged in or unplugged).
+The technical term is "power session".
+
+If a USB device's power session is interrupted then the system is
+required to behave as though the device has been unplugged.  It's a
+conservative approach; in the absence of suspend current the computer
+has no way to know what has actually happened.  Perhaps the same
+device is still attached or perhaps it was removed and a different
+device plugged into the port.  The system must assume the worst.
+
+By default, Linux behaves according to the spec.  If a USB host
+controller loses power during a system suspend, then when the system
+wakes up all the devices attached to that controller are treated as
+though they had disconnected.  This is always safe and it is the
+"officially correct" thing to do.
+
+For many sorts of devices this behavior doesn't matter in the least.
+If the kernel wants to believe that your USB keyboard was unplugged
+while the system was asleep and a new keyboard was plugged in when the
+system woke up, who cares?  It'll still work the same when you type on
+it.
+
+Unfortunately problems _can_ arise, particularly with mass-storage
+devices.  The effect is exactly the same as if the device really had
+been unplugged while the system was suspended.  If you had a mounted
+filesystem on the device, you're out of luck -- everything in that
+filesystem is now inaccessible.  This is especially annoying if your
+root filesystem was located on the device, since your system will
+instantly crash.
+
+Loss of power isn't the only mechanism to worry about.  Anything that
+interrupts a power session will have the same effect.  For example,
+even though suspend current may have been maintained while the system
+was asleep, on many systems during the initial stages of wakeup the
+firmware (i.e., the BIOS) resets the motherboard's USB host
+controllers.  Result: all the power sessions are destroyed and again
+it's as though you had unplugged all the USB devices.  Yes, it's
+entirely the BIOS's fault, but that doesn't do _you_ any good unless
+you can convince the BIOS supplier to fix the problem (lots of luck!).
+
+On many systems the USB host controllers will get reset after a
+suspend-to-RAM.  On almost all systems, no suspend current is
+available during suspend-to-disk (also known as swsusp).  You can
+check the kernel log after resuming to see if either of these has
+happened; look for lines saying "root hub lost power or was reset".
+
+In practice, people are forced to unmount any filesystems on a USB
+device before suspending.  If the root filesystem is on a USB device,
+the system can't be suspended at all.  (All right, it _can_ be
+suspended -- but it will crash as soon as it wakes up, which isn't
+much better.)
+
+
+	What is the solution?
+
+Setting CONFIG_USB_PERSIST will cause the kernel to work around these
+issues.  It enables a mode in which the core USB device data
+structures are allowed to persist across a power-session disruption.
+It works like this.  If the kernel sees that a USB host controller is
+not in the expected state during resume (i.e., if the controller was
+reset or otherwise had lost power) then it applies a persistence check
+to each of the USB devices below that controller.  It doesn't try to
+resume the device; that can't work once the power session is gone.
+Instead it issues a USB port reset and then re-enumerates the device.
+(This is exactly the same thing that happens whenever a USB device is
+reset.)  If the re-enumeration shows that the device now attached to
+that port has the same descriptors as before, including the Vendor and
+Product IDs, then the kernel continues to use the same device
+structure.  In effect, the kernel treats the device as though it had
+merely been reset instead of unplugged.
+
+If no device is now attached to the port, or if the descriptors are
+different from what the kernel remembers, then the treatment is what
+you would expect.  The kernel destroys the old device structure and
+behaves as though the old device had been unplugged and a new device
+plugged in, just as it would without the CONFIG_USB_PERSIST option.
+
+The end result is that the USB device remains available and usable.
+Filesystem mounts and memory mappings are unaffected, and the world is
+now a good and happy place.
+
+
+	Is this the best solution?
+
+Perhaps not.  Arguably, keeping track of mounted filesystems and
+memory mappings across device disconnects should be handled by a
+centralized Logical Volume Manager.  Such a solution would allow you
+to plug in a USB flash device, create a persistent volume associated
+with it, unplug the flash device, plug it back in later, and still
+have the same persistent volume associated with the device.  As such
+it would be more far-reaching than CONFIG_USB_PERSIST.
+
+On the other hand, writing a persistent volume manager would be a big
+job and using it would require significant input from the user.  This
+solution is much quicker and easier -- and it exists now, a giant
+point in its favor!
+
+Furthermore, the USB_PERSIST option applies to _all_ USB devices, not
+just mass-storage devices.  It might turn out to be equally useful for
+other device types, such as network interfaces.
+
+
+	WARNING: Using CONFIG_USB_PERSIST can be dangerous!!
+
+When recovering an interrupted power session the kernel does its best
+to make sure the USB device hasn't been changed; that is, the same
+device is still plugged into the port as before.  But the checks
+aren't guaranteed to be 100% accurate.
+
+If you replace one USB device with another of the same type (same
+manufacturer, same IDs, and so on) there's an excellent chance the
+kernel won't detect the change.  Serial numbers and other strings are
+not compared.  In many cases it wouldn't help if they were, because
+manufacturers frequently omit serial numbers entirely in their
+devices.
+
+Furthermore it's quite possible to leave a USB device exactly the same
+while changing its media.  If you replace the flash memory card in a
+USB card reader while the system is asleep, the kernel will have no
+way to know you did it.  The kernel will assume that nothing has
+happened and will continue to use the partition tables, inodes, and
+memory mappings for the old card.
+
+If the kernel gets fooled in this way, it's almost certain to cause
+data corruption and to crash your system.  You'll have no one to blame
+but yourself.
+
+YOU HAVE BEEN WARNED!  USE AT YOUR OWN RISK!
+
+That having been said, most of the time there shouldn't be any trouble
+at all.  The "persist" feature can be extremely useful.  Make the most
+of it.
diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c
index 3afa4a5035b7..e221b0d1f667 100644
--- a/drivers/hid/usbhid/hid-core.c
+++ b/drivers/hid/usbhid/hid-core.c
@@ -1015,7 +1015,7 @@ static void hid_pre_reset(struct usb_interface *intf)
 	hid_suspend(intf, PMSG_ON);
 }
 
-static void hid_post_reset(struct usb_interface *intf)
+static void hid_post_reset(struct usb_interface *intf, int reset_resume)
 {
 	struct usb_device *dev = interface_to_usbdev (intf);
 
diff --git a/drivers/usb/core/Kconfig b/drivers/usb/core/Kconfig
index 346fc030c929..5113ef4cb7f6 100644
--- a/drivers/usb/core/Kconfig
+++ b/drivers/usb/core/Kconfig
@@ -86,6 +86,28 @@ config USB_SUSPEND
 
 	  If you are unsure about this, say N here.
 
+config USB_PERSIST
+	bool "USB device persistence during system suspend (DANGEROUS)"
+	depends on USB &amp;&amp; PM &amp;&amp; EXPERIMENTAL
+	default n
+	help
+	  If you say Y here, USB device data structures will remain
+	  persistent across system suspend, even if the USB bus loses
+	  power.  (This includes software-suspend, also known as swsusp,
+	  or suspend-to-disk.)  The devices will reappear as if by magic
+	  when the system wakes up, with no need to unmount USB filesystems,
+	  rmmod host-controller drivers, or do anything else.
+
+	  	WARNING: This option can be dangerous!
+
+	  If a USB device is replaced by another of the same type while
+	  the system is asleep, there's a good chance the kernel won't
+	  detect the change.  Likewise if the media in a USB storage
+	  device is replaced.  When this happens it's almost certain to
+	  cause data corruption and maybe even crash your system.
+
+	  If you are unsure, say N here.
+
 config USB_OTG
 	bool
 	depends on USB &amp;&amp; EXPERIMENTAL
diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index e8b447e06c54..12dd986bdffd 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -824,8 +824,9 @@ static int usb_resume_device(struct usb_device *udev)
 	struct usb_device_driver	*udriver;
 	int				status = 0;
 
-	if (udev-&gt;state == USB_STATE_NOTATTACHED ||
-			udev-&gt;state != USB_STATE_SUSPENDED)
+	if (udev-&gt;state == USB_STATE_NOTATTACHED)
+		goto done;
+	if (udev-&gt;state != USB_STATE_SUSPENDED &amp;&amp; !udev-&gt;reset_resume)
 		goto done;
 
 	/* Can't resume it if it doesn't have a driver. */
@@ -882,7 +883,7 @@ static int usb_suspend_interface(struct usb_interface *intf, pm_message_t msg)
 }
 
 /* Caller has locked intf's usb_device's pm_mutex */
-static int usb_resume_interface(struct usb_interface *intf)
+static int usb_resume_interface(struct usb_interface *intf, int reset_resume)
 {
 	struct usb_driver	*driver;
 	int			status = 0;
@@ -902,21 +903,21 @@ static int usb_resume_interface(struct usb_interface *intf)
 	}
 	driver = to_usb_driver(intf-&gt;dev.driver);
 
-	if (driver-&gt;resume) {
+	if (reset_resume &amp;&amp; driver-&gt;post_reset)
+		driver-&gt;post_reset(intf, reset_resume);
+	else if (driver-&gt;resume) {
 		status = driver-&gt;resume(intf);
 		if (status)
 			dev_err(&amp;intf-&gt;dev, "%s error %d\n",
 					"resume", status);
-		else
-			mark_active(intf);
-	} else {
+	} else
 		dev_warn(&amp;intf-&gt;dev, "no resume for driver %s?\n",
 				driver-&gt;name);
-		mark_active(intf);
-	}
 
 done:
 	// dev_dbg(&amp;intf-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
+	if (status == 0)
+		mark_active(intf);
 	return status;
 }
 
@@ -1063,7 +1064,7 @@ static int usb_suspend_both(struct usb_device *udev, pm_message_t msg)
 	if (status != 0) {
 		while (--i &gt;= 0) {
 			intf = udev-&gt;actconfig-&gt;interface[i];
-			usb_resume_interface(intf);
+			usb_resume_interface(intf, 0);
 		}
 
 		/* Try another autosuspend when the interfaces aren't busy */
@@ -1162,20 +1163,21 @@ static int usb_resume_both(struct usb_device *udev)
  		}
 	} else {
 
-		/* Needed only for setting udev-&gt;dev.power.power_state.event
-		 * and for possible debugging message. */
+		/* Needed for setting udev-&gt;dev.power.power_state.event,
+		 * for possible debugging message, and for reset_resume. */
 		status = usb_resume_device(udev);
 	}
 
 	if (status == 0 &amp;&amp; udev-&gt;actconfig) {
 		for (i = 0; i &lt; udev-&gt;actconfig-&gt;desc.bNumInterfaces; i++) {
 			intf = udev-&gt;actconfig-&gt;interface[i];
-			usb_resume_interface(intf);
+			usb_resume_interface(intf, udev-&gt;reset_resume);
 		}
 	}
 
  done:
 	// dev_dbg(&amp;udev-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
+	udev-&gt;reset_resume = 0;
 	return status;
 }
 
@@ -1510,8 +1512,15 @@ static int usb_resume(struct device *dev)
 	if (!is_usb_device(dev))	/* Ignore PM for interfaces */
 		return 0;
 	udev = to_usb_device(dev);
-	if (udev-&gt;autoresume_disabled)
-		return -EPERM;
+
+	/* If autoresume is disabled then we also want to prevent resume
+	 * during system wakeup.  However, a "persistent-device" reset-resume
+	 * after power loss counts as a wakeup event.  So allow a
+	 * reset-resume to occur if remote wakeup is enabled. */
+	if (udev-&gt;autoresume_disabled) {
+		if (!(udev-&gt;reset_resume &amp;&amp; udev-&gt;do_remote_wakeup))
+			return -EPERM;
+	}
 	return usb_external_resume_device(udev);
 }
 
diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index 7cbf992adccd..d363b0ea7345 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -217,7 +217,10 @@ static int generic_resume(struct usb_device *udev)
 {
 	int rc;
 
-	rc = usb_port_resume(udev);
+	if (udev-&gt;reset_resume)
+		rc = usb_reset_suspended_device(udev);
+	else
+		rc = usb_port_resume(udev);
 
 	/* Root hubs don't have upstream ports to resume or reset,
 	 * so the line above won't do much for them.  We have to
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 77a6627b18d2..51d2d304568b 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -553,45 +553,121 @@ static int hub_hub_status(struct usb_hub *hub,
 static int hub_port_disable(struct usb_hub *hub, int port1, int set_state)
 {
 	struct usb_device *hdev = hub-&gt;hdev;
-	int ret;
+	int ret = 0;
 
-	if (hdev-&gt;children[port1-1] &amp;&amp; set_state) {
+	if (hdev-&gt;children[port1-1] &amp;&amp; set_state)
 		usb_set_device_state(hdev-&gt;children[port1-1],
 				USB_STATE_NOTATTACHED);
-	}
-	ret = clear_port_feature(hdev, port1, USB_PORT_FEAT_ENABLE);
+	if (!hub-&gt;error)
+		ret = clear_port_feature(hdev, port1, USB_PORT_FEAT_ENABLE);
 	if (ret)
 		dev_err(hub-&gt;intfdev, "cannot disable port %d (err = %d)\n",
-			port1, ret);
-
+				port1, ret);
 	return ret;
 }
 
+/*
+ * Disable a port and mark a logical connnect-change event, so that some
+ * time later khubd will disconnect() any existing usb_device on the port
+ * and will re-enumerate if there actually is a device attached.
+ */
+static void hub_port_logical_disconnect(struct usb_hub *hub, int port1)
+{
+	dev_dbg(hub-&gt;intfdev, "logical disconnect on port %d\n", port1);
+	hub_port_disable(hub, port1, 1);
 
-/* caller has locked the hub device */
-static void hub_pre_reset(struct usb_interface *intf)
+	/* FIXME let caller ask to power down the port:
+	 *  - some devices won't enumerate without a VBUS power cycle
+	 *  - SRP saves power that way
+	 *  - ... new call, TBD ...
+	 * That's easy if this hub can switch power per-port, and
+	 * khubd reactivates the port later (timer, SRP, etc).
+	 * Powerdown must be optional, because of reset/DFU.
+	 */
+
+	set_bit(port1, hub-&gt;change_bits);
+ 	kick_khubd(hub);
+}
+
+static void disconnect_all_children(struct usb_hub *hub, int logical)
 {
-	struct usb_hub *hub = usb_get_intfdata(intf);
 	struct usb_device *hdev = hub-&gt;hdev;
 	int port1;
 
 	for (port1 = 1; port1 &lt;= hdev-&gt;maxchild; ++port1) {
-		if (hdev-&gt;children[port1 - 1]) {
-			usb_disconnect(&amp;hdev-&gt;children[port1 - 1]);
-			if (hub-&gt;error == 0)
-				hub_port_disable(hub, port1, 0);
+		if (hdev-&gt;children[port1-1]) {
+			if (logical)
+				hub_port_logical_disconnect(hub, port1);
+			else
+				usb_disconnect(&amp;hdev-&gt;children[port1-1]);
+		}
+	}
+}
+
+#ifdef	CONFIG_USB_PERSIST
+
+#define USB_PERSIST	1
+
+/* For "persistent-device" resets we must mark the child devices for reset
+ * and turn off a possible connect-change status (so khubd won't disconnect
+ * them later).
+ */
+static void mark_children_for_reset_resume(struct usb_hub *hub)
+{
+	struct usb_device *hdev = hub-&gt;hdev;
+	int port1;
+
+	for (port1 = 1; port1 &lt;= hdev-&gt;maxchild; ++port1) {
+		struct usb_device *child = hdev-&gt;children[port1-1];
+
+		if (child) {
+			child-&gt;reset_resume = 1;
+			clear_port_feature(hdev, port1,
+					USB_PORT_FEAT_C_CONNECTION);
 		}
 	}
+}
+
+#else
+
+#define USB_PERSIST	0
+
+static inline void mark_children_for_reset_resume(struct usb_hub *hub)
+{ }
+
+#endif	/* CONFIG_USB_PERSIST */
+
+/* caller has locked the hub device */
+static void hub_pre_reset(struct usb_interface *intf)
+{
+	struct usb_hub *hub = usb_get_intfdata(intf);
+
+	/* This routine doesn't run as part of a reset-resume, so it's safe
+	 * to disconnect all the drivers below the hub.
+	 */
+	disconnect_all_children(hub, 0);
 	hub_quiesce(hub);
 }
 
 /* caller has locked the hub device */
-static void hub_post_reset(struct usb_interface *intf)
+static void hub_post_reset(struct usb_interface *intf, int reset_resume)
 {
 	struct usb_hub *hub = usb_get_intfdata(intf);
 
-	hub_activate(hub);
 	hub_power_on(hub);
+	if (reset_resume) {
+		if (USB_PERSIST)
+			mark_children_for_reset_resume(hub);
+		else {
+			/* Reset-resume doesn't call pre_reset, so we have to
+			 * disconnect the children here.  But we may not lock
+			 * the child devices, so we have to do a "logical"
+			 * disconnect.
+			 */
+			disconnect_all_children(hub, 1);
+		}
+	}
+	hub_activate(hub);
 }
 
 
@@ -1053,33 +1129,64 @@ void usb_set_device_state(struct usb_device *udev,
 
 #ifdef	CONFIG_PM
 
+/**
+ * usb_reset_suspended_device - reset a suspended device instead of resuming it
+ * @udev: device to be reset instead of resumed
+ *
+ * If a host controller doesn't maintain VBUS suspend current during a
+ * system sleep or is reset when the system wakes up, all the USB
+ * power sessions below it will be broken.  This is especially troublesome
+ * for mass-storage devices containing mounted filesystems, since the
+ * device will appear to have disconnected and all the memory mappings
+ * to it will be lost.
+ *
+ * As an alternative, this routine attempts to recover power sessions for
+ * devices that are still present by resetting them instead of resuming
+ * them.  If all goes well, the devices will appear to persist across the
+ * the interruption of the power sessions.
+ *
+ * This facility is inherently dangerous.  Although usb_reset_device()
+ * makes every effort to insure that the same device is present after the
+ * reset as before, it cannot provide a 100% guarantee.  Furthermore it's
+ * quite possible for a device to remain unaltered but its media to be
+ * changed.  If the user replaces a flash memory card while the system is
+ * asleep, he will have only himself to blame when the filesystem on the
+ * new card is corrupted and the system crashes.
+ */
+int usb_reset_suspended_device(struct usb_device *udev)
+{
+	int rc = 0;
+
+	dev_dbg(&amp;udev-&gt;dev, "usb %sresume\n", "reset-");
+
+	/* After we're done the device won't be suspended any more.
+	 * In addition, the reset won't work if udev-&gt;state is SUSPENDED.
+	 */
+	usb_set_device_state(udev, udev-&gt;actconfig
+			? USB_STATE_CONFIGURED
+			: USB_STATE_ADDRESS);
+
+	/* Root hubs don't need to be (and can't be) reset */
+	if (udev-&gt;parent)
+		rc = usb_reset_device(udev);
+	return rc;
+}
+
 /**
  * usb_root_hub_lost_power - called by HCD if the root hub lost Vbus power
  * @rhdev: struct usb_device for the root hub
  *
  * The USB host controller driver calls this function when its root hub
  * is resumed and Vbus power has been interrupted or the controller
- * has been reset.  The routine marks all the children of the root hub
- * as NOTATTACHED and marks logical connect-change events on their ports.
+ * has been reset.  The routine marks @rhdev as having lost power.  When
+ * the hub driver is resumed it will take notice; if CONFIG_USB_PERSIST
+ * is enabled then it will carry out power-session recovery, otherwise
+ * it will disconnect all the child devices.
  */
 void usb_root_hub_lost_power(struct usb_device *rhdev)
 {
-	struct usb_hub *hub;
-	int port1;
-	unsigned long flags;
-
 	dev_warn(&amp;rhdev-&gt;dev, "root hub lost power or was reset\n");
-
-	spin_lock_irqsave(&amp;device_state_lock, flags);
-	hub = hdev_to_hub(rhdev);
-	for (port1 = 1; port1 &lt;= rhdev-&gt;maxchild; ++port1) {
-		if (rhdev-&gt;children[port1 - 1]) {
-			recursively_mark_NOTATTACHED(
-					rhdev-&gt;children[port1 - 1]);
-			set_bit(port1, hub-&gt;change_bits);
-		}
-	}
-	spin_unlock_irqrestore(&amp;device_state_lock, flags);
+	rhdev-&gt;reset_resume = 1;
 }
 EXPORT_SYMBOL_GPL(usb_root_hub_lost_power);
 
@@ -1513,29 +1620,6 @@ static int hub_port_reset(struct usb_hub *hub, int port1,
 	return status;
 }
 
-/*
- * Disable a port and mark a logical connnect-change event, so that some
- * time later khubd will disconnect() any existing usb_device on the port
- * and will re-enumerate if there actually is a device attached.
- */
-static void hub_port_logical_disconnect(struct usb_hub *hub, int port1)
-{
-	dev_dbg(hub-&gt;intfdev, "logical disconnect on port %d\n", port1);
-	hub_port_disable(hub, port1, 1);
-
-	/* FIXME let caller ask to power down the port:
-	 *  - some devices won't enumerate without a VBUS power cycle
-	 *  - SRP saves power that way
-	 *  - ... new call, TBD ...
-	 * That's easy if this hub can switch power per-port, and
-	 * khubd reactivates the port later (timer, SRP, etc).
-	 * Powerdown must be optional, because of reset/DFU.
-	 */
-
-	set_bit(port1, hub-&gt;change_bits);
- 	kick_khubd(hub);
-}
-
 #ifdef	CONFIG_PM
 
 #ifdef	CONFIG_USB_SUSPEND
@@ -3018,7 +3102,7 @@ int usb_reset_composite_device(struct usb_device *udev,
 					cintf-&gt;dev.driver) {
 				drv = to_usb_driver(cintf-&gt;dev.driver);
 				if (drv-&gt;post_reset)
-					(drv-&gt;post_reset)(cintf);
+					(drv-&gt;post_reset)(cintf, 0);
 			}
 			if (cintf != iface)
 				up(&amp;cintf-&gt;dev.sem);
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 6f361df374fc..1a4862886733 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -36,6 +36,7 @@ extern void usb_host_cleanup(void);
 extern void usb_autosuspend_work(struct work_struct *work);
 extern int usb_port_suspend(struct usb_device *dev);
 extern int usb_port_resume(struct usb_device *dev);
+extern int usb_reset_suspended_device(struct usb_device *udev);
 extern int usb_external_suspend_device(struct usb_device *udev,
 		pm_message_t msg);
 extern int usb_external_resume_device(struct usb_device *udev);
diff --git a/drivers/usb/storage/usb.c b/drivers/usb/storage/usb.c
index df5dc186aef5..be4cd8fe4ce6 100644
--- a/drivers/usb/storage/usb.c
+++ b/drivers/usb/storage/usb.c
@@ -236,7 +236,7 @@ static void storage_pre_reset(struct usb_interface *iface)
 	mutex_lock(&amp;us-&gt;dev_mutex);
 }
 
-static void storage_post_reset(struct usb_interface *iface)
+static void storage_post_reset(struct usb_interface *iface, int reset_resume)
 {
 	struct us_data *us = usb_get_intfdata(iface);
 
@@ -249,7 +249,11 @@ static void storage_post_reset(struct usb_interface *iface)
 
 	/* FIXME: Notify the subdrivers that they need to reinitialize
 	 * the device */
-	mutex_unlock(&amp;us-&gt;dev_mutex);
+
+	/* If this is a reset-resume then the pre_reset routine wasn't
+	 * called, so we don't need to unlock the mutex. */
+	if (!reset_resume)
+		mutex_unlock(&amp;us-&gt;dev_mutex);
 }
 
 /*
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 56aa2ee21f1b..3d63e0c2dd70 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -403,6 +403,7 @@ struct usb_device {
 
 	unsigned auto_pm:1;		/* autosuspend/resume in progress */
 	unsigned do_remote_wakeup:1;	/* remote wakeup should be enabled */
+	unsigned reset_resume:1;	/* needs reset instead of resume */
 	unsigned autosuspend_disabled:1; /* autosuspend and autoresume */
 	unsigned autoresume_disabled:1;  /*  disabled by the user */
 #endif
@@ -819,7 +820,10 @@ struct usbdrv_wrap {
  * @pre_reset: Called by usb_reset_composite_device() when the device
  *	is about to be reset.
  * @post_reset: Called by usb_reset_composite_device() after the device
- *	has been reset.
+ *	has been reset, or in lieu of @resume following a reset-resume
+ *	(i.e., the device is reset instead of being resumed, as might
+ *	happen if power was lost).  The second argument tells which is
+ *	the reason.
  * @id_table: USB drivers use ID table to support hotplugging.
  *	Export this with MODULE_DEVICE_TABLE(usb,...).  This must be set
  *	or your driver's probe function will never get called.
@@ -861,7 +865,7 @@ struct usb_driver {
 	int (*resume) (struct usb_interface *intf);
 
 	void (*pre_reset) (struct usb_interface *intf);
-	void (*post_reset) (struct usb_interface *intf);
+	void (*post_reset) (struct usb_interface *intf, int reset_resume);
 
 	const struct usb_device_id *id_table;
 </pre><hr><pre>commit e8054854221d9d51e381c64d365404f4c1c30f50
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 4 11:55:11 2007 -0400

    USB: make hub driver's release more robust
    
    This revised patch (as893c) improves the method used by the hub driver
    to release its private data structure.  The current code is non-robust,
    relying on a memory region not getting reused by another driver after
    it has been freed.  The patch adds a reference count to the structure,
    resolving the question of when to release it.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 9464eb504ae6..77a6627b18d2 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -34,6 +34,7 @@
 struct usb_hub {
 	struct device		*intfdev;	/* the "interface" device */
 	struct usb_device	*hdev;
+	struct kref		kref;
 	struct urb		*urb;		/* for interrupt polling pipe */
 
 	/* buffer for urb ... with extra space in case of babble */
@@ -66,6 +67,7 @@ struct usb_hub {
 	unsigned		limited_power:1;
 	unsigned		quiescing:1;
 	unsigned		activating:1;
+	unsigned		disconnected:1;
 
 	unsigned		has_indicators:1;
 	u8			indicator[USB_MAXCHILDREN];
@@ -321,7 +323,7 @@ static void kick_khubd(struct usb_hub *hub)
 	to_usb_interface(hub-&gt;intfdev)-&gt;pm_usage_cnt = 1;
 
 	spin_lock_irqsave(&amp;hub_event_lock, flags);
-	if (list_empty(&amp;hub-&gt;event_list)) {
+	if (!hub-&gt;disconnected &amp; list_empty(&amp;hub-&gt;event_list)) {
 		list_add_tail(&amp;hub-&gt;event_list, &amp;hub_event_list);
 		wake_up(&amp;khubd_wait);
 	}
@@ -330,6 +332,7 @@ static void kick_khubd(struct usb_hub *hub)
 
 void usb_kick_khubd(struct usb_device *hdev)
 {
+	/* FIXME: What if hdev isn't bound to the hub driver? */
 	kick_khubd(hdev_to_hub(hdev));
 }
 
@@ -845,43 +848,42 @@ static int hub_configure(struct usb_hub *hub,
 	return ret;
 }
 
+static void hub_release(struct kref *kref)
+{
+	struct usb_hub *hub = container_of(kref, struct usb_hub, kref);
+
+	usb_put_intf(to_usb_interface(hub-&gt;intfdev));
+	kfree(hub);
+}
+
 static unsigned highspeed_hubs;
 
 static void hub_disconnect(struct usb_interface *intf)
 {
 	struct usb_hub *hub = usb_get_intfdata (intf);
-	struct usb_device *hdev;
+
+	/* Take the hub off the event list and don't let it be added again */
+	spin_lock_irq(&amp;hub_event_lock);
+	list_del_init(&amp;hub-&gt;event_list);
+	hub-&gt;disconnected = 1;
+	spin_unlock_irq(&amp;hub_event_lock);
 
 	/* Disconnect all children and quiesce the hub */
 	hub-&gt;error = 0;
 	hub_pre_reset(intf);
 
 	usb_set_intfdata (intf, NULL);
-	hdev = hub-&gt;hdev;
 
-	if (hdev-&gt;speed == USB_SPEED_HIGH)
+	if (hub-&gt;hdev-&gt;speed == USB_SPEED_HIGH)
 		highspeed_hubs--;
 
 	usb_free_urb(hub-&gt;urb);
-	hub-&gt;urb = NULL;
-
-	spin_lock_irq(&amp;hub_event_lock);
-	list_del_init(&amp;hub-&gt;event_list);
-	spin_unlock_irq(&amp;hub_event_lock);
-
 	kfree(hub-&gt;descriptor);
-	hub-&gt;descriptor = NULL;
-
 	kfree(hub-&gt;status);
-	hub-&gt;status = NULL;
-
-	if (hub-&gt;buffer) {
-		usb_buffer_free(hdev, sizeof(*hub-&gt;buffer), hub-&gt;buffer,
-				hub-&gt;buffer_dma);
-		hub-&gt;buffer = NULL;
-	}
+	usb_buffer_free(hub-&gt;hdev, sizeof(*hub-&gt;buffer), hub-&gt;buffer,
+			hub-&gt;buffer_dma);
 
-	kfree(hub);
+	kref_put(&amp;hub-&gt;kref, hub_release);
 }
 
 static int hub_probe(struct usb_interface *intf, const struct usb_device_id *id)
@@ -929,10 +931,12 @@ static int hub_probe(struct usb_interface *intf, const struct usb_device_id *id)
 		return -ENOMEM;
 	}
 
+	kref_init(&amp;hub-&gt;kref);
 	INIT_LIST_HEAD(&amp;hub-&gt;event_list);
 	hub-&gt;intfdev = &amp;intf-&gt;dev;
 	hub-&gt;hdev = hdev;
 	INIT_DELAYED_WORK(&amp;hub-&gt;leds, led_work);
+	usb_get_intf(intf);
 
 	usb_set_intfdata (intf, hub);
 	intf-&gt;needs_remote_wakeup = 1;
@@ -2534,10 +2538,12 @@ static void hub_events(void)
 		list_del_init(tmp);
 
 		hub = list_entry(tmp, struct usb_hub, event_list);
-		hdev = hub-&gt;hdev;
-		intf = to_usb_interface(hub-&gt;intfdev);
-		hub_dev = &amp;intf-&gt;dev;
+		kref_get(&amp;hub-&gt;kref);
+		spin_unlock_irq(&amp;hub_event_lock);
 
+		hdev = hub-&gt;hdev;
+		hub_dev = hub-&gt;intfdev;
+		intf = to_usb_interface(hub_dev);
 		dev_dbg(hub_dev, "state %d ports %d chg %04x evt %04x\n",
 				hdev-&gt;state, hub-&gt;descriptor
 					? hub-&gt;descriptor-&gt;bNbrPorts
@@ -2546,13 +2552,10 @@ static void hub_events(void)
 				(u16) hub-&gt;change_bits[0],
 				(u16) hub-&gt;event_bits[0]);
 
-		usb_get_intf(intf);
-		spin_unlock_irq(&amp;hub_event_lock);
-
 		/* Lock the device, then check to see if we were
 		 * disconnected while waiting for the lock to succeed. */
 		usb_lock_device(hdev);
-		if (hub != usb_get_intfdata(intf))
+		if (unlikely(hub-&gt;disconnected))
 			goto loop;
 
 		/* If the hub has died, clean up after it */
@@ -2715,7 +2718,7 @@ static void hub_events(void)
 			usb_autopm_enable(intf);
 loop:
 		usb_unlock_device(hdev);
-		usb_put_intf(intf);
+		kref_put(&amp;hub-&gt;kref, hub_release);
 
         } /* end while (1) */
 }</pre><hr><pre>commit 06b84e8adcad8280d76a7c71e772c5cddba96d85
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 4 11:54:50 2007 -0400

    USB: remove "locktree" routine from the hub driver
    
    This patch (as892) removes the "locktree" routine from the hub driver.
    It currently is used in only one place, by a single kernel thread;
    hence it isn't doing any good.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 702023075310..9464eb504ae6 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -982,49 +982,6 @@ hub_ioctl(struct usb_interface *intf, unsigned int code, void *user_data)
 }
 
 
-/* grab device/port lock, returning index of that port (zero based).
- * protects the upstream link used by this device from concurrent
- * tree operations like suspend, resume, reset, and disconnect, which
- * apply to everything downstream of a given port.
- */
-static int locktree(struct usb_device *udev)
-{
-	int			t;
-	struct usb_device	*hdev;
-
-	if (!udev)
-		return -ENODEV;
-
-	/* root hub is always the first lock in the series */
-	hdev = udev-&gt;parent;
-	if (!hdev) {
-		usb_lock_device(udev);
-		return 0;
-	}
-
-	/* on the path from root to us, lock everything from
-	 * top down, dropping parent locks when not needed
-	 */
-	t = locktree(hdev);
-	if (t &lt; 0)
-		return t;
-
-	/* everything is fail-fast once disconnect
-	 * processing starts
-	 */
-	if (udev-&gt;state == USB_STATE_NOTATTACHED) {
-		usb_unlock_device(hdev);
-		return -ENODEV;
-	}
-
-	/* when everyone grabs locks top-&gt;bottom,
-	 * non-overlapping work may be concurrent
-	 */
-	usb_lock_device(udev);
-	usb_unlock_device(hdev);
-	return udev-&gt;portnum;
-}
-
 static void recursively_mark_NOTATTACHED(struct usb_device *udev)
 {
 	int i;
@@ -2594,10 +2551,7 @@ static void hub_events(void)
 
 		/* Lock the device, then check to see if we were
 		 * disconnected while waiting for the lock to succeed. */
-		if (locktree(hdev) &lt; 0) {
-			usb_put_intf(intf);
-			continue;
-		}
+		usb_lock_device(hdev);
 		if (hub != usb_get_intfdata(intf))
 			goto loop;
 </pre>
    <div class="pagination">
        <a href='2_106.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><span>[107]</span><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_108.html'>Next&gt;&gt;</a>
    <div>
</body>
