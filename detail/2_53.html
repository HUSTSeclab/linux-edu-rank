<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_52.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><span>[53]</span><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_54.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit fde25a9b63b9a3dc91365c394a426ebe64cfc2da
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jan 24 13:34:24 2012 -0500

    Driver core: driver_find() drops reference before returning
    
    As part of the removal of get_driver()/put_driver(), this patch
    (as1510) changes driver_find(); it now drops the reference it acquires
    before returning.  The patch also adjusts all the callers of
    driver_find() to remove the now unnecessary calls to put_driver().
    
    In addition, the patch adds a warning to driver_find(): Callers must
    make sure the driver they are searching for does not get unloaded
    while they are using it.  This has always been the case; driver_find()
    has never prevented a driver from being unregistered or unloaded.
    Hence the patch will not introduce any new bugs.  The existing callers
    all seem to be okay in this respect, however I don't understand the
    video drivers well enough to be certain about them.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Dmitry Torokhov &lt;dmitry.torokhov@gmail.com&gt;
    CC: Kyungmin Park &lt;kyungmin.park@samsung.com&gt;
    CC: Andy Walls &lt;awalls@md.metrocast.net&gt;
    CC: Martin Schwidefsky &lt;schwidefsky@de.ibm.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index b631f7c59453..e979cad75c6e 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -234,7 +234,6 @@ int driver_register(struct device_driver *drv)
 
 	other = driver_find(drv-&gt;name, drv-&gt;bus);
 	if (other) {
-		put_driver(other);
 		printk(KERN_ERR "Error: Driver '%s' is already registered, "
 			"aborting...\n", drv-&gt;name);
 		return -EBUSY;
@@ -275,7 +274,9 @@ EXPORT_SYMBOL_GPL(driver_unregister);
  * Call kset_find_obj() to iterate over list of drivers on
  * a bus to find driver by name. Return driver if found.
  *
- * Note that kset_find_obj increments driver's reference count.
+ * This routine provides no locking to prevent the driver it returns
+ * from being unregistered or unloaded while the caller is using it.
+ * The caller is responsible for preventing this.
  */
 struct device_driver *driver_find(const char *name, struct bus_type *bus)
 {
@@ -283,6 +284,8 @@ struct device_driver *driver_find(const char *name, struct bus_type *bus)
 	struct driver_private *priv;
 
 	if (k) {
+		/* Drop reference added by kset_find_obj() */
+		kobject_put(k);
 		priv = to_driver(k);
 		return priv-&gt;driver;
 	}
diff --git a/drivers/input/gameport/gameport.c b/drivers/input/gameport/gameport.c
index c351aa421f8f..da739d9d1905 100644
--- a/drivers/input/gameport/gameport.c
+++ b/drivers/input/gameport/gameport.c
@@ -449,7 +449,6 @@ static ssize_t gameport_rebind_driver(struct device *dev, struct device_attribut
 	} else if ((drv = driver_find(buf, &amp;gameport_bus)) != NULL) {
 		gameport_disconnect_port(gameport);
 		error = gameport_bind_driver(gameport, to_gameport_driver(drv));
-		put_driver(drv);
 	} else {
 		error = -EINVAL;
 	}
diff --git a/drivers/input/serio/serio.c b/drivers/input/serio/serio.c
index ba70058e2be3..d0f7533dbf88 100644
--- a/drivers/input/serio/serio.c
+++ b/drivers/input/serio/serio.c
@@ -441,7 +441,6 @@ static ssize_t serio_rebind_driver(struct device *dev, struct device_attribute *
 	} else if ((drv = driver_find(buf, &amp;serio_bus)) != NULL) {
 		serio_disconnect_port(serio);
 		error = serio_bind_driver(serio, to_serio_driver(drv));
-		put_driver(drv);
 		serio_remove_duplicate_events(serio, SERIO_RESCAN_PORT);
 	} else {
 		error = -EINVAL;
diff --git a/drivers/media/video/cx18/cx18-alsa-main.c b/drivers/media/video/cx18/cx18-alsa-main.c
index a1e6c2a32478..e118361c2e7b 100644
--- a/drivers/media/video/cx18/cx18-alsa-main.c
+++ b/drivers/media/video/cx18/cx18-alsa-main.c
@@ -285,7 +285,6 @@ static void __exit cx18_alsa_exit(void)
 
 	drv = driver_find("cx18", &amp;pci_bus_type);
 	ret = driver_for_each_device(drv, NULL, NULL, cx18_alsa_exit_callback);
-	put_driver(drv);
 
 	cx18_ext_init = NULL;
 	printk(KERN_INFO "cx18-alsa: module unload complete\n");
diff --git a/drivers/media/video/ivtv/ivtvfb.c b/drivers/media/video/ivtv/ivtvfb.c
index d0fbfcf7133d..e5e7fa9e737b 100644
--- a/drivers/media/video/ivtv/ivtvfb.c
+++ b/drivers/media/video/ivtv/ivtvfb.c
@@ -1293,7 +1293,6 @@ static int __init ivtvfb_init(void)
 
 	drv = driver_find("ivtv", &amp;pci_bus_type);
 	err = driver_for_each_device(drv, NULL, &amp;registered, ivtvfb_callback_init);
-	put_driver(drv);
 	if (!registered) {
 		printk(KERN_ERR "ivtvfb:  no cards found\n");
 		return -ENODEV;
@@ -1310,7 +1309,6 @@ static void ivtvfb_cleanup(void)
 
 	drv = driver_find("ivtv", &amp;pci_bus_type);
 	err = driver_for_each_device(drv, NULL, NULL, ivtvfb_callback_cleanup);
-	put_driver(drv);
 }
 
 module_init(ivtvfb_init);
diff --git a/drivers/media/video/s5p-fimc/fimc-mdevice.c b/drivers/media/video/s5p-fimc/fimc-mdevice.c
index 8ea4ee116e46..63eccb55728f 100644
--- a/drivers/media/video/s5p-fimc/fimc-mdevice.c
+++ b/drivers/media/video/s5p-fimc/fimc-mdevice.c
@@ -344,16 +344,13 @@ static int fimc_md_register_platform_entities(struct fimc_md *fmd)
 		return -ENODEV;
 	ret = driver_for_each_device(driver, NULL, fmd,
 				     fimc_register_callback);
-	put_driver(driver);
 	if (ret)
 		return ret;
 
 	driver = driver_find(CSIS_DRIVER_NAME, &amp;platform_bus_type);
-	if (driver) {
+	if (driver)
 		ret = driver_for_each_device(driver, NULL, fmd,
 					     csis_register_callback);
-		put_driver(driver);
-	}
 	return ret;
 }
 
diff --git a/drivers/media/video/s5p-tv/mixer_video.c b/drivers/media/video/s5p-tv/mixer_video.c
index 7884baeff76a..f7ca5cc143c6 100644
--- a/drivers/media/video/s5p-tv/mixer_video.c
+++ b/drivers/media/video/s5p-tv/mixer_video.c
@@ -58,7 +58,6 @@ static struct v4l2_subdev *find_and_register_subdev(
 	}
 
 done:
-	put_driver(drv);
 	return sd;
 }
 
diff --git a/drivers/s390/net/smsgiucv_app.c b/drivers/s390/net/smsgiucv_app.c
index 4d2ea4000422..32515a201bbc 100644
--- a/drivers/s390/net/smsgiucv_app.c
+++ b/drivers/s390/net/smsgiucv_app.c
@@ -168,7 +168,7 @@ static int __init smsgiucv_app_init(void)
 	rc = dev_set_name(smsg_app_dev, KMSG_COMPONENT);
 	if (rc) {
 		kfree(smsg_app_dev);
-		goto fail_put_driver;
+		goto fail;
 	}
 	smsg_app_dev-&gt;bus = &amp;iucv_bus;
 	smsg_app_dev-&gt;parent = iucv_root;
@@ -177,7 +177,7 @@ static int __init smsgiucv_app_init(void)
 	rc = device_register(smsg_app_dev);
 	if (rc) {
 		put_device(smsg_app_dev);
-		goto fail_put_driver;
+		goto fail;
 	}
 
 	/* convert sender to uppercase characters */
@@ -191,12 +191,11 @@ static int __init smsgiucv_app_init(void)
 	rc = smsg_register_callback(SMSG_PREFIX, smsg_app_callback);
 	if (rc) {
 		device_unregister(smsg_app_dev);
-		goto fail_put_driver;
+		goto fail;
 	}
 
 	rc = 0;
-fail_put_driver:
-	put_driver(smsgiucv_drv);
+fail:
 	return rc;
 }
 module_init(smsgiucv_app_init);</pre><hr><pre>commit 194b3af4eb4b7ba84e2e4274daf9f58aa958bd04
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jan 24 11:58:15 2012 -0500

    USB: OHCI: fix new compiler warnings
    
    This patch (as1515) fixes some unavoidably dumb compiler warnings:
    
      CC [M]  drivers/usb/renesas_usbhs/mod.o
    In file included from drivers/usb/host/ohci-hcd.c:101:0:
    drivers/usb/host/ohci-dbg.c: In function ‘fill_registers_buffer’:
    drivers/usb/host/ohci-dbg.c:656:2: warning: the comparison will always evaluate as ‘true’ for the address of ‘next’ will never be NULL [-Waddress]
    drivers/usb/host/ohci-dbg.c:675:3: warning: the comparison will always evaluate as ‘true’ for the address of ‘next’ will never be NULL [-Waddress]
    
    Instead of trying to fix the macro to work under all cirumstances,
    just add a second macro for use in cases where the "next" argument is
    the address of a local variable.
    
    Unfortunately the macro cannot be replaced by a real subroutine,
    because there's no va_list version of ohci_dbg() or dev_dbg().
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ohci-dbg.c b/drivers/usb/host/ohci-dbg.c
index 5179fcd73d8a..e4bcb62b930a 100644
--- a/drivers/usb/host/ohci-dbg.c
+++ b/drivers/usb/host/ohci-dbg.c
@@ -82,6 +82,14 @@ urb_print(struct urb * urb, char * str, int small, int status)
 		ohci_dbg(ohci,format, ## arg ); \
 	} while (0);
 
+/* Version for use where "next" is the address of a local variable */
+#define ohci_dbg_nosw(ohci, next, size, format, arg...) \
+	do { \
+		unsigned s_len; \
+		s_len = scnprintf(*next, *size, format, ## arg); \
+		*size -= s_len; *next += s_len; \
+	} while (0);
+
 
 static void ohci_dump_intr_mask (
 	struct ohci_hcd *ohci,
@@ -653,7 +661,7 @@ static ssize_t fill_registers_buffer(struct debug_buffer *buf)
 
 	/* dump driver info, then registers in spec order */
 
-	ohci_dbg_sw (ohci, &amp;next, &amp;size,
+	ohci_dbg_nosw(ohci, &amp;next, &amp;size,
 		"bus %s, device %s\n"
 		"%s\n"
 		"%s\n",
@@ -672,7 +680,7 @@ static ssize_t fill_registers_buffer(struct debug_buffer *buf)
 
 	/* hcca */
 	if (ohci-&gt;hcca)
-		ohci_dbg_sw (ohci, &amp;next, &amp;size,
+		ohci_dbg_nosw(ohci, &amp;next, &amp;size,
 			"hcca frame 0x%04x\n", ohci_frame_no(ohci));
 
 	/* other registers mostly affect frame timings */</pre><hr><pre>commit b10d5efdf7892d18b3b7d899edce2c8d9b80aea9
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jan 17 11:39:00 2012 -0500

    Documentation update for the driver model core
    
    This patch (as1509) documents two important points regarding the use
    of device structures in the driver model:
    
            Structures must be initialized to all 0's before they are
            passed to device_initialize().
    
            Structures must not be passed to device_add() or
            device_register() more than once.
    
    Although these restrictions have applied ever since the driver model
    was first created, they have not been mentioned anywhere.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 4a67cc0c8b37..ad29e928baaa 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -632,6 +632,11 @@ static void klist_children_put(struct klist_node *n)
  * may be used for reference counting of @dev after calling this
  * function.
  *
+ * All fields in @dev must be initialized by the caller to 0, except
+ * for those explicitly set to some other value.  The simplest
+ * approach is to use kzalloc() to allocate the structure containing
+ * @dev.
+ *
  * NOTE: Use put_device() to give up your reference instead of freeing
  * @dev directly once you have called this function.
  */
@@ -930,6 +935,13 @@ int device_private_init(struct device *dev)
  * to the global and sibling lists for the device, then
  * adds it to the other relevant subsystems of the driver model.
  *
+ * Do not call this routine or device_register() more than once for
+ * any device structure.  The driver model core is not designed to work
+ * with devices that get unregistered and then spring back to life.
+ * (Among other things, it's very hard to guarantee that all references
+ * to the previous incarnation of @dev have been dropped.)  Allocate
+ * and register a fresh new struct device instead.
+ *
  * NOTE: _Never_ directly free @dev after calling this function, even
  * if it returned an error! Always use put_device() to give up your
  * reference instead.
@@ -1090,6 +1102,9 @@ int device_add(struct device *dev)
  * have a clearly defined need to use and refcount the device
  * before it is added to the hierarchy.
  *
+ * For more information, see the kerneldoc for device_initialize()
+ * and device_add().
+ *
  * NOTE: _Never_ directly free @dev after calling this function, even
  * if it returned an error! Always use put_device() to give up the
  * reference initialized in this function instead.</pre><hr><pre>commit d8cae98cddd286e38db1724dda1b0e7b467f9237
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jan 4 16:36:35 2012 -0500

    USB: update documentation for usbmon
    
    The documentation for usbmon is out of date; the usbfs "devices" file
    now exists in /sys/kernel/debug/usb rather than /proc/bus/usb.  This
    patch (as1505) updates the documentation accordingly, and also
    mentions that the necessary information can be found by running lsusb.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Pete Zaitcev &lt;zaitcev@redhat.com&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/Documentation/usb/usbmon.txt b/Documentation/usb/usbmon.txt
index a4efa0462f05..5335fa8b06eb 100644
--- a/Documentation/usb/usbmon.txt
+++ b/Documentation/usb/usbmon.txt
@@ -47,10 +47,11 @@ This allows to filter away annoying devices that talk continuously.
 
 2. Find which bus connects to the desired device
 
-Run "cat /proc/bus/usb/devices", and find the T-line which corresponds to
-the device. Usually you do it by looking for the vendor string. If you have
-many similar devices, unplug one and compare two /proc/bus/usb/devices outputs.
-The T-line will have a bus number. Example:
+Run "cat /sys/kernel/debug/usb/devices", and find the T-line which corresponds
+to the device. Usually you do it by looking for the vendor string. If you have
+many similar devices, unplug one and compare the two
+/sys/kernel/debug/usb/devices outputs. The T-line will have a bus number.
+Example:
 
 T:  Bus=03 Lev=01 Prnt=01 Port=00 Cnt=01 Dev#=  2 Spd=12  MxCh= 0
 D:  Ver= 1.10 Cls=00(&gt;ifc ) Sub=00 Prot=00 MxPS= 8 #Cfgs=  1
@@ -58,7 +59,10 @@ P:  Vendor=0557 ProdID=2004 Rev= 1.00
 S:  Manufacturer=ATEN
 S:  Product=UC100KM V2.00
 
-Bus=03 means it's bus 3.
+"Bus=03" means it's bus 3. Alternatively, you can look at the output from
+"lsusb" and get the bus number from the appropriate line. Example:
+
+Bus 003 Device 002: ID 0557:2004 ATEN UC100KM V2.00
 
 3. Start 'cat'
 </pre><hr><pre>commit fe6b91f47080eb17d21cbf2a39311877d57f6938
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Dec 6 23:24:52 2011 +0100

    PM / Driver core: leave runtime PM enabled during system shutdown
    
    Disabling all runtime PM during system shutdown turns out not to be a
    good idea, because some devices may need to be woken up from a
    low-power state at that time.
    
    The whole point of disabling runtime PM for system shutdown was to
    prevent untimely runtime-suspend method calls.  This patch (as1504)
    accomplishes the same result by incrementing the usage count for each
    device and waiting for ongoing runtime-PM callbacks to finish.  This
    is what we already do during system suspend and hibernation, which
    makes sense since the shutdown method is pretty much a legacy analog
    of the pm-&gt;poweroff method.
    
    This fixes a recent regression on some OMAP systems introduced by
    commit af8db1508f2c9f3b6e633e2d2d906c6557c617f9 (PM / driver core:
    disable device's runtime PM during shutdown).
    
    Reported-and-tested-by: NeilBrown &lt;neilb@suse.de&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;
    Signed-off-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;

diff --git a/drivers/base/core.c b/drivers/base/core.c
index d8b3d89db043..919daa7cd5b1 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -1743,8 +1743,10 @@ void device_shutdown(void)
 		 */
 		list_del_init(&amp;dev-&gt;kobj.entry);
 		spin_unlock(&amp;devices_kset-&gt;list_lock);
-		/* Disable all device's runtime power management */
-		pm_runtime_disable(dev);
+
+		/* Don't allow any more runtime suspends */
+		pm_runtime_get_noresume(dev);
+		pm_runtime_barrier(dev);
 
 		if (dev-&gt;bus &amp;&amp; dev-&gt;bus-&gt;shutdown) {
 			dev_dbg(dev, "shutdown\n");</pre><hr><pre>commit 045ddc8991698a8e9c5668c6190faa8b5d516dc0
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Nov 21 10:15:13 2011 -0500

    NLS: raname "maxlen" to "maxout" in UTF conversion routines
    
    As requested by NamJae Jeon, this patch (as1503) changes the name of
    the "maxlen" parameters to "maxout" in the various UTF conversion
    routines.  This should make the role of that parameter more clear.
    
    The patch also renames the "len" parameters to "inlen", for the same
    reason.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reviewed-by: NamJae Jeon &lt;linkinjeon@gmail.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/fs/nls/nls_base.c b/fs/nls/nls_base.c
index 0eb059ec6f28..fea6bd5831dc 100644
--- a/fs/nls/nls_base.c
+++ b/fs/nls/nls_base.c
@@ -52,7 +52,7 @@ static const struct utf8_table utf8_table[] =
 #define SURROGATE_LOW	0x00000400
 #define SURROGATE_BITS	0x000003ff
 
-int utf8_to_utf32(const u8 *s, int len, unicode_t *pu)
+int utf8_to_utf32(const u8 *s, int inlen, unicode_t *pu)
 {
 	unsigned long l;
 	int c0, c, nc;
@@ -71,7 +71,7 @@ int utf8_to_utf32(const u8 *s, int len, unicode_t *pu)
 			*pu = (unicode_t) l;
 			return nc;
 		}
-		if (len &lt;= nc)
+		if (inlen &lt;= nc)
 			return -1;
 		s++;
 		c = (*s ^ 0x80) &amp; 0xFF;
@@ -83,7 +83,7 @@ int utf8_to_utf32(const u8 *s, int len, unicode_t *pu)
 }
 EXPORT_SYMBOL(utf8_to_utf32);
 
-int utf32_to_utf8(unicode_t u, u8 *s, int maxlen)
+int utf32_to_utf8(unicode_t u, u8 *s, int maxout)
 {
 	unsigned long l;
 	int c, nc;
@@ -97,7 +97,7 @@ int utf32_to_utf8(unicode_t u, u8 *s, int maxlen)
 		return -1;
 
 	nc = 0;
-	for (t = utf8_table; t-&gt;cmask &amp;&amp; maxlen; t++, maxlen--) {
+	for (t = utf8_table; t-&gt;cmask &amp;&amp; maxout; t++, maxout--) {
 		nc++;
 		if (l &lt;= t-&gt;lmask) {
 			c = t-&gt;shift;
@@ -129,24 +129,24 @@ static inline void put_utf16(wchar_t *s, unsigned c, enum utf16_endian endian)
 	}
 }
 
-int utf8s_to_utf16s(const u8 *s, int len, enum utf16_endian endian,
-		wchar_t *pwcs, int maxlen)
+int utf8s_to_utf16s(const u8 *s, int inlen, enum utf16_endian endian,
+		wchar_t *pwcs, int maxout)
 {
 	u16 *op;
 	int size;
 	unicode_t u;
 
 	op = pwcs;
-	while (len &gt; 0 &amp;&amp; maxlen &gt; 0 &amp;&amp; *s) {
+	while (inlen &gt; 0 &amp;&amp; maxout &gt; 0 &amp;&amp; *s) {
 		if (*s &amp; 0x80) {
-			size = utf8_to_utf32(s, len, &amp;u);
+			size = utf8_to_utf32(s, inlen, &amp;u);
 			if (size &lt; 0)
 				return -EINVAL;
 			s += size;
-			len -= size;
+			inlen -= size;
 
 			if (u &gt;= PLANE_SIZE) {
-				if (maxlen &lt; 2)
+				if (maxout &lt; 2)
 					break;
 				u -= PLANE_SIZE;
 				put_utf16(op++, SURROGATE_PAIR |
@@ -156,15 +156,15 @@ int utf8s_to_utf16s(const u8 *s, int len, enum utf16_endian endian,
 						SURROGATE_LOW |
 						(u &amp; SURROGATE_BITS),
 						endian);
-				maxlen -= 2;
+				maxout -= 2;
 			} else {
 				put_utf16(op++, u, endian);
-				maxlen--;
+				maxout--;
 			}
 		} else {
 			put_utf16(op++, *s++, endian);
-			len--;
-			maxlen--;
+			inlen--;
+			maxout--;
 		}
 	}
 	return op - pwcs;
@@ -183,27 +183,27 @@ static inline unsigned long get_utf16(unsigned c, enum utf16_endian endian)
 	}
 }
 
-int utf16s_to_utf8s(const wchar_t *pwcs, int len, enum utf16_endian endian,
-		u8 *s, int maxlen)
+int utf16s_to_utf8s(const wchar_t *pwcs, int inlen, enum utf16_endian endian,
+		u8 *s, int maxout)
 {
 	u8 *op;
 	int size;
 	unsigned long u, v;
 
 	op = s;
-	while (len &gt; 0 &amp;&amp; maxlen &gt; 0) {
+	while (inlen &gt; 0 &amp;&amp; maxout &gt; 0) {
 		u = get_utf16(*pwcs, endian);
 		if (!u)
 			break;
 		pwcs++;
-		len--;
+		inlen--;
 		if (u &gt; 0x7f) {
 			if ((u &amp; SURROGATE_MASK) == SURROGATE_PAIR) {
 				if (u &amp; SURROGATE_LOW) {
 					/* Ignore character and move on */
 					continue;
 				}
-				if (len &lt;= 0)
+				if (inlen &lt;= 0)
 					break;
 				v = get_utf16(*pwcs, endian);
 				if ((v &amp; SURROGATE_MASK) != SURROGATE_PAIR ||
@@ -214,18 +214,18 @@ int utf16s_to_utf8s(const wchar_t *pwcs, int len, enum utf16_endian endian,
 				u = PLANE_SIZE + ((u &amp; SURROGATE_BITS) &lt;&lt; 10)
 						+ (v &amp; SURROGATE_BITS);
 				pwcs++;
-				len--;
+				inlen--;
 			}
-			size = utf32_to_utf8(u, op, maxlen);
+			size = utf32_to_utf8(u, op, maxout);
 			if (size == -1) {
 				/* Ignore character and move on */
 			} else {
 				op += size;
-				maxlen -= size;
+				maxout -= size;
 			}
 		} else {
 			*op++ = (u8) u;
-			maxlen--;
+			maxout--;
 		}
 	}
 	return op - s;</pre><hr><pre>commit c61875977458637226ab093a35d200f2d5789787
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Nov 17 16:41:45 2011 -0500

    OHCI: final fix for NVIDIA problems (I hope)
    
    Problems with NVIDIA's OHCI host controllers persist.  After looking
    carefully through the spec, I finally realized that when a controller
    is reset it then automatically goes into a SUSPEND state in which it
    is completely quiescent (no DMA and no IRQs) and from which it will
    not awaken until the system puts it into the OPERATIONAL state.
    
    Therefore there's no need to worry about controllers being in the
    RESET state for extended periods, or remaining in the OPERATIONAL
    state during system shutdown.  The proper action for device
    initialization is to put the controller into the RESET state (if it's
    not there already) and then to issue a software reset.  Similarly, the
    proper action for device shutdown is simply to do a software reset.
    
    This patch (as1499) implements such an approach.  It simplifies
    initialization and shutdown, and allows the NVIDIA shutdown-quirk code
    to be removed.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Andre "Osku" Schmidt &lt;andre.osku.schmidt@googlemail.com&gt;
    Tested-by: Arno Augustin &lt;Arno.Augustin@web.de&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt; [after tested in 3.2 for a while]
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index 34efd479e068..b2639191549e 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -389,17 +389,14 @@ ohci_shutdown (struct usb_hcd *hcd)
 	struct ohci_hcd *ohci;
 
 	ohci = hcd_to_ohci (hcd);
-	ohci_writel (ohci, OHCI_INTR_MIE, &amp;ohci-&gt;regs-&gt;intrdisable);
-	ohci-&gt;hc_control = ohci_readl(ohci, &amp;ohci-&gt;regs-&gt;control);
+	ohci_writel(ohci, (u32) ~0, &amp;ohci-&gt;regs-&gt;intrdisable);
 
-	/* If the SHUTDOWN quirk is set, don't put the controller in RESET */
-	ohci-&gt;hc_control &amp;= (ohci-&gt;flags &amp; OHCI_QUIRK_SHUTDOWN ?
-			OHCI_CTRL_RWC | OHCI_CTRL_HCFS :
-			OHCI_CTRL_RWC);
-	ohci_writel(ohci, ohci-&gt;hc_control, &amp;ohci-&gt;regs-&gt;control);
+	/* Software reset, after which the controller goes into SUSPEND */
+	ohci_writel(ohci, OHCI_HCR, &amp;ohci-&gt;regs-&gt;cmdstatus);
+	ohci_readl(ohci, &amp;ohci-&gt;regs-&gt;cmdstatus);	/* flush the writes */
+	udelay(10);
 
-	/* flush the writes */
-	(void) ohci_readl (ohci, &amp;ohci-&gt;regs-&gt;control);
+	ohci_writel(ohci, ohci-&gt;fminterval, &amp;ohci-&gt;regs-&gt;fminterval);
 }
 
 static int check_ed(struct ohci_hcd *ohci, struct ed *ed)
diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index ad8166c681e2..bc01b064585a 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -175,28 +175,6 @@ static int ohci_quirk_amd700(struct usb_hcd *hcd)
 	return 0;
 }
 
-/* nVidia controllers continue to drive Reset signalling on the bus
- * even after system shutdown, wasting power.  This flag tells the
- * shutdown routine to leave the controller OPERATIONAL instead of RESET.
- */
-static int ohci_quirk_nvidia_shutdown(struct usb_hcd *hcd)
-{
-	struct pci_dev *pdev = to_pci_dev(hcd-&gt;self.controller);
-	struct ohci_hcd	*ohci = hcd_to_ohci(hcd);
-
-	/* Evidently nVidia fixed their later hardware; this is a guess at
-	 * the changeover point.
-	 */
-#define PCI_DEVICE_ID_NVIDIA_NFORCE_MCP51_USB		0x026d
-
-	if (pdev-&gt;device &lt; PCI_DEVICE_ID_NVIDIA_NFORCE_MCP51_USB) {
-		ohci-&gt;flags |= OHCI_QUIRK_SHUTDOWN;
-		ohci_dbg(ohci, "enabled nVidia shutdown quirk\n");
-	}
-
-	return 0;
-}
-
 static void sb800_prefetch(struct ohci_hcd *ohci, int on)
 {
 	struct pci_dev *pdev;
@@ -260,10 +238,6 @@ static const struct pci_device_id ohci_pci_quirks[] = {
 		PCI_DEVICE(PCI_VENDOR_ID_ATI, 0x4399),
 		.driver_data = (unsigned long)ohci_quirk_amd700,
 	},
-	{
-		PCI_DEVICE(PCI_VENDOR_ID_NVIDIA, PCI_ANY_ID),
-		.driver_data = (unsigned long) ohci_quirk_nvidia_shutdown,
-	},
 
 	/* FIXME for some of the early AMD 760 southbridges, OHCI
 	 * won't work at all.  blacklist them.
diff --git a/drivers/usb/host/ohci.h b/drivers/usb/host/ohci.h
index 35e5fd640ce7..0795b934d00c 100644
--- a/drivers/usb/host/ohci.h
+++ b/drivers/usb/host/ohci.h
@@ -403,7 +403,6 @@ struct ohci_hcd {
 #define	OHCI_QUIRK_HUB_POWER	0x100			/* distrust firmware power/oc setup */
 #define	OHCI_QUIRK_AMD_PLL	0x200			/* AMD PLL quirk*/
 #define	OHCI_QUIRK_AMD_PREFETCH	0x400			/* pre-fetch for ISO transfer */
-#define	OHCI_QUIRK_SHUTDOWN	0x800			/* nVidia power bug */
 	// there are also chip quirks/bugs in init logic
 
 	struct work_struct	nec_work;	/* Worker for NEC quirk */
diff --git a/drivers/usb/host/pci-quirks.c b/drivers/usb/host/pci-quirks.c
index c7fd6ce11904..caf87428ca43 100644
--- a/drivers/usb/host/pci-quirks.c
+++ b/drivers/usb/host/pci-quirks.c
@@ -37,6 +37,7 @@
 #define OHCI_INTRENABLE		0x10
 #define OHCI_INTRDISABLE	0x14
 #define OHCI_FMINTERVAL		0x34
+#define OHCI_HCFS		(3 &lt;&lt; 6)	/* hc functional state */
 #define OHCI_HCR		(1 &lt;&lt; 0)	/* host controller reset */
 #define OHCI_OCR		(1 &lt;&lt; 3)	/* ownership change request */
 #define OHCI_CTRL_RWC		(1 &lt;&lt; 9)	/* remote wakeup connected */
@@ -466,6 +467,8 @@ static void __devinit quirk_usb_handoff_ohci(struct pci_dev *pdev)
 {
 	void __iomem *base;
 	u32 control;
+	u32 fminterval;
+	int cnt;
 
 	if (!mmio_resource_enabled(pdev, 0))
 		return;
@@ -498,41 +501,32 @@ static void __devinit quirk_usb_handoff_ohci(struct pci_dev *pdev)
 	}
 #endif
 
-	/* reset controller, preserving RWC (and possibly IR) */
-	writel(control &amp; OHCI_CTRL_MASK, base + OHCI_CONTROL);
-	readl(base + OHCI_CONTROL);
+	/* disable interrupts */
+	writel((u32) ~0, base + OHCI_INTRDISABLE);
 
-	/* Some NVIDIA controllers stop working if kept in RESET for too long */
-	if (pdev-&gt;vendor == PCI_VENDOR_ID_NVIDIA) {
-		u32 fminterval;
-		int cnt;
+	/* Reset the USB bus, if the controller isn't already in RESET */
+	if (control &amp; OHCI_HCFS) {
+		/* Go into RESET, preserving RWC (and possibly IR) */
+		writel(control &amp; OHCI_CTRL_MASK, base + OHCI_CONTROL);
+		readl(base + OHCI_CONTROL);
 
-		/* drive reset for at least 50 ms (7.1.7.5) */
+		/* drive bus reset for at least 50 ms (7.1.7.5) */
 		msleep(50);
+	}
 
-		/* software reset of the controller, preserving HcFmInterval */
-		fminterval = readl(base + OHCI_FMINTERVAL);
-		writel(OHCI_HCR, base + OHCI_CMDSTATUS);
+	/* software reset of the controller, preserving HcFmInterval */
+	fminterval = readl(base + OHCI_FMINTERVAL);
+	writel(OHCI_HCR, base + OHCI_CMDSTATUS);
 
-		/* reset requires max 10 us delay */
-		for (cnt = 30; cnt &gt; 0; --cnt) {	/* ... allow extra time */
-			if ((readl(base + OHCI_CMDSTATUS) &amp; OHCI_HCR) == 0)
-				break;
-			udelay(1);
-		}
-		writel(fminterval, base + OHCI_FMINTERVAL);
-
-		/* Now we're in the SUSPEND state with all devices reset
-		 * and wakeups and interrupts disabled
-		 */
+	/* reset requires max 10 us delay */
+	for (cnt = 30; cnt &gt; 0; --cnt) {	/* ... allow extra time */
+		if ((readl(base + OHCI_CMDSTATUS) &amp; OHCI_HCR) == 0)
+			break;
+		udelay(1);
 	}
+	writel(fminterval, base + OHCI_FMINTERVAL);
 
-	/*
-	 * disable interrupts
-	 */
-	writel(~(u32)0, base + OHCI_INTRDISABLE);
-	writel(~(u32)0, base + OHCI_INTRSTATUS);
-
+	/* Now the controller is safely in SUSPEND and nothing can wake it up */
 	iounmap(base);
 }
 </pre><hr><pre>commit 3f5eb8d5688a5266ab943cf94aebe4c0eea726a3
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Nov 17 16:41:35 2011 -0500

    USB: make the usbfs memory limit configurable
    
    The 16-MB global limit on memory used by usbfs isn't suitable for all
    people.  It's a reasonable default, but there are applications
    (especially for SuperSpeed devices) that need a lot more.
    
    This patch (as1498) creates a writable module parameter for usbcore to
    control the global limit.  The default is still 16 MB, but users can
    change it at runtime, even after usbcore has been loaded.  As a
    special case, setting the value to 0 is treated the same as the hard
    limit of 2047 MB.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt
index a0c5c5f4fce6..72c68bbec5d4 100644
--- a/Documentation/kernel-parameters.txt
+++ b/Documentation/kernel-parameters.txt
@@ -2632,6 +2632,10 @@ bytes respectively. Such letter suffixes can also be entirely omitted.
 			[USB] Start with the old device initialization
 			scheme (default 0 = off).
 
+	usbcore.usbfs_memory_mb=
+			[USB] Memory limit (in MB) for buffers allocated by
+			usbfs (default = 16, 0 = max = 2047).
+
 	usbcore.use_both_schemes=
 			[USB] Try the other device initialization scheme
 			if the first one fails (default 1 = enabled).
diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index b69768b7d226..d8cf06f186f2 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -110,15 +110,33 @@ enum snoop_when {
 #define USB_DEVICE_DEV		MKDEV(USB_DEVICE_MAJOR, 0)
 
 /* Limit on the total amount of memory we can allocate for transfers */
-#define MAX_USBFS_MEMORY_USAGE	16777216	/* 16 MB */
+static unsigned usbfs_memory_mb = 16;
+module_param(usbfs_memory_mb, uint, 0644);
+MODULE_PARM_DESC(usbfs_memory_mb,
+		"maximum MB allowed for usbfs buffers (0 = no limit)");
+
+/* Hard limit, necessary to avoid aithmetic overflow */
+#define USBFS_XFER_MAX		(UINT_MAX / 2 - 1000000)
 
 static atomic_t usbfs_memory_usage;	/* Total memory currently allocated */
 
 /* Check whether it's okay to allocate more memory for a transfer */
 static int usbfs_increase_memory_usage(unsigned amount)
 {
+	unsigned lim;
+
+	/*
+	 * Convert usbfs_memory_mb to bytes, avoiding overflows.
+	 * 0 means use the hard limit (effectively unlimited).
+	 */
+	lim = ACCESS_ONCE(usbfs_memory_mb);
+	if (lim == 0 || lim &gt; (USBFS_XFER_MAX &gt;&gt; 20))
+		lim = USBFS_XFER_MAX;
+	else
+		lim &lt;&lt;= 20;
+
 	atomic_add(amount, &amp;usbfs_memory_usage);
-	if (atomic_read(&amp;usbfs_memory_usage) &lt;= MAX_USBFS_MEMORY_USAGE)
+	if (atomic_read(&amp;usbfs_memory_usage) &lt;= lim)
 		return 0;
 	atomic_sub(amount, &amp;usbfs_memory_usage);
 	return -ENOMEM;
@@ -907,7 +925,7 @@ static int proc_bulk(struct dev_state *ps, void __user *arg)
 	if (!usb_maxpacket(dev, pipe, !(bulk.ep &amp; USB_DIR_IN)))
 		return -EINVAL;
 	len1 = bulk.len;
-	if (len1 &gt; MAX_USBFS_MEMORY_USAGE)
+	if (len1 &gt;= USBFS_XFER_MAX)
 		return -EINVAL;
 	ret = usbfs_increase_memory_usage(len1 + sizeof(struct urb));
 	if (ret)
@@ -1227,7 +1245,7 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 		return -EINVAL;
 	}
 
-	if (uurb-&gt;buffer_length &gt; MAX_USBFS_MEMORY_USAGE) {
+	if (uurb-&gt;buffer_length &gt;= USBFS_XFER_MAX) {
 		ret = -EINVAL;
 		goto error;
 	}</pre><hr><pre>commit add1aaeabe6b08ed26381a2a06e505b2f09c3ba5
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Nov 17 16:41:25 2011 -0500

    USB: change the memory limits in usbfs URB submission
    
    For a long time people have complained about the limitations imposed
    by usbfs.  URBs coming from userspace are not allowed to have transfer
    buffers larger than a more-or-less arbitrary maximum.
    
    While it is generally a good idea to avoid large transfer buffers
    (because the data has to be bounced to/from a contiguous kernel-space
    buffer), it's not the kernel's job to enforce such limits.  Programs
    should be allowed to submit URBs as large as they like; if there isn't
    sufficient contiguous memory available then the submission will fail
    with a simple ENOMEM error.
    
    On the other hand, we would like to prevent programs from submitting a
    lot of small URBs and using up all the DMA-able kernel memory.  To
    that end, this patch (as1497) replaces the old limits on individual
    transfer buffers with a single global limit on the total amount of
    memory in use by usbfs.  The global limit is set to 16 MB as a nice
    compromise value: not too big, but large enough to hold about 300 ms
    of data for high-speed transfers.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index e8ade68f64e2..b69768b7d226 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -86,6 +86,7 @@ struct async {
 	void __user *userbuffer;
 	void __user *userurb;
 	struct urb *urb;
+	unsigned int mem_usage;
 	int status;
 	u32 secid;
 	u8 bulk_addr;
@@ -108,8 +109,26 @@ enum snoop_when {
 
 #define USB_DEVICE_DEV		MKDEV(USB_DEVICE_MAJOR, 0)
 
-#define	MAX_USBFS_BUFFER_SIZE	16384
+/* Limit on the total amount of memory we can allocate for transfers */
+#define MAX_USBFS_MEMORY_USAGE	16777216	/* 16 MB */
 
+static atomic_t usbfs_memory_usage;	/* Total memory currently allocated */
+
+/* Check whether it's okay to allocate more memory for a transfer */
+static int usbfs_increase_memory_usage(unsigned amount)
+{
+	atomic_add(amount, &amp;usbfs_memory_usage);
+	if (atomic_read(&amp;usbfs_memory_usage) &lt;= MAX_USBFS_MEMORY_USAGE)
+		return 0;
+	atomic_sub(amount, &amp;usbfs_memory_usage);
+	return -ENOMEM;
+}
+
+/* Memory for a transfer is being deallocated */
+static void usbfs_decrease_memory_usage(unsigned amount)
+{
+	atomic_sub(amount, &amp;usbfs_memory_usage);
+}
 
 static int connected(struct dev_state *ps)
 {
@@ -253,6 +272,7 @@ static void free_async(struct async *as)
 	kfree(as-&gt;urb-&gt;transfer_buffer);
 	kfree(as-&gt;urb-&gt;setup_packet);
 	usb_free_urb(as-&gt;urb);
+	usbfs_decrease_memory_usage(as-&gt;mem_usage);
 	kfree(as);
 }
 
@@ -792,9 +812,15 @@ static int proc_control(struct dev_state *ps, void __user *arg)
 	wLength = ctrl.wLength;		/* To suppress 64k PAGE_SIZE warning */
 	if (wLength &gt; PAGE_SIZE)
 		return -EINVAL;
+	ret = usbfs_increase_memory_usage(PAGE_SIZE + sizeof(struct urb) +
+			sizeof(struct usb_ctrlrequest));
+	if (ret)
+		return ret;
 	tbuf = (unsigned char *)__get_free_page(GFP_KERNEL);
-	if (!tbuf)
-		return -ENOMEM;
+	if (!tbuf) {
+		ret = -ENOMEM;
+		goto done;
+	}
 	tmo = ctrl.timeout;
 	snoop(&amp;dev-&gt;dev, "control urb: bRequestType=%02x "
 		"bRequest=%02x wValue=%04x "
@@ -852,6 +878,8 @@ static int proc_control(struct dev_state *ps, void __user *arg)
 	ret = i;
  done:
 	free_page((unsigned long) tbuf);
+	usbfs_decrease_memory_usage(PAGE_SIZE + sizeof(struct urb) +
+			sizeof(struct usb_ctrlrequest));
 	return ret;
 }
 
@@ -879,10 +907,15 @@ static int proc_bulk(struct dev_state *ps, void __user *arg)
 	if (!usb_maxpacket(dev, pipe, !(bulk.ep &amp; USB_DIR_IN)))
 		return -EINVAL;
 	len1 = bulk.len;
-	if (len1 &gt; MAX_USBFS_BUFFER_SIZE)
+	if (len1 &gt; MAX_USBFS_MEMORY_USAGE)
 		return -EINVAL;
-	if (!(tbuf = kmalloc(len1, GFP_KERNEL)))
-		return -ENOMEM;
+	ret = usbfs_increase_memory_usage(len1 + sizeof(struct urb));
+	if (ret)
+		return ret;
+	if (!(tbuf = kmalloc(len1, GFP_KERNEL))) {
+		ret = -ENOMEM;
+		goto done;
+	}
 	tmo = bulk.timeout;
 	if (bulk.ep &amp; 0x80) {
 		if (len1 &amp;&amp; !access_ok(VERIFY_WRITE, bulk.data, len1)) {
@@ -919,6 +952,7 @@ static int proc_bulk(struct dev_state *ps, void __user *arg)
 	ret = (i &lt; 0 ? i : len2);
  done:
 	kfree(tbuf);
+	usbfs_decrease_memory_usage(len1 + sizeof(struct urb));
 	return ret;
 }
 
@@ -1097,14 +1131,14 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 	}
 	if (!ep)
 		return -ENOENT;
+
+	u = 0;
 	switch(uurb-&gt;type) {
 	case USBDEVFS_URB_TYPE_CONTROL:
 		if (!usb_endpoint_xfer_control(&amp;ep-&gt;desc))
 			return -EINVAL;
-		/* min 8 byte setup packet,
-		 * max 8 byte setup plus an arbitrary data stage */
-		if (uurb-&gt;buffer_length &lt; 8 ||
-		    uurb-&gt;buffer_length &gt; (8 + MAX_USBFS_BUFFER_SIZE))
+		/* min 8 byte setup packet */
+		if (uurb-&gt;buffer_length &lt; 8)
 			return -EINVAL;
 		dr = kmalloc(sizeof(struct usb_ctrlrequest), GFP_KERNEL);
 		if (!dr)
@@ -1138,6 +1172,7 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 			__le16_to_cpup(&amp;dr-&gt;wValue),
 			__le16_to_cpup(&amp;dr-&gt;wIndex),
 			__le16_to_cpup(&amp;dr-&gt;wLength));
+		u = sizeof(struct usb_ctrlrequest);
 		break;
 
 	case USBDEVFS_URB_TYPE_BULK:
@@ -1151,8 +1186,6 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 			goto interrupt_urb;
 		}
 		uurb-&gt;number_of_packets = 0;
-		if (uurb-&gt;buffer_length &gt; MAX_USBFS_BUFFER_SIZE)
-			return -EINVAL;
 		break;
 
 	case USBDEVFS_URB_TYPE_INTERRUPT:
@@ -1160,8 +1193,6 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 			return -EINVAL;
  interrupt_urb:
 		uurb-&gt;number_of_packets = 0;
-		if (uurb-&gt;buffer_length &gt; MAX_USBFS_BUFFER_SIZE)
-			return -EINVAL;
 		break;
 
 	case USBDEVFS_URB_TYPE_ISO:
@@ -1188,17 +1219,18 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 			}
 			totlen += isopkt[u].length;
 		}
-		/* 3072 * 64 microframes */
-		if (totlen &gt; 196608) {
-			ret = -EINVAL;
-			goto error;
-		}
+		u *= sizeof(struct usb_iso_packet_descriptor);
 		uurb-&gt;buffer_length = totlen;
 		break;
 
 	default:
 		return -EINVAL;
 	}
+
+	if (uurb-&gt;buffer_length &gt; MAX_USBFS_MEMORY_USAGE) {
+		ret = -EINVAL;
+		goto error;
+	}
 	if (uurb-&gt;buffer_length &gt; 0 &amp;&amp;
 			!access_ok(is_in ? VERIFY_WRITE : VERIFY_READ,
 				uurb-&gt;buffer, uurb-&gt;buffer_length)) {
@@ -1210,6 +1242,12 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 		ret = -ENOMEM;
 		goto error;
 	}
+	u += sizeof(struct async) + sizeof(struct urb) + uurb-&gt;buffer_length;
+	ret = usbfs_increase_memory_usage(u);
+	if (ret)
+		goto error;
+	as-&gt;mem_usage = u;
+
 	if (uurb-&gt;buffer_length &gt; 0) {
 		as-&gt;urb-&gt;transfer_buffer = kmalloc(uurb-&gt;buffer_length,
 				GFP_KERNEL);</pre><hr><pre>commit 52fb743d3aa7ee27a4f3182816aa02dc3e513d9d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Nov 17 16:41:14 2011 -0500

    USB: unify some error pathways in usbfs
    
    This patch (as1496) unifies the error-return pathways of several
    functions in the usbfs driver.  This is not a very important change by
    itself; it merely prepares the way for the next patch in this series.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index e3beaf229ee3..e8ade68f64e2 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -806,8 +806,8 @@ static int proc_control(struct dev_state *ps, void __user *arg)
 	if (ctrl.bRequestType &amp; 0x80) {
 		if (ctrl.wLength &amp;&amp; !access_ok(VERIFY_WRITE, ctrl.data,
 					       ctrl.wLength)) {
-			free_page((unsigned long)tbuf);
-			return -EINVAL;
+			ret = -EINVAL;
+			goto done;
 		}
 		pipe = usb_rcvctrlpipe(dev, 0);
 		snoop_urb(dev, NULL, pipe, ctrl.wLength, tmo, SUBMIT, NULL, 0);
@@ -821,15 +821,15 @@ static int proc_control(struct dev_state *ps, void __user *arg)
 			  tbuf, max(i, 0));
 		if ((i &gt; 0) &amp;&amp; ctrl.wLength) {
 			if (copy_to_user(ctrl.data, tbuf, i)) {
-				free_page((unsigned long)tbuf);
-				return -EFAULT;
+				ret = -EFAULT;
+				goto done;
 			}
 		}
 	} else {
 		if (ctrl.wLength) {
 			if (copy_from_user(tbuf, ctrl.data, ctrl.wLength)) {
-				free_page((unsigned long)tbuf);
-				return -EFAULT;
+				ret = -EFAULT;
+				goto done;
 			}
 		}
 		pipe = usb_sndctrlpipe(dev, 0);
@@ -843,14 +843,16 @@ static int proc_control(struct dev_state *ps, void __user *arg)
 		usb_lock_device(dev);
 		snoop_urb(dev, NULL, pipe, max(i, 0), min(i, 0), COMPLETE, NULL, 0);
 	}
-	free_page((unsigned long)tbuf);
 	if (i &lt; 0 &amp;&amp; i != -EPIPE) {
 		dev_printk(KERN_DEBUG, &amp;dev-&gt;dev, "usbfs: USBDEVFS_CONTROL "
 			   "failed cmd %s rqt %u rq %u len %u ret %d\n",
 			   current-&gt;comm, ctrl.bRequestType, ctrl.bRequest,
 			   ctrl.wLength, i);
 	}
-	return i;
+	ret = i;
+ done:
+	free_page((unsigned long) tbuf);
+	return ret;
 }
 
 static int proc_bulk(struct dev_state *ps, void __user *arg)
@@ -884,8 +886,8 @@ static int proc_bulk(struct dev_state *ps, void __user *arg)
 	tmo = bulk.timeout;
 	if (bulk.ep &amp; 0x80) {
 		if (len1 &amp;&amp; !access_ok(VERIFY_WRITE, bulk.data, len1)) {
-			kfree(tbuf);
-			return -EINVAL;
+			ret = -EINVAL;
+			goto done;
 		}
 		snoop_urb(dev, NULL, pipe, len1, tmo, SUBMIT, NULL, 0);
 
@@ -896,15 +898,15 @@ static int proc_bulk(struct dev_state *ps, void __user *arg)
 
 		if (!i &amp;&amp; len2) {
 			if (copy_to_user(bulk.data, tbuf, len2)) {
-				kfree(tbuf);
-				return -EFAULT;
+				ret = -EFAULT;
+				goto done;
 			}
 		}
 	} else {
 		if (len1) {
 			if (copy_from_user(tbuf, bulk.data, len1)) {
-				kfree(tbuf);
-				return -EFAULT;
+				ret = -EFAULT;
+				goto done;
 			}
 		}
 		snoop_urb(dev, NULL, pipe, len1, tmo, SUBMIT, tbuf, len1);
@@ -914,10 +916,10 @@ static int proc_bulk(struct dev_state *ps, void __user *arg)
 		usb_lock_device(dev);
 		snoop_urb(dev, NULL, pipe, len2, i, COMPLETE, NULL, 0);
 	}
+	ret = (i &lt; 0 ? i : len2);
+ done:
 	kfree(tbuf);
-	if (i &lt; 0)
-		return i;
-	return len2;
+	return ret;
 }
 
 static int proc_resetep(struct dev_state *ps, void __user *arg)
@@ -1062,7 +1064,7 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 {
 	struct usbdevfs_iso_packet_desc *isopkt = NULL;
 	struct usb_host_endpoint *ep;
-	struct async *as;
+	struct async *as = NULL;
 	struct usb_ctrlrequest *dr = NULL;
 	unsigned int u, totlen, isofrmlen;
 	int ret, ifnum = -1;
@@ -1108,19 +1110,17 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 		if (!dr)
 			return -ENOMEM;
 		if (copy_from_user(dr, uurb-&gt;buffer, 8)) {
-			kfree(dr);
-			return -EFAULT;
+			ret = -EFAULT;
+			goto error;
 		}
 		if (uurb-&gt;buffer_length &lt; (le16_to_cpup(&amp;dr-&gt;wLength) + 8)) {
-			kfree(dr);
-			return -EINVAL;
+			ret = -EINVAL;
+			goto error;
 		}
 		ret = check_ctrlrecip(ps, dr-&gt;bRequestType, dr-&gt;bRequest,
 				      le16_to_cpup(&amp;dr-&gt;wIndex));
-		if (ret) {
-			kfree(dr);
-			return ret;
-		}
+		if (ret)
+			goto error;
 		uurb-&gt;number_of_packets = 0;
 		uurb-&gt;buffer_length = le16_to_cpup(&amp;dr-&gt;wLength);
 		uurb-&gt;buffer += 8;
@@ -1176,22 +1176,22 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 		if (!(isopkt = kmalloc(isofrmlen, GFP_KERNEL)))
 			return -ENOMEM;
 		if (copy_from_user(isopkt, iso_frame_desc, isofrmlen)) {
-			kfree(isopkt);
-			return -EFAULT;
+			ret = -EFAULT;
+			goto error;
 		}
 		for (totlen = u = 0; u &lt; uurb-&gt;number_of_packets; u++) {
 			/* arbitrary limit,
 			 * sufficient for USB 2.0 high-bandwidth iso */
 			if (isopkt[u].length &gt; 8192) {
-				kfree(isopkt);
-				return -EINVAL;
+				ret = -EINVAL;
+				goto error;
 			}
 			totlen += isopkt[u].length;
 		}
 		/* 3072 * 64 microframes */
 		if (totlen &gt; 196608) {
-			kfree(isopkt);
-			return -EINVAL;
+			ret = -EINVAL;
+			goto error;
 		}
 		uurb-&gt;buffer_length = totlen;
 		break;
@@ -1202,24 +1202,20 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 	if (uurb-&gt;buffer_length &gt; 0 &amp;&amp;
 			!access_ok(is_in ? VERIFY_WRITE : VERIFY_READ,
 				uurb-&gt;buffer, uurb-&gt;buffer_length)) {
-		kfree(isopkt);
-		kfree(dr);
-		return -EFAULT;
+		ret = -EFAULT;
+		goto error;
 	}
 	as = alloc_async(uurb-&gt;number_of_packets);
 	if (!as) {
-		kfree(isopkt);
-		kfree(dr);
-		return -ENOMEM;
+		ret = -ENOMEM;
+		goto error;
 	}
 	if (uurb-&gt;buffer_length &gt; 0) {
 		as-&gt;urb-&gt;transfer_buffer = kmalloc(uurb-&gt;buffer_length,
 				GFP_KERNEL);
 		if (!as-&gt;urb-&gt;transfer_buffer) {
-			kfree(isopkt);
-			kfree(dr);
-			free_async(as);
-			return -ENOMEM;
+			ret = -ENOMEM;
+			goto error;
 		}
 		/* Isochronous input data may end up being discontiguous
 		 * if some of the packets are short.  Clear the buffer so
@@ -1253,6 +1249,7 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 
 	as-&gt;urb-&gt;transfer_buffer_length = uurb-&gt;buffer_length;
 	as-&gt;urb-&gt;setup_packet = (unsigned char *)dr;
+	dr = NULL;
 	as-&gt;urb-&gt;start_frame = uurb-&gt;start_frame;
 	as-&gt;urb-&gt;number_of_packets = uurb-&gt;number_of_packets;
 	if (uurb-&gt;type == USBDEVFS_URB_TYPE_ISO ||
@@ -1268,6 +1265,7 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 		totlen += isopkt[u].length;
 	}
 	kfree(isopkt);
+	isopkt = NULL;
 	as-&gt;ps = ps;
 	as-&gt;userurb = arg;
 	if (is_in &amp;&amp; uurb-&gt;buffer_length &gt; 0)
@@ -1282,8 +1280,8 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 	if (!is_in &amp;&amp; uurb-&gt;buffer_length &gt; 0) {
 		if (copy_from_user(as-&gt;urb-&gt;transfer_buffer, uurb-&gt;buffer,
 				uurb-&gt;buffer_length)) {
-			free_async(as);
-			return -EFAULT;
+			ret = -EFAULT;
+			goto error;
 		}
 	}
 	snoop_urb(ps-&gt;dev, as-&gt;userurb, as-&gt;urb-&gt;pipe,
@@ -1329,10 +1327,16 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 		snoop_urb(ps-&gt;dev, as-&gt;userurb, as-&gt;urb-&gt;pipe,
 				0, ret, COMPLETE, NULL, 0);
 		async_removepending(as);
-		free_async(as);
-		return ret;
+		goto error;
 	}
 	return 0;
+
+ error:
+	kfree(isopkt);
+	kfree(dr);
+	if (as)
+		free_async(as);
+	return ret;
 }
 
 static int proc_submiturb(struct dev_state *ps, void __user *arg)</pre>
    <div class="pagination">
        <a href='2_52.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><span>[53]</span><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_54.html'>Next&gt;&gt;</a>
    <div>
</body>
