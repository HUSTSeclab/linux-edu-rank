<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_89.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><span>[90]</span><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_91.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit d64aac36394b3c26db53538bfedd8444a3a2206e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jun 24 14:47:19 2008 -0400

    usbfs: fix race between open and unregister
    
    This patch (as1106) fixes a race between opening and unregistering
    device files in usbfs.  The current code drops its reference to the
    device and then reacquires it, ignoring the possibility that the
    device structure might have been removed in the meantime.  It also
    doesn't check whether the device is already in the NOTATTACHED state
    when the file is opened.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 57bedcebf96c..c44e98f6099e 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -562,7 +562,6 @@ static struct usb_device *usbdev_lookup_by_devt(dev_t devt)
 	dev = bus_find_device(&amp;usb_bus_type, NULL, (void *) devt, match_devt);
 	if (!dev)
 		return NULL;
-	put_device(dev);
 	return container_of(dev, struct usb_device, dev);
 }
 
@@ -591,16 +590,21 @@ static int usbdev_open(struct inode *inode, struct file *file)
 		dev = usbdev_lookup_by_devt(inode-&gt;i_rdev);
 #ifdef CONFIG_USB_DEVICEFS
 	/* procfs file */
-	if (!dev)
+	if (!dev) {
 		dev = inode-&gt;i_private;
+		if (dev &amp;&amp; dev-&gt;usbfs_dentry &amp;&amp;
+					dev-&gt;usbfs_dentry-&gt;d_inode == inode)
+			usb_get_dev(dev);
+		else
+			dev = NULL;
+	}
 #endif
-	if (!dev)
+	if (!dev || dev-&gt;state == USB_STATE_NOTATTACHED)
 		goto out;
 	ret = usb_autoresume_device(dev);
 	if (ret)
 		goto out;
 
-	usb_get_dev(dev);
 	ret = 0;
 	ps-&gt;dev = dev;
 	ps-&gt;file = file;
@@ -620,8 +624,10 @@ static int usbdev_open(struct inode *inode, struct file *file)
 	list_add_tail(&amp;ps-&gt;list, &amp;dev-&gt;filelist);
 	file-&gt;private_data = ps;
  out:
-	if (ret)
+	if (ret) {
 		kfree(ps);
+		usb_put_dev(dev);
+	}
 	mutex_unlock(&amp;usbfs_mutex);
 	unlock_kernel();
 	return ret;</pre><hr><pre>commit 61ad04a89f0e3e6adaed0d9adfc0c9b431ccbb92
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jun 24 14:47:12 2008 -0400

    usbfs: simplify the lookup-by-minor routines
    
    This patch (as1105) simplifies the lookup-by-minor-number code in
    usbfs.  Instead of passing the minor number to the callback, which
    must then reconstruct the entire dev_t value, the patch passes the
    dev_t value directly.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index bbd029f68faa..57bedcebf96c 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -550,20 +550,16 @@ static int check_ctrlrecip(struct dev_state *ps, unsigned int requesttype,
 	return ret;
 }
 
-static int __match_minor(struct device *dev, void *data)
+static int match_devt(struct device *dev, void *data)
 {
-	int minor = *((int *)data);
-
-	if (dev-&gt;devt == MKDEV(USB_DEVICE_MAJOR, minor))
-		return 1;
-	return 0;
+	return (dev-&gt;devt == (dev_t) data);
 }
 
-static struct usb_device *usbdev_lookup_by_minor(int minor)
+static struct usb_device *usbdev_lookup_by_devt(dev_t devt)
 {
 	struct device *dev;
 
-	dev = bus_find_device(&amp;usb_bus_type, NULL, &amp;minor, __match_minor);
+	dev = bus_find_device(&amp;usb_bus_type, NULL, (void *) devt, match_devt);
 	if (!dev)
 		return NULL;
 	put_device(dev);
@@ -589,9 +585,10 @@ static int usbdev_open(struct inode *inode, struct file *file)
 		goto out;
 
 	ret = -ENOENT;
+
 	/* usbdev device-node */
 	if (imajor(inode) == USB_DEVICE_MAJOR)
-		dev = usbdev_lookup_by_minor(iminor(inode));
+		dev = usbdev_lookup_by_devt(inode-&gt;i_rdev);
 #ifdef CONFIG_USB_DEVICEFS
 	/* procfs file */
 	if (!dev)</pre><hr><pre>commit cd9f03759d3eb588e185b04e1854c778b050833e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jun 24 14:47:04 2008 -0400

    usbfs: send disconnect signals when device is unregistered
    
    USB device files are accessible in two ways: as files in usbfs and as
    character device nodes.  The two paths are supposed to behave
    identically, but they don't.  When the underlying USB device is
    unplugged, disconnect signals are sent to processes with open usbfs
    files (if they requested these signals) but not to processes with open
    device node files.
    
    This patch (as1104) fixes the bug by moving the disconnect-signalling
    code into a common subroutine which is called from both paths.
    Putting this subroutine in devio.c removes the only out-of-file
    reference to struct dev_state, and so the structure's declaration can
    be moved from usb.h into devio.c.
    
    Finally, the new subroutine performs one extra action: It kills all
    the outstanding async URBs.  (I'd kill the outstanding synchronous
    URBs too, if there was any way to do it.)  In the past this hasn't
    mattered much, because devices were unregistered from usbfs only
    when they were disconnected.  But now the unregistration can also
    occur whenever devices are unbound from the usb_generic driver.  At
    any rate, killing URBs when a device is unregistered from usbfs seems
    like a good thing to do.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index e09935acae80..bbd029f68faa 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -59,6 +59,22 @@
 /* Mutual exclusion for removal, open, and release */
 DEFINE_MUTEX(usbfs_mutex);
 
+struct dev_state {
+	struct list_head list;      /* state list */
+	struct usb_device *dev;
+	struct file *file;
+	spinlock_t lock;            /* protects the async urb lists */
+	struct list_head async_pending;
+	struct list_head async_completed;
+	wait_queue_head_t wait;     /* wake up if a request completed */
+	unsigned int discsignr;
+	struct pid *disc_pid;
+	uid_t disc_uid, disc_euid;
+	void __user *disccontext;
+	unsigned long ifclaimed;
+	u32 secid;
+};
+
 struct async {
 	struct list_head asynclist;
 	struct dev_state *ps;
@@ -1680,6 +1696,28 @@ const struct file_operations usbdev_file_operations = {
 	.release =	usbdev_release,
 };
 
+void usb_fs_classdev_common_remove(struct usb_device *udev)
+{
+	struct dev_state *ps;
+	struct siginfo sinfo;
+
+	while (!list_empty(&amp;udev-&gt;filelist)) {
+		ps = list_entry(udev-&gt;filelist.next, struct dev_state, list);
+		destroy_all_async(ps);
+		wake_up_all(&amp;ps-&gt;wait);
+		list_del_init(&amp;ps-&gt;list);
+		if (ps-&gt;discsignr) {
+			sinfo.si_signo = ps-&gt;discsignr;
+			sinfo.si_errno = EPIPE;
+			sinfo.si_code = SI_ASYNCIO;
+			sinfo.si_addr = ps-&gt;disccontext;
+			kill_pid_info_as_uid(ps-&gt;discsignr, &amp;sinfo,
+					ps-&gt;disc_pid, ps-&gt;disc_uid,
+					ps-&gt;disc_euid, ps-&gt;secid);
+		}
+	}
+}
+
 #ifdef CONFIG_USB_DEVICE_CLASS
 static struct class *usb_classdev_class;
 
@@ -1699,6 +1737,7 @@ static int usb_classdev_add(struct usb_device *dev)
 static void usb_classdev_remove(struct usb_device *dev)
 {
 	device_unregister(dev-&gt;usb_classdev);
+	usb_fs_classdev_common_remove(dev);
 }
 
 static int usb_classdev_notify(struct notifier_block *self,
diff --git a/drivers/usb/core/inode.c b/drivers/usb/core/inode.c
index 1d253dd4ea81..db410e92c80d 100644
--- a/drivers/usb/core/inode.c
+++ b/drivers/usb/core/inode.c
@@ -712,25 +712,11 @@ static void usbfs_add_device(struct usb_device *dev)
 
 static void usbfs_remove_device(struct usb_device *dev)
 {
-	struct dev_state *ds;
-	struct siginfo sinfo;
-
 	if (dev-&gt;usbfs_dentry) {
 		fs_remove_file (dev-&gt;usbfs_dentry);
 		dev-&gt;usbfs_dentry = NULL;
 	}
-	while (!list_empty(&amp;dev-&gt;filelist)) {
-		ds = list_entry(dev-&gt;filelist.next, struct dev_state, list);
-		wake_up_all(&amp;ds-&gt;wait);
-		list_del_init(&amp;ds-&gt;list);
-		if (ds-&gt;discsignr) {
-			sinfo.si_signo = ds-&gt;discsignr;
-			sinfo.si_errno = EPIPE;
-			sinfo.si_code = SI_ASYNCIO;
-			sinfo.si_addr = ds-&gt;disccontext;
-			kill_pid_info_as_uid(ds-&gt;discsignr, &amp;sinfo, ds-&gt;disc_pid, ds-&gt;disc_uid, ds-&gt;disc_euid, ds-&gt;secid);
-		}
-	}
+	usb_fs_classdev_common_remove(dev);
 }
 
 static int usbfs_notify(struct notifier_block *self, unsigned long action, void *dev)
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index d3eb0a29bca1..d9a6e16dbf84 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -142,26 +142,11 @@ extern struct usb_driver usbfs_driver;
 extern const struct file_operations usbfs_devices_fops;
 extern const struct file_operations usbdev_file_operations;
 extern void usbfs_conn_disc_event(void);
+extern void usb_fs_classdev_common_remove(struct usb_device *udev);
 
 extern int usb_devio_init(void);
 extern void usb_devio_cleanup(void);
 
-struct dev_state {
-	struct list_head list;      /* state list */
-	struct usb_device *dev;
-	struct file *file;
-	spinlock_t lock;            /* protects the async urb lists */
-	struct list_head async_pending;
-	struct list_head async_completed;
-	wait_queue_head_t wait;     /* wake up if a request completed */
-	unsigned int discsignr;
-	struct pid *disc_pid;
-	uid_t disc_uid, disc_euid;
-	void __user *disccontext;
-	unsigned long ifclaimed;
-	u32 secid;
-};
-
 /* internal notify stuff */
 extern void usb_notify_add_device(struct usb_device *udev);
 extern void usb_notify_remove_device(struct usb_device *udev);</pre><hr><pre>commit 78d9a487ee961c356e1a934d9a92eca38ffb3a70
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jun 23 16:00:40 2008 -0400

    USB: Force unbinding of drivers lacking reset_resume or other methods
    
    This patch (as1024) takes care of a FIXME issue: Drivers that don't
    have the necessary suspend, resume, reset_resume, pre_reset, or
    post_reset methods will be unbound and their interface reprobed when
    one of the unsupported events occurs.
    
    This is made slightly more difficult by the fact that bind operations
    won't work during a system sleep transition.  So instead the code has
    to defer the operation until the transition ends.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 8da1a56659be..ddb54e14a5c5 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -201,6 +201,7 @@ static int usb_probe_interface(struct device *dev)
 
 	intf = to_usb_interface(dev);
 	udev = interface_to_usbdev(intf);
+	intf-&gt;needs_binding = 0;
 
 	if (udev-&gt;authorized == 0) {
 		dev_err(&amp;intf-&gt;dev, "Device is not authorized for usage\n");
@@ -311,6 +312,7 @@ int usb_driver_claim_interface(struct usb_driver *driver,
 
 	dev-&gt;driver = &amp;driver-&gt;drvwrap.driver;
 	usb_set_intfdata(iface, priv);
+	iface-&gt;needs_binding = 0;
 
 	usb_pm_lock(udev);
 	iface-&gt;condition = USB_INTERFACE_BOUND;
@@ -772,6 +774,104 @@ void usb_deregister(struct usb_driver *driver)
 }
 EXPORT_SYMBOL_GPL(usb_deregister);
 
+
+/* Forced unbinding of a USB interface driver, either because
+ * it doesn't support pre_reset/post_reset/reset_resume or
+ * because it doesn't support suspend/resume.
+ *
+ * The caller must hold @intf's device's lock, but not its pm_mutex
+ * and not @intf-&gt;dev.sem.
+ */
+void usb_forced_unbind_intf(struct usb_interface *intf)
+{
+	struct usb_driver *driver = to_usb_driver(intf-&gt;dev.driver);
+
+	dev_dbg(&amp;intf-&gt;dev, "forced unbind\n");
+	usb_driver_release_interface(driver, intf);
+
+	/* Mark the interface for later rebinding */
+	intf-&gt;needs_binding = 1;
+}
+
+/* Delayed forced unbinding of a USB interface driver and scan
+ * for rebinding.
+ *
+ * The caller must hold @intf's device's lock, but not its pm_mutex
+ * and not @intf-&gt;dev.sem.
+ *
+ * FIXME: The caller must block system sleep transitions.
+ */
+void usb_rebind_intf(struct usb_interface *intf)
+{
+	int rc;
+
+	/* Delayed unbind of an existing driver */
+	if (intf-&gt;dev.driver) {
+		struct usb_driver *driver =
+				to_usb_driver(intf-&gt;dev.driver);
+
+		dev_dbg(&amp;intf-&gt;dev, "forced unbind\n");
+		usb_driver_release_interface(driver, intf);
+	}
+
+	/* Try to rebind the interface */
+	intf-&gt;needs_binding = 0;
+	rc = device_attach(&amp;intf-&gt;dev);
+	if (rc &lt; 0)
+		dev_warn(&amp;intf-&gt;dev, "rebind failed: %d\n", rc);
+}
+
+#define DO_UNBIND	0
+#define DO_REBIND	1
+
+/* Unbind drivers for @udev's interfaces that don't support suspend/resume,
+ * or rebind interfaces that have been unbound, according to @action.
+ *
+ * The caller must hold @udev's device lock.
+ * FIXME: For rebinds, the caller must block system sleep transitions.
+ */
+static void do_unbind_rebind(struct usb_device *udev, int action)
+{
+	struct usb_host_config	*config;
+	int			i;
+	struct usb_interface	*intf;
+	struct usb_driver	*drv;
+
+	config = udev-&gt;actconfig;
+	if (config) {
+		for (i = 0; i &lt; config-&gt;desc.bNumInterfaces; ++i) {
+			intf = config-&gt;interface[i];
+			switch (action) {
+			case DO_UNBIND:
+				if (intf-&gt;dev.driver) {
+					drv = to_usb_driver(intf-&gt;dev.driver);
+					if (!drv-&gt;suspend || !drv-&gt;resume)
+						usb_forced_unbind_intf(intf);
+				}
+				break;
+			case DO_REBIND:
+				if (intf-&gt;needs_binding) {
+
+	/* FIXME: The next line is needed because we are going to probe
+	 * the interface, but as far as the PM core is concerned the
+	 * interface is still suspended.  The problem wouldn't exist
+	 * if we could rebind the interface during the interface's own
+	 * resume() call, but at the time the usb_device isn't locked!
+	 *
+	 * The real solution will be to carry this out during the device's
+	 * complete() callback.  Until that is implemented, we have to
+	 * use this hack.
+	 */
+//					intf-&gt;dev.power.sleeping = 0;
+
+					usb_rebind_intf(intf);
+				}
+				break;
+			}
+		}
+	}
+}
+
 #ifdef CONFIG_PM
 
 /* Caller has locked udev's pm_mutex */
@@ -841,7 +941,7 @@ static int usb_suspend_interface(struct usb_interface *intf, pm_message_t msg)
 		goto done;
 	driver = to_usb_driver(intf-&gt;dev.driver);
 
-	if (driver-&gt;suspend &amp;&amp; driver-&gt;resume) {
+	if (driver-&gt;suspend) {
 		status = driver-&gt;suspend(intf, msg);
 		if (status == 0)
 			mark_quiesced(intf);
@@ -849,12 +949,10 @@ static int usb_suspend_interface(struct usb_interface *intf, pm_message_t msg)
 			dev_err(&amp;intf-&gt;dev, "%s error %d\n",
 					"suspend", status);
 	} else {
-		/*
-		 * FIXME else if there's no suspend method, disconnect...
-		 * Not possible if auto_pm is set...
-		 */
-		dev_warn(&amp;intf-&gt;dev, "no suspend for driver %s?\n",
-				driver-&gt;name);
+		/* Later we will unbind the driver and reprobe */
+		intf-&gt;needs_binding = 1;
+		dev_warn(&amp;intf-&gt;dev, "no %s for driver %s?\n",
+				"suspend", driver-&gt;name);
 		mark_quiesced(intf);
 	}
 
@@ -878,10 +976,12 @@ static int usb_resume_interface(struct usb_interface *intf, int reset_resume)
 		goto done;
 
 	/* Can't resume it if it doesn't have a driver. */
-	if (intf-&gt;condition == USB_INTERFACE_UNBOUND) {
-		status = -ENOTCONN;
+	if (intf-&gt;condition == USB_INTERFACE_UNBOUND)
+		goto done;
+
+	/* Don't resume if the interface is marked for rebinding */
+	if (intf-&gt;needs_binding)
 		goto done;
-	}
 	driver = to_usb_driver(intf-&gt;dev.driver);
 
 	if (reset_resume) {
@@ -891,7 +991,7 @@ static int usb_resume_interface(struct usb_interface *intf, int reset_resume)
 				dev_err(&amp;intf-&gt;dev, "%s error %d\n",
 						"reset_resume", status);
 		} else {
-			/* status = -EOPNOTSUPP; */
+			intf-&gt;needs_binding = 1;
 			dev_warn(&amp;intf-&gt;dev, "no %s for driver %s?\n",
 					"reset_resume", driver-&gt;name);
 		}
@@ -902,7 +1002,7 @@ static int usb_resume_interface(struct usb_interface *intf, int reset_resume)
 				dev_err(&amp;intf-&gt;dev, "%s error %d\n",
 						"resume", status);
 		} else {
-			/* status = -EOPNOTSUPP; */
+			intf-&gt;needs_binding = 1;
 			dev_warn(&amp;intf-&gt;dev, "no %s for driver %s?\n",
 					"resume", driver-&gt;name);
 		}
@@ -910,11 +1010,10 @@ static int usb_resume_interface(struct usb_interface *intf, int reset_resume)
 
 done:
 	dev_vdbg(&amp;intf-&gt;dev, "%s: status %d\n", __func__, status);
-	if (status == 0)
+	if (status == 0 &amp;&amp; intf-&gt;condition == USB_INTERFACE_BOUND)
 		mark_active(intf);
 
-	/* FIXME: Unbind the driver and reprobe if the resume failed
-	 * (not possible if auto_pm is set) */
+	/* Later we will unbind the driver and/or reprobe, if necessary */
 	return status;
 }
 
@@ -1470,6 +1569,7 @@ int usb_external_suspend_device(struct usb_device *udev, pm_message_t msg)
 {
 	int	status;
 
+	do_unbind_rebind(udev, DO_UNBIND);
 	usb_pm_lock(udev);
 	udev-&gt;auto_pm = 0;
 	status = usb_suspend_both(udev, msg);
@@ -1497,6 +1597,7 @@ int usb_external_resume_device(struct usb_device *udev)
 	status = usb_resume_both(udev);
 	udev-&gt;last_busy = jiffies;
 	usb_pm_unlock(udev);
+	do_unbind_rebind(udev, DO_REBIND);
 
 	/* Now that the device is awake, we can start trying to autosuspend
 	 * it again. */
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index bb3ecc4c08f2..f1efabbc1ca2 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -3367,6 +3367,11 @@ static int usb_reset_and_verify_device(struct usb_device *udev)
  * this from a driver probe() routine after downloading new firmware.
  * For calls that might not occur during probe(), drivers should lock
  * the device using usb_lock_device_for_reset().
+ *
+ * If an interface is currently being probed or disconnected, we assume
+ * its driver knows how to handle resets.  For all other interfaces,
+ * if the driver doesn't have pre_reset and post_reset methods then
+ * we attempt to unbind it and rebind afterward.
  */
 int usb_reset_device(struct usb_device *udev)
 {
@@ -3388,12 +3393,17 @@ int usb_reset_device(struct usb_device *udev)
 		for (i = 0; i &lt; config-&gt;desc.bNumInterfaces; ++i) {
 			struct usb_interface *cintf = config-&gt;interface[i];
 			struct usb_driver *drv;
+			int unbind = 0;
 
 			if (cintf-&gt;dev.driver) {
 				drv = to_usb_driver(cintf-&gt;dev.driver);
-				if (drv-&gt;pre_reset)
-					(drv-&gt;pre_reset)(cintf);
-	/* FIXME: Unbind if pre_reset returns an error or isn't defined */
+				if (drv-&gt;pre_reset &amp;&amp; drv-&gt;post_reset)
+					unbind = (drv-&gt;pre_reset)(cintf);
+				else if (cintf-&gt;condition ==
+						USB_INTERFACE_BOUND)
+					unbind = 1;
+				if (unbind)
+					usb_forced_unbind_intf(cintf);
 			}
 		}
 	}
@@ -3404,13 +3414,18 @@ int usb_reset_device(struct usb_device *udev)
 		for (i = config-&gt;desc.bNumInterfaces - 1; i &gt;= 0; --i) {
 			struct usb_interface *cintf = config-&gt;interface[i];
 			struct usb_driver *drv;
+			int rebind = cintf-&gt;needs_binding;
 
-			if (cintf-&gt;dev.driver) {
+			if (!rebind &amp;&amp; cintf-&gt;dev.driver) {
 				drv = to_usb_driver(cintf-&gt;dev.driver);
 				if (drv-&gt;post_reset)
-					(drv-&gt;post_reset)(cintf);
-	/* FIXME: Unbind if post_reset returns an error or isn't defined */
+					rebind = (drv-&gt;post_reset)(cintf);
+				else if (cintf-&gt;condition ==
+						USB_INTERFACE_BOUND)
+					rebind = 1;
 			}
+			if (rebind)
+				usb_rebind_intf(cintf);
 		}
 	}
 
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 1a8bc21c335e..d3eb0a29bca1 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -29,6 +29,8 @@ extern int usb_choose_configuration(struct usb_device *udev);
 extern void usb_kick_khubd(struct usb_device *dev);
 extern int usb_match_device(struct usb_device *dev,
 			    const struct usb_device_id *id);
+extern void usb_forced_unbind_intf(struct usb_interface *intf);
+extern void usb_rebind_intf(struct usb_interface *intf);
 
 extern int  usb_hub_init(void);
 extern void usb_hub_cleanup(void);
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 3cc8db5254d1..5811c5da69f9 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -160,6 +160,7 @@ struct usb_interface {
 	unsigned is_active:1;		/* the interface is not suspended */
 	unsigned sysfs_files_created:1;	/* the sysfs attributes exist */
 	unsigned needs_remote_wakeup:1;	/* driver requires remote wakeup */
+	unsigned needs_binding:1;	/* needs delayed unbind/rebind */
 
 	struct device dev;		/* interface specific device info */
 	struct device *usb_dev;</pre><hr><pre>commit 7c3e28bc56bd2e4310dc0af99f2b95eeda9a2ff7
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jun 16 12:11:39 2008 -0400

    USB: use standard SG iterator in the scatter-gather library
    
    This patch (as1103) changes the iteration in the USB scatter-gather to
    use a standard SG iterator.  Otherwise the iteration will fail if it
    encounters a chained SG list.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Jens Axboe &lt;jens.axboe@oracle.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 315363b744a3..08af1083ebfc 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -400,7 +400,7 @@ int usb_sg_init(struct usb_sg_request *io, struct usb_device *dev,
 	if (usb_pipein(pipe))
 		urb_flags |= URB_SHORT_NOT_OK;
 
-	for (i = 0; i &lt; io-&gt;entries; i++) {
+	for_each_sg(sg, sg, io-&gt;entries, i) {
 		unsigned len;
 
 		io-&gt;urbs[i] = usb_alloc_urb(0, mem_flags);
@@ -434,17 +434,17 @@ int usb_sg_init(struct usb_sg_request *io, struct usb_device *dev,
 		 * to prevent stale pointers and to help spot bugs.
 		 */
 		if (dma) {
-			io-&gt;urbs[i]-&gt;transfer_dma = sg_dma_address(sg + i);
-			len = sg_dma_len(sg + i);
+			io-&gt;urbs[i]-&gt;transfer_dma = sg_dma_address(sg);
+			len = sg_dma_len(sg);
 #if defined(CONFIG_HIGHMEM) || defined(CONFIG_GART_IOMMU)
 			io-&gt;urbs[i]-&gt;transfer_buffer = NULL;
 #else
-			io-&gt;urbs[i]-&gt;transfer_buffer = sg_virt(&amp;sg[i]);
+			io-&gt;urbs[i]-&gt;transfer_buffer = sg_virt(sg);
 #endif
 		} else {
 			/* hc may use _only_ transfer_buffer */
-			io-&gt;urbs[i]-&gt;transfer_buffer = sg_virt(&amp;sg[i]);
-			len = sg[i].length;
+			io-&gt;urbs[i]-&gt;transfer_buffer = sg_virt(sg);
+			len = sg-&gt;length;
 		}
 
 		if (length) {</pre><hr><pre>commit f579c2b46f74038e8f5a762c7f10c2385b33e3dc
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jun 2 16:26:48 2008 -0400

    USB Gadget: documentation update
    
    This patch (as1102) clarifies two points in the USB Gadget kerneldoc:
    
            Request completion callbacks are always made with interrupts
            disabled;
    
            Device controllers may not support STALLing the status stage
            of a control transfer after the data stage is over.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: David Brownell &lt;dbrownell@users.sourceforge.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/include/linux/usb/gadget.h b/include/linux/usb/gadget.h
index 0ebedaec075d..0460a746480c 100644
--- a/include/linux/usb/gadget.h
+++ b/include/linux/usb/gadget.h
@@ -33,7 +33,8 @@ struct usb_ep;
  * @short_not_ok: When reading data, makes short packets be
  *     treated as errors (queue stops advancing till cleanup).
  * @complete: Function called when request completes, so this request and
- *	its buffer may be re-used.
+ *	its buffer may be re-used.  The function will always be called with
+ *	interrupts disabled, and it must not sleep.
  *	Reads terminate with a short packet, or when the buffer fills,
  *	whichever comes first.  When writes terminate, some data bytes
  *	will usually still be in flight (often in a hardware fifo).
@@ -271,7 +272,10 @@ static inline void usb_ep_free_request(struct usb_ep *ep,
  * (Note that some USB device controllers disallow protocol stall responses
  * in some cases.)  When control responses are deferred (the response is
  * written after the setup callback returns), then usb_ep_set_halt() may be
- * used on ep0 to trigger protocol stalls.
+ * used on ep0 to trigger protocol stalls.  Depending on the controller,
+ * it may not be possible to trigger a status-stage protocol stall when the
+ * data stage is over, that is, from within the response's completion
+ * routine.
  *
  * For periodic endpoints, like interrupt or isochronous ones, the usb host
  * arranges to poll once per interval, and the gadget driver usually will</pre><hr><pre>commit 543f7810fba2a62e412efa9473ad08167b691f09
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu May 8 11:55:59 2008 -0400

    usb-storage: implement "soft" unbinding
    
    This patch (as1092) implements "soft" unbinding for usb-storage.  When
    the disconnect routine is called, all commands and reset delays are
    allowed to complete normally until after scsi_remove_host() returns.
    This means that the commands needed for an orderly shutdown will be
    sent through to the device.
    
    Unlike before, the driver will now execute every command that it
    accepts.  Hence there's no need for special code to catch unexecuted
    commands and fail them.
    
    The new sequence of events when disconnect runs goes as follows:
    
            If the device is truly unplugged, set the DISCONNECTING
            flag so we won't try to access it any more.
    
            If the SCSI-scanning thread hasn't started up yet, prevent
            it from doing anything by setting the new DONT_SCAN flag.
            Then wake it up and wait for it to terminate.
    
            Remove the SCSI host.  This unbinds the upper-level drivers,
            doing an orderly shutdown.  Commands sent to quiesce the
            device will be transmitted normally, unless the device is
            unplugged.
    
            Set the DISCONNECTING flag so that we won't accept any new
            commands that might get submitted (there aren't supposed to be
            any) and we won't try to access the device for resets.
    
            Tell the control thread to exit by waking it up with no
            pending command, and wait for it to terminate.
    
            Go on to do all the other normal stuff: releasing resources,
            freeing memory, and so on.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/transport.c b/drivers/usb/storage/transport.c
index 2f88bb958bad..94138df557b9 100644
--- a/drivers/usb/storage/transport.c
+++ b/drivers/usb/storage/transport.c
@@ -127,8 +127,8 @@ static int usb_stor_msg_common(struct us_data *us, int timeout)
 	long timeleft;
 	int status;
 
-	/* don't submit URBs during abort/disconnect processing */
-	if (us-&gt;dflags &amp; ABORTING_OR_DISCONNECTING)
+	/* don't submit URBs during abort processing */
+	if (test_bit(US_FLIDX_ABORTING, &amp;us-&gt;dflags))
 		return -EIO;
 
 	/* set up data structures for the wakeup system */
@@ -161,8 +161,8 @@ static int usb_stor_msg_common(struct us_data *us, int timeout)
 	 * to cancel it */
 	set_bit(US_FLIDX_URB_ACTIVE, &amp;us-&gt;dflags);
 
-	/* did an abort/disconnect occur during the submission? */
-	if (us-&gt;dflags &amp; ABORTING_OR_DISCONNECTING) {
+	/* did an abort occur during the submission? */
+	if (test_bit(US_FLIDX_ABORTING, &amp;us-&gt;dflags)) {
 
 		/* cancel the URB, if it hasn't been cancelled already */
 		if (test_and_clear_bit(US_FLIDX_URB_ACTIVE, &amp;us-&gt;dflags)) {
@@ -419,8 +419,8 @@ static int usb_stor_bulk_transfer_sglist(struct us_data *us, unsigned int pipe,
 {
 	int result;
 
-	/* don't submit s-g requests during abort/disconnect processing */
-	if (us-&gt;dflags &amp; ABORTING_OR_DISCONNECTING)
+	/* don't submit s-g requests during abort processing */
+	if (test_bit(US_FLIDX_ABORTING, &amp;us-&gt;dflags))
 		return USB_STOR_XFER_ERROR;
 
 	/* initialize the scatter-gather request block */
@@ -437,8 +437,8 @@ static int usb_stor_bulk_transfer_sglist(struct us_data *us, unsigned int pipe,
 	 * okay to cancel it */
 	set_bit(US_FLIDX_SG_ACTIVE, &amp;us-&gt;dflags);
 
-	/* did an abort/disconnect occur during the submission? */
-	if (us-&gt;dflags &amp; ABORTING_OR_DISCONNECTING) {
+	/* did an abort occur during the submission? */
+	if (test_bit(US_FLIDX_ABORTING, &amp;us-&gt;dflags)) {
 
 		/* cancel the request, if it hasn't been cancelled already */
 		if (test_and_clear_bit(US_FLIDX_SG_ACTIVE, &amp;us-&gt;dflags)) {
diff --git a/drivers/usb/storage/usb.c b/drivers/usb/storage/usb.c
index 6b14f8d253f1..6bfd99dd57aa 100644
--- a/drivers/usb/storage/usb.c
+++ b/drivers/usb/storage/usb.c
@@ -320,16 +320,17 @@ static int usb_stor_control_thread(void * __us)
 		/* lock the device pointers */
 		mutex_lock(&amp;(us-&gt;dev_mutex));
 
-		/* if the device has disconnected, we are free to exit */
-		if (test_bit(US_FLIDX_DISCONNECTING, &amp;us-&gt;dflags)) {
-			US_DEBUGP("-- exiting\n");
+		/* lock access to the state */
+		scsi_lock(host);
+
+		/* When we are called with no command pending, we're done */
+		if (us-&gt;srb == NULL) {
+			scsi_unlock(host);
 			mutex_unlock(&amp;us-&gt;dev_mutex);
+			US_DEBUGP("-- exiting\n");
 			break;
 		}
 
-		/* lock access to the state */
-		scsi_lock(host);
-
 		/* has the command timed out *already* ? */
 		if (test_bit(US_FLIDX_TIMED_OUT, &amp;us-&gt;dflags)) {
 			us-&gt;srb-&gt;result = DID_ABORT &lt;&lt; 16;
@@ -384,12 +385,8 @@ static int usb_stor_control_thread(void * __us)
 		/* lock access to the state */
 		scsi_lock(host);
 
-		/* did the command already complete because of a disconnect? */
-		if (!us-&gt;srb)
-			;		/* nothing to do */
-
 		/* indicate that the command is done */
-		else if (us-&gt;srb-&gt;result != DID_ABORT &lt;&lt; 16) {
+		if (us-&gt;srb-&gt;result != DID_ABORT &lt;&lt; 16) {
 			US_DEBUGP("scsi cmd done, result=0x%x\n", 
 				   us-&gt;srb-&gt;result);
 			us-&gt;srb-&gt;scsi_done(us-&gt;srb);
@@ -820,11 +817,10 @@ static void usb_stor_release_resources(struct us_data *us)
 	US_DEBUGP("-- %s\n", __func__);
 
 	/* Tell the control thread to exit.  The SCSI host must
-	 * already have been removed so it won't try to queue
-	 * any more commands.
+	 * already have been removed and the DISCONNECTING flag set
+	 * so that we won't accept any more commands.
 	 */
 	US_DEBUGP("-- sending exit command to thread\n");
-	set_bit(US_FLIDX_DISCONNECTING, &amp;us-&gt;dflags);
 	complete(&amp;us-&gt;cmnd_ready);
 	if (us-&gt;ctl_thread)
 		kthread_stop(us-&gt;ctl_thread);
@@ -859,39 +855,36 @@ static void dissociate_dev(struct us_data *us)
 	usb_set_intfdata(us-&gt;pusb_intf, NULL);
 }
 
-/* First stage of disconnect processing: stop all commands and remove
- * the host */
+/* First stage of disconnect processing: stop SCSI scanning,
+ * remove the host, and stop accepting new commands
+ */
 static void quiesce_and_remove_host(struct us_data *us)
 {
 	struct Scsi_Host *host = us_to_host(us);
 
-	/* Prevent new USB transfers, stop the current command, and
-	 * interrupt a SCSI-scan or device-reset delay */
-	scsi_lock(host);
-	set_bit(US_FLIDX_DISCONNECTING, &amp;us-&gt;dflags);
-	scsi_unlock(host);
-	usb_stor_stop_transport(us);
-	wake_up(&amp;us-&gt;delay_wait);
+	/* If the device is really gone, cut short reset delays */
+	if (us-&gt;pusb_dev-&gt;state == USB_STATE_NOTATTACHED)
+		set_bit(US_FLIDX_DISCONNECTING, &amp;us-&gt;dflags);
 
-	/* queuecommand won't accept any new commands and the control
-	 * thread won't execute a previously-queued command.  If there
-	 * is such a command pending, complete it with an error. */
-	mutex_lock(&amp;us-&gt;dev_mutex);
-	if (us-&gt;srb) {
-		us-&gt;srb-&gt;result = DID_NO_CONNECT &lt;&lt; 16;
-		scsi_lock(host);
-		us-&gt;srb-&gt;scsi_done(us-&gt;srb);
-		us-&gt;srb = NULL;
-		complete(&amp;us-&gt;notify);		/* in case of an abort */
-		scsi_unlock(host);
-	}
-	mutex_unlock(&amp;us-&gt;dev_mutex);
+	/* Prevent SCSI-scanning (if it hasn't started yet)
+	 * and wait for the SCSI-scanning thread to stop.
+	 */
+	set_bit(US_FLIDX_DONT_SCAN, &amp;us-&gt;dflags);
+	wake_up(&amp;us-&gt;delay_wait);
+	wait_for_completion(&amp;us-&gt;scanning_done);
 
-	/* Now we own no commands so it's safe to remove the SCSI host */
+	/* Removing the host will perform an orderly shutdown: caches
+	 * synchronized, disks spun down, etc.
+	 */
 	scsi_remove_host(host);
 
-	/* Wait for the SCSI-scanning thread to stop */
-	wait_for_completion(&amp;us-&gt;scanning_done);
+	/* Prevent any new commands from being accepted and cut short
+	 * reset delays.
+	 */
+	scsi_lock(host);
+	set_bit(US_FLIDX_DISCONNECTING, &amp;us-&gt;dflags);
+	scsi_unlock(host);
+	wake_up(&amp;us-&gt;delay_wait);
 }
 
 /* Second stage of disconnect processing: deallocate all resources */
@@ -919,12 +912,12 @@ static int usb_stor_scan_thread(void * __us)
 		printk(KERN_DEBUG "usb-storage: waiting for device "
 				"to settle before scanning\n");
 		wait_event_freezable_timeout(us-&gt;delay_wait,
-				test_bit(US_FLIDX_DISCONNECTING, &amp;us-&gt;dflags),
+				test_bit(US_FLIDX_DONT_SCAN, &amp;us-&gt;dflags),
 				delay_use * HZ);
 	}
 
 	/* If the device is still connected, perform the scanning */
-	if (!test_bit(US_FLIDX_DISCONNECTING, &amp;us-&gt;dflags)) {
+	if (!test_bit(US_FLIDX_DONT_SCAN, &amp;us-&gt;dflags)) {
 
 		/* For bulk-only devices, determine the max LUN value */
 		if (us-&gt;protocol == US_PR_BULK &amp;&amp;
@@ -1023,6 +1016,7 @@ static int storage_probe(struct usb_interface *intf,
 	if (IS_ERR(th)) {
 		printk(KERN_WARNING USB_STORAGE 
 		       "Unable to start the device-scanning thread\n");
+		complete(&amp;us-&gt;scanning_done);
 		quiesce_and_remove_host(us);
 		result = PTR_ERR(th);
 		goto BadDevice;
@@ -1065,6 +1059,7 @@ static struct usb_driver usb_storage_driver = {
 	.pre_reset =	storage_pre_reset,
 	.post_reset =	storage_post_reset,
 	.id_table =	storage_usb_ids,
+	.soft_unbind =	1,
 };
 
 static int __init usb_stor_init(void)
diff --git a/drivers/usb/storage/usb.h b/drivers/usb/storage/usb.h
index 8da96da5875d..47906dc620db 100644
--- a/drivers/usb/storage/usb.h
+++ b/drivers/usb/storage/usb.h
@@ -72,11 +72,9 @@ struct us_unusual_dev {
 #define US_FLIDX_SG_ACTIVE	1	/* current_sg is in use     */
 #define US_FLIDX_ABORTING	2	/* abort is in progress     */
 #define US_FLIDX_DISCONNECTING	3	/* disconnect in progress   */
-#define ABORTING_OR_DISCONNECTING	((1UL &lt;&lt; US_FLIDX_ABORTING) | \
-					 (1UL &lt;&lt; US_FLIDX_DISCONNECTING))
 #define US_FLIDX_RESETTING	4	/* device reset in progress */
 #define US_FLIDX_TIMED_OUT	5	/* SCSI midlayer timed out  */
-
+#define US_FLIDX_DONT_SCAN	6	/* don't scan (disconnect)  */
 
 #define USB_STOR_STRING_LEN 32
 </pre><hr><pre>commit 9da82bd4649334817ef0e752a69eb99051645dad
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu May 8 11:54:37 2008 -0400

    USB: implement "soft" unbinding
    
    This patch (as1091) changes the way usbcore handles interface
    unbinding.  If the interface's driver supports "soft" unbinding (a new
    flag in the driver structure) then in-flight URBs are not cancelled
    and endpoints are not disabled.  Instead the driver is allowed to
    continue communicating with the device (although of course it should
    stop before its disconnect routine returns).
    
    The purpose of this change is to allow drivers to do a clean shutdown
    when they get unbound from a device that is still plugged in.  Killing
    all the URBs and disabling the endpoints before calling the driver's
    disconnect method doesn't give the driver any control over what
    happens, and it can leave devices in indeterminate states.  For
    example, when usb-storage unbinds it doesn't want to stop while in the
    middle of transmitting a SCSI command.
    
    The soft_unbind flag is added because in the past, a number of drivers
    have experienced problems related to ongoing I/O after their disconnect
    routine returned.  Hence "soft" unbinding is made available only to
    drivers that claim to support it.
    
    The patch also replaces "interface_to_usbdev(intf)" with "udev" in a
    couple of places, a minor simplification.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 0a0e8cea0afc..8da1a56659be 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -257,15 +257,16 @@ static int usb_unbind_interface(struct device *dev)
 	udev = interface_to_usbdev(intf);
 	error = usb_autoresume_device(udev);
 
-	/* release all urbs for this interface */
-	usb_disable_interface(interface_to_usbdev(intf), intf);
+	/* Terminate all URBs for this interface unless the driver
+	 * supports "soft" unbinding.
+	 */
+	if (!driver-&gt;soft_unbind)
+		usb_disable_interface(udev, intf);
 
 	driver-&gt;disconnect(intf);
 
 	/* reset other interface state */
-	usb_set_interface(interface_to_usbdev(intf),
-			intf-&gt;altsetting[0].desc.bInterfaceNumber,
-			0);
+	usb_set_interface(udev, intf-&gt;altsetting[0].desc.bInterfaceNumber, 0);
 	usb_set_intfdata(intf, NULL);
 
 	intf-&gt;condition = USB_INTERFACE_UNBOUND;
diff --git a/include/linux/usb.h b/include/linux/usb.h
index cee7fbb2b605..8429d08bd2fd 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -972,6 +972,8 @@ struct usbdrv_wrap {
  *	added to this driver by preventing the sysfs file from being created.
  * @supports_autosuspend: if set to 0, the USB core will not allow autosuspend
  *	for interfaces bound to this driver.
+ * @soft_unbind: if set to 1, the USB core will not kill URBs and disable
+ *	endpoints before calling the driver's disconnect method.
  *
  * USB interface drivers must provide a name, probe() and disconnect()
  * methods, and an id_table.  Other driver fields are optional.
@@ -1012,6 +1014,7 @@ struct usb_driver {
 	struct usbdrv_wrap drvwrap;
 	unsigned int no_dynamic_id:1;
 	unsigned int supports_autosuspend:1;
+	unsigned int soft_unbind:1;
 };
 #define	to_usb_driver(d) container_of(d, struct usb_driver, drvwrap.driver)
 </pre><hr><pre>commit 7119e3c37fbf7c27adb5929f344c826ecb8c7859
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu May 1 15:36:13 2008 -0400

    usb-storage: change remaining semaphore to completion
    
    This patch (as1090) converts the one remaining semaphore in
    usb-storage into a completion.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: Matthew Dharm &lt;mdharm-usb@one-eyed-alien.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 1caf3f7af349..043b60b2ad17 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -248,7 +248,7 @@ static int queuecommand(struct scsi_cmnd *srb,
 	/* enqueue the command and wake up the control thread */
 	srb-&gt;scsi_done = done;
 	us-&gt;srb = srb;
-	up(&amp;(us-&gt;sema));
+	complete(&amp;us-&gt;cmnd_ready);
 
 	return 0;
 }
diff --git a/drivers/usb/storage/usb.c b/drivers/usb/storage/usb.c
index 78c0c7ee6b99..6b14f8d253f1 100644
--- a/drivers/usb/storage/usb.c
+++ b/drivers/usb/storage/usb.c
@@ -312,9 +312,9 @@ static int usb_stor_control_thread(void * __us)
 
 	for(;;) {
 		US_DEBUGP("*** thread sleeping.\n");
-		if(down_interruptible(&amp;us-&gt;sema))
+		if (wait_for_completion_interruptible(&amp;us-&gt;cmnd_ready))
 			break;
-			
+
 		US_DEBUGP("*** thread awakened.\n");
 
 		/* lock the device pointers */
@@ -825,7 +825,7 @@ static void usb_stor_release_resources(struct us_data *us)
 	 */
 	US_DEBUGP("-- sending exit command to thread\n");
 	set_bit(US_FLIDX_DISCONNECTING, &amp;us-&gt;dflags);
-	up(&amp;us-&gt;sema);
+	complete(&amp;us-&gt;cmnd_ready);
 	if (us-&gt;ctl_thread)
 		kthread_stop(us-&gt;ctl_thread);
 
@@ -975,7 +975,7 @@ static int storage_probe(struct usb_interface *intf,
 	us = host_to_us(host);
 	memset(us, 0, sizeof(struct us_data));
 	mutex_init(&amp;(us-&gt;dev_mutex));
-	init_MUTEX_LOCKED(&amp;(us-&gt;sema));
+	init_completion(&amp;us-&gt;cmnd_ready);
 	init_completion(&amp;(us-&gt;notify));
 	init_waitqueue_head(&amp;us-&gt;delay_wait);
 	init_completion(&amp;us-&gt;scanning_done);
diff --git a/drivers/usb/storage/usb.h b/drivers/usb/storage/usb.h
index b169132f021b..8da96da5875d 100644
--- a/drivers/usb/storage/usb.h
+++ b/drivers/usb/storage/usb.h
@@ -148,7 +148,7 @@ struct us_data {
 	struct task_struct	*ctl_thread;	 /* the control thread   */
 
 	/* mutual exclusion and synchronization structures */
-	struct semaphore	sema;		 /* to sleep thread on	    */
+	struct completion	cmnd_ready;	 /* to sleep thread on	    */
 	struct completion	notify;		 /* thread begin/end	    */
 	wait_queue_head_t	delay_wait;	 /* wait during scan, reset */
 	struct completion	scanning_done;	 /* wait for scan thread    */</pre><hr><pre>commit 7e4d6c387994294ac8198b624ee71e75de60dfd2
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu May 1 15:35:18 2008 -0400

    usb-storage: separate dynamic flags from fixed flags
    
    This patch (as1089) separates out the dynamic atomic bitflags and the
    static bitfields in usb-storage.  Until now the two sorts of flags
    have been sharing the same word; this has always been awkward.
    
    To help prevent possible confusion, the two new fields each have a
    different name from the original.  us-&gt;fflags contains the fixed
    bitfields (mostly taken from the USB ID table in unusual_devs.h), and
    us-&gt;dflags contains the dynamic atomic bitflags (used with set_bit,
    test_bit, and so on).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: Matthew Dharm &lt;mdharm-usb@one-eyed-alien.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/isd200.c b/drivers/usb/storage/isd200.c
index 3addcd8f827b..a153335f3648 100644
--- a/drivers/usb/storage/isd200.c
+++ b/drivers/usb/storage/isd200.c
@@ -586,7 +586,7 @@ static void isd200_invoke_transport( struct us_data *us,
 	/* if the command gets aborted by the higher layers, we need to
 	 * short-circuit all other processing
 	 */
-	if (test_bit(US_FLIDX_TIMED_OUT, &amp;us-&gt;flags)) {
+	if (test_bit(US_FLIDX_TIMED_OUT, &amp;us-&gt;dflags)) {
 		US_DEBUGP("-- command was aborted\n");
 		goto Handle_Abort;
 	}
@@ -633,7 +633,7 @@ static void isd200_invoke_transport( struct us_data *us,
 
 	if (need_auto_sense) {
 		result = isd200_read_regs(us);
-		if (test_bit(US_FLIDX_TIMED_OUT, &amp;us-&gt;flags)) {
+		if (test_bit(US_FLIDX_TIMED_OUT, &amp;us-&gt;dflags)) {
 			US_DEBUGP("-- auto-sense aborted\n");
 			goto Handle_Abort;
 		}
@@ -663,7 +663,7 @@ static void isd200_invoke_transport( struct us_data *us,
 	srb-&gt;result = DID_ABORT &lt;&lt; 16;
 
 	/* permit the reset transfer to take place */
-	clear_bit(US_FLIDX_ABORTING, &amp;us-&gt;flags);
+	clear_bit(US_FLIDX_ABORTING, &amp;us-&gt;dflags);
 	/* Need reset here */
 }
 
diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 3fcde9f0fa5f..1caf3f7af349 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -116,10 +116,10 @@ static int slave_configure(struct scsi_device *sdev)
 	 * while others have trouble with more than 64K. At this time we
 	 * are limiting both to 32K (64 sectores).
 	 */
-	if (us-&gt;flags &amp; (US_FL_MAX_SECTORS_64 | US_FL_MAX_SECTORS_MIN)) {
+	if (us-&gt;fflags &amp; (US_FL_MAX_SECTORS_64 | US_FL_MAX_SECTORS_MIN)) {
 		unsigned int max_sectors = 64;
 
-		if (us-&gt;flags &amp; US_FL_MAX_SECTORS_MIN)
+		if (us-&gt;fflags &amp; US_FL_MAX_SECTORS_MIN)
 			max_sectors = PAGE_CACHE_SIZE &gt;&gt; 9;
 		if (sdev-&gt;request_queue-&gt;max_sectors &gt; max_sectors)
 			blk_queue_max_sectors(sdev-&gt;request_queue,
@@ -148,7 +148,7 @@ static int slave_configure(struct scsi_device *sdev)
 		 * majority of devices work fine, but a few still can't
 		 * handle it.  The sd driver will simply assume those
 		 * devices are write-enabled. */
-		if (us-&gt;flags &amp; US_FL_NO_WP_DETECT)
+		if (us-&gt;fflags &amp; US_FL_NO_WP_DETECT)
 			sdev-&gt;skip_ms_page_3f = 1;
 
 		/* A number of devices have problems with MODE SENSE for
@@ -158,13 +158,13 @@ static int slave_configure(struct scsi_device *sdev)
 		/* Some disks return the total number of blocks in response
 		 * to READ CAPACITY rather than the highest block number.
 		 * If this device makes that mistake, tell the sd driver. */
-		if (us-&gt;flags &amp; US_FL_FIX_CAPACITY)
+		if (us-&gt;fflags &amp; US_FL_FIX_CAPACITY)
 			sdev-&gt;fix_capacity = 1;
 
 		/* A few disks have two indistinguishable version, one of
 		 * which reports the correct capacity and the other does not.
 		 * The sd driver has to guess which is the case. */
-		if (us-&gt;flags &amp; US_FL_CAPACITY_HEURISTICS)
+		if (us-&gt;fflags &amp; US_FL_CAPACITY_HEURISTICS)
 			sdev-&gt;guess_capacity = 1;
 
 		/* Some devices report a SCSI revision level above 2 but are
@@ -213,7 +213,7 @@ static int slave_configure(struct scsi_device *sdev)
 
 	/* Some devices choke when they receive a PREVENT-ALLOW MEDIUM
 	 * REMOVAL command, so suppress those commands. */
-	if (us-&gt;flags &amp; US_FL_NOT_LOCKABLE)
+	if (us-&gt;fflags &amp; US_FL_NOT_LOCKABLE)
 		sdev-&gt;lockable = 0;
 
 	/* this is to satisfy the compiler, tho I don't think the 
@@ -238,7 +238,7 @@ static int queuecommand(struct scsi_cmnd *srb,
 	}
 
 	/* fail the command if we are disconnecting */
-	if (test_bit(US_FLIDX_DISCONNECTING, &amp;us-&gt;flags)) {
+	if (test_bit(US_FLIDX_DISCONNECTING, &amp;us-&gt;dflags)) {
 		US_DEBUGP("Fail command during disconnect\n");
 		srb-&gt;result = DID_NO_CONNECT &lt;&lt; 16;
 		done(srb);
@@ -280,9 +280,9 @@ static int command_abort(struct scsi_cmnd *srb)
 	 * with the reset).  Note that we must retain the host lock while
 	 * calling usb_stor_stop_transport(); otherwise it might interfere
 	 * with an auto-reset that begins as soon as we release the lock. */
-	set_bit(US_FLIDX_TIMED_OUT, &amp;us-&gt;flags);
-	if (!test_bit(US_FLIDX_RESETTING, &amp;us-&gt;flags)) {
-		set_bit(US_FLIDX_ABORTING, &amp;us-&gt;flags);
+	set_bit(US_FLIDX_TIMED_OUT, &amp;us-&gt;dflags);
+	if (!test_bit(US_FLIDX_RESETTING, &amp;us-&gt;dflags)) {
+		set_bit(US_FLIDX_ABORTING, &amp;us-&gt;dflags);
 		usb_stor_stop_transport(us);
 	}
 	scsi_unlock(us_to_host(us));
@@ -329,7 +329,7 @@ void usb_stor_report_device_reset(struct us_data *us)
 	struct Scsi_Host *host = us_to_host(us);
 
 	scsi_report_device_reset(host, 0, 0);
-	if (us-&gt;flags &amp; US_FL_SCM_MULT_TARG) {
+	if (us-&gt;fflags &amp; US_FL_SCM_MULT_TARG) {
 		for (i = 1; i &lt; host-&gt;max_id; ++i)
 			scsi_report_device_reset(host, 0, i);
 	}
@@ -400,7 +400,7 @@ static int proc_info (struct Scsi_Host *host, char *buffer,
 		pos += sprintf(pos, "       Quirks:");
 
 #define US_FLAG(name, value) \
-	if (us-&gt;flags &amp; value) pos += sprintf(pos, " " #name);
+	if (us-&gt;fflags &amp; value) pos += sprintf(pos, " " #name);
 US_DO_ALL_FLAGS
 #undef US_FLAG
 
diff --git a/drivers/usb/storage/transport.c b/drivers/usb/storage/transport.c
index 6610d2dd1e7f..2f88bb958bad 100644
--- a/drivers/usb/storage/transport.c
+++ b/drivers/usb/storage/transport.c
@@ -75,14 +75,14 @@
  * by a separate code path.)
  *
  * The abort function (usb_storage_command_abort() in scsiglue.c) first
- * sets the machine state and the ABORTING bit in us-&gt;flags to prevent
+ * sets the machine state and the ABORTING bit in us-&gt;dflags to prevent
  * new URBs from being submitted.  It then calls usb_stor_stop_transport()
- * below, which atomically tests-and-clears the URB_ACTIVE bit in us-&gt;flags
+ * below, which atomically tests-and-clears the URB_ACTIVE bit in us-&gt;dflags
  * to see if the current_urb needs to be stopped.  Likewise, the SG_ACTIVE
  * bit is tested to see if the current_sg scatter-gather request needs to be
  * stopped.  The timeout callback routine does much the same thing.
  *
- * When a disconnect occurs, the DISCONNECTING bit in us-&gt;flags is set to
+ * When a disconnect occurs, the DISCONNECTING bit in us-&gt;dflags is set to
  * prevent new URBs from being submitted, and usb_stor_stop_transport() is
  * called to stop any ongoing requests.
  *
@@ -128,7 +128,7 @@ static int usb_stor_msg_common(struct us_data *us, int timeout)
 	int status;
 
 	/* don't submit URBs during abort/disconnect processing */
-	if (us-&gt;flags &amp; ABORTING_OR_DISCONNECTING)
+	if (us-&gt;dflags &amp; ABORTING_OR_DISCONNECTING)
 		return -EIO;
 
 	/* set up data structures for the wakeup system */
@@ -159,13 +159,13 @@ static int usb_stor_msg_common(struct us_data *us, int timeout)
 
 	/* since the URB has been submitted successfully, it's now okay
 	 * to cancel it */
-	set_bit(US_FLIDX_URB_ACTIVE, &amp;us-&gt;flags);
+	set_bit(US_FLIDX_URB_ACTIVE, &amp;us-&gt;dflags);
 
 	/* did an abort/disconnect occur during the submission? */
-	if (us-&gt;flags &amp; ABORTING_OR_DISCONNECTING) {
+	if (us-&gt;dflags &amp; ABORTING_OR_DISCONNECTING) {
 
 		/* cancel the URB, if it hasn't been cancelled already */
-		if (test_and_clear_bit(US_FLIDX_URB_ACTIVE, &amp;us-&gt;flags)) {
+		if (test_and_clear_bit(US_FLIDX_URB_ACTIVE, &amp;us-&gt;dflags)) {
 			US_DEBUGP("-- cancelling URB\n");
 			usb_unlink_urb(us-&gt;current_urb);
 		}
@@ -175,7 +175,7 @@ static int usb_stor_msg_common(struct us_data *us, int timeout)
 	timeleft = wait_for_completion_interruptible_timeout(
 			&amp;urb_done, timeout ? : MAX_SCHEDULE_TIMEOUT);
  
-	clear_bit(US_FLIDX_URB_ACTIVE, &amp;us-&gt;flags);
+	clear_bit(US_FLIDX_URB_ACTIVE, &amp;us-&gt;dflags);
 
 	if (timeleft &lt;= 0) {
 		US_DEBUGP("%s -- cancelling URB\n",
@@ -420,7 +420,7 @@ static int usb_stor_bulk_transfer_sglist(struct us_data *us, unsigned int pipe,
 	int result;
 
 	/* don't submit s-g requests during abort/disconnect processing */
-	if (us-&gt;flags &amp; ABORTING_OR_DISCONNECTING)
+	if (us-&gt;dflags &amp; ABORTING_OR_DISCONNECTING)
 		return USB_STOR_XFER_ERROR;
 
 	/* initialize the scatter-gather request block */
@@ -435,13 +435,13 @@ static int usb_stor_bulk_transfer_sglist(struct us_data *us, unsigned int pipe,
 
 	/* since the block has been initialized successfully, it's now
 	 * okay to cancel it */
-	set_bit(US_FLIDX_SG_ACTIVE, &amp;us-&gt;flags);
+	set_bit(US_FLIDX_SG_ACTIVE, &amp;us-&gt;dflags);
 
 	/* did an abort/disconnect occur during the submission? */
-	if (us-&gt;flags &amp; ABORTING_OR_DISCONNECTING) {
+	if (us-&gt;dflags &amp; ABORTING_OR_DISCONNECTING) {
 
 		/* cancel the request, if it hasn't been cancelled already */
-		if (test_and_clear_bit(US_FLIDX_SG_ACTIVE, &amp;us-&gt;flags)) {
+		if (test_and_clear_bit(US_FLIDX_SG_ACTIVE, &amp;us-&gt;dflags)) {
 			US_DEBUGP("-- cancelling sg request\n");
 			usb_sg_cancel(&amp;us-&gt;current_sg);
 		}
@@ -449,7 +449,7 @@ static int usb_stor_bulk_transfer_sglist(struct us_data *us, unsigned int pipe,
 
 	/* wait for the completion of the transfer */
 	usb_sg_wait(&amp;us-&gt;current_sg);
-	clear_bit(US_FLIDX_SG_ACTIVE, &amp;us-&gt;flags);
+	clear_bit(US_FLIDX_SG_ACTIVE, &amp;us-&gt;dflags);
 
 	result = us-&gt;current_sg.status;
 	if (act_len)
@@ -530,7 +530,7 @@ void usb_stor_invoke_transport(struct scsi_cmnd *srb, struct us_data *us)
 	/* if the command gets aborted by the higher layers, we need to
 	 * short-circuit all other processing
 	 */
-	if (test_bit(US_FLIDX_TIMED_OUT, &amp;us-&gt;flags)) {
+	if (test_bit(US_FLIDX_TIMED_OUT, &amp;us-&gt;dflags)) {
 		US_DEBUGP("-- command was aborted\n");
 		srb-&gt;result = DID_ABORT &lt;&lt; 16;
 		goto Handle_Errors;
@@ -616,7 +616,7 @@ void usb_stor_invoke_transport(struct scsi_cmnd *srb, struct us_data *us)
 		/* let's clean up right away */
 		scsi_eh_restore_cmnd(srb, &amp;ses);
 
-		if (test_bit(US_FLIDX_TIMED_OUT, &amp;us-&gt;flags)) {
+		if (test_bit(US_FLIDX_TIMED_OUT, &amp;us-&gt;dflags)) {
 			US_DEBUGP("-- auto-sense aborted\n");
 			srb-&gt;result = DID_ABORT &lt;&lt; 16;
 			goto Handle_Errors;
@@ -629,7 +629,7 @@ void usb_stor_invoke_transport(struct scsi_cmnd *srb, struct us_data *us)
 			 * auto-sense is perfectly valid
 			 */
 			srb-&gt;result = DID_ERROR &lt;&lt; 16;
-			if (!(us-&gt;flags &amp; US_FL_SCM_MULT_TARG))
+			if (!(us-&gt;fflags &amp; US_FL_SCM_MULT_TARG))
 				goto Handle_Errors;
 			return;
 		}
@@ -679,8 +679,8 @@ void usb_stor_invoke_transport(struct scsi_cmnd *srb, struct us_data *us)
 	/* Set the RESETTING bit, and clear the ABORTING bit so that
 	 * the reset may proceed. */
 	scsi_lock(us_to_host(us));
-	set_bit(US_FLIDX_RESETTING, &amp;us-&gt;flags);
-	clear_bit(US_FLIDX_ABORTING, &amp;us-&gt;flags);
+	set_bit(US_FLIDX_RESETTING, &amp;us-&gt;dflags);
+	clear_bit(US_FLIDX_ABORTING, &amp;us-&gt;dflags);
 	scsi_unlock(us_to_host(us));
 
 	/* We must release the device lock because the pre_reset routine
@@ -695,7 +695,7 @@ void usb_stor_invoke_transport(struct scsi_cmnd *srb, struct us_data *us)
 		scsi_unlock(us_to_host(us));
 		us-&gt;transport_reset(us);
 	}
-	clear_bit(US_FLIDX_RESETTING, &amp;us-&gt;flags);
+	clear_bit(US_FLIDX_RESETTING, &amp;us-&gt;dflags);
 }
 
 /* Stop the current URB transfer */
@@ -707,13 +707,13 @@ void usb_stor_stop_transport(struct us_data *us)
 	 * let's wake it up.  The test_and_clear_bit() call
 	 * guarantees that if a URB has just been submitted,
 	 * it won't be cancelled more than once. */
-	if (test_and_clear_bit(US_FLIDX_URB_ACTIVE, &amp;us-&gt;flags)) {
+	if (test_and_clear_bit(US_FLIDX_URB_ACTIVE, &amp;us-&gt;dflags)) {
 		US_DEBUGP("-- cancelling URB\n");
 		usb_unlink_urb(us-&gt;current_urb);
 	}
 
 	/* If we are waiting for a scatter-gather operation, cancel it. */
-	if (test_and_clear_bit(US_FLIDX_SG_ACTIVE, &amp;us-&gt;flags)) {
+	if (test_and_clear_bit(US_FLIDX_SG_ACTIVE, &amp;us-&gt;dflags)) {
 		US_DEBUGP("-- cancelling sg request\n");
 		usb_sg_cancel(&amp;us-&gt;current_sg);
 	}
@@ -914,7 +914,7 @@ int usb_stor_Bulk_transport(struct scsi_cmnd *srb, struct us_data *us)
 	unsigned int cbwlen = US_BULK_CB_WRAP_LEN;
 
 	/* Take care of BULK32 devices; set extra byte to 0 */
-	if ( unlikely(us-&gt;flags &amp; US_FL_BULK32)) {
+	if (unlikely(us-&gt;fflags &amp; US_FL_BULK32)) {
 		cbwlen = 32;
 		us-&gt;iobuf[31] = 0;
 	}
@@ -925,7 +925,7 @@ int usb_stor_Bulk_transport(struct scsi_cmnd *srb, struct us_data *us)
 	bcb-&gt;Flags = srb-&gt;sc_data_direction == DMA_FROM_DEVICE ? 1 &lt;&lt; 7 : 0;
 	bcb-&gt;Tag = ++us-&gt;tag;
 	bcb-&gt;Lun = srb-&gt;device-&gt;lun;
-	if (us-&gt;flags &amp; US_FL_SCM_MULT_TARG)
+	if (us-&gt;fflags &amp; US_FL_SCM_MULT_TARG)
 		bcb-&gt;Lun |= srb-&gt;device-&gt;id &lt;&lt; 4;
 	bcb-&gt;Length = srb-&gt;cmd_len;
 
@@ -951,7 +951,7 @@ int usb_stor_Bulk_transport(struct scsi_cmnd *srb, struct us_data *us)
 	/* Some USB-IDE converter chips need a 100us delay between the
 	 * command phase and the data phase.  Some devices need a little
 	 * more than that, probably because of clock rate inaccuracies. */
-	if (unlikely(us-&gt;flags &amp; US_FL_GO_SLOW))
+	if (unlikely(us-&gt;fflags &amp; US_FL_GO_SLOW))
 		udelay(125);
 
 	if (transfer_length) {
@@ -1010,7 +1010,7 @@ int usb_stor_Bulk_transport(struct scsi_cmnd *srb, struct us_data *us)
 	US_DEBUGP("Bulk Status S 0x%x T 0x%x R %u Stat 0x%x\n",
 			le32_to_cpu(bcs-&gt;Signature), bcs-&gt;Tag, 
 			residue, bcs-&gt;Status);
-	if (!(bcs-&gt;Tag == us-&gt;tag || (us-&gt;flags &amp; US_FL_BULK_IGNORE_TAG)) ||
+	if (!(bcs-&gt;Tag == us-&gt;tag || (us-&gt;fflags &amp; US_FL_BULK_IGNORE_TAG)) ||
 		bcs-&gt;Status &gt; US_BULK_STAT_PHASE) {
 		US_DEBUGP("Bulk logical error\n");
 		return USB_STOR_TRANSPORT_ERROR;
@@ -1035,7 +1035,7 @@ int usb_stor_Bulk_transport(struct scsi_cmnd *srb, struct us_data *us)
 	/* try to compute the actual residue, based on how much data
 	 * was really transferred and what the device tells us */
 	if (residue) {
-		if (!(us-&gt;flags &amp; US_FL_IGNORE_RESIDUE)) {
+		if (!(us-&gt;fflags &amp; US_FL_IGNORE_RESIDUE)) {
 			residue = min(residue, transfer_length);
 			scsi_set_resid(srb, max(scsi_get_resid(srb),
 			                                       (int) residue));
@@ -1090,7 +1090,7 @@ static int usb_stor_reset_common(struct us_data *us,
 	int result;
 	int result2;
 
-	if (test_bit(US_FLIDX_DISCONNECTING, &amp;us-&gt;flags)) {
+	if (test_bit(US_FLIDX_DISCONNECTING, &amp;us-&gt;dflags)) {
 		US_DEBUGP("No reset during disconnect\n");
 		return -EIO;
 	}
@@ -1103,12 +1103,12 @@ static int usb_stor_reset_common(struct us_data *us,
 		return result;
 	}
 
- 	/* Give the device some time to recover from the reset,
- 	 * but don't delay disconnect processing. */
- 	wait_event_interruptible_timeout(us-&gt;delay_wait,
- 			test_bit(US_FLIDX_DISCONNECTING, &amp;us-&gt;flags),
- 			HZ*6);
-	if (test_bit(US_FLIDX_DISCONNECTING, &amp;us-&gt;flags)) {
+	/* Give the device some time to recover from the reset,
+	 * but don't delay disconnect processing. */
+	wait_event_interruptible_timeout(us-&gt;delay_wait,
+			test_bit(US_FLIDX_DISCONNECTING, &amp;us-&gt;dflags),
+			HZ*6);
+	if (test_bit(US_FLIDX_DISCONNECTING, &amp;us-&gt;dflags)) {
 		US_DEBUGP("Reset interrupted by disconnect\n");
 		return -EIO;
 	}
@@ -1170,7 +1170,7 @@ int usb_stor_port_reset(struct us_data *us)
 		US_DEBUGP("unable to lock device for reset: %d\n", result);
 	else {
 		/* Were we disconnected while waiting for the lock? */
-		if (test_bit(US_FLIDX_DISCONNECTING, &amp;us-&gt;flags)) {
+		if (test_bit(US_FLIDX_DISCONNECTING, &amp;us-&gt;dflags)) {
 			result = -EIO;
 			US_DEBUGP("No reset during disconnect\n");
 		} else {
diff --git a/drivers/usb/storage/usb.c b/drivers/usb/storage/usb.c
index e268aacb773a..78c0c7ee6b99 100644
--- a/drivers/usb/storage/usb.c
+++ b/drivers/usb/storage/usb.c
@@ -321,7 +321,7 @@ static int usb_stor_control_thread(void * __us)
 		mutex_lock(&amp;(us-&gt;dev_mutex));
 
 		/* if the device has disconnected, we are free to exit */
-		if (test_bit(US_FLIDX_DISCONNECTING, &amp;us-&gt;flags)) {
+		if (test_bit(US_FLIDX_DISCONNECTING, &amp;us-&gt;dflags)) {
 			US_DEBUGP("-- exiting\n");
 			mutex_unlock(&amp;us-&gt;dev_mutex);
 			break;
@@ -331,7 +331,7 @@ static int usb_stor_control_thread(void * __us)
 		scsi_lock(host);
 
 		/* has the command timed out *already* ? */
-		if (test_bit(US_FLIDX_TIMED_OUT, &amp;us-&gt;flags)) {
+		if (test_bit(US_FLIDX_TIMED_OUT, &amp;us-&gt;dflags)) {
 			us-&gt;srb-&gt;result = DID_ABORT &lt;&lt; 16;
 			goto SkipForAbort;
 		}
@@ -350,7 +350,7 @@ static int usb_stor_control_thread(void * __us)
 		 * the maximum known LUN
 		 */
 		else if (us-&gt;srb-&gt;device-&gt;id &amp;&amp; 
-				!(us-&gt;flags &amp; US_FL_SCM_MULT_TARG)) {
+				!(us-&gt;fflags &amp; US_FL_SCM_MULT_TARG)) {
 			US_DEBUGP("Bad target number (%d:%d)\n",
 				  us-&gt;srb-&gt;device-&gt;id, us-&gt;srb-&gt;device-&gt;lun);
 			us-&gt;srb-&gt;result = DID_BAD_TARGET &lt;&lt; 16;
@@ -365,7 +365,7 @@ static int usb_stor_control_thread(void * __us)
 		/* Handle those devices which need us to fake 
 		 * their inquiry data */
 		else if ((us-&gt;srb-&gt;cmnd[0] == INQUIRY) &amp;&amp;
-			    (us-&gt;flags &amp; US_FL_FIX_INQUIRY)) {
+			    (us-&gt;fflags &amp; US_FL_FIX_INQUIRY)) {
 			unsigned char data_ptr[36] = {
 			    0x00, 0x80, 0x02, 0x02,
 			    0x1F, 0x00, 0x00, 0x00};
@@ -403,12 +403,12 @@ static int usb_stor_control_thread(void * __us)
 		 * the TIMED_OUT flag, not srb-&gt;result == DID_ABORT, because
 		 * the timeout might have occurred after the command had
 		 * already completed with a different result code. */
-		if (test_bit(US_FLIDX_TIMED_OUT, &amp;us-&gt;flags)) {
+		if (test_bit(US_FLIDX_TIMED_OUT, &amp;us-&gt;dflags)) {
 			complete(&amp;(us-&gt;notify));
 
 			/* Allow USB transfers to resume */
-			clear_bit(US_FLIDX_ABORTING, &amp;us-&gt;flags);
-			clear_bit(US_FLIDX_TIMED_OUT, &amp;us-&gt;flags);
+			clear_bit(US_FLIDX_ABORTING, &amp;us-&gt;dflags);
+			clear_bit(US_FLIDX_TIMED_OUT, &amp;us-&gt;dflags);
 		}
 
 		/* finished working on this command */
@@ -500,9 +500,9 @@ static int get_device_info(struct us_data *us, const struct usb_device_id *id)
 	us-&gt;protocol = (unusual_dev-&gt;useTransport == US_PR_DEVICE) ?
 			idesc-&gt;bInterfaceProtocol :
 			unusual_dev-&gt;useTransport;
-	us-&gt;flags = USB_US_ORIG_FLAGS(id-&gt;driver_info);
+	us-&gt;fflags = USB_US_ORIG_FLAGS(id-&gt;driver_info);
 
-	if (us-&gt;flags &amp; US_FL_IGNORE_DEVICE) {
+	if (us-&gt;fflags &amp; US_FL_IGNORE_DEVICE) {
 		printk(KERN_INFO USB_STORAGE "device ignored\n");
 		return -ENODEV;
 	}
@@ -512,7 +512,7 @@ static int get_device_info(struct us_data *us, const struct usb_device_id *id)
 	 * disable it if we're in full-speed
 	 */
 	if (dev-&gt;speed != USB_SPEED_HIGH)
-		us-&gt;flags &amp;= ~US_FL_GO_SLOW;
+		us-&gt;fflags &amp;= ~US_FL_GO_SLOW;
 
 	/* Log a message if a non-generic unusual_dev entry contains an
 	 * unnecessary subclass or protocol override.  This may stimulate
@@ -533,7 +533,7 @@ static int get_device_info(struct us_data *us, const struct usb_device_id *id)
 		if (unusual_dev-&gt;useTransport != US_PR_DEVICE &amp;&amp;
 			us-&gt;protocol == idesc-&gt;bInterfaceProtocol)
 			msg += 2;
-		if (msg &gt;= 0 &amp;&amp; !(us-&gt;flags &amp; US_FL_NEED_OVERRIDE))
+		if (msg &gt;= 0 &amp;&amp; !(us-&gt;fflags &amp; US_FL_NEED_OVERRIDE))
 			printk(KERN_NOTICE USB_STORAGE "This device "
 				"(%04x,%04x,%04x S %02x P %02x)"
 				" has %s in unusual_devs.h (kernel"
@@ -663,7 +663,7 @@ static int get_transport(struct us_data *us)
 	US_DEBUGP("Transport: %s\n", us-&gt;transport_name);
 
 	/* fix for single-lun devices */
-	if (us-&gt;flags &amp; US_FL_SINGLE_LUN)
+	if (us-&gt;fflags &amp; US_FL_SINGLE_LUN)
 		us-&gt;max_lun = 0;
 	return 0;
 }
@@ -824,7 +824,7 @@ static void usb_stor_release_resources(struct us_data *us)
 	 * any more commands.
 	 */
 	US_DEBUGP("-- sending exit command to thread\n");
-	set_bit(US_FLIDX_DISCONNECTING, &amp;us-&gt;flags);
+	set_bit(US_FLIDX_DISCONNECTING, &amp;us-&gt;dflags);
 	up(&amp;us-&gt;sema);
 	if (us-&gt;ctl_thread)
 		kthread_stop(us-&gt;ctl_thread);
@@ -868,7 +868,7 @@ static void quiesce_and_remove_host(struct us_data *us)
 	/* Prevent new USB transfers, stop the current command, and
 	 * interrupt a SCSI-scan or device-reset delay */
 	scsi_lock(host);
-	set_bit(US_FLIDX_DISCONNECTING, &amp;us-&gt;flags);
+	set_bit(US_FLIDX_DISCONNECTING, &amp;us-&gt;dflags);
 	scsi_unlock(host);
 	usb_stor_stop_transport(us);
 	wake_up(&amp;us-&gt;delay_wait);
@@ -919,16 +919,16 @@ static int usb_stor_scan_thread(void * __us)
 		printk(KERN_DEBUG "usb-storage: waiting for device "
 				"to settle before scanning\n");
 		wait_event_freezable_timeout(us-&gt;delay_wait,
-				test_bit(US_FLIDX_DISCONNECTING, &amp;us-&gt;flags),
+				test_bit(US_FLIDX_DISCONNECTING, &amp;us-&gt;dflags),
 				delay_use * HZ);
 	}
 
 	/* If the device is still connected, perform the scanning */
-	if (!test_bit(US_FLIDX_DISCONNECTING, &amp;us-&gt;flags)) {
+	if (!test_bit(US_FLIDX_DISCONNECTING, &amp;us-&gt;dflags)) {
 
 		/* For bulk-only devices, determine the max LUN value */
 		if (us-&gt;protocol == US_PR_BULK &amp;&amp;
-				!(us-&gt;flags &amp; US_FL_SINGLE_LUN)) {
+				!(us-&gt;fflags &amp; US_FL_SINGLE_LUN)) {
 			mutex_lock(&amp;us-&gt;dev_mutex);
 			us-&gt;max_lun = usb_stor_Bulk_max_lun(us);
 			mutex_unlock(&amp;us-&gt;dev_mutex);
diff --git a/drivers/usb/storage/usb.h b/drivers/usb/storage/usb.h
index 8d87503e2560..b169132f021b 100644
--- a/drivers/usb/storage/usb.h
+++ b/drivers/usb/storage/usb.h
@@ -67,15 +67,15 @@ struct us_unusual_dev {
 };
 
 
-/* Dynamic flag definitions: used in set_bit() etc. */
-#define US_FLIDX_URB_ACTIVE	18  /* 0x00040000  current_urb is in use  */
-#define US_FLIDX_SG_ACTIVE	19  /* 0x00080000  current_sg is in use   */
-#define US_FLIDX_ABORTING	20  /* 0x00100000  abort is in progress   */
-#define US_FLIDX_DISCONNECTING	21  /* 0x00200000  disconnect in progress */
+/* Dynamic bitflag definitions (us-&gt;dflags): used in set_bit() etc. */
+#define US_FLIDX_URB_ACTIVE	0	/* current_urb is in use    */
+#define US_FLIDX_SG_ACTIVE	1	/* current_sg is in use     */
+#define US_FLIDX_ABORTING	2	/* abort is in progress     */
+#define US_FLIDX_DISCONNECTING	3	/* disconnect in progress   */
 #define ABORTING_OR_DISCONNECTING	((1UL &lt;&lt; US_FLIDX_ABORTING) | \
 					 (1UL &lt;&lt; US_FLIDX_DISCONNECTING))
-#define US_FLIDX_RESETTING	22  /* 0x00400000  device reset in progress */
-#define US_FLIDX_TIMED_OUT	23  /* 0x00800000  SCSI midlayer timed out  */
+#define US_FLIDX_RESETTING	4	/* device reset in progress */
+#define US_FLIDX_TIMED_OUT	5	/* SCSI midlayer timed out  */
 
 
 #define USB_STOR_STRING_LEN 32
@@ -109,7 +109,8 @@ struct us_data {
 	struct usb_device	*pusb_dev;	 /* this usb_device */
 	struct usb_interface	*pusb_intf;	 /* this interface */
 	struct us_unusual_dev   *unusual_dev;	 /* device-filter entry     */
-	unsigned long		flags;		 /* from filter initially */
+	unsigned long		fflags;		 /* fixed flags from filter */
+	unsigned long		dflags;		 /* dynamic atomic bitflags */
 	unsigned int		send_bulk_pipe;	 /* cached pipe values */
 	unsigned int		recv_bulk_pipe;
 	unsigned int		send_ctrl_pipe;</pre>
    <div class="pagination">
        <a href='2_89.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><span>[90]</span><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_91.html'>Next&gt;&gt;</a>
    <div>
</body>
